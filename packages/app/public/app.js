var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x3) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x3, {
  get: (a2, b2) => (typeof require !== "undefined" ? require : a2)[b2]
}) : x3)(function(x3) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x3 + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb2, mod) => function __require2() {
  return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/maths/point/Point.mjs
var Point, tempPoint;
var init_Point = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/maths/point/Point.mjs"() {
    Point = class _Point {
      /**
       * Creates a new `Point`
       * @param {number} [x=0] - position of the point on the x axis
       * @param {number} [y=0] - position of the point on the y axis
       */
      constructor(x3 = 0, y2 = 0) {
        this.x = 0;
        this.y = 0;
        this.x = x3;
        this.y = y2;
      }
      /**
       * Creates a clone of this point
       * @returns A clone of this point
       */
      clone() {
        return new _Point(this.x, this.y);
      }
      /**
       * Copies `x` and `y` from the given point into this point
       * @param p - The point to copy from
       * @returns The point instance itself
       */
      copyFrom(p3) {
        this.set(p3.x, p3.y);
        return this;
      }
      /**
       * Copies this point's x and y into the given point (`p`).
       * @param p - The point to copy to. Can be any of type that is or extends `PointData`
       * @returns The point (`p`) with values updated
       */
      copyTo(p3) {
        p3.set(this.x, this.y);
        return p3;
      }
      /**
       * Accepts another point (`p`) and returns `true` if the given point is equal to this point
       * @param p - The point to check
       * @returns Returns `true` if both `x` and `y` are equal
       */
      equals(p3) {
        return p3.x === this.x && p3.y === this.y;
      }
      /**
       * Sets the point to a new `x` and `y` position.
       * If `y` is omitted, both `x` and `y` will be set to `x`.
       * @param {number} [x=0] - position of the point on the `x` axis
       * @param {number} [y=x] - position of the point on the `y` axis
       * @returns The point instance itself
       */
      set(x3 = 0, y2 = x3) {
        this.x = x3;
        this.y = y2;
        return this;
      }
      toString() {
        return `[@pixi/math:Point x=${this.x} y=${this.y}]`;
      }
      static get shared() {
        tempPoint.x = 0;
        tempPoint.y = 0;
        return tempPoint;
      }
    };
    tempPoint = new Point();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/events/FederatedEvent.mjs
var FederatedEvent;
var init_FederatedEvent = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/events/FederatedEvent.mjs"() {
    init_Point();
    FederatedEvent = class _FederatedEvent {
      /**
       * @param manager - The event boundary which manages this event. Propagation can only occur
       *  within the boundary's jurisdiction.
       */
      constructor(manager) {
        this.bubbles = true;
        this.cancelBubble = true;
        this.cancelable = false;
        this.composed = false;
        this.defaultPrevented = false;
        this.eventPhase = _FederatedEvent.prototype.NONE;
        this.propagationStopped = false;
        this.propagationImmediatelyStopped = false;
        this.layer = new Point();
        this.page = new Point();
        this.NONE = 0;
        this.CAPTURING_PHASE = 1;
        this.AT_TARGET = 2;
        this.BUBBLING_PHASE = 3;
        this.manager = manager;
      }
      /** @readonly */
      get layerX() {
        return this.layer.x;
      }
      /** @readonly */
      get layerY() {
        return this.layer.y;
      }
      /** @readonly */
      get pageX() {
        return this.page.x;
      }
      /** @readonly */
      get pageY() {
        return this.page.y;
      }
      /**
       * Fallback for the deprecated @code{InteractionEvent.data}.
       * @deprecated since 7.0.0
       */
      get data() {
        return this;
      }
      /** The propagation path for this event. Alias for {@link EventBoundary.propagationPath}. */
      composedPath() {
        if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
          this.path = this.target ? this.manager.propagationPath(this.target) : [];
        }
        return this.path;
      }
      /**
       * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw an {@code Error}.
       * @deprecated
       * @param _type
       * @param _bubbles
       * @param _cancelable
       */
      initEvent(_type, _bubbles, _cancelable) {
        throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
      }
      /**
       * Unimplemented method included for implementing the DOM interface {@code UIEvent}. It will throw an {@code Error}.
       * @deprecated
       * @param _typeArg
       * @param _bubblesArg
       * @param _cancelableArg
       * @param _viewArg
       * @param _detailArg
       */
      initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
        throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
      }
      /** Prevent default behavior of PixiJS and the user agent. */
      preventDefault() {
        if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
          this.nativeEvent.preventDefault();
        }
        this.defaultPrevented = true;
      }
      /**
       * Stop this event from propagating to any addition listeners, including on the
       * {@link FederatedEventTarget.currentTarget currentTarget} and also the following
       * event targets on the propagation path.
       */
      stopImmediatePropagation() {
        this.propagationImmediatelyStopped = true;
      }
      /**
       * Stop this event from propagating to the next {@link FederatedEventTarget}. The rest of the listeners
       * on the {@link FederatedEventTarget.currentTarget currentTarget} will still be notified.
       */
      stopPropagation() {
        this.propagationStopped = true;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/extensions/Extensions.mjs
var ExtensionType, normalizeExtension, normalizeExtensionPriority, extensions;
var init_Extensions = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/extensions/Extensions.mjs"() {
    ExtensionType = /* @__PURE__ */ ((ExtensionType22) => {
      ExtensionType22["Renderer"] = "renderer";
      ExtensionType22["Application"] = "application";
      ExtensionType22["WebGLPipes"] = "webgl-pipes";
      ExtensionType22["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";
      ExtensionType22["WebGLSystem"] = "webgl-system";
      ExtensionType22["WebGPUPipes"] = "webgpu-pipes";
      ExtensionType22["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";
      ExtensionType22["WebGPUSystem"] = "webgpu-system";
      ExtensionType22["CanvasSystem"] = "canvas-system";
      ExtensionType22["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";
      ExtensionType22["CanvasPipes"] = "canvas-pipes";
      ExtensionType22["Asset"] = "asset";
      ExtensionType22["LoadParser"] = "load-parser";
      ExtensionType22["ResolveParser"] = "resolve-parser";
      ExtensionType22["CacheParser"] = "cache-parser";
      ExtensionType22["DetectionParser"] = "detection-parser";
      ExtensionType22["MaskEffect"] = "mask-effect";
      return ExtensionType22;
    })(ExtensionType || {});
    normalizeExtension = (ext) => {
      if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
        if (!ext.extension) {
          throw new Error("Extension class must have an extension object");
        }
        const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
        ext = { ...metadata, ref: ext };
      }
      if (typeof ext === "object") {
        ext = { ...ext };
      } else {
        throw new Error("Invalid extension type");
      }
      if (typeof ext.type === "string") {
        ext.type = [ext.type];
      }
      return ext;
    };
    normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;
    extensions = {
      /** @ignore */
      _addHandlers: {},
      /** @ignore */
      _removeHandlers: {},
      /** @ignore */
      _queue: {},
      /**
       * Remove extensions from PixiJS.
       * @param extensions - Extensions to be removed.
       * @returns {extensions} For chaining.
       */
      remove(...extensions22) {
        extensions22.map(normalizeExtension).forEach((ext) => {
          ext.type.forEach((type2) => this._removeHandlers[type2]?.(ext));
        });
        return this;
      },
      /**
       * Register new extensions with PixiJS.
       * @param extensions - The spread of extensions to add to PixiJS.
       * @returns {extensions} For chaining.
       */
      add(...extensions22) {
        extensions22.map(normalizeExtension).forEach((ext) => {
          ext.type.forEach((type2) => {
            const handlers = this._addHandlers;
            const queue = this._queue;
            if (!handlers[type2]) {
              queue[type2] = queue[type2] || [];
              queue[type2].push(ext);
            } else {
              handlers[type2](ext);
            }
          });
        });
        return this;
      },
      /**
       * Internal method to handle extensions by name.
       * @param type - The extension type.
       * @param onAdd  - Function for handling when extensions are added/registered passes {@link ExtensionFormat}.
       * @param onRemove  - Function for handling when extensions are removed/unregistered passes {@link ExtensionFormat}.
       * @returns {extensions} For chaining.
       */
      handle(type2, onAdd, onRemove) {
        const addHandlers = this._addHandlers;
        const removeHandlers = this._removeHandlers;
        if (addHandlers[type2] || removeHandlers[type2]) {
          throw new Error(`Extension type ${type2} already has a handler`);
        }
        addHandlers[type2] = onAdd;
        removeHandlers[type2] = onRemove;
        const queue = this._queue;
        if (queue[type2]) {
          queue[type2].forEach((ext) => onAdd(ext));
          delete queue[type2];
        }
        return this;
      },
      /**
       * Handle a type, but using a map by `name` property.
       * @param type - Type of extension to handle.
       * @param map - The object map of named extensions.
       * @returns {extensions} For chaining.
       */
      handleByMap(type2, map5) {
        return this.handle(
          type2,
          (extension) => {
            map5[extension.name] = extension.ref;
          },
          (extension) => {
            delete map5[extension.name];
          }
        );
      },
      /**
       * Handle a type, but using a list of extensions with a `name` property.
       * @param type - Type of extension to handle.
       * @param map - The array of named extensions.
       * @param defaultPriority - Fallback priority if none is defined.
       * @returns {extensions} For chaining.
       */
      handleByNamedList(type2, map5, defaultPriority = -1) {
        return this.handle(
          type2,
          (extension) => {
            const index = map5.findIndex((item) => item.name === extension.name);
            if (index >= 0)
              return;
            map5.push({ name: extension.name, value: extension.ref });
            map5.sort((a2, b2) => normalizeExtensionPriority(b2.value, defaultPriority) - normalizeExtensionPriority(a2.value, defaultPriority));
          },
          (extension) => {
            const index = map5.findIndex((item) => item.name === extension.name);
            if (index !== -1) {
              map5.splice(index, 1);
            }
          }
        );
      },
      /**
       * Handle a type, but using a list of extensions.
       * @param type - Type of extension to handle.
       * @param list - The list of extensions.
       * @param defaultPriority - The default priority to use if none is specified.
       * @returns {extensions} For chaining.
       */
      handleByList(type2, list, defaultPriority = -1) {
        return this.handle(
          type2,
          (extension) => {
            if (list.includes(extension.ref)) {
              return;
            }
            list.push(extension.ref);
            list.sort((a2, b2) => normalizeExtensionPriority(b2, defaultPriority) - normalizeExtensionPriority(a2, defaultPriority));
          },
          (extension) => {
            const index = list.indexOf(extension.ref);
            if (index !== -1) {
              list.splice(index, 1);
            }
          }
        );
      }
    };
  }
});

// ../../node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "../../node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix2 = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix2 = false;
    }
    function EE(fn, context4, once) {
      this.fn = fn;
      this.context = context4;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context4, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context4 || emitter, once), evt = prefix2 ? prefix2 + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix2 ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i3 = 0, l3 = handlers.length, ee = new Array(l3); i3 < l3; i3++) {
        ee[i3] = handlers[i3].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i3;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i3 = 1, args = new Array(len - 1); i3 < len; i3++) {
          args[i3 - 1] = arguments[i3];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j3;
        for (i3 = 0; i3 < length; i3++) {
          if (listeners[i3].once)
            this.removeListener(event, listeners[i3].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i3].fn.call(listeners[i3].context);
              break;
            case 2:
              listeners[i3].fn.call(listeners[i3].context, a1);
              break;
            case 3:
              listeners[i3].fn.call(listeners[i3].context, a1, a2);
              break;
            case 4:
              listeners[i3].fn.call(listeners[i3].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j3 = 1, args = new Array(len - 1); j3 < len; j3++) {
                  args[j3 - 1] = arguments[j3];
                }
              listeners[i3].fn.apply(listeners[i3].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context4) {
      return addListener(this, event, fn, context4, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context4) {
      return addListener(this, event, fn, context4, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context4, once) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context4 || listeners.context === context4)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i3 = 0, events = [], length = listeners.length; i3 < length; i3++) {
          if (listeners[i3].fn !== fn || once && !listeners[i3].once || context4 && listeners[i3].context !== context4) {
            events.push(listeners[i3]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix2 ? prefix2 + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix2;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter2;
    }
  }
});

// ../../node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.mjs
var import_index, eventemitter3_default;
var init_eventemitter3 = __esm({
  "../../node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.mjs"() {
    import_index = __toESM(require_eventemitter3(), 1);
    eventemitter3_default = import_index.default;
  }
});

// ../../node_modules/.pnpm/@pixi+colord@2.9.6/node_modules/@pixi/colord/index.mjs
var r, t, n, e, u, a, o, i2, s, h, b, g, d, f, c, l, p, v, m, y, N, x, M, H, $, j, w, S, k;
var init_colord = __esm({
  "../../node_modules/.pnpm/@pixi+colord@2.9.6/node_modules/@pixi/colord/index.mjs"() {
    r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
    t = function(r2) {
      return "string" == typeof r2 ? r2.length > 0 : "number" == typeof r2;
    };
    n = function(r2, t2, n2) {
      return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
    };
    e = function(r2, t2, n2) {
      return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
    };
    u = function(r2) {
      return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
    };
    a = function(r2) {
      return { r: e(r2.r, 0, 255), g: e(r2.g, 0, 255), b: e(r2.b, 0, 255), a: e(r2.a) };
    };
    o = function(r2) {
      return { r: n(r2.r), g: n(r2.g), b: n(r2.b), a: n(r2.a, 3) };
    };
    i2 = /^#([0-9a-f]{3,8})$/i;
    s = function(r2) {
      var t2 = r2.toString(16);
      return t2.length < 2 ? "0" + t2 : t2;
    };
    h = function(r2) {
      var t2 = r2.r, n2 = r2.g, e3 = r2.b, u3 = r2.a, a2 = Math.max(t2, n2, e3), o2 = a2 - Math.min(t2, n2, e3), i3 = o2 ? a2 === t2 ? (n2 - e3) / o2 : a2 === n2 ? 2 + (e3 - t2) / o2 : 4 + (t2 - n2) / o2 : 0;
      return { h: 60 * (i3 < 0 ? i3 + 6 : i3), s: a2 ? o2 / a2 * 100 : 0, v: a2 / 255 * 100, a: u3 };
    };
    b = function(r2) {
      var t2 = r2.h, n2 = r2.s, e3 = r2.v, u3 = r2.a;
      t2 = t2 / 360 * 6, n2 /= 100, e3 /= 100;
      var a2 = Math.floor(t2), o2 = e3 * (1 - n2), i3 = e3 * (1 - (t2 - a2) * n2), s2 = e3 * (1 - (1 - t2 + a2) * n2), h2 = a2 % 6;
      return { r: 255 * [e3, i3, o2, o2, s2, e3][h2], g: 255 * [s2, e3, e3, i3, o2, o2][h2], b: 255 * [o2, o2, s2, e3, e3, i3][h2], a: u3 };
    };
    g = function(r2) {
      return { h: u(r2.h), s: e(r2.s, 0, 100), l: e(r2.l, 0, 100), a: e(r2.a) };
    };
    d = function(r2) {
      return { h: n(r2.h), s: n(r2.s), l: n(r2.l), a: n(r2.a, 3) };
    };
    f = function(r2) {
      return b((n2 = (t2 = r2).s, { h: t2.h, s: (n2 *= ((e3 = t2.l) < 50 ? e3 : 100 - e3) / 100) > 0 ? 2 * n2 / (e3 + n2) * 100 : 0, v: e3 + n2, a: t2.a }));
      var t2, n2, e3;
    };
    c = function(r2) {
      return { h: (t2 = h(r2)).h, s: (u3 = (200 - (n2 = t2.s)) * (e3 = t2.v) / 100) > 0 && u3 < 200 ? n2 * e3 / 100 / (u3 <= 100 ? u3 : 200 - u3) * 100 : 0, l: u3 / 2, a: t2.a };
      var t2, n2, e3, u3;
    };
    l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    y = { string: [[function(r2) {
      var t2 = i2.exec(r2);
      return t2 ? (r2 = t2[1]).length <= 4 ? { r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: 4 === r2.length ? n(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1 } : 6 === r2.length || 8 === r2.length ? { r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: 8 === r2.length ? n(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
    }, "hex"], [function(r2) {
      var t2 = v.exec(r2) || m.exec(r2);
      return t2 ? t2[2] !== t2[4] || t2[4] !== t2[6] ? null : a({ r: Number(t2[1]) / (t2[2] ? 100 / 255 : 1), g: Number(t2[3]) / (t2[4] ? 100 / 255 : 1), b: Number(t2[5]) / (t2[6] ? 100 / 255 : 1), a: void 0 === t2[7] ? 1 : Number(t2[7]) / (t2[8] ? 100 : 1) }) : null;
    }, "rgb"], [function(t2) {
      var n2 = l.exec(t2) || p.exec(t2);
      if (!n2)
        return null;
      var e3, u3, a2 = g({ h: (e3 = n2[1], u3 = n2[2], void 0 === u3 && (u3 = "deg"), Number(e3) * (r[u3] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: void 0 === n2[5] ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
      return f(a2);
    }, "hsl"]], object: [[function(r2) {
      var n2 = r2.r, e3 = r2.g, u3 = r2.b, o2 = r2.a, i3 = void 0 === o2 ? 1 : o2;
      return t(n2) && t(e3) && t(u3) ? a({ r: Number(n2), g: Number(e3), b: Number(u3), a: Number(i3) }) : null;
    }, "rgb"], [function(r2) {
      var n2 = r2.h, e3 = r2.s, u3 = r2.l, a2 = r2.a, o2 = void 0 === a2 ? 1 : a2;
      if (!t(n2) || !t(e3) || !t(u3))
        return null;
      var i3 = g({ h: Number(n2), s: Number(e3), l: Number(u3), a: Number(o2) });
      return f(i3);
    }, "hsl"], [function(r2) {
      var n2 = r2.h, a2 = r2.s, o2 = r2.v, i3 = r2.a, s2 = void 0 === i3 ? 1 : i3;
      if (!t(n2) || !t(a2) || !t(o2))
        return null;
      var h2 = function(r3) {
        return { h: u(r3.h), s: e(r3.s, 0, 100), v: e(r3.v, 0, 100), a: e(r3.a) };
      }({ h: Number(n2), s: Number(a2), v: Number(o2), a: Number(s2) });
      return b(h2);
    }, "hsv"]] };
    N = function(r2, t2) {
      for (var n2 = 0; n2 < t2.length; n2++) {
        var e3 = t2[n2][0](r2);
        if (e3)
          return [e3, t2[n2][1]];
      }
      return [null, void 0];
    };
    x = function(r2) {
      return "string" == typeof r2 ? N(r2.trim(), y.string) : "object" == typeof r2 && null !== r2 ? N(r2, y.object) : [null, void 0];
    };
    M = function(r2, t2) {
      var n2 = c(r2);
      return { h: n2.h, s: e(n2.s + 100 * t2, 0, 100), l: n2.l, a: n2.a };
    };
    H = function(r2) {
      return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1e3 / 255;
    };
    $ = function(r2, t2) {
      var n2 = c(r2);
      return { h: n2.h, s: n2.s, l: e(n2.l + 100 * t2, 0, 100), a: n2.a };
    };
    j = function() {
      function r2(r3) {
        this.parsed = x(r3)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
      }
      return r2.prototype.isValid = function() {
        return null !== this.parsed;
      }, r2.prototype.brightness = function() {
        return n(H(this.rgba), 2);
      }, r2.prototype.isDark = function() {
        return H(this.rgba) < 0.5;
      }, r2.prototype.isLight = function() {
        return H(this.rgba) >= 0.5;
      }, r2.prototype.toHex = function() {
        return r3 = o(this.rgba), t2 = r3.r, e3 = r3.g, u3 = r3.b, i3 = (a2 = r3.a) < 1 ? s(n(255 * a2)) : "", "#" + s(t2) + s(e3) + s(u3) + i3;
        var r3, t2, e3, u3, a2, i3;
      }, r2.prototype.toRgb = function() {
        return o(this.rgba);
      }, r2.prototype.toRgbString = function() {
        return r3 = o(this.rgba), t2 = r3.r, n2 = r3.g, e3 = r3.b, (u3 = r3.a) < 1 ? "rgba(" + t2 + ", " + n2 + ", " + e3 + ", " + u3 + ")" : "rgb(" + t2 + ", " + n2 + ", " + e3 + ")";
        var r3, t2, n2, e3, u3;
      }, r2.prototype.toHsl = function() {
        return d(c(this.rgba));
      }, r2.prototype.toHslString = function() {
        return r3 = d(c(this.rgba)), t2 = r3.h, n2 = r3.s, e3 = r3.l, (u3 = r3.a) < 1 ? "hsla(" + t2 + ", " + n2 + "%, " + e3 + "%, " + u3 + ")" : "hsl(" + t2 + ", " + n2 + "%, " + e3 + "%)";
        var r3, t2, n2, e3, u3;
      }, r2.prototype.toHsv = function() {
        return r3 = h(this.rgba), { h: n(r3.h), s: n(r3.s), v: n(r3.v), a: n(r3.a, 3) };
        var r3;
      }, r2.prototype.invert = function() {
        return w({ r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a });
        var r3;
      }, r2.prototype.saturate = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, r3));
      }, r2.prototype.desaturate = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, -r3));
      }, r2.prototype.grayscale = function() {
        return w(M(this.rgba, -1));
      }, r2.prototype.lighten = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w($(this.rgba, r3));
      }, r2.prototype.darken = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w($(this.rgba, -r3));
      }, r2.prototype.rotate = function(r3) {
        return void 0 === r3 && (r3 = 15), this.hue(this.hue() + r3);
      }, r2.prototype.alpha = function(r3) {
        return "number" == typeof r3 ? w({ r: (t2 = this.rgba).r, g: t2.g, b: t2.b, a: r3 }) : n(this.rgba.a, 3);
        var t2;
      }, r2.prototype.hue = function(r3) {
        var t2 = c(this.rgba);
        return "number" == typeof r3 ? w({ h: r3, s: t2.s, l: t2.l, a: t2.a }) : n(t2.h);
      }, r2.prototype.isEqual = function(r3) {
        return this.toHex() === w(r3).toHex();
      }, r2;
    }();
    w = function(r2) {
      return r2 instanceof j ? r2 : new j(r2);
    };
    S = [];
    k = function(r2) {
      r2.forEach(function(r3) {
        S.indexOf(r3) < 0 && (r3(j, y), S.push(r3));
      });
    };
  }
});

// ../../node_modules/.pnpm/@pixi+colord@2.9.6/node_modules/@pixi/colord/plugins/names.mjs
function names_default(e3, f3) {
  var a2 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r2 = {};
  for (var d3 in a2)
    r2[a2[d3]] = d3;
  var l3 = {};
  e3.prototype.toName = function(f4) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
      return "transparent";
    var d4, i3, n2 = r2[this.toHex()];
    if (n2)
      return n2;
    if (null == f4 ? void 0 : f4.closest) {
      var o2 = this.toRgb(), t2 = 1 / 0, b2 = "black";
      if (!l3.length)
        for (var c2 in a2)
          l3[c2] = new e3(a2[c2]).toRgb();
      for (var g2 in a2) {
        var u3 = (d4 = o2, i3 = l3[g2], Math.pow(d4.r - i3.r, 2) + Math.pow(d4.g - i3.g, 2) + Math.pow(d4.b - i3.b, 2));
        u3 < t2 && (t2 = u3, b2 = g2);
      }
      return b2;
    }
  };
  f3.string.push([function(f4) {
    var r3 = f4.toLowerCase(), d4 = "transparent" === r3 ? "#0000" : a2[r3];
    return d4 ? new e3(d4).toRgb() : null;
  }, "name"]);
}
var init_names = __esm({
  "../../node_modules/.pnpm/@pixi+colord@2.9.6/node_modules/@pixi/colord/plugins/names.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/color/Color.mjs
var _Color, Color;
var init_Color = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/color/Color.mjs"() {
    init_colord();
    init_names();
    k([names_default]);
    _Color = class {
      /**
       * @param {ColorSource} value - Optional value to use, if not provided, white is used.
       */
      constructor(value = 16777215) {
        this._value = null;
        this._components = new Float32Array(4);
        this._components.fill(1);
        this._int = 16777215;
        this.value = value;
      }
      /** Get red component (0 - 1) */
      get red() {
        return this._components[0];
      }
      /** Get green component (0 - 1) */
      get green() {
        return this._components[1];
      }
      /** Get blue component (0 - 1) */
      get blue() {
        return this._components[2];
      }
      /** Get alpha component (0 - 1) */
      get alpha() {
        return this._components[3];
      }
      /**
       * Set the value, suitable for chaining
       * @param value
       * @see Color.value
       */
      setValue(value) {
        this.value = value;
        return this;
      }
      /**
       * The current color source.
       *
       * When setting:
       * - Setting to an instance of `Color` will copy its color source and components.
       * - Otherwise, `Color` will try to normalize the color source and set the components.
       *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.
       *
       * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter
       * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.
       *
       * When getting:
       * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},
       *   {@link Color.premultiply premultiply} or {@link Color.round round}).
       * - Otherwise, the color source used when setting is returned.
       * @type {ColorSource}
       */
      set value(value) {
        if (value instanceof _Color) {
          this._value = this._cloneSource(value._value);
          this._int = value._int;
          this._components.set(value._components);
        } else if (value === null) {
          throw new Error("Cannot set Color#value to null");
        } else if (this._value === null || !this._isSourceEqual(this._value, value)) {
          this._normalize(value);
          this._value = this._cloneSource(value);
        }
      }
      get value() {
        return this._value;
      }
      /**
       * Copy a color source internally.
       * @param value - Color source
       */
      _cloneSource(value) {
        if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
          return value;
        } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
          return value.slice(0);
        } else if (typeof value === "object" && value !== null) {
          return { ...value };
        }
        return value;
      }
      /**
       * Equality check for color sources.
       * @param value1 - First color source
       * @param value2 - Second color source
       * @returns `true` if the color sources are equal, `false` otherwise.
       */
      _isSourceEqual(value1, value2) {
        const type1 = typeof value1;
        const type2 = typeof value2;
        if (type1 !== type2) {
          return false;
        } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
          return value1 === value2;
        } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
          if (value1.length !== value2.length) {
            return false;
          }
          return value1.every((v3, i3) => v3 === value2[i3]);
        } else if (value1 !== null && value2 !== null) {
          const keys1 = Object.keys(value1);
          const keys2 = Object.keys(value2);
          if (keys1.length !== keys2.length) {
            return false;
          }
          return keys1.every((key2) => value1[key2] === value2[key2]);
        }
        return value1 === value2;
      }
      /**
       * Convert to a RGBA color object.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }
       */
      toRgba() {
        const [r2, g2, b2, a2] = this._components;
        return { r: r2, g: g2, b: b2, a: a2 };
      }
      /**
       * Convert to a RGB color object.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }
       */
      toRgb() {
        const [r2, g2, b2] = this._components;
        return { r: r2, g: g2, b: b2 };
      }
      /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */
      toRgbaString() {
        const [r2, g2, b2] = this.toUint8RgbArray();
        return `rgba(${r2},${g2},${b2},${this.alpha})`;
      }
      toUint8RgbArray(out3) {
        const [r2, g2, b2] = this._components;
        if (!this._arrayRgb) {
          this._arrayRgb = [];
        }
        out3 = out3 || this._arrayRgb;
        out3[0] = Math.round(r2 * 255);
        out3[1] = Math.round(g2 * 255);
        out3[2] = Math.round(b2 * 255);
        return out3;
      }
      toArray(out3) {
        if (!this._arrayRgba) {
          this._arrayRgba = [];
        }
        out3 = out3 || this._arrayRgba;
        const [r2, g2, b2, a2] = this._components;
        out3[0] = r2;
        out3[1] = g2;
        out3[2] = b2;
        out3[3] = a2;
        return out3;
      }
      toRgbArray(out3) {
        if (!this._arrayRgb) {
          this._arrayRgb = [];
        }
        out3 = out3 || this._arrayRgb;
        const [r2, g2, b2] = this._components;
        out3[0] = r2;
        out3[1] = g2;
        out3[2] = b2;
        return out3;
      }
      /**
       * Convert to a hexadecimal number.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toNumber(); // returns 16777215
       */
      toNumber() {
        return this._int;
      }
      /**
       * Convert to a BGR number
       * @example
       * import { Color } from 'pixi.js';
       * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff
       */
      toBgrNumber() {
        const [r2, g2, b2] = this.toUint8RgbArray();
        return (b2 << 16) + (g2 << 8) + r2;
      }
      /**
       * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
       * @example
       * import { Color } from 'pixi.js';
       * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
       * @returns {number} - The color as a number in little endian format.
       */
      toLittleEndianNumber() {
        const value = this._int;
        return (value >> 16) + (value & 65280) + ((value & 255) << 16);
      }
      /**
       * Multiply with another color. This action is destructive, and will
       * override the previous `value` property to be `null`.
       * @param {ColorSource} value - The color to multiply by.
       */
      multiply(value) {
        const [r2, g2, b2, a2] = _Color._temp.setValue(value)._components;
        this._components[0] *= r2;
        this._components[1] *= g2;
        this._components[2] *= b2;
        this._components[3] *= a2;
        this._refreshInt();
        this._value = null;
        return this;
      }
      /**
       * Converts color to a premultiplied alpha format. This action is destructive, and will
       * override the previous `value` property to be `null`.
       * @param alpha - The alpha to multiply by.
       * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
       * @returns {Color} - Itself.
       */
      premultiply(alpha, applyToRGB = true) {
        if (applyToRGB) {
          this._components[0] *= alpha;
          this._components[1] *= alpha;
          this._components[2] *= alpha;
        }
        this._components[3] = alpha;
        this._refreshInt();
        this._value = null;
        return this;
      }
      /**
       * Premultiplies alpha with current color.
       * @param {number} alpha - The alpha to multiply by.
       * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
       * @returns {number} tint multiplied by alpha
       */
      toPremultiplied(alpha, applyToRGB = true) {
        if (alpha === 1) {
          return (255 << 24) + this._int;
        }
        if (alpha === 0) {
          return applyToRGB ? 0 : this._int;
        }
        let r2 = this._int >> 16 & 255;
        let g2 = this._int >> 8 & 255;
        let b2 = this._int & 255;
        if (applyToRGB) {
          r2 = r2 * alpha + 0.5 | 0;
          g2 = g2 * alpha + 0.5 | 0;
          b2 = b2 * alpha + 0.5 | 0;
        }
        return (alpha * 255 << 24) + (r2 << 16) + (g2 << 8) + b2;
      }
      /**
       * Convert to a hexidecimal string.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toHex(); // returns "#ffffff"
       */
      toHex() {
        const hexString = this._int.toString(16);
        return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
      }
      /**
       * Convert to a hexidecimal string with alpha.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toHexa(); // returns "#ffffffff"
       */
      toHexa() {
        const alphaValue = Math.round(this._components[3] * 255);
        const alphaString = alphaValue.toString(16);
        return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
      }
      /**
       * Set alpha, suitable for chaining.
       * @param alpha
       */
      setAlpha(alpha) {
        this._components[3] = this._clamp(alpha);
        return this;
      }
      /**
       * Normalize the input value into rgba
       * @param value - Input value
       */
      _normalize(value) {
        let r2;
        let g2;
        let b2;
        let a2;
        if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
          const int = value;
          r2 = (int >> 16 & 255) / 255;
          g2 = (int >> 8 & 255) / 255;
          b2 = (int & 255) / 255;
          a2 = 1;
        } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
          value = this._clamp(value);
          [r2, g2, b2, a2 = 1] = value;
        } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
          value = this._clamp(value, 0, 255);
          [r2, g2, b2, a2 = 255] = value;
          r2 /= 255;
          g2 /= 255;
          b2 /= 255;
          a2 /= 255;
        } else if (typeof value === "string" || typeof value === "object") {
          if (typeof value === "string") {
            const match = _Color.HEX_PATTERN.exec(value);
            if (match) {
              value = `#${match[2]}`;
            }
          }
          const color = w(value);
          if (color.isValid()) {
            ({ r: r2, g: g2, b: b2, a: a2 } = color.rgba);
            r2 /= 255;
            g2 /= 255;
            b2 /= 255;
          }
        }
        if (r2 !== void 0) {
          this._components[0] = r2;
          this._components[1] = g2;
          this._components[2] = b2;
          this._components[3] = a2;
          this._refreshInt();
        } else {
          throw new Error(`Unable to convert color ${value}`);
        }
      }
      /** Refresh the internal color rgb number */
      _refreshInt() {
        this._clamp(this._components);
        const [r2, g2, b2] = this._components;
        this._int = (r2 * 255 << 16) + (g2 * 255 << 8) + (b2 * 255 | 0);
      }
      /**
       * Clamps values to a range. Will override original values
       * @param value - Value(s) to clamp
       * @param min - Minimum value
       * @param max - Maximum value
       */
      _clamp(value, min = 0, max = 1) {
        if (typeof value === "number") {
          return Math.min(Math.max(value, min), max);
        }
        value.forEach((v3, i3) => {
          value[i3] = Math.min(Math.max(v3, min), max);
        });
        return value;
      }
      /**
       * Check if the value is a color-like object
       * @param value - Value to check
       * @returns True if the value is a color-like object
       * @static
       * @example
       * import { Color } from 'pixi.js';
       * Color.isColorLike('white'); // returns true
       * Color.isColorLike(0xffffff); // returns true
       * Color.isColorLike([1, 1, 1]); // returns true
       */
      static isColorLike(value) {
        return typeof value === "number" || typeof value === "string" || value instanceof Number || value instanceof _Color || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;
      }
    };
    Color = _Color;
    Color.shared = new _Color();
    Color._temp = new _Color();
    Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/maths/misc/const.mjs
var PI_2, RAD_TO_DEG, DEG_TO_RAD;
var init_const = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/maths/misc/const.mjs"() {
    PI_2 = Math.PI * 2;
    RAD_TO_DEG = 180 / Math.PI;
    DEG_TO_RAD = Math.PI / 180;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs
var Matrix, tempMatrix, identityMatrix;
var init_Matrix = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"() {
    init_const();
    init_Point();
    Matrix = class _Matrix {
      /**
       * @param a - x scale
       * @param b - y skew
       * @param c - x skew
       * @param d - y scale
       * @param tx - x translation
       * @param ty - y translation
       */
      constructor(a2 = 1, b2 = 0, c2 = 0, d3 = 1, tx = 0, ty = 0) {
        this.array = null;
        this.a = a2;
        this.b = b2;
        this.c = c2;
        this.d = d3;
        this.tx = tx;
        this.ty = ty;
      }
      /**
       * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
       *
       * a = array[0]
       * b = array[1]
       * c = array[3]
       * d = array[4]
       * tx = array[2]
       * ty = array[5]
       * @param array - The array that the matrix will be populated from.
       */
      fromArray(array) {
        this.a = array[0];
        this.b = array[1];
        this.c = array[3];
        this.d = array[4];
        this.tx = array[2];
        this.ty = array[5];
      }
      /**
       * Sets the matrix properties.
       * @param a - Matrix component
       * @param b - Matrix component
       * @param c - Matrix component
       * @param d - Matrix component
       * @param tx - Matrix component
       * @param ty - Matrix component
       * @returns This matrix. Good for chaining method calls.
       */
      set(a2, b2, c2, d3, tx, ty) {
        this.a = a2;
        this.b = b2;
        this.c = c2;
        this.d = d3;
        this.tx = tx;
        this.ty = ty;
        return this;
      }
      /**
       * Creates an array from the current Matrix object.
       * @param transpose - Whether we need to transpose the matrix or not
       * @param [out=new Float32Array(9)] - If provided the array will be assigned to out
       * @returns The newly created array which contains the matrix
       */
      toArray(transpose, out3) {
        if (!this.array) {
          this.array = new Float32Array(9);
        }
        const array = out3 || this.array;
        if (transpose) {
          array[0] = this.a;
          array[1] = this.b;
          array[2] = 0;
          array[3] = this.c;
          array[4] = this.d;
          array[5] = 0;
          array[6] = this.tx;
          array[7] = this.ty;
          array[8] = 1;
        } else {
          array[0] = this.a;
          array[1] = this.c;
          array[2] = this.tx;
          array[3] = this.b;
          array[4] = this.d;
          array[5] = this.ty;
          array[6] = 0;
          array[7] = 0;
          array[8] = 1;
        }
        return array;
      }
      /**
       * Get a new position with the current transformation applied.
       * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
       * @param pos - The origin
       * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
       * @returns {Point} The new point, transformed through this matrix
       */
      apply(pos, newPos) {
        newPos = newPos || new Point();
        const x3 = pos.x;
        const y2 = pos.y;
        newPos.x = this.a * x3 + this.c * y2 + this.tx;
        newPos.y = this.b * x3 + this.d * y2 + this.ty;
        return newPos;
      }
      /**
       * Get a new position with the inverse of the current transformation applied.
       * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
       * @param pos - The origin
       * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
       * @returns {Point} The new point, inverse-transformed through this matrix
       */
      applyInverse(pos, newPos) {
        newPos = newPos || new Point();
        const a2 = this.a;
        const b2 = this.b;
        const c2 = this.c;
        const d3 = this.d;
        const tx = this.tx;
        const ty = this.ty;
        const id = 1 / (a2 * d3 + c2 * -b2);
        const x3 = pos.x;
        const y2 = pos.y;
        newPos.x = d3 * id * x3 + -c2 * id * y2 + (ty * c2 - tx * d3) * id;
        newPos.y = a2 * id * y2 + -b2 * id * x3 + (-ty * a2 + tx * b2) * id;
        return newPos;
      }
      /**
       * Translates the matrix on the x and y.
       * @param x - How much to translate x by
       * @param y - How much to translate y by
       * @returns This matrix. Good for chaining method calls.
       */
      translate(x3, y2) {
        this.tx += x3;
        this.ty += y2;
        return this;
      }
      /**
       * Applies a scale transformation to the matrix.
       * @param x - The amount to scale horizontally
       * @param y - The amount to scale vertically
       * @returns This matrix. Good for chaining method calls.
       */
      scale(x3, y2) {
        this.a *= x3;
        this.d *= y2;
        this.c *= x3;
        this.b *= y2;
        this.tx *= x3;
        this.ty *= y2;
        return this;
      }
      /**
       * Applies a rotation transformation to the matrix.
       * @param angle - The angle in radians.
       * @returns This matrix. Good for chaining method calls.
       */
      rotate(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const a1 = this.a;
        const c1 = this.c;
        const tx1 = this.tx;
        this.a = a1 * cos - this.b * sin;
        this.b = a1 * sin + this.b * cos;
        this.c = c1 * cos - this.d * sin;
        this.d = c1 * sin + this.d * cos;
        this.tx = tx1 * cos - this.ty * sin;
        this.ty = tx1 * sin + this.ty * cos;
        return this;
      }
      /**
       * Appends the given Matrix to this Matrix.
       * @param matrix - The matrix to append.
       * @returns This matrix. Good for chaining method calls.
       */
      append(matrix) {
        const a1 = this.a;
        const b1 = this.b;
        const c1 = this.c;
        const d1 = this.d;
        this.a = matrix.a * a1 + matrix.b * c1;
        this.b = matrix.a * b1 + matrix.b * d1;
        this.c = matrix.c * a1 + matrix.d * c1;
        this.d = matrix.c * b1 + matrix.d * d1;
        this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
        this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
        return this;
      }
      /**
       * Appends two matrix's and sets the result to this matrix. AB = A * B
       * @param a - The matrix to append.
       * @param b - The matrix to append.
       * @returns This matrix. Good for chaining method calls.
       */
      appendFrom(a2, b2) {
        const a1 = a2.a;
        const b1 = a2.b;
        const c1 = a2.c;
        const d1 = a2.d;
        const tx = a2.tx;
        const ty = a2.ty;
        const a22 = b2.a;
        const b22 = b2.b;
        const c2 = b2.c;
        const d22 = b2.d;
        this.a = a1 * a22 + b1 * c2;
        this.b = a1 * b22 + b1 * d22;
        this.c = c1 * a22 + d1 * c2;
        this.d = c1 * b22 + d1 * d22;
        this.tx = tx * a22 + ty * c2 + b2.tx;
        this.ty = tx * b22 + ty * d22 + b2.ty;
        return this;
      }
      /**
       * Sets the matrix based on all the available properties
       * @param x - Position on the x axis
       * @param y - Position on the y axis
       * @param pivotX - Pivot on the x axis
       * @param pivotY - Pivot on the y axis
       * @param scaleX - Scale on the x axis
       * @param scaleY - Scale on the y axis
       * @param rotation - Rotation in radians
       * @param skewX - Skew on the x axis
       * @param skewY - Skew on the y axis
       * @returns This matrix. Good for chaining method calls.
       */
      setTransform(x3, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
        this.a = Math.cos(rotation + skewY) * scaleX;
        this.b = Math.sin(rotation + skewY) * scaleX;
        this.c = -Math.sin(rotation - skewX) * scaleY;
        this.d = Math.cos(rotation - skewX) * scaleY;
        this.tx = x3 - (pivotX * this.a + pivotY * this.c);
        this.ty = y2 - (pivotX * this.b + pivotY * this.d);
        return this;
      }
      /**
       * Prepends the given Matrix to this Matrix.
       * @param matrix - The matrix to prepend
       * @returns This matrix. Good for chaining method calls.
       */
      prepend(matrix) {
        const tx1 = this.tx;
        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
          const a1 = this.a;
          const c1 = this.c;
          this.a = a1 * matrix.a + this.b * matrix.c;
          this.b = a1 * matrix.b + this.b * matrix.d;
          this.c = c1 * matrix.a + this.d * matrix.c;
          this.d = c1 * matrix.b + this.d * matrix.d;
        }
        this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
        this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
        return this;
      }
      /**
       * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
       * @param transform - The transform to apply the properties to.
       * @returns The transform with the newly applied properties
       */
      decompose(transform) {
        const a2 = this.a;
        const b2 = this.b;
        const c2 = this.c;
        const d3 = this.d;
        const pivot = transform.pivot;
        const skewX = -Math.atan2(-c2, d3);
        const skewY = Math.atan2(b2, a2);
        const delta = Math.abs(skewX + skewY);
        if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
          transform.rotation = skewY;
          transform.skew.x = transform.skew.y = 0;
        } else {
          transform.rotation = 0;
          transform.skew.x = skewX;
          transform.skew.y = skewY;
        }
        transform.scale.x = Math.sqrt(a2 * a2 + b2 * b2);
        transform.scale.y = Math.sqrt(c2 * c2 + d3 * d3);
        transform.position.x = this.tx + (pivot.x * a2 + pivot.y * c2);
        transform.position.y = this.ty + (pivot.x * b2 + pivot.y * d3);
        return transform;
      }
      /**
       * Inverts this matrix
       * @returns This matrix. Good for chaining method calls.
       */
      invert() {
        const a1 = this.a;
        const b1 = this.b;
        const c1 = this.c;
        const d1 = this.d;
        const tx1 = this.tx;
        const n2 = a1 * d1 - b1 * c1;
        this.a = d1 / n2;
        this.b = -b1 / n2;
        this.c = -c1 / n2;
        this.d = a1 / n2;
        this.tx = (c1 * this.ty - d1 * tx1) / n2;
        this.ty = -(a1 * this.ty - b1 * tx1) / n2;
        return this;
      }
      /** Checks if this matrix is an identity matrix */
      isIdentity() {
        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
      }
      /**
       * Resets this Matrix to an identity (default) matrix.
       * @returns This matrix. Good for chaining method calls.
       */
      identity() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
        return this;
      }
      /**
       * Creates a new Matrix object with the same values as this one.
       * @returns A copy of this matrix. Good for chaining method calls.
       */
      clone() {
        const matrix = new _Matrix();
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      }
      /**
       * Changes the values of the given matrix to be the same as the ones in this matrix
       * @param matrix - The matrix to copy to.
       * @returns The matrix given in parameter with its values updated.
       */
      copyTo(matrix) {
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      }
      /**
       * Changes the values of the matrix to be the same as the ones in given matrix
       * @param matrix - The matrix to copy from.
       * @returns this
       */
      copyFrom(matrix) {
        this.a = matrix.a;
        this.b = matrix.b;
        this.c = matrix.c;
        this.d = matrix.d;
        this.tx = matrix.tx;
        this.ty = matrix.ty;
        return this;
      }
      toString() {
        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
      }
      /**
       * A default (identity) matrix
       * @readonly
       */
      static get IDENTITY() {
        return identityMatrix.identity();
      }
      /**
       * A temp matrix
       * @readonly
       */
      static get shared() {
        return tempMatrix.identity();
      }
    };
    tempMatrix = new Matrix();
    identityMatrix = new Matrix();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs
var ObservablePoint;
var init_ObservablePoint = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs"() {
    ObservablePoint = class _ObservablePoint {
      /**
       * Creates a new `ObservablePoint`
       * @param observer - Observer to pass to listen for change events.
       * @param {number} [x=0] - position of the point on the x axis
       * @param {number} [y=0] - position of the point on the y axis
       */
      constructor(observer, x3, y2) {
        this._x = x3 || 0;
        this._y = y2 || 0;
        this._observer = observer;
      }
      /**
       * Creates a clone of this point.
       * @param observer - Optional observer to pass to the new observable point.
       * @returns a copy of this observable point
       */
      clone(observer) {
        return new _ObservablePoint(observer ?? this._observer, this._x, this._y);
      }
      /**
       * Sets the point to a new `x` and `y` position.
       * If `y` is omitted, both `x` and `y` will be set to `x`.
       * @param {number} [x=0] - position of the point on the x axis
       * @param {number} [y=x] - position of the point on the y axis
       * @returns The observable point instance itself
       */
      set(x3 = 0, y2 = x3) {
        if (this._x !== x3 || this._y !== y2) {
          this._x = x3;
          this._y = y2;
          this._observer.onUpdate();
        }
        return this;
      }
      /**
       * Copies x and y from the given point (`p`)
       * @param p - The point to copy from. Can be any of type that is or extends `PointData`
       * @returns The observable point instance itself
       */
      copyFrom(p3) {
        if (this._x !== p3.x || this._y !== p3.y) {
          this._x = p3.x;
          this._y = p3.y;
          this._observer.onUpdate();
        }
        return this;
      }
      /**
       * Copies this point's x and y into that of the given point (`p`)
       * @param p - The point to copy to. Can be any of type that is or extends `PointData`
       * @returns The point (`p`) with values updated
       */
      copyTo(p3) {
        p3.set(this._x, this._y);
        return p3;
      }
      /**
       * Accepts another point (`p`) and returns `true` if the given point is equal to this point
       * @param p - The point to check
       * @returns Returns `true` if both `x` and `y` are equal
       */
      equals(p3) {
        return p3.x === this._x && p3.y === this._y;
      }
      toString() {
        return `[@pixi/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;
      }
      /** Position of the observable point on the x axis. */
      get x() {
        return this._x;
      }
      set x(value) {
        if (this._x !== value) {
          this._x = value;
          this._observer.onUpdate(this);
        }
      }
      /** Position of the observable point on the y axis. */
      get y() {
        return this._y;
      }
      set y(value) {
        if (this._y !== value) {
          this._y = value;
          this._observer.onUpdate(this);
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/data/uid.mjs
function uid(name = "default") {
  if (uidCache[name] === void 0) {
    uidCache[name] = -1;
  }
  return ++uidCache[name];
}
var uidCache;
var init_uid = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/data/uid.mjs"() {
    uidCache = {
      default: -1
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/logging/deprecation.mjs
function deprecation(version, message, ignoreDepth = 3) {
  if (warnings[message]) {
    return;
  }
  let stack = new Error().stack;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (console.groupCollapsed) {
      console.groupCollapsed(
        "%cPixiJS Deprecation Warning: %c%s",
        "color:#614108;background:#fffbe6",
        "font-weight:normal;color:#614108;background:#fffbe6",
        `${message}
Deprecated since v${version}`
      );
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
      console.warn(stack);
    }
  }
  warnings[message] = true;
}
var warnings, v8_0_0;
var init_deprecation = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/logging/deprecation.mjs"() {
    warnings = {};
    v8_0_0 = "8.0.0";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/data/removeItems.mjs
function removeItems(arr, startIdx, removeCount) {
  const length = arr.length;
  let i3;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  const len = length - removeCount;
  for (i3 = startIdx; i3 < len; ++i3) {
    arr[i3] = arr[i3 + removeCount];
  }
  arr.length = len;
}
var init_removeItems = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/data/removeItems.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs
var childrenHelperMixin;
var init_childrenHelperMixin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs"() {
    init_removeItems();
    init_deprecation();
    childrenHelperMixin = {
      allowChildren: true,
      /**
       * Removes all children from this container that are within the begin and end indexes.
       * @param beginIndex - The beginning position.
       * @param endIndex - The ending position. Default value is size of the container.
       * @returns - List of removed children
       * @memberof Container#
       */
      removeChildren(beginIndex = 0, endIndex) {
        const end = endIndex ?? this.children.length;
        const range = end - beginIndex;
        const removed = [];
        if (range > 0 && range <= end) {
          for (let i3 = end - 1; i3 >= beginIndex; i3--) {
            const child = this.children[i3];
            if (!child)
              continue;
            if (this.layerGroup) {
              this.layerGroup.removeChild(child);
            }
            removed.push(child);
            child.parent = null;
          }
          removeItems(this.children, beginIndex, end);
          for (let i3 = 0; i3 < removed.length; ++i3) {
            this.emit("childRemoved", removed[i3], this, i3);
            removed[i3].emit("removed", this);
          }
          return removed;
        } else if (range === 0 && this.children.length === 0) {
          return removed;
        }
        throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
      },
      /**
       * Removes a child from the specified index position.
       * @param index - The index to get the child from
       * @returns The child that was removed.
       * @memberof Container#
       */
      removeChildAt(index) {
        const child = this.getChildAt(index);
        return this.removeChild(child);
      },
      /**
       * Returns the child at the specified index
       * @param index - The index to get the child at
       * @returns - The child at the given index, if any.
       * @memberof Container#
       */
      getChildAt(index) {
        if (index < 0 || index >= this.children.length) {
          throw new Error(`getChildAt: Index (${index}) does not exist.`);
        }
        return this.children[index];
      },
      /**
       * Changes the position of an existing child in the container container
       * @param child - The child Container instance for which you want to change the index number
       * @param index - The resulting index number for the child container
       * @memberof Container#
       */
      setChildIndex(child, index) {
        if (index < 0 || index >= this.children.length) {
          throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
        }
        this.getChildIndex(child);
        this.addChildAt(child, index);
      },
      /**
       * Returns the index position of a child Container instance
       * @param child - The Container instance to identify
       * @returns - The index position of the child container to identify
       * @memberof Container#
       */
      getChildIndex(child) {
        const index = this.children.indexOf(child);
        if (index === -1) {
          throw new Error("The supplied Container must be a child of the caller");
        }
        return index;
      },
      /**
       * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.
       * If the child is already in this container, it will be moved to the specified index.
       * @param {Container} child - The child to add.
       * @param {number} index - The absolute index where the child will be positioned at the end of the operation.
       * @returns {Container} The child that was added.
       * @memberof Container#
       */
      addChildAt(child, index) {
        if (!this.allowChildren) {
          deprecation(v8_0_0, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
        }
        const { children } = this;
        if (index < 0 || index > children.length) {
          throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);
        }
        if (child.parent) {
          const currentIndex = child.parent.children.indexOf(child);
          if (child.parent === this && currentIndex === index) {
            return child;
          }
          if (currentIndex !== -1) {
            child.parent.children.splice(currentIndex, 1);
          }
        }
        if (index === children.length) {
          children.push(child);
        } else {
          children.splice(index, 0, child);
        }
        child.parent = this;
        child.didChange = true;
        child.didViewUpdate = false;
        child._updateFlags = 15;
        if (this.layerGroup) {
          this.layerGroup.addChild(child);
        }
        if (this.sortableChildren)
          this.sortDirty = true;
        this.emit("childAdded", child, this, index);
        child.emit("added", this);
        return child;
      },
      /**
       * Swaps the position of 2 Containers within this container.
       * @param child - First container to swap
       * @param child2 - Second container to swap
       */
      swapChildren(child, child2) {
        if (child === child2) {
          return;
        }
        const index1 = this.getChildIndex(child);
        const index2 = this.getChildIndex(child2);
        this.children[index1] = child2;
        this.children[index2] = child;
      },
      /** Remove the Container from its parent Container. If the Container has no parent, do nothing. */
      removeFromParent() {
        this.parent?.removeChild(this);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/FilterEffect.mjs
function getFilterEffect(filters) {
  const filterEffect = filterEffectsPool.pop() || new FilterEffect();
  filterEffect.filters = filters;
  return filterEffect;
}
function returnFilterEffect(effect) {
  effect.filters = null;
  filterEffectsPool.push(effect);
}
var FilterEffect, filterEffectsPool;
var init_FilterEffect = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/FilterEffect.mjs"() {
    FilterEffect = class {
      constructor(options) {
        this.pipe = "filter";
        this.priority = 1;
        this.filters = options?.filters;
      }
      destroy() {
        for (let i3 = 0; i3 < this.filters.length; i3++) {
          this.filters[i3].destroy();
        }
        this.filters = null;
      }
    };
    filterEffectsPool = [];
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/pool/Pool.mjs
var Pool2;
var init_Pool = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/pool/Pool.mjs"() {
    Pool2 = class {
      constructor(ClassType, initialSize) {
        this._pool = [];
        this._count = 0;
        this._index = 0;
        this._classType = ClassType;
        if (initialSize) {
          this.prepopulate(initialSize);
        }
      }
      prepopulate(total) {
        for (let i3 = 0; i3 < total; i3++) {
          this._pool[this._index++] = new this._classType();
        }
        this._count += total;
      }
      get(data) {
        let item;
        if (this._index > 0) {
          item = this._pool[--this._index];
        } else {
          item = new this._classType();
        }
        item.init?.(data);
        return item;
      }
      return(item) {
        item.reset?.();
        this._pool[this._index++] = item;
      }
      get totalSize() {
        return this._count;
      }
      get totalFree() {
        return this._pool.length;
      }
      get totalUsed() {
        return this._count - this._pool.length;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs
var PoolGroupClass, BigPool;
var init_PoolGroup = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"() {
    init_Pool();
    PoolGroupClass = class {
      constructor() {
        this._poolsByClass = /* @__PURE__ */ new Map();
      }
      prepopulate(Class, total) {
        const classPool = this.getPool(Class);
        classPool.prepopulate(total);
      }
      get(Class, data) {
        const pool = this.getPool(Class);
        return pool.get(data);
      }
      return(item) {
        const pool = this.getPool(item.constructor);
        pool.return(item);
      }
      getPool(ClassType) {
        if (!this._poolsByClass.has(ClassType)) {
          this._poolsByClass.set(ClassType, new Pool2(ClassType));
        }
        return this._poolsByClass.get(ClassType);
      }
      /** gets the usage stats of each pool in the system */
      stats() {
        const stats = {};
        this._poolsByClass.forEach((pool) => {
          const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;
          stats[name] = {
            free: pool.totalFree,
            used: pool.totalUsed,
            size: pool.totalSize
          };
        });
        return stats;
      }
    };
    BigPool = new PoolGroupClass();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs
var MaskEffectManagerClass, MaskEffectManager;
var init_MaskEffectManager = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs"() {
    init_Extensions();
    init_PoolGroup();
    MaskEffectManagerClass = class {
      constructor() {
        this._effectClasses = [];
        this._tests = [];
        this._initialized = false;
      }
      init() {
        if (this._initialized)
          return;
        this._initialized = true;
        this._effectClasses.forEach((test) => {
          this.add({
            test: test.test,
            maskClass: test
          });
        });
      }
      add(test) {
        this._tests.push(test);
      }
      getMaskEffect(item) {
        if (!this._initialized)
          this.init();
        for (let i3 = 0; i3 < this._tests.length; i3++) {
          const test = this._tests[i3];
          if (test.test(item)) {
            return BigPool.get(test.maskClass, item);
          }
        }
        return item;
      }
      returnMaskEffect(effect) {
        BigPool.return(effect);
      }
    };
    MaskEffectManager = new MaskEffectManagerClass();
    extensions.handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs
var effectsMixin;
var init_effectsMixin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs"() {
    init_FilterEffect();
    init_MaskEffectManager();
    effectsMixin = {
      _mask: null,
      _filters: null,
      effects: [],
      addEffect(effect) {
        const index = this.effects.indexOf(effect);
        if (index !== -1)
          return;
        this.effects.push(effect);
        this.effects.sort((a2, b2) => a2.priority - b2.priority);
        if (!this.isLayerRoot && this.layerGroup) {
          this.layerGroup.structureDidChange = true;
        }
        this._updateIsSimple();
      },
      removeEffect(effect) {
        const index = this.effects.indexOf(effect);
        if (index === -1)
          return;
        this.effects.splice(index, 1);
        if (!this.isLayerRoot && this.layerGroup) {
          this.layerGroup.structureDidChange = true;
        }
        this._updateIsSimple();
      },
      set mask(value) {
        this._mask || (this._mask = { mask: null, effect: null });
        if (this._mask.mask === value)
          return;
        if (this._mask.effect) {
          this.removeEffect(this._mask.effect);
          MaskEffectManager.returnMaskEffect(this._mask.effect);
          this._mask.effect = null;
        }
        this._mask.mask = value;
        if (value === null || value === void 0)
          return;
        const effect = MaskEffectManager.getMaskEffect(value);
        this._mask.effect = effect;
        this.addEffect(effect);
      },
      get mask() {
        return this._mask?.mask;
      },
      set filters(value) {
        if (!Array.isArray(value) && value !== null)
          value = [value];
        this._filters || (this._filters = { filters: null, effect: null });
        if (this._filters.filters === value)
          return;
        if (this._filters.effect) {
          this.removeEffect(this._filters.effect);
          returnFilterEffect(this._filters.effect);
          this._filters.effect = null;
        }
        this._filters.filters = value;
        if (!value)
          return;
        const effect = getFilterEffect(value);
        this._filters.effect = effect;
        this.addEffect(effect);
      },
      get filters() {
        return this._filters?.filters;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs
var findMixin;
var init_findMixin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs"() {
    init_deprecation();
    findMixin = {
      label: null,
      /** @deprecated since 8.0.0 */
      get name() {
        deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
        return this.label;
      },
      /** @deprecated since 8.0.0 */
      set name(value) {
        deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
        this.label = value;
      },
      /**
       * @method getChildByName
       * @memberof Container#
       * @deprecated since 8.0.0
       * @see Container#getChildByLabel
       * @param {string} name - Instance name.
       * @param {boolean}[deep=false] - Whether to search recursively
       * @returns {Container} The child with the specified name.
       */
      getChildByName(name, deep = false) {
        return this.getChildByLabel(name, deep);
      },
      /**
       * Returns the first child in the container with the specified label.
       *
       * Recursive searches are done in a pre-order traversal.
       * @method getChildByLabel
       * @memberof Container#
       * @param {string|RegExp} label - Instance label.
       * @param {boolean}[deep=false] - Whether to search recursively
       * @returns {Container} The child with the specified label.
       */
      getChildByLabel(label, deep = false) {
        const children = this.children;
        for (let i3 = 0; i3 < children.length; i3++) {
          const child = children[i3];
          if (child.label === label || label instanceof RegExp && label.test(child.label))
            return child;
        }
        if (deep) {
          for (let i3 = 0; i3 < children.length; i3++) {
            const child = children[i3];
            const found = child.getChildByLabel(label, true);
            if (found) {
              return found;
            }
          }
        }
        return null;
      },
      /**
       * Returns all children in the container with the specified label.
       * @method getChildrenByLabel
       * @memberof Container#
       * @param {string|RegExp} label - Instance label.
       * @param {boolean}[deep=false] - Whether to search recursively
       * @param {Container[]} [out=[]] - The array to store matching children in.
       * @returns {Container[]} An array of children with the specified label.
       */
      getChildrenByLabel(label, deep = false, out3 = []) {
        const children = this.children;
        for (let i3 = 0; i3 < children.length; i3++) {
          const child = children[i3];
          if (child.label === label || label instanceof RegExp && label.test(child.label)) {
            out3.push(child);
          }
        }
        if (deep) {
          for (let i3 = 0; i3 < children.length; i3++) {
            children[i3].getChildrenByLabel(label, true, out3);
          }
        }
        return out3;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs
var tempPoints, Rectangle;
var init_Rectangle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs"() {
    init_Point();
    tempPoints = [new Point(), new Point(), new Point(), new Point()];
    Rectangle = class _Rectangle {
      /**
       * @param x - The X coordinate of the upper-left corner of the rectangle
       * @param y - The Y coordinate of the upper-left corner of the rectangle
       * @param width - The overall width of the rectangle
       * @param height - The overall height of the rectangle
       */
      constructor(x3 = 0, y2 = 0, width = 0, height = 0) {
        this.type = "rectangle";
        this.x = Number(x3);
        this.y = Number(y2);
        this.width = Number(width);
        this.height = Number(height);
      }
      /** Returns the left edge of the rectangle. */
      get left() {
        return this.x;
      }
      /** Returns the right edge of the rectangle. */
      get right() {
        return this.x + this.width;
      }
      /** Returns the top edge of the rectangle. */
      get top() {
        return this.y;
      }
      /** Returns the bottom edge of the rectangle. */
      get bottom() {
        return this.y + this.height;
      }
      /** A constant empty rectangle. */
      static get EMPTY() {
        return new _Rectangle(0, 0, 0, 0);
      }
      /**
       * Creates a clone of this Rectangle
       * @returns a copy of the rectangle
       */
      clone() {
        return new _Rectangle(this.x, this.y, this.width, this.height);
      }
      /**
       * Converts a Bounds object to a Rectangle object.
       * @param bounds - The bounds to copy and convert to a rectangle.
       * @returns Returns itself.
       */
      copyFromBounds(bounds) {
        this.x = bounds.minX;
        this.y = bounds.minY;
        this.width = bounds.maxX - bounds.minX;
        this.height = bounds.maxY - bounds.minY;
        return this;
      }
      /**
       * Copies another rectangle to this one.
       * @param rectangle - The rectangle to copy from.
       * @returns Returns itself.
       */
      copyFrom(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
      }
      /**
       * Copies this rectangle to another one.
       * @param rectangle - The rectangle to copy to.
       * @returns Returns given parameter.
       */
      copyTo(rectangle) {
        rectangle.copyFrom(this);
        return rectangle;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this Rectangle
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coordinates are within this Rectangle
       */
      contains(x3, y2) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x3 >= this.x && x3 < this.x + this.width) {
          if (y2 >= this.y && y2 < this.y + this.height) {
            return true;
          }
        }
        return false;
      }
      /**
       * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
       * Returns true only if the area of the intersection is >0, this means that Rectangles
       * sharing a side are not overlapping. Another side effect is that an arealess rectangle
       * (width or height equal to zero) can't intersect any other rectangle.
       * @param {Rectangle} other - The Rectangle to intersect with `this`.
       * @param {Matrix} transform - The transformation matrix of `other`.
       * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
       */
      intersects(other, transform) {
        if (!transform) {
          const x02 = this.x < other.x ? other.x : this.x;
          const x12 = this.right > other.right ? other.right : this.right;
          if (x12 <= x02) {
            return false;
          }
          const y02 = this.y < other.y ? other.y : this.y;
          const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
          return y12 > y02;
        }
        const x0 = this.left;
        const x1 = this.right;
        const y0 = this.top;
        const y1 = this.bottom;
        if (x1 <= x0 || y1 <= y0) {
          return false;
        }
        const lt = tempPoints[0].set(other.left, other.top);
        const lb = tempPoints[1].set(other.left, other.bottom);
        const rt = tempPoints[2].set(other.right, other.top);
        const rb = tempPoints[3].set(other.right, other.bottom);
        if (rt.x <= lt.x || lb.y <= lt.y) {
          return false;
        }
        const s2 = Math.sign(transform.a * transform.d - transform.b * transform.c);
        if (s2 === 0) {
          return false;
        }
        transform.apply(lt, lt);
        transform.apply(lb, lb);
        transform.apply(rt, rt);
        transform.apply(rb, rb);
        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
          return false;
        }
        const nx = s2 * (lb.y - lt.y);
        const ny = s2 * (lt.x - lb.x);
        const n00 = nx * x0 + ny * y0;
        const n10 = nx * x1 + ny * y0;
        const n01 = nx * x0 + ny * y1;
        const n11 = nx * x1 + ny * y1;
        if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
          return false;
        }
        const mx = s2 * (lt.y - rt.y);
        const my = s2 * (rt.x - lt.x);
        const m00 = mx * x0 + my * y0;
        const m10 = mx * x1 + my * y0;
        const m01 = mx * x0 + my * y1;
        const m11 = mx * x1 + my * y1;
        if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
          return false;
        }
        return true;
      }
      /**
       * Pads the rectangle making it grow in all directions.
       * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
       * @param paddingX - The horizontal padding amount.
       * @param paddingY - The vertical padding amount.
       * @returns Returns itself.
       */
      pad(paddingX = 0, paddingY = paddingX) {
        this.x -= paddingX;
        this.y -= paddingY;
        this.width += paddingX * 2;
        this.height += paddingY * 2;
        return this;
      }
      /**
       * Fits this rectangle around the passed one.
       * @param rectangle - The rectangle to fit.
       * @returns Returns itself.
       */
      fit(rectangle) {
        const x1 = Math.max(this.x, rectangle.x);
        const x22 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
        const y1 = Math.max(this.y, rectangle.y);
        const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = Math.max(x22 - x1, 0);
        this.y = y1;
        this.height = Math.max(y2 - y1, 0);
        return this;
      }
      /**
       * Enlarges rectangle that way its corners lie on grid
       * @param resolution - resolution
       * @param eps - precision
       * @returns Returns itself.
       */
      ceil(resolution = 1, eps = 1e-3) {
        const x22 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
        const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
        this.x = Math.floor((this.x + eps) * resolution) / resolution;
        this.y = Math.floor((this.y + eps) * resolution) / resolution;
        this.width = x22 - this.x;
        this.height = y2 - this.y;
        return this;
      }
      /**
       * Enlarges this rectangle to include the passed rectangle.
       * @param rectangle - The rectangle to include.
       * @returns Returns itself.
       */
      enlarge(rectangle) {
        const x1 = Math.min(this.x, rectangle.x);
        const x22 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
        const y1 = Math.min(this.y, rectangle.y);
        const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = x22 - x1;
        this.y = y1;
        this.height = y2 - y1;
        return this;
      }
      /**
       * Returns the framing rectangle of the rectangle as a Rectangle object
       * @param out - optional rectangle to store the result
       * @returns The framing rectangle
       */
      getBounds(out3) {
        out3 = out3 || new _Rectangle();
        out3.copyFrom(this);
        return out3;
      }
      toString() {
        return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs
var Bounds;
var init_Bounds = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs"() {
    init_Matrix();
    init_Rectangle();
    Bounds = class _Bounds {
      constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
        this._matrixStack = [];
        this.matrix = new Matrix();
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      }
      get rectangle() {
        if (!this._rectangle) {
          this._rectangle = new Rectangle();
        }
        const rectangle = this._rectangle;
        if (this.minX > this.maxX || this.minY > this.maxY) {
          rectangle.x = 0;
          rectangle.y = 0;
          rectangle.width = 0;
          rectangle.height = 0;
        } else {
          rectangle.copyFromBounds(this);
        }
        return rectangle;
      }
      clear() {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
        this._matrixStack.length = 0;
        this.matrix.identity();
      }
      pushMatrix(matrix) {
        this._matrixStack.push(matrix);
        if (this._matrixStack.length > 1) {
          this.matrix.copyFrom(this._matrixStack[this._matrixStack.length - 2]);
          this.matrix.append(matrix);
        } else {
          this.matrix.copyFrom(matrix);
        }
      }
      popMatrix() {
        this._matrixStack.pop();
        if (this._matrixStack.length > 1) {
          this.matrix.copyFrom(this._matrixStack[this._matrixStack.length - 2]);
          this.matrix.append(this._matrixStack[this._matrixStack.length - 1]);
        } else if (this._matrixStack.length === 1) {
          this.matrix.copyFrom(this._matrixStack[0]);
        } else {
          this.matrix.identity();
        }
      }
      setMatrix(matrix) {
        this.matrix.copyFrom(matrix);
      }
      set(x0, y0, x1, y1) {
        this.minX = x0;
        this.minY = y0;
        this.maxX = x1;
        this.maxY = y1;
      }
      /**
       * Adds sprite frame
       * @param x0 - left X of frame
       * @param y0 - top Y of frame
       * @param x1 - right X of frame
       * @param y1 - bottom Y of frame
       */
      addFrame(x0, y0, x1, y1) {
        const matrix = this.matrix;
        const a2 = matrix.a;
        const b2 = matrix.b;
        const c2 = matrix.c;
        const d3 = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        let minX = this.minX;
        let minY = this.minY;
        let maxX = this.maxX;
        let maxY = this.maxY;
        let x3 = a2 * x0 + c2 * y0 + tx;
        let y2 = b2 * x0 + d3 * y0 + ty;
        minX = x3 < minX ? x3 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x3 > maxX ? x3 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x3 = a2 * x1 + c2 * y0 + tx;
        y2 = b2 * x1 + d3 * y0 + ty;
        minX = x3 < minX ? x3 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x3 > maxX ? x3 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x3 = a2 * x0 + c2 * y1 + tx;
        y2 = b2 * x0 + d3 * y1 + ty;
        minX = x3 < minX ? x3 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x3 > maxX ? x3 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x3 = a2 * x1 + c2 * y1 + tx;
        y2 = b2 * x1 + d3 * y1 + ty;
        minX = x3 < minX ? x3 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x3 > maxX ? x3 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      }
      addRect(rect) {
        this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height);
      }
      addBounds(bounds) {
        this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
      }
      addBoundsMask(mask2) {
        this.minX = this.minX > mask2.minX ? this.minX : mask2.minX;
        this.minY = this.minY > mask2.minY ? this.minY : mask2.minY;
        this.maxX = this.maxX < mask2.maxX ? this.maxX : mask2.maxX;
        this.maxY = this.maxY < mask2.maxY ? this.maxY : mask2.maxY;
      }
      applyMatrix(matrix) {
        const minX = this.minX;
        const minY = this.minY;
        const maxX = this.maxX;
        const maxY = this.maxY;
        const { a: a2, b: b2, c: c2, d: d3, tx, ty } = matrix;
        let x3 = a2 * minX + c2 * minY + tx;
        let y2 = b2 * minX + d3 * minY + ty;
        this.minX = x3;
        this.minY = y2;
        this.maxX = x3;
        this.maxY = y2;
        x3 = a2 * maxX + c2 * minY + tx;
        y2 = b2 * maxX + d3 * minY + ty;
        this.minX = x3 < this.minX ? x3 : this.minX;
        this.minY = y2 < this.minY ? y2 : this.minY;
        this.maxX = x3 > this.maxX ? x3 : this.maxX;
        this.maxY = y2 > this.maxY ? y2 : this.maxY;
        x3 = a2 * minX + c2 * maxY + tx;
        y2 = b2 * minX + d3 * maxY + ty;
        this.minX = x3 < this.minX ? x3 : this.minX;
        this.minY = y2 < this.minY ? y2 : this.minY;
        this.maxX = x3 > this.maxX ? x3 : this.maxX;
        this.maxY = y2 > this.maxY ? y2 : this.maxY;
        x3 = a2 * maxX + c2 * maxY + tx;
        y2 = b2 * maxX + d3 * maxY + ty;
        this.minX = x3 < this.minX ? x3 : this.minX;
        this.minY = y2 < this.minY ? y2 : this.minY;
        this.maxX = x3 > this.maxX ? x3 : this.maxX;
        this.maxY = y2 > this.maxY ? y2 : this.maxY;
      }
      fit(rect) {
        if (this.minX < rect.left)
          this.minX = rect.left;
        if (this.maxX > rect.right)
          this.maxX = rect.right;
        if (this.minY < rect.top)
          this.minY = rect.top;
        if (this.maxY > rect.bottom)
          this.maxY = rect.bottom;
        return this;
      }
      pad(paddingX, paddingY = paddingX) {
        this.minX -= paddingX;
        this.maxX += paddingX;
        this.minY -= paddingY;
        this.maxY += paddingY;
        return this;
      }
      ceil() {
        this.minX = Math.floor(this.minX);
        this.minY = Math.floor(this.minY);
        this.maxX = Math.ceil(this.maxX);
        this.maxY = Math.ceil(this.maxY);
        return this;
      }
      clone() {
        return new _Bounds(this.minX, this.minY, this.maxX, this.maxY);
      }
      scale(x3, y2 = x3) {
        this.minX *= x3;
        this.minY *= y2;
        this.maxX *= x3;
        this.maxY *= y2;
        return this;
      }
      get x() {
        return this.minX;
      }
      get y() {
        return this.minY;
      }
      get width() {
        return this.maxX - this.minX;
      }
      get height() {
        return this.maxY - this.minY;
      }
      get isPositive() {
        return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
      }
      get isValid() {
        return this.minX + this.minY !== Infinity;
      }
      /**
       * Adds screen vertices from array
       * @param vertexData - calculated vertices
       * @param beginOffset - begin offset
       * @param endOffset - end offset, excluded
       */
      addVertexData(vertexData, beginOffset, endOffset) {
        let minX = this.minX;
        let minY = this.minY;
        let maxX = this.maxX;
        let maxY = this.maxY;
        const matrix = this.matrix;
        const a2 = matrix.a;
        const b2 = matrix.b;
        const c2 = matrix.c;
        const d3 = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        for (let i3 = beginOffset; i3 < endOffset; i3 += 2) {
          const localX = vertexData[i3];
          const localY = vertexData[i3 + 1];
          const x3 = a2 * localX + c2 * localY + tx;
          const y2 = b2 * localX + d3 * localY + ty;
          minX = x3 < minX ? x3 : minX;
          minY = y2 < minY ? y2 : minY;
          maxX = x3 > maxX ? x3 : maxX;
          maxY = y2 > maxY ? y2 : maxY;
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      }
      toString() {
        return `[@pixi:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/utils/updateLocalTransform.mjs
function updateLocalTransform(lt, container) {
  const scale3 = container._scale;
  const pivot = container._pivot;
  const position = container._position;
  const sx = scale3._x;
  const sy = scale3._y;
  const px = pivot._x;
  const py = pivot._y;
  lt.a = container._cx * sx;
  lt.b = container._sx * sx;
  lt.c = container._cy * sy;
  lt.d = container._sy * sy;
  lt.tx = position._x - (px * lt.a + py * lt.c);
  lt.ty = position._y - (px * lt.b + py * lt.d);
}
var init_updateLocalTransform = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/utils/updateLocalTransform.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs
function getGlobalBounds(target, skipUpdateTransform, bounds) {
  bounds.clear();
  let parentTransform;
  if (target.parent) {
    if (!skipUpdateTransform) {
      parentTransform = updateTransformBackwards(target, new Matrix());
    } else {
      parentTransform = target.parent.worldTransform;
    }
  } else {
    parentTransform = Matrix.IDENTITY;
  }
  _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  return bounds;
}
function _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {
  if (!target.visible || !target.measurable)
    return;
  let worldTransform;
  if (!skipUpdateTransform) {
    if (target.didChange) {
      updateLocalTransform(target.localTransform, target);
    }
    worldTransform = Matrix.shared.appendFrom(target.localTransform, parentTransform).clone();
  } else {
    worldTransform = target.worldTransform;
  }
  const parentBounds = bounds;
  const preserveBounds = !!target.effects.length;
  if (preserveBounds) {
    bounds = bounds.clone();
  }
  if (target.view) {
    bounds.setMatrix(worldTransform);
    target.view.addBounds(bounds);
  }
  for (let i3 = 0; i3 < target.children.length; i3++) {
    _getGlobalBounds(target.children[i3], bounds, worldTransform, skipUpdateTransform);
  }
  if (preserveBounds) {
    for (let i3 = 0; i3 < target.effects.length; i3++) {
      target.effects[i3].addBounds?.(bounds);
    }
    parentBounds.setMatrix(Matrix.IDENTITY);
    parentBounds.addBounds(bounds);
  }
}
function updateTransformBackwards(target, parentTransform) {
  const parent = target.parent;
  if (parent) {
    updateTransformBackwards(parent, parentTransform);
    if (parent.didChange) {
      updateLocalTransform(parent.localTransform, parent);
    }
    parentTransform.append(parent.localTransform);
  }
  return parentTransform;
}
var init_getGlobalBounds = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs"() {
    init_Matrix();
    init_updateLocalTransform();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/logging/warn.mjs
function warn(...args) {
  if (warnCount === maxWarnings)
    return;
  warnCount++;
  if (warnCount === maxWarnings) {
    console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");
  } else {
    console.warn("PixiJS Warning: ", ...args);
  }
}
var warnCount, maxWarnings;
var init_warn = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/logging/warn.mjs"() {
    warnCount = 0;
    maxWarnings = 500;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs
function getLocalBounds(target, bounds, relativeMatrix) {
  bounds.clear();
  relativeMatrix || (relativeMatrix = new Matrix());
  if (target.view) {
    bounds.setMatrix(relativeMatrix);
    target.view.addBounds(bounds);
  }
  for (let i3 = 0; i3 < target.children.length; i3++) {
    _getLocalBounds(target.children[i3], bounds, relativeMatrix, target);
  }
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  return bounds;
}
function _getLocalBounds(target, bounds, parentTransform, rootContainer) {
  if (!target.visible || !target.measurable)
    return;
  if (target.didChange) {
    updateLocalTransform(target.localTransform, target);
  }
  const localTransform = target.localTransform;
  const relativeTransform = Matrix.shared.appendFrom(localTransform, parentTransform).clone();
  const parentBounds = bounds;
  const preserveBounds = !!target.effects.length;
  if (preserveBounds) {
    bounds = new Bounds();
  }
  if (target.view) {
    bounds.setMatrix(relativeTransform);
    target.view.addBounds(bounds);
  }
  for (let i3 = 0; i3 < target.children.length; i3++) {
    _getLocalBounds(target.children[i3], bounds, relativeTransform, rootContainer);
  }
  if (preserveBounds) {
    for (let i3 = 0; i3 < target.effects.length; i3++) {
      target.effects[i3].addLocalBounds?.(bounds, rootContainer);
    }
    parentBounds.setMatrix(Matrix.IDENTITY);
    parentBounds.addBounds(bounds);
  }
}
var init_getLocalBounds = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs"() {
    init_Matrix();
    init_updateLocalTransform();
    init_Bounds();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs
var tempBounds, tempMatrix2, measureMixin;
var init_measureMixin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs"() {
    init_Matrix();
    init_Bounds();
    init_getGlobalBounds();
    init_getLocalBounds();
    tempBounds = new Bounds();
    tempMatrix2 = new Matrix();
    measureMixin = {
      get width() {
        return Math.abs(this.scale.x * getLocalBounds(this, tempBounds, tempMatrix2).width);
      },
      set width(value) {
        const localWidth = getLocalBounds(this, tempBounds, tempMatrix2).width;
        if (localWidth !== 0) {
          this.scale.x = value / localWidth;
        } else {
          this.scale.x = 1;
        }
      },
      get height() {
        return Math.abs(this.scale.y * getLocalBounds(this, tempBounds, tempMatrix2).height);
      },
      set height(value) {
        const localHeight = getLocalBounds(this, tempBounds, tempMatrix2).height;
        if (localHeight !== 0) {
          this.scale.y = value / localHeight;
        } else {
          this.scale.y = 1;
        }
      },
      /**
       * Retrieves the local bounds of the container as a Bounds object.
       * @param rect - Optional rectangle to store the result of the bounds calculation.
       * @returns - The bounding area.
       */
      getLocalBounds(rect) {
        const bounds = getLocalBounds(this, new Bounds(), tempMatrix2);
        return rect ? rect.copyFromBounds(bounds) : bounds.rectangle.clone();
      },
      /**
       * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.
       * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from
       *  being updated. This means the calculation returned MAY be out of date BUT will give you a
       *  nice performance boost.
       * @param rect - Optional rectangle to store the result of the bounds calculation.
       * @returns - The minimum axis-aligned rectangle in world space that fits around this object.
       */
      getBounds(skipUpdate, rect) {
        const bounds = getGlobalBounds(this, skipUpdate, tempBounds);
        return rect ? rect.copyFromBounds(bounds) : bounds.rectangle.clone();
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs
var onRenderMixin;
var init_onRenderMixin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs"() {
    onRenderMixin = {
      _onRender: null,
      set onRender(func2) {
        const layerGroup = this.layerGroup;
        if (!func2) {
          if (this._onRender) {
            layerGroup?.removeOnRender(this);
          }
          this._onRender = null;
          return;
        }
        if (!this._onRender) {
          layerGroup?.addOnRender(this);
        }
        this._onRender = func2;
      },
      get onRender() {
        return this._onRender;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs
function sortChildren(a2, b2) {
  return a2._zIndex - b2._zIndex;
}
var sortMixin;
var init_sortMixin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs"() {
    sortMixin = {
      _zIndex: 0,
      sortDirty: false,
      sortableChildren: false,
      get zIndex() {
        return this._zIndex;
      },
      /** The depth of the object. Setting this value, will automatically set the parent to be sortable */
      set zIndex(value) {
        if (this._zIndex === value)
          return;
        this._zIndex = value;
        this.depthOfChildModified();
      },
      depthOfChildModified() {
        if (this.parent) {
          this.parent.sortableChildren = true;
          this.parent.sortDirty = true;
        }
        if (this.layerGroup && !this.isLayerRoot) {
          this.layerGroup.structureDidChange = true;
        }
      },
      sortChildren() {
        if (!this.sortDirty)
          return;
        this.sortDirty = false;
        this.children.sort(sortChildren);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs
var toLocalGlobalMixin;
var init_toLocalGlobalMixin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs"() {
    init_Matrix();
    init_Point();
    init_getGlobalBounds();
    init_updateLocalTransform();
    toLocalGlobalMixin = {
      /**
       * Returns the global position of the container.
       * @param point - The optional point to write the global value to.
       * @param skipUpdate - Should we skip the update transform.
       * @returns - The updated point.
       * @memberof Container#
       */
      getGlobalPosition(point = new Point(), skipUpdate = false) {
        if (this.parent) {
          this.parent.toGlobal(this._position, point, skipUpdate);
        } else {
          point.x = this._position.x;
          point.y = this._position.y;
        }
        return point;
      },
      /**
       * Calculates the global position of the container.
       * @param position - The world origin to calculate from.
       * @param point - A Point object in which to store the value, optional
       *  (otherwise will create a new Point).
       * @param skipUpdate - Should we skip the update transform.
       * @returns - A point object representing the position of this object.
       * @memberof Container#
       */
      toGlobal(position, point, skipUpdate = false) {
        if (!skipUpdate) {
          if (this.didChange) {
            updateLocalTransform(this.localTransform, this);
          }
          const globalMatrix = updateTransformBackwards(this, new Matrix());
          globalMatrix.append(this.localTransform);
          return globalMatrix.apply(position, point);
        }
        return this.worldTransform.apply(position, point);
      },
      /**
       * Calculates the local position of the container relative to another point.
       * @param position - The world origin to calculate from.
       * @param from - The Container to calculate the global position from.
       * @param point - A Point object in which to store the value, optional
       *  (otherwise will create a new Point).
       * @param skipUpdate - Should we skip the update transform
       * @returns - A point object representing the position of this object
       * @memberof Container#
       */
      toLocal(position, from, point, skipUpdate) {
        if (from) {
          position = from.toGlobal(position, point, skipUpdate);
        }
        if (!skipUpdate) {
          if (this.didChange) {
            updateLocalTransform(this.localTransform, this);
          }
          const globalMatrix = updateTransformBackwards(this, new Matrix());
          globalMatrix.append(this.localTransform);
          return globalMatrix.applyInverse(position, point);
        }
        return this.worldTransform.applyInverse(position, point);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs
var InstructionSet;
var init_InstructionSet = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs"() {
    init_uid();
    InstructionSet = class {
      constructor() {
        this.uid = uid("instructionSet");
        this.instructions = [];
        this.instructionSize = 0;
      }
      reset() {
        this.instructionSize = 0;
      }
      add(instruction) {
        this.instructions[this.instructionSize++] = instruction;
      }
      log() {
        this.instructions.length = this.instructionSize;
        console.table(this.instructions, ["type", "action"]);
      }
      lastInstruction() {
        return this.instructions[this.instructionSize - 1];
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/LayerGroup.mjs
var LayerGroup;
var init_LayerGroup = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/LayerGroup.mjs"() {
    init_Matrix();
    init_InstructionSet();
    LayerGroup = class {
      constructor(root) {
        this.type = "layer";
        this.root = null;
        this.canBundle = false;
        this.layerGroupParent = null;
        this.layerGroupChildren = [];
        this._children = [];
        this.worldTransform = new Matrix();
        this.worldColor = 4294967295;
        this.childrenToUpdate = /* @__PURE__ */ Object.create(null);
        this.updateTick = 0;
        this.childrenRenderablesToUpdate = { list: [], index: 0 };
        this.structureDidChange = true;
        this.instructionSet = new InstructionSet();
        this._onRenderContainers = [];
        this.root = root;
        this.addChild(root);
      }
      get localTransform() {
        return this.root.localTransform;
      }
      get layerTransform() {
        return this.root.layerTransform;
      }
      addLayerGroupChild(layerGroupChild) {
        if (layerGroupChild.layerGroupParent) {
          layerGroupChild.layerGroupParent._removeLayerGroupChild(layerGroupChild);
        }
        layerGroupChild.layerGroupParent = this;
        this.onChildUpdate(layerGroupChild.root);
        this.layerGroupChildren.push(layerGroupChild);
      }
      _removeLayerGroupChild(layerGroupChild) {
        if (layerGroupChild.root.didChange) {
          this._removeChildFromUpdate(layerGroupChild.root);
        }
        const index = this.layerGroupChildren.indexOf(layerGroupChild);
        if (index > -1) {
          this.layerGroupChildren.splice(index, 1);
        }
        layerGroupChild.layerGroupParent = null;
      }
      addChild(child) {
        this.structureDidChange = true;
        if (child !== this.root) {
          this._children.push(child);
          child.updateTick = -1;
          if (child.parent === this.root) {
            child.relativeLayerDepth = 1;
          } else {
            child.relativeLayerDepth = child.parent.relativeLayerDepth + 1;
          }
          if (child._onRender) {
            this.addOnRender(child);
          }
        }
        if (child.layerGroup) {
          if (child.layerGroup.root === child) {
            this.addLayerGroupChild(child.layerGroup);
            return;
          }
        } else {
          child.layerGroup = this;
          child.didChange = true;
        }
        const children = child.children;
        if (!child.isLayerRoot) {
          this.onChildUpdate(child);
        }
        for (let i3 = 0; i3 < children.length; i3++) {
          this.addChild(children[i3]);
        }
      }
      removeChild(child) {
        this.structureDidChange = true;
        if (child._onRender) {
          this.removeOnRender(child);
        }
        if (child.layerGroup.root !== child) {
          const children = child.children;
          for (let i3 = 0; i3 < children.length; i3++) {
            this.removeChild(children[i3]);
          }
          if (child.didChange) {
            child.layerGroup._removeChildFromUpdate(child);
          }
          child.layerGroup = null;
        } else {
          this._removeLayerGroupChild(child.layerGroup);
        }
        const index = this._children.indexOf(child);
        if (index > -1) {
          this._children.splice(index, 1);
        }
      }
      onChildUpdate(child) {
        let childrenToUpdate = this.childrenToUpdate[child.relativeLayerDepth];
        if (!childrenToUpdate) {
          childrenToUpdate = this.childrenToUpdate[child.relativeLayerDepth] = {
            index: 0,
            list: []
          };
        }
        childrenToUpdate.list[childrenToUpdate.index++] = child;
      }
      // SHOULD THIS BE HERE?
      updateRenderable(container) {
        if (container.layerVisibleRenderable < 3)
          return;
        container.didViewUpdate = false;
        this.instructionSet.renderPipes[container.view.renderPipeId].updateRenderable(container);
      }
      onChildViewUpdate(child) {
        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;
      }
      _removeChildFromUpdate(child) {
        const childrenToUpdate = this.childrenToUpdate[child.relativeLayerDepth];
        if (!childrenToUpdate) {
          return;
        }
        const index = childrenToUpdate.list.indexOf(child);
        if (index > -1) {
          childrenToUpdate.list.splice(index, 1);
        }
        childrenToUpdate.index--;
      }
      get isRenderable() {
        const worldAlpha = this.worldColor >> 24 & 255;
        return this.root.localVisibleRenderable === 3 && worldAlpha > 0;
      }
      /**
       * adding a container to the onRender list will make sure the user function
       * passed in to the user defined 'onRender` callBack
       * @param container - the container to add to the onRender list
       */
      addOnRender(container) {
        this._onRenderContainers.push(container);
      }
      removeOnRender(container) {
        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);
      }
      runOnRender() {
        this._onRenderContainers.forEach((container) => {
          container._onRender();
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs
function definedProps(obj) {
  return Object.fromEntries(
    Object.entries(obj).filter(([_k, v3]) => v3 !== void 0)
  );
}
var init_definedProps = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/Container.mjs
var defaultSkew, defaultPivot, defaultScale, UPDATE_COLOR, UPDATE_BLEND, UPDATE_VISIBLE, Container;
var init_Container = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/Container.mjs"() {
    init_eventemitter3();
    init_Color();
    init_Matrix();
    init_const();
    init_ObservablePoint();
    init_uid();
    init_deprecation();
    init_childrenHelperMixin();
    init_effectsMixin();
    init_findMixin();
    init_measureMixin();
    init_onRenderMixin();
    init_sortMixin();
    init_toLocalGlobalMixin();
    init_LayerGroup();
    init_definedProps();
    defaultSkew = new ObservablePoint(null);
    defaultPivot = new ObservablePoint(null);
    defaultScale = new ObservablePoint(null, 1, 1);
    UPDATE_COLOR = 1;
    UPDATE_BLEND = 2;
    UPDATE_VISIBLE = 4;
    Container = class _Container extends eventemitter3_default {
      constructor(options = {}) {
        super();
        this.uid = uid("renderable");
        this._updateFlags = 15;
        this.isLayerRoot = false;
        this.layerGroup = null;
        this.didChange = false;
        this.didViewUpdate = false;
        this.relativeLayerDepth = 0;
        this.children = [];
        this.parent = null;
        this.includeInBuild = true;
        this.measurable = true;
        this.isSimple = true;
        this.updateTick = -1;
        this.localTransform = new Matrix();
        this.layerTransform = new Matrix();
        this.destroyed = false;
        this._position = new ObservablePoint(this, 0, 0);
        this._scale = defaultScale;
        this._pivot = defaultPivot;
        this._skew = defaultSkew;
        this._cx = 1;
        this._sx = 0;
        this._cy = 0;
        this._sy = 1;
        this._rotation = 0;
        this.localColor = 4294967295;
        this.layerColor = 4294967295;
        this.localBlendMode = "inherit";
        this.layerBlendMode = "normal";
        this.localVisibleRenderable = 3;
        this.layerVisibleRenderable = 3;
        if (options.view) {
          this.view = options.view;
          this.view.owner = this;
          options.view = void 0;
        }
        Object.assign(this, definedProps(options));
        this.children = [];
        options.children?.forEach((child) => this.addChild(child));
        this.effects = [];
        options.effects?.forEach((effect) => this.addEffect(effect));
      }
      /**
       * Mixes all enumerable properties and methods from a source object to Container.
       * @param source - The source of properties and methods to mix in.
       */
      static mixin(source3) {
        Object.defineProperties(_Container.prototype, Object.getOwnPropertyDescriptors(source3));
      }
      /**
       * Adds one or more children to the container.
       *
       * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
       * @param {...Container} children - The Container(s) to add to the container
       * @returns {Container} - The first child that was added.
       */
      addChild(...children) {
        if (!this.allowChildren) {
          deprecation(v8_0_0, "addChild: Only Containers will be allowed to add children in v8.0.0");
        }
        if (children.length > 1) {
          for (let i3 = 0; i3 < children.length; i3++) {
            this.addChild(children[i3]);
          }
          return children[0];
        }
        const child = children[0];
        if (child.parent === this) {
          this.children.splice(this.children.indexOf(child), 1);
          this.children.push(child);
          if (this.layerGroup && !this.isLayerRoot) {
            this.layerGroup.structureDidChange = true;
          }
          return child;
        }
        if (child.parent) {
          child.parent.removeChild(child);
        }
        this.children.push(child);
        if (this.sortableChildren)
          this.sortDirty = true;
        child.parent = this;
        child.didChange = true;
        child.didViewUpdate = false;
        child._updateFlags = 15;
        if (this.layerGroup) {
          this.layerGroup.addChild(child);
        }
        this.emit("childAdded", child, this, this.children.length - 1);
        child.emit("added", this);
        if (child._zIndex !== 0) {
          child.depthOfChildModified();
        }
        return child;
      }
      /**
       * Removes one or more children from the container.
       * @param {...Container} children - The Container(s) to remove
       * @returns {Container} The first child that was removed.
       */
      removeChild(...children) {
        if (children.length > 1) {
          for (let i3 = 0; i3 < children.length; i3++) {
            this.removeChild(children[i3]);
          }
          return children[0];
        }
        const child = children[0];
        const index = this.children.indexOf(child);
        if (index > -1) {
          this.children.splice(index, 1);
          if (this.layerGroup) {
            this.layerGroup.removeChild(child);
          }
        }
        child.parent = null;
        this.emit("childRemoved", child, this, index);
        child.emit("removed", this);
        return child;
      }
      /**
       * @param point
       * @internal
       */
      onUpdate(point) {
        if (point) {
          if (point === this._skew) {
            this._updateSkew();
          }
        }
        if (this.didChange)
          return;
        this.didChange = true;
        if (this.isLayerRoot) {
          const layerGroupParent = this.layerGroup.layerGroupParent;
          if (layerGroupParent) {
            layerGroupParent.onChildUpdate(this);
          }
        } else if (this.layerGroup) {
          this.layerGroup.onChildUpdate(this);
        }
      }
      /** @internal */
      onViewUpdate() {
        if (this.didViewUpdate)
          return;
        this.didViewUpdate = true;
        if (this.layerGroup) {
          this.layerGroup.onChildViewUpdate(this);
        }
      }
      set layer(value) {
        if (this.isLayerRoot && value === false) {
          throw new Error("[Pixi] cannot undo a layer just yet");
        }
        if (value) {
          this.enableLayer();
        }
      }
      get layer() {
        return this.isLayerRoot;
      }
      enableLayer() {
        if (this.layerGroup && this.layerGroup.root === this)
          return;
        this.isLayerRoot = true;
        const parentLayerGroup = this.layerGroup;
        if (parentLayerGroup) {
          parentLayerGroup.removeChild(this);
        }
        this.layerGroup = new LayerGroup(this);
        if (parentLayerGroup) {
          for (let i3 = 0; i3 < parentLayerGroup.layerGroupChildren.length; i3++) {
            const childLayerGroup = parentLayerGroup.layerGroupChildren[i3];
            let parent = childLayerGroup.root;
            while (parent) {
              if (parent === this) {
                this.layerGroup.addLayerGroupChild(childLayerGroup);
                break;
              }
              parent = parent.parent;
            }
          }
          parentLayerGroup.addLayerGroupChild(this.layerGroup);
        }
        this._updateIsSimple();
      }
      /**
       * @ignore
       */
      _updateIsSimple() {
        this.isSimple = !this.isLayerRoot && this.effects.length === 0;
      }
      get worldTransform() {
        this._worldTransform || (this._worldTransform = new Matrix());
        if (this.layerGroup) {
          if (this.isLayerRoot) {
            this._worldTransform.copyFrom(this.layerGroup.worldTransform);
          } else {
            this._worldTransform.appendFrom(this.layerTransform, this.layerGroup.worldTransform);
          }
        }
        return this._worldTransform;
      }
      /// ////// transform related stuff
      /**
       * The position of the container on the x axis relative to the local coordinates of the parent.
       * An alias to position.x
       */
      get x() {
        return this._position.x;
      }
      set x(value) {
        this._position.x = value;
      }
      /**
       * The position of the container on the y axis relative to the local coordinates of the parent.
       * An alias to position.y
       */
      get y() {
        return this._position.y;
      }
      set y(value) {
        this._position.y = value;
      }
      get position() {
        return this._position;
      }
      set position(value) {
        this._position.copyFrom(value);
      }
      /**
       * The rotation of the object in radians.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get rotation() {
        return this._rotation;
      }
      set rotation(value) {
        if (this._rotation !== value) {
          this._rotation = value;
          this.onUpdate(this._skew);
        }
      }
      /**
       * The angle of the object in degrees.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get angle() {
        return this.rotation * RAD_TO_DEG;
      }
      set angle(value) {
        this.rotation = value * DEG_TO_RAD;
      }
      get pivot() {
        if (this._pivot === defaultPivot) {
          this._pivot = new ObservablePoint(this, 0, 0);
        }
        return this._pivot;
      }
      set pivot(value) {
        if (this._pivot === defaultPivot) {
          this._pivot = new ObservablePoint(this, 0, 0);
        }
        this._pivot.copyFrom(value);
      }
      get skew() {
        if (this._skew === defaultSkew) {
          this._skew = new ObservablePoint(this, 0, 0);
        }
        return this._skew;
      }
      get scale() {
        if (this._scale === defaultScale) {
          this._scale = new ObservablePoint(this, 1, 1);
        }
        return this._scale;
      }
      set scale(value) {
        if (this._scale === defaultScale) {
          this._scale = new ObservablePoint(this, 0, 0);
        }
        this._scale.copyFrom(value);
      }
      /** Called when the skew or the rotation changes. */
      _updateSkew() {
        const rotation = this._rotation;
        const skew = this._skew;
        this._cx = Math.cos(rotation + skew._y);
        this._sx = Math.sin(rotation + skew._y);
        this._cy = -Math.sin(rotation - skew._x);
        this._sy = Math.cos(rotation - skew._x);
      }
      /// ///// color related stuff
      set alpha(value) {
        value = value * 255 | 0;
        if (value === (this.localColor >> 24 & 255))
          return;
        this.localColor = this.localColor & 16777215 | value << 24;
        this._updateFlags |= UPDATE_COLOR;
        this.onUpdate();
      }
      get alpha() {
        return (this.localColor >> 24 & 255) / 255;
      }
      set tint(value) {
        const tempColor = Color.shared.setValue(value);
        const bgr = tempColor.toBgrNumber();
        if (bgr === (this.localColor & 16777215))
          return;
        this.localColor = this.localColor & 4278190080 | bgr & 16777215;
        this._updateFlags |= UPDATE_COLOR;
        this.onUpdate();
      }
      get tint() {
        const bgr = this.localColor & 16777215;
        return ((bgr & 255) << 16) + (bgr & 65280) + (bgr >> 16 & 255);
      }
      /// //////////////// blend related stuff
      set blendMode(value) {
        if (this.localBlendMode === value)
          return;
        if (this.layerGroup && !this.isLayerRoot) {
          this.layerGroup.structureDidChange = true;
        }
        this._updateFlags |= UPDATE_BLEND;
        this.localBlendMode = value;
        this.onUpdate();
      }
      get blendMode() {
        return this.localBlendMode;
      }
      /// ///////// VISIBILITY / RENDERABLE /////////////////
      get visible() {
        return !!(this.localVisibleRenderable & 2);
      }
      // visible -  the renderable is not shown, also the transform is not updated
      set visible(value) {
        const valueNumber = value ? 1 : 0;
        if ((this.localVisibleRenderable & 2) >> 1 === valueNumber)
          return;
        if (this.layerGroup && !this.isLayerRoot) {
          this.layerGroup.structureDidChange = true;
        }
        this._updateFlags |= UPDATE_VISIBLE;
        this.localVisibleRenderable = this.localVisibleRenderable & 1 | valueNumber << 1;
        this.onUpdate();
      }
      get renderable() {
        return !!(this.localVisibleRenderable & 1);
      }
      set renderable(value) {
        const valueNumber = value ? 1 : 0;
        if ((this.localVisibleRenderable & 1) === valueNumber)
          return;
        this.localVisibleRenderable = this.localVisibleRenderable & 2 | valueNumber;
        this._updateFlags |= UPDATE_VISIBLE;
        if (this.layerGroup && !this.isLayerRoot) {
          this.layerGroup.structureDidChange = true;
        }
        this.onUpdate();
      }
      get isRenderable() {
        const worldAlpha = this.layerColor >> 24 & 255;
        return this.localVisibleRenderable === 3 && worldAlpha > 0;
      }
      /**
       * Removes all internal references and listeners as well as removes children from the display list.
       * Do not use a Container after calling `destroy`.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
       *  method called as well. 'options' will be passed on to those calls.
       * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children
       * is set to true it should destroy the texture of the child sprite
       * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
       * If options.children is set to true it should destroy the texture source of the child sprite
       * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
       * If options.children is set to true it should destroy the context of the child graphics
       */
      destroy(options = false) {
        if (this.destroyed)
          return;
        this.destroyed = true;
        this.removeFromParent();
        this.parent = null;
        this._mask = null;
        this._filters = null;
        this.effects = null;
        this._position = null;
        this._scale = null;
        this._pivot = null;
        this._skew = null;
        this.emit("destroyed");
        this.removeAllListeners();
        const destroyChildren = typeof options === "boolean" ? options : options?.children;
        const oldChildren = this.removeChildren(0, this.children.length);
        if (destroyChildren) {
          for (let i3 = 0; i3 < oldChildren.length; ++i3) {
            oldChildren[i3].destroy(options);
          }
        }
        if (this.view) {
          this.view.destroy(options);
          this.view.owner = null;
        }
      }
    };
    Container.mixin(childrenHelperMixin);
    Container.mixin(toLocalGlobalMixin);
    Container.mixin(onRenderMixin);
    Container.mixin(measureMixin);
    Container.mixin(effectsMixin);
    Container.mixin(findMixin);
    Container.mixin(sortMixin);
  }
});

// ../../node_modules/.pnpm/ismobilejs@1.1.1/node_modules/ismobilejs/esm/isMobile.js
function createMatch(userAgent) {
  return function(regex) {
    return regex.test(userAgent);
  };
}
function isMobile(param) {
  var nav = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  if (!param && typeof navigator !== "undefined") {
    nav = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      maxTouchPoints: navigator.maxTouchPoints || 0
    };
  } else if (typeof param === "string") {
    nav.userAgent = param;
  } else if (param && param.userAgent) {
    nav = {
      userAgent: param.userAgent,
      platform: param.platform,
      maxTouchPoints: param.maxTouchPoints || 0
    };
  }
  var userAgent = nav.userAgent;
  var tmp = userAgent.split("[FBAN");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  tmp = userAgent.split("Twitter");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  var match = createMatch(userAgent);
  var result = {
    apple: {
      phone: match(appleIphone) && !match(windowsPhone),
      ipod: match(appleIpod),
      tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
      universal: match(appleUniversal),
      device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
    },
    amazon: {
      phone: match(amazonPhone),
      tablet: !match(amazonPhone) && match(amazonTablet),
      device: match(amazonPhone) || match(amazonTablet)
    },
    android: {
      phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
      tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
      device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
    },
    windows: {
      phone: match(windowsPhone),
      tablet: match(windowsTablet),
      device: match(windowsPhone) || match(windowsTablet)
    },
    other: {
      blackberry: match(otherBlackBerry),
      blackberry10: match(otherBlackBerry10),
      opera: match(otherOpera),
      firefox: match(otherFirefox),
      chrome: match(otherChrome),
      device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
    },
    any: false,
    phone: false,
    tablet: false
  };
  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
  result.phone = result.apple.phone || result.android.phone || result.windows.phone;
  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
  return result;
}
var appleIphone, appleIpod, appleTablet, appleUniversal, androidPhone, androidTablet, amazonPhone, amazonTablet, windowsPhone, windowsTablet, otherBlackBerry, otherBlackBerry10, otherOpera, otherChrome, otherFirefox, isAppleTabletOnIos13;
var init_isMobile = __esm({
  "../../node_modules/.pnpm/ismobilejs@1.1.1/node_modules/ismobilejs/esm/isMobile.js"() {
    appleIphone = /iPhone/i;
    appleIpod = /iPod/i;
    appleTablet = /iPad/i;
    appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
    androidPhone = /\bAndroid(?:.+)Mobile\b/i;
    androidTablet = /Android/i;
    amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
    amazonTablet = /Silk/i;
    windowsPhone = /Windows Phone/i;
    windowsTablet = /\bWindows(?:.+)ARM\b/i;
    otherBlackBerry = /BlackBerry/i;
    otherBlackBerry10 = /BB10/i;
    otherOpera = /Opera Mini/i;
    otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
    otherFirefox = /Mobile(?:.+)Firefox\b/i;
    isAppleTabletOnIos13 = function(navigator2) {
      return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
    };
  }
});

// ../../node_modules/.pnpm/ismobilejs@1.1.1/node_modules/ismobilejs/esm/index.js
var init_esm = __esm({
  "../../node_modules/.pnpm/ismobilejs@1.1.1/node_modules/ismobilejs/esm/index.js"() {
    init_isMobile();
    init_isMobile();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/settings/utils/isMobile.mjs
var isMobileCall, isMobile2;
var init_isMobile2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/settings/utils/isMobile.mjs"() {
    init_esm();
    isMobileCall = isMobile.default ?? isMobile;
    isMobile2 = isMobileCall(globalThis.navigator);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs
var accessibilityTarget;
var init_accessibilityTarget = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs"() {
    accessibilityTarget = {
      /**
       *  Flag for if the object is accessible. If true AccessibilityManager will overlay a
       *   shadow div with attributes set
       * @member {boolean}
       * @memberof Container#
       */
      accessible: false,
      /**
       * Sets the title attribute of the shadow div
       * If accessibleTitle AND accessibleHint has not been this will default to 'container [tabIndex]'
       * @member {?string}
       * @memberof Container#
       */
      accessibleTitle: null,
      /**
       * Sets the aria-label attribute of the shadow div
       * @member {string}
       * @memberof Container#
       */
      accessibleHint: null,
      /**
       * @member {number}
       * @memberof Container#
       * @private
       * @todo Needs docs.
       */
      tabIndex: 0,
      /**
       * @member {boolean}
       * @memberof Container#
       * @todo Needs docs.
       */
      _accessibleActive: false,
      /**
       * @member {boolean}
       * @memberof Container#
       * @todo Needs docs.
       */
      _accessibleDiv: null,
      /**
       * Specify the type of div the accessible layer is. Screen readers treat the element differently
       * depending on this type. Defaults to button.
       * @member {string}
       * @memberof Container#
       * @default 'button'
       */
      accessibleType: "button",
      /**
       * Specify the pointer-events the accessible div will use
       * Defaults to auto.
       * @member {string}
       * @memberof Container#
       * @default 'auto'
       */
      accessiblePointerEvents: "auto",
      /**
       * Setting to false will prevent any children inside this container to
       * be accessible. Defaults to true.
       * @member {boolean}
       * @memberof Container#
       * @default true
       */
      accessibleChildren: true,
      renderId: -1
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs
var KEY_CODE_TAB, DIV_TOUCH_SIZE, DIV_TOUCH_POS_X, DIV_TOUCH_POS_Y, DIV_TOUCH_ZINDEX, DIV_HOOK_SIZE, DIV_HOOK_POS_X, DIV_HOOK_POS_Y, DIV_HOOK_ZINDEX, AccessibilitySystem;
var init_AccessibilitySystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs"() {
    init_FederatedEvent();
    init_Extensions();
    init_Container();
    init_isMobile2();
    init_removeItems();
    init_accessibilityTarget();
    Container.mixin(accessibilityTarget);
    KEY_CODE_TAB = 9;
    DIV_TOUCH_SIZE = 100;
    DIV_TOUCH_POS_X = 0;
    DIV_TOUCH_POS_Y = 0;
    DIV_TOUCH_ZINDEX = 2;
    DIV_HOOK_SIZE = 1;
    DIV_HOOK_POS_X = -1e3;
    DIV_HOOK_POS_Y = -1e3;
    DIV_HOOK_ZINDEX = 2;
    AccessibilitySystem = class {
      // 2fps
      // eslint-disable-next-line jsdoc/require-param
      /**
       * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer
       */
      // eslint-disable-next-line @typescript-eslint/no-parameter-properties
      constructor(renderer, _mobileInfo = isMobile2) {
        this._mobileInfo = _mobileInfo;
        this.debug = false;
        this._isActive = false;
        this._isMobileAccessibility = false;
        this._pool = [];
        this._renderId = 0;
        this._children = [];
        this._androidUpdateCount = 0;
        this._androidUpdateFrequency = 500;
        this._hookDiv = null;
        if (_mobileInfo.tablet || _mobileInfo.phone) {
          this._createTouchHook();
        }
        const div = document.createElement("div");
        div.style.width = `${DIV_TOUCH_SIZE}px`;
        div.style.height = `${DIV_TOUCH_SIZE}px`;
        div.style.position = "absolute";
        div.style.top = `${DIV_TOUCH_POS_X}px`;
        div.style.left = `${DIV_TOUCH_POS_Y}px`;
        div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
        this._div = div;
        this._renderer = renderer;
        this._onKeyDown = this._onKeyDown.bind(this);
        this._onMouseMove = this._onMouseMove.bind(this);
        globalThis.addEventListener("keydown", this._onKeyDown, false);
      }
      /**
       * Value of `true` if accessibility is currently active and accessibility layers are showing.
       * @member {boolean}
       * @readonly
       */
      get isActive() {
        return this._isActive;
      }
      /**
       * Value of `true` if accessibility is enabled for touch devices.
       * @member {boolean}
       * @readonly
       */
      get isMobileAccessibility() {
        return this._isMobileAccessibility;
      }
      get hookDiv() {
        return this._hookDiv;
      }
      /**
       * Creates the touch hooks.
       * @private
       */
      _createTouchHook() {
        const hookDiv = document.createElement("button");
        hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
        hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
        hookDiv.style.position = "absolute";
        hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
        hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
        hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
        hookDiv.style.backgroundColor = "#FF0000";
        hookDiv.title = "select to enable accessibility for this content";
        hookDiv.addEventListener("focus", () => {
          this._isMobileAccessibility = true;
          this._activate();
          this._destroyTouchHook();
        });
        document.body.appendChild(hookDiv);
        this._hookDiv = hookDiv;
      }
      /**
       * Destroys the touch hooks.
       * @private
       */
      _destroyTouchHook() {
        if (!this._hookDiv) {
          return;
        }
        document.body.removeChild(this._hookDiv);
        this._hookDiv = null;
      }
      /**
       * Activating will cause the Accessibility layer to be shown.
       * This is called when a user presses the tab key.
       * @private
       */
      _activate() {
        if (this._isActive) {
          return;
        }
        this._isActive = true;
        globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
        globalThis.removeEventListener("keydown", this._onKeyDown, false);
        this._renderer.runners.postrender.add(this);
        this._renderer.view.canvas.parentNode?.appendChild(this._div);
      }
      /**
       * Deactivating will cause the Accessibility layer to be hidden.
       * This is called when a user moves the mouse.
       * @private
       */
      _deactivate() {
        if (!this._isActive || this._isMobileAccessibility) {
          return;
        }
        this._isActive = false;
        globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
        globalThis.addEventListener("keydown", this._onKeyDown, false);
        this._renderer.runners.postrender.remove(this);
        this._div.parentNode?.removeChild(this._div);
      }
      /**
       * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
       * @private
       * @param {Container} container - The Container to check.
       */
      _updateAccessibleObjects(container) {
        if (!container.visible || !container.accessibleChildren) {
          return;
        }
        if (container.accessible && container.isInteractive()) {
          if (!container._accessibleActive) {
            this._addChild(container);
          }
          container.renderId = this._renderId;
        }
        const children = container.children;
        if (children) {
          for (let i3 = 0; i3 < children.length; i3++) {
            this._updateAccessibleObjects(children[i3]);
          }
        }
      }
      /**
       * Runner init called, view is available at this point.
       * @ignore
       */
      init(options) {
        this.debug = options?.debug ?? this.debug;
        this._renderer.runners.postrender.remove(this);
      }
      /**
       * Runner postrender was called, ensure that all divs are mapped correctly to their DisplayObjects.
       * Only fires while active.
       * @ignore
       */
      postrender() {
        const now = performance.now();
        if (this._mobileInfo.android.device && now < this._androidUpdateCount) {
          return;
        }
        this._androidUpdateCount = now + this._androidUpdateFrequency;
        if (!this._renderer.renderingToScreen || !this._renderer.view.canvas) {
          return;
        }
        if (this._renderer.lastObjectRendered) {
          this._updateAccessibleObjects(this._renderer.lastObjectRendered);
        }
        const { x: x3, y: y2, width, height } = this._renderer.view.canvas.getBoundingClientRect();
        const { width: viewWidth, height: viewHeight, resolution } = this._renderer;
        const sx = width / viewWidth * resolution;
        const sy = height / viewHeight * resolution;
        let div = this._div;
        div.style.left = `${x3}px`;
        div.style.top = `${y2}px`;
        div.style.width = `${viewWidth}px`;
        div.style.height = `${viewHeight}px`;
        for (let i3 = 0; i3 < this._children.length; i3++) {
          const child = this._children[i3];
          if (child.renderId !== this._renderId) {
            child._accessibleActive = false;
            removeItems(this._children, i3, 1);
            this._div.removeChild(child._accessibleDiv);
            this._pool.push(child._accessibleDiv);
            child._accessibleDiv = null;
            i3--;
          } else {
            div = child._accessibleDiv;
            let hitArea = child.hitArea;
            const wt = child.worldTransform;
            if (child.hitArea) {
              div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;
              div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;
              div.style.width = `${hitArea.width * wt.a * sx}px`;
              div.style.height = `${hitArea.height * wt.d * sy}px`;
            } else {
              hitArea = child.getBounds();
              this.capHitArea(hitArea);
              div.style.left = `${hitArea.x * sx}px`;
              div.style.top = `${hitArea.y * sy}px`;
              div.style.width = `${hitArea.width * sx}px`;
              div.style.height = `${hitArea.height * sy}px`;
              if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
                div.title = child.accessibleTitle;
              }
              if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
                div.setAttribute("aria-label", child.accessibleHint);
              }
            }
            if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
              div.title = child.accessibleTitle;
              div.tabIndex = child.tabIndex;
              if (this.debug) {
                this.updateDebugHTML(div);
              }
            }
          }
        }
        this._renderId++;
      }
      /**
       * private function that will visually add the information to the
       * accessibility div
       * @param {HTMLElement} div -
       */
      updateDebugHTML(div) {
        div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
      }
      /**
       * Adjust the hit area based on the bounds of a display object
       * @param {Rectangle} hitArea - Bounds of the child
       */
      capHitArea(hitArea) {
        if (hitArea.x < 0) {
          hitArea.width += hitArea.x;
          hitArea.x = 0;
        }
        if (hitArea.y < 0) {
          hitArea.height += hitArea.y;
          hitArea.y = 0;
        }
        const { width: viewWidth, height: viewHeight } = this._renderer;
        if (hitArea.x + hitArea.width > viewWidth) {
          hitArea.width = viewWidth - hitArea.x;
        }
        if (hitArea.y + hitArea.height > viewHeight) {
          hitArea.height = viewHeight - hitArea.y;
        }
      }
      /**
       * Adds a Container to the accessibility manager
       * @private
       * @param {Container} container - The child to make accessible.
       */
      _addChild(container) {
        let div = this._pool.pop();
        if (!div) {
          div = document.createElement("button");
          div.style.width = `${DIV_TOUCH_SIZE}px`;
          div.style.height = `${DIV_TOUCH_SIZE}px`;
          div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
          div.style.position = "absolute";
          div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
          div.style.borderStyle = "none";
          if (navigator.userAgent.toLowerCase().includes("chrome")) {
            div.setAttribute("aria-live", "off");
          } else {
            div.setAttribute("aria-live", "polite");
          }
          if (navigator.userAgent.match(/rv:.*Gecko\//)) {
            div.setAttribute("aria-relevant", "additions");
          } else {
            div.setAttribute("aria-relevant", "text");
          }
          div.addEventListener("click", this._onClick.bind(this));
          div.addEventListener("focus", this._onFocus.bind(this));
          div.addEventListener("focusout", this._onFocusOut.bind(this));
        }
        div.style.pointerEvents = container.accessiblePointerEvents;
        div.type = container.accessibleType;
        if (container.accessibleTitle && container.accessibleTitle !== null) {
          div.title = container.accessibleTitle;
        } else if (!container.accessibleHint || container.accessibleHint === null) {
          div.title = `container ${container.tabIndex}`;
        }
        if (container.accessibleHint && container.accessibleHint !== null) {
          div.setAttribute("aria-label", container.accessibleHint);
        }
        if (this.debug) {
          this.updateDebugHTML(div);
        }
        container._accessibleActive = true;
        container._accessibleDiv = div;
        div.container = container;
        this._children.push(container);
        this._div.appendChild(container._accessibleDiv);
        container._accessibleDiv.tabIndex = container.tabIndex;
      }
      /**
       * Dispatch events with the EventSystem.
       * @param e
       * @param type
       * @private
       */
      _dispatchEvent(e3, type2) {
        const { container: target } = e3.target;
        const boundary = this._renderer.events.rootBoundary;
        const event = Object.assign(new FederatedEvent(boundary), { target });
        boundary.rootTarget = this._renderer.lastObjectRendered;
        type2.forEach((type22) => boundary.dispatchEvent(event, type22));
      }
      /**
       * Maps the div button press to pixi's EventSystem (click)
       * @private
       * @param {MouseEvent} e - The click event.
       */
      _onClick(e3) {
        this._dispatchEvent(e3, ["click", "pointertap", "tap"]);
      }
      /**
       * Maps the div focus events to pixi's EventSystem (mouseover)
       * @private
       * @param {FocusEvent} e - The focus event.
       */
      _onFocus(e3) {
        if (!e3.target.getAttribute("aria-live")) {
          e3.target.setAttribute("aria-live", "assertive");
        }
        this._dispatchEvent(e3, ["mouseover"]);
      }
      /**
       * Maps the div focus events to pixi's EventSystem (mouseout)
       * @private
       * @param {FocusEvent} e - The focusout event.
       */
      _onFocusOut(e3) {
        if (!e3.target.getAttribute("aria-live")) {
          e3.target.setAttribute("aria-live", "polite");
        }
        this._dispatchEvent(e3, ["mouseout"]);
      }
      /**
       * Is called when a key is pressed
       * @private
       * @param {KeyboardEvent} e - The keydown event.
       */
      _onKeyDown(e3) {
        if (e3.keyCode !== KEY_CODE_TAB) {
          return;
        }
        this._activate();
      }
      /**
       * Is called when the mouse moves across the renderer element
       * @private
       * @param {MouseEvent} e - The mouse event.
       */
      _onMouseMove(e3) {
        if (e3.movementX === 0 && e3.movementY === 0) {
          return;
        }
        this._deactivate();
      }
      /** Destroys the accessibility manager */
      destroy() {
        this._destroyTouchHook();
        this._div = null;
        globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
        globalThis.removeEventListener("keydown", this._onKeyDown);
        this._pool = null;
        this._children = null;
        this._renderer = null;
      }
    };
    AccessibilitySystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "accessibility"
    };
    extensions.add(AccessibilitySystem);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/accessibility/init.mjs
var init_init = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/accessibility/init.mjs"() {
    init_Extensions();
    init_Container();
    init_AccessibilitySystem();
    init_accessibilityTarget();
    extensions.add(AccessibilitySystem);
    Container.mixin(accessibilityTarget);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/ticker/const.mjs
var UPDATE_PRIORITY;
var init_const2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/ticker/const.mjs"() {
    UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY22) => {
      UPDATE_PRIORITY22[UPDATE_PRIORITY22["INTERACTION"] = 50] = "INTERACTION";
      UPDATE_PRIORITY22[UPDATE_PRIORITY22["HIGH"] = 25] = "HIGH";
      UPDATE_PRIORITY22[UPDATE_PRIORITY22["NORMAL"] = 0] = "NORMAL";
      UPDATE_PRIORITY22[UPDATE_PRIORITY22["LOW"] = -25] = "LOW";
      UPDATE_PRIORITY22[UPDATE_PRIORITY22["UTILITY"] = -50] = "UTILITY";
      return UPDATE_PRIORITY22;
    })(UPDATE_PRIORITY || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/ticker/TickerListener.mjs
var TickerListener;
var init_TickerListener = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/ticker/TickerListener.mjs"() {
    TickerListener = class {
      /**
       * Constructor
       * @private
       * @param fn - The listener function to be added for one update
       * @param context - The listener context
       * @param priority - The priority for emitting
       * @param once - If the handler should fire once
       */
      constructor(fn, context4 = null, priority = 0, once = false) {
        this.next = null;
        this.previous = null;
        this._destroyed = false;
        this._fn = fn;
        this._context = context4;
        this.priority = priority;
        this._once = once;
      }
      /**
       * Simple compare function to figure out if a function and context match.
       * @param fn - The listener function to be added for one update
       * @param context - The listener context
       * @returns `true` if the listener match the arguments
       */
      match(fn, context4 = null) {
        return this._fn === fn && this._context === context4;
      }
      /**
       * Emit by calling the current function.
       * @param ticker - The ticker emitting.
       * @returns Next ticker
       */
      emit(ticker) {
        if (this._fn) {
          if (this._context) {
            this._fn.call(this._context, ticker);
          } else {
            this._fn(ticker);
          }
        }
        const redirect = this.next;
        if (this._once) {
          this.destroy(true);
        }
        if (this._destroyed) {
          this.next = null;
        }
        return redirect;
      }
      /**
       * Connect to the list.
       * @param previous - Input node, previous listener
       */
      connect(previous) {
        this.previous = previous;
        if (previous.next) {
          previous.next.previous = this;
        }
        this.next = previous.next;
        previous.next = this;
      }
      /**
       * Destroy and don't use after this.
       * @param hard - `true` to remove the `next` reference, this
       *        is considered a hard destroy. Soft destroy maintains the next reference.
       * @returns The listener to redirect while emitting or removing.
       */
      destroy(hard = false) {
        this._destroyed = true;
        this._fn = null;
        this._context = null;
        if (this.previous) {
          this.previous.next = this.next;
        }
        if (this.next) {
          this.next.previous = this.previous;
        }
        const redirect = this.next;
        this.next = hard ? null : redirect;
        this.previous = null;
        return redirect;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/ticker/Ticker.mjs
var _Ticker, Ticker;
var init_Ticker = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/ticker/Ticker.mjs"() {
    init_const2();
    init_TickerListener();
    _Ticker = class {
      constructor() {
        this.autoStart = false;
        this.deltaTime = 1;
        this.lastTime = -1;
        this.speed = 1;
        this.started = false;
        this._requestId = null;
        this._maxElapsedMS = 100;
        this._minElapsedMS = 0;
        this._protected = false;
        this._lastFrame = -1;
        this._head = new TickerListener(null, null, Infinity);
        this.deltaMS = 1 / _Ticker.targetFPMS;
        this.elapsedMS = 1 / _Ticker.targetFPMS;
        this._tick = (time) => {
          this._requestId = null;
          if (this.started) {
            this.update(time);
            if (this.started && this._requestId === null && this._head.next) {
              this._requestId = requestAnimationFrame(this._tick);
            }
          }
        };
      }
      /**
       * Conditionally requests a new animation frame.
       * If a frame has not already been requested, and if the internal
       * emitter has listeners, a new frame is requested.
       * @private
       */
      _requestIfNeeded() {
        if (this._requestId === null && this._head.next) {
          this.lastTime = performance.now();
          this._lastFrame = this.lastTime;
          this._requestId = requestAnimationFrame(this._tick);
        }
      }
      /**
       * Conditionally cancels a pending animation frame.
       * @private
       */
      _cancelIfNeeded() {
        if (this._requestId !== null) {
          cancelAnimationFrame(this._requestId);
          this._requestId = null;
        }
      }
      /**
       * Conditionally requests a new animation frame.
       * If the ticker has been started it checks if a frame has not already
       * been requested, and if the internal emitter has listeners. If these
       * conditions are met, a new frame is requested. If the ticker has not
       * been started, but autoStart is `true`, then the ticker starts now,
       * and continues with the previous conditions to request a new frame.
       * @private
       */
      _startIfPossible() {
        if (this.started) {
          this._requestIfNeeded();
        } else if (this.autoStart) {
          this.start();
        }
      }
      /**
       * Register a handler for tick events. Calls continuously unless
       * it is removed or the ticker is stopped.
       * @param fn - The listener function to be added for updates
       * @param context - The listener context
       * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
       * @returns This instance of a ticker
       */
      add(fn, context4, priority = UPDATE_PRIORITY.NORMAL) {
        return this._addListener(new TickerListener(fn, context4, priority));
      }
      /**
       * Add a handler for the tick event which is only execute once.
       * @param fn - The listener function to be added for one update
       * @param context - The listener context
       * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
       * @returns This instance of a ticker
       */
      addOnce(fn, context4, priority = UPDATE_PRIORITY.NORMAL) {
        return this._addListener(new TickerListener(fn, context4, priority, true));
      }
      /**
       * Internally adds the event handler so that it can be sorted by priority.
       * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
       * before the rendering.
       * @private
       * @param listener - Current listener being added.
       * @returns This instance of a ticker
       */
      _addListener(listener) {
        let current = this._head.next;
        let previous = this._head;
        if (!current) {
          listener.connect(previous);
        } else {
          while (current) {
            if (listener.priority > current.priority) {
              listener.connect(previous);
              break;
            }
            previous = current;
            current = current.next;
          }
          if (!listener.previous) {
            listener.connect(previous);
          }
        }
        this._startIfPossible();
        return this;
      }
      /**
       * Removes any handlers matching the function and context parameters.
       * If no handlers are left after removing, then it cancels the animation frame.
       * @param fn - The listener function to be removed
       * @param context - The listener context to be removed
       * @returns This instance of a ticker
       */
      remove(fn, context4) {
        let listener = this._head.next;
        while (listener) {
          if (listener.match(fn, context4)) {
            listener = listener.destroy();
          } else {
            listener = listener.next;
          }
        }
        if (!this._head.next) {
          this._cancelIfNeeded();
        }
        return this;
      }
      /**
       * The number of listeners on this ticker, calculated by walking through linked list
       * @readonly
       * @member {number}
       */
      get count() {
        if (!this._head) {
          return 0;
        }
        let count2 = 0;
        let current = this._head;
        while (current = current.next) {
          count2++;
        }
        return count2;
      }
      /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */
      start() {
        if (!this.started) {
          this.started = true;
          this._requestIfNeeded();
        }
      }
      /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */
      stop() {
        if (this.started) {
          this.started = false;
          this._cancelIfNeeded();
        }
      }
      /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */
      destroy() {
        if (!this._protected) {
          this.stop();
          let listener = this._head.next;
          while (listener) {
            listener = listener.destroy(true);
          }
          this._head.destroy();
          this._head = null;
        }
      }
      /**
       * Triggers an update. An update entails setting the
       * current {@link Ticker#elapsedMS},
       * the current {@link Ticker#deltaTime},
       * invoking all listeners with current deltaTime,
       * and then finally setting {@link Ticker#lastTime}
       * with the value of currentTime that was provided.
       * This method will be called automatically by animation
       * frame callbacks if the ticker instance has been started
       * and listeners are added.
       * @param {number} [currentTime=performance.now()] - the current time of execution
       */
      update(currentTime = performance.now()) {
        let elapsedMS;
        if (currentTime > this.lastTime) {
          elapsedMS = this.elapsedMS = currentTime - this.lastTime;
          if (elapsedMS > this._maxElapsedMS) {
            elapsedMS = this._maxElapsedMS;
          }
          elapsedMS *= this.speed;
          if (this._minElapsedMS) {
            const delta = currentTime - this._lastFrame | 0;
            if (delta < this._minElapsedMS) {
              return;
            }
            this._lastFrame = currentTime - delta % this._minElapsedMS;
          }
          this.deltaMS = elapsedMS;
          this.deltaTime = this.deltaMS * _Ticker.targetFPMS;
          const head = this._head;
          let listener = head.next;
          while (listener) {
            listener = listener.emit(this);
          }
          if (!head.next) {
            this._cancelIfNeeded();
          }
        } else {
          this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        }
        this.lastTime = currentTime;
      }
      /**
       * The frames per second at which this ticker is running.
       * The default is approximately 60 in most modern browsers.
       * **Note:** This does not factor in the value of
       * {@link Ticker#speed}, which is specific
       * to scaling {@link Ticker#deltaTime}.
       * @member {number}
       * @readonly
       */
      get FPS() {
        return 1e3 / this.elapsedMS;
      }
      /**
       * Manages the maximum amount of milliseconds allowed to
       * elapse between invoking {@link Ticker#update}.
       * This value is used to cap {@link Ticker#deltaTime},
       * but does not effect the measured value of {@link Ticker#FPS}.
       * When setting this property it is clamped to a value between
       * `0` and `Ticker.targetFPMS * 1000`.
       * @member {number}
       * @default 10
       */
      get minFPS() {
        return 1e3 / this._maxElapsedMS;
      }
      set minFPS(fps2) {
        const minFPS = Math.min(this.maxFPS, fps2);
        const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);
        this._maxElapsedMS = 1 / minFPMS;
      }
      /**
       * Manages the minimum amount of milliseconds required to
       * elapse between invoking {@link Ticker#update}.
       * This will effect the measured value of {@link Ticker#FPS}.
       * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
       * Otherwise it will be at least `minFPS`
       * @member {number}
       * @default 0
       */
      get maxFPS() {
        if (this._minElapsedMS) {
          return Math.round(1e3 / this._minElapsedMS);
        }
        return 0;
      }
      set maxFPS(fps2) {
        if (fps2 === 0) {
          this._minElapsedMS = 0;
        } else {
          const maxFPS = Math.max(this.minFPS, fps2);
          this._minElapsedMS = 1 / (maxFPS / 1e3);
        }
      }
      /**
       * The shared ticker instance used by {@link AnimatedSprite} and by
       * {@link VideoResource} to update animation frames / video textures.
       *
       * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.
       *
       * The property {@link Ticker#autoStart} is set to `true` for this instance.
       * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
       * @example
       * import { Ticker } from 'pixi.js';
       *
       * const ticker = Ticker.shared;
       * // Set this to prevent starting this ticker when listeners are added.
       * // By default this is true only for the Ticker.shared instance.
       * ticker.autoStart = false;
       *
       * // FYI, call this to ensure the ticker is stopped. It should be stopped
       * // if you have not attempted to render anything yet.
       * ticker.stop();
       *
       * // Call this when you are ready for a running shared ticker.
       * ticker.start();
       * @example
       * import { autoDetectRenderer, Container } from 'pixi.js';
       *
       * // You may use the shared ticker to render...
       * const renderer = autoDetectRenderer();
       * const stage = new Container();
       * document.body.appendChild(renderer.view);
       * ticker.add((time) => renderer.render(stage));
       *
       * // Or you can just update it manually.
       * ticker.autoStart = false;
       * ticker.stop();
       * const animate = (time) => {
       *     ticker.update(time);
       *     renderer.render(stage);
       *     requestAnimationFrame(animate);
       * };
       * animate(performance.now());
       * @member {Ticker}
       * @static
       */
      static get shared() {
        if (!_Ticker._shared) {
          const shared = _Ticker._shared = new _Ticker();
          shared.autoStart = true;
          shared._protected = true;
        }
        return _Ticker._shared;
      }
      /**
       * The system ticker instance used by {@link BasePrepare} for core timing
       * functionality that shouldn't usually need to be paused, unlike the `shared`
       * ticker which drives visual animations and rendering which may want to be paused.
       *
       * The property {@link Ticker#autoStart} is set to `true` for this instance.
       * @member {Ticker}
       * @static
       */
      static get system() {
        if (!_Ticker._system) {
          const system = _Ticker._system = new _Ticker();
          system.autoStart = true;
          system._protected = true;
        }
        return _Ticker._system;
      }
    };
    Ticker = _Ticker;
    Ticker.targetFPMS = 0.06;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/ticker/TickerPlugin.mjs
var TickerPlugin;
var init_TickerPlugin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/ticker/TickerPlugin.mjs"() {
    init_Extensions();
    init_const2();
    init_Ticker();
    TickerPlugin = class {
      /**
       * Initialize the plugin with scope of application instance
       * @static
       * @private
       * @param {object} [options] - See application options
       */
      static init(options) {
        options = Object.assign({
          autoStart: true,
          sharedTicker: false
        }, options);
        Object.defineProperty(
          this,
          "ticker",
          {
            set(ticker) {
              if (this._ticker) {
                this._ticker.remove(this.render, this);
              }
              this._ticker = ticker;
              if (ticker) {
                ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
              }
            },
            get() {
              return this._ticker;
            }
          }
        );
        this.stop = () => {
          this._ticker.stop();
        };
        this.start = () => {
          this._ticker.start();
        };
        this._ticker = null;
        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
        if (options.autoStart) {
          this.start();
        }
      }
      /**
       * Clean up the ticker, scoped to application.
       * @static
       * @private
       */
      static destroy() {
        if (this._ticker) {
          const oldTicker = this._ticker;
          this.ticker = null;
          oldTicker.destroy();
        }
      }
    };
    TickerPlugin.extension = ExtensionType.Application;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/app/ResizePlugin.mjs
var ResizePlugin;
var init_ResizePlugin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/app/ResizePlugin.mjs"() {
    init_Extensions();
    ResizePlugin = class {
      /**
       * Initialize the plugin with scope of application instance
       * @static
       * @private
       * @param {object} [options] - See application options
       */
      static init(options) {
        Object.defineProperty(
          this,
          "resizeTo",
          /**
           * The HTML element or window to automatically resize the
           * renderer's view element to match width and height.
           * @member {Window|HTMLElement}
           * @name resizeTo
           * @memberof Application#
           */
          {
            set(dom) {
              globalThis.removeEventListener("resize", this.queueResize);
              this._resizeTo = dom;
              if (dom) {
                globalThis.addEventListener("resize", this.queueResize);
                this.resize();
              }
            },
            get() {
              return this._resizeTo;
            }
          }
        );
        this.queueResize = () => {
          if (!this._resizeTo) {
            return;
          }
          this._cancelResize();
          this._resizeId = requestAnimationFrame(() => this.resize());
        };
        this._cancelResize = () => {
          if (this._resizeId) {
            cancelAnimationFrame(this._resizeId);
            this._resizeId = null;
          }
        };
        this.resize = () => {
          if (!this._resizeTo) {
            return;
          }
          this._cancelResize();
          let width;
          let height;
          if (this._resizeTo === globalThis.window) {
            width = globalThis.innerWidth;
            height = globalThis.innerHeight;
          } else {
            const { clientWidth, clientHeight } = this._resizeTo;
            width = clientWidth;
            height = clientHeight;
          }
          this.renderer.resize(width, height);
          this.render();
        };
        this._resizeId = null;
        this._resizeTo = null;
        this.resizeTo = options.resizeTo || null;
      }
      /**
       * Clean up the ticker, scoped to application
       * @static
       * @private
       */
      static destroy() {
        globalThis.removeEventListener("resize", this.queueResize);
        this._cancelResize();
        this._cancelResize = null;
        this.queueResize = null;
        this.resizeTo = null;
        this.resize = null;
      }
    };
    ResizePlugin.extension = ExtensionType.Application;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/app/init.mjs
var init_init2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/app/init.mjs"() {
    init_Extensions();
    init_TickerPlugin();
    init_ResizePlugin();
    extensions.add(ResizePlugin);
    extensions.add(TickerPlugin);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs
var LoaderParserPriority;
var init_LoaderParser = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs"() {
    LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority22) => {
      LoaderParserPriority22[LoaderParserPriority22["Low"] = 0] = "Low";
      LoaderParserPriority22[LoaderParserPriority22["Normal"] = 1] = "Normal";
      LoaderParserPriority22[LoaderParserPriority22["High"] = 2] = "High";
      return LoaderParserPriority22;
    })(LoaderParserPriority || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs
var copySearchParams;
var init_copySearchParams = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs"() {
    copySearchParams = (targetUrl, sourceUrl) => {
      const searchParams = sourceUrl.split("?")[1];
      if (searchParams) {
        targetUrl += `?${searchParams}`;
      }
      return targetUrl;
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/settings/adapter/adapter.mjs
var BrowserAdapter;
var init_adapter = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/settings/adapter/adapter.mjs"() {
    BrowserAdapter = {
      /**
       * Creates a canvas element of the given size.
       * This canvas is created using the browser's native canvas element.
       * @param width - width of the canvas
       * @param height - height of the canvas
       */
      createCanvas: (width, height) => {
        const canvas3 = document.createElement("canvas");
        canvas3.width = width;
        canvas3.height = height;
        return canvas3;
      },
      getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
      getWebGLRenderingContext: () => WebGLRenderingContext,
      getNavigator: () => navigator,
      getBaseUrl: () => document.baseURI ?? window.location.href,
      getFontFaceSet: () => document.fonts,
      fetch: (url2, options) => fetch(url2, options),
      parseXML: (xml) => {
        const parser = new DOMParser();
        return parser.parseFromString(xml, "text/xml");
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/settings/settings.mjs
var settings;
var init_settings = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/settings/settings.mjs"() {
    init_adapter();
    settings = {
      /**
       * This adapter is used to call methods that are platform dependent.
       * For example `document.createElement` only runs on the web but fails in node environments.
       * This allows us to support more platforms by abstracting away specific implementations per platform.
       *
       * By default the adapter is set to work in the browser. However you can create your own
       * by implementing the `IAdapter` interface. See `IAdapter` for more information.
       * @name ADAPTER
       * @memberof settings
       * @type {Adapter}
       * @default BrowserAdapter
       */
      ADAPTER: BrowserAdapter,
      /**
       * The prefix that denotes a URL is for a retina asset.
       * @static
       * @name RETINA_PREFIX
       * @memberof settings
       * @type {RegExp}
       * @default /@([0-9\.]+)x/
       * @example `@2x`
       */
      RETINA_PREFIX: /@([0-9\.]+)x/,
      /**
       * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported` function.
       * If set to true, a WebGL renderer can fail to be created if the browser thinks there could be performance issues when
       * using WebGL.
       *
       * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many scenarios as possible.
       * However, some users may have a poor experience, for example, if a user has a gpu or driver version blacklisted by the
       * browser.
       *
       * If your application requires high performance rendering, you may wish to set this to false.
       * We recommend one of two options if you decide to set this flag to false:
       *
       * 1: Use the `pixi.js-legacy` package, which includes a Canvas renderer as a fallback in case high performance WebGL is
       *    not supported.
       *
       * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a
       *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their
       *    device & browser combination does not support high performance WebGL.
       *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.
       * @static
       * @name FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
       * @memberof settings
       * @type {boolean}
       * @default false
       */
      FAIL_IF_MAJOR_PERFORMANCE_CAVEAT: false,
      /**
       * Default resolution / device pixel ratio of the renderer.
       * @static
       * @name RESOLUTION
       * @memberof settings
       * @type {number}
       * @default 1
       */
      RESOLUTION: 1
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/path.mjs
function assertPath(path22) {
  if (typeof path22 !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path22)}`);
  }
}
function removeUrlParams(url2) {
  const re = url2.split("?")[0];
  return re.split("#")[0];
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll(str, find, replace) {
  return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
}
function normalizeStringPosix(path22, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = -1;
  for (let i3 = 0; i3 <= path22.length; ++i3) {
    if (i3 < path22.length) {
      code = path22.charCodeAt(i3);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === i3 - 1 || dots === 1) {
      } else if (lastSlash !== i3 - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i3;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i3;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path22.slice(lastSlash + 1, i3)}`;
        } else {
          res = path22.slice(lastSlash + 1, i3);
        }
        lastSegmentLength = i3 - lastSlash - 1;
      }
      lastSlash = i3;
      dots = 0;
    } else if (code === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
var path;
var init_path = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/path.mjs"() {
    init_settings();
    path = {
      /**
       * Converts a path to posix format.
       * @param path - The path to convert to posix
       */
      toPosix(path22) {
        return replaceAll(path22, "\\", "/");
      },
      /**
       * Checks if the path is a URL e.g. http://, https://
       * @param path - The path to check
       */
      isUrl(path22) {
        return /^https?:/.test(this.toPosix(path22));
      },
      /**
       * Checks if the path is a data URL
       * @param path - The path to check
       */
      isDataUrl(path22) {
        return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path22);
      },
      /**
       * Checks if the path is a blob URL
       * @param path - The path to check
       */
      isBlobUrl(path22) {
        return path22.startsWith("blob:");
      },
      /**
       * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
       * This will return true for windows file paths
       * @param path - The path to check
       */
      hasProtocol(path22) {
        return /^[^/:]+:/.test(this.toPosix(path22));
      },
      /**
       * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
       * @param path - The path to get the protocol from
       */
      getProtocol(path22) {
        assertPath(path22);
        path22 = this.toPosix(path22);
        const matchFile = /^file:\/\/\//.exec(path22);
        if (matchFile) {
          return matchFile[0];
        }
        const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path22);
        if (matchProtocol) {
          return matchProtocol[0];
        }
        return "";
      },
      /**
       * Converts URL to an absolute path.
       * When loading from a Web Worker, we must use absolute paths.
       * If the URL is already absolute we return it as is
       * If it's not, we convert it
       * @param url - The URL to test
       * @param customBaseUrl - The base URL to use
       * @param customRootUrl - The root URL to use
       */
      toAbsolute(url2, customBaseUrl, customRootUrl) {
        assertPath(url2);
        if (this.isDataUrl(url2) || this.isBlobUrl(url2))
          return url2;
        const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? settings.ADAPTER.getBaseUrl()));
        const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
        url2 = this.toPosix(url2);
        if (url2.startsWith("/")) {
          return path.join(rootUrl, url2.slice(1));
        }
        const absolutePath = this.isAbsolute(url2) ? url2 : this.join(baseUrl, url2);
        return absolutePath;
      },
      /**
       * Normalizes the given path, resolving '..' and '.' segments
       * @param path - The path to normalize
       */
      normalize(path22) {
        assertPath(path22);
        if (path22.length === 0)
          return ".";
        if (this.isDataUrl(path22) || this.isBlobUrl(path22))
          return path22;
        path22 = this.toPosix(path22);
        let protocol = "";
        const isAbsolute = path22.startsWith("/");
        if (this.hasProtocol(path22)) {
          protocol = this.rootname(path22);
          path22 = path22.slice(protocol.length);
        }
        const trailingSeparator = path22.endsWith("/");
        path22 = normalizeStringPosix(path22, false);
        if (path22.length > 0 && trailingSeparator)
          path22 += "/";
        if (isAbsolute)
          return `/${path22}`;
        return protocol + path22;
      },
      /**
       * Determines if path is an absolute path.
       * Absolute paths can be urls, data urls, or paths on disk
       * @param path - The path to test
       */
      isAbsolute(path22) {
        assertPath(path22);
        path22 = this.toPosix(path22);
        if (this.hasProtocol(path22))
          return true;
        return path22.startsWith("/");
      },
      /**
       * Joins all given path segments together using the platform-specific separator as a delimiter,
       * then normalizes the resulting path
       * @param segments - The segments of the path to join
       */
      join(...segments) {
        if (segments.length === 0) {
          return ".";
        }
        let joined;
        for (let i3 = 0; i3 < segments.length; ++i3) {
          const arg2 = segments[i3];
          assertPath(arg2);
          if (arg2.length > 0) {
            if (joined === void 0)
              joined = arg2;
            else {
              const prevArg = segments[i3 - 1] ?? "";
              if (this.extname(prevArg)) {
                joined += `/../${arg2}`;
              } else {
                joined += `/${arg2}`;
              }
            }
          }
        }
        if (joined === void 0) {
          return ".";
        }
        return this.normalize(joined);
      },
      /**
       * Returns the directory name of a path
       * @param path - The path to parse
       */
      dirname(path22) {
        assertPath(path22);
        if (path22.length === 0)
          return ".";
        path22 = this.toPosix(path22);
        let code = path22.charCodeAt(0);
        const hasRoot = code === 47;
        let end = -1;
        let matchedSlash = true;
        const proto = this.getProtocol(path22);
        const origpath = path22;
        path22 = path22.slice(proto.length);
        for (let i3 = path22.length - 1; i3 >= 1; --i3) {
          code = path22.charCodeAt(i3);
          if (code === 47) {
            if (!matchedSlash) {
              end = i3;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : this.isUrl(origpath) ? proto + path22 : proto;
        if (hasRoot && end === 1)
          return "//";
        return proto + path22.slice(0, end);
      },
      /**
       * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
       * @param path - The path to parse
       */
      rootname(path22) {
        assertPath(path22);
        path22 = this.toPosix(path22);
        let root = "";
        if (path22.startsWith("/"))
          root = "/";
        else {
          root = this.getProtocol(path22);
        }
        if (this.isUrl(path22)) {
          const index = path22.indexOf("/", root.length);
          if (index !== -1) {
            root = path22.slice(0, index);
          } else
            root = path22;
          if (!root.endsWith("/"))
            root += "/";
        }
        return root;
      },
      /**
       * Returns the last portion of a path
       * @param path - The path to test
       * @param ext - Optional extension to remove
       */
      basename(path22, ext) {
        assertPath(path22);
        if (ext)
          assertPath(ext);
        path22 = removeUrlParams(this.toPosix(path22));
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i3;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path22.length) {
          if (ext.length === path22.length && ext === path22)
            return "";
          let extIdx = ext.length - 1;
          let firstNonSlashEnd = -1;
          for (i3 = path22.length - 1; i3 >= 0; --i3) {
            const code = path22.charCodeAt(i3);
            if (code === 47) {
              if (!matchedSlash) {
                start = i3 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i3 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i3;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path22.length;
          return path22.slice(start, end);
        }
        for (i3 = path22.length - 1; i3 >= 0; --i3) {
          if (path22.charCodeAt(i3) === 47) {
            if (!matchedSlash) {
              start = i3 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i3 + 1;
          }
        }
        if (end === -1)
          return "";
        return path22.slice(start, end);
      },
      /**
       * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
       * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
       * the first character of the basename of path, an empty string is returned.
       * @param path - The path to parse
       */
      extname(path22) {
        assertPath(path22);
        path22 = removeUrlParams(this.toPosix(path22));
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        for (let i3 = path22.length - 1; i3 >= 0; --i3) {
          const code = path22.charCodeAt(i3);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i3 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i3 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i3;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path22.slice(startDot, end);
      },
      /**
       * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
       * @param path - The path to parse
       */
      parse(path22) {
        assertPath(path22);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path22.length === 0)
          return ret;
        path22 = removeUrlParams(this.toPosix(path22));
        let code = path22.charCodeAt(0);
        const isAbsolute = this.isAbsolute(path22);
        let start;
        const protocol = "";
        ret.root = this.rootname(path22);
        if (isAbsolute || this.hasProtocol(path22)) {
          start = 1;
        } else {
          start = 0;
        }
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let i3 = path22.length - 1;
        let preDotState = 0;
        for (; i3 >= start; --i3) {
          code = path22.charCodeAt(i3);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i3 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i3 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i3;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute)
              ret.base = ret.name = path22.slice(1, end);
            else
              ret.base = ret.name = path22.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path22.slice(1, startDot);
            ret.base = path22.slice(1, end);
          } else {
            ret.name = path22.slice(startPart, startDot);
            ret.base = path22.slice(startPart, end);
          }
          ret.ext = path22.slice(startDot, end);
        }
        ret.dir = this.dirname(path22);
        if (protocol)
          ret.dir = protocol + ret.dir;
        return ret;
      },
      sep: "/",
      delimiter: ":"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/utils/convertToList.mjs
var convertToList;
var init_convertToList = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/utils/convertToList.mjs"() {
    convertToList = (input, transform, forceTransform = false) => {
      if (!Array.isArray(input)) {
        input = [input];
      }
      if (!transform) {
        return input;
      }
      return input.map((item) => {
        if (typeof item === "string" || forceTransform) {
          return transform(item);
        }
        return item;
      });
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/cache/Cache.mjs
var CacheClass, Cache;
var init_Cache = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/cache/Cache.mjs"() {
    init_warn();
    init_convertToList();
    CacheClass = class {
      constructor() {
        this._parsers = [];
        this._cache = /* @__PURE__ */ new Map();
        this._cacheMap = /* @__PURE__ */ new Map();
      }
      /** Clear all entries. */
      reset() {
        this._cacheMap.clear();
        this._cache.clear();
      }
      /**
       * Check if the key exists
       * @param key - The key to check
       */
      has(key2) {
        return this._cache.has(key2);
      }
      /**
       * Fetch entry by key
       * @param key - The key of the entry to get
       */
      get(key2) {
        const result = this._cache.get(key2);
        if (!result) {
          warn(`[Assets] Asset id ${key2} was not found in the Cache`);
        }
        return result;
      }
      /**
       * Set a value by key or keys name
       * @param key - The key or keys to set
       * @param value - The value to store in the cache or from which cacheable assets will be derived.
       */
      set(key2, value) {
        const keys = convertToList(key2);
        let cacheableAssets;
        for (let i3 = 0; i3 < this.parsers.length; i3++) {
          const parser = this.parsers[i3];
          if (parser.test(value)) {
            cacheableAssets = parser.getCacheableAssets(keys, value);
            break;
          }
        }
        if (!cacheableAssets) {
          cacheableAssets = {};
          keys.forEach((key22) => {
            cacheableAssets[key22] = value;
          });
        }
        const cacheKeys = Object.keys(cacheableAssets);
        const cachedAssets = {
          cacheKeys,
          keys
        };
        keys.forEach((key22) => {
          this._cacheMap.set(key22, cachedAssets);
        });
        cacheKeys.forEach((key22) => {
          if (this._cache.has(key22) && this._cache.get(key22) !== value) {
            warn("[Cache] already has key:", key22);
          }
          this._cache.set(key22, cacheableAssets[key22]);
        });
      }
      /**
       * Remove entry by key
       *
       * This function will also remove any associated alias from the cache also.
       * @param key - The key of the entry to remove
       */
      remove(key2) {
        if (!this._cacheMap.has(key2)) {
          warn(`[Assets] Asset id ${key2} was not found in the Cache`);
          return;
        }
        const cacheMap2 = this._cacheMap.get(key2);
        const cacheKeys = cacheMap2.cacheKeys;
        cacheKeys.forEach((key22) => {
          this._cache.delete(key22);
        });
        cacheMap2.keys.forEach((key22) => {
          this._cacheMap.delete(key22);
        });
      }
      /** All loader parsers registered */
      get parsers() {
        return this._parsers;
      }
    };
    Cache = new CacheClass();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/NOOP.mjs
var NOOP;
var init_NOOP = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/NOOP.mjs"() {
    NOOP = () => {
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs
function createIdFromString(value, groupId) {
  let id = idHash[value];
  if (id === void 0) {
    if (idCounts[groupId] === void 0) {
      idCounts[groupId] = 1;
    }
    idHash[value] = id = idCounts[groupId]++;
  }
  return id;
}
var idCounts, idHash;
var init_createIdFromString = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs"() {
    idCounts = /* @__PURE__ */ Object.create(null);
    idHash = /* @__PURE__ */ Object.create(null);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs
var _TextureStyle, TextureStyle;
var init_TextureStyle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs"() {
    init_eventemitter3();
    init_deprecation();
    init_createIdFromString();
    _TextureStyle = class extends eventemitter3_default {
      constructor(options = {}) {
        super();
        this.resourceType = "textureSampler";
        this.touched = 0;
        this._maxAnisotropy = 1;
        options = { ..._TextureStyle.defaultOptions, ...options };
        this.addressMode = options.addressMode;
        this.addressModeU = options.addressModeU ?? this.addressModeU;
        this.addressModeV = options.addressModeV ?? this.addressModeV;
        this.addressModeW = options.addressModeW ?? this.addressModeW;
        this.scaleMode = options.scaleMode;
        this.magFilter = options.magFilter ?? this.magFilter;
        this.minFilter = options.minFilter ?? this.minFilter;
        this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;
        this.lodMinClamp = options.lodMinClamp;
        this.lodMaxClamp = options.lodMaxClamp;
        this.compare = options.compare;
        this.maxAnisotropy = options.maxAnisotropy ?? 1;
      }
      set addressMode(value) {
        this.addressModeU = value;
        this.addressModeV = value;
        this.addressModeW = value;
      }
      get addressMode() {
        return this.addressModeU;
      }
      set wrapMode(value) {
        deprecation("8", "TextureStyle.wrapMode is now TextureStyle.addressMode");
        this.addressMode = value;
      }
      get wrapMode() {
        return this.addressMode;
      }
      set scaleMode(value) {
        this.magFilter = value;
        this.minFilter = value;
        this.mipmapFilter = value;
      }
      get scaleMode() {
        return this.magFilter;
      }
      set maxAnisotropy(value) {
        this._maxAnisotropy = Math.min(value, 16);
        if (this._maxAnisotropy > 1) {
          this.scaleMode = "linear";
        }
      }
      get maxAnisotropy() {
        return this._maxAnisotropy;
      }
      // TODO - move this to WebGL?
      get resourceId() {
        return this._resourceId || this._generateResourceId();
      }
      update() {
        this.emit("change", this);
        this._resourceId = null;
      }
      _generateResourceId() {
        const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
        this._resourceId = createIdFromString(bigKey, "sampler");
        return this._resourceId;
      }
      /** Destroys the style */
      destroy() {
        this.emit("destroy", this);
        this.removeAllListeners();
      }
    };
    TextureStyle = _TextureStyle;
    TextureStyle.defaultOptions = {
      addressMode: "clamp-to-edge",
      scaleMode: "linear"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs
var _TextureSource, TextureSource;
var init_TextureSource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs"() {
    init_eventemitter3();
    init_uid();
    init_deprecation();
    init_TextureStyle();
    _TextureSource = class extends eventemitter3_default {
      // eslint-disable-next-line @typescript-eslint/no-parameter-properties
      constructor(options = {}) {
        super();
        this.options = options;
        this.uid = uid("textureSource");
        this.resourceType = "textureSource";
        this.resourceId = uid("textureResource");
        this.uploadMethodId = "unknown";
        this._resolution = 1;
        this.pixelWidth = 1;
        this.pixelHeight = 1;
        this.width = 1;
        this.height = 1;
        this.sampleCount = 1;
        this.mipLevelCount = 1;
        this.autoGenerateMipmaps = false;
        this.format = "rgba8unorm-srgb";
        this.dimension = "2d";
        this.antialias = false;
        this.depthStencil = true;
        this.touched = 0;
        this._batchTick = -1;
        this._textureBindLocation = -1;
        options = { ..._TextureSource.defaultOptions, ...options };
        this.resource = options.resource;
        this._resolution = options.resolution;
        if (options.width) {
          this.pixelWidth = options.width * this._resolution;
        } else {
          this.pixelWidth = options.resource?.width ?? 1;
        }
        if (options.height) {
          this.pixelHeight = options.height * this._resolution;
        } else {
          this.pixelHeight = options.resource?.height ?? 1;
        }
        this.width = this.pixelWidth / this._resolution;
        this.height = this.pixelHeight / this._resolution;
        this.format = options.format;
        this.dimension = options.dimensions;
        this.mipLevelCount = options.mipLevelCount;
        this.autoGenerateMipmaps = options.autoGenerateMipmaps;
        this.sampleCount = options.sampleCount;
        this.antialias = options.antialias;
        this.alphaMode = options.alphaMode;
        const style = options.style ?? {};
        this.style = style instanceof TextureStyle ? style : new TextureStyle(style);
        this.destroyed = false;
      }
      get source() {
        return this;
      }
      get style() {
        return this._style;
      }
      set style(value) {
        if (this.style === value)
          return;
        this._style?.off("change", this._onStyleChange, this);
        this._style = value;
        this._style?.on("change", this._onStyleChange, this);
        this._onStyleChange();
      }
      _onStyleChange() {
        this.emit("styleChange", this);
      }
      update() {
        this.emit("update", this);
      }
      /** Destroys this texture source */
      destroy() {
        this.destroyed = true;
        this.emit("destroy", this);
        if (this._style) {
          this._style.destroy();
          this._style = null;
        }
        this.uploadMethodId = null;
        this.resource = null;
        this.removeAllListeners();
      }
      unload() {
        this.resourceId++;
        this.emit("change", this);
        this.emit("unload", this);
      }
      get resourceWidth() {
        const { resource } = this;
        return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;
      }
      get resourceHeight() {
        const { resource } = this;
        return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;
      }
      get resolution() {
        return this._resolution;
      }
      set resolution(resolution) {
        if (this._resolution === resolution)
          return;
        this._resolution = resolution;
        this.width = this.pixelWidth / resolution;
        this.height = this.pixelHeight / resolution;
      }
      resize(width, height, resolution) {
        resolution = resolution || this._resolution;
        width = width || this.width;
        height = height || this.height;
        const newPixelWidth = Math.round(width * resolution);
        const newPixelHeight = Math.round(height * resolution);
        this.width = newPixelWidth / resolution;
        this.height = newPixelHeight / resolution;
        this._resolution = resolution;
        if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {
          return;
        }
        this.pixelWidth = newPixelWidth;
        this.pixelHeight = newPixelHeight;
        this.emit("resize", this);
        this.resourceId++;
        this.emit("change", this);
      }
      /** @deprecated since 8.0.0 */
      set wrapMode(value) {
        deprecation(v8_0_0, "TextureSource.wrapMode property has been deprecated. Use TextureSource.style.addressMode instead.");
        this._style.wrapMode = value;
      }
      /** @deprecated since 8.0.0 */
      get wrapMode() {
        deprecation(v8_0_0, "TextureSource.wrapMode property has been deprecated. Use TextureSource.style.addressMode instead.");
        return this._style.wrapMode;
      }
      /** @deprecated since 8.0.0 */
      set scaleMode(value) {
        deprecation(v8_0_0, "TextureSource.scaleMode property has been deprecated. Use TextureSource.style.scaleMode instead.");
        this._style.scaleMode = value;
      }
      /** @deprecated since 8.0.0 */
      get scaleMode() {
        deprecation(v8_0_0, "TextureSource.scaleMode property has been deprecated. Use TextureSource.style.scaleMode instead.");
        return this._style.scaleMode;
      }
    };
    TextureSource = _TextureSource;
    TextureSource.defaultOptions = {
      resolution: 1,
      format: "bgra8unorm",
      alphaMode: "no-premultiply-alpha",
      dimensions: "2d",
      mipLevelCount: 1,
      autoGenerateMipmaps: false,
      sampleCount: 1,
      antialias: false,
      style: {}
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs
var BufferImageSource;
var init_BufferImageSource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs"() {
    init_TextureSource();
    BufferImageSource = class _BufferImageSource extends TextureSource {
      constructor() {
        super(...arguments);
        this.uploadMethodId = "buffer";
      }
      static from(options) {
        const buffer2 = options.resource || new Float32Array(options.width * options.height * 4);
        let format3 = options.format;
        if (!format3) {
          if (buffer2 instanceof Float32Array) {
            format3 = "rgba32float";
          } else if (buffer2 instanceof Int32Array) {
            format3 = "rgba32uint";
          } else if (buffer2 instanceof Uint32Array) {
            format3 = "rgba32uint";
          } else if (buffer2 instanceof Int16Array) {
            format3 = "rgba16uint";
          } else if (buffer2 instanceof Uint16Array) {
            format3 = "rgba16uint";
          } else if (buffer2 instanceof Int8Array) {
            format3 = "bgra8unorm";
          } else {
            format3 = "bgra8unorm";
          }
        }
        return new _BufferImageSource({
          ...options,
          format: format3
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/maths/matrix/groupD8.mjs
function init() {
  for (let i3 = 0; i3 < 16; i3++) {
    const row = [];
    rotationCayley.push(row);
    for (let j3 = 0; j3 < 16; j3++) {
      const _ux = signum(ux[i3] * ux[j3] + vx[i3] * uy[j3]);
      const _uy = signum(uy[i3] * ux[j3] + vy[i3] * uy[j3]);
      const _vx = signum(ux[i3] * vx[j3] + vx[i3] * vy[j3]);
      const _vy = signum(uy[i3] * vx[j3] + vy[i3] * vy[j3]);
      for (let k3 = 0; k3 < 16; k3++) {
        if (ux[k3] === _ux && uy[k3] === _uy && vx[k3] === _vx && vy[k3] === _vy) {
          row.push(k3);
          break;
        }
      }
    }
  }
  for (let i3 = 0; i3 < 16; i3++) {
    const mat = new Matrix();
    mat.set(ux[i3], uy[i3], vx[i3], vy[i3], 0, 0);
    rotationMatrices.push(mat);
  }
}
var ux, uy, vx, vy, rotationCayley, rotationMatrices, signum, groupD8;
var init_groupD8 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/maths/matrix/groupD8.mjs"() {
    init_Matrix();
    ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
    uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
    vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
    vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
    rotationCayley = [];
    rotationMatrices = [];
    signum = Math.sign;
    init();
    groupD8 = {
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 0°       | East      |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      E: 0,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 45°↻     | Southeast |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      SE: 1,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 90°↻     | South     |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      S: 2,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 135°↻    | Southwest |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      SW: 3,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 180°     | West      |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      W: 4,
      /**
       * | Rotation    | Direction    |
       * |-------------|--------------|
       * | -135°/225°↻ | Northwest    |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      NW: 5,
      /**
       * | Rotation    | Direction    |
       * |-------------|--------------|
       * | -90°/270°↻  | North        |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      N: 6,
      /**
       * | Rotation    | Direction    |
       * |-------------|--------------|
       * | -45°/315°↻  | Northeast    |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      NE: 7,
      /**
       * Reflection about Y-axis.
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      MIRROR_VERTICAL: 8,
      /**
       * Reflection about the main diagonal.
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      MAIN_DIAGONAL: 10,
      /**
       * Reflection about X-axis.
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      MIRROR_HORIZONTAL: 12,
      /**
       * Reflection about reverse diagonal.
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      REVERSE_DIAGONAL: 14,
      /**
       * @memberof groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The X-component of the U-axis
       *    after rotating the axes.
       */
      uX: (ind) => ux[ind],
      /**
       * @memberof groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The Y-component of the U-axis
       *    after rotating the axes.
       */
      uY: (ind) => uy[ind],
      /**
       * @memberof groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The X-component of the V-axis
       *    after rotating the axes.
       */
      vX: (ind) => vx[ind],
      /**
       * @memberof groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The Y-component of the V-axis
       *    after rotating the axes.
       */
      vY: (ind) => vy[ind],
      /**
       * @memberof groupD8
       * @param {GD8Symmetry} rotation - symmetry whose opposite
       *   is needed. Only rotations have opposite symmetries while
       *   reflections don't.
       * @returns {GD8Symmetry} The opposite symmetry of `rotation`
       */
      inv: (rotation) => {
        if (rotation & 8) {
          return rotation & 15;
        }
        return -rotation & 7;
      },
      /**
       * Composes the two D8 operations.
       *
       * Taking `^` as reflection:
       *
       * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
       * |-------|-----|-----|-----|-----|------|-------|-------|-------|
       * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
       * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
       * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
       * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
       * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
       * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
       * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
       * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
       *
       * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
       * @memberof groupD8
       * @param {GD8Symmetry} rotationSecond - Second operation, which
       *   is the row in the above cayley table.
       * @param {GD8Symmetry} rotationFirst - First operation, which
       *   is the column in the above cayley table.
       * @returns {GD8Symmetry} Composed operation
       */
      add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
      /**
       * Reverse of `add`.
       * @memberof groupD8
       * @param {GD8Symmetry} rotationSecond - Second operation
       * @param {GD8Symmetry} rotationFirst - First operation
       * @returns {GD8Symmetry} Result
       */
      sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
      /**
       * Adds 180 degrees to rotation, which is a commutative
       * operation.
       * @memberof groupD8
       * @param {number} rotation - The number to rotate.
       * @returns {number} Rotated number
       */
      rotate180: (rotation) => rotation ^ 4,
      /**
       * Checks if the rotation angle is vertical, i.e. south
       * or north. It doesn't work for reflections.
       * @memberof groupD8
       * @param {GD8Symmetry} rotation - The number to check.
       * @returns {boolean} Whether or not the direction is vertical
       */
      isVertical: (rotation) => (rotation & 3) === 2,
      // rotation % 4 === 2
      /**
       * Approximates the vector `V(dx,dy)` into one of the
       * eight directions provided by `groupD8`.
       * @memberof groupD8
       * @param {number} dx - X-component of the vector
       * @param {number} dy - Y-component of the vector
       * @returns {GD8Symmetry} Approximation of the vector into
       *  one of the eight symmetries.
       */
      byDirection: (dx, dy) => {
        if (Math.abs(dx) * 2 <= Math.abs(dy)) {
          if (dy >= 0) {
            return groupD8.S;
          }
          return groupD8.N;
        } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
          if (dx > 0) {
            return groupD8.E;
          }
          return groupD8.W;
        } else if (dy > 0) {
          if (dx > 0) {
            return groupD8.SE;
          }
          return groupD8.SW;
        } else if (dx > 0) {
          return groupD8.NE;
        }
        return groupD8.NW;
      },
      /**
       * Helps sprite to compensate texture packer rotation.
       * @memberof groupD8
       * @param {Matrix} matrix - sprite world matrix
       * @param {GD8Symmetry} rotation - The rotation factor to use.
       * @param {number} tx - sprite anchoring
       * @param {number} ty - sprite anchoring
       */
      matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
        const mat = rotationMatrices[groupD8.inv(rotation)];
        mat.tx = tx;
        mat.ty = ty;
        matrix.append(mat);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureLayout.mjs
var TextureLayout;
var init_TextureLayout = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureLayout.mjs"() {
    init_eventemitter3();
    init_groupD8();
    init_Rectangle();
    TextureLayout = class extends eventemitter3_default {
      constructor(options = {}) {
        super();
        this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };
        this.frame = options.frame || new Rectangle(0, 0, 1, 1);
        this.orig = options.orig || this.frame;
        this.rotate = options.rotate ?? 0;
        this.trim = options.trim;
        this.defaultAnchor = options.defaultAnchor;
        this.defaultBorders = options.defaultBorders;
        this.updateUvs();
      }
      updateUvs() {
        const uvs = this.uvs;
        const frame = this.frame;
        let rotate = this.rotate;
        if (rotate) {
          const w2 = frame.width / 2;
          const h2 = frame.height / 2;
          const cX = frame.x + w2;
          const cY = frame.y + h2;
          rotate = groupD8.add(rotate, groupD8.NW);
          uvs.x0 = cX + w2 * groupD8.uX(rotate);
          uvs.y0 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          uvs.x1 = cX + w2 * groupD8.uX(rotate);
          uvs.y1 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          uvs.x2 = cX + w2 * groupD8.uX(rotate);
          uvs.y2 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          uvs.x3 = cX + w2 * groupD8.uX(rotate);
          uvs.y3 = cY + h2 * groupD8.uY(rotate);
        } else {
          uvs.x0 = frame.x;
          uvs.y0 = frame.y;
          uvs.x1 = frame.x + frame.width;
          uvs.y1 = frame.y;
          uvs.x2 = frame.x + frame.width;
          uvs.y2 = frame.y + frame.height;
          uvs.x3 = frame.x;
          uvs.y3 = frame.y + frame.height;
        }
      }
      update() {
        this.updateUvs();
        this.emit("update", this);
      }
      /** Destroys this TextureLayout */
      destroy() {
        this.emit("destroy", this);
        this.removeAllListeners();
        this.frame = null;
        this.orig = null;
        this.trim = null;
        this.defaultAnchor = null;
        this.uvs = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs
var tempMat, TextureMatrix;
var init_TextureMatrix = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs"() {
    init_Matrix();
    tempMat = new Matrix();
    TextureMatrix = class {
      /**
       * @param texture - observed texture
       * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
       */
      constructor(texture, clampMargin) {
        this.mapCoord = new Matrix();
        this.uClampFrame = new Float32Array(4);
        this.uClampOffset = new Float32Array(2);
        this._textureID = -1;
        this._updateID = 0;
        this.clampOffset = 0;
        this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
        this.isSimple = false;
        this.texture = texture;
      }
      /** Texture property. */
      get texture() {
        return this._texture;
      }
      set texture(value) {
        if (this.texture === value)
          return;
        this._texture?.removeListener("update", this.update, this);
        this._texture = value;
        this._texture.addListener("update", this.update, this);
        this.update();
      }
      /**
       * Multiplies uvs array to transform
       * @param uvs - mesh uvs
       * @param [out=uvs] - output
       * @returns - output
       */
      multiplyUvs(uvs, out3) {
        if (out3 === void 0) {
          out3 = uvs;
        }
        const mat = this.mapCoord;
        for (let i3 = 0; i3 < uvs.length; i3 += 2) {
          const x3 = uvs[i3];
          const y2 = uvs[i3 + 1];
          out3[i3] = x3 * mat.a + y2 * mat.c + mat.tx;
          out3[i3 + 1] = x3 * mat.b + y2 * mat.d + mat.ty;
        }
        return out3;
      }
      update() {
        const tex = this._texture;
        this._updateID++;
        const uvs = tex.layout.uvs;
        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
        const orig = tex.layout.orig;
        const trim = tex.layout.trim;
        if (trim) {
          tempMat.set(
            orig.width / trim.width,
            0,
            0,
            orig.height / trim.height,
            -trim.x / trim.width,
            -trim.y / trim.height
          );
          this.mapCoord.append(tempMat);
        }
        const texBase = tex.source;
        const frame = this.uClampFrame;
        const margin = this.clampMargin / texBase._resolution;
        const offset = this.clampOffset;
        frame[0] = (tex.frameX + margin + offset) / texBase.width;
        frame[1] = (tex.frameY + margin + offset) / texBase.height;
        frame[2] = (tex.frameX + tex.frameWidth - margin + offset) / texBase.width;
        frame[3] = (tex.frameY + tex.frameHeight - margin + offset) / texBase.height;
        this.uClampOffset[0] = offset / texBase.pixelWidth;
        this.uClampOffset[1] = offset / texBase.pixelHeight;
        this.isSimple = tex.frameWidth === texBase.width && tex.frameHeight === texBase.height && tex.layout.rotate === 0;
        return true;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs
var Texture;
var init_Texture = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"() {
    init_eventemitter3();
    init_Cache();
    init_uid();
    init_deprecation();
    init_NOOP();
    init_BufferImageSource();
    init_TextureSource();
    init_TextureLayout();
    init_TextureMatrix();
    Texture = class _Texture extends eventemitter3_default {
      constructor({ source: source3, layout, label, frame } = {}) {
        super();
        this.id = uid("texture");
        this.styleSourceKey = 0;
        this.label = label;
        this.source = source3?.source ?? new TextureSource();
        layout = layout instanceof TextureLayout ? layout : new TextureLayout(layout);
        if (frame) {
          const { width, height } = this._source;
          layout.frame.x = frame.x / width;
          layout.frame.y = frame.y / height;
          layout.frame.width = frame.width / width;
          layout.frame.height = frame.height / height;
          layout.updateUvs();
        }
        this.layout = layout;
        this.destroyed = false;
      }
      static from(id) {
        if (typeof id === "string") {
          return Cache.get(id);
        } else if (id instanceof TextureSource) {
          return new _Texture({ source: id });
        }
        return new _Texture({
          source: new TextureSource(id)
        });
      }
      static fromBuffer(options) {
        return new _Texture({
          source: BufferImageSource.from({
            ...options,
            style: {
              scaleMode: "nearest"
            }
          })
        });
      }
      set source(value) {
        if (this._source) {
          this._source.off("resize", this.onUpdate, this);
        }
        this._source = value;
        value.on("resize", this.onUpdate, this);
        this.emit("update", this);
      }
      get source() {
        return this._source;
      }
      get layout() {
        return this._layout;
      }
      set layout(value) {
        this._layout?.off("update", this.onUpdate, this);
        this._layout = value;
        value.on("update", this.onUpdate, this);
        this.emit("update", this);
      }
      get textureMatrix() {
        if (!this._textureMatrix) {
          this._textureMatrix = new TextureMatrix(this);
        }
        return this._textureMatrix;
      }
      set frameWidth(value) {
        this._layout.frame.width = value / this._source.width;
      }
      get frameWidth() {
        return this._source.pixelWidth / this._source._resolution * this._layout.frame.width;
      }
      set frameHeight(value) {
        this._layout.frame.height = value / this._source.height;
      }
      get frameHeight() {
        return this._source.pixelHeight / this._source._resolution * this._layout.frame.height;
      }
      set frameX(value) {
        if (value === 0) {
          this._layout.frame.x = 0;
          return;
        }
        this._layout.frame.x = this._source.width / value;
      }
      get frameX() {
        return this._source.width * this._layout.frame.x;
      }
      set frameY(value) {
        if (value === 0) {
          this._layout.frame.y = 0;
          return;
        }
        this._layout.frame.y = this._source.height / value;
      }
      get frameY() {
        return this._source.height * this._layout.frame.y;
      }
      /** The width of the Texture in pixels. */
      get width() {
        return this._source.width * this._layout.orig.width;
      }
      /** The height of the Texture in pixels. */
      get height() {
        return this._source.height * this._layout.orig.height;
      }
      /**
       * Destroys this texture
       * @param destroySource - Destroy the source when the texture is destroyed.
       */
      destroy(destroySource = false) {
        if (this._layout) {
          this._layout.destroy();
          this._layout = null;
        }
        if (this._source) {
          if (destroySource) {
            this._source.destroy();
            this._source = null;
          }
        }
        this._textureMatrix = null;
        this.destroyed = true;
        this.emit("destroy", this);
        this.removeAllListeners();
      }
      /**
       * @internal
       */
      onUpdate() {
        this.emit("update", this);
      }
      /** @deprecated since 8.0.0 */
      get baseTexture() {
        deprecation(v8_0_0, "Texture.baseTexture is now Texture.source");
        return this._source;
      }
    };
    Texture.EMPTY = new Texture({});
    Texture.EMPTY.label = "EMPTY";
    Texture.EMPTY.destroy = NOOP;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/bitmap/AbstractBitmapFont.mjs
var AbstractBitmapFont;
var init_AbstractBitmapFont = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/bitmap/AbstractBitmapFont.mjs"() {
    init_eventemitter3();
    init_deprecation();
    AbstractBitmapFont = class extends eventemitter3_default {
      constructor() {
        super(...arguments);
        this.chars = /* @__PURE__ */ Object.create(null);
        this.lineHeight = 0;
        this.fontFamily = "";
        this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };
        this.baseLineOffset = 0;
        this.distanceField = { type: "none", range: 0 };
        this.pages = [];
        this.baseMeasurementFontSize = 100;
        this.baseRenderedFontSize = 100;
      }
      /**
       * @deprecated since 8.0.0
       * The name of the font face.
       */
      get font() {
        deprecation(v8_0_0, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");
        return this.fontFamily;
      }
      /** @deprecated since 8.0.0 */
      get pageTextures() {
        deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
        return this.pages;
      }
      /**
       * @deprecated since 8.0.0
       * The size of the font face in pixels.
       */
      get size() {
        deprecation(v8_0_0, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");
        return this.fontMetrics.fontSize;
      }
      /**
       * @deprecated since 8.0.0
       * The kind of distance field for this font or "none".
       */
      get distanceFieldRange() {
        deprecation(v8_0_0, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");
        return this.distanceField.range;
      }
      /**
       * @deprecated since 8.0.0
       * The range of the distance field in pixels.
       */
      get distanceFieldType() {
        deprecation(v8_0_0, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");
        return this.distanceField.type;
      }
      destroy() {
        this.emit("destroy", this);
        this.removeAllListeners();
        for (const i3 in this.chars) {
          this.chars[i3].texture.destroy();
        }
        this.chars = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/bitmap/BitmapFont.mjs
var BitmapFont;
var init_BitmapFont = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/bitmap/BitmapFont.mjs"() {
    init_Rectangle();
    init_Texture();
    init_AbstractBitmapFont();
    BitmapFont = class extends AbstractBitmapFont {
      constructor(options) {
        super();
        const { textures, data } = options;
        Object.keys(data.pages).forEach((key2) => {
          const pageData = data.pages[parseInt(key2, 10)];
          const texture = textures[pageData.id];
          this.pages.push({ texture });
        });
        Object.keys(data.chars).forEach((key2) => {
          const charData = data.chars[key2];
          const textureSource = textures[charData.page].source;
          const frame = new Rectangle(
            charData.x / textureSource.width,
            charData.y / textureSource.height,
            charData.width / textureSource.width,
            charData.height / textureSource.height
          );
          const texture = new Texture({
            source: textureSource,
            layout: {
              frame
            }
          });
          this.chars[key2] = {
            id: key2.codePointAt(0),
            xOffset: charData.xOffset,
            yOffset: charData.yOffset,
            xAdvance: charData.xAdvance,
            kerning: charData.kerning ?? {},
            texture
          };
        });
        this.baseRenderedFontSize = data.fontSize;
        const writable = this;
        writable.baseMeasurementFontSize = data.fontSize;
        writable.fontMetrics = {
          ascent: 0,
          descent: 0,
          fontSize: data.fontSize
        };
        writable.baseLineOffset = data.baseLineOffset;
        writable.lineHeight = data.lineHeight;
        writable.fontFamily = data.fontFamily;
        writable.distanceField = data.distanceField ?? {
          type: "none",
          range: 0
        };
      }
      destroy() {
        super.destroy();
        for (let i3 = 0; i3 < this.pages.length; i3++) {
          const { texture } = this.pages[i3];
          texture.destroy(true);
        }
        this.pages = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/bitmap/asset/textFormat.mjs
var TextFormat;
var init_textFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/bitmap/asset/textFormat.mjs"() {
    TextFormat = {
      test(data) {
        return typeof data === "string" && data.startsWith("info face=");
      },
      parse(txt) {
        const items = txt.match(/^[a-z]+\s+.+$/gm);
        const rawData = {
          info: [],
          common: [],
          page: [],
          char: [],
          chars: [],
          kerning: [],
          kernings: [],
          distanceField: []
        };
        for (const i3 in items) {
          const name = items[i3].match(/^[a-z]+/gm)[0];
          const attributeList = items[i3].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
          const itemData = {};
          for (const i22 in attributeList) {
            const split = attributeList[i22].split("=");
            const key2 = split[0];
            const strValue = split[1].replace(/"/gm, "");
            const floatValue = parseFloat(strValue);
            const value = isNaN(floatValue) ? strValue : floatValue;
            itemData[key2] = value;
          }
          rawData[name].push(itemData);
        }
        const font = {
          chars: {},
          pages: [],
          lineHeight: 0,
          fontSize: 0,
          fontFamily: "",
          distanceField: null,
          baseLineOffset: 0
        };
        const [info] = rawData.info;
        const [common] = rawData.common;
        const [distanceField] = rawData.distanceField ?? [];
        if (distanceField) {
          font.distanceField = {
            range: parseInt(distanceField.distanceRange, 10),
            type: distanceField.fieldType
          };
        }
        font.fontSize = parseInt(info.size, 10);
        font.fontFamily = info.face;
        font.lineHeight = parseInt(common.lineHeight, 10);
        const page = rawData.page;
        for (let i3 = 0; i3 < page.length; i3++) {
          font.pages.push({
            id: parseInt(page[i3].id, 10) || 0,
            file: page[i3].file
          });
        }
        const map5 = {};
        font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);
        const char = rawData.char;
        for (let i3 = 0; i3 < char.length; i3++) {
          const charNode = char[i3];
          const id = parseInt(charNode.id, 10);
          let letter = charNode.letter ?? charNode.char;
          if (letter === "space")
            letter = " ";
          map5[id] = letter;
          font.chars[letter] = {
            id,
            // texture deets..
            page: parseInt(charNode.page, 10) || 0,
            x: parseInt(charNode.x, 10),
            y: parseInt(charNode.y, 10),
            width: parseInt(charNode.width, 10),
            height: parseInt(charNode.height, 10),
            xOffset: parseInt(charNode.xoffset, 10),
            yOffset: parseInt(charNode.yoffset, 10),
            xAdvance: parseInt(charNode.xadvance, 10),
            kerning: {}
          };
        }
        const kerning = rawData.kerning || [];
        for (let i3 = 0; i3 < kerning.length; i3++) {
          const first = parseInt(kerning[i3].first, 10);
          const second = parseInt(kerning[i3].second, 10);
          const amount = parseInt(kerning[i3].amount, 10);
          font.chars[map5[second]].kerning[map5[first]] = amount;
        }
        return font;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/bitmap/asset/xmlFormat.mjs
var XMLFormat;
var init_xmlFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/bitmap/asset/xmlFormat.mjs"() {
    XMLFormat = {
      test(data) {
        const xml = data;
        return typeof xml !== "string" && "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
      },
      parse(xml) {
        const data = {
          chars: {},
          pages: [],
          lineHeight: 0,
          fontSize: 0,
          fontFamily: "",
          distanceField: null,
          baseLineOffset: 0
        };
        const info = xml.getElementsByTagName("info")[0];
        const common = xml.getElementsByTagName("common")[0];
        const distanceField = xml.getElementsByTagName("distanceField")[0];
        if (distanceField) {
          data.distanceField = {
            type: distanceField.getAttribute("fieldType"),
            range: parseInt(distanceField.getAttribute("distanceRange"), 10)
          };
        }
        const page = xml.getElementsByTagName("page");
        const char = xml.getElementsByTagName("char");
        const kerning = xml.getElementsByTagName("kerning");
        data.fontSize = parseInt(info.getAttribute("size"), 10);
        data.fontFamily = info.getAttribute("face");
        data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10);
        for (let i3 = 0; i3 < page.length; i3++) {
          data.pages.push({
            id: parseInt(page[i3].getAttribute("id"), 10) || 0,
            file: page[i3].getAttribute("file")
          });
        }
        const map5 = {};
        data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute("base"), 10);
        for (let i3 = 0; i3 < char.length; i3++) {
          const charNode = char[i3];
          const id = parseInt(charNode.getAttribute("id"), 10);
          let letter = charNode.getAttribute("letter") ?? charNode.getAttribute("char");
          if (letter === "space")
            letter = " ";
          map5[id] = letter;
          data.chars[letter] = {
            id,
            // texture deets..
            page: parseInt(charNode.getAttribute("page"), 10) || 0,
            x: parseInt(charNode.getAttribute("x"), 10),
            y: parseInt(charNode.getAttribute("y"), 10),
            width: parseInt(charNode.getAttribute("width"), 10),
            height: parseInt(charNode.getAttribute("height"), 10),
            // render deets..
            xOffset: parseInt(charNode.getAttribute("xoffset"), 10),
            yOffset: parseInt(charNode.getAttribute("yoffset"), 10),
            // + baseLineOffset,
            xAdvance: parseInt(charNode.getAttribute("xadvance"), 10),
            kerning: {}
          };
        }
        for (let i3 = 0; i3 < kerning.length; i3++) {
          const first = parseInt(kerning[i3].getAttribute("first"), 10);
          const second = parseInt(kerning[i3].getAttribute("second"), 10);
          const amount = parseInt(kerning[i3].getAttribute("amount"), 10);
          data.chars[map5[second]].kerning[map5[first]] = amount;
        }
        return data;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/bitmap/asset/xmlStringFormat.mjs
var XMLStringFormat;
var init_xmlStringFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/bitmap/asset/xmlStringFormat.mjs"() {
    init_settings();
    init_xmlFormat();
    XMLStringFormat = {
      test(data) {
        if (typeof data === "string" && data.includes("<font>")) {
          return XMLFormat.test(settings.ADAPTER.parseXML(data));
        }
        return false;
      },
      parse(data) {
        return XMLFormat.parse(settings.ADAPTER.parseXML(data));
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/bitmap/asset/loadBitmapFont.mjs
var validExtensions, bitmapFontCachePlugin, xmlBitmapFontLoader;
var init_loadBitmapFont = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/bitmap/asset/loadBitmapFont.mjs"() {
    init_LoaderParser();
    init_copySearchParams();
    init_Extensions();
    init_settings();
    init_path();
    init_BitmapFont();
    init_textFormat();
    init_xmlStringFormat();
    validExtensions = [".xml", ".fnt"];
    bitmapFontCachePlugin = {
      extension: ExtensionType.CacheParser,
      test: (asset) => asset instanceof BitmapFont,
      getCacheableAssets(keys, asset) {
        const out3 = {};
        keys.forEach((key2) => {
          out3[key2] = asset;
        });
        out3[asset.fontFamily] = asset;
        return out3;
      }
    };
    xmlBitmapFontLoader = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Normal
      },
      test(url2) {
        return validExtensions.includes(path.extname(url2).toLowerCase());
      },
      async testParse(data) {
        return TextFormat.test(data) || XMLStringFormat.test(data);
      },
      async parse(asset, data, loader) {
        const bitmapFontData = TextFormat.test(asset) ? TextFormat.parse(asset) : XMLStringFormat.parse(asset);
        const { src } = data;
        const { pages } = bitmapFontData;
        const textureUrls = [];
        for (let i3 = 0; i3 < pages.length; ++i3) {
          const pageFile = pages[i3].file;
          let imagePath = path.join(path.dirname(src), pageFile);
          imagePath = copySearchParams(imagePath, src);
          textureUrls.push(imagePath);
        }
        const loadedTextures = await loader.load(textureUrls);
        const textures = textureUrls.map((url2) => loadedTextures[url2]);
        const bitmapFont = new BitmapFont({
          data: bitmapFontData,
          textures
        });
        return bitmapFont;
      },
      async load(url2, _options) {
        const response = await settings.ADAPTER.fetch(url2);
        return await response.text();
      },
      unload(bitmapFont) {
        bitmapFont.destroy();
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs
var cacheTextureArray;
var init_cacheTextureArray = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs"() {
    init_Extensions();
    init_Texture();
    cacheTextureArray = {
      extension: ExtensionType.CacheParser,
      test: (asset) => Array.isArray(asset) && asset.every((t2) => t2 instanceof Texture),
      getCacheableAssets: (keys, asset) => {
        const out3 = {};
        keys.forEach((key2) => {
          asset.forEach((item, i3) => {
            out3[key2 + (i3 === 0 ? "" : i3 + 1)] = item;
          });
        });
        return out3;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs
async function testImageFormat(imageData) {
  if ("Image" in globalThis) {
    return new Promise((resolve2) => {
      const image = new Image();
      image.onload = () => {
        resolve2(true);
      };
      image.onerror = () => {
        resolve2(false);
      };
      image.src = imageData;
    });
  }
  if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
    try {
      const blob = await (await fetch(imageData)).blob();
      await createImageBitmap(blob);
    } catch (e3) {
      return false;
    }
    return true;
  }
  return false;
}
var init_testImageFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs
var detectAvif;
var init_detectAvif = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs"() {
    init_Extensions();
    init_testImageFormat();
    detectAvif = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 1
      },
      test: async () => testImageFormat(
        // eslint-disable-next-line max-len
        "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
      ),
      add: async (formats) => [...formats, "avif"],
      remove: async (formats) => formats.filter((f3) => f3 !== "avif")
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs
var imageFormats, detectDefaults;
var init_detectDefaults = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs"() {
    init_Extensions();
    imageFormats = ["png", "jpg", "jpeg"];
    detectDefaults = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: -1
      },
      test: () => Promise.resolve(true),
      add: async (formats) => [...formats, ...imageFormats],
      remove: async (formats) => formats.filter((f3) => !imageFormats.includes(f3))
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs
function testVideoFormat(mimeType) {
  if (inWorker) {
    return false;
  }
  const video = document.createElement("video");
  return video.canPlayType(mimeType) !== "";
}
var inWorker;
var init_testVideoFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs"() {
    inWorker = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs
var detectMp4;
var init_detectMp4 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs"() {
    init_Extensions();
    init_testVideoFormat();
    detectMp4 = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 0
      },
      test: async () => testVideoFormat("video/mp4"),
      add: async (formats) => [...formats, "mp4", "m4v"],
      remove: async (formats) => formats.filter((f3) => f3 !== "mp4" && f3 !== "m4v")
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs
var detectOgv;
var init_detectOgv = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs"() {
    init_Extensions();
    init_testVideoFormat();
    detectOgv = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 0
      },
      test: async () => testVideoFormat("video/ogg"),
      add: async (formats) => [...formats, "ogv"],
      remove: async (formats) => formats.filter((f3) => f3 !== "ogv")
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs
var detectWebm;
var init_detectWebm = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs"() {
    init_Extensions();
    init_testVideoFormat();
    detectWebm = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 0
      },
      test: async () => testVideoFormat("video/webm"),
      add: async (formats) => [...formats, "webm"],
      remove: async (formats) => formats.filter((f3) => f3 !== "webm")
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs
var detectWebp;
var init_detectWebp = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs"() {
    init_Extensions();
    init_testImageFormat();
    detectWebp = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 0
      },
      test: async () => testImageFormat(
        "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="
      ),
      add: async (formats) => [...formats, "webp"],
      remove: async (formats) => formats.filter((f3) => f3 !== "webp")
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs
function checkDataUrl(url2, mimes) {
  if (Array.isArray(mimes)) {
    for (const mime of mimes) {
      if (url2.startsWith(`data:${mime}`))
        return true;
    }
    return false;
  }
  return url2.startsWith(`data:${mimes}`);
}
var init_checkDataUrl = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/utils/checkExtension.mjs
function checkExtension(url2, extension) {
  const tempURL = url2.split("?")[0];
  const ext = path.extname(tempURL).toLowerCase();
  if (Array.isArray(extension)) {
    return extension.includes(ext);
  }
  return ext === extension;
}
var init_checkExtension = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/utils/checkExtension.mjs"() {
    init_path();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs
var validJSONExtension, validJSONMIME, loadJson;
var init_loadJson = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs"() {
    init_Extensions();
    init_settings();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    validJSONExtension = ".json";
    validJSONMIME = "application/json";
    loadJson = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Low
      },
      name: "loadJson",
      test(url2) {
        return checkDataUrl(url2, validJSONMIME) || checkExtension(url2, validJSONExtension);
      },
      async load(url2) {
        const response = await settings.ADAPTER.fetch(url2);
        const json = await response.json();
        return json;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs
var validTXTExtension, validTXTMIME, loadTxt;
var init_loadTxt = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs"() {
    init_Extensions();
    init_settings();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    validTXTExtension = ".txt";
    validTXTMIME = "text/plain";
    loadTxt = {
      name: "loadTxt",
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Low
      },
      test(url2) {
        return checkDataUrl(url2, validTXTMIME) || checkExtension(url2, validTXTExtension);
      },
      async load(url2) {
        const response = await settings.ADAPTER.fetch(url2);
        const txt = await response.text();
        return txt;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs
function getFontFamilyName(url2) {
  const ext = path.extname(url2);
  const name = path.basename(url2, ext);
  const nameWithSpaces = name.replace(/(-|_)/g, " ");
  const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
  let valid = nameTokens.length > 0;
  for (const token of nameTokens) {
    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
      valid = false;
      break;
    }
  }
  let fontFamilyName = nameTokens.join(" ");
  if (!valid) {
    fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`;
  }
  return fontFamilyName;
}
function encodeURIWhenNeeded(uri) {
  if (validURICharactersRegex.test(uri)) {
    return uri;
  }
  return encodeURI(uri);
}
var validWeights, validFontExtensions, validFontMIMEs, CSS_IDENT_TOKEN_REGEX, validURICharactersRegex, loadWebFont;
var init_loadWebFont = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs"() {
    init_Extensions();
    init_settings();
    init_warn();
    init_path();
    init_Cache();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    validWeights = [
      "normal",
      "bold",
      "100",
      "200",
      "300",
      "400",
      "500",
      "600",
      "700",
      "800",
      "900"
    ];
    validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];
    validFontMIMEs = [
      "font/ttf",
      "font/otf",
      "font/woff",
      "font/woff2"
    ];
    CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
    validURICharactersRegex = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
    loadWebFont = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Low
      },
      name: "loadWebFont",
      test(url2) {
        return checkDataUrl(url2, validFontMIMEs) || checkExtension(url2, validFontExtensions);
      },
      async load(url2, options) {
        const fonts = settings.ADAPTER.getFontFaceSet();
        if (fonts) {
          const fontFaces = [];
          const name = options.data?.family ?? getFontFamilyName(url2);
          const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"];
          const data = options.data ?? {};
          for (let i3 = 0; i3 < weights.length; i3++) {
            const weight = weights[i3];
            const font = new FontFace(name, `url(${encodeURIWhenNeeded(url2)})`, {
              ...data,
              weight
            });
            await font.load();
            fonts.add(font);
            fontFaces.push(font);
          }
          Cache.set(name, {
            url: url2,
            fontFaces
          });
          return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
        }
        warn("[loadWebFont] FontFace API is not supported. Skipping loading font");
        return null;
      },
      unload(font) {
        (Array.isArray(font) ? font : [font]).forEach((t2) => {
          Cache.remove(t2.family);
          settings.ADAPTER.getFontFaceSet().delete(t2);
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs
function SVGToGraphicsPath(svgPath, path4) {
  const commands = svgPath.match(/[a-df-z][^a-df-z]*/gi);
  const data = svgPath.match(/[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/g)?.map(parseFloat);
  const betterCommands = [];
  commands.forEach((command) => {
    const data2 = command.match(/[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/g)?.map(parseFloat);
    const type2 = command[0];
    let totalInstructions = 1;
    if (data2) {
      totalInstructions = data2.length / commandSizeMap[type2.toLowerCase()];
    }
    for (let i3 = 0; i3 < totalInstructions; i3++) {
      betterCommands.push(type2);
    }
  });
  let dataIndex = 0;
  let lastX = 0;
  let lastY = 0;
  for (let i3 = 0; i3 < betterCommands.length; i3++) {
    const type2 = betterCommands[i3];
    switch (type2) {
      case "M":
        lastX = data[dataIndex++];
        lastY = data[dataIndex++];
        path4.moveTo(lastX, lastY);
        break;
      case "m":
        lastX += data[dataIndex++];
        lastY += data[dataIndex++];
        path4.moveTo(lastX, lastY);
        break;
      case "H":
        lastX = data[dataIndex++];
        path4.lineTo(lastX, lastY);
        break;
      case "h":
        lastX += data[dataIndex++];
        path4.lineTo(lastX, lastY);
        break;
      case "V":
        lastY = data[dataIndex++];
        path4.lineTo(lastX, lastY);
        break;
      case "v":
        lastY += data[dataIndex++];
        path4.lineTo(lastX, lastY);
        break;
      case "L":
        lastX = data[dataIndex++];
        lastY = data[dataIndex++];
        path4.lineTo(lastX, lastY);
        break;
      case "l":
        lastX += data[dataIndex++];
        lastY += data[dataIndex++];
        path4.lineTo(lastX, lastY);
        break;
      case "C":
        lastX = data[dataIndex + 4];
        lastY = data[dataIndex + 5];
        path4.bezierCurveTo(
          data[dataIndex],
          data[dataIndex + 1],
          data[dataIndex + 2],
          data[dataIndex + 3],
          lastX,
          lastY
        );
        dataIndex += 6;
        break;
      case "c":
        path4.bezierCurveTo(
          lastX + data[dataIndex],
          lastY + data[dataIndex + 1],
          lastX + data[dataIndex + 2],
          lastY + data[dataIndex + 3],
          lastX + data[dataIndex + 4],
          lastY + data[dataIndex + 5]
        );
        lastX += data[dataIndex + 4];
        lastY += data[dataIndex + 5];
        dataIndex += 6;
        break;
      case "S":
        lastX = data[dataIndex + 2];
        lastY = data[dataIndex + 3];
        path4.bezierCurveToShort(
          data[dataIndex],
          data[dataIndex + 1],
          lastX,
          lastY
        );
        dataIndex += 4;
        break;
      case "s":
        path4.bezierCurveToShort(
          lastX + data[dataIndex],
          lastY + data[dataIndex + 1],
          lastX + data[dataIndex + 2],
          lastY + data[dataIndex + 3]
        );
        lastX += data[dataIndex + 2];
        lastY += data[dataIndex + 3];
        dataIndex += 4;
        break;
      case "Q":
        lastX = data[dataIndex + 2];
        lastY = data[dataIndex + 3];
        path4.quadraticCurveTo(
          data[dataIndex],
          data[dataIndex + 1],
          lastX,
          lastY
        );
        dataIndex += 4;
        break;
      case "q":
        path4.quadraticCurveTo(
          lastX + data[dataIndex],
          lastY + data[dataIndex + 1],
          lastX + data[dataIndex + 2],
          lastY + data[dataIndex + 3]
        );
        lastX += data[dataIndex + 2];
        lastY += data[dataIndex + 3];
        dataIndex += 4;
        break;
      case "T":
        lastX = data[dataIndex++];
        lastY = data[dataIndex++];
        path4.quadraticCurveToShort(
          lastX,
          lastY
        );
        break;
      case "t":
        lastX += data[dataIndex++];
        lastY += data[dataIndex++];
        path4.quadraticCurveToShort(
          lastX,
          lastY
        );
        break;
      case "A":
        lastX = data[dataIndex + 5];
        lastY = data[dataIndex + 6];
        path4.arcToSvg(
          data[dataIndex],
          data[dataIndex + 1],
          data[dataIndex + 2],
          data[dataIndex + 3],
          data[dataIndex + 4],
          lastX,
          lastY
        );
        dataIndex += 7;
        break;
      case "a":
        lastX += data[dataIndex + 5];
        lastY += data[dataIndex + 6];
        path4.arcToSvg(
          data[dataIndex],
          data[dataIndex + 1],
          data[dataIndex + 2],
          data[dataIndex + 3],
          data[dataIndex + 4],
          lastX,
          lastY
        );
        dataIndex += 7;
        break;
      case "Z":
      case "z":
        path4.closePath();
        break;
      default:
        warn(`Unknown SVG path command: ${type2}`);
    }
  }
  return path4;
}
var commandSizeMap;
var init_SVGToGraphicsPath = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs"() {
    init_warn();
    commandSizeMap = {
      a: 7,
      c: 6,
      h: 1,
      l: 2,
      m: 2,
      q: 4,
      s: 4,
      t: 2,
      v: 1,
      z: 0
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/maths/shapes/Circle.mjs
var Circle;
var init_Circle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/maths/shapes/Circle.mjs"() {
    init_Rectangle();
    Circle = class _Circle {
      /**
       * @param x - The X coordinate of the center of this circle
       * @param y - The Y coordinate of the center of this circle
       * @param radius - The radius of the circle
       */
      constructor(x3 = 0, y2 = 0, radius = 0) {
        this.type = "circle";
        this.x = x3;
        this.y = y2;
        this.radius = radius;
      }
      /**
       * Creates a clone of this Circle instance
       * @returns A copy of the Circle
       */
      clone() {
        return new _Circle(this.x, this.y, this.radius);
      }
      /**
       * Checks whether the x and y coordinates given are contained within this circle
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coordinates are within this Circle
       */
      contains(x3, y2) {
        if (this.radius <= 0) {
          return false;
        }
        const r2 = this.radius * this.radius;
        let dx = this.x - x3;
        let dy = this.y - y2;
        dx *= dx;
        dy *= dy;
        return dx + dy <= r2;
      }
      /**
       * Returns the framing rectangle of the circle as a Rectangle object
       * @param out
       * @returns The framing rectangle
       */
      getBounds(out3) {
        out3 = out3 || new Rectangle();
        out3.x = this.x - this.radius;
        out3.y = this.y - this.radius;
        out3.width = this.radius * 2;
        out3.height = this.radius * 2;
        return out3;
      }
      /**
       * Copies another circle to this one.
       * @param circle - The circle to copy from.
       * @returns Returns itself.
       */
      copyFrom(circle) {
        this.x = circle.x;
        this.y = circle.y;
        this.radius = circle.radius;
        return this;
      }
      /**
       * Copies this circle to another one.
       * @param circle - The circle to copy to.
       * @returns Returns given parameter.
       */
      copyTo(circle) {
        circle.copyFrom(this);
        return circle;
      }
      toString() {
        return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs
var Ellipse;
var init_Ellipse = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs"() {
    init_Rectangle();
    Ellipse = class _Ellipse {
      /**
       * @param x - The X coordinate of the center of this ellipse
       * @param y - The Y coordinate of the center of this ellipse
       * @param halfWidth - The half width of this ellipse
       * @param halfHeight - The half height of this ellipse
       */
      constructor(x3 = 0, y2 = 0, halfWidth = 0, halfHeight = 0) {
        this.type = "ellipse";
        this.x = x3;
        this.y = y2;
        this.halfWidth = halfWidth;
        this.halfHeight = halfHeight;
      }
      /**
       * Creates a clone of this Ellipse instance
       * @returns {Ellipse} A copy of the ellipse
       */
      clone() {
        return new _Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);
      }
      /**
       * Checks whether the x and y coordinates given are contained within this ellipse
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coords are within this ellipse
       */
      contains(x3, y2) {
        if (this.halfWidth <= 0 || this.halfHeight <= 0) {
          return false;
        }
        let normx = (x3 - this.x) / this.halfWidth;
        let normy = (y2 - this.y) / this.halfHeight;
        normx *= normx;
        normy *= normy;
        return normx + normy <= 1;
      }
      /**
       * Returns the framing rectangle of the ellipse as a Rectangle object
       * @returns The framing rectangle
       */
      getBounds() {
        return new Rectangle(this.x - this.halfWidth, this.y - this.halfHeight, this.halfWidth * 2, this.halfHeight * 2);
      }
      /**
       * Copies another ellipse to this one.
       * @param ellipse - The ellipse to copy from.
       * @returns Returns itself.
       */
      copyFrom(ellipse) {
        this.x = ellipse.x;
        this.y = ellipse.y;
        this.halfWidth = ellipse.halfWidth;
        this.halfHeight = ellipse.halfHeight;
        return this;
      }
      /**
       * Copies this ellipse to another one.
       * @param ellipse - The ellipse to copy to.
       * @returns Returns given parameter.
       */
      copyTo(ellipse) {
        ellipse.copyFrom(this);
        return ellipse;
      }
      toString() {
        return `[@pixi/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/maths/shapes/Polygon.mjs
var Polygon;
var init_Polygon = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/maths/shapes/Polygon.mjs"() {
    init_Rectangle();
    Polygon = class _Polygon {
      /**
       * @param {PointData[]|number[]} points - This can be an array of Points
       *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
       *  the arguments passed can be all the points of the polygon e.g.
       *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
       *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
       */
      constructor(...points) {
        this.type = "polygon";
        let flat = Array.isArray(points[0]) ? points[0] : points;
        if (typeof flat[0] !== "number") {
          const p3 = [];
          for (let i3 = 0, il = flat.length; i3 < il; i3++) {
            p3.push(flat[i3].x, flat[i3].y);
          }
          flat = p3;
        }
        this.points = flat;
        this.closePath = true;
      }
      /**
       * Creates a clone of this polygon.
       * @returns - A copy of the polygon.
       */
      clone() {
        const points = this.points.slice();
        const polygon = new _Polygon(points);
        polygon.closePath = this.closePath;
        return polygon;
      }
      /**
       * Checks whether the x and y coordinates passed to this function are contained within this polygon.
       * @param x - The X coordinate of the point to test.
       * @param y - The Y coordinate of the point to test.
       * @returns - Whether the x/y coordinates are within this polygon.
       */
      contains(x3, y2) {
        let inside = false;
        const length = this.points.length / 2;
        for (let i3 = 0, j3 = length - 1; i3 < length; j3 = i3++) {
          const xi = this.points[i3 * 2];
          const yi = this.points[i3 * 2 + 1];
          const xj = this.points[j3 * 2];
          const yj = this.points[j3 * 2 + 1];
          const intersect = yi > y2 !== yj > y2 && x3 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi;
          if (intersect) {
            inside = !inside;
          }
        }
        return inside;
      }
      /**
       * Returns the framing rectangle of the polygon as a Rectangle object
       * @param out - optional rectangle to store the result
       * @returns The framing rectangle
       */
      getBounds(out3) {
        out3 = out3 || new Rectangle();
        const points = this.points;
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        for (let i3 = 0, n2 = points.length; i3 < n2; i3 += 2) {
          const x3 = points[i3];
          const y2 = points[i3 + 1];
          minX = x3 < minX ? x3 : minX;
          maxX = x3 > maxX ? x3 : maxX;
          minY = y2 < minY ? y2 : minY;
          maxY = y2 > maxY ? y2 : maxY;
        }
        out3.x = minX;
        out3.width = maxX - minX;
        out3.y = minY;
        out3.height = maxY - minY;
        return out3;
      }
      /**
       * Copies another polygon to this one.
       * @param polygon - The polygon to copy from.
       * @returns Returns itself.
       */
      copyFrom(polygon) {
        this.points = polygon.points.slice();
        this.closePath = polygon.closePath;
        return this;
      }
      /**
       * Copies this polygon to another one.
       * @param polygon - The polygon to copy to.
       * @returns Returns given parameter.
       */
      copyTo(polygon) {
        polygon.copyFrom(this);
        return polygon;
      }
      toString() {
        return `[@pixi/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
      }
      /**
       * Get the last X coordinate of the polygon
       * @readonly
       */
      get lastX() {
        return this.points[this.points.length - 2];
      }
      /**
       * Get the last Y coordinate of the polygon
       * @readonly
       */
      get lastY() {
        return this.points[this.points.length - 1];
      }
      /**
       * Get the first X coordinate of the polygon
       * @readonly
       */
      get x() {
        return this.points[this.points.length - 2];
      }
      /**
       * Get the first Y coordinate of the polygon
       * @readonly
       */
      get y() {
        return this.points[this.points.length - 1];
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs
var RoundedRectangle;
var init_RoundedRectangle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs"() {
    init_Rectangle();
    RoundedRectangle = class _RoundedRectangle {
      /**
       * @param x - The X coordinate of the upper-left corner of the rounded rectangle
       * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
       * @param width - The overall width of this rounded rectangle
       * @param height - The overall height of this rounded rectangle
       * @param radius - Controls the radius of the rounded corners
       */
      constructor(x3 = 0, y2 = 0, width = 0, height = 0, radius = 20) {
        this.type = "roundedRectangle";
        this.x = x3;
        this.y = y2;
        this.width = width;
        this.height = height;
        this.radius = radius;
      }
      /**
       * Returns the framing rectangle of the rounded rectangle as a Rectangle object
       * @param out - optional rectangle to store the result
       * @returns The framing rectangle
       */
      getBounds(out3) {
        out3 = out3 || new Rectangle();
        out3.x = this.x;
        out3.y = this.y;
        out3.width = this.width;
        out3.height = this.height;
        return out3;
      }
      /**
       * Creates a clone of this Rounded Rectangle.
       * @returns - A copy of the rounded rectangle.
       */
      clone() {
        return new _RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
      }
      /**
       * Copies another rectangle to this one.
       * @param rectangle - The rectangle to copy from.
       * @returns Returns itself.
       */
      copyFrom(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
      }
      /**
       * Copies this rectangle to another one.
       * @param rectangle - The rectangle to copy to.
       * @returns Returns given parameter.
       */
      copyTo(rectangle) {
        rectangle.copyFrom(this);
        return rectangle;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
       * @param x - The X coordinate of the point to test.
       * @param y - The Y coordinate of the point to test.
       * @returns - Whether the x/y coordinates are within this Rounded Rectangle.
       */
      contains(x3, y2) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x3 >= this.x && x3 <= this.x + this.width) {
          if (y2 >= this.y && y2 <= this.y + this.height) {
            const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
            if (y2 >= this.y + radius && y2 <= this.y + this.height - radius || x3 >= this.x + radius && x3 <= this.x + this.width - radius) {
              return true;
            }
            let dx = x3 - (this.x + radius);
            let dy = y2 - (this.y + radius);
            const radius2 = radius * radius;
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dx = x3 - (this.x + this.width - radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dy = y2 - (this.y + this.height - radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dx = x3 - (this.x + radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
          }
        }
        return false;
      }
      toString() {
        return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs
function buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY) {
  const scale3 = 1;
  let distanceTolerance = PATH_DISTANCE_EPSILON / scale3;
  distanceTolerance *= distanceTolerance;
  begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);
  return points;
}
function begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {
  recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);
  points.push(eX, eY);
}
function recursive(x1, y1, x22, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
  if (level > RECURSION_LIMIT) {
    return;
  }
  const pi = Math.PI;
  const x12 = (x1 + x22) / 2;
  const y12 = (y1 + y2) / 2;
  const x23 = (x22 + x3) / 2;
  const y23 = (y2 + y3) / 2;
  const x34 = (x3 + x4) / 2;
  const y34 = (y3 + y4) / 2;
  const x123 = (x12 + x23) / 2;
  const y123 = (y12 + y23) / 2;
  const x234 = (x23 + x34) / 2;
  const y234 = (y23 + y34) / 2;
  const x1234 = (x123 + x234) / 2;
  const y1234 = (y123 + y234) / 2;
  if (level > 0) {
    let dx = x4 - x1;
    let dy = y4 - y1;
    const d22 = Math.abs((x22 - x4) * dy - (y2 - y4) * dx);
    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);
    let da1;
    let da2;
    if (d22 > FLT_EPSILON && d3 > FLT_EPSILON) {
      if ((d22 + d3) * (d22 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        const a23 = Math.atan2(y3 - y2, x3 - x22);
        da1 = Math.abs(a23 - Math.atan2(y2 - y1, x22 - x1));
        da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da2 >= pi)
          da2 = 2 * pi - da2;
        if (da1 + da2 < mAngleTolerance) {
          points.push(x1234, y1234);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x22, y2);
            return;
          }
          if (da2 > mCuspLimit) {
            points.push(x3, y3);
            return;
          }
        }
      }
    } else if (d22 > FLT_EPSILON) {
      if (d22 * d22 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x22) - Math.atan2(y2 - y1, x22 - x1));
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da1 < mAngleTolerance) {
          points.push(x22, y2);
          points.push(x3, y3);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x22, y2);
            return;
          }
        }
      }
    } else if (d3 > FLT_EPSILON) {
      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x22));
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da1 < mAngleTolerance) {
          points.push(x22, y2);
          points.push(x3, y3);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x3, y3);
            return;
          }
        }
      }
    } else {
      dx = x1234 - (x1 + x4) / 2;
      dy = y1234 - (y1 + y4) / 2;
      if (dx * dx + dy * dy <= distanceTolerance) {
        points.push(x1234, y1234);
        return;
      }
    }
  }
  recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);
  recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);
}
var RECURSION_LIMIT, FLT_EPSILON, PATH_DISTANCE_EPSILON, curveAngleToleranceEpsilon, mAngleTolerance, mCuspLimit;
var init_buildAdaptiveBezier = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs"() {
    RECURSION_LIMIT = 8;
    FLT_EPSILON = 11920929e-14;
    PATH_DISTANCE_EPSILON = 1;
    curveAngleToleranceEpsilon = 0.01;
    mAngleTolerance = 0;
    mCuspLimit = 0;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs
function buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY) {
  const scale3 = 1;
  let distanceTolerance = PATH_DISTANCE_EPSILON2 / scale3;
  distanceTolerance *= distanceTolerance;
  begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);
  return points;
}
function begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {
  recursive2(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);
  points.push(eX, eY);
}
function recursive2(points, x1, y1, x22, y2, x3, y3, distanceTolerance, level) {
  if (level > RECURSION_LIMIT2) {
    return;
  }
  const pi = Math.PI;
  const x12 = (x1 + x22) / 2;
  const y12 = (y1 + y2) / 2;
  const x23 = (x22 + x3) / 2;
  const y23 = (y2 + y3) / 2;
  const x123 = (x12 + x23) / 2;
  const y123 = (y12 + y23) / 2;
  let dx = x3 - x1;
  let dy = y3 - y1;
  const d3 = Math.abs((x22 - x3) * dy - (y2 - y3) * dx);
  if (d3 > FLT_EPSILON2) {
    if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
      if (mAngleTolerance2 < curveAngleToleranceEpsilon2) {
        points.push(x123, y123);
        return;
      }
      let da = Math.abs(Math.atan2(y3 - y2, x3 - x22) - Math.atan2(y2 - y1, x22 - x1));
      if (da >= pi)
        da = 2 * pi - da;
      if (da < mAngleTolerance2) {
        points.push(x123, y123);
        return;
      }
    }
  } else {
    dx = x123 - (x1 + x3) / 2;
    dy = y123 - (y1 + y3) / 2;
    if (dx * dx + dy * dy <= distanceTolerance) {
      points.push(x123, y123);
      return;
    }
  }
  recursive2(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);
  recursive2(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);
}
var RECURSION_LIMIT2, FLT_EPSILON2, PATH_DISTANCE_EPSILON2, curveAngleToleranceEpsilon2, mAngleTolerance2;
var init_buildAdaptiveQuadratic = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs"() {
    RECURSION_LIMIT2 = 8;
    FLT_EPSILON2 = 11920929e-14;
    PATH_DISTANCE_EPSILON2 = 1;
    curveAngleToleranceEpsilon2 = 0.01;
    mAngleTolerance2 = 0;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs
function buildArc(points, x3, y2, radius, start, end, clockwise, steps) {
  let dist = Math.abs(start - end);
  if (!clockwise && start > end) {
    dist = 2 * Math.PI - dist;
  } else if (clockwise && end > start) {
    dist = 2 * Math.PI - dist;
  }
  steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI)));
  steps = Math.max(steps, 3);
  let f3 = dist / steps;
  let t2 = start;
  f3 *= clockwise ? -1 : 1;
  for (let i3 = 0; i3 < steps + 1; i3++) {
    const cs = Math.cos(t2);
    const sn = Math.sin(t2);
    const nx = x3 + cs * radius;
    const ny = y2 + sn * radius;
    points.push(nx, ny);
    t2 += f3;
  }
}
var init_buildArc = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs
function buildArcTo(points, x1, y1, x22, y2, radius) {
  const fromX = points[points.length - 2];
  const fromY = points[points.length - 1];
  const a1 = fromY - y1;
  const b1 = fromX - x1;
  const a2 = y2 - y1;
  const b2 = x22 - x1;
  const mm = Math.abs(a1 * b2 - b1 * a2);
  if (mm < 1e-8 || radius === 0) {
    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
      points.push(x1, y1);
    }
    return;
  }
  const dd = a1 * a1 + b1 * b1;
  const cc = a2 * a2 + b2 * b2;
  const tt = a1 * a2 + b1 * b2;
  const k1 = radius * Math.sqrt(dd) / mm;
  const k22 = radius * Math.sqrt(cc) / mm;
  const j1 = k1 * tt / dd;
  const j22 = k22 * tt / cc;
  const cx = k1 * b2 + k22 * b1;
  const cy = k1 * a2 + k22 * a1;
  const px = b1 * (k22 + j1);
  const py = a1 * (k22 + j1);
  const qx = b2 * (k1 + j22);
  const qy = a2 * (k1 + j22);
  const startAngle = Math.atan2(py - cy, px - cx);
  const endAngle = Math.atan2(qy - cy, qx - cx);
  buildArc(
    points,
    cx + x1,
    cy + y1,
    radius,
    startAngle,
    endAngle,
    b1 * a2 > b2 * a1
  );
}
var init_buildArcTo = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs"() {
    init_buildArc();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs
function approxUnitArc(ang1, ang2) {
  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  const a2 = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;
  const x1 = Math.cos(ang1);
  const y1 = Math.sin(ang1);
  const x22 = Math.cos(ang1 + ang2);
  const y2 = Math.sin(ang1 + ang2);
  return [
    {
      x: x1 - y1 * a2,
      y: y1 + x1 * a2
    },
    {
      x: x22 + y2 * a2,
      y: y2 - x22 * a2
    },
    {
      x: x22,
      y: y2
    }
  ];
}
function buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {
  if (rx === 0 || ry === 0) {
    return;
  }
  const sinPhi = Math.sin(xAxisRotation * TAU / 360);
  const cosPhi = Math.cos(xAxisRotation * TAU / 360);
  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;
  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;
  if (pxp === 0 && pyp === 0) {
    return;
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  getArcCenter(
    px,
    py,
    cx,
    cy,
    rx,
    ry,
    largeArcFlag,
    sweepFlag,
    sinPhi,
    cosPhi,
    pxp,
    pyp,
    out
  );
  let { ang1, ang2 } = out;
  const { centerX, centerY } = out;
  let ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  const segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  let lastX = points[points.length - 2];
  let lastY = points[points.length - 1];
  const outCurvePoint = { x: 0, y: 0 };
  for (let i3 = 0; i3 < segments; i3++) {
    const curve = approxUnitArc(ang1, ang2);
    const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    const { x: x22, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    const { x: x3, y: y3 } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    buildAdaptiveBezier(
      points,
      lastX,
      lastY,
      x1,
      y1,
      x22,
      y2,
      x3,
      y3
    );
    lastX = x3;
    lastY = y3;
    ang1 += ang2;
  }
}
var TAU, out, mapToEllipse, vectorAngle, getArcCenter;
var init_buildArcToSvg = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs"() {
    init_buildAdaptiveBezier();
    TAU = Math.PI * 2;
    out = {
      centerX: 0,
      centerY: 0,
      ang1: 0,
      ang2: 0
    };
    mapToEllipse = ({ x: x3, y: y2 }, rx, ry, cosPhi, sinPhi, centerX, centerY, out22) => {
      x3 *= rx;
      y2 *= ry;
      const xp = cosPhi * x3 - sinPhi * y2;
      const yp = sinPhi * x3 + cosPhi * y2;
      out22.x = xp + centerX;
      out22.y = yp + centerY;
      return out22;
    };
    vectorAngle = (ux4, uy4, vx4, vy4) => {
      const sign2 = ux4 * vy4 - uy4 * vx4 < 0 ? -1 : 1;
      let dot = ux4 * vx4 + uy4 * vy4;
      if (dot > 1) {
        dot = 1;
      }
      if (dot < -1) {
        dot = -1;
      }
      return sign2 * Math.acos(dot);
    };
    getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out22) => {
      const rxSq = Math.pow(rx, 2);
      const rySq = Math.pow(ry, 2);
      const pxpSq = Math.pow(pxp, 2);
      const pypSq = Math.pow(pyp, 2);
      let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;
      if (radicant < 0) {
        radicant = 0;
      }
      radicant /= rxSq * pypSq + rySq * pxpSq;
      radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
      const centerXp = radicant * rx / ry * pyp;
      const centerYp = radicant * -ry / rx * pxp;
      const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;
      const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;
      const vx1 = (pxp - centerXp) / rx;
      const vy1 = (pyp - centerYp) / ry;
      const vx22 = (-pxp - centerXp) / rx;
      const vy22 = (-pyp - centerYp) / ry;
      const ang1 = vectorAngle(1, 0, vx1, vy1);
      let ang2 = vectorAngle(vx1, vy1, vx22, vy22);
      if (sweepFlag === 0 && ang2 > 0) {
        ang2 -= TAU;
      }
      if (sweepFlag === 1 && ang2 < 0) {
        ang2 += TAU;
      }
      out22.centerX = centerX;
      out22.centerY = centerY;
      out22.ang1 = ang1;
      out22.ang2 = ang2;
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs
var tempRectangle, ShapePath;
var init_ShapePath = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs"() {
    init_Circle();
    init_Ellipse();
    init_Polygon();
    init_Rectangle();
    init_RoundedRectangle();
    init_Bounds();
    init_buildAdaptiveBezier();
    init_buildAdaptiveQuadratic();
    init_buildArc();
    init_buildArcTo();
    init_buildArcToSvg();
    tempRectangle = new Rectangle();
    ShapePath = class {
      constructor(graphicsPath2D) {
        this.shapePrimitives = [];
        this._currentPoly = null;
        this._bounds = new Bounds();
        this._graphicsPath2D = graphicsPath2D;
      }
      moveTo(x3, y2) {
        this.startPoly(x3, y2);
        return this;
      }
      lineTo(x3, y2) {
        this._ensurePoly();
        const points = this._currentPoly.points;
        const fromX = points[points.length - 2];
        const fromY = points[points.length - 1];
        if (fromX !== x3 || fromY !== y2) {
          points.push(x3, y2);
        }
        return this;
      }
      arc(x3, y2, radius, startAngle, endAngle, anticlockwise) {
        this._ensurePoly(false);
        const points = this._currentPoly.points;
        buildArc(points, x3, y2, radius, startAngle, endAngle, anticlockwise);
        return this;
      }
      arcTo(x1, y1, x22, y2, radius) {
        this._ensurePoly();
        const points = this._currentPoly.points;
        buildArcTo(points, x1, y1, x22, y2, radius);
        return this;
      }
      arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x3, y2) {
        const points = this._currentPoly.points;
        buildArcToSvg(
          points,
          this._currentPoly.lastX,
          this._currentPoly.lastY,
          x3,
          y2,
          rx,
          ry,
          xAxisRotation,
          largeArcFlag,
          sweepFlag
        );
        return this;
      }
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x3, y2) {
        this._ensurePoly();
        const currentPoly = this._currentPoly;
        buildAdaptiveBezier(
          this._currentPoly.points,
          currentPoly.lastX,
          currentPoly.lastY,
          cp1x,
          cp1y,
          cp2x,
          cp2y,
          x3,
          y2
        );
        return this;
      }
      quadraticCurveTo(cp1x, cp1y, x3, y2) {
        this._ensurePoly();
        const currentPoly = this._currentPoly;
        buildAdaptiveQuadratic(
          this._currentPoly.points,
          currentPoly.lastX,
          currentPoly.lastY,
          cp1x,
          cp1y,
          x3,
          y2
        );
        return this;
      }
      closePath() {
        this.endPoly(true);
        return this;
      }
      addPath(path4, transform) {
        this.endPoly();
        if (transform && !transform.isIdentity()) {
          path4 = path4.clone(true);
          path4.transform(transform);
        }
        for (let i3 = 0; i3 < path4.instructions.length; i3++) {
          const instruction = path4.instructions[i3];
          this[instruction.action](...instruction.data);
        }
        return this;
      }
      finish(closePath = false) {
        this.endPoly(closePath);
      }
      rect(x3, y2, w2, h2, transform) {
        this.drawShape(new Rectangle(x3, y2, w2, h2), transform);
        return this;
      }
      circle(x3, y2, radius, transform) {
        this.drawShape(new Circle(x3, y2, radius), transform);
        return this;
      }
      poly(points, close, transform) {
        const polygon = new Polygon(points);
        polygon.closePath = close;
        this.drawShape(polygon, transform);
      }
      ellipse(x3, y2, radiusX, radiusY, transform) {
        this.drawShape(new Ellipse(x3, y2, radiusX, radiusY), transform);
        return this;
      }
      roundRect(x3, y2, w2, h2, radii, transform) {
        this.drawShape(new RoundedRectangle(x3, y2, w2, h2, radii), transform);
        return this;
      }
      drawShape(shape, matrix) {
        this.endPoly();
        this.shapePrimitives.push({ shape, transform: matrix });
        return this;
      }
      startPoly(x3, y2) {
        let currentPoly = this._currentPoly;
        if (currentPoly) {
          this.endPoly();
        }
        currentPoly = new Polygon();
        currentPoly.points.push(x3, y2);
        this._currentPoly = currentPoly;
        return this;
      }
      endPoly(closePath = false) {
        const shape = this._currentPoly;
        if (shape && shape.points.length > 2) {
          shape.closePath = closePath;
          this.shapePrimitives.push({ shape });
        }
        this._currentPoly = null;
        return this;
      }
      _ensurePoly(start = true) {
        if (this._currentPoly)
          return;
        this._currentPoly = new Polygon();
        if (start) {
          const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];
          if (lastShape) {
            let lx = lastShape.shape.x;
            let ly = lastShape.shape.y;
            if (lastShape.transform.isIdentity()) {
              const t2 = lastShape.transform;
              const tempX = lx;
              lx = t2.a * lx + t2.c * ly + t2.tx;
              ly = t2.b * tempX + t2.d * ly + t2.ty;
            }
            this._currentPoly.points.push(lx, lx);
          } else {
            this._currentPoly.points.push(0, 0);
          }
        }
      }
      buildPath() {
        const path4 = this._graphicsPath2D;
        this.shapePrimitives.length = 0;
        this._currentPoly = null;
        for (let i3 = 0; i3 < path4.instructions.length; i3++) {
          const instruction = path4.instructions[i3];
          this[instruction.action](...instruction.data);
        }
        this.finish();
      }
      get bounds() {
        const bounds = this._bounds;
        bounds.clear();
        const shapePrimitives = this.shapePrimitives;
        for (let i3 = 0; i3 < shapePrimitives.length; i3++) {
          const shapePrimitive = shapePrimitives[i3];
          const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);
          if (shapePrimitive.transform) {
            bounds.pushMatrix(shapePrimitive.transform);
            bounds.addRect(boundsRect);
            bounds.popMatrix();
          } else {
            bounds.addRect(boundsRect);
          }
        }
        return bounds;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs
function adjustTransform(currentMatrix, transform) {
  if (currentMatrix) {
    return currentMatrix.prepend(transform);
  }
  return transform.clone();
}
var GraphicsPath;
var init_GraphicsPath = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs"() {
    init_Point();
    init_uid();
    init_warn();
    init_SVGToGraphicsPath();
    init_ShapePath();
    GraphicsPath = class _GraphicsPath {
      constructor(instructions) {
        this.instructions = [];
        this.uid = uid("graphicsPath");
        this._dirty = true;
        if (typeof instructions === "string") {
          SVGToGraphicsPath(instructions, this);
        } else {
          this.instructions = instructions?.slice() ?? [];
        }
      }
      get shapePath() {
        if (!this._shapePath) {
          this._shapePath = new ShapePath(this);
        }
        if (this._dirty) {
          this._dirty = false;
          this._shapePath.buildPath();
        }
        return this._shapePath;
      }
      addPath(path4, transform) {
        path4 = path4.clone();
        this.instructions.push({ action: "addPath", data: [path4, transform] });
        this._dirty = true;
        return this;
      }
      arc(...args) {
        this.instructions.push({ action: "arc", data: args });
        this._dirty = true;
        return this;
      }
      arcTo(...args) {
        this.instructions.push({ action: "arcTo", data: args });
        this._dirty = true;
        return this;
      }
      arcToSvg(...args) {
        this.instructions.push({ action: "arcToSvg", data: args });
        this._dirty = true;
        return this;
      }
      bezierCurveTo(...args) {
        this.instructions.push({ action: "bezierCurveTo", data: args });
        this._dirty = true;
        return this;
      }
      bezierCurveToShort(cp2x, cp2y, x3, y2) {
        const last = this.instructions[this.instructions.length - 1];
        const lastPoint = this._getLastPoint(Point.shared);
        let cp1x = 0;
        let cp1y = 0;
        if (!last || last.action !== "bezierCurveTo") {
          cp1x = lastPoint.x;
          cp1y = lastPoint.y;
        } else {
          cp1x = last.data[2];
          cp1y = last.data[3];
          const currentX = lastPoint.x;
          const currentY = lastPoint.y;
          cp1x = currentX + (currentX - cp1x);
          cp1y = currentY + (currentY - cp1y);
        }
        this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x3, y2] });
        this._dirty = true;
        return this;
      }
      closePath() {
        this.instructions.push({ action: "closePath", data: [] });
        this._dirty = true;
        return this;
      }
      ellipse(...args) {
        this.instructions.push({ action: "ellipse", data: args });
        this._dirty = true;
        return this;
      }
      lineTo(...args) {
        this.instructions.push({ action: "lineTo", data: args });
        this._dirty = true;
        return this;
      }
      moveTo(...args) {
        this.instructions.push({ action: "moveTo", data: args });
        return this;
      }
      quadraticCurveTo(...args) {
        this.instructions.push({ action: "quadraticCurveTo", data: args });
        this._dirty = true;
        return this;
      }
      quadraticCurveToShort(x3, y2) {
        const last = this.instructions[this.instructions.length - 1];
        const lastPoint = this._getLastPoint(Point.shared);
        let cpx1 = 0;
        let cpy1 = 0;
        if (!last || last.action !== "quadraticCurveTo") {
          cpx1 = lastPoint.x;
          cpy1 = lastPoint.y;
        } else {
          cpx1 = last.data[0];
          cpy1 = last.data[1];
          const currentX = lastPoint.x;
          const currentY = lastPoint.y;
          cpx1 = currentX + (currentX - cpx1);
          cpy1 = currentY + (currentY - cpy1);
        }
        this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x3, y2] });
        this._dirty = true;
        return this;
      }
      rect(x3, y2, w2, h2, transform) {
        this.instructions.push({ action: "rect", data: [x3, y2, w2, h2, transform] });
        this._dirty = true;
        return this;
      }
      circle(x3, y2, radius, transform) {
        this.instructions.push({ action: "circle", data: [x3, y2, radius, transform] });
        this._dirty = true;
        return this;
      }
      roundRect(...args) {
        this.instructions.push({ action: "roundRect", data: args });
        this._dirty = true;
        return this;
      }
      poly(...args) {
        this.instructions.push({ action: "poly", data: args });
        this._dirty = true;
        return this;
      }
      // eslint-disable-next-line max-len
      star(x3, y2, points, radius, innerRadius, rotation = 0, transform) {
        innerRadius = innerRadius || radius / 2;
        const startAngle = -1 * Math.PI / 2 + rotation;
        const len = points * 2;
        const delta = Math.PI * 2 / len;
        const polygon = [];
        for (let i3 = 0; i3 < len; i3++) {
          const r2 = i3 % 2 ? innerRadius : radius;
          const angle = i3 * delta + startAngle;
          polygon.push(
            x3 + r2 * Math.cos(angle),
            y2 + r2 * Math.sin(angle)
          );
        }
        this.poly(polygon, true, transform);
        return this;
      }
      clone(deep = false) {
        const newGraphicsPath2D = new _GraphicsPath();
        if (!deep) {
          newGraphicsPath2D.instructions = this.instructions.slice();
        } else {
          for (let i3 = 0; i3 < this.instructions.length; i3++) {
            const instruction = this.instructions[i3];
            newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });
          }
        }
        return newGraphicsPath2D;
      }
      clear() {
        this.instructions.length = 0;
        this._dirty = true;
        return this;
      }
      transform(matrix) {
        if (matrix.isIdentity())
          return this;
        const a2 = matrix.a;
        const b2 = matrix.b;
        const c2 = matrix.c;
        const d3 = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        let x3 = 0;
        let y2 = 0;
        let cpx1 = 0;
        let cpy1 = 0;
        let cpx2 = 0;
        let cpy2 = 0;
        let rx = 0;
        let ry = 0;
        for (let i3 = 0; i3 < this.instructions.length; i3++) {
          const instruction = this.instructions[i3];
          const data = instruction.data;
          switch (instruction.action) {
            case "moveTo":
            case "lineTo":
              x3 = data[0];
              y2 = data[1];
              data[0] = a2 * x3 + c2 * y2 + tx;
              data[1] = b2 * x3 + d3 * y2 + ty;
              break;
            case "bezierCurveTo":
              cpx1 = data[0];
              cpy1 = data[1];
              cpx2 = data[2];
              cpy2 = data[3];
              x3 = data[4];
              y2 = data[5];
              data[0] = a2 * cpx1 + c2 * cpy1 + tx;
              data[1] = b2 * cpx1 + d3 * cpy1 + ty;
              data[2] = a2 * cpx2 + c2 * cpy2 + tx;
              data[3] = b2 * cpx2 + d3 * cpy2 + ty;
              data[4] = a2 * x3 + c2 * y2 + tx;
              data[5] = b2 * x3 + d3 * y2 + ty;
              break;
            case "quadraticCurveTo":
              cpx1 = data[0];
              cpy1 = data[1];
              x3 = data[2];
              y2 = data[3];
              data[0] = a2 * cpx1 + c2 * cpy1 + tx;
              data[1] = b2 * cpx1 + d3 * cpy1 + ty;
              data[2] = a2 * x3 + c2 * y2 + tx;
              data[3] = b2 * x3 + d3 * y2 + ty;
              break;
            case "arcToSvg":
              x3 = data[5];
              y2 = data[6];
              rx = data[0];
              ry = data[1];
              data[0] = a2 * rx + c2 * ry;
              data[1] = b2 * rx + d3 * ry;
              data[5] = a2 * x3 + c2 * y2 + tx;
              data[6] = b2 * x3 + d3 * y2 + ty;
              break;
            case "rect":
              data[4] = adjustTransform(data[4], matrix);
              break;
            case "ellipse":
              data[8] = adjustTransform(data[8], matrix);
              break;
            case "roundRect":
              data[5] = adjustTransform(data[5], matrix);
              break;
            case "addPath":
              data[0].transform(matrix);
              break;
            default:
              warn("unknown transform action", instruction.action);
              break;
          }
        }
        this._dirty = true;
        return this;
      }
      get bounds() {
        return this.shapePath.bounds;
      }
      _getLastPoint(out3) {
        let index = this.instructions.length - 1;
        let lastInstruction = this.instructions[index];
        if (!lastInstruction) {
          out3.x = 0;
          out3.y = 0;
          return out3;
        }
        while (lastInstruction.action === "closePath") {
          index--;
          if (index < 0) {
            out3.x = 0;
            out3.y = 0;
            return out3;
          }
          lastInstruction = this.instructions[index];
        }
        let x3;
        let y2;
        let transform;
        switch (lastInstruction.action) {
          case "moveTo":
          case "lineTo":
            out3.x = lastInstruction.data[0];
            out3.y = lastInstruction.data[1];
            break;
          case "quadraticCurveTo":
            out3.x = lastInstruction.data[2];
            out3.y = lastInstruction.data[3];
            break;
          case "bezierCurveTo":
            out3.x = lastInstruction.data[4];
            out3.y = lastInstruction.data[5];
            break;
          case "arc":
          case "arcToSvg":
            out3.x = lastInstruction.data[5];
            out3.y = lastInstruction.data[6];
            break;
          case "addPath":
            out3.x = lastInstruction.data[0].lastX;
            out3.y = lastInstruction.data[2].lastY;
            break;
          case "rect":
            transform = lastInstruction.data[4];
            x3 = lastInstruction.data[0];
            y2 = lastInstruction.data[1];
            if (transform) {
              const { a: a2, b: b2, c: c2, d: d3, tx, ty } = transform;
              out3.x = a2 * x3 + c2 * y2 + tx;
              out3.y = b2 * x3 + d3 * y2 + ty;
            } else {
              out3.x = x3;
              out3.y = y2;
            }
            break;
          default:
            warn(`${lastInstruction.action} is not supported yet`);
            break;
        }
        return out3;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs
function SVGParser(svg, graphicsContext) {
  if (typeof svg === "string") {
    const div = document.createElement("div");
    div.innerHTML = svg.trim();
    svg = div.querySelector("svg");
  }
  const session = {
    context: graphicsContext,
    path: new GraphicsPath()
  };
  renderChildren(svg, session, null, null);
  return graphicsContext;
}
function renderChildren(svg, session, fillStyle, strokeStyle) {
  const children = svg.children;
  const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);
  if (f1 && fillStyle) {
    fillStyle = { ...fillStyle, ...f1 };
  } else if (f1) {
    fillStyle = f1;
  }
  if (s1 && strokeStyle) {
    strokeStyle = { ...strokeStyle, ...s1 };
  } else if (s1) {
    strokeStyle = s1;
  }
  session.context.fillStyle = fillStyle;
  session.context.strokeStyle = strokeStyle;
  let x3;
  let y2;
  let x1;
  let y1;
  let x22;
  let y22;
  let cx;
  let cy;
  let r2;
  let rx;
  let ry;
  let points;
  let pointsString;
  let d3;
  let graphicsPath;
  let width;
  let height;
  switch (svg.nodeName.toLowerCase()) {
    case "path":
      d3 = svg.getAttribute("d");
      graphicsPath = new GraphicsPath(d3);
      session.context.path(graphicsPath);
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "circle":
      cx = parseFloatAttribute(svg, "cx", 0);
      cy = parseFloatAttribute(svg, "cy", 0);
      r2 = parseFloatAttribute(svg, "r", 0);
      session.context.ellipse(cx, cy, r2, r2);
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "rect":
      x3 = parseFloatAttribute(svg, "x", 0);
      y2 = parseFloatAttribute(svg, "y", 0);
      width = parseFloatAttribute(svg, "width", 0);
      height = parseFloatAttribute(svg, "height", 0);
      rx = parseFloatAttribute(svg, "rx", 0);
      ry = parseFloatAttribute(svg, "ry", 0);
      if (rx || ry) {
        session.context.roundRect(x3, y2, width, height, rx || ry);
      } else {
        session.context.rect(x3, y2, width, height);
      }
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "ellipse":
      cx = parseFloatAttribute(svg, "cx", 0);
      cy = parseFloatAttribute(svg, "cy", 0);
      rx = parseFloatAttribute(svg, "rx", 0);
      ry = parseFloatAttribute(svg, "ry", 0);
      session.context.beginPath();
      session.context.ellipse(cx, cy, rx, ry);
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "line":
      x1 = parseFloatAttribute(svg, "x1", 0);
      y1 = parseFloatAttribute(svg, "y1", 0);
      x22 = parseFloatAttribute(svg, "x2", 0);
      y22 = parseFloatAttribute(svg, "y2", 0);
      session.context.beginPath();
      session.context.moveTo(x1, y1);
      session.context.lineTo(x22, y22);
      if (strokeStyle)
        session.context.stroke();
      break;
    case "polygon":
      pointsString = svg.getAttribute("points");
      points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
      session.context.poly(points, true);
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "polyline":
      pointsString = svg.getAttribute("points");
      points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
      session.context.poly(points, false);
      if (strokeStyle)
        session.context.stroke();
      break;
    case "g":
    case "svg":
      break;
    default: {
      console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);
      break;
    }
  }
  for (let i3 = 0; i3 < children.length; i3++) {
    renderChildren(children[i3], session, fillStyle, strokeStyle);
  }
}
function parseFloatAttribute(svg, id, defaultValue3) {
  const value = svg.getAttribute(id);
  return value ? Number(value) : defaultValue3;
}
function parseStyle(svg) {
  const style = svg.getAttribute("style");
  const strokeStyle = {};
  const fillStyle = {};
  let useFill = false;
  let useStroke = false;
  if (style) {
    const styleParts = style.split(";");
    for (let i3 = 0; i3 < styleParts.length; i3++) {
      const stylePart = styleParts[i3];
      const [key2, value] = stylePart.split(":");
      switch (key2) {
        case "stroke":
          if (value !== "none") {
            strokeStyle.color = Color.shared.setValue(value).toNumber();
            useStroke = true;
          }
          break;
        case "stroke-width":
          strokeStyle.width = Number(value);
          break;
        case "fill":
          if (value !== "none") {
            useFill = true;
            fillStyle.color = Color.shared.setValue(value).toNumber();
          }
          break;
        case "fill-opacity":
          fillStyle.alpha = Number(value);
          break;
        case "stroke-opacity":
          strokeStyle.alpha = Number(value);
          break;
        case "opacity":
          fillStyle.alpha = Number(value);
          strokeStyle.alpha = Number(value);
          break;
      }
    }
  } else {
    const stroke = svg.getAttribute("stroke");
    if (stroke && stroke !== "none") {
      useStroke = true;
      strokeStyle.color = Color.shared.setValue(stroke).toNumber();
      strokeStyle.width = parseFloatAttribute(svg, "stroke-width", 1);
    }
    const fill = svg.getAttribute("fill");
    if (fill && fill !== "none") {
      useFill = true;
      fillStyle.color = Color.shared.setValue(fill).toNumber();
    }
  }
  return {
    strokeStyle: useStroke ? strokeStyle : null,
    fillStyle: useFill ? fillStyle : null
  };
}
var init_SVGParser = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs"() {
    init_Color();
    init_GraphicsPath();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs
var ImageSource, canvas, size, ctx;
var init_ImageSource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs"() {
    init_settings();
    init_NOOP();
    init_Texture();
    init_TextureSource();
    ImageSource = class extends TextureSource {
      constructor() {
        super(...arguments);
        this.uploadMethodId = "image";
      }
    };
    canvas = settings.ADAPTER.createCanvas();
    size = 1;
    canvas.width = size;
    canvas.height = size;
    ctx = canvas.getContext("2d");
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, size, size);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(size, 0);
    ctx.lineTo(size, size);
    ctx.closePath();
    ctx.fillStyle = "#ffffff";
    ctx.fill();
    Texture.WHITE = new Texture({
      source: new ImageSource({
        resource: canvas
      })
    });
    Texture.WHITE.label = "WHITE";
    Texture.WHITE.destroy = NOOP;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs
var _FillGradient, FillGradient;
var init_FillGradient = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs"() {
    init_Color();
    init_Matrix();
    init_ImageSource();
    init_Texture();
    init_settings();
    init_uid();
    _FillGradient = class {
      constructor(x0, y0, x1, y1) {
        this.uid = uid("fillGradient");
        this.type = "linear";
        this.gradientStops = [];
        this.x0 = x0;
        this.y0 = y0;
        this.x1 = x1;
        this.y1 = y1;
      }
      addColorStop(offset, color) {
        this.gradientStops.push({ offset, color: Color.shared.setValue(color).toHex() });
        return this;
      }
      // TODO move to the system!
      buildLinearGradient() {
        const defaultSize = _FillGradient.defaultTextureSize;
        const { gradientStops } = this;
        const canvas3 = settings.ADAPTER.createCanvas();
        canvas3.width = defaultSize;
        canvas3.height = defaultSize;
        const ctx3 = canvas3.getContext("2d");
        const gradient = ctx3.createLinearGradient(0, 0, _FillGradient.defaultTextureSize, 1);
        for (let i3 = 0; i3 < gradientStops.length; i3++) {
          const stop = gradientStops[i3];
          gradient.addColorStop(stop.offset, stop.color);
        }
        ctx3.fillStyle = gradient;
        ctx3.fillRect(0, 0, defaultSize, defaultSize);
        this.texture = new Texture({
          source: new ImageSource({
            resource: canvas3,
            style: {
              addressModeU: "clamp-to-edge",
              addressModeV: "repeat"
            }
          })
        });
        const { x0, y0, x1, y1 } = this;
        const m3 = new Matrix();
        const dx = x1 - x0;
        const dy = y1 - y0;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        m3.translate(-x0, -y0);
        m3.scale(1 / defaultSize, 1 / defaultSize);
        m3.rotate(-angle);
        m3.scale(256 / dist, 1);
        this.transform = m3;
      }
    };
    FillGradient = _FillGradient;
    FillGradient.defaultTextureSize = 256;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs
var repetitionMap, FillPattern;
var init_FillPattern = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs"() {
    init_Matrix();
    init_uid();
    repetitionMap = {
      repeat: {
        addressModeU: "repeat",
        addressModeV: "repeat"
      },
      "repeat-x": {
        addressModeU: "repeat",
        addressModeV: "clamp-to-edge"
      },
      "repeat-y": {
        addressModeU: "clamp-to-edge",
        addressModeV: "repeat"
      },
      "no-repeat": {
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      }
    };
    FillPattern = class {
      constructor(texture, repetition) {
        this.uid = uid("fillPattern");
        this.transform = new Matrix();
        this.texture = texture;
        this.transform.scale(
          1 / texture.frameWidth,
          1 / texture.frameHeight
        );
        if (repetition) {
          texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;
          texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;
        }
      }
      setTransform(transform) {
        const texture = this.texture;
        this.transform.copyFrom(transform);
        this.transform.invert();
        this.transform.scale(
          1 / texture.frameWidth,
          1 / texture.frameHeight
        );
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs
function convertFillInputToFillStyle(value, defaultStyle) {
  if (!value) {
    return null;
  }
  let fillStyleToParse;
  let styleToMerge;
  if (value?.fill) {
    styleToMerge = value.fill;
    fillStyleToParse = { ...defaultStyle, ...value };
  } else {
    styleToMerge = value;
    fillStyleToParse = defaultStyle;
  }
  if (Color.isColorLike(styleToMerge)) {
    const temp = Color.shared.setValue(styleToMerge ?? 0);
    const opts = {
      ...fillStyleToParse,
      color: temp.toNumber(),
      alpha: fillStyleToParse.alpha ?? temp.alpha,
      texture: Texture.WHITE
    };
    return opts;
  } else if (styleToMerge instanceof FillPattern) {
    const pattern = styleToMerge;
    return {
      ...fillStyleToParse,
      color: 16777215,
      texture: pattern.texture,
      matrix: pattern.transform,
      fill: fillStyleToParse.fill ?? null
    };
  } else if (styleToMerge instanceof FillGradient) {
    const gradient = styleToMerge;
    gradient.buildLinearGradient();
    return {
      ...fillStyleToParse,
      color: 16777215,
      texture: gradient.texture,
      matrix: gradient.transform
    };
  }
  const style = { ...defaultStyle, ...value };
  if (style.texture !== Texture.WHITE) {
    const m3 = style.matrix || new Matrix();
    m3.scale(1 / style.texture.frameWidth, 1 / style.texture.frameHeight);
    style.matrix = m3;
    style.color = 16777215;
  }
  style.color = Color.shared.setValue(style.color).toNumber();
  return style;
}
var init_convertFillInputToFillStyle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs"() {
    init_Color();
    init_Matrix();
    init_Texture();
    init_FillGradient();
    init_FillPattern();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs
var tmpPoint, tempMatrix3, _GraphicsContext, GraphicsContext;
var init_GraphicsContext = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs"() {
    init_eventemitter3();
    init_Color();
    init_Matrix();
    init_Point();
    init_Texture();
    init_uid();
    init_deprecation();
    init_Bounds();
    init_GraphicsPath();
    init_SVGParser();
    init_convertFillInputToFillStyle();
    tmpPoint = new Point();
    tempMatrix3 = new Matrix();
    _GraphicsContext = class extends eventemitter3_default {
      constructor() {
        super(...arguments);
        this.uid = uid("graphicsContext");
        this.dirty = true;
        this.batchMode = "auto";
        this.instructions = [];
        this._activePath = new GraphicsPath();
        this._transform = new Matrix();
        this._fillStyle = { ..._GraphicsContext.defaultFillStyle };
        this._strokeStyle = { ..._GraphicsContext.defaultStrokeStyle };
        this._stateStack = [];
        this._tick = 0;
        this._bounds = new Bounds();
        this._boundsDirty = true;
      }
      get fillStyle() {
        return this._fillStyle;
      }
      set fillStyle(value) {
        this._fillStyle = convertFillInputToFillStyle(value, _GraphicsContext.defaultFillStyle);
      }
      get strokeStyle() {
        return this._strokeStyle;
      }
      set strokeStyle(value) {
        this._strokeStyle = convertFillInputToFillStyle(value, _GraphicsContext.defaultStrokeStyle);
      }
      texture(texture, tint, dx, dy, dw, dh) {
        this.instructions.push({
          action: "texture",
          data: {
            image: texture,
            dx: dx || 0,
            dy: dy || 0,
            dw: dw || texture.frameWidth,
            dh: dh || texture.frameHeight,
            transform: this._transform.clone(),
            alpha: this._fillStyle.alpha,
            style: tint ? Color.shared.setValue(tint).toNumber() : 0
          }
        });
        this.onUpdate();
        return this;
      }
      beginPath() {
        this._activePath = new GraphicsPath();
        return this;
      }
      fill(style, alpha) {
        let path4;
        const lastInstruction = this.instructions[this.instructions.length - 1];
        if (this._tick === 0 && lastInstruction && lastInstruction.action === "stroke") {
          path4 = lastInstruction.data.path;
        } else {
          path4 = this._activePath.clone();
        }
        if (!path4)
          return this;
        if (style) {
          if (alpha !== void 0 && typeof style === "number") {
            deprecation("8.0.0", "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");
            style = { color: style, alpha };
          }
          this.fillStyle = convertFillInputToFillStyle(style, _GraphicsContext.defaultFillStyle);
        }
        this.instructions.push({
          action: "fill",
          // TODO copy fill style!
          data: { style: this.fillStyle, path: path4 }
        });
        this.onUpdate();
        this._activePath.instructions.length = 0;
        this._tick = 0;
        return this;
      }
      stroke(style) {
        let path4;
        const lastInstruction = this.instructions[this.instructions.length - 1];
        if (this._tick === 0 && lastInstruction && lastInstruction.action === "fill") {
          path4 = lastInstruction.data.path;
        } else {
          path4 = this._activePath.clone();
        }
        if (!path4)
          return this;
        if (style) {
          this.strokeStyle = convertFillInputToFillStyle(style, _GraphicsContext.defaultStrokeStyle);
        }
        this.instructions.push({
          action: "stroke",
          // TODO copy fill style!
          data: { style: this.strokeStyle, path: path4 }
        });
        this.onUpdate();
        this._activePath.instructions.length = 0;
        this._tick = 0;
        return this;
      }
      cut() {
        for (let i3 = 0; i3 < 2; i3++) {
          const lastInstruction = this.instructions[this.instructions.length - 1 - i3];
          const holePath = this._activePath.clone();
          if (lastInstruction) {
            if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {
              lastInstruction.data.hole = holePath;
            }
          }
        }
        this._activePath.instructions.length = 0;
        return this;
      }
      arc(x3, y2, radius, startAngle, endAngle, counterclockwise) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.arc(
          t2.a * x3 + t2.c * y2 + t2.tx,
          t2.b * x3 + t2.d * y2 + t2.ty,
          radius,
          startAngle,
          endAngle,
          counterclockwise
        );
        return this;
      }
      arcTo(x1, y1, x22, y2, radius) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.arcTo(
          t2.a * x1 + t2.c * y1 + t2.tx,
          t2.b * x1 + t2.d * y1 + t2.ty,
          t2.a * x22 + t2.c * y2 + t2.tx,
          t2.b * x22 + t2.d * y2 + t2.ty,
          radius
        );
        return this;
      }
      arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x3, y2) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.arcToSvg(
          rx,
          ry,
          xAxisRotation,
          // should we rotate this with transform??
          largeArcFlag,
          sweepFlag,
          t2.a * x3 + t2.c * y2 + t2.tx,
          t2.b * x3 + t2.d * y2 + t2.ty
        );
        return this;
      }
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x3, y2) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.bezierCurveTo(
          t2.a * cp1x + t2.c * cp1y + t2.tx,
          t2.b * cp1x + t2.d * cp1y + t2.ty,
          t2.a * cp2x + t2.c * cp2y + t2.tx,
          t2.b * cp2x + t2.d * cp2y + t2.ty,
          t2.a * x3 + t2.c * y2 + t2.tx,
          t2.b * x3 + t2.d * y2 + t2.ty
        );
        return this;
      }
      closePath() {
        this._tick++;
        this._activePath?.closePath();
        return this;
      }
      ellipse(x3, y2, radiusX, radiusY) {
        this._tick++;
        this._activePath.ellipse(x3, y2, radiusX, radiusY, this._transform.clone());
        return this;
      }
      circle(x3, y2, radius) {
        this._tick++;
        this._activePath.circle(x3, y2, radius, this._transform.clone());
        return this;
      }
      path(path4) {
        this._tick++;
        this._activePath.addPath(path4, this._transform.clone());
        return this;
      }
      lineTo(x3, y2) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.lineTo(
          t2.a * x3 + t2.c * y2 + t2.tx,
          t2.b * x3 + t2.d * y2 + t2.ty
        );
        return this;
      }
      moveTo(x3, y2) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.moveTo(
          t2.a * x3 + t2.c * y2 + t2.tx,
          t2.b * x3 + t2.d * y2 + t2.ty
        );
        return this;
      }
      quadraticCurveTo(cpx, cpy, x3, y2) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.quadraticCurveTo(
          t2.a * cpx + t2.c * cpy + t2.tx,
          t2.b * cpx + t2.d * cpy + t2.ty,
          t2.a * x3 + t2.c * y2 + t2.tx,
          t2.b * x3 + t2.d * y2 + t2.ty
        );
      }
      rect(x3, y2, w2, h2) {
        this._tick++;
        this._activePath.rect(x3, y2, w2, h2, this._transform.clone());
        return this;
      }
      roundRect(x3, y2, w2, h2, radii) {
        this._tick++;
        this._activePath.roundRect(x3, y2, w2, h2, radii, this._transform.clone());
        return this;
      }
      poly(points, close) {
        this._tick++;
        this._activePath.poly(points, close, this._transform.clone());
        return this;
      }
      star(x3, y2, points, radius, innerRadius, rotation) {
        this._tick++;
        this._activePath.star(x3, y2, points, radius, innerRadius, rotation, this._transform.clone());
        return this;
      }
      svg(svg) {
        this._tick++;
        SVGParser(svg, this);
      }
      restore() {
        const state = this._stateStack.pop();
        if (state) {
          this._transform = state.transform;
          this._fillStyle = state.fillStyle;
          this._strokeStyle = state.strokeStyle;
        }
      }
      save() {
        this._stateStack.push({
          transform: this._transform.clone(),
          fillStyle: { ...this._fillStyle },
          strokeStyle: { ...this._strokeStyle }
        });
      }
      getTransform() {
        return this._transform;
      }
      resetTransform() {
        this._transform.identity();
        return this;
      }
      rotate(angle) {
        this._transform.rotate(angle);
        return this;
      }
      scale(x3, y2 = x3) {
        this._transform.scale(x3, y2);
        return this;
      }
      setTransform(a2, b2, c2, d3, dx, dy) {
        if (a2 instanceof Matrix) {
          this._transform.set(a2.a, a2.b, a2.c, a2.d, a2.tx, a2.ty);
          return this;
        }
        this._transform.set(a2, b2, c2, d3, dx, dy);
        return this;
      }
      transform(a2, b2, c2, d3, dx, dy) {
        if (a2 instanceof Matrix) {
          this._transform.append(a2);
          return this;
        }
        tempMatrix3.set(a2, b2, c2, d3, dx, dy);
        this._transform.append(tempMatrix3);
        return this;
      }
      translate(x3, y2) {
        this._transform.translate(x3, y2);
        return this;
      }
      clear() {
        this.instructions.length = 0;
        this.resetTransform();
        this.onUpdate();
        return this;
      }
      onUpdate() {
        if (this.dirty)
          return;
        this.emit("update", this, 16);
        this.dirty = true;
        this._boundsDirty = true;
      }
      get bounds() {
        if (!this._boundsDirty)
          return this._bounds;
        const bounds = this._bounds;
        bounds.clear();
        for (let i3 = 0; i3 < this.instructions.length; i3++) {
          const instruction = this.instructions[i3];
          const action = instruction.action;
          if (action === "fill") {
            const data = instruction.data;
            bounds.addBounds(data.path.bounds);
          } else if (action === "texture") {
            const data = instruction.data;
            bounds.pushMatrix(data.transform);
            bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh);
            bounds.popMatrix();
          }
        }
        return bounds;
      }
      /**
       * Check to see if a point is contained within this geometry.
       * @param point - Point to check if it's contained.
       * @returns {boolean} `true` if the point is contained within geometry.
       */
      containsPoint(point) {
        const instructions = this.instructions;
        let hasHit = false;
        instructions.forEach((instruction) => {
          const data = instruction.data;
          const path4 = data.path;
          if (!instruction.action || !path4)
            return;
          const style = data.style;
          const shapes = path4.shapePath?.shapePrimitives;
          this._forEachShape(shapes, (shape) => {
            if (!style || !shape)
              return;
            if (typeof style !== "number" && style.matrix) {
              style.matrix.applyInverse(point, tmpPoint);
            } else {
              tmpPoint.copyFrom(point);
            }
            hasHit = shape.contains(tmpPoint.x, tmpPoint.y);
            const holes = data.hole;
            if (!holes)
              return;
            const holeShapes = holes.shapePath?.shapePrimitives;
            if (!holeShapes)
              return;
            this._forEachShape(holeShapes, (hole) => {
              if (hole.contains(tmpPoint.x, tmpPoint.y)) {
                hasHit = false;
              }
            });
          });
        });
        return hasHit;
      }
      _forEachShape(shapes, callback) {
        shapes?.forEach((shapePrimitive) => {
          const shape = shapePrimitive?.shape;
          if (shape) {
            callback(shape);
          }
        });
      }
      /**
       * Destroys the GraphicsData object.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?
       * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?
       */
      destroy(options = false) {
        this._stateStack.length = 0;
        this._transform = null;
        this.emit("destroy", this);
        this.removeAllListeners();
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          if (this._fillStyle.texture) {
            this._fillStyle.texture.destroy(destroyTextureSource);
          }
          if (this._strokeStyle.texture) {
            this._strokeStyle.texture.destroy(destroyTextureSource);
          }
        }
        this._fillStyle = null;
        this._strokeStyle = null;
        this.instructions = null;
        this._activePath = null;
        this._bounds = null;
        this._stateStack = null;
        this.customShader = null;
        this._transform = null;
      }
    };
    GraphicsContext = _GraphicsContext;
    GraphicsContext.defaultFillStyle = {
      color: 0,
      alpha: 1,
      texture: Texture.WHITE,
      matrix: null,
      fill: null
    };
    GraphicsContext.defaultStrokeStyle = {
      width: 1,
      color: 0,
      alpha: 1,
      alignment: 0.5,
      miterLimit: 10,
      cap: "butt",
      join: "miter",
      texture: Texture.WHITE,
      matrix: null,
      fill: null
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs
var SVG_XML, validSVGExtension, validSVGMIME, loadSvg;
var init_loadSVG = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs"() {
    init_Extensions();
    init_GraphicsContext();
    init_settings();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
    validSVGExtension = ".svg";
    validSVGMIME = "image/svg+xml";
    loadSvg = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Low
      },
      name: "loadSVG",
      test(url2) {
        return checkDataUrl(url2, validSVGMIME) || checkExtension(url2, validSVGExtension);
      },
      async testParse(data) {
        return typeof data === "string" && data.startsWith("data:image/svg+xml") || typeof data === "string" && SVG_XML.test(data);
      },
      async parse(asset) {
        const context4 = new GraphicsContext();
        context4.svg(asset);
        return context4;
      },
      async load(url2) {
        const response = await settings.ADAPTER.fetch(url2);
        return response.text();
      },
      unload(asset) {
        asset.destroy(true);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs
function getResolutionOfUrl(url2, defaultValue3 = 1) {
  const resolution = settings.RETINA_PREFIX?.exec(url2);
  if (resolution) {
    return parseFloat(resolution[1]);
  }
  return defaultValue3;
}
var init_getResolutionOfUrl = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs"() {
    init_settings();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/loader/parsers/WorkerManager.mjs
var UUID, MAX_WORKERS, WHITE_PNG, checkImageBitmapCode, workerCode, workerURL, WorkerManagerClass, WorkerManager;
var init_WorkerManager = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/loader/parsers/WorkerManager.mjs"() {
    UUID = 0;
    WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    checkImageBitmapCode = {
      id: "checkImageBitmap",
      code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${WHITE_PNG}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
    };
    workerCode = {
      id: "loadImageBitmap",
      code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
    };
    WorkerManagerClass = class {
      constructor() {
        this._initialized = false;
        this._createdWorkers = 0;
        this._workerPool = [];
        this._queue = [];
        this._resolveHash = {};
      }
      isImageBitmapSupported() {
        if (this._isImageBitmapSupported !== void 0)
          return this._isImageBitmapSupported;
        this._isImageBitmapSupported = new Promise((resolve2) => {
          const workerURL22 = URL.createObjectURL(new Blob(
            [checkImageBitmapCode.code],
            { type: "application/javascript" }
          ));
          const worker = new Worker(workerURL22);
          worker.addEventListener("message", (event) => {
            worker.terminate();
            URL.revokeObjectURL(workerURL22);
            resolve2(event.data);
          });
        });
        return this._isImageBitmapSupported;
      }
      loadImageBitmap(src) {
        return this._run("loadImageBitmap", [src]);
      }
      async _initWorkers() {
        if (this._initialized)
          return;
        this._initialized = true;
      }
      _getWorker() {
        if (MAX_WORKERS === void 0) {
          MAX_WORKERS = navigator.hardwareConcurrency || 4;
        }
        let worker = this._workerPool.pop();
        if (!worker && this._createdWorkers < MAX_WORKERS) {
          if (!workerURL) {
            workerURL = URL.createObjectURL(new Blob([workerCode.code], { type: "application/javascript" }));
          }
          this._createdWorkers++;
          worker = new Worker(workerURL);
          worker.addEventListener("message", (event) => {
            this._complete(event.data);
            this._returnWorker(event.target);
            this._next();
          });
        }
        return worker;
      }
      _returnWorker(worker) {
        this._workerPool.push(worker);
      }
      _complete(data) {
        if (data.error !== void 0) {
          this._resolveHash[data.uuid].reject(data.error);
        } else {
          this._resolveHash[data.uuid].resolve(data.data);
        }
        this._resolveHash[data.uuid] = null;
      }
      async _run(id, args) {
        await this._initWorkers();
        const promise4 = new Promise((resolve2, reject) => {
          this._queue.push({ id, arguments: args, resolve: resolve2, reject });
        });
        this._next();
        return promise4;
      }
      _next() {
        if (!this._queue.length)
          return;
        const worker = this._getWorker();
        if (!worker) {
          return;
        }
        const toDo = this._queue.pop();
        const id = toDo.id;
        this._resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };
        worker.postMessage({
          data: toDo.arguments,
          uuid: UUID++,
          id
        });
      }
    };
    WorkerManager = new WorkerManagerClass();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs
function createTexture(source3, loader, url2) {
  const texture = new Texture({
    source: source3,
    label: url2
  });
  const unload = () => {
    delete loader.promiseCache[url2];
    if (Cache.has(url2)) {
      Cache.remove(url2);
    }
  };
  texture.once("destroy", () => {
    if (url2 in loader.promiseCache) {
      warn("[Assets] A BaseTexture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the BaseTexture.");
      unload();
    }
  });
  texture.source.once("destroy", () => {
    if (!source3.destroyed) {
      warn("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.");
      unload();
    }
  });
  return texture;
}
var init_createTexture = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs"() {
    init_Texture();
    init_warn();
    init_Cache();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs
async function loadImageBitmap(url2) {
  const response = await settings.ADAPTER.fetch(url2);
  if (!response.ok) {
    throw new Error(`[loadImageBitmap] Failed to fetch ${url2}: ${response.status} ${response.statusText}`);
  }
  const imageBlob = await response.blob();
  const imageBitmap = await createImageBitmap(imageBlob);
  return imageBitmap;
}
var validImageExtensions, validImageMIMEs, loadTextures;
var init_loadTextures = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs"() {
    init_Extensions();
    init_ImageSource();
    init_settings();
    init_getResolutionOfUrl();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    init_WorkerManager();
    init_createTexture();
    validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
    validImageMIMEs = [
      "image/jpeg",
      "image/png",
      "image/webp",
      "image/avif"
    ];
    loadTextures = {
      name: "loadTextures",
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.High
      },
      config: {
        preferWorkers: true,
        preferCreateImageBitmap: true,
        crossOrigin: "anonymous"
      },
      test(url2) {
        return checkDataUrl(url2, validImageMIMEs) || checkExtension(url2, validImageExtensions);
      },
      async load(url2, asset, loader) {
        let src = null;
        if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {
          if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {
            src = await WorkerManager.loadImageBitmap(url2);
          } else {
            src = await loadImageBitmap(url2);
          }
        } else {
          src = await new Promise((resolve2) => {
            src = new Image();
            src.crossOrigin = this.config.crossOrigin;
            src.src = url2;
            if (src.complete) {
              resolve2(src);
            } else {
              src.onload = () => {
                resolve2(src);
              };
            }
          });
        }
        const base = new ImageSource({
          resource: src,
          alphaMode: "premultiply-alpha-on-upload",
          resolution: asset.data?.resolution || getResolutionOfUrl(url2),
          ...asset.data
        });
        return createTexture(base, loader, url2);
      },
      unload(texture) {
        texture.destroy(true);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs
async function detectVideoAlphaMode() {
  promise ?? (promise = (async () => {
    const canvas3 = document.createElement("canvas");
    const gl = canvas3.getContext("webgl");
    if (!gl) {
      return "premultiply-alpha-on-upload";
    }
    const video = await new Promise((resolve2) => {
      const video2 = document.createElement("video");
      video2.onloadeddata = () => resolve2(video2);
      video2.onerror = () => resolve2(null);
      video2.autoplay = false;
      video2.crossOrigin = "anonymous";
      video2.preload = "auto";
      video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";
      video2.load();
    });
    if (!video) {
      return "premultiply-alpha-on-upload";
    }
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    const framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      texture,
      0
    );
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
    const pixel = new Uint8Array(4);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
    gl.deleteFramebuffer(framebuffer);
    gl.deleteTexture(texture);
    gl.getExtension("WEBGL_lose_context")?.loseContext();
    return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
  })());
  return promise;
}
var promise;
var init_detectVideoAlphaMode = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs
var _VideoSource, VideoSource;
var init_VideoSource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs"() {
    init_Ticker();
    init_detectVideoAlphaMode();
    init_TextureSource();
    _VideoSource = class extends TextureSource {
      constructor(options) {
        super(options);
        this.isReady = false;
        this.uploadMethodId = "video";
        options = {
          ..._VideoSource.defaultOptions,
          ...options
        };
        this._autoUpdate = true;
        this._isConnectedToTicker = false;
        this._updateFPS = options.updateFPS || 0;
        this._msToNextUpdate = 0;
        this.autoPlay = options.autoPlay !== false;
        this.alphaMode = options.alphaMode ?? "premultiply-alpha-on-upload";
        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);
        this._videoFrameRequestCallbackHandle = null;
        this._load = null;
        this._resolve = null;
        this._reject = null;
        this._onCanPlay = this._onCanPlay.bind(this);
        this._onError = this._onError.bind(this);
        this._onPlayStart = this._onPlayStart.bind(this);
        this._onPlayStop = this._onPlayStop.bind(this);
        this._onSeeked = this._onSeeked.bind(this);
        if (options.autoLoad !== false) {
          void this.load();
        }
      }
      /** Update the video frame if the source is not destroyed and meets certain conditions. */
      updateFrame() {
        if (this.destroyed) {
          return;
        }
        if (this._updateFPS) {
          const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;
          this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
        }
        if (!this._updateFPS || this._msToNextUpdate <= 0) {
          this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
        }
        if (this.isValid) {
          this.update();
        }
      }
      /** Callback to update the video frame and potentially request the next frame update. */
      _videoFrameRequestCallback() {
        this.updateFrame();
        if (this.destroyed) {
          this._videoFrameRequestCallbackHandle = null;
        } else {
          this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(
            this._videoFrameRequestCallback
          );
        }
      }
      /**
       * Checks if the resource has valid dimensions.
       * @returns {boolean} True if width and height are set, otherwise false.
       */
      get isValid() {
        return !!this.resource.videoWidth && !!this.resource.videoHeight;
      }
      /**
       * Start preloading the video resource.
       * @returns {Promise<this>} Handle the validate event
       */
      async load() {
        if (this._load) {
          return this._load;
        }
        const source3 = this.resource;
        if ((source3.readyState === source3.HAVE_ENOUGH_DATA || source3.readyState === source3.HAVE_FUTURE_DATA) && source3.width && source3.height) {
          source3.complete = true;
        }
        source3.addEventListener("play", this._onPlayStart);
        source3.addEventListener("pause", this._onPlayStop);
        source3.addEventListener("seeked", this._onSeeked);
        if (!this._isSourceReady()) {
          const options = this.options;
          if (!options.preload) {
            source3.addEventListener("canplay", this._onCanPlay);
          }
          source3.addEventListener("canplaythrough", this._onCanPlay);
          source3.addEventListener("error", this._onError, true);
        } else {
          this._onCanPlay();
        }
        this.alphaMode = await detectVideoAlphaMode();
        this._load = new Promise((resolve2, reject) => {
          if (this.isValid) {
            resolve2(this);
          } else {
            this._resolve = resolve2;
            this._reject = reject;
            source3.load();
          }
        });
        return this._load;
      }
      /**
       * Handle video error events.
       * @param event - The error event
       */
      _onError(event) {
        this.resource.removeEventListener("error", this._onError, true);
        this.emit("error", event);
        if (this._reject) {
          this._reject(event);
          this._reject = null;
          this._resolve = null;
        }
      }
      /**
       * Checks if the underlying source is playing.
       * @returns True if playing.
       */
      _isSourcePlaying() {
        const source3 = this.resource;
        return !source3.paused && !source3.ended;
      }
      /**
       * Checks if the underlying source is ready for playing.
       * @returns True if ready.
       */
      _isSourceReady() {
        const source3 = this.resource;
        return source3.readyState > 2;
      }
      /** Runs the update loop when the video is ready to play. */
      _onPlayStart() {
        if (!this.isValid) {
          this._onCanPlay();
        }
        this._configureAutoUpdate();
      }
      /** Stops the update loop when a pause event is triggered. */
      _onPlayStop() {
        this._configureAutoUpdate();
      }
      /** Handles behavior when the video completes seeking to the current playback position. */
      _onSeeked() {
        if (this._autoUpdate && !this._isSourcePlaying()) {
          this._msToNextUpdate = 0;
          this.updateFrame();
          this._msToNextUpdate = 0;
        }
      }
      /** Fired when the video is loaded and ready to play. */
      _onCanPlay() {
        const source3 = this.resource;
        source3.removeEventListener("canplay", this._onCanPlay);
        source3.removeEventListener("canplaythrough", this._onCanPlay);
        if (this.isValid) {
          this.isReady = true;
          this.resize(source3.videoWidth, source3.videoHeight);
        }
        this._msToNextUpdate = 0;
        this.updateFrame();
        this._msToNextUpdate = 0;
        if (this._resolve) {
          this._resolve(this);
          this._resolve = null;
          this._reject = null;
        }
        if (this._isSourcePlaying()) {
          this._onPlayStart();
        } else if (this.autoPlay) {
          void this.resource.play();
        }
      }
      /** Cleans up resources and event listeners associated with this texture. */
      destroy() {
        this._configureAutoUpdate();
        const source3 = this.resource;
        if (source3) {
          source3.removeEventListener("play", this._onPlayStart);
          source3.removeEventListener("pause", this._onPlayStop);
          source3.removeEventListener("seeked", this._onSeeked);
          source3.removeEventListener("canplay", this._onCanPlay);
          source3.removeEventListener("canplaythrough", this._onCanPlay);
          source3.removeEventListener("error", this._onError, true);
          source3.pause();
          source3.src = "";
          source3.load();
        }
        super.destroy();
      }
      /** Should the base texture automatically update itself, set to true by default. */
      get autoUpdate() {
        return this._autoUpdate;
      }
      set autoUpdate(value) {
        if (value !== this._autoUpdate) {
          this._autoUpdate = value;
          this._configureAutoUpdate();
        }
      }
      /**
       * How many times a second to update the texture from the video.
       * Leave at 0 to update at every render.
       * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
       */
      get updateFPS() {
        return this._updateFPS;
      }
      set updateFPS(value) {
        if (value !== this._updateFPS) {
          this._updateFPS = value;
          this._configureAutoUpdate();
        }
      }
      /**
       * Configures the updating mechanism based on the current state and settings.
       *
       * This method decides between using the browser's native video frame callback or a custom ticker
       * for updating the video frame. It ensures optimal performance and responsiveness
       * based on the video's state, playback status, and the desired frames-per-second setting.
       *
       * - If `_autoUpdate` is enabled and the video source is playing:
       *   - It will prefer the native video frame callback if available and no specific FPS is set.
       *   - Otherwise, it will use a custom ticker for manual updates.
       * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.
       */
      _configureAutoUpdate() {
        if (this._autoUpdate && this._isSourcePlaying()) {
          if (!this._updateFPS && this.source.requestVideoFrameCallback) {
            if (this._isConnectedToTicker) {
              Ticker.shared.remove(this.updateFrame, this);
              this._isConnectedToTicker = false;
              this._msToNextUpdate = 0;
            }
            if (this._videoFrameRequestCallbackHandle === null) {
              this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(
                this._videoFrameRequestCallback
              );
            }
          } else {
            if (this._videoFrameRequestCallbackHandle !== null) {
              this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
              this._videoFrameRequestCallbackHandle = null;
            }
            if (!this._isConnectedToTicker) {
              Ticker.shared.add(this.updateFrame, this);
              this._isConnectedToTicker = true;
              this._msToNextUpdate = 0;
            }
          }
        } else {
          if (this._videoFrameRequestCallbackHandle !== null) {
            this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
            this._videoFrameRequestCallbackHandle = null;
          }
          if (this._isConnectedToTicker) {
            Ticker.shared.remove(this.updateFrame, this);
            this._isConnectedToTicker = false;
            this._msToNextUpdate = 0;
          }
        }
      }
    };
    VideoSource = _VideoSource;
    VideoSource.defaultOptions = {
      ...TextureSource.defaultOptions,
      autoLoad: true,
      autoPlay: true,
      updateFPS: 0,
      crossorigin: true,
      loop: false,
      muted: true,
      playsinline: true,
      preload: false
    };
    VideoSource.MIME_TYPES = {
      ogv: "video/ogg",
      mov: "video/quicktime",
      m4v: "video/mp4"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs
function crossOrigin(element, url2, crossorigin) {
  if (crossorigin === void 0 && !url2.startsWith("data:")) {
    element.crossOrigin = determineCrossOrigin(url2);
  } else if (crossorigin !== false) {
    element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
  }
}
function determineCrossOrigin(url2, loc = globalThis.location) {
  if (url2.startsWith("data:")) {
    return "";
  }
  loc = loc || globalThis.location;
  const parsedUrl = new URL(url2, document.baseURI);
  if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {
    return "anonymous";
  }
  return "";
}
var validVideoExtensions, validVideoMIMEs, loadVideoTextures;
var init_loadVideoTextures = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs"() {
    init_Extensions();
    init_VideoSource();
    init_detectVideoAlphaMode();
    init_getResolutionOfUrl();
    init_checkDataUrl();
    init_checkExtension();
    init_createTexture();
    validVideoExtensions = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"];
    validVideoMIMEs = validVideoExtensions.map((ext) => `video/${ext.substring(1)}`);
    loadVideoTextures = {
      name: "loadVideo",
      extension: {
        type: ExtensionType.LoadParser
      },
      config: null,
      test(url2) {
        const isValidDataUrl = checkDataUrl(url2, validVideoMIMEs);
        const isValidExtension = checkExtension(url2, validVideoExtensions);
        return isValidDataUrl || isValidExtension;
      },
      async load(url2, asset, loader) {
        const options = {
          ...VideoSource.defaultOptions,
          resolution: asset.data?.resolution || getResolutionOfUrl(url2),
          alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode(),
          ...asset.data
        };
        const videoElement = document.createElement("video");
        const attributeMap = {
          preload: options.autoLoad !== false ? "auto" : void 0,
          "webkit-playsinline": options.playsinline !== false ? "" : void 0,
          playsinline: options.playsinline !== false ? "" : void 0,
          muted: options.muted === true ? "" : void 0,
          loop: options.loop === true ? "" : void 0,
          autoplay: options.autoPlay !== false ? "" : void 0
        };
        Object.keys(attributeMap).forEach((key2) => {
          const value = attributeMap[key2];
          if (value !== void 0)
            videoElement.setAttribute(key2, value);
        });
        if (options.muted === true) {
          videoElement.muted = true;
        }
        crossOrigin(videoElement, url2, options.crossorigin);
        const sourceElement = document.createElement("source");
        let mime;
        if (url2.startsWith("data:")) {
          mime = url2.slice(5, url2.indexOf(";"));
        } else if (!url2.startsWith("blob:")) {
          const ext = url2.split("?")[0].slice(url2.lastIndexOf(".") + 1).toLowerCase();
          mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;
        }
        sourceElement.src = url2;
        if (mime) {
          sourceElement.type = mime;
        }
        videoElement.appendChild(sourceElement);
        const base = new VideoSource({ ...options, resource: videoElement });
        return createTexture(base, loader, url2);
      },
      unload(texture) {
        texture.destroy(true);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs
var resolveTextureUrl;
var init_resolveTextureUrl = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs"() {
    init_Extensions();
    init_settings();
    init_loadTextures();
    resolveTextureUrl = {
      extension: ExtensionType.ResolveParser,
      test: loadTextures.test,
      parse: (value) => ({
        resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
        format: value.split(".").pop(),
        src: value
      })
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/init.mjs
var assetKeyMap;
var init_init3 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/init.mjs"() {
    init_Extensions();
    init_loadBitmapFont();
    init_cacheTextureArray();
    init_detectAvif();
    init_detectDefaults();
    init_detectMp4();
    init_detectOgv();
    init_detectWebm();
    init_detectWebp();
    init_loadJson();
    init_loadTxt();
    init_loadWebFont();
    init_loadSVG();
    init_loadTextures();
    init_loadVideoTextures();
    init_resolveTextureUrl();
    extensions.add(
      cacheTextureArray,
      detectDefaults,
      detectAvif,
      detectWebp,
      detectMp4,
      detectOgv,
      detectWebm,
      loadJson,
      loadTxt,
      loadWebFont,
      loadSvg,
      loadTextures,
      loadVideoTextures,
      resolveTextureUrl,
      // TODO: these should probably be moved to its own init, along with splitting out all the
      // text pipeline stuff
      xmlBitmapFontLoader,
      bitmapFontCachePlugin
    );
    assetKeyMap = {
      loader: ExtensionType.LoadParser,
      resolver: ExtensionType.ResolveParser,
      cache: ExtensionType.CacheParser,
      detection: ExtensionType.DetectionParser
    };
    extensions.handle(ExtensionType.Asset, (extension) => {
      const ref = extension.ref;
      Object.entries(assetKeyMap).filter(([key2]) => !!ref[key2]).forEach(([key2, type2]) => extensions.add(Object.assign(
        ref[key2],
        // Allow the function to optionally define it's own
        // ExtensionMetadata, the use cases here is priority for LoaderParsers
        { extension: ref[key2].extension ?? type2 }
      )));
    }, (extension) => {
      const ref = extension.ref;
      Object.keys(assetKeyMap).filter((key2) => !!ref[key2]).forEach((key2) => extensions.remove(ref[key2]));
    });
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/events/EventTicker.mjs
var EventsTickerClass, EventsTicker;
var init_EventTicker = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/events/EventTicker.mjs"() {
    init_const2();
    init_Ticker();
    EventsTickerClass = class {
      constructor() {
        this.interactionFrequency = 10;
        this._deltaTime = 0;
        this._didMove = false;
        this._tickerAdded = false;
        this._pauseUpdate = true;
      }
      /**
       * Initializes the event ticker.
       * @param events - The event system.
       */
      init(events) {
        this.removeTickerListener();
        this.events = events;
        this.interactionFrequency = 10;
        this._deltaTime = 0;
        this._didMove = false;
        this._tickerAdded = false;
        this._pauseUpdate = true;
      }
      /** Whether to pause the update checks or not. */
      get pauseUpdate() {
        return this._pauseUpdate;
      }
      set pauseUpdate(paused) {
        this._pauseUpdate = paused;
      }
      /** Adds the ticker listener. */
      addTickerListener() {
        if (this._tickerAdded || !this.domElement) {
          return;
        }
        Ticker.system.add(this._tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
        this._tickerAdded = true;
      }
      /** Removes the ticker listener. */
      removeTickerListener() {
        if (!this._tickerAdded) {
          return;
        }
        Ticker.system.remove(this._tickerUpdate, this);
        this._tickerAdded = false;
      }
      /** Sets flag to not fire extra events when the user has already moved there mouse */
      pointerMoved() {
        this._didMove = true;
      }
      /** Updates the state of interactive objects. */
      _update() {
        if (!this.domElement || this._pauseUpdate) {
          return;
        }
        if (this._didMove) {
          this._didMove = false;
          return;
        }
        const rootPointerEvent = this.events["_rootPointerEvent"];
        if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
          return;
        }
        globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
          clientX: rootPointerEvent.clientX,
          clientY: rootPointerEvent.clientY
        }));
      }
      /**
       * Updates the state of interactive objects if at least {@link interactionFrequency}
       * milliseconds have passed since the last invocation.
       *
       * Invoked by a throttled ticker update from {@link Ticker.system}.
       * @param ticker - The throttled ticker.
       */
      _tickerUpdate(ticker) {
        this._deltaTime += ticker.deltaTime;
        if (this._deltaTime < this.interactionFrequency) {
          return;
        }
        this._deltaTime = 0;
        this._update();
      }
    };
    EventsTicker = new EventsTickerClass();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs
var FederatedMouseEvent;
var init_FederatedMouseEvent = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs"() {
    init_Point();
    init_FederatedEvent();
    FederatedMouseEvent = class extends FederatedEvent {
      constructor() {
        super(...arguments);
        this.client = new Point();
        this.movement = new Point();
        this.offset = new Point();
        this.global = new Point();
        this.screen = new Point();
      }
      /** @readonly */
      get clientX() {
        return this.client.x;
      }
      /** @readonly */
      get clientY() {
        return this.client.y;
      }
      /**
       * Alias for {@link FederatedMouseEvent.clientX this.clientX}.
       * @readonly
       */
      get x() {
        return this.clientX;
      }
      /**
       * Alias for {@link FederatedMouseEvent.clientY this.clientY}.
       * @readonly
       */
      get y() {
        return this.clientY;
      }
      /** @readonly */
      get movementX() {
        return this.movement.x;
      }
      /** @readonly */
      get movementY() {
        return this.movement.y;
      }
      /** @readonly */
      get offsetX() {
        return this.offset.x;
      }
      /** @readonly */
      get offsetY() {
        return this.offset.y;
      }
      /** @readonly */
      get globalX() {
        return this.global.x;
      }
      /** @readonly */
      get globalY() {
        return this.global.y;
      }
      /**
       * The pointer coordinates in the renderer's screen. Alias for {@code screen.x}.
       * @readonly
       */
      get screenX() {
        return this.screen.x;
      }
      /**
       * The pointer coordinates in the renderer's screen. Alias for {@code screen.y}.
       * @readonly
       */
      get screenY() {
        return this.screen.y;
      }
      /**
       * This will return the local coordinates of the specified container for this InteractionData
       * @param {Container} container - The Container that you would like the local
       *  coords off
       * @param {PointData} point - A Point object in which to store the value, optional (otherwise
       *  will create a new point)
       * @param {PointData} globalPos - A Point object containing your custom global coords, optional
       *  (otherwise will use the current global coords)
       * @returns - A point containing the coordinates of the InteractionData position relative
       *  to the Container
       */
      getLocalPosition(container, point, globalPos) {
        return container.worldTransform.applyInverse(globalPos || this.global, point);
      }
      /**
       * Whether the modifier key was pressed when this event natively occurred.
       * @param key - The modifier key.
       */
      getModifierState(key2) {
        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key2);
      }
      /**
       * Not supported.
       * @param _typeArg
       * @param _canBubbleArg
       * @param _cancelableArg
       * @param _viewArg
       * @param _detailArg
       * @param _screenXArg
       * @param _screenYArg
       * @param _clientXArg
       * @param _clientYArg
       * @param _ctrlKeyArg
       * @param _altKeyArg
       * @param _shiftKeyArg
       * @param _metaKeyArg
       * @param _buttonArg
       * @param _relatedTargetArg
       * @deprecated since 7.0.0
       */
      // eslint-disable-next-line max-params
      initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
        throw new Error("Method not implemented.");
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs
var FederatedPointerEvent;
var init_FederatedPointerEvent = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs"() {
    init_FederatedMouseEvent();
    FederatedPointerEvent = class extends FederatedMouseEvent {
      constructor() {
        super(...arguments);
        this.width = 0;
        this.height = 0;
        this.isPrimary = false;
      }
      // Only included for completeness for now
      getCoalescedEvents() {
        if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
          return [this];
        }
        return [];
      }
      // Only included for completeness for now
      getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!");
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs
var FederatedWheelEvent;
var init_FederatedWheelEvent = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs"() {
    init_FederatedMouseEvent();
    FederatedWheelEvent = class extends FederatedMouseEvent {
      constructor() {
        super(...arguments);
        this.DOM_DELTA_PIXEL = 0;
        this.DOM_DELTA_LINE = 1;
        this.DOM_DELTA_PAGE = 2;
      }
    };
    FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
    FederatedWheelEvent.DOM_DELTA_LINE = 1;
    FederatedWheelEvent.DOM_DELTA_PAGE = 2;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/events/EventBoundary.mjs
var PROPAGATION_LIMIT, tempHitLocation, tempLocalMapping, EventBoundary;
var init_EventBoundary = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/events/EventBoundary.mjs"() {
    init_eventemitter3();
    init_Point();
    init_warn();
    init_EventTicker();
    init_FederatedMouseEvent();
    init_FederatedPointerEvent();
    init_FederatedWheelEvent();
    PROPAGATION_LIMIT = 2048;
    tempHitLocation = new Point();
    tempLocalMapping = new Point();
    EventBoundary = class {
      /**
       * @param rootTarget - The holder of the event boundary.
       */
      constructor(rootTarget) {
        this.dispatch = new eventemitter3_default();
        this.moveOnAll = false;
        this.enableGlobalMoveEvents = true;
        this.mappingState = {
          trackingData: {}
        };
        this.eventPool = /* @__PURE__ */ new Map();
        this._allInteractiveElements = [];
        this._hitElements = [];
        this._isPointerMoveEvent = false;
        this.rootTarget = rootTarget;
        this.hitPruneFn = this.hitPruneFn.bind(this);
        this.hitTestFn = this.hitTestFn.bind(this);
        this.mapPointerDown = this.mapPointerDown.bind(this);
        this.mapPointerMove = this.mapPointerMove.bind(this);
        this.mapPointerOut = this.mapPointerOut.bind(this);
        this.mapPointerOver = this.mapPointerOver.bind(this);
        this.mapPointerUp = this.mapPointerUp.bind(this);
        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
        this.mapWheel = this.mapWheel.bind(this);
        this.mappingTable = {};
        this.addEventMapping("pointerdown", this.mapPointerDown);
        this.addEventMapping("pointermove", this.mapPointerMove);
        this.addEventMapping("pointerout", this.mapPointerOut);
        this.addEventMapping("pointerleave", this.mapPointerOut);
        this.addEventMapping("pointerover", this.mapPointerOver);
        this.addEventMapping("pointerup", this.mapPointerUp);
        this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
        this.addEventMapping("wheel", this.mapWheel);
      }
      /**
       * Adds an event mapping for the event `type` handled by `fn`.
       *
       * Event mappings can be used to implement additional or custom events. They take an event
       * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events
       * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.
       *
       * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden
       * instead.
       * @param type - The type of upstream event to map.
       * @param fn - The mapping method. The context of this function must be bound manually, if desired.
       */
      addEventMapping(type2, fn) {
        if (!this.mappingTable[type2]) {
          this.mappingTable[type2] = [];
        }
        this.mappingTable[type2].push({
          fn,
          priority: 0
        });
        this.mappingTable[type2].sort((a2, b2) => a2.priority - b2.priority);
      }
      /**
       * Dispatches the given event
       * @param e
       * @param type
       */
      dispatchEvent(e3, type2) {
        e3.propagationStopped = false;
        e3.propagationImmediatelyStopped = false;
        this.propagate(e3, type2);
        this.dispatch.emit(type2 || e3.type, e3);
      }
      /**
       * Maps the given upstream event through the event boundary and propagates it downstream.
       * @param e
       */
      mapEvent(e3) {
        if (!this.rootTarget) {
          return;
        }
        const mappers = this.mappingTable[e3.type];
        if (mappers) {
          for (let i3 = 0, j3 = mappers.length; i3 < j3; i3++) {
            mappers[i3].fn(e3);
          }
        } else {
          warn(`[EventBoundary]: Event mapping not defined for ${e3.type}`);
        }
      }
      /**
       * Finds the Container that is the target of a event at the given coordinates.
       *
       * The passed (x,y) coordinates are in the world space above this event boundary.
       * @param x
       * @param y
       */
      hitTest(x3, y2) {
        EventsTicker.pauseUpdate = true;
        const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
        const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
        const invertedPath = this[fn](
          this.rootTarget,
          this.rootTarget.eventMode,
          tempHitLocation.set(x3, y2),
          this.hitTestFn,
          this.hitPruneFn
        );
        return invertedPath && invertedPath[0];
      }
      /**
       * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its
       * target {@code e.target}.
       * @param e - The event to propagate.
       * @param type
       */
      propagate(e3, type2) {
        if (!e3.target) {
          return;
        }
        const composedPath = e3.composedPath();
        e3.eventPhase = e3.CAPTURING_PHASE;
        for (let i3 = 0, j3 = composedPath.length - 1; i3 < j3; i3++) {
          e3.currentTarget = composedPath[i3];
          this.notifyTarget(e3, type2);
          if (e3.propagationStopped || e3.propagationImmediatelyStopped)
            return;
        }
        e3.eventPhase = e3.AT_TARGET;
        e3.currentTarget = e3.target;
        this.notifyTarget(e3, type2);
        if (e3.propagationStopped || e3.propagationImmediatelyStopped)
          return;
        e3.eventPhase = e3.BUBBLING_PHASE;
        for (let i3 = composedPath.length - 2; i3 >= 0; i3--) {
          e3.currentTarget = composedPath[i3];
          this.notifyTarget(e3, type2);
          if (e3.propagationStopped || e3.propagationImmediatelyStopped)
            return;
        }
      }
      /**
       * Emits the event {@code e} to all interactive containers. The event is propagated in the bubbling phase always.
       *
       * This is used in the `globalpointermove` event.
       * @param e - The emitted event.
       * @param type - The listeners to notify.
       * @param targets - The targets to notify.
       */
      all(e3, type2, targets = this._allInteractiveElements) {
        if (targets.length === 0)
          return;
        e3.eventPhase = e3.BUBBLING_PHASE;
        const events = Array.isArray(type2) ? type2 : [type2];
        for (let i3 = targets.length - 1; i3 >= 0; i3--) {
          events.forEach((event) => {
            e3.currentTarget = targets[i3];
            this.notifyTarget(e3, event);
          });
        }
      }
      /**
       * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed
       * {@code target}. The last element in the path is {@code target}.
       * @param target
       */
      propagationPath(target) {
        const propagationPath = [target];
        for (let i3 = 0; i3 < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i3++) {
          if (!target.parent) {
            throw new Error("Cannot find propagation path to disconnected target");
          }
          propagationPath.push(target.parent);
          target = target.parent;
        }
        propagationPath.reverse();
        return propagationPath;
      }
      hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
        let shouldReturn = false;
        if (this._interactivePrune(currentTarget))
          return null;
        if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
          EventsTicker.pauseUpdate = false;
        }
        if (currentTarget.interactiveChildren && currentTarget.children) {
          const children = currentTarget.children;
          for (let i3 = children.length - 1; i3 >= 0; i3--) {
            const child = children[i3];
            const nestedHit = this.hitTestMoveRecursive(
              child,
              this._isInteractive(eventMode) ? eventMode : child.eventMode,
              location,
              testFn,
              pruneFn,
              ignore || pruneFn(currentTarget, location)
            );
            if (nestedHit) {
              if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                continue;
              }
              const isInteractive = currentTarget.isInteractive();
              if (nestedHit.length > 0 || isInteractive) {
                if (isInteractive)
                  this._allInteractiveElements.push(currentTarget);
                nestedHit.push(currentTarget);
              }
              if (this._hitElements.length === 0)
                this._hitElements = nestedHit;
              shouldReturn = true;
            }
          }
        }
        const isInteractiveMode = this._isInteractive(eventMode);
        const isInteractiveTarget = currentTarget.isInteractive();
        if (isInteractiveTarget && isInteractiveTarget)
          this._allInteractiveElements.push(currentTarget);
        if (ignore || this._hitElements.length > 0)
          return null;
        if (shouldReturn)
          return this._hitElements;
        if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {
          return isInteractiveTarget ? [currentTarget] : [];
        }
        return null;
      }
      /**
       * Recursive implementation for {@link EventBoundary.hitTest hitTest}.
       * @param currentTarget - The Container that is to be hit tested.
       * @param eventMode - The event mode for the `currentTarget` or one of its parents.
       * @param location - The location that is being tested for overlap.
       * @param testFn - Callback that determines whether the target passes hit testing. This callback
       *  can assume that `pruneFn` failed to prune the container.
       * @param pruneFn - Callback that determiness whether the target and all of its children
       *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees
       *  of the scene graph.
       * @returns An array holding the hit testing target and all its ancestors in order. The first element
       *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite
       *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.
       */
      hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
        if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
          return null;
        }
        if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
          EventsTicker.pauseUpdate = false;
        }
        if (currentTarget.interactiveChildren && currentTarget.children) {
          const children = currentTarget.children;
          const relativeLocation = location;
          for (let i3 = children.length - 1; i3 >= 0; i3--) {
            const child = children[i3];
            const nestedHit = this.hitTestRecursive(
              child,
              this._isInteractive(eventMode) ? eventMode : child.eventMode,
              relativeLocation,
              testFn,
              pruneFn
            );
            if (nestedHit) {
              if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                continue;
              }
              const isInteractive = currentTarget.isInteractive();
              if (nestedHit.length > 0 || isInteractive)
                nestedHit.push(currentTarget);
              return nestedHit;
            }
          }
        }
        const isInteractiveMode = this._isInteractive(eventMode);
        const isInteractiveTarget = currentTarget.isInteractive();
        if (isInteractiveMode && testFn(currentTarget, location)) {
          return isInteractiveTarget ? [currentTarget] : [];
        }
        return null;
      }
      _isInteractive(int) {
        return int === "static" || int === "dynamic";
      }
      _interactivePrune(container) {
        if (!container || !container.visible || !container.renderable) {
          return true;
        }
        if (container.eventMode === "none") {
          return true;
        }
        if (container.eventMode === "passive" && !container.interactiveChildren) {
          return true;
        }
        return false;
      }
      /**
       * Checks whether the container or any of its children cannot pass the hit test at all.
       *
       * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}
       * and {@link Container._mask} for pruning.
       * @param container
       * @param location
       */
      hitPruneFn(container, location) {
        if (container.hitArea) {
          container.worldTransform.applyInverse(location, tempLocalMapping);
          if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
            return true;
          }
        }
        if (container.effects && container.effects.length) {
          for (let i3 = 0; i3 < container.effects.length; i3++) {
            const effect = container.effects[i3];
            if (effect.containsPoint) {
              const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);
              if (!effectContainsPoint) {
                return true;
              }
            }
          }
        }
        return false;
      }
      /**
       * Checks whether the container passes hit testing for the given location.
       * @param container
       * @param location
       * @returns - Whether `container` passes hit testing for `location`.
       */
      hitTestFn(container, location) {
        if (container.hitArea) {
          return true;
        }
        if (container.view?.containsPoint) {
          container.worldTransform.applyInverse(location, tempLocalMapping);
          return container.view.containsPoint(tempLocalMapping);
        }
        return false;
      }
      /**
       * Notify all the listeners to the event's `currentTarget`.
       *
       * If the `currentTarget` contains the property `on<type>`, then it is called here,
       * simulating the behavior from version 6.x and prior.
       * @param e - The event passed to the target.
       * @param type
       */
      notifyTarget(e3, type2) {
        type2 = type2 ?? e3.type;
        const handlerKey = `on${type2}`;
        e3.currentTarget[handlerKey]?.(e3);
        const key2 = e3.eventPhase === e3.CAPTURING_PHASE || e3.eventPhase === e3.AT_TARGET ? `${type2}capture` : type2;
        this._notifyListeners(e3, key2);
        if (e3.eventPhase === e3.AT_TARGET) {
          this._notifyListeners(e3, type2);
        }
      }
      /**
       * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.
       *
       * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.
       * @param from
       */
      mapPointerDown(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const e3 = this.createPointerEvent(from);
        this.dispatchEvent(e3, "pointerdown");
        if (e3.pointerType === "touch") {
          this.dispatchEvent(e3, "touchstart");
        } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
          const isRightButton = e3.button === 2;
          this.dispatchEvent(e3, isRightButton ? "rightdown" : "mousedown");
        }
        const trackingData = this.trackingData(from.pointerId);
        trackingData.pressTargetsByButton[from.button] = e3.composedPath();
        this.freeEvent(e3);
      }
      /**
       * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.
       *
       * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,
       * `mousemove`, and `touchmove` events are fired as well for specific pointer types.
       * @param from - The upstream `pointermove` event.
       */
      mapPointerMove(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        this._allInteractiveElements.length = 0;
        this._hitElements.length = 0;
        this._isPointerMoveEvent = true;
        const e3 = this.createPointerEvent(from);
        this._isPointerMoveEvent = false;
        const isMouse = e3.pointerType === "mouse" || e3.pointerType === "pen";
        const trackingData = this.trackingData(from.pointerId);
        const outTarget = this.findMountedTarget(trackingData.overTargets);
        if (trackingData.overTargets?.length > 0 && outTarget !== e3.target) {
          const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
          const outEvent = this.createPointerEvent(from, outType, outTarget);
          this.dispatchEvent(outEvent, "pointerout");
          if (isMouse)
            this.dispatchEvent(outEvent, "mouseout");
          if (!e3.composedPath().includes(outTarget)) {
            const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
            leaveEvent.eventPhase = leaveEvent.AT_TARGET;
            while (leaveEvent.target && !e3.composedPath().includes(leaveEvent.target)) {
              leaveEvent.currentTarget = leaveEvent.target;
              this.notifyTarget(leaveEvent);
              if (isMouse)
                this.notifyTarget(leaveEvent, "mouseleave");
              leaveEvent.target = leaveEvent.target.parent;
            }
            this.freeEvent(leaveEvent);
          }
          this.freeEvent(outEvent);
        }
        if (outTarget !== e3.target) {
          const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
          const overEvent = this.clonePointerEvent(e3, overType);
          this.dispatchEvent(overEvent, "pointerover");
          if (isMouse)
            this.dispatchEvent(overEvent, "mouseover");
          let overTargetAncestor = outTarget?.parent;
          while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
            if (overTargetAncestor === e3.target)
              break;
            overTargetAncestor = overTargetAncestor.parent;
          }
          const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
          if (didPointerEnter) {
            const enterEvent = this.clonePointerEvent(e3, "pointerenter");
            enterEvent.eventPhase = enterEvent.AT_TARGET;
            while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
              enterEvent.currentTarget = enterEvent.target;
              this.notifyTarget(enterEvent);
              if (isMouse)
                this.notifyTarget(enterEvent, "mouseenter");
              enterEvent.target = enterEvent.target.parent;
            }
            this.freeEvent(enterEvent);
          }
          this.freeEvent(overEvent);
        }
        const allMethods = [];
        const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
        this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e3, "pointermove");
        allowGlobalPointerEvents && allMethods.push("globalpointermove");
        if (e3.pointerType === "touch") {
          this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e3, "touchmove");
          allowGlobalPointerEvents && allMethods.push("globaltouchmove");
        }
        if (isMouse) {
          this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e3, "mousemove");
          allowGlobalPointerEvents && allMethods.push("globalmousemove");
          this.cursor = e3.target?.cursor;
        }
        if (allMethods.length > 0) {
          this.all(e3, allMethods);
        }
        this._allInteractiveElements.length = 0;
        this._hitElements.length = 0;
        trackingData.overTargets = e3.composedPath();
        this.freeEvent(e3);
      }
      /**
       * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.
       *
       * The tracking data for the specific pointer gets a new `overTarget`.
       * @param from - The upstream `pointerover` event.
       */
      mapPointerOver(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const trackingData = this.trackingData(from.pointerId);
        const e3 = this.createPointerEvent(from);
        const isMouse = e3.pointerType === "mouse" || e3.pointerType === "pen";
        this.dispatchEvent(e3, "pointerover");
        if (isMouse)
          this.dispatchEvent(e3, "mouseover");
        if (e3.pointerType === "mouse")
          this.cursor = e3.target?.cursor;
        const enterEvent = this.clonePointerEvent(e3, "pointerenter");
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
          enterEvent.currentTarget = enterEvent.target;
          this.notifyTarget(enterEvent);
          if (isMouse)
            this.notifyTarget(enterEvent, "mouseenter");
          enterEvent.target = enterEvent.target.parent;
        }
        trackingData.overTargets = e3.composedPath();
        this.freeEvent(e3);
        this.freeEvent(enterEvent);
      }
      /**
       * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.
       *
       * The tracking data for the specific pointer is cleared of a `overTarget`.
       * @param from - The upstream `pointerout` event.
       */
      mapPointerOut(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const trackingData = this.trackingData(from.pointerId);
        if (trackingData.overTargets) {
          const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
          const outTarget = this.findMountedTarget(trackingData.overTargets);
          const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
          this.dispatchEvent(outEvent);
          if (isMouse)
            this.dispatchEvent(outEvent, "mouseout");
          const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
          leaveEvent.eventPhase = leaveEvent.AT_TARGET;
          while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
            leaveEvent.currentTarget = leaveEvent.target;
            this.notifyTarget(leaveEvent);
            if (isMouse)
              this.notifyTarget(leaveEvent, "mouseleave");
            leaveEvent.target = leaveEvent.target.parent;
          }
          trackingData.overTargets = null;
          this.freeEvent(outEvent);
          this.freeEvent(leaveEvent);
        }
        this.cursor = null;
      }
      /**
       * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,
       * and `click`/`rightclick`/`pointertap` events, in that order.
       *
       * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific
       * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,
       * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for
       * specific pointer types.
       * @param from - The upstream `pointerup` event.
       */
      mapPointerUp(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const now = performance.now();
        const e3 = this.createPointerEvent(from);
        this.dispatchEvent(e3, "pointerup");
        if (e3.pointerType === "touch") {
          this.dispatchEvent(e3, "touchend");
        } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
          const isRightButton = e3.button === 2;
          this.dispatchEvent(e3, isRightButton ? "rightup" : "mouseup");
        }
        const trackingData = this.trackingData(from.pointerId);
        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        let clickTarget = pressTarget;
        if (pressTarget && !e3.composedPath().includes(pressTarget)) {
          let currentTarget = pressTarget;
          while (currentTarget && !e3.composedPath().includes(currentTarget)) {
            e3.currentTarget = currentTarget;
            this.notifyTarget(e3, "pointerupoutside");
            if (e3.pointerType === "touch") {
              this.notifyTarget(e3, "touchendoutside");
            } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
              const isRightButton = e3.button === 2;
              this.notifyTarget(e3, isRightButton ? "rightupoutside" : "mouseupoutside");
            }
            currentTarget = currentTarget.parent;
          }
          delete trackingData.pressTargetsByButton[from.button];
          clickTarget = currentTarget;
        }
        if (clickTarget) {
          const clickEvent = this.clonePointerEvent(e3, "click");
          clickEvent.target = clickTarget;
          clickEvent.path = null;
          if (!trackingData.clicksByButton[from.button]) {
            trackingData.clicksByButton[from.button] = {
              clickCount: 0,
              target: clickEvent.target,
              timeStamp: now
            };
          }
          const clickHistory = trackingData.clicksByButton[from.button];
          if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
            ++clickHistory.clickCount;
          } else {
            clickHistory.clickCount = 1;
          }
          clickHistory.target = clickEvent.target;
          clickHistory.timeStamp = now;
          clickEvent.detail = clickHistory.clickCount;
          if (clickEvent.pointerType === "mouse") {
            const isRightButton = clickEvent.button === 2;
            this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
          } else if (clickEvent.pointerType === "touch") {
            this.dispatchEvent(clickEvent, "tap");
          }
          this.dispatchEvent(clickEvent, "pointertap");
          this.freeEvent(clickEvent);
        }
        this.freeEvent(e3);
      }
      /**
       * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original
       * `pointerdown` target to `rootTarget`.
       *
       * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the
       * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)
       *
       * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer
       * types. The tracking data for the specific pointer is cleared of a `pressTarget`.
       * @param from - The upstream `pointerupoutside` event.
       */
      mapPointerUpOutside(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const trackingData = this.trackingData(from.pointerId);
        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        const e3 = this.createPointerEvent(from);
        if (pressTarget) {
          let currentTarget = pressTarget;
          while (currentTarget) {
            e3.currentTarget = currentTarget;
            this.notifyTarget(e3, "pointerupoutside");
            if (e3.pointerType === "touch") {
              this.notifyTarget(e3, "touchendoutside");
            } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
              this.notifyTarget(e3, e3.button === 2 ? "rightupoutside" : "mouseupoutside");
            }
            currentTarget = currentTarget.parent;
          }
          delete trackingData.pressTargetsByButton[from.button];
        }
        this.freeEvent(e3);
      }
      /**
       * Maps the upstream `wheel` event to a downstream `wheel` event.
       * @param from - The upstream `wheel` event.
       */
      mapWheel(from) {
        if (!(from instanceof FederatedWheelEvent)) {
          warn("EventBoundary cannot map a non-wheel event as a wheel event");
          return;
        }
        const wheelEvent = this.createWheelEvent(from);
        this.dispatchEvent(wheelEvent);
        this.freeEvent(wheelEvent);
      }
      /**
       * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.
       *
       * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`
       * or `pointerover` target was unmounted from the scene graph.
       * @param propagationPath - The propagation path was valid in the past.
       * @returns - The most specific event-target still mounted at the same location in the scene graph.
       */
      findMountedTarget(propagationPath) {
        if (!propagationPath) {
          return null;
        }
        let currentTarget = propagationPath[0];
        for (let i3 = 1; i3 < propagationPath.length; i3++) {
          if (propagationPath[i3].parent === currentTarget) {
            currentTarget = propagationPath[i3];
          } else {
            break;
          }
        }
        return currentTarget;
      }
      /**
       * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.
       *
       * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
       * @param from - The {@code originalEvent} for the returned event.
       * @param [type=from.type] - The type of the returned event.
       * @param target - The target of the returned event.
       */
      createPointerEvent(from, type2, target) {
        const event = this.allocateEvent(FederatedPointerEvent);
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
        if (typeof type2 === "string") {
          event.type = type2;
        }
        return event;
      }
      /**
       * Creates a wheel event whose {@code originalEvent} is {@code from}.
       *
       * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
       * @param from - The upstream wheel event.
       */
      createWheelEvent(from) {
        const event = this.allocateEvent(FederatedWheelEvent);
        this.copyWheelData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        event.target = this.hitTest(event.global.x, event.global.y);
        return event;
      }
      /**
       * Clones the event {@code from}, with an optional {@code type} override.
       *
       * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
       * @param from - The event to clone.
       * @param [type=from.type] - The type of the returned event.
       */
      clonePointerEvent(from, type2) {
        const event = this.allocateEvent(FederatedPointerEvent);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from.originalEvent;
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.target = from.target;
        event.path = from.composedPath().slice();
        event.type = type2 ?? event.type;
        return event;
      }
      /**
       * Copies wheel {@link FederatedWheelEvent} data from {@code from} into {@code to}.
       *
       * The following properties are copied:
       * + deltaMode
       * + deltaX
       * + deltaY
       * + deltaZ
       * @param from
       * @param to
       */
      copyWheelData(from, to) {
        to.deltaMode = from.deltaMode;
        to.deltaX = from.deltaX;
        to.deltaY = from.deltaY;
        to.deltaZ = from.deltaZ;
      }
      /**
       * Copies pointer {@link FederatedPointerEvent} data from {@code from} into {@code to}.
       *
       * The following properties are copied:
       * + pointerId
       * + width
       * + height
       * + isPrimary
       * + pointerType
       * + pressure
       * + tangentialPressure
       * + tiltX
       * + tiltY
       * @param from
       * @param to
       */
      copyPointerData(from, to) {
        if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))
          return;
        to.pointerId = from.pointerId;
        to.width = from.width;
        to.height = from.height;
        to.isPrimary = from.isPrimary;
        to.pointerType = from.pointerType;
        to.pressure = from.pressure;
        to.tangentialPressure = from.tangentialPressure;
        to.tiltX = from.tiltX;
        to.tiltY = from.tiltY;
        to.twist = from.twist;
      }
      /**
       * Copies mouse {@link FederatedMouseEvent} data from {@code from} to {@code to}.
       *
       * The following properties are copied:
       * + altKey
       * + button
       * + buttons
       * + clientX
       * + clientY
       * + metaKey
       * + movementX
       * + movementY
       * + pageX
       * + pageY
       * + x
       * + y
       * + screen
       * + shiftKey
       * + global
       * @param from
       * @param to
       */
      copyMouseData(from, to) {
        if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))
          return;
        to.altKey = from.altKey;
        to.button = from.button;
        to.buttons = from.buttons;
        to.client.copyFrom(from.client);
        to.ctrlKey = from.ctrlKey;
        to.metaKey = from.metaKey;
        to.movement.copyFrom(from.movement);
        to.screen.copyFrom(from.screen);
        to.shiftKey = from.shiftKey;
        to.global.copyFrom(from.global);
      }
      /**
       * Copies base {@link FederatedEvent} data from {@code from} into {@code to}.
       *
       * The following properties are copied:
       * + isTrusted
       * + srcElement
       * + timeStamp
       * + type
       * @param from - The event to copy data from.
       * @param to - The event to copy data into.
       */
      copyData(from, to) {
        to.isTrusted = from.isTrusted;
        to.srcElement = from.srcElement;
        to.timeStamp = performance.now();
        to.type = from.type;
        to.detail = from.detail;
        to.view = from.view;
        to.which = from.which;
        to.layer.copyFrom(from.layer);
        to.page.copyFrom(from.page);
      }
      /**
       * @param id - The pointer ID.
       * @returns The tracking data stored for the given pointer. If no data exists, a blank
       *  state will be created.
       */
      trackingData(id) {
        if (!this.mappingState.trackingData[id]) {
          this.mappingState.trackingData[id] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null
          };
        }
        return this.mappingState.trackingData[id];
      }
      /**
       * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.
       *
       * This allocation is constructor-agnostic, as long as it only takes one argument - this event
       * boundary.
       * @param constructor - The event's constructor.
       */
      allocateEvent(constructor) {
        if (!this.eventPool.has(constructor)) {
          this.eventPool.set(constructor, []);
        }
        const event = this.eventPool.get(constructor).pop() || new constructor(this);
        event.eventPhase = event.NONE;
        event.currentTarget = null;
        event.path = null;
        event.target = null;
        return event;
      }
      /**
       * Frees the event and puts it back into the event pool.
       *
       * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.
       *
       * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}
       * not be freed. This is because of the possibility that the same event is freed twice, which can cause
       * it to be allocated twice & result in overwriting.
       * @param event - The event to be freed.
       * @throws Error if the event is managed by another event boundary.
       */
      freeEvent(event) {
        if (event.manager !== this)
          throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        const constructor = event.constructor;
        if (!this.eventPool.has(constructor)) {
          this.eventPool.set(constructor, []);
        }
        this.eventPool.get(constructor).push(event);
      }
      /**
       * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag
       * is set on the event.
       * @param e - The event to call each listener with.
       * @param type - The event key.
       */
      _notifyListeners(e3, type2) {
        const listeners = e3.currentTarget._events[type2];
        if (!listeners)
          return;
        if (!e3.currentTarget.isInteractive())
          return;
        if ("fn" in listeners) {
          if (listeners.once)
            e3.currentTarget.removeListener(type2, listeners.fn, void 0, true);
          listeners.fn.call(listeners.context, e3);
        } else {
          for (let i3 = 0, j3 = listeners.length; i3 < j3 && !e3.propagationImmediatelyStopped; i3++) {
            if (listeners[i3].once)
              e3.currentTarget.removeListener(type2, listeners[i3].fn, void 0, true);
            listeners[i3].fn.call(listeners[i3].context, e3);
          }
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/events/EventSystem.mjs
var MOUSE_POINTER_ID, TOUCH_TO_POINTER, _EventSystem, EventSystem;
var init_EventSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/events/EventSystem.mjs"() {
    init_Extensions();
    init_EventBoundary();
    init_EventTicker();
    init_FederatedPointerEvent();
    init_FederatedWheelEvent();
    MOUSE_POINTER_ID = 1;
    TOUCH_TO_POINTER = {
      touchstart: "pointerdown",
      touchend: "pointerup",
      touchendoutside: "pointerupoutside",
      touchmove: "pointermove",
      touchcancel: "pointercancel"
    };
    _EventSystem = class {
      /**
       * @param {Renderer} renderer
       */
      constructor(renderer) {
        this.supportsTouchEvents = "ontouchstart" in globalThis;
        this.supportsPointerEvents = !!globalThis.PointerEvent;
        this.domElement = null;
        this.resolution = 1;
        this.renderer = renderer;
        this.rootBoundary = new EventBoundary(null);
        EventsTicker.init(this);
        this.autoPreventDefault = true;
        this._eventsAdded = false;
        this._rootPointerEvent = new FederatedPointerEvent(null);
        this._rootWheelEvent = new FederatedWheelEvent(null);
        this.cursorStyles = {
          default: "inherit",
          pointer: "pointer"
        };
        this.features = new Proxy({ ..._EventSystem.defaultEventFeatures }, {
          set: (target, key2, value) => {
            if (key2 === "globalMove") {
              this.rootBoundary.enableGlobalMoveEvents = value;
            }
            target[key2] = value;
            return true;
          }
        });
        this._onPointerDown = this._onPointerDown.bind(this);
        this._onPointerMove = this._onPointerMove.bind(this);
        this._onPointerUp = this._onPointerUp.bind(this);
        this._onPointerOverOut = this._onPointerOverOut.bind(this);
        this.onWheel = this.onWheel.bind(this);
      }
      /**
       * The default interaction mode for all display objects.
       * @see Container.eventMode
       * @type {EventMode}
       * @readonly
       * @since 7.2.0
       */
      static get defaultEventMode() {
        return this._defaultEventMode;
      }
      /**
       * Runner init called, view is available at this point.
       * @ignore
       */
      init(options) {
        const { canvas: canvas3, resolution } = this.renderer;
        this.setTargetElement(canvas3);
        this.resolution = resolution;
        _EventSystem._defaultEventMode = options.eventMode ?? "passive";
        Object.assign(this.features, options.eventFeatures ?? {});
        this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
      }
      /**
       * Handle changing resolution.
       * @ignore
       */
      resolutionChange(resolution) {
        this.resolution = resolution;
      }
      /** Destroys all event listeners and detaches the renderer. */
      destroy() {
        this.setTargetElement(null);
        this.renderer = null;
        this._currentCursor = null;
      }
      /**
       * Sets the current cursor mode, handling any callbacks or CSS style changes.
       * @param mode - cursor mode, a key from the cursorStyles dictionary
       */
      setCursor(mode) {
        mode = mode || "default";
        let applyStyles = true;
        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
          applyStyles = false;
        }
        if (this._currentCursor === mode) {
          return;
        }
        this._currentCursor = mode;
        const style = this.cursorStyles[mode];
        if (style) {
          switch (typeof style) {
            case "string":
              if (applyStyles) {
                this.domElement.style.cursor = style;
              }
              break;
            case "function":
              style(mode);
              break;
            case "object":
              if (applyStyles) {
                Object.assign(this.domElement.style, style);
              }
              break;
          }
        } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
          this.domElement.style.cursor = mode;
        }
      }
      /**
       * The global pointer event.
       * Useful for getting the pointer position without listening to events.
       * @since 7.2.0
       */
      get pointer() {
        return this._rootPointerEvent;
      }
      /**
       * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch event.
       */
      _onPointerDown(nativeEvent) {
        if (!this.features.click)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const events = this._normalizeToPointerData(nativeEvent);
        if (this.autoPreventDefault && events[0].isNormalized) {
          const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
          if (cancelable) {
            nativeEvent.preventDefault();
          }
        }
        for (let i3 = 0, j3 = events.length; i3 < j3; i3++) {
          const nativeEvent2 = events[i3];
          const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);
          this.rootBoundary.mapEvent(federatedEvent);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch events.
       */
      _onPointerMove(nativeEvent) {
        if (!this.features.move)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        EventsTicker.pointerMoved();
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for (let i3 = 0, j3 = normalizedEvents.length; i3 < j3; i3++) {
          const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i3]);
          this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch event.
       */
      _onPointerUp(nativeEvent) {
        if (!this.features.click)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        let target = nativeEvent.target;
        if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
          target = nativeEvent.composedPath()[0];
        }
        const outside = target !== this.domElement ? "outside" : "";
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for (let i3 = 0, j3 = normalizedEvents.length; i3 < j3; i3++) {
          const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i3]);
          event.type += outside;
          this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch event.
       */
      _onPointerOverOut(nativeEvent) {
        if (!this.features.click)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for (let i3 = 0, j3 = normalizedEvents.length; i3 < j3; i3++) {
          const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i3]);
          this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.
       * @param nativeEvent - The native wheel event.
       */
      onWheel(nativeEvent) {
        if (!this.features.wheel)
          return;
        const wheelEvent = this.normalizeWheelEvent(nativeEvent);
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        this.rootBoundary.mapEvent(wheelEvent);
      }
      /**
       * Sets the {@link EventSystem#domElement domElement} and binds event listeners.
       *
       * To deregister the current DOM element without setting a new one, pass {@code null}.
       * @param element - The new DOM element.
       */
      setTargetElement(element) {
        this._removeEvents();
        this.domElement = element;
        EventsTicker.domElement = element;
        this._addEvents();
      }
      /** Register event listeners on {@link Renderer#domElement this.domElement}. */
      _addEvents() {
        if (this._eventsAdded || !this.domElement) {
          return;
        }
        EventsTicker.addTickerListener();
        const style = this.domElement.style;
        if (style) {
          if (globalThis.navigator.msPointerEnabled) {
            style.msContentZooming = "none";
            style.msTouchAction = "none";
          } else if (this.supportsPointerEvents) {
            style.touchAction = "none";
          }
        }
        if (this.supportsPointerEvents) {
          globalThis.document.addEventListener("pointermove", this._onPointerMove, true);
          this.domElement.addEventListener("pointerdown", this._onPointerDown, true);
          this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true);
          this.domElement.addEventListener("pointerover", this._onPointerOverOut, true);
          globalThis.addEventListener("pointerup", this._onPointerUp, true);
        } else {
          globalThis.document.addEventListener("mousemove", this._onPointerMove, true);
          this.domElement.addEventListener("mousedown", this._onPointerDown, true);
          this.domElement.addEventListener("mouseout", this._onPointerOverOut, true);
          this.domElement.addEventListener("mouseover", this._onPointerOverOut, true);
          globalThis.addEventListener("mouseup", this._onPointerUp, true);
          if (this.supportsTouchEvents) {
            this.domElement.addEventListener("touchstart", this._onPointerDown, true);
            this.domElement.addEventListener("touchend", this._onPointerUp, true);
            this.domElement.addEventListener("touchmove", this._onPointerMove, true);
          }
        }
        this.domElement.addEventListener("wheel", this.onWheel, {
          passive: true,
          capture: true
        });
        this._eventsAdded = true;
      }
      /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */
      _removeEvents() {
        if (!this._eventsAdded || !this.domElement) {
          return;
        }
        EventsTicker.removeTickerListener();
        const style = this.domElement.style;
        if (globalThis.navigator.msPointerEnabled) {
          style.msContentZooming = "";
          style.msTouchAction = "";
        } else if (this.supportsPointerEvents) {
          style.touchAction = "";
        }
        if (this.supportsPointerEvents) {
          globalThis.document.removeEventListener("pointermove", this._onPointerMove, true);
          this.domElement.removeEventListener("pointerdown", this._onPointerDown, true);
          this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true);
          this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true);
          globalThis.removeEventListener("pointerup", this._onPointerUp, true);
        } else {
          globalThis.document.removeEventListener("mousemove", this._onPointerMove, true);
          this.domElement.removeEventListener("mousedown", this._onPointerDown, true);
          this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true);
          this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true);
          globalThis.removeEventListener("mouseup", this._onPointerUp, true);
          if (this.supportsTouchEvents) {
            this.domElement.removeEventListener("touchstart", this._onPointerDown, true);
            this.domElement.removeEventListener("touchend", this._onPointerUp, true);
            this.domElement.removeEventListener("touchmove", this._onPointerMove, true);
          }
        }
        this.domElement.removeEventListener("wheel", this.onWheel, true);
        this.domElement = null;
        this._eventsAdded = false;
      }
      /**
       * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The
       * resulting value is stored in the point. This takes into account the fact that the DOM
       * element could be scaled and positioned anywhere on the screen.
       * @param  {PointData} point - the point that the result will be stored in
       * @param  {number} x - the x coord of the position to map
       * @param  {number} y - the y coord of the position to map
       */
      mapPositionToPoint(point, x3, y2) {
        const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
          x: 0,
          y: 0,
          width: this.domElement.width,
          height: this.domElement.height,
          left: 0,
          top: 0
        };
        const resolutionMultiplier = 1 / this.resolution;
        point.x = (x3 - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
        point.y = (y2 - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
      }
      /**
       * Ensures that the original event object contains all data that a regular pointer event would have
       * @param event - The original event data from a touch or mouse event
       * @returns An array containing a single normalized pointer event, in the case of a pointer
       *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
       */
      _normalizeToPointerData(event) {
        const normalizedEvents = [];
        if (this.supportsTouchEvents && event instanceof TouchEvent) {
          for (let i3 = 0, li = event.changedTouches.length; i3 < li; i3++) {
            const touch = event.changedTouches[i3];
            if (typeof touch.button === "undefined")
              touch.button = 0;
            if (typeof touch.buttons === "undefined")
              touch.buttons = 1;
            if (typeof touch.isPrimary === "undefined") {
              touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
            }
            if (typeof touch.width === "undefined")
              touch.width = touch.radiusX || 1;
            if (typeof touch.height === "undefined")
              touch.height = touch.radiusY || 1;
            if (typeof touch.tiltX === "undefined")
              touch.tiltX = 0;
            if (typeof touch.tiltY === "undefined")
              touch.tiltY = 0;
            if (typeof touch.pointerType === "undefined")
              touch.pointerType = "touch";
            if (typeof touch.pointerId === "undefined")
              touch.pointerId = touch.identifier || 0;
            if (typeof touch.pressure === "undefined")
              touch.pressure = touch.force || 0.5;
            if (typeof touch.twist === "undefined")
              touch.twist = 0;
            if (typeof touch.tangentialPressure === "undefined")
              touch.tangentialPressure = 0;
            if (typeof touch.layerX === "undefined")
              touch.layerX = touch.offsetX = touch.clientX;
            if (typeof touch.layerY === "undefined")
              touch.layerY = touch.offsetY = touch.clientY;
            touch.isNormalized = true;
            touch.type = event.type;
            normalizedEvents.push(touch);
          }
        } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
          const tempEvent = event;
          if (typeof tempEvent.isPrimary === "undefined")
            tempEvent.isPrimary = true;
          if (typeof tempEvent.width === "undefined")
            tempEvent.width = 1;
          if (typeof tempEvent.height === "undefined")
            tempEvent.height = 1;
          if (typeof tempEvent.tiltX === "undefined")
            tempEvent.tiltX = 0;
          if (typeof tempEvent.tiltY === "undefined")
            tempEvent.tiltY = 0;
          if (typeof tempEvent.pointerType === "undefined")
            tempEvent.pointerType = "mouse";
          if (typeof tempEvent.pointerId === "undefined")
            tempEvent.pointerId = MOUSE_POINTER_ID;
          if (typeof tempEvent.pressure === "undefined")
            tempEvent.pressure = 0.5;
          if (typeof tempEvent.twist === "undefined")
            tempEvent.twist = 0;
          if (typeof tempEvent.tangentialPressure === "undefined")
            tempEvent.tangentialPressure = 0;
          tempEvent.isNormalized = true;
          normalizedEvents.push(tempEvent);
        } else {
          normalizedEvents.push(event);
        }
        return normalizedEvents;
      }
      /**
       * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.
       *
       * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across
       * multiple native wheel events.
       * @param nativeEvent - The native wheel event that occurred on the canvas.
       * @returns A federated wheel event.
       */
      normalizeWheelEvent(nativeEvent) {
        const event = this._rootWheelEvent;
        this._transferMouseData(event, nativeEvent);
        event.deltaX = nativeEvent.deltaX;
        event.deltaY = nativeEvent.deltaY;
        event.deltaZ = nativeEvent.deltaZ;
        event.deltaMode = nativeEvent.deltaMode;
        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
        event.global.copyFrom(event.screen);
        event.offset.copyFrom(event.screen);
        event.nativeEvent = nativeEvent;
        event.type = nativeEvent.type;
        return event;
      }
      /**
       * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.
       * @param event
       * @param nativeEvent
       */
      _bootstrapEvent(event, nativeEvent) {
        event.originalEvent = null;
        event.nativeEvent = nativeEvent;
        event.pointerId = nativeEvent.pointerId;
        event.width = nativeEvent.width;
        event.height = nativeEvent.height;
        event.isPrimary = nativeEvent.isPrimary;
        event.pointerType = nativeEvent.pointerType;
        event.pressure = nativeEvent.pressure;
        event.tangentialPressure = nativeEvent.tangentialPressure;
        event.tiltX = nativeEvent.tiltX;
        event.tiltY = nativeEvent.tiltY;
        event.twist = nativeEvent.twist;
        this._transferMouseData(event, nativeEvent);
        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
        event.global.copyFrom(event.screen);
        event.offset.copyFrom(event.screen);
        event.isTrusted = nativeEvent.isTrusted;
        if (event.type === "pointerleave") {
          event.type = "pointerout";
        }
        if (event.type.startsWith("mouse")) {
          event.type = event.type.replace("mouse", "pointer");
        }
        if (event.type.startsWith("touch")) {
          event.type = TOUCH_TO_POINTER[event.type] || event.type;
        }
        return event;
      }
      /**
       * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.
       * @param event
       * @param nativeEvent
       */
      _transferMouseData(event, nativeEvent) {
        event.isTrusted = nativeEvent.isTrusted;
        event.srcElement = nativeEvent.srcElement;
        event.timeStamp = performance.now();
        event.type = nativeEvent.type;
        event.altKey = nativeEvent.altKey;
        event.button = nativeEvent.button;
        event.buttons = nativeEvent.buttons;
        event.client.x = nativeEvent.clientX;
        event.client.y = nativeEvent.clientY;
        event.ctrlKey = nativeEvent.ctrlKey;
        event.metaKey = nativeEvent.metaKey;
        event.movement.x = nativeEvent.movementX;
        event.movement.y = nativeEvent.movementY;
        event.page.x = nativeEvent.pageX;
        event.page.y = nativeEvent.pageY;
        event.relatedTarget = null;
        event.shiftKey = nativeEvent.shiftKey;
      }
    };
    EventSystem = _EventSystem;
    EventSystem.extension = {
      name: "events",
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.CanvasSystem,
        ExtensionType.WebGPUSystem
      ],
      priority: -1
    };
    EventSystem.defaultEventFeatures = {
      move: true,
      globalMove: true,
      click: true,
      wheel: true
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/events/FederatedEventTarget.mjs
var FederatedContainer;
var init_FederatedEventTarget = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/events/FederatedEventTarget.mjs"() {
    init_EventSystem();
    init_FederatedEvent();
    FederatedContainer = {
      /**
       * Property-based event handler for the `click` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onclick = (event) => {
       *  //some function here that happens on click
       * }
       */
      onclick: null,
      /**
       * Property-based event handler for the `mousedown` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmousedown = (event) => {
       *  //some function here that happens on mousedown
       * }
       */
      onmousedown: null,
      /**
       * Property-based event handler for the `mouseenter` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmouseenter = (event) => {
       *  //some function here that happens on mouseenter
       * }
       */
      onmouseenter: null,
      /**
       * Property-based event handler for the `mouseleave` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmouseleave = (event) => {
       *  //some function here that happens on mouseleave
       * }
       */
      onmouseleave: null,
      /**
       * Property-based event handler for the `mousemove` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmousemove = (event) => {
       *  //some function here that happens on mousemove
       * }
       */
      onmousemove: null,
      /**
       * Property-based event handler for the `globalmousemove` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onglobalmousemove = (event) => {
       *  //some function here that happens on globalmousemove
       * }
       */
      onglobalmousemove: null,
      /**
       * Property-based event handler for the `mouseout` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmouseout = (event) => {
       *  //some function here that happens on mouseout
       * }
       */
      onmouseout: null,
      /**
       * Property-based event handler for the `mouseover` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmouseover = (event) => {
       *  //some function here that happens on mouseover
       * }
       */
      onmouseover: null,
      /**
       * Property-based event handler for the `mouseup` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmouseup = (event) => {
       *  //some function here that happens on mouseup
       * }
       */
      onmouseup: null,
      /**
       * Property-based event handler for the `mouseupoutside` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmouseupoutside = (event) => {
       *  //some function here that happens on mouseupoutside
       * }
       */
      onmouseupoutside: null,
      /**
       * Property-based event handler for the `pointercancel` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointercancel = (event) => {
       *  //some function here that happens on pointercancel
       * }
       */
      onpointercancel: null,
      /**
       * Property-based event handler for the `pointerdown` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointerdown = (event) => {
       *  //some function here that happens on pointerdown
       * }
       */
      onpointerdown: null,
      /**
       * Property-based event handler for the `pointerenter` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointerenter = (event) => {
       *  //some function here that happens on pointerenter
       * }
       */
      onpointerenter: null,
      /**
       * Property-based event handler for the `pointerleave` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointerleave = (event) => {
       *  //some function here that happens on pointerleave
       * }
       */
      onpointerleave: null,
      /**
       * Property-based event handler for the `pointermove` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointermove = (event) => {
       *  //some function here that happens on pointermove
       * }
       */
      onpointermove: null,
      /**
       * Property-based event handler for the `globalpointermove` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onglobalpointermove = (event) => {
       *  //some function here that happens on globalpointermove
       * }
       */
      onglobalpointermove: null,
      /**
       * Property-based event handler for the `pointerout` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointerout = (event) => {
       *  //some function here that happens on pointerout
       * }
       */
      onpointerout: null,
      /**
       * Property-based event handler for the `pointerover` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointerover = (event) => {
       *  //some function here that happens on pointerover
       * }
       */
      onpointerover: null,
      /**
       * Property-based event handler for the `pointertap` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointertap = (event) => {
       *  //some function here that happens on pointertap
       * }
       */
      onpointertap: null,
      /**
       * Property-based event handler for the `pointerup` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointerup = (event) => {
       *  //some function here that happens on pointerup
       * }
       */
      onpointerup: null,
      /**
       * Property-based event handler for the `pointerupoutside` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointerupoutside = (event) => {
       *  //some function here that happens on pointerupoutside
       * }
       */
      onpointerupoutside: null,
      /**
       * Property-based event handler for the `rightclick` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onrightclick = (event) => {
       *  //some function here that happens on rightclick
       * }
       */
      onrightclick: null,
      /**
       * Property-based event handler for the `rightdown` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onrightdown = (event) => {
       *  //some function here that happens on rightdown
       * }
       */
      onrightdown: null,
      /**
       * Property-based event handler for the `rightup` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onrightup = (event) => {
       *  //some function here that happens on rightup
       * }
       */
      onrightup: null,
      /**
       * Property-based event handler for the `rightupoutside` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onrightupoutside = (event) => {
       *  //some function here that happens on rightupoutside
       * }
       */
      onrightupoutside: null,
      /**
       * Property-based event handler for the `tap` event.
       * @memberof Container#
       * @default null
       * @example
       * this.ontap = (event) => {
       *  //some function here that happens on tap
       * }
       */
      ontap: null,
      /**
       * Property-based event handler for the `touchcancel` event.
       * @memberof Container#
       * @default null
       * @example
       * this.ontouchcancel = (event) => {
       *  //some function here that happens on touchcancel
       * }
       */
      ontouchcancel: null,
      /**
       * Property-based event handler for the `touchend` event.
       * @memberof Container#
       * @default null
       * @example
       * this.ontouchend = (event) => {
       *  //some function here that happens on touchend
       * }
       */
      ontouchend: null,
      /**
       * Property-based event handler for the `touchendoutside` event.
       * @memberof Container#
       * @default null
       * @example
       * this.ontouchendoutside = (event) => {
       *  //some function here that happens on touchendoutside
       * }
       */
      ontouchendoutside: null,
      /**
       * Property-based event handler for the `touchmove` event.
       * @memberof Container#
       * @default null
       * @example
       * this.ontouchmove = (event) => {
       *  //some function here that happens on touchmove
       * }
       */
      ontouchmove: null,
      /**
       * Property-based event handler for the `globaltouchmove` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onglobaltouchmove = (event) => {
       *  //some function here that happens on globaltouchmove
       * }
       */
      onglobaltouchmove: null,
      /**
       * Property-based event handler for the `touchstart` event.
       * @memberof Container#
       * @default null
       * @example
       * this.ontouchstart = (event) => {
       *  //some function here that happens on touchstart
       * }
       */
      ontouchstart: null,
      /**
       * Property-based event handler for the `wheel` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onwheel = (event) => {
       *  //some function here that happens on wheel
       * }
       */
      onwheel: null,
      /**
       * Enable interaction events for the Container. Touch, pointer and mouse
       * @memberof Container#
       */
      get interactive() {
        return this.eventMode === "dynamic" || this.eventMode === "static";
      },
      set interactive(value) {
        this.eventMode = value ? "static" : "passive";
      },
      /**
       * @ignore
       */
      _internalEventMode: void 0,
      /**
       * Enable interaction events for the Container. Touch, pointer and mouse.
       * This now replaces the `interactive` property.
       * There are 5 types of interaction settings:
       * - `'none'`: Ignores all interaction events, even on its children.
       * - `'passive'`: Does not emit events and ignores all hit testing on itself and non-interactive children.
       * Interactive children will still emit events.
       * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7
       * - `'static'`: Emit events and is hit tested. Same as `interaction = true` in v7
       * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from a ticker to
       * allow for interaction when the mouse isn't moving
       * @example
       * import { Sprite } from 'pixi.js';
       *
       * const sprite = new Sprite(texture);
       * sprite.eventMode = 'static';
       * sprite.on('tap', (event) => {
       *     // Handle event
       * });
       * @memberof Container#
       * @since 7.2.0
       */
      get eventMode() {
        return this._internalEventMode ?? EventSystem.defaultEventMode;
      },
      set eventMode(value) {
        this._internalEventMode = value;
      },
      /**
       * Determines if the container is interactive or not
       * @returns {boolean} Whether the container is interactive or not
       * @memberof Container#
       * @since 7.2.0
       * @example
       * import { Sprite } from 'pixi.js';
       * const sprite = new Sprite(texture);
       * sprite.eventMode = 'static';
       * sprite.isInteractive(); // true
       *
       * sprite.eventMode = 'dynamic';
       * sprite.isInteractive(); // true
       *
       * sprite.eventMode = 'none';
       * sprite.isInteractive(); // false
       *
       * sprite.eventMode = 'passive';
       * sprite.isInteractive(); // false
       *
       * sprite.eventMode = 'auto';
       * sprite.isInteractive(); // false
       */
      isInteractive() {
        return this.eventMode === "static" || this.eventMode === "dynamic";
      },
      /**
       * Determines if the children to the container can be clicked/touched
       * Setting this to false allows PixiJS to bypass a recursive `hitTest` function
       * @memberof Container#
       */
      interactiveChildren: true,
      /**
       * Interaction shape. Children will be hit first, then this shape will be checked.
       * Setting this will cause this shape to be checked in hit tests rather than the container's bounds.
       * @example
       * import { Rectangle, Sprite } from 'pixi.js';
       *
       * const sprite = new Sprite(texture);
       * sprite.interactive = true;
       * sprite.hitArea = new Rectangle(0, 0, 100, 100);
       * @member {IHitArea}
       * @memberof Container#
       */
      hitArea: null,
      /**
       * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`
       * seeks to be compatible with the DOM's `addEventListener` with support for options.
       * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.
       * @memberof Container
       * @param type - The type of event to listen to.
       * @param listener - The listener callback or object.
       * @param options - Listener options, used for capture phase.
       * @example
       * // Tell the user whether they did a single, double, triple, or nth click.
       * button.addEventListener('click', {
       *     handleEvent(e): {
       *         let prefix;
       *
       *         switch (e.detail) {
       *             case 1: prefix = 'single'; break;
       *             case 2: prefix = 'double'; break;
       *             case 3: prefix = 'triple'; break;
       *             default: prefix = e.detail + 'th'; break;
       *         }
       *
       *         console.log('That was a ' + prefix + 'click');
       *     }
       * });
       *
       * // But skip the first click!
       * button.parent.addEventListener('click', function blockClickOnce(e) {
       *     e.stopImmediatePropagation();
       *     button.parent.removeEventListener('click', blockClickOnce, true);
       * }, {
       *     capture: true,
       * });
       */
      addEventListener(type2, listener, options) {
        const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
        const context4 = typeof listener === "function" ? void 0 : listener;
        type2 = capture ? `${type2}capture` : type2;
        listener = typeof listener === "function" ? listener : listener.handleEvent;
        this.on(type2, listener, context4);
      },
      /**
       * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`
       * seeks to be compatible with the DOM's `removeEventListener` with support for options.
       * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.
       * @memberof Container
       * @param type - The type of event the listener is bound to.
       * @param listener - The listener callback or object.
       * @param options - The original listener options. This is required to deregister a capture phase listener.
       */
      removeEventListener(type2, listener, options) {
        const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
        const context4 = typeof listener === "function" ? void 0 : listener;
        type2 = capture ? `${type2}capture` : type2;
        listener = typeof listener === "function" ? listener : listener.handleEvent;
        this.off(type2, listener, context4);
      },
      /**
       * Dispatch the event on this {@link Container} using the event's {@link EventBoundary}.
       *
       * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.
       *
       * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.
       * @memberof Container
       * @param e - The event to dispatch.
       * @returns Whether the {@link FederatedEvent.preventDefault preventDefault}() method was not invoked.
       * @example
       * // Reuse a click event!
       * button.dispatchEvent(clickEvent);
       */
      dispatchEvent(e3) {
        if (!(e3 instanceof FederatedEvent)) {
          throw new Error("Container cannot propagate events outside of the Federated Events API");
        }
        e3.defaultPrevented = false;
        e3.path = null;
        e3.target = this;
        e3.manager.dispatchEvent(e3);
        return !e3.defaultPrevented;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/events/init.mjs
var init_init4 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/events/init.mjs"() {
    init_Extensions();
    init_Container();
    init_EventSystem();
    init_FederatedEventTarget();
    extensions.add(EventSystem);
    Container.mixin(FederatedContainer);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs
var _Spritesheet, Spritesheet;
var init_Spritesheet = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs"() {
    init_Rectangle();
    init_Texture();
    _Spritesheet = class {
      /**
       * @param texture - Reference to the source BaseTexture object.
       * @param {object} data - Spritesheet image data.
       */
      constructor(texture, data) {
        this.linkedSheets = [];
        this._texture = texture instanceof Texture ? texture : null;
        this.textureSource = texture.source;
        this.textures = {};
        this.animations = {};
        this.data = data;
        const metaResolution = parseFloat(data.meta.scale);
        if (metaResolution) {
          this.resolution = metaResolution;
          texture.source.resolution = this.resolution;
        } else {
          this.resolution = texture.source._resolution;
        }
        this._frames = this.data.frames;
        this._frameKeys = Object.keys(this._frames);
        this._batchIndex = 0;
        this._callback = null;
      }
      /**
       * Parser spritesheet from loaded data. This is done asynchronously
       * to prevent creating too many Texture within a single process.
       * @method Spritesheet#parse
       */
      parse() {
        return new Promise((resolve2) => {
          this._callback = resolve2;
          this._batchIndex = 0;
          if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {
            this._processFrames(0);
            this._processAnimations();
            this._parseComplete();
          } else {
            this._nextBatch();
          }
        });
      }
      /**
       * Process a batch of frames
       * @param initialFrameIndex - The index of frame to start.
       */
      _processFrames(initialFrameIndex) {
        let frameIndex = initialFrameIndex;
        const maxFrames = _Spritesheet.BATCH_SIZE;
        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
          const i3 = this._frameKeys[frameIndex];
          const data = this._frames[i3];
          const rect = data.frame;
          if (rect) {
            let frame = null;
            let trim = null;
            const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
            const orig = new Rectangle(
              0,
              0,
              Math.floor(sourceSize.w) / this.resolution,
              Math.floor(sourceSize.h) / this.resolution
            );
            if (data.rotated) {
              frame = new Rectangle(
                Math.floor(rect.x) / this.resolution,
                Math.floor(rect.y) / this.resolution,
                Math.floor(rect.h) / this.resolution,
                Math.floor(rect.w) / this.resolution
              );
            } else {
              frame = new Rectangle(
                Math.floor(rect.x) / this.resolution,
                Math.floor(rect.y) / this.resolution,
                Math.floor(rect.w) / this.resolution,
                Math.floor(rect.h) / this.resolution
              );
            }
            if (data.trimmed !== false && data.spriteSourceSize) {
              trim = new Rectangle(
                Math.floor(data.spriteSourceSize.x) / this.resolution,
                Math.floor(data.spriteSourceSize.y) / this.resolution,
                Math.floor(rect.w) / this.resolution,
                Math.floor(rect.h) / this.resolution
              );
              trim.x /= this.textureSource.width;
              trim.y /= this.textureSource.height;
              trim.width /= this.textureSource.width;
              trim.height /= this.textureSource.height;
            }
            frame.x /= this.textureSource.width;
            frame.y /= this.textureSource.height;
            frame.width /= this.textureSource.width;
            frame.height /= this.textureSource.height;
            orig.x /= this.textureSource.width;
            orig.y /= this.textureSource.height;
            orig.width /= this.textureSource.width;
            orig.height /= this.textureSource.height;
            this.textures[i3] = new Texture({
              source: this.textureSource,
              layout: {
                frame,
                orig,
                trim,
                rotate: data.rotated ? 2 : 0,
                defaultAnchor: data.anchor,
                defaultBorders: data.borders
              },
              label: i3.toString()
            });
          }
          frameIndex++;
        }
      }
      /** Parse animations config. */
      _processAnimations() {
        const animations = this.data.animations || {};
        for (const animName in animations) {
          this.animations[animName] = [];
          for (let i3 = 0; i3 < animations[animName].length; i3++) {
            const frameName = animations[animName][i3];
            this.animations[animName].push(this.textures[frameName]);
          }
        }
      }
      /** The parse has completed. */
      _parseComplete() {
        const callback = this._callback;
        this._callback = null;
        this._batchIndex = 0;
        callback.call(this, this.textures);
      }
      /** Begin the next batch of textures. */
      _nextBatch() {
        this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);
        this._batchIndex++;
        setTimeout(() => {
          if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {
            this._nextBatch();
          } else {
            this._processAnimations();
            this._parseComplete();
          }
        }, 0);
      }
      /**
       * Destroy Spritesheet and don't use after this.
       * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
       */
      destroy(destroyBase = false) {
        for (const i3 in this.textures) {
          this.textures[i3].destroy();
        }
        this._frames = null;
        this._frameKeys = null;
        this.data = null;
        this.textures = null;
        if (destroyBase) {
          this._texture?.destroy();
          this.textureSource.destroy();
        }
        this._texture = null;
        this.textureSource = null;
        this.linkedSheets = [];
      }
    };
    Spritesheet = _Spritesheet;
    Spritesheet.BATCH_SIZE = 1e3;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs
function getCacheableAssets(keys, asset, ignoreMultiPack) {
  const out3 = {};
  keys.forEach((key2) => {
    out3[key2] = asset;
  });
  Object.keys(asset.textures).forEach((key2) => {
    out3[key2] = asset.textures[key2];
  });
  if (!ignoreMultiPack) {
    const basePath = path.dirname(keys[0]);
    asset.linkedSheets.forEach((item, i3) => {
      const out22 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i3]}`], item, true);
      Object.assign(out3, out22);
    });
  }
  return out3;
}
var validImages, spritesheetAsset;
var init_spritesheetAsset = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs"() {
    init_LoaderParser();
    init_copySearchParams();
    init_Extensions();
    init_settings();
    init_path();
    init_Spritesheet();
    validImages = ["jpg", "png", "jpeg", "avif", "webp"];
    spritesheetAsset = {
      extension: ExtensionType.Asset,
      /** Handle the caching of the related Spritesheet Textures */
      cache: {
        test: (asset) => asset instanceof Spritesheet,
        getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
      },
      /** Resolve the the resolution of the asset. */
      resolver: {
        test: (value) => {
          const tempURL = value.split("?")[0];
          const split = tempURL.split(".");
          const extension = split.pop();
          const format3 = split.pop();
          return extension === "json" && validImages.includes(format3);
        },
        parse: (value) => {
          const split = value.split(".");
          return {
            resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
            format: split[split.length - 2],
            src: value
          };
        }
      },
      /**
       * Loader plugin that parses sprite sheets!
       * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
       * If it is, we load the spritesheets image and parse the data into Spritesheet
       * All textures in the sprite sheet are then added to the cache
       * @ignore
       */
      loader: {
        name: "spritesheetLoader",
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Normal
        },
        async testParse(asset, options) {
          return path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
        },
        async parse(asset, options, loader) {
          let basePath = path.dirname(options.src);
          if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
            basePath += "/";
          }
          let imagePath = basePath + asset.meta.image;
          imagePath = copySearchParams(imagePath, options.src);
          const assets = await loader.load([imagePath]);
          const texture = assets[imagePath];
          const spritesheet = new Spritesheet(
            texture.source,
            asset
          );
          await spritesheet.parse();
          const multiPacks = asset?.meta?.related_multi_packs;
          if (Array.isArray(multiPacks)) {
            const promises = [];
            for (const item of multiPacks) {
              if (typeof item !== "string") {
                continue;
              }
              let itemUrl = basePath + item;
              if (options.data?.ignoreMultiPack) {
                continue;
              }
              itemUrl = copySearchParams(itemUrl, options.src);
              promises.push(loader.load({
                src: itemUrl,
                data: {
                  ignoreMultiPack: true
                }
              }));
            }
            const res = await Promise.all(promises);
            spritesheet.linkedSheets = res;
            res.forEach((item) => {
              item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
            });
          }
          return spritesheet;
        },
        unload(spritesheet) {
          spritesheet.destroy(true);
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/spritesheet/init.mjs
var init_init5 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/spritesheet/init.mjs"() {
    init_Extensions();
    init_spritesheetAsset();
    extensions.add(spritesheetAsset);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/view/View.mjs
var emptyViewObserver;
var init_View = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/view/View.mjs"() {
    emptyViewObserver = {
      onViewUpdate: () => {
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/updateQuadBounds.mjs
function updateQuadBounds(bounds, anchor, texture, padding) {
  const textureSource = texture._source;
  const layout = texture.layout;
  const orig = layout.orig;
  const trim = layout.trim;
  const textureSourceWidth = textureSource.width;
  const textureSourceHeight = textureSource.height;
  const width = textureSourceWidth * orig.width;
  const height = textureSourceHeight * orig.height;
  if (trim) {
    const sourceWidth = textureSourceWidth * trim.width;
    const sourceHeight = textureSourceHeight * trim.height;
    bounds[0] = trim.x * textureSourceWidth - anchor._x * width - padding;
    bounds[1] = bounds[0] + sourceWidth;
    bounds[2] = trim.y * textureSourceHeight - anchor._y * height - padding;
    bounds[3] = bounds[2] + sourceHeight;
  } else {
    bounds[0] = -anchor._x * width - padding;
    bounds[1] = bounds[0] + width;
    bounds[2] = -anchor._y * height - padding;
    bounds[3] = bounds[2] + height;
  }
  return;
}
var init_updateQuadBounds = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/updateQuadBounds.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/sprite/SpriteView.mjs
var SpriteView;
var init_SpriteView = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/sprite/SpriteView.mjs"() {
    init_ObservablePoint();
    init_Texture();
    init_View();
    init_uid();
    init_updateQuadBounds();
    SpriteView = class {
      constructor(texture) {
        this.renderPipeId = "sprite";
        this.owner = emptyViewObserver;
        this.uid = uid("spriteView");
        this.batched = true;
        this._didUpdate = false;
        this._bounds = [0, 1, 0, 0];
        this._sourceBounds = [0, 1, 0, 0];
        this._boundsDirty = true;
        this._sourceBoundsDirty = true;
        this.roundPixels = 0;
        this.anchor = new ObservablePoint(
          this,
          texture.layout.defaultAnchor?.x || 0,
          texture.layout.defaultAnchor?.y || 0
        );
        this.texture = texture;
      }
      set texture(value) {
        value || (value = Texture.EMPTY);
        if (this._texture === value)
          return;
        if (this._texture) {
          this._texture.off("update", this.onUpdate, this);
        }
        value.on("update", this.onUpdate, this);
        this._texture = value;
        this.onUpdate();
      }
      get texture() {
        return this._texture;
      }
      get bounds() {
        if (this._boundsDirty) {
          this._updateBounds();
          this._boundsDirty = false;
        }
        return this._bounds;
      }
      get sourceBounds() {
        if (this._sourceBoundsDirty) {
          this._updateSourceBounds();
          this._sourceBoundsDirty = false;
        }
        return this._sourceBounds;
      }
      // passed local space..
      containsPoint(point) {
        const width = this._texture.frameWidth;
        const height = this._texture.frameHeight;
        const x1 = -width * this.anchor.x;
        let y1 = 0;
        if (point.x >= x1 && point.x < x1 + width) {
          y1 = -height * this.anchor.y;
          if (point.y >= y1 && point.y < y1 + height) {
            return true;
          }
        }
        return false;
      }
      addBounds(bounds) {
        const trim = this._texture._layout.trim;
        if (trim) {
          const sourceBounds = this.sourceBounds;
          bounds.addFrame(sourceBounds[0], sourceBounds[2], sourceBounds[1], sourceBounds[3]);
        } else {
          const _bounds = this.bounds;
          bounds.addFrame(_bounds[0], _bounds[2], _bounds[1], _bounds[3]);
        }
      }
      /**
       * @internal
       */
      onUpdate() {
        this._didUpdate = true;
        this._sourceBoundsDirty = this._boundsDirty = true;
        this.owner.onViewUpdate();
      }
      _updateBounds() {
        updateQuadBounds(this._bounds, this.anchor, this._texture, 0);
      }
      _updateSourceBounds() {
        const anchor = this.anchor;
        const texture = this._texture;
        const textureSource = texture._source;
        const layout = texture.layout;
        const orig = layout.orig;
        const sourceBounds = this._sourceBounds;
        const width = textureSource.width * orig.width;
        const height = textureSource.height * orig.height;
        sourceBounds[1] = -anchor._x * width;
        sourceBounds[0] = sourceBounds[1] + width;
        sourceBounds[3] = -anchor._y * height;
        sourceBounds[2] = sourceBounds[3] + height;
      }
      /**
       * Destroys this sprite renderable and optionally its texture.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
       * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
       */
      destroy(options = false) {
        this.anchor = null;
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          this._texture.destroy(destroyTextureSource);
        }
        this._texture = null;
        this._bounds = null;
        this._sourceBounds = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/sprite/Sprite.mjs
var Sprite;
var init_Sprite = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/sprite/Sprite.mjs"() {
    init_Cache();
    init_Texture();
    init_Container();
    init_SpriteView();
    Sprite = class _Sprite extends Container {
      static from(id) {
        if (typeof id === "string") {
          return new _Sprite(Cache.get(id));
        }
        return new _Sprite(id);
      }
      constructor(options = Texture.EMPTY) {
        if (options instanceof Texture) {
          options = { texture: options };
        }
        const { texture, ...rest } = options;
        super({
          view: new SpriteView(texture ?? Texture.EMPTY),
          label: "Sprite",
          ...rest
        });
        this.allowChildren = false;
      }
      get anchor() {
        return this.view.anchor;
      }
      set anchor(value) {
        this.view.anchor.x = value.x;
        this.view.anchor.y = value.y;
      }
      get texture() {
        return this.view.texture;
      }
      set texture(value) {
        this.view.texture = value;
      }
      get roundPixels() {
        return !!this.view.roundPixels;
      }
      set roundPixels(value) {
        this.view.roundPixels = value ? 1 : 0;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs
function addMaskBounds(mask2, bounds, skipUpdateTransform) {
  const boundsToMask = tempBounds2;
  mask2.measurable = true;
  getGlobalBounds(mask2, skipUpdateTransform, boundsToMask);
  bounds.addBoundsMask(boundsToMask);
  mask2.measurable = false;
}
var tempBounds2;
var init_addMaskBounds = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs"() {
    init_Bounds();
    init_getGlobalBounds();
    tempBounds2 = new Bounds();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs
function addMaskLocalBounds(mask2, bounds, localRoot) {
  const boundsToMask = new Bounds();
  mask2.measurable = true;
  const relativeMask = getMatrixRelativeToParent(mask2, localRoot, new Matrix());
  getLocalBounds(mask2, boundsToMask, relativeMask);
  mask2.measurable = false;
  bounds.addBoundsMask(boundsToMask);
}
function getMatrixRelativeToParent(target, root, matrix) {
  if (!target) {
    warn("Item is not inside the root container");
    return matrix;
  }
  if (target !== root) {
    getMatrixRelativeToParent(target.parent, root, matrix);
    if (target.didChange) {
      updateLocalTransform(target.localTransform, target);
    }
    matrix.append(target.localTransform);
  }
  return matrix;
}
var init_addMaskLocalBounds = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs"() {
    init_Matrix();
    init_Bounds();
    init_getLocalBounds();
    init_updateLocalTransform();
    init_warn();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs
var AlphaMask;
var init_AlphaMask = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs"() {
    init_Extensions();
    init_Sprite();
    init_addMaskBounds();
    init_addMaskLocalBounds();
    AlphaMask = class {
      constructor(options) {
        this.priority = 0;
        this.pipe = "alphaMask";
        if (options?.mask) {
          this.init(options.mask);
        }
      }
      init(mask2) {
        this.mask = mask2;
        this.renderMaskToTexture = !(mask2 instanceof Sprite);
        this.mask.renderable = this.renderMaskToTexture;
        this.mask.includeInBuild = !this.renderMaskToTexture;
        this.mask.measurable = false;
      }
      reset() {
        this.mask.measurable = true;
        this.mask = null;
      }
      addBounds(bounds, skipUpdateTransform) {
        addMaskBounds(this.mask, bounds, skipUpdateTransform);
      }
      addLocalBounds(bounds, localRoot) {
        addMaskLocalBounds(this.mask, bounds, localRoot);
      }
      containsPoint(point, hitTestFn) {
        const mask2 = this.mask;
        return hitTestFn(mask2, point);
      }
      destroy() {
        this.reset();
      }
      static test(mask2) {
        return mask2 instanceof Sprite;
      }
    };
    AlphaMask.extension = ExtensionType.MaskEffect;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs
var ColorMask;
var init_ColorMask = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs"() {
    init_Extensions();
    ColorMask = class {
      constructor(options) {
        this.priority = 0;
        this.pipe = "colorMask";
        if (options?.mask) {
          this.init(options.mask);
        }
      }
      init(mask2) {
        this.mask = mask2;
      }
      destroy() {
      }
      static test(mask2) {
        return typeof mask2 === "number";
      }
    };
    ColorMask.extension = ExtensionType.MaskEffect;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs
var StencilMask;
var init_StencilMask = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs"() {
    init_Extensions();
    init_Container();
    init_addMaskBounds();
    init_addMaskLocalBounds();
    StencilMask = class {
      constructor(options) {
        this.priority = 0;
        this.pipe = "stencilMask";
        if (options?.mask) {
          this.init(options.mask);
        }
      }
      init(mask2) {
        this.mask = mask2;
        this.mask.includeInBuild = false;
        this.mask.measurable = false;
      }
      reset() {
        this.mask.measurable = true;
        this.mask.includeInBuild = true;
        this.mask = null;
      }
      addBounds(bounds, skipUpdateTransform) {
        addMaskBounds(this.mask, bounds, skipUpdateTransform);
      }
      addLocalBounds(bounds, localRoot) {
        addMaskLocalBounds(this.mask, bounds, localRoot);
      }
      containsPoint(point, hitTestFn) {
        const mask2 = this.mask;
        return hitTestFn(mask2, point);
      }
      destroy() {
        this.reset();
      }
      static test(mask2) {
        return mask2 instanceof Container;
      }
    };
    StencilMask.extension = ExtensionType.MaskEffect;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/init.mjs
var init_init6 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/init.mjs"() {
    init_Extensions();
    init_AlphaMask();
    init_ColorMask();
    init_StencilMask();
    extensions.add(AlphaMask, ColorMask, StencilMask);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/all.mjs
var all_exports = {};
var init_all = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/all.mjs"() {
    init_init2();
    init_init3();
    init_init4();
    init_init5();
    init_init6();
    init_init();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs
var BindGroup;
var init_BindGroup = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs"() {
    BindGroup = class {
      constructor(resources) {
        this.resources = /* @__PURE__ */ Object.create(null);
        this._dirty = true;
        let index = 0;
        for (const i3 in resources) {
          const resource = resources[i3];
          this.setResource(resource, index++);
        }
        this.updateKey();
      }
      update() {
        this.updateKey();
      }
      updateKey() {
        if (!this._dirty)
          return;
        this._dirty = false;
        const keyParts = [];
        let index = 0;
        for (const i3 in this.resources) {
          keyParts[index++] = this.resources[i3].resourceId;
        }
        this.key = keyParts.join("|");
      }
      setResource(resource, index) {
        const currentResource = this.resources[index];
        if (resource === currentResource)
          return;
        if (currentResource) {
          resource.off?.("change", this.onResourceChange, this);
        }
        resource.on?.("change", this.onResourceChange, this);
        this.resources[index] = resource;
        this._dirty = true;
      }
      getResource(index) {
        return this.resources[index];
      }
      touch(tick) {
        const resources = this.resources;
        for (const i3 in resources) {
          resources[i3].touched = tick;
        }
      }
      destroy() {
        const resources = this.resources;
        for (const i3 in resources) {
          const resource = resources[i3];
          resource.off?.("change", this.onResourceChange, this);
        }
        this.resources = null;
      }
      onResourceChange() {
        this._dirty = true;
        this.update();
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/batcher/shared/const.mjs
var MAX_TEXTURES;
var init_const3 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/batcher/shared/const.mjs"() {
    MAX_TEXTURES = 16;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs
function getTextureBatchBindGroup(textures, size3) {
  let uid4 = 0;
  for (let i3 = 0; i3 < size3; i3++) {
    uid4 = uid4 * 31 + textures[i3].uid >>> 0;
  }
  return cachedGroups[uid4] || generateTextureBatchBindGroup(textures, uid4);
}
function generateTextureBatchBindGroup(textures, key2) {
  const bindGroupResources = {};
  let bindIndex = 0;
  for (let i3 = 0; i3 < MAX_TEXTURES; i3++) {
    const texture = i3 < textures.length ? textures[i3] : Texture.EMPTY.source;
    bindGroupResources[bindIndex++] = texture.source;
    bindGroupResources[bindIndex++] = texture.style;
  }
  const bindGroup = new BindGroup(bindGroupResources);
  cachedGroups[key2] = bindGroup;
  return bindGroup;
}
var cachedGroups;
var init_getTextureBatchBindGroup = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs"() {
    init_BindGroup();
    init_Texture();
    init_const3();
    cachedGroups = {};
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensurePrecision.mjs
function ensurePrecision(src, options, isFragment) {
  const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;
  if (src.substring(0, 9) !== "precision") {
    let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;
    if (precision === "highp" && maxSupportedPrecision !== "highp") {
      precision = "mediump";
    }
    if (src.substring(0, 8) !== "#version") {
      return `precision ${precision} float;
${src}`;
    }
    const firstLineBreak = src.indexOf("\n");
    return `${src.substring(0, firstLineBreak + 1)}precision ${precision} float;
${src.substring(firstLineBreak + 1)}`;
  } else if (maxSupportedPrecision !== "highp" && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}
var init_ensurePrecision = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensurePrecision.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs
function getTestContext() {
  if (context === unknownContext || context?.isContextLost()) {
    const canvas3 = settings.ADAPTER.createCanvas();
    context = canvas3.getContext("webgl2", {});
  }
  return context;
}
var unknownContext, context;
var init_getTestContext = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs"() {
    init_settings();
    unknownContext = {};
    context = unknownContext;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = "mediump";
    const gl = getTestContext();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? "highp" : "mediump";
      }
    }
  }
  return maxFragmentPrecision;
}
var maxFragmentPrecision;
var init_getMaxFragmentPrecision = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs"() {
    init_getTestContext();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/setProgramName.mjs
function setProgramName(src, { name = `pixi-program` }, isFragment = true) {
  name = name.replace(/\s+/g, "-");
  name += isFragment ? "-fragment" : "-vertex";
  const nameCache2 = isFragment ? fragmentNameCache : VertexNameCache;
  if (nameCache2[name]) {
    nameCache2[name]++;
    name += `-${nameCache2[name]}`;
  } else {
    nameCache2[name] = 1;
  }
  if (src.indexOf("#define SHADER_NAME") !== -1)
    return src;
  const shaderName = `#define SHADER_NAME ${name}`;
  if (src.substring(0, 8) !== "#version") {
    return `${shaderName}
${src}`;
  }
  const firstLineBreak = src.indexOf("\n");
  return `${src.substring(0, firstLineBreak + 1)}${shaderName}
${src.substring(firstLineBreak + 1)}`;
}
var fragmentNameCache, VertexNameCache;
var init_setProgramName = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/setProgramName.mjs"() {
    fragmentNameCache = {};
    VertexNameCache = {};
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/setProgramVersion.mjs
function setProgramVersion(src, { version = "300 es" }) {
  if (src.substring(0, 8) === "#version")
    return src;
  return `#version ${version}
${src}`;
}
var init_setProgramVersion = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/setProgramVersion.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs
var processes, _GlProgram, GlProgram;
var init_GlProgram = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs"() {
    init_ensurePrecision();
    init_getMaxFragmentPrecision();
    init_setProgramName();
    init_setProgramVersion();
    processes = {
      ensurePrecision,
      setProgramName,
      setProgramVersion
    };
    _GlProgram = class {
      constructor(options) {
        options = { ..._GlProgram.defaultOptions, ...options };
        const preprocessorOptions = {
          ensurePrecision: {
            requestedFragmentPrecision: options.preferredFragmentPrecision,
            requestedVertexPrecision: options.preferredVertexPrecision,
            maxSupportedVertexPrecision: "highp",
            maxSupportedFragmentPrecision: getMaxFragmentPrecision()
          },
          setProgramName: {
            name: options.name
          },
          setProgramVersion: {
            version: "300 es"
          }
        };
        let fragment3 = options.fragment;
        let vertex3 = options.vertex;
        Object.keys(processes).forEach((processKey) => {
          const processOptions = preprocessorOptions[processKey] ?? {};
          fragment3 = processes[processKey](fragment3, processOptions, true);
          vertex3 = processes[processKey](vertex3, processOptions, false);
        });
        this.fragment = fragment3;
        this.vertex = vertex3;
        this.key = `${this.vertex}:${this.fragment}`;
      }
      destroy() {
        this.fragment = null;
        this.vertex = null;
        this.attributeData = null;
        this.uniformData = null;
        this.uniformBlockData = null;
        this.transformFeedbackVaryings = null;
      }
      static from(options) {
        const key2 = `${options.vertex}:${options.fragment}`;
        if (!_GlProgram.programCached[key2]) {
          _GlProgram.programCached[key2] = new _GlProgram(options);
        }
        return _GlProgram.programCached[key2];
      }
    };
    GlProgram = _GlProgram;
    GlProgram.defaultOptions = {
      preferredVertexPrecision: "highp",
      preferredFragmentPrecision: "mediump"
    };
    GlProgram.programCached = /* @__PURE__ */ Object.create(null);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/extractStructAndGroups.mjs
function extractStructAndGroups(wgsl) {
  const linePattern = /(?<!\/\/.*)@(group|binding)\(\d+\)[^;]+;/g;
  const groupPattern = /@group\((\d+)\)/;
  const bindingPattern = /@binding\((\d+)\)/;
  const namePattern = /var(<[^>]+>)? (\w+)/;
  const typePattern = /:\s*(\w+)/;
  const structPattern = /struct\s+(\w+)\s*{([^}]+)}/g;
  const structMemberPattern = /(\w+)\s*:\s*([\w\<\>]+)/g;
  const structName = /struct\s+(\w+)/;
  const groups = wgsl.match(linePattern)?.map((item) => ({
    group: parseInt(item.match(groupPattern)[1], 10),
    binding: parseInt(item.match(bindingPattern)[1], 10),
    name: item.match(namePattern)[2],
    isUniform: item.match(namePattern)[1] === "<uniform>",
    type: item.match(typePattern)[1]
  }));
  if (!groups) {
    return {
      groups: [],
      structs: []
    };
  }
  const structs = wgsl.match(structPattern)?.map((struct) => {
    const name = struct.match(structName)[1];
    const members = struct.match(structMemberPattern).reduce((acc, member) => {
      const [name2, type2] = member.split(":");
      acc[name2.trim()] = type2.trim();
      return acc;
    }, {});
    if (!members) {
      return null;
    }
    return { name, members };
  }).filter(({ name }) => groups.some((group) => group.type === name)) ?? [];
  return {
    groups,
    structs
  };
}
var init_extractStructAndGroups = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/extractStructAndGroups.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs
var ShaderStage;
var init_const4 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs"() {
    ShaderStage = /* @__PURE__ */ ((ShaderStage22) => {
      ShaderStage22[ShaderStage22["VERTEX"] = 1] = "VERTEX";
      ShaderStage22[ShaderStage22["FRAGMENT"] = 2] = "FRAGMENT";
      ShaderStage22[ShaderStage22["COMPUTE"] = 4] = "COMPUTE";
      return ShaderStage22;
    })(ShaderStage || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/generateGpuLayoutGroups.mjs
function generateGpuLayoutGroups({ groups }) {
  const layout = [];
  for (let i3 = 0; i3 < groups.length; i3++) {
    const group = groups[i3];
    if (!layout[group.group]) {
      layout[group.group] = [];
    }
    if (group.isUniform) {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,
        buffer: {
          type: "uniform"
        }
      });
    } else if (group.type === "sampler") {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.FRAGMENT,
        sampler: {
          type: "filtering"
        }
      });
    } else if (group.type === "texture_2d") {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.FRAGMENT,
        texture: {
          sampleType: "float",
          viewDimension: "2d",
          multisampled: false
        }
      });
    }
  }
  return layout;
}
var init_generateGpuLayoutGroups = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/generateGpuLayoutGroups.mjs"() {
    init_const4();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/generateLayoutHash.mjs
function generateLayoutHash({ groups }) {
  const layout = [];
  for (let i3 = 0; i3 < groups.length; i3++) {
    const group = groups[i3];
    if (!layout[group.group]) {
      layout[group.group] = {};
    }
    layout[group.group][group.name] = group.binding;
  }
  return layout;
}
var init_generateLayoutHash = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/generateLayoutHash.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/removeStructAndGroupDuplicates.mjs
function removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {
  const structNameSet = /* @__PURE__ */ new Set();
  const dupeGroupKeySet = /* @__PURE__ */ new Set();
  const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {
    if (structNameSet.has(struct.name)) {
      return false;
    }
    structNameSet.add(struct.name);
    return true;
  });
  const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {
    const key2 = `${group.name}-${group.binding}`;
    if (dupeGroupKeySet.has(key2)) {
      return false;
    }
    dupeGroupKeySet.add(key2);
    return true;
  });
  return { structs, groups };
}
var init_removeStructAndGroupDuplicates = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/removeStructAndGroupDuplicates.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs
var _GpuProgram, GpuProgram;
var init_GpuProgram = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs"() {
    init_extractStructAndGroups();
    init_generateGpuLayoutGroups();
    init_generateLayoutHash();
    init_removeStructAndGroupDuplicates();
    _GpuProgram = class {
      constructor({ fragment: fragment3, vertex: vertex3, layout, gpuLayout, name }) {
        this._layoutKey = 0;
        this.name = name;
        this.fragment = fragment3;
        this.vertex = vertex3;
        if (fragment3.source === vertex3.source) {
          const structsAndGroups = extractStructAndGroups(fragment3.source);
          this.structsAndGroups = structsAndGroups;
        } else {
          const vertexStructsAndGroups = extractStructAndGroups(vertex3.source);
          const fragmentStructsAndGroups = extractStructAndGroups(fragment3.source);
          this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);
        }
        this.layout = layout ?? generateLayoutHash(this.structsAndGroups);
        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);
      }
      destroy() {
        this._gpuLayout = null;
        this.gpuLayout = null;
        this.layout = null;
        this.structsAndGroups = null;
        this.fragment = null;
        this.vertex = null;
      }
      static from(options) {
        const key2 = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;
        if (!_GpuProgram.programCached[key2]) {
          _GpuProgram.programCached[key2] = new _GpuProgram(options);
        }
        return _GpuProgram.programCached[key2];
      }
    };
    GpuProgram = _GpuProgram;
    GpuProgram.programCached = /* @__PURE__ */ Object.create(null);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs
function addBits(srcParts, parts, name) {
  if (srcParts) {
    for (const i3 in srcParts) {
      const id = i3.toLocaleLowerCase();
      const part = parts[id];
      if (part) {
        let sanitisedPart = srcParts[i3];
        if (i3 === "header") {
          sanitisedPart = sanitisedPart.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "");
        }
        if (name) {
          part.push(`//----${name}----//`);
        }
        part.push(sanitisedPart);
      } else {
        warn(`${i3} placement hook does not exist in shader`);
      }
    }
  }
}
var init_addBits = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs"() {
    init_warn();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs
function compileHooks(programSrc) {
  const parts = {};
  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, "")) ?? [];
  partMatches.forEach((hook) => {
    parts[hook] = [];
  });
  return parts;
}
var findHooksRx;
var init_compileHooks = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs"() {
    findHooksRx = /\{\{(.*?)\}\}/g;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs
function extractInputs(fragmentSource, out3) {
  let match;
  const regex = /@in\s+([^;]+);/g;
  while ((match = regex.exec(fragmentSource)) !== null) {
    out3.push(match[1]);
  }
}
function compileInputs(fragments, template, sort = false) {
  const results = [];
  extractInputs(template, results);
  fragments.forEach((fragment3) => {
    if (fragment3.header) {
      extractInputs(fragment3.header, results);
    }
  });
  const mainInput = results;
  if (sort) {
    mainInput.sort();
  }
  const finalString = mainInput.map((inValue, i3) => `       @location(${i3}) ${inValue},`).join("\n");
  let cleanedString = template.replace(/@in\s+[^;]+;\s*/g, "");
  cleanedString = cleanedString.replace("{{in}}", `
${finalString}
`);
  return cleanedString;
}
var init_compileInputs = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs
function extractOutputs(fragmentSource, out3) {
  let match;
  const regex = /@out\s+([^;]+);/g;
  while ((match = regex.exec(fragmentSource)) !== null) {
    out3.push(match[1]);
  }
}
function extractVariableName(value) {
  const regex = /\b(\w+)\s*:/g;
  const match = regex.exec(value);
  return match ? match[1] : "";
}
function stripVariable(value) {
  const regex = /@.*?\s+/g;
  return value.replace(regex, "");
}
function compileOutputs(fragments, template) {
  const results = [];
  extractOutputs(template, results);
  fragments.forEach((fragment3) => {
    if (fragment3.header) {
      extractOutputs(fragment3.header, results);
    }
  });
  let index = 0;
  const mainStruct = results.sort().map((inValue) => {
    if (inValue.indexOf("builtin") > -1) {
      return inValue;
    }
    return `@location(${index++}) ${inValue}`;
  }).join(",\n");
  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join("\n");
  const mainEnd = `return VSOutput(
                ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(",\n")});`;
  let compiledCode = template.replace(/@out\s+[^;]+;\s*/g, "");
  compiledCode = compiledCode.replace("{{struct}}", `
${mainStruct}
`);
  compiledCode = compiledCode.replace("{{start}}", `
${mainStart}
`);
  compiledCode = compiledCode.replace("{{return}}", `
${mainEnd}
`);
  return compiledCode;
}
var init_compileOutputs = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs
function injectBits(templateSrc, fragmentParts) {
  let out3 = templateSrc;
  for (const i3 in fragmentParts) {
    const parts = fragmentParts[i3];
    const toInject = parts.join("\n");
    if (toInject.length) {
      out3 = out3.replace(`{{${i3}}}`, `//-----${i3} START-----//
${parts.join("\n")}
//----${i3} FINISH----//`);
    } else {
      out3 = out3.replace(`{{${i3}}}`, "");
    }
  }
  return out3;
}
var init_injectBits = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs
function compileHighShader({
  template,
  bits
}) {
  const cacheId = generateCacheId(template, bits);
  if (cacheMap[cacheId])
    return cacheMap[cacheId];
  const { vertex: vertex3, fragment: fragment3 } = compileInputsAndOutputs(template, bits);
  cacheMap[cacheId] = compileBits(vertex3, fragment3, bits);
  return cacheMap[cacheId];
}
function compileHighShaderGl({
  template,
  bits
}) {
  const cacheId = generateCacheId(template, bits);
  if (cacheMap[cacheId])
    return cacheMap[cacheId];
  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);
  return cacheMap[cacheId];
}
function compileInputsAndOutputs(template, bits) {
  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v3) => !!v3);
  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v3) => !!v3);
  let compiledVertex = compileInputs(vertexFragments, template.vertex);
  compiledVertex = compileOutputs(vertexFragments, compiledVertex);
  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);
  return {
    vertex: compiledVertex,
    fragment: compiledFragment
  };
}
function generateCacheId(template, bits) {
  return bits.map((highFragment) => {
    if (!bitCacheMap.has(highFragment)) {
      bitCacheMap.set(highFragment, CACHE_UID++);
    }
    return bitCacheMap.get(highFragment);
  }).sort((a2, b2) => a2 - b2).join("-") + template.vertex + template.fragment;
}
function compileBits(vertex3, fragment3, bits) {
  const vertexParts = compileHooks(vertex3);
  const fragmentParts = compileHooks(fragment3);
  bits.forEach((shaderBit) => {
    addBits(shaderBit.vertex, vertexParts, shaderBit.name);
    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);
  });
  return {
    vertex: injectBits(vertex3, vertexParts),
    fragment: injectBits(fragment3, fragmentParts)
  };
}
var cacheMap, bitCacheMap, CACHE_UID;
var init_compileHighShader = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs"() {
    init_addBits();
    init_compileHooks();
    init_compileInputs();
    init_compileOutputs();
    init_injectBits();
    cacheMap = /* @__PURE__ */ Object.create(null);
    bitCacheMap = /* @__PURE__ */ new Map();
    CACHE_UID = 0;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs
var vertexGPUTemplate, fragmentGPUTemplate, vertexGlTemplate, fragmentGlTemplate;
var init_defaultProgramTemplate = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs"() {
    vertexGPUTemplate = /* wgsl */
    `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.worldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);
        vUV = aUV;

        {{main}}

        var modelViewProjectionMatrix = globalUniforms.projectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.worldAlpha;

        {{end}}

        {{return}}
    };
`;
    fragmentGPUTemplate = /* wgsl */
    `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        return outColor * vColor;
      };
`;
    vertexGlTemplate = /* glsl */
    `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = worldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;

        {{start}}
        
        vColor = vec4(1.);
        vUV = aUV;

        {{main}}

        mat3 modelViewProjectionMatrix = projectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= worldAlpha;

        {{end}}
    }
`;
    fragmentGlTemplate = /* glsl */
    `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
    }
`;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs
var globalUniformsBit, globalUniformsBitGl;
var init_globalUniformsBit = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs"() {
    globalUniformsBit = {
      name: "global-uniforms-bit",
      vertex: {
        header: (
          /* wgsl */
          `
        struct GlobalUniforms {
            projectionMatrix:mat3x3<f32>,
            worldTransformMatrix:mat3x3<f32>,
            worldAlpha: f32,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
        )
      }
    };
    globalUniformsBitGl = {
      name: "global-uniforms-bit",
      vertex: {
        header: (
          /* glsl */
          `
          uniform globalUniforms {
            mat3 projectionMatrix;
            mat3 worldTransformMatrix;
            float worldAlpha;
            vec2 uResolution;
          };
        `
        )
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs
function compileHighShaderGpuProgram({ bits, name }) {
  const source3 = compileHighShader({
    template: {
      fragment: fragmentGPUTemplate,
      vertex: vertexGPUTemplate
    },
    bits: [
      globalUniformsBit,
      ...bits
    ]
  });
  return new GpuProgram({
    name,
    vertex: {
      source: source3.vertex,
      entryPoint: "main"
    },
    fragment: {
      source: source3.fragment,
      entryPoint: "main"
    }
  });
}
function compileHighShaderGlProgram({ bits, name }) {
  return new GlProgram({
    name,
    ...compileHighShaderGl({
      template: {
        vertex: vertexGlTemplate,
        fragment: fragmentGlTemplate
      },
      bits: [
        globalUniformsBitGl,
        ...bits
      ]
    })
  });
}
var init_compileHighShaderToProgram = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs"() {
    init_GlProgram();
    init_GpuProgram();
    init_compileHighShader();
    init_defaultProgramTemplate();
    init_globalUniformsBit();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs
var colorBit, colorBitGl;
var init_colorBit = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs"() {
    colorBit = {
      name: "color-bit",
      vertex: {
        header: (
          /* wgsl */
          `
            @in aColor: vec4<f32>;
        `
        ),
        main: (
          /* wgsl */
          `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
        )
      }
    };
    colorBitGl = {
      name: "color-bit",
      vertex: {
        header: (
          /* glsl */
          `
            in vec4 aColor;
        `
        ),
        main: (
          /* glsl */
          `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
        )
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs
function generateBindingSrc(maxTextures) {
  const src = [];
  if (maxTextures === 1) {
    src.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;");
    src.push("@group(1) @binding(1) var textureSampler1: sampler;");
  } else {
    let bindingIndex = 0;
    for (let i3 = 0; i3 < maxTextures; i3++) {
      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i3 + 1}: texture_2d<f32>;`);
      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i3 + 1}: sampler;`);
    }
  }
  return src.join("\n");
}
function generateSampleSrc(maxTextures) {
  const src = [];
  if (maxTextures === 1) {
    src.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
  } else {
    src.push("switch vTextureId {");
    for (let i3 = 0; i3 < maxTextures; i3++) {
      if (i3 === maxTextures - 1) {
        src.push(`  default:{`);
      } else {
        src.push(`  case ${i3}:{`);
      }
      src.push(`      outColor = textureSampleGrad(textureSource${i3 + 1}, textureSampler${i3 + 1}, vUV, uvDx, uvDy);`);
      src.push(`      break;}`);
    }
    src.push(`}`);
  }
  return src.join("\n");
}
function generateTextureBatchBit(maxTextures) {
  if (!textureBatchBitCache[maxTextures]) {
    textureBatchBitCache[maxTextures] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
      },
      fragment: {
        header: `
                @in @interpolate(flat) vTextureId: u32;
    
                ${generateBindingSrc(16)}
            `,
        main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);
    
                ${generateSampleSrc(16)}
            `
      }
    };
  }
  return textureBatchBitCache[maxTextures];
}
function generateSampleGlSrc(maxTextures) {
  const src = [];
  for (let i3 = 0; i3 < maxTextures; i3++) {
    if (i3 > 0) {
      src.push("else");
    }
    if (i3 < maxTextures - 1) {
      src.push(`if(vTextureId < ${i3}.5)`);
    }
    src.push("{");
    src.push(`	outColor = texture(uSamplers[${i3}], vUV);`);
    src.push("}");
  }
  return src.join("\n");
}
function generateTextureBatchBitGl(maxTextures) {
  if (!textureBatchBitCache[maxTextures]) {
    textureBatchBitCache[maxTextures] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;
              
            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
      },
      fragment: {
        header: `
                in float vTextureId;
    
                uniform sampler2D uSamplers[${maxTextures}];
              
            `,
        main: `
    
                ${generateSampleGlSrc(16)}
            `
      }
    };
  }
  return textureBatchBitCache[maxTextures];
}
var textureBatchBitCache;
var init_generateTextureBatchBit = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs"() {
    textureBatchBitCache = {};
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs
var roundPixelsBit, roundPixelsBitGl;
var init_roundPixelsBit = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs"() {
    roundPixelsBit = {
      name: "round-pixels-bit",
      vertex: {
        header: (
          /* wgsl */
          `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;
            }
        `
        )
      }
    };
    roundPixelsBitGl = {
      name: "round-pixels-bit",
      vertex: {
        header: (
          /* glsl */
          `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;
            }
        `
        )
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/types.mjs
var RendererType;
var init_types = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/types.mjs"() {
    RendererType = /* @__PURE__ */ ((RendererType22) => {
      RendererType22[RendererType22["WEBGL"] = 1] = "WEBGL";
      RendererType22[RendererType22["WEBGPU"] = 2] = "WEBGPU";
      return RendererType22;
    })(RendererType || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/defaultUniformValue.mjs
function defaultUniformValue(type2, size3) {
  switch (type2) {
    case "f32":
      return 0;
    case "vec2<f32>":
      return new Float32Array(2 * size3);
    case "vec3<f32>":
      return new Float32Array(3 * size3);
    case "vec4<f32>":
      return new Float32Array(4 * size3);
    case "mat2x2<f32>":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3x3<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4x4<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var init_defaultUniformValue = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/defaultUniformValue.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs
var _UniformGroup, UniformGroup;
var init_UniformGroup = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"() {
    init_uid();
    init_defaultUniformValue();
    _UniformGroup = class {
      constructor(uniformStructures, options) {
        this.touched = 0;
        this.uid = uid("uniform");
        this.resourceType = "uniformGroup";
        this.resourceId = this.uid;
        this.isUniformGroup = true;
        this.dirtyId = 0;
        options = { ..._UniformGroup.DEFAULT, ...options };
        this.uniformStructures = uniformStructures;
        const uniforms = {};
        for (const i3 in uniformStructures) {
          const uniformData = uniformStructures[i3];
          uniformData.name = i3;
          uniformData.size = uniformData.size ?? 1;
          uniformData.value ?? (uniformData.value = defaultUniformValue(uniformData.type, uniformData.size));
          uniforms[i3] = uniformData.value;
        }
        this.uniforms = uniforms;
        this.dirtyId = 1;
        this.ubo = options.ubo;
        this.isStatic = options.isStatic;
        this.signature = Object.keys(uniforms).map(
          (i3) => `${i3}-${uniformStructures[i3].type}`
        ).join("-");
      }
      update() {
        this.dirtyId++;
      }
    };
    UniformGroup = _UniformGroup;
    UniformGroup.DEFAULT = {
      ubo: false,
      isStatic: false
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs
var Shader;
var init_Shader = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs"() {
    init_eventemitter3();
    init_BindGroup();
    init_types();
    init_UniformGroup();
    Shader = class extends eventemitter3_default {
      constructor({ gpuProgram, glProgram, groups, resources, groupMap, compatibleRenderers }) {
        super();
        this.uniformBindMap = /* @__PURE__ */ Object.create(null);
        this.gpuProgram = gpuProgram;
        this.glProgram = glProgram;
        if (compatibleRenderers === void 0) {
          compatibleRenderers = 0;
          if (gpuProgram)
            compatibleRenderers |= RendererType.WEBGPU;
          if (glProgram)
            compatibleRenderers |= RendererType.WEBGL;
        }
        this.compatibleRenderers = compatibleRenderers;
        const nameHash = {};
        if (resources && groups) {
          throw new Error("[Shader] Cannot have both resources and groups");
        } else if (!resources && !groups) {
          throw new Error("[Shader] Must provide either resources or groups descriptor");
        } else if (!gpuProgram && groups && !groupMap) {
          throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
        } else if (!gpuProgram && groups && groupMap) {
          for (const i3 in groupMap) {
            for (const j3 in groupMap[i3]) {
              const uniformName = groupMap[i3][j3];
              nameHash[uniformName] = {
                group: i3,
                binding: j3,
                name: uniformName
              };
            }
          }
        } else if (gpuProgram && groups && !groupMap) {
          const groupData = gpuProgram.structsAndGroups.groups;
          groupMap = {};
          groupData.forEach((data) => {
            groupMap[data.group] = groupMap[data.group] || {};
            groupMap[data.group][data.binding] = data.name;
            nameHash[data.name] = data;
          });
        } else if (resources) {
          if (!gpuProgram) {
            groupMap = {};
            groups = {
              99: new BindGroup()
            };
            let bindTick = 0;
            for (const i3 in resources) {
              nameHash[i3] = { group: 99, binding: bindTick, name: i3 };
              groupMap[99] = groupMap[99] || {};
              groupMap[99][bindTick] = i3;
              bindTick++;
            }
          } else {
            const groupData = gpuProgram.structsAndGroups.groups;
            groupMap = {};
            groupData.forEach((data) => {
              groupMap[data.group] = groupMap[data.group] || {};
              groupMap[data.group][data.binding] = data.name;
              nameHash[data.name] = data;
            });
          }
          groups = {};
          for (const i3 in resources) {
            const name = i3;
            let value = resources[i3];
            if (!value.source && !value.resourceType) {
              value = new UniformGroup(value);
            }
            const data = nameHash[name];
            if (data) {
              groups[data.group] = groups[data.group] || new BindGroup();
              groups[data.group].setResource(value, data.binding);
            }
          }
        }
        this.groups = groups;
        this.uniformBindMap = groupMap;
        this.resources = this._buildResourceAccessor(groups, nameHash);
      }
      addResource(name, groupIndex, bindIndex) {
        var _a2, _b;
        (_a2 = this.uniformBindMap)[groupIndex] || (_a2[groupIndex] = {});
        (_b = this.uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);
      }
      _buildResourceAccessor(groups, nameHash) {
        const uniformsOut = {};
        for (const i3 in nameHash) {
          const data = nameHash[i3];
          Object.defineProperty(uniformsOut, data.name, {
            get() {
              return groups[data.group].getResource(data.binding);
            },
            set(value) {
              groups[data.group].setResource(value, data.binding);
            }
          });
        }
        return uniformsOut;
      }
      destroy(destroyProgram = false) {
        this.emit("destroy", this);
        if (destroyProgram) {
          this.gpuProgram?.destroy();
          this.glProgram?.destroy();
        }
        this.gpuProgram = null;
        this.glProgram = null;
        this.groups = null;
        this.removeAllListeners();
        this.uniformBindMap = null;
        this.resources = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs
var GpuGraphicsAdaptor;
var init_GpuGraphicsAdaptor = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs"() {
    init_Extensions();
    init_Matrix();
    init_getTextureBatchBindGroup();
    init_const3();
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_roundPixelsBit();
    init_Shader();
    init_UniformGroup();
    GpuGraphicsAdaptor = class {
      init() {
        const localUniforms = new UniformGroup({
          transformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          uRound: { value: 0, type: "f32" }
        });
        const localUniformBit2 = {
          name: "local-uniform-bit",
          vertex: {
            header: (
              /* wgsl */
              `
        
                    struct LocalUniforms {
                        uTransformMatrix:mat3x3<f32>,
                        uColor:vec4<f32>,
                        uRound:f32,
                    }
        
                    @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
                `
            ),
            main: (
              /* wgsl */
              `
                    vColor *= localUniforms.uColor;
                    modelMatrix *= localUniforms.uTransformMatrix;
                `
            ),
            end: (
              /* wgsl */
              `
                    if(localUniforms.uRound == 1)
                    {
                        vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                    }
                `
            )
          }
        };
        const gpuProgram = compileHighShaderGpuProgram({
          name: "graphics",
          bits: [
            colorBit,
            generateTextureBatchBit(MAX_TEXTURES),
            localUniformBit2,
            roundPixelsBit
          ]
        });
        this.shader = new Shader({
          gpuProgram,
          resources: {
            // added on the fly!
            localUniforms
          }
        });
        this.shader.addResource("globalUniforms", 0, 0);
      }
      execute(graphicsPipe, renderable) {
        const context4 = renderable.view.context;
        const shader = context4.customShader || this.shader;
        const renderer = graphicsPipe.renderer;
        const contextSystem = renderer.graphicsContext;
        const {
          geometry,
          instructions
        } = contextSystem.getContextRenderData(context4);
        const encoder = renderer.encoder;
        encoder.setPipelineFromGeometryProgramAndState(
          geometry,
          shader.gpuProgram,
          graphicsPipe.state
        );
        encoder.setGeometry(geometry);
        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
        encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);
        const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);
        encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);
        const batches = instructions.instructions;
        for (let i3 = 0; i3 < instructions.instructionSize; i3++) {
          const batch = batches[i3];
          shader.groups[1] = batch.bindGroup;
          if (!batch.gpuBindGroup) {
            const textureBatch = batch.textures;
            batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);
            batch.gpuBindGroup = renderer.bindGroup.getBindGroup(
              batch.bindGroup,
              shader.gpuProgram,
              1
            );
          }
          encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);
          encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
        }
      }
      destroy() {
        this.shader.destroy(true);
        this.shader = null;
      }
    };
    GpuGraphicsAdaptor.extension = {
      type: [
        ExtensionType.WebGPUPipesAdaptor
      ],
      name: "graphics"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs
var localUniformBit, localUniformBitGl;
var init_localUniformBit = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs"() {
    localUniformBit = {
      name: "local-uniform-bit",
      vertex: {
        header: (
          /* wgsl */
          `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
        ),
        main: (
          /* wgsl */
          `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
        ),
        end: (
          /* wgsl */
          `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        )
      }
    };
    localUniformBitGl = {
      name: "local-uniform-bit",
      vertex: {
        header: (
          /* glsl */
          `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
        ),
        main: (
          /* glsl */
          `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `
        ),
        end: (
          /* glsl */
          `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
        )
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs
var textureBit, textureBitGl;
var init_textureBit = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs"() {
    textureBit = {
      name: "texture-bit",
      fragment: {
        header: (
          /* wgsl */
          `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `
        ),
        main: (
          /* wgsl */
          `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
        )
      }
    };
    textureBitGl = {
      name: "texture-bit",
      fragment: {
        header: (
          /* wgsl */
          `
        uniform sampler2D uTexture;

         
        `
        ),
        main: (
          /* wgsl */
          `
            outColor = texture(uTexture, vUV);
        `
        )
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs
var GpuMeshAdapter;
var init_GpuMeshAdapter = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs"() {
    init_Extensions();
    init_compileHighShaderToProgram();
    init_localUniformBit();
    init_roundPixelsBit();
    init_textureBit();
    init_Shader();
    init_Texture();
    GpuMeshAdapter = class {
      init() {
        const gpuProgram = compileHighShaderGpuProgram({
          name: "mesh",
          bits: [
            localUniformBit,
            textureBit,
            roundPixelsBit
          ]
        });
        this._shader = new Shader({
          gpuProgram,
          resources: {
            uTexture: Texture.EMPTY._source,
            uSampler: Texture.EMPTY._source.style
          }
        });
      }
      execute(meshPipe, renderable) {
        const renderer = meshPipe.renderer;
        const view = renderable.view;
        let shader = view._shader;
        if (!shader) {
          shader = this._shader;
          shader.groups[2] = renderer.texture.getTextureBindGroup(view.texture);
        }
        shader.groups[0] = renderer.globalUniforms.bindGroup;
        const localUniforms = meshPipe.localUniforms;
        shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);
        renderer.encoder.draw({
          geometry: view._geometry,
          shader,
          state: view.state
        });
      }
      destroy() {
        this._shader.destroy(true);
        this._shader = null;
      }
    };
    GpuMeshAdapter.extension = {
      type: [
        ExtensionType.WebGPUPipesAdaptor
      ],
      name: "mesh"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs
var blendModeIds, BLEND, OFFSET, CULLING, DEPTH_TEST, WINDING, DEPTH_MASK, State;
var init_State = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs"() {
    blendModeIds = {
      normal: 0,
      additive: 1,
      multiply: 2,
      screen: 3,
      overlay: 4,
      erase: 5
    };
    BLEND = 0;
    OFFSET = 1;
    CULLING = 2;
    DEPTH_TEST = 3;
    WINDING = 4;
    DEPTH_MASK = 5;
    State = class _State {
      constructor() {
        this.data = 0;
        this.blendMode = "normal";
        this.polygonOffset = 0;
        this.blend = true;
        this.depthMask = true;
      }
      /**
       * Activates blending of the computed fragment color values.
       * @default true
       */
      get blend() {
        return !!(this.data & 1 << BLEND);
      }
      set blend(value) {
        if (!!(this.data & 1 << BLEND) !== value) {
          this.data ^= 1 << BLEND;
        }
      }
      /**
       * Activates adding an offset to depth values of polygon's fragments
       * @default false
       */
      get offsets() {
        return !!(this.data & 1 << OFFSET);
      }
      set offsets(value) {
        if (!!(this.data & 1 << OFFSET) !== value) {
          this.data ^= 1 << OFFSET;
        }
      }
      set cullMode(value) {
        if (value === "none") {
          this.culling = false;
          return;
        }
        this.culling = true;
        this.clockwiseFrontFace = value === "front";
      }
      get cullMode() {
        if (!this.culling) {
          return "none";
        }
        return this.clockwiseFrontFace ? "front" : "back";
      }
      /**
       * Activates culling of polygons.
       * @default false
       */
      get culling() {
        return !!(this.data & 1 << CULLING);
      }
      set culling(value) {
        if (!!(this.data & 1 << CULLING) !== value) {
          this.data ^= 1 << CULLING;
        }
      }
      /**
       * Activates depth comparisons and updates to the depth buffer.
       * @default false
       */
      get depthTest() {
        return !!(this.data & 1 << DEPTH_TEST);
      }
      set depthTest(value) {
        if (!!(this.data & 1 << DEPTH_TEST) !== value) {
          this.data ^= 1 << DEPTH_TEST;
        }
      }
      /**
       * Enables or disables writing to the depth buffer.
       * @default true
       */
      get depthMask() {
        return !!(this.data & 1 << DEPTH_MASK);
      }
      set depthMask(value) {
        if (!!(this.data & 1 << DEPTH_MASK) !== value) {
          this.data ^= 1 << DEPTH_MASK;
        }
      }
      /**
       * Specifies whether or not front or back-facing polygons can be culled.
       * @default false
       */
      get clockwiseFrontFace() {
        return !!(this.data & 1 << WINDING);
      }
      set clockwiseFrontFace(value) {
        if (!!(this.data & 1 << WINDING) !== value) {
          this.data ^= 1 << WINDING;
        }
      }
      /**
       * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.
       * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
       * @default 'normal'
       */
      get blendMode() {
        return this._blendMode;
      }
      set blendMode(value) {
        this.blend = value !== "none";
        this._blendMode = value;
        this._blendModeId = blendModeIds[value] || 0;
      }
      /**
       * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
       * @default 0
       */
      get polygonOffset() {
        return this._polygonOffset;
      }
      set polygonOffset(value) {
        this.offsets = !!value;
        this._polygonOffset = value;
      }
      toString() {
        return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
      }
      static for2d() {
        const state = new _State();
        state.depthTest = false;
        state.blend = true;
        return state;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs
var tempState, GpuBatchAdaptor;
var init_GpuBatchAdaptor = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs"() {
    init_Extensions();
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_roundPixelsBit();
    init_Shader();
    init_State();
    init_const3();
    init_getTextureBatchBindGroup();
    tempState = State.for2d();
    GpuBatchAdaptor = class {
      init() {
        const gpuProgram = compileHighShaderGpuProgram({
          name: "batch",
          bits: [
            colorBit,
            generateTextureBatchBit(MAX_TEXTURES),
            roundPixelsBit
          ]
        });
        this._shader = new Shader({
          gpuProgram,
          groups: {
            // these will be dynamically allocated
          }
        });
      }
      start(batchPipe, geometry) {
        const renderer = batchPipe.renderer;
        const encoder = renderer.encoder;
        const program = this._shader.gpuProgram;
        this._geometry = geometry;
        encoder.setGeometry(geometry);
        tempState.blendMode = "normal";
        renderer.pipeline.getPipeline(
          geometry,
          program,
          tempState
        );
        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
        encoder.setBindGroup(0, globalUniformsBindGroup, program);
      }
      execute(batchPipe, batch) {
        const program = this._shader.gpuProgram;
        const renderer = batchPipe.renderer;
        const encoder = renderer.encoder;
        if (!batch.bindGroup) {
          const textureBatch = batch.textures;
          batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);
        }
        tempState.blendMode = batch.blendMode;
        const gpuBindGroup = renderer.bindGroup.getBindGroup(
          batch.bindGroup,
          program,
          1
        );
        const pipeline = renderer.pipeline.getPipeline(
          this._geometry,
          program,
          tempState
        );
        batch.bindGroup.touch(renderer.textureGC.count);
        encoder.setPipeline(pipeline);
        encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);
        encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
      }
      destroy() {
        this._shader.destroy(true);
        this._shader = null;
      }
    };
    GpuBatchAdaptor.extension = {
      type: [
        ExtensionType.WebGPUPipesAdaptor
      ],
      name: "batch"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs
var SystemRunner;
var init_SystemRunner = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs"() {
    SystemRunner = class {
      /**
       * @param name - The function name that will be executed on the listeners added to this Runner.
       */
      constructor(name) {
        this.items = [];
        this._name = name;
      }
      /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */
      /**
       * Dispatch/Broadcast Runner to all listeners added to the queue.
       * @param {...any} params - (optional) parameters to pass to each listener
       */
      /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */
      emit(a0, a1, a2, a3, a4, a5, a6, a7) {
        const { name, items } = this;
        for (let i3 = 0, len = items.length; i3 < len; i3++) {
          items[i3][name](a0, a1, a2, a3, a4, a5, a6, a7);
        }
        return this;
      }
      /**
       * Add a listener to the Runner
       *
       * Runners do not need to have scope or functions passed to them.
       * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
       * as the name provided to the Runner when it was created.
       *
       * Eg A listener passed to this Runner will require a 'complete' function.
       *
       * ```
       * import { Runner } from '@pixi/runner';
       *
       * const complete = new Runner('complete');
       * ```
       *
       * The scope used will be the object itself.
       * @param {any} item - The object that will be listening.
       */
      add(item) {
        if (item[this._name]) {
          this.remove(item);
          this.items.push(item);
        }
        return this;
      }
      /**
       * Remove a single listener from the dispatch queue.
       * @param {any} item - The listener that you would like to remove.
       */
      remove(item) {
        const index = this.items.indexOf(item);
        if (index !== -1) {
          this.items.splice(index, 1);
        }
        return this;
      }
      /**
       * Check to see if the listener is already in the Runner
       * @param {any} item - The listener that you would like to check.
       */
      contains(item) {
        return this.items.indexOf(item) !== -1;
      }
      /** Remove all listeners from the Runner */
      removeAll() {
        this.items.length = 0;
        return this;
      }
      /** Remove all references, don't use after this. */
      destroy() {
        this.removeAll();
        this.items = null;
        this._name = null;
      }
      /**
       * `true` if there are no this Runner contains no listeners
       * @readonly
       */
      get empty() {
        return this.items.length === 0;
      }
      /**
       * The name of the runner.
       * @readonly
       */
      get name() {
        return this._name;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs
var defaultRunners, AbstractRenderer;
var init_AbstractRenderer = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs"() {
    init_Color();
    init_Container();
    init_deprecation();
    init_SystemRunner();
    defaultRunners = [
      "init",
      "destroy",
      "contextChange",
      "reset",
      "renderEnd",
      "renderStart",
      "render",
      "update",
      "postrender",
      "prerender"
    ];
    AbstractRenderer = class {
      /**
       * Set up a system with a collection of SystemClasses and runners.
       * Systems are attached dynamically to this class when added.
       * @param config - the config for the system manager
       */
      constructor(config) {
        this.runners = /* @__PURE__ */ Object.create(null);
        this.renderPipes = /* @__PURE__ */ Object.create(null);
        this._systemsHash = /* @__PURE__ */ Object.create(null);
        this.type = config.type;
        this.name = config.name;
        const combinedRunners = [...defaultRunners, ...config.runners ?? []];
        this._addRunners(...combinedRunners);
        this._addSystems(config.systems);
        this._addPipes(config.renderPipes, config.renderPipeAdaptors);
      }
      /**
       * Initialize the renderer.
       * @param options - The options to use to create the renderer.
       */
      async init(options = {}) {
        for (const systemName in this._systemsHash) {
          const system = this._systemsHash[systemName];
          const defaultSystemOptions = system.constructor.defaultOptions;
          options = { ...defaultSystemOptions, ...options };
          this._roundPixels = options.roundPixels ? 1 : 0;
        }
        for (let i3 = 0; i3 < this.runners.init.items.length; i3++) {
          await this.runners.init.items[i3].init(options);
        }
      }
      render(args, deprecated) {
        let options = args;
        if (options instanceof Container) {
          options = { container: options };
          if (deprecated) {
            deprecation(v8_0_0, "passing a second argument is deprecated, please use render options instead");
            options.target = deprecated.renderTexture;
          }
        }
        options.target || (options.target = this.view.texture);
        if (options.target === this.view.texture) {
          this._lastObjectRendered = options.container;
        }
        if (options.clearColor) {
          const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;
          options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();
        }
        this.runners.prerender.emit(options);
        this.runners.renderStart.emit(options);
        this.runners.render.emit(options);
        this.runners.renderEnd.emit(options);
        this.runners.postrender.emit(options);
      }
      /**
       * Resizes the WebGL view to the specified width and height.
       * @param desiredScreenWidth - The desired width of the screen.
       * @param desiredScreenHeight - The desired height of the screen.
       * @param resolution - The resolution / device pixel ratio of the renderer.
       */
      resize(desiredScreenWidth, desiredScreenHeight, resolution) {
        this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);
      }
      /** The resolution / device pixel ratio of the renderer. */
      get resolution() {
        return this.view.resolution;
      }
      set resolution(value) {
        this.view.resolution = value;
      }
      /**
       * Same as view.width, actual number of pixels in the canvas by horizontal.
       * @member {number}
       * @readonly
       * @default 800
       */
      get width() {
        return this.view.texture.frameWidth;
      }
      /**
       * Same as view.height, actual number of pixels in the canvas by vertical.
       * @default 600
       */
      get height() {
        return this.view.texture.frameHeight;
      }
      // NOTE: this was `view` in v7
      /** The canvas element that everything is drawn to.*/
      get canvas() {
        return this.view.canvas;
      }
      /**
       * the last object rendered by the renderer. Useful for other plugins like interaction managers
       * @readonly
       */
      get lastObjectRendered() {
        return this._lastObjectRendered;
      }
      /**
       * Flag if we are rendering to the screen vs renderTexture
       * @readonly
       * @default true
       */
      get renderingToScreen() {
        const renderer = this;
        return renderer.renderTarget.renderingToScreen;
      }
      /**
       * Measurements of the screen. (0, 0, screenWidth, screenHeight).
       *
       * Its safe to use as filterArea or hitArea for the whole stage.
       * @member {Rectangle}
       */
      get screen() {
        return this.view.screen;
      }
      /**
       * Create a bunch of runners based of a collection of ids
       * @param runnerIds - the runner ids to add
       */
      _addRunners(...runnerIds) {
        runnerIds.forEach((runnerId) => {
          this.runners[runnerId] = new SystemRunner(runnerId);
        });
      }
      _addSystems(systems3) {
        let i3;
        for (i3 in systems3) {
          const val = systems3[i3];
          this._addSystem(val.value, val.name);
        }
      }
      /**
       * Add a new system to the renderer.
       * @param ClassRef - Class reference
       * @param name - Property name for system, if not specified
       *        will use a static `name` property on the class itself. This
       *        name will be assigned as s property on the Renderer so make
       *        sure it doesn't collide with properties on Renderer.
       * @returns Return instance of renderer
       */
      _addSystem(ClassRef, name) {
        const system = new ClassRef(this);
        if (this[name]) {
          throw new Error(`Whoops! The name "${name}" is already in use`);
        }
        this[name] = system;
        this._systemsHash[name] = system;
        for (const i3 in this.runners) {
          this.runners[i3].add(system);
        }
        return this;
      }
      _addPipes(pipes, pipeAdaptors) {
        const adaptors = pipeAdaptors.reduce((acc, adaptor) => {
          acc[adaptor.name] = adaptor.value;
          return acc;
        }, {});
        pipes.forEach((pipe) => {
          const PipeClass = pipe.value;
          const name = pipe.name;
          const Adaptor = adaptors[name];
          this.renderPipes[name] = new PipeClass(
            this,
            Adaptor ? new Adaptor() : null
          );
        });
      }
      destroy(options = false) {
        const writeable = this;
        this.runners.destroy.items.reverse();
        this.runners.destroy.emit(options);
        Object.values(this.runners).forEach((runner) => {
          runner.destroy();
        });
        writeable.runners = null;
        this._systemsHash = null;
        writeable.renderPipes = null;
      }
      /**
       * @deprecated since 8.0.0
       * @param options - options or container target to use when generating the texture
       * @returns a texture
       */
      generateTexture(options) {
        return this.textureGenerator.generateTexture(options);
      }
      /**
       * Whether the renderer will round coordinates to whole pixels when rendering.
       * Can be overridden on a per scene item basis.
       */
      get roundPixels() {
        return !!this._roundPixels;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/FilterPipe.mjs
var FilterPipe;
var init_FilterPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/FilterPipe.mjs"() {
    init_Extensions();
    FilterPipe = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      push(filterEffect, container, instructionSet) {
        const renderPipes3 = this._renderer.renderPipes;
        renderPipes3.batch.break(instructionSet);
        instructionSet.add({
          type: "filter",
          canBundle: false,
          action: "pushFilter",
          container,
          filterEffect
        });
      }
      pop(_filterEffect, _container, instructionSet) {
        this._renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          type: "filter",
          action: "popFilter",
          canBundle: false
        });
      }
      execute(instruction) {
        if (instruction.action === "pushFilter") {
          this._renderer.filter.push(instruction);
        } else if (instruction.action === "popFilter") {
          this._renderer.filter.pop();
        }
      }
      destroy() {
        this._renderer = null;
      }
    };
    FilterPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "filter"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs
var Buffer2;
var init_Buffer = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs"() {
    init_eventemitter3();
    init_uid();
    Buffer2 = class extends eventemitter3_default {
      constructor({ data, size: size3, usage, label }) {
        super();
        this.resourceType = "buffer";
        this.resourceId = uid("bufferResource");
        this.touched = 0;
        this.uid = uid("buffer");
        this._updateID = 1;
        if (data instanceof Array) {
          data = new Float32Array(data);
        }
        this._data = data;
        size3 = size3 ?? data?.byteLength;
        const mappedAtCreation = !!data;
        this.descriptor = {
          size: size3,
          usage,
          mappedAtCreation,
          label
        };
      }
      get data() {
        return this._data;
      }
      set data(value) {
        if (this._data !== value) {
          const oldData = this._data;
          this._data = value;
          if (oldData.length !== value.length) {
            this.descriptor.size = value.byteLength;
            this.resourceId = uid("bufferResource");
            this.emit("change", this);
          } else {
            this.emit("update", this);
          }
        }
      }
      update(sizeInBytes) {
        this._updateSize = sizeInBytes || this.descriptor.size;
        this._updateID++;
        this.emit("update", this);
      }
      destroy() {
        this.emit("destroy", this);
        this._data = null;
        this.descriptor = null;
        this.removeAllListeners();
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs
var BufferUsage;
var init_const5 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs"() {
    BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {
      BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";
      BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";
      BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";
      BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";
      BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";
      BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";
      BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";
      BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";
      BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";
      BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";
      BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";
      return BufferUsage2;
    })(BufferUsage || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs
function ensureIsBuffer(buffer2, index) {
  if (!(buffer2 instanceof Buffer2)) {
    let usage = index ? BufferUsage.INDEX : BufferUsage.VERTEX;
    if (buffer2 instanceof Array) {
      if (index) {
        buffer2 = new Uint32Array(buffer2);
        usage = BufferUsage.INDEX | BufferUsage.COPY_DST;
      } else {
        buffer2 = new Float32Array(buffer2);
        usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;
      }
    }
    buffer2 = new Buffer2({
      data: buffer2,
      label: "index-mesh-buffer",
      usage
    });
  }
  return buffer2;
}
var init_ensureIsBuffer = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs"() {
    init_Buffer();
    init_const5();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs
var Geometry;
var init_Geometry = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs"() {
    init_eventemitter3();
    init_uid();
    init_ensureIsBuffer();
    Geometry = class extends eventemitter3_default {
      constructor({ attributes, indexBuffer, topology }) {
        super();
        this.uid = uid("geometry");
        this._layoutKey = 0;
        this.attributes = attributes;
        this.buffers = [];
        for (const i3 in attributes) {
          const attribute = attributes[i3];
          attribute.buffer = ensureIsBuffer(attribute.buffer, false);
          const bufferIndex = this.buffers.indexOf(attribute.buffer);
          if (bufferIndex === -1) {
            this.buffers.push(attribute.buffer);
            attribute.buffer.on("update", this.onBufferUpdate, this);
          }
        }
        if (indexBuffer) {
          this.indexBuffer = ensureIsBuffer(indexBuffer, true);
          this.buffers.push(this.indexBuffer);
        }
        this.topology = topology || "triangle-list";
      }
      onBufferUpdate() {
        this.emit("update", this);
      }
      /**
       * Returns the requested attribute.
       * @param id - The name of the attribute required
       * @returns - The attribute requested.
       */
      getAttribute(id) {
        return this.attributes[id];
      }
      /**
       * Returns the index buffer
       * @returns - The index buffer.
       */
      getIndex() {
        return this.indexBuffer;
      }
      /**
       * Returns the requested buffer.
       * @param id - The name of the buffer required.
       * @returns - The buffer requested.
       */
      getBuffer(id) {
        return this.getAttribute(id).buffer;
      }
      getSize() {
        for (const i3 in this.attributes) {
          const attribute = this.attributes[i3];
          const buffer2 = this.getBuffer(i3);
          return buffer2.data.length / (attribute.stride / 4 || attribute.size);
        }
        return 0;
      }
      destroy(destroyBuffers = false) {
        this.emit("destroy", this);
        this.removeAllListeners();
        if (destroyBuffers) {
          this.buffers.forEach((buffer2) => buffer2.destroy());
        }
        this.attributes = null;
        this.buffers = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/maths/misc/pow2.mjs
function nextPow2(v3) {
  v3 += v3 === 0 ? 1 : 0;
  --v3;
  v3 |= v3 >>> 1;
  v3 |= v3 >>> 2;
  v3 |= v3 >>> 4;
  v3 |= v3 >>> 8;
  v3 |= v3 >>> 16;
  return v3 + 1;
}
var init_pow2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/maths/misc/pow2.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs
var count, TexturePoolClass, TexturePool;
var init_TexturePool = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs"() {
    init_pow2();
    init_TextureSource();
    init_Texture();
    count = 0;
    TexturePoolClass = class {
      /**
       * @param textureOptions - options that will be passed to BaseRenderTexture constructor
       * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.
       */
      constructor(textureOptions) {
        this._poolKeyHash = /* @__PURE__ */ Object.create(null);
        this._texturePool = {};
        this.textureOptions = textureOptions || {};
        this.enableFullScreen = false;
      }
      /**
       * Creates texture with params that were specified in pool constructor.
       * @param pixelWidth - Width of texture in pixels.
       * @param pixelHeight - Height of texture in pixels.
       * @param antialias
       */
      createTexture(pixelWidth, pixelHeight, antialias) {
        const textureSource = new TextureSource({
          ...this.textureOptions,
          width: pixelWidth,
          height: pixelHeight,
          resolution: 1,
          antialias
        });
        return new Texture({
          source: textureSource,
          label: `texturePool_${count++}`
        });
      }
      /**
       * Gets a Power-of-Two render texture or fullScreen texture
       * @param frameWidth - The minimum width of the render texture.
       * @param frameHeight - The minimum height of the render texture.
       * @param resolution - The resolution of the render texture.
       * @param antialias
       * @returns The new render texture.
       */
      getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {
        let po2Width = Math.ceil(frameWidth * resolution - 1e-6);
        let po2Height = Math.ceil(frameHeight * resolution - 1e-6);
        po2Width = nextPow2(po2Width);
        po2Height = nextPow2(po2Height);
        const key2 = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);
        if (!this._texturePool[key2]) {
          this._texturePool[key2] = [];
        }
        let texture = this._texturePool[key2].pop();
        if (!texture) {
          texture = this.createTexture(po2Width, po2Height, antialias);
        }
        texture.source._resolution = resolution;
        texture.source.width = po2Width / resolution;
        texture.source.height = po2Height / resolution;
        texture.source.pixelWidth = po2Width;
        texture.source.pixelHeight = po2Height;
        texture.frameX = 0;
        texture.frameY = 0;
        texture.frameWidth = frameWidth;
        texture.frameHeight = frameHeight;
        texture.layout.update();
        this._poolKeyHash[texture.id] = key2;
        return texture;
      }
      getSameSizeTexture(texture, antialias = false) {
        const source3 = texture.source;
        return this.getOptimalTexture(texture.width, texture.height, source3._resolution, antialias);
      }
      /**
       * Place a render texture back into the pool.
       * @param renderTexture - The renderTexture to free
       */
      returnTexture(renderTexture) {
        const key2 = this._poolKeyHash[renderTexture.id];
        this._texturePool[key2].push(renderTexture);
      }
      /**
       * Clears the pool.
       * @param destroyTextures - Destroy all stored textures.
       */
      clear(destroyTextures) {
        destroyTextures = destroyTextures !== false;
        if (destroyTextures) {
          for (const i3 in this._texturePool) {
            const textures = this._texturePool[i3];
            if (textures) {
              for (let j3 = 0; j3 < textures.length; j3++) {
                textures[j3].destroy(true);
              }
            }
          }
        }
        this._texturePool = {};
      }
    };
    TexturePool = new TexturePoolClass();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs
function getGlobalRenderableBounds(renderables, bounds) {
  bounds.clear();
  const tempMatrix9 = bounds.matrix;
  for (let i3 = 0; i3 < renderables.length; i3++) {
    const renderable = renderables[i3];
    if (renderable.layerVisibleRenderable < 3) {
      continue;
    }
    bounds.matrix = renderable.worldTransform;
    renderable.view.addBounds(bounds);
  }
  bounds.matrix = tempMatrix9;
  return bounds;
}
var init_getRenderableBounds = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/FilterSystem.mjs
var quadGeometry, FilterSystem;
var init_FilterSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/FilterSystem.mjs"() {
    init_Extensions();
    init_Matrix();
    init_Point();
    init_BindGroup();
    init_Geometry();
    init_UniformGroup();
    init_Texture();
    init_TexturePool();
    init_Bounds();
    init_getGlobalBounds();
    init_getRenderableBounds();
    init_warn();
    quadGeometry = new Geometry({
      attributes: {
        aPosition: {
          buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
          shaderLocation: 0,
          format: "float32x2",
          stride: 2 * 4,
          offset: 0
        }
      },
      indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])
    });
    FilterSystem = class {
      constructor(renderer) {
        this._filterStackIndex = 0;
        this._filterStack = [];
        this._filterGlobalUniforms = new UniformGroup({
          inputSize: { value: new Float32Array(4), type: "vec4<f32>" },
          inputPixel: { value: new Float32Array(4), type: "vec4<f32>" },
          inputClamp: { value: new Float32Array(4), type: "vec4<f32>" },
          outputFrame: { value: new Float32Array(4), type: "vec4<f32>" },
          globalFrame: { value: new Float32Array(4), type: "vec4<f32>" },
          outputTexture: { value: new Float32Array(4), type: "vec4<f32>" }
        });
        this._globalFilterBindGroup = new BindGroup({});
        this.renderer = renderer;
      }
      push(instruction) {
        const renderer = this.renderer;
        const filters = instruction.filterEffect.filters;
        if (!this._filterStack[this._filterStackIndex]) {
          this._filterStack[this._filterStackIndex] = this._getFilterData();
        }
        const filterData = this._filterStack[this._filterStackIndex];
        this._filterStackIndex++;
        const bounds = filterData.bounds;
        if (instruction.renderables) {
          getGlobalRenderableBounds(instruction.renderables, bounds);
        } else {
          getGlobalBounds(instruction.container, true, bounds);
        }
        if (filters.length === 0) {
          filterData.skip = true;
          return;
        }
        let resolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;
        let padding = 0;
        let antialias = renderer.renderTarget.rootRenderTarget.colorTexture.source.antialias;
        let blendRequired = false;
        let enabled = false;
        for (let i3 = 0; i3 < filters.length; i3++) {
          const filter = filters[i3];
          resolution = Math.min(resolution, filter.resolution);
          padding += filter.padding;
          if (filter.antialias !== "inherit") {
            if (filter.antialias === "on") {
              antialias = true;
            } else {
              antialias = false;
            }
          }
          const isCompatible = !!(filter.compatibleRenderers & renderer.type);
          if (!isCompatible) {
            enabled = false;
            break;
          }
          if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {
            warn("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.");
            enabled = false;
            break;
          }
          enabled = filter.enabled || enabled;
          blendRequired = blendRequired || filter.blendRequired;
        }
        if (!enabled) {
          filterData.skip = true;
          return;
        }
        bounds.scale(resolution).fit(renderer.renderTarget.rootRenderTarget.viewport).scale(1 / resolution).pad(padding).ceil();
        if (!bounds.isPositive) {
          filterData.skip = true;
          return;
        }
        filterData.skip = false;
        filterData.bounds = bounds;
        filterData.blendRequired = blendRequired;
        filterData.container = instruction.container;
        filterData.filterEffect = instruction.filterEffect;
        filterData.previousRenderSurface = renderer.renderTarget.renderTarget;
        filterData.inputTexture = TexturePool.getOptimalTexture(
          bounds.width,
          bounds.height,
          resolution,
          antialias
        );
        renderer.renderTarget.bind(filterData.inputTexture, true);
        renderer.globalUniforms.push({
          offset: bounds
        });
      }
      pop() {
        const renderer = this.renderer;
        this._filterStackIndex--;
        const filterData = this._filterStack[this._filterStackIndex];
        if (filterData.skip) {
          return;
        }
        this._activeFilterData = filterData;
        const inputTexture = filterData.inputTexture;
        const bounds = filterData.bounds;
        let backTexture = Texture.EMPTY;
        renderer.renderTarget.finishRenderPass?.();
        if (filterData.blendRequired) {
          renderer.encoder.finishRenderPass();
          const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;
          backTexture = this.getBackTexture(filterData.previousRenderSurface, bounds, previousBounds);
        }
        filterData.backTexture = backTexture;
        const filters = filterData.filterEffect.filters;
        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);
        this._globalFilterBindGroup.setResource(backTexture.source, 3);
        renderer.globalUniforms.pop();
        if (filters.length === 1) {
          filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);
          TexturePool.returnTexture(inputTexture);
        } else {
          let flip = filterData.inputTexture;
          let flop = TexturePool.getOptimalTexture(
            bounds.width,
            bounds.height,
            flip.source._resolution,
            false
          );
          let i3 = 0;
          for (i3 = 0; i3 < filters.length - 1; ++i3) {
            const filter = filters[i3];
            filter.apply(this, flip, flop, true);
            const t2 = flip;
            flip = flop;
            flop = t2;
          }
          filters[i3].apply(this, flip, filterData.previousRenderSurface, false);
          TexturePool.returnTexture(flip);
          TexturePool.returnTexture(flop);
        }
        if (filterData.blendRequired) {
          TexturePool.returnTexture(backTexture);
        }
      }
      getBackTexture(lastRenderSurface, bounds, previousBounds) {
        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;
        const backTexture = TexturePool.getOptimalTexture(
          bounds.width,
          bounds.height,
          backgroundResolution,
          false
        );
        let x3 = bounds.minX;
        let y2 = bounds.minY;
        if (previousBounds) {
          x3 -= previousBounds.minX;
          y2 -= previousBounds.minY;
        }
        x3 = Math.floor(x3 * backgroundResolution);
        y2 = Math.floor(y2 * backgroundResolution);
        const width = Math.ceil(bounds.width * backgroundResolution);
        const height = Math.ceil(bounds.height * backgroundResolution);
        this.renderer.renderTarget.copyToTexture(
          lastRenderSurface,
          backTexture,
          { x: x3, y: y2 },
          { width, height }
        );
        return backTexture;
      }
      applyFilter(filter, input, output, clear) {
        const renderer = this.renderer;
        const filterData = this._filterStack[this._filterStackIndex];
        const bounds = filterData.bounds;
        const offset = Point.shared;
        const previousRenderSurface = filterData.previousRenderSurface;
        const isFinalTarget = previousRenderSurface === this.renderer.renderTarget.getRenderTarget(output);
        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;
        if (this._filterStackIndex > 0) {
          resolution = this._filterStack[this._filterStackIndex - 1].inputTexture.source._resolution;
        }
        const filterUniforms = this._filterGlobalUniforms;
        const uniforms = filterUniforms.uniforms;
        const outputFrame = uniforms.outputFrame;
        const inputSize = uniforms.inputSize;
        const inputPixel = uniforms.inputPixel;
        const inputClamp = uniforms.inputClamp;
        const globalFrame = uniforms.globalFrame;
        const outputTexture = uniforms.outputTexture;
        if (isFinalTarget) {
          if (this._filterStackIndex > 0) {
            offset.x = this._filterStack[this._filterStackIndex - 1].bounds.minX;
            offset.y = this._filterStack[this._filterStackIndex - 1].bounds.minY;
          }
          outputFrame[0] = bounds.minX - offset.x;
          outputFrame[1] = bounds.minY - offset.y;
        } else {
          outputFrame[0] = 0;
          outputFrame[1] = 0;
        }
        outputFrame[2] = input.frameWidth;
        outputFrame[3] = input.frameHeight;
        inputSize[0] = input.source.width;
        inputSize[1] = input.source.height;
        inputSize[2] = 1 / inputSize[0];
        inputSize[3] = 1 / inputSize[1];
        inputPixel[0] = input.source.pixelWidth;
        inputPixel[1] = input.source.pixelHeight;
        inputPixel[2] = 1 / inputPixel[0];
        inputPixel[3] = 1 / inputPixel[1];
        inputClamp[0] = 0.5 * inputPixel[2];
        inputClamp[1] = 0.5 * inputPixel[3];
        inputClamp[2] = input.frameWidth * inputSize[2] - 0.5 * inputPixel[2];
        inputClamp[3] = input.frameHeight * inputSize[3] - 0.5 * inputPixel[3];
        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;
        globalFrame[0] = offset.x * resolution;
        globalFrame[1] = offset.y * resolution;
        globalFrame[2] = rootTexture.source.width * resolution;
        globalFrame[3] = rootTexture.source.height * resolution;
        const renderSurface = this.renderer.renderTarget.getRenderTarget(output);
        outputTexture[0] = renderSurface.colorTexture.frameWidth;
        outputTexture[1] = renderSurface.colorTexture.frameHeight;
        outputTexture[2] = renderSurface.isRoot ? -1 : 1;
        filterUniforms.update();
        if (renderer.renderPipes.uniformBatch) {
          const batchUniforms = renderer.renderPipes.uniformBatch.getUniformBufferResource(this._filterGlobalUniforms);
          this._globalFilterBindGroup.setResource(batchUniforms, 0);
        } else {
          this._globalFilterBindGroup.setResource(filterUniforms, 0);
        }
        this._globalFilterBindGroup.setResource(input.source, 1);
        this._globalFilterBindGroup.setResource(input.source.style, 2);
        renderer.renderTarget.bind(output, !!clear);
        filter.groups[0] = this._globalFilterBindGroup;
        renderer.encoder.draw({
          geometry: quadGeometry,
          shader: filter,
          state: filter._state,
          topology: "triangle-list"
        });
      }
      _getFilterData() {
        return {
          skip: false,
          inputTexture: null,
          bounds: new Bounds(),
          container: null,
          filterEffect: null,
          blendRequired: false,
          previousRenderSurface: null
        };
      }
      /**
       * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.
       *
       * Use `outputMatrix * vTextureCoord` in the shader.
       * @param outputMatrix - The matrix to output to.
       * @param {Sprite} sprite - The sprite to map to.
       * @returns The mapped matrix.
       */
      calculateSpriteMatrix(outputMatrix, sprite) {
        const data = this._activeFilterData;
        const mappedMatrix = outputMatrix.set(
          data.inputTexture._source.width,
          0,
          0,
          data.inputTexture._source.height,
          data.bounds.minX,
          data.bounds.minY
        );
        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);
        worldTransform.invert();
        mappedMatrix.prepend(worldTransform);
        mappedMatrix.scale(1 / sprite.texture.frameWidth, 1 / sprite.texture.frameHeight);
        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
        return mappedMatrix;
      }
    };
    FilterSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "filter"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs
function executeInstructions(layerGroup, renderer) {
  const instructionSet = layerGroup.instructionSet;
  const instructions = instructionSet.instructions;
  for (let i3 = 0; i3 < instructionSet.instructionSize; i3++) {
    const instruction = instructions[i3];
    renderer[instruction.type].execute(instruction);
  }
}
var init_executeInstructions = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/LayerPipe.mjs
var LayerPipe;
var init_LayerPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/LayerPipe.mjs"() {
    init_Extensions();
    init_executeInstructions();
    LayerPipe = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      addLayerGroup(layerGroup, instructionSet) {
        this._renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add(layerGroup);
      }
      execute(layerGroup) {
        if (!layerGroup.isRenderable)
          return;
        this._renderer.globalUniforms.push({
          projectionData: this._renderer.renderTarget.renderTarget,
          worldTransformMatrix: layerGroup.worldTransform,
          worldColor: layerGroup.worldColor
        });
        executeInstructions(layerGroup, this._renderer.renderPipes);
        this._renderer.globalUniforms.pop();
      }
      destroy() {
        this._renderer = null;
      }
    };
    LayerPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "layer"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/LayerRenderable.mjs
var LayerRenderable;
var init_LayerRenderable = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/LayerRenderable.mjs"() {
    init_eventemitter3();
    init_Matrix();
    init_uid();
    LayerRenderable = class extends eventemitter3_default {
      constructor({ original, view }) {
        super();
        this.uid = uid("renderable");
        this.view = view;
        this._original = original;
        this.layerTransform = new Matrix();
        this.layerColor = 4294967295;
        this.layerVisibleRenderable = 3;
        this.view.owner = this;
      }
      get layerBlendMode() {
        return this._original.layerBlendMode;
      }
      onViewUpdate() {
        this.didViewUpdate = true;
        this._original.layerGroup.onChildViewUpdate(this);
      }
      get isRenderable() {
        return this._original.isRenderable;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/utils/buildInstructions.mjs
function buildInstructions(layerGroup, renderPipes3) {
  const root = layerGroup.root;
  const instructionSet = layerGroup.instructionSet;
  instructionSet.reset();
  renderPipes3.batch.buildStart(instructionSet);
  renderPipes3.blendMode.buildStart();
  renderPipes3.colorMask.buildStart();
  if (root.sortableChildren) {
    root.sortChildren();
  }
  collectAllRenderablesAdvanced(root, instructionSet, renderPipes3, true);
  renderPipes3.batch.buildEnd(instructionSet);
  renderPipes3.blendMode.buildEnd(instructionSet);
}
function collectAllRenderables(container, instructionSet, rendererPipes) {
  if (container.layerVisibleRenderable < 3 || !container.includeInBuild)
    return;
  if (container.sortableChildren) {
    container.sortChildren();
  }
  if (container.isSimple) {
    collectAllRenderablesSimple(container, instructionSet, rendererPipes);
  } else {
    collectAllRenderablesAdvanced(container, instructionSet, rendererPipes, false);
  }
}
function collectAllRenderablesSimple(container, instructionSet, renderPipes3) {
  const view = container.view;
  if (view) {
    renderPipes3.blendMode.setBlendMode(container, container.layerBlendMode, instructionSet);
    container.didViewUpdate = false;
    const rp = renderPipes3;
    rp[view.renderPipeId].addRenderable(container, instructionSet);
  }
  if (!container.isLayerRoot) {
    const children = container.children;
    const length = children.length;
    for (let i3 = 0; i3 < length; i3++) {
      collectAllRenderables(children[i3], instructionSet, renderPipes3);
    }
  }
}
function collectAllRenderablesAdvanced(container, instructionSet, renderPipes3, isRoot) {
  if (isRoot) {
    const layerGroup = container.layerGroup;
    if (layerGroup.root.view) {
      const proxyRenderable = layerGroup.proxyRenderable ?? initProxyRenderable(layerGroup);
      if (proxyRenderable) {
        renderPipes3.blendMode.setBlendMode(proxyRenderable, proxyRenderable.layerBlendMode, instructionSet);
        renderPipes3[proxyRenderable.view.renderPipeId].addRenderable(proxyRenderable, instructionSet);
      }
    }
  } else {
    for (let i3 = 0; i3 < container.effects.length; i3++) {
      const effect = container.effects[i3];
      const pipe = renderPipes3[effect.pipe];
      pipe.push(effect, container, instructionSet);
    }
  }
  if (!isRoot && container.isLayerRoot) {
    renderPipes3.layer.addLayerGroup(container.layerGroup, instructionSet);
  } else {
    const view = container.view;
    if (view) {
      renderPipes3.blendMode.setBlendMode(container, container.layerBlendMode, instructionSet);
      container.didViewUpdate = false;
      const pipe = renderPipes3[view.renderPipeId];
      pipe.addRenderable(container, instructionSet);
    }
    const children = container.children;
    if (children.length) {
      for (let i3 = 0; i3 < children.length; i3++) {
        collectAllRenderables(children[i3], instructionSet, renderPipes3);
      }
    }
  }
  if (!isRoot) {
    for (let i3 = container.effects.length - 1; i3 >= 0; i3--) {
      const effect = container.effects[i3];
      const pipe = renderPipes3[effect.pipe];
      pipe.pop(effect, container, instructionSet);
    }
  }
}
function initProxyRenderable(layerGroup) {
  const root = layerGroup.root;
  layerGroup.proxyRenderable = new LayerRenderable({
    original: root,
    view: root.view
  });
}
var init_buildInstructions = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/utils/buildInstructions.mjs"() {
    init_LayerRenderable();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/utils/collectLayerGroups.mjs
function collectLayerGroups(renderGroup, out3 = []) {
  out3.push(renderGroup);
  for (let i3 = 0; i3 < renderGroup.layerGroupChildren.length; i3++) {
    collectLayerGroups(renderGroup.layerGroupChildren[i3], out3);
  }
  return out3;
}
var init_collectLayerGroups = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/utils/collectLayerGroups.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs
function mixHexColors(color1, color2, ratio) {
  const r1 = color1 >> 16 & 255;
  const g1 = color1 >> 8 & 255;
  const b1 = color1 & 255;
  const r2 = color2 >> 16 & 255;
  const g2 = color2 >> 8 & 255;
  const b2 = color2 & 255;
  const r3 = r1 + (r2 - r1) * ratio;
  const g3 = g1 + (g2 - g1) * ratio;
  const b3 = b1 + (b2 - b1) * ratio;
  return (r3 << 16) + (g3 << 8) + b3;
}
var init_mixHexColors = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/utils/mixColors.mjs
function mixColors(localColor, parentColor) {
  const localAlpha = (localColor >> 24 & 255) / 255;
  const parentAlpha = (parentColor >> 24 & 255) / 255;
  const globalAlpha = localAlpha * parentAlpha * 255;
  const localBGRColor = localColor & 16777215;
  const parentBGRColor = parentColor & 16777215;
  let sharedBGRColor = 16777215;
  if (localBGRColor + (parentBGRColor << 32) !== WHITE_WHITE) {
    if (localBGRColor === 16777215) {
      sharedBGRColor = parentBGRColor;
    } else if (parentBGRColor === 16777215) {
      sharedBGRColor = localBGRColor;
    } else {
      sharedBGRColor = mixHexColors(localBGRColor, parentBGRColor, 0.5);
    }
  }
  return sharedBGRColor + (globalAlpha << 24);
}
var WHITE_WHITE;
var init_mixColors = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/utils/mixColors.mjs"() {
    init_mixHexColors();
    WHITE_WHITE = 16777215 + (16777215 << 32);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/utils/updateLayerGroupTransforms.mjs
function updateLayerGroupTransforms(layerGroup, updateChildRenderGroups = false) {
  updateLayerTransform(layerGroup);
  const childrenToUpdate = layerGroup.childrenToUpdate;
  const updateTick = layerGroup.updateTick;
  layerGroup.updateTick++;
  for (const j3 in childrenToUpdate) {
    const childrenAtDepth = childrenToUpdate[j3];
    const list = childrenAtDepth.list;
    const index = childrenAtDepth.index;
    for (let i3 = 0; i3 < index; i3++) {
      updateTransformAndChildren(list[i3], updateTick, 0);
    }
    childrenAtDepth.index = 0;
  }
  if (updateChildRenderGroups) {
    for (let i3 = 0; i3 < layerGroup.layerGroupChildren.length; i3++) {
      updateLayerGroupTransforms(layerGroup.layerGroupChildren[i3], updateChildRenderGroups);
    }
  }
}
function updateLayerTransform(layerGroup) {
  if (layerGroup.layerGroupParent) {
    layerGroup.worldTransform.appendFrom(
      layerGroup.root.layerTransform,
      layerGroup.layerGroupParent.worldTransform
    );
    layerGroup.worldColor = mixColors(
      layerGroup.root.layerColor,
      layerGroup.layerGroupParent.worldColor
    );
  } else {
    layerGroup.worldTransform.copyFrom(layerGroup.root.layerTransform);
    layerGroup.worldColor = layerGroup.root.localColor;
  }
}
function updateTransformAndChildren(container, updateTick, updateFlags) {
  if (updateTick === container.updateTick)
    return;
  container.updateTick = updateTick;
  container.didChange = false;
  const localTransform = container.localTransform;
  updateLocalTransform(localTransform, container);
  const parent = container.parent;
  if (parent && !parent.isLayerRoot) {
    updateFlags = updateFlags | container._updateFlags;
    container.layerTransform.appendFrom(
      localTransform,
      parent.layerTransform
    );
    if (updateFlags) {
      updateColorBlendVisibility(container, parent, updateFlags);
    }
  } else {
    updateFlags = container._updateFlags;
    container.layerTransform.copyFrom(localTransform);
    if (updateFlags) {
      updateColorBlendVisibility(container, tempContainer, updateFlags);
    }
  }
  if (!container.isLayerRoot) {
    const children = container.children;
    const length = children.length;
    for (let i3 = 0; i3 < length; i3++) {
      updateTransformAndChildren(children[i3], updateTick, updateFlags);
    }
    const layerGroup = container.layerGroup;
    if (container.view && !layerGroup.structureDidChange) {
      layerGroup.updateRenderable(container);
    }
  }
}
function updateColorBlendVisibility(container, parent, updateFlags) {
  if (updateFlags & UPDATE_COLOR) {
    container.layerColor = mixColors(container.localColor, parent.layerColor);
  }
  if (updateFlags & UPDATE_BLEND) {
    container.layerBlendMode = container.localBlendMode === "inherit" ? parent.layerBlendMode : container.localBlendMode;
  }
  if (updateFlags & UPDATE_VISIBLE) {
    container.layerVisibleRenderable = container.localVisibleRenderable & parent.layerVisibleRenderable;
  }
  container._updateFlags = 0;
}
var tempContainer;
var init_updateLayerGroupTransforms = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/utils/updateLayerGroupTransforms.mjs"() {
    init_Container();
    init_mixColors();
    init_updateLocalTransform();
    tempContainer = new Container();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs
function validateRenderables(layerGroup, renderPipes3) {
  const { list, index } = layerGroup.childrenRenderablesToUpdate;
  let rebuildRequired = false;
  for (let i3 = 0; i3 < index; i3++) {
    const container = list[i3];
    const renderable = container.view;
    const pipe = renderPipes3[renderable.renderPipeId];
    rebuildRequired = pipe.validateRenderable(container);
    if (rebuildRequired) {
      break;
    }
  }
  layerGroup.structureDidChange = rebuildRequired;
  if (rebuildRequired) {
    layerGroup.childrenRenderablesToUpdate.index = 0;
  }
  return rebuildRequired;
}
var init_validateRenderables = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/LayerSystem.mjs
function updateRenderables(layerGroup) {
  const { list, index } = layerGroup.childrenRenderablesToUpdate;
  for (let i3 = 0; i3 < index; i3++) {
    const container = list[i3];
    if (container.didViewUpdate) {
      layerGroup.updateRenderable(container);
    }
  }
  layerGroup.childrenRenderablesToUpdate.index = 0;
}
var LayerSystem;
var init_LayerSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/container/LayerSystem.mjs"() {
    init_Extensions();
    init_buildInstructions();
    init_collectLayerGroups();
    init_executeInstructions();
    init_updateLayerGroupTransforms();
    init_validateRenderables();
    LayerSystem = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      render({ container, transform }) {
        container.layer = true;
        const renderer = this._renderer;
        const layerGroups = collectLayerGroups(container.layerGroup, []);
        const renderPipes3 = renderer.renderPipes;
        for (let i3 = 0; i3 < layerGroups.length; i3++) {
          const layerGroup = layerGroups[i3];
          layerGroup.runOnRender();
          layerGroup.instructionSet.renderPipes = renderPipes3;
          if (!layerGroup.structureDidChange) {
            validateRenderables(layerGroup, renderPipes3);
          }
          updateLayerGroupTransforms(layerGroup);
          if (layerGroup.structureDidChange) {
            layerGroup.structureDidChange = false;
            buildInstructions(layerGroup, renderPipes3);
          } else {
            updateRenderables(layerGroup);
          }
          renderer.renderPipes.batch.upload(layerGroup.instructionSet);
        }
        if (transform) {
          container.layerGroup.worldTransform.copyFrom(transform);
        }
        renderer.globalUniforms.start(
          {
            projectionData: renderer.renderTarget.rootRenderTarget,
            worldTransformMatrix: container.layerGroup.worldTransform
          }
        );
        executeInstructions(container.layerGroup, renderPipes3);
        if (renderPipes3.uniformBatch) {
          renderPipes3.uniformBatch.renderEnd();
          renderPipes3.uniformBuffer.renderEnd();
        }
      }
      destroy() {
        const writeable = this;
        writeable._renderer = null;
      }
    };
    LayerSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "layer"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/batcher/gpu/BatchGeometry.mjs
var placeHolderBufferData, placeHolderIndexData, BatchGeometry;
var init_BatchGeometry = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/batcher/gpu/BatchGeometry.mjs"() {
    init_Buffer();
    init_const5();
    init_Geometry();
    placeHolderBufferData = new Float32Array(1);
    placeHolderIndexData = new Uint32Array(1);
    BatchGeometry = class extends Geometry {
      constructor() {
        const vertexSize = 6;
        const attributeBuffer = new Buffer2({
          data: placeHolderBufferData,
          label: "attribute-batch-buffer",
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
        });
        const indexBuffer = new Buffer2({
          data: placeHolderIndexData,
          label: "index-batch-buffer",
          usage: BufferUsage.INDEX | BufferUsage.COPY_DST
          // | BufferUsage.STATIC,
        });
        const stride = vertexSize * 4;
        super({
          attributes: {
            aPosition: {
              buffer: attributeBuffer,
              shaderLocation: 0,
              format: "float32x2",
              stride,
              offset: 0
            },
            aUV: {
              buffer: attributeBuffer,
              shaderLocation: 1,
              format: "float32x2",
              stride,
              offset: 2 * 4
            },
            aColor: {
              buffer: attributeBuffer,
              shaderLocation: 2,
              format: "unorm8x4",
              stride,
              offset: 4 * 4
            },
            aTextureIdAndRound: {
              buffer: attributeBuffer,
              shaderLocation: 3,
              format: "uint16x2",
              stride,
              offset: 5 * 4
            }
          },
          indexBuffer
        });
      }
      reset() {
        this.indexBuffer.data = placeHolderIndexData;
        this.buffers[0].data = placeHolderBufferData;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/ViewableBuffer.mjs
var ViewableBuffer;
var init_ViewableBuffer = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/ViewableBuffer.mjs"() {
    ViewableBuffer = class {
      constructor(sizeOrBuffer) {
        if (typeof sizeOrBuffer === "number") {
          this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
        } else if (sizeOrBuffer instanceof Uint8Array) {
          this.rawBinaryData = sizeOrBuffer.buffer;
        } else {
          this.rawBinaryData = sizeOrBuffer;
        }
        this.uint32View = new Uint32Array(this.rawBinaryData);
        this.float32View = new Float32Array(this.rawBinaryData);
        this.size = this.rawBinaryData.byteLength;
      }
      /** View on the raw binary data as a `Int8Array`. */
      get int8View() {
        if (!this._int8View) {
          this._int8View = new Int8Array(this.rawBinaryData);
        }
        return this._int8View;
      }
      /** View on the raw binary data as a `Uint8Array`. */
      get uint8View() {
        if (!this._uint8View) {
          this._uint8View = new Uint8Array(this.rawBinaryData);
        }
        return this._uint8View;
      }
      /**  View on the raw binary data as a `Int16Array`. */
      get int16View() {
        if (!this._int16View) {
          this._int16View = new Int16Array(this.rawBinaryData);
        }
        return this._int16View;
      }
      /** View on the raw binary data as a `Int32Array`. */
      get int32View() {
        if (!this._int32View) {
          this._int32View = new Int32Array(this.rawBinaryData);
        }
        return this._int32View;
      }
      get float64View() {
        if (!this._float64Array) {
          this._float64Array = new Float64Array(this.rawBinaryData);
        }
        return this._float64Array;
      }
      get bigUint64View() {
        if (!this._bigUint64Array) {
          this._bigUint64Array = new BigUint64Array(this.rawBinaryData);
        }
        return this._bigUint64Array;
      }
      /**
       * Returns the view of the given type.
       * @param type - One of `int8`, `uint8`, `int16`,
       *    `uint16`, `int32`, `uint32`, and `float32`.
       * @returns - typed array of given type
       */
      view(type2) {
        return this[`${type2}View`];
      }
      /** Destroys all buffer references. Do not use after calling this. */
      destroy() {
        this.rawBinaryData = null;
        this._int8View = null;
        this._uint8View = null;
        this._int16View = null;
        this.uint16View = null;
        this._int32View = null;
        this.uint32View = null;
        this.float32View = null;
      }
      static sizeOf(type2) {
        switch (type2) {
          case "int8":
          case "uint8":
            return 1;
          case "int16":
          case "uint16":
            return 2;
          case "int32":
          case "uint32":
          case "float32":
            return 4;
          default:
            throw new Error(`${type2} isn't a valid view type`);
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs
function fastCopy(sourceBuffer, destinationBuffer) {
  const lengthDouble = sourceBuffer.byteLength / 8 | 0;
  const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);
  const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);
  for (let i3 = 0; i3 < lengthDouble; i3++) {
    destinationFloat64View[i3] = sourceFloat64View[i3];
  }
  const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8);
  const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8);
  for (let i3 = 0; i3 < sourceUint8View.length; i3++) {
    destinationUint8View[i3] = sourceUint8View[i3];
  }
}
var init_fastCopy = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs
var BatchTextureArray;
var init_BatchTextureArray = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs"() {
    BatchTextureArray = class {
      constructor() {
        this.ids = /* @__PURE__ */ Object.create(null);
        this.textures = [];
        this.count = 0;
      }
      clear() {
        for (let i3 = 0; i3 < this.count; i3++) {
          const t2 = this.textures[i3];
          this.textures[i3] = null;
          this.ids[t2.uid] = null;
        }
        this.count = 0;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs
var Batch, BATCH_TICK, Batcher;
var init_Batcher = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs"() {
    init_uid();
    init_ViewableBuffer();
    init_fastCopy();
    init_BatchTextureArray();
    init_const3();
    Batch = class {
      constructor() {
        this.type = "batch";
        this.action = "startBatch";
        this.start = 0;
        this.size = 0;
        this.blendMode = "normal";
        this.canBundle = true;
      }
      destroy() {
        this.textures = null;
        this.gpuBindGroup = null;
        this.bindGroup = null;
        this.batcher = null;
      }
    };
    BATCH_TICK = 0;
    Batcher = class {
      constructor(vertexSize = 4, indexSize = 6) {
        this.uid = uid("batcher");
        this.dirty = true;
        this.batchIndex = 0;
        this.batches = [];
        this._vertexSize = 6;
        this._elements = [];
        this._batchPool = [];
        this._batchPoolIndex = 0;
        this._textureBatchPool = [];
        this._textureBatchPoolIndex = 0;
        this.attributeBuffer = new ViewableBuffer(vertexSize * this._vertexSize * 4);
        this.indexBuffer = new Uint32Array(indexSize);
      }
      begin() {
        this.batchIndex = 0;
        this.elementSize = 0;
        this.elementStart = 0;
        this.indexSize = 0;
        this.attributeSize = 0;
        this._batchPoolIndex = 0;
        this._textureBatchPoolIndex = 0;
        this._batchIndexStart = 0;
        this._batchIndexSize = 0;
        this.dirty = true;
      }
      add(batchableObject) {
        this._elements[this.elementSize++] = batchableObject;
        batchableObject.indexStart = this.indexSize;
        batchableObject.location = this.attributeSize;
        batchableObject.batcher = this;
        this.indexSize += batchableObject.indexSize;
        this.attributeSize += batchableObject.vertexSize * this._vertexSize;
      }
      checkAndUpdateTexture(batchableObject, texture) {
        const textureId = batchableObject.batch.textures.ids[texture._source.uid];
        if (!textureId && textureId !== 0)
          return false;
        batchableObject.textureId = textureId;
        batchableObject.texture = texture;
        return true;
      }
      updateElement(batchableObject) {
        this.dirty = true;
        batchableObject.packAttributes(
          this.attributeBuffer.float32View,
          this.attributeBuffer.uint32View,
          batchableObject.location,
          batchableObject.textureId
        );
      }
      /**
       * breaks the batcher. This happens when a batch gets too big,
       * or we need to switch to a different type of rendering (a filter for example)
       * @param instructionSet
       */
      break(instructionSet) {
        const elements = this._elements;
        let textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();
        textureBatch.clear();
        if (!elements[this.elementStart])
          return;
        let blendMode = elements[this.elementStart].blendMode;
        if (this.attributeSize * 4 > this.attributeBuffer.size) {
          this._resizeAttributeBuffer(this.attributeSize * 4);
        }
        if (this.indexSize > this.indexBuffer.length) {
          this._resizeIndexBuffer(this.indexSize);
        }
        const f32 = this.attributeBuffer.float32View;
        const u32 = this.attributeBuffer.uint32View;
        const iBuffer = this.indexBuffer;
        let size3 = this._batchIndexSize;
        let start = this._batchIndexStart;
        let action = "startBatch";
        let batch = this._batchPool[this._batchPoolIndex++] || new Batch();
        for (let i3 = this.elementStart; i3 < this.elementSize; ++i3) {
          const element = elements[i3];
          elements[i3] = null;
          const texture = element.texture;
          const source3 = texture._source;
          const blendModeChange = blendMode !== element.blendMode;
          if (source3._batchTick === BATCH_TICK && !blendModeChange) {
            element.textureId = source3._textureBindLocation;
            size3 += element.indexSize;
            element.packAttributes(f32, u32, element.location, element.textureId);
            element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);
            element.batch = batch;
            continue;
          }
          source3._batchTick = BATCH_TICK;
          if (textureBatch.count >= MAX_TEXTURES || blendModeChange) {
            this._finishBatch(
              batch,
              start,
              size3 - start,
              textureBatch,
              blendMode,
              instructionSet,
              action
            );
            action = "renderBatch";
            start = size3;
            blendMode = element.blendMode;
            textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();
            textureBatch.clear();
            batch = this._batchPool[this._batchPoolIndex++] || new Batch();
            ++BATCH_TICK;
          }
          element.textureId = source3._textureBindLocation = textureBatch.count;
          textureBatch.ids[source3.uid] = textureBatch.count;
          textureBatch.textures[textureBatch.count++] = source3;
          element.batch = batch;
          size3 += element.indexSize;
          element.packAttributes(f32, u32, element.location, element.textureId);
          element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);
        }
        if (textureBatch.count > 0) {
          this._finishBatch(
            batch,
            start,
            size3 - start,
            textureBatch,
            blendMode,
            instructionSet,
            action
          );
          start = size3;
          ++BATCH_TICK;
        }
        this.elementStart = this.elementSize;
        this._batchIndexStart = start;
        this._batchIndexSize = size3;
      }
      _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {
        batch.gpuBindGroup = null;
        batch.action = action;
        batch.batcher = this;
        batch.textures = textureBatch;
        batch.blendMode = blendMode;
        batch.start = indexStart;
        batch.size = indexSize;
        ++BATCH_TICK;
        instructionSet.add(batch);
      }
      finish(instructionSet) {
        this.break(instructionSet);
      }
      ensureAttributeBuffer(size3) {
        if (size3 * 4 < this.attributeBuffer.size)
          return;
        this._resizeAttributeBuffer(size3 * 4);
      }
      ensureIndexBuffer(size3) {
        if (size3 < this.indexBuffer.length)
          return;
        this._resizeIndexBuffer(size3);
      }
      _resizeAttributeBuffer(size3) {
        const newSize = Math.max(size3, this.attributeBuffer.size * 2);
        const newArrayBuffer = new ViewableBuffer(newSize);
        fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);
        this.attributeBuffer = newArrayBuffer;
      }
      _resizeIndexBuffer(size3) {
        const indexBuffer = this.indexBuffer;
        const newSize = Math.max(size3, indexBuffer.length * 2);
        const newIndexBuffer = new Uint32Array(newSize);
        fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);
        this.indexBuffer = newIndexBuffer;
      }
      destroy() {
        for (let i3 = 0; i3 < this.batches.length; i3++) {
          this.batches[i3].destroy();
        }
        this.batches = null;
        for (let i3 = 0; i3 < this._elements.length; i3++) {
          this._elements[i3].batch = null;
        }
        this._elements = null;
        this.indexBuffer = null;
        this.attributeBuffer.destroy();
        this.attributeBuffer = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs
function buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size3, matrix = null) {
  let index = 0;
  verticesOffset *= verticesStride;
  uvsOffset *= uvsStride;
  const a2 = matrix.a;
  const b2 = matrix.b;
  const c2 = matrix.c;
  const d3 = matrix.d;
  const tx = matrix.tx;
  const ty = matrix.ty;
  while (index < size3) {
    const x3 = vertices[verticesOffset];
    const y2 = vertices[verticesOffset + 1];
    uvs[uvsOffset] = a2 * x3 + c2 * y2 + tx;
    uvs[uvsOffset + 1] = b2 * x3 + d3 * y2 + ty;
    uvsOffset += uvsStride;
    verticesOffset += verticesStride;
    index++;
  }
}
function buildSimpleUvs(uvs, uvsOffset, uvsStride, size3) {
  let index = 0;
  uvsOffset *= uvsStride;
  while (index < size3) {
    uvs[uvsOffset] = 0;
    uvs[uvsOffset + 1] = 0;
    uvsOffset += uvsStride;
    index++;
  }
}
var init_buildUvs = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs
function transformVertices(vertices, m3, offset, stride, size3) {
  const a2 = m3.a;
  const b2 = m3.b;
  const c2 = m3.c;
  const d3 = m3.d;
  const tx = m3.tx;
  const ty = m3.ty;
  offset = offset || 0;
  stride = stride || 2;
  size3 = size3 || vertices.length / stride - offset;
  let index = offset * stride;
  for (let i3 = 0; i3 < size3; i3++) {
    const x3 = vertices[index];
    const y2 = vertices[index + 1];
    vertices[index] = a2 * x3 + c2 * y2 + tx;
    vertices[index + 1] = b2 * x3 + d3 * y2 + ty;
    index += stride;
  }
}
var init_transformVertices = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs
var BatchableGraphics;
var init_BatchableGraphics = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs"() {
    init_mixColors();
    BatchableGraphics = class {
      constructor() {
        this.batcher = null;
        this.batch = null;
        this.applyTransform = true;
        this.roundPixels = 0;
      }
      get blendMode() {
        if (this.applyTransform) {
          return this.renderable.layerBlendMode;
        }
        return "normal";
      }
      packIndex(indexBuffer, index, indicesOffset) {
        const indices = this.geometryData.indices;
        for (let i3 = 0; i3 < this.indexSize; i3++) {
          indexBuffer[index++] = indices[i3 + this.indexOffset] + indicesOffset - this.vertexOffset;
        }
      }
      packAttributes(float32View, uint32View, index, textureId) {
        const geometry = this.geometryData;
        const graphics = this.renderable;
        const positions = geometry.vertices;
        const uvs = geometry.uvs;
        const offset = this.vertexOffset * 2;
        const vertSize = (this.vertexOffset + this.vertexSize) * 2;
        const rgb = this.color;
        const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;
        if (this.applyTransform) {
          const argb = mixColors(bgr + (this.alpha * 255 << 24), graphics.layerColor);
          const wt = graphics.layerTransform;
          const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;
          const a2 = wt.a;
          const b2 = wt.b;
          const c2 = wt.c;
          const d3 = wt.d;
          const tx = wt.tx;
          const ty = wt.ty;
          for (let i3 = offset; i3 < vertSize; i3 += 2) {
            const x3 = positions[i3];
            const y2 = positions[i3 + 1];
            float32View[index] = a2 * x3 + c2 * y2 + tx;
            float32View[index + 1] = b2 * x3 + d3 * y2 + ty;
            float32View[index + 2] = uvs[i3];
            float32View[index + 3] = uvs[i3 + 1];
            uint32View[index + 4] = argb;
            uint32View[index + 5] = textureIdAndRound;
            index += 6;
          }
        } else {
          const argb = bgr + (this.alpha * 255 << 24);
          for (let i3 = offset; i3 < vertSize; i3 += 2) {
            float32View[index] = positions[i3];
            float32View[index + 1] = positions[i3 + 1];
            float32View[index + 2] = uvs[i3];
            float32View[index + 3] = uvs[i3 + 1];
            uint32View[index + 4] = argb;
            uint32View[index + 5] = textureId;
            index += 6;
          }
        }
      }
      // TODO rename to vertexSize
      get vertSize() {
        return this.vertexSize;
      }
      copyTo(gpuBuffer) {
        gpuBuffer.indexOffset = this.indexOffset;
        gpuBuffer.indexSize = this.indexSize;
        gpuBuffer.vertexOffset = this.vertexOffset;
        gpuBuffer.vertexSize = this.vertexSize;
        gpuBuffer.color = this.color;
        gpuBuffer.alpha = this.alpha;
        gpuBuffer.texture = this.texture;
        gpuBuffer.geometryData = this.geometryData;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs
var buildCircle;
var init_buildCircle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs"() {
    buildCircle = {
      build(shape, points) {
        let x3;
        let y2;
        let dx;
        let dy;
        let rx;
        let ry;
        if (shape.type === "circle") {
          const circle = shape;
          x3 = circle.x;
          y2 = circle.y;
          rx = ry = circle.radius;
          dx = dy = 0;
        } else if (shape.type === "ellipse") {
          const ellipse = shape;
          x3 = ellipse.x;
          y2 = ellipse.y;
          rx = ellipse.halfWidth;
          ry = ellipse.halfHeight;
          dx = dy = 0;
        } else {
          const roundedRect = shape;
          const halfWidth = roundedRect.width / 2;
          const halfHeight = roundedRect.height / 2;
          x3 = roundedRect.x + halfWidth;
          y2 = roundedRect.y + halfHeight;
          rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
          dx = halfWidth - rx;
          dy = halfHeight - ry;
        }
        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
          return points;
        }
        const n2 = Math.ceil(2.3 * Math.sqrt(rx + ry));
        const m3 = n2 * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
        if (m3 === 0) {
          return points;
        }
        if (n2 === 0) {
          points[0] = points[6] = x3 + dx;
          points[1] = points[3] = y2 + dy;
          points[2] = points[4] = x3 - dx;
          points[5] = points[7] = y2 - dy;
          return points;
        }
        let j1 = 0;
        let j22 = n2 * 4 + (dx ? 2 : 0) + 2;
        let j3 = j22;
        let j4 = m3;
        let x0 = dx + rx;
        let y0 = dy;
        let x1 = x3 + x0;
        let x22 = x3 - x0;
        let y1 = y2 + y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j22] = y1;
        points[--j22] = x22;
        if (dy) {
          const y222 = y2 - y0;
          points[j3++] = x22;
          points[j3++] = y222;
          points[--j4] = y222;
          points[--j4] = x1;
        }
        for (let i3 = 1; i3 < n2; i3++) {
          const a2 = Math.PI / 2 * (i3 / n2);
          const x02 = dx + Math.cos(a2) * rx;
          const y02 = dy + Math.sin(a2) * ry;
          const x12 = x3 + x02;
          const x222 = x3 - x02;
          const y12 = y2 + y02;
          const y222 = y2 - y02;
          points[j1++] = x12;
          points[j1++] = y12;
          points[--j22] = y12;
          points[--j22] = x222;
          points[j3++] = x222;
          points[j3++] = y222;
          points[--j4] = y222;
          points[--j4] = x12;
        }
        x0 = dx;
        y0 = dy + ry;
        x1 = x3 + x0;
        x22 = x3 - x0;
        y1 = y2 + y0;
        const y22 = y2 - y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j4] = y22;
        points[--j4] = x1;
        if (dx) {
          points[j1++] = x22;
          points[j1++] = y1;
          points[--j4] = y22;
          points[--j4] = x22;
        }
        return points;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        if (points.length === 0) {
          return;
        }
        let x3 = 0;
        let y2 = 0;
        const div = points.length / 4;
        x3 += points[0];
        y2 += points[1];
        x3 += points[div | 0];
        y2 += points[(div | 0) + 1];
        x3 += points[div * 2 | 0];
        y2 += points[(div * 2 | 0) + 1];
        x3 += points[div * 3 | 0];
        y2 += points[(div * 3 | 0) + 1];
        x3 /= 4;
        y2 /= 4;
        let count2 = verticesOffset;
        vertices[count2 * verticesStride] = x3;
        vertices[count2 * verticesStride + 1] = y2;
        count2++;
        const center = verticesOffset;
        vertices[count2 * verticesStride] = points[0];
        vertices[count2 * verticesStride + 1] = points[1];
        count2++;
        for (let i3 = 2; i3 < points.length; i3 += 2) {
          vertices[count2 * verticesStride] = points[i3];
          vertices[count2 * verticesStride + 1] = points[i3 + 1];
          indices[indicesOffset++] = count2;
          indices[indicesOffset++] = center;
          indices[indicesOffset++] = count2 - 1;
          count2++;
        }
        indices[indicesOffset++] = count2 - 1;
        indices[indicesOffset++] = center;
        indices[indicesOffset++] = center + 1;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/const.mjs
var closePointEps, curveEps;
var init_const6 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/const.mjs"() {
    closePointEps = 1e-4;
    curveEps = 1e-4;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs
function getOrientationOfPoints(points) {
  const m3 = points.length;
  if (m3 < 6) {
    return 1;
  }
  let area = 0;
  for (let i3 = 0, x1 = points[m3 - 2], y1 = points[m3 - 1]; i3 < m3; i3 += 2) {
    const x22 = points[i3];
    const y2 = points[i3 + 1];
    area += (x22 - x1) * (y2 + y1);
    x1 = x22;
    y1 = y2;
  }
  if (area < 0) {
    return -1;
  }
  return 1;
}
var init_getOrientationOfPoints = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs
function square(x3, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  const ix = x3 - nx * innerWeight;
  const iy = y2 - ny * innerWeight;
  const ox = x3 + nx * outerWeight;
  const oy = y2 + ny * outerWeight;
  let exx;
  let eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  const eix = ix + exx;
  const eiy = iy + eyy;
  const eox = ox + exx;
  const eoy = oy + eyy;
  verts.push(eix, eiy);
  verts.push(eox, eoy);
  return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  const cx2p0x = sx - cx;
  const cy2p0y = sy - cy;
  let angle0 = Math.atan2(cx2p0x, cy2p0y);
  let angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  let startAngle = angle0;
  const angleDiff = angle1 - angle0;
  const absAngleDiff = Math.abs(angleDiff);
  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  const angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy);
    verts.push(sx, sy);
    for (let i3 = 1, angle = startAngle; i3 < segCount; i3++, angle += angleInc) {
      verts.push(cx, cy);
      verts.push(
        cx + Math.sin(angle) * radius,
        cy + Math.cos(angle) * radius
      );
    }
    verts.push(cx, cy);
    verts.push(ex, ey);
  } else {
    verts.push(sx, sy);
    verts.push(cx, cy);
    for (let i3 = 1, angle = startAngle; i3 < segCount; i3++, angle += angleInc) {
      verts.push(
        cx + Math.sin(angle) * radius,
        cy + Math.cos(angle) * radius
      );
      verts.push(cx, cy);
    }
    verts.push(ex, ey);
    verts.push(cx, cy);
  }
  return segCount * 2;
}
function buildLine(points, lineStyle, flipAlignment, closed, vertices, _verticesStride, _verticesOffset, indices, _indicesOffset) {
  const eps = closePointEps;
  if (points.length === 0) {
    return;
  }
  const style = lineStyle;
  let alignment = style.alignment;
  if (lineStyle.alignment !== 0.5) {
    let orientation = getOrientationOfPoints(points);
    if (flipAlignment)
      orientation *= -1;
    alignment = (alignment - 0.5) * orientation + 0.5;
  }
  const firstPoint = new Point(points[0], points[1]);
  const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
  const closedShape = closed;
  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  const verts = vertices;
  const length = points.length / 2;
  let indexCount = points.length;
  const indexStart = verts.length / 2;
  const width = style.width / 2;
  const widthSquared = width * width;
  const miterLimitSquared = style.miterLimit * style.miterLimit;
  let x0 = points[0];
  let y0 = points[1];
  let x1 = points[2];
  let y1 = points[3];
  let x22 = 0;
  let y2 = 0;
  let perpX = -(y0 - y1);
  let perpY = x0 - x1;
  let perp1x = 0;
  let perp1y = 0;
  let dist = Math.sqrt(perpX * perpX + perpY * perpY);
  perpX /= dist;
  perpY /= dist;
  perpX *= width;
  perpY *= width;
  const ratio = alignment;
  const innerWeight = (1 - ratio) * 2;
  const outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === "round") {
      indexCount += round(
        x0 - perpX * (innerWeight - outerWeight) * 0.5,
        y0 - perpY * (innerWeight - outerWeight) * 0.5,
        x0 - perpX * innerWeight,
        y0 - perpY * innerWeight,
        x0 + perpX * outerWeight,
        y0 + perpY * outerWeight,
        verts,
        true
      ) + 2;
    } else if (style.cap === "square") {
      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(
    x0 - perpX * innerWeight,
    y0 - perpY * innerWeight
  );
  verts.push(
    x0 + perpX * outerWeight,
    y0 + perpY * outerWeight
  );
  for (let i3 = 1; i3 < length - 1; ++i3) {
    x0 = points[(i3 - 1) * 2];
    y0 = points[(i3 - 1) * 2 + 1];
    x1 = points[i3 * 2];
    y1 = points[i3 * 2 + 1];
    x22 = points[(i3 + 1) * 2];
    y2 = points[(i3 + 1) * 2 + 1];
    perpX = -(y0 - y1);
    perpY = x0 - x1;
    dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    perp1x = -(y1 - y2);
    perp1y = x1 - x22;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    const dx0 = x1 - x0;
    const dy0 = y0 - y1;
    const dx1 = x1 - x22;
    const dy1 = y2 - y1;
    const dot = dx0 * dx1 + dy0 * dy1;
    const cross = dy0 * dx1 - dy1 * dx0;
    const clockwise = cross < 0;
    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
      verts.push(
        x1 - perpX * innerWeight,
        y1 - perpY * innerWeight
      );
      verts.push(
        x1 + perpX * outerWeight,
        y1 + perpY * outerWeight
      );
      if (dot >= 0) {
        if (style.join === "round") {
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 4;
        } else {
          indexCount += 2;
        }
        verts.push(
          x1 - perp1x * outerWeight,
          y1 - perp1y * outerWeight
        );
        verts.push(
          x1 + perp1x * innerWeight,
          y1 + perp1y * innerWeight
        );
      }
      continue;
    }
    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);
    const c2 = (-perp1x + x22) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
    const px = (dx0 * c2 - dx1 * c1) / cross;
    const py = (dy1 * c1 - dy0 * c2) / cross;
    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    const imx = x1 + (px - x1) * innerWeight;
    const imy = y1 + (py - y1) * innerWeight;
    const omx = x1 - (px - x1) * outerWeight;
    const omy = y1 - (py - y1) * outerWeight;
    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    const insideWeight = clockwise ? innerWeight : outerWeight;
    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    const insideMiterOk = pDist <= smallerInsideDiagonalSq;
    if (insideMiterOk) {
      if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
          verts.push(omx, omy);
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
        indexCount += 2;
      } else if (style.join === "round") {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
          indexCount += round(
            x1,
            y1,
            x1 + perpX * outerWeight,
            y1 + perpY * outerWeight,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight,
            verts,
            true
          ) + 4;
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
          verts.push(omx, omy);
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 4;
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
      } else {
        verts.push(imx, imy);
        verts.push(omx, omy);
      }
    } else {
      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
      if (style.join === "round") {
        if (clockwise) {
          indexCount += round(
            x1,
            y1,
            x1 + perpX * outerWeight,
            y1 + perpY * outerWeight,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight,
            verts,
            true
          ) + 2;
        } else {
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 2;
        }
      } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {
        if (clockwise) {
          verts.push(omx, omy);
          verts.push(omx, omy);
        } else {
          verts.push(imx, imy);
          verts.push(imx, imy);
        }
        indexCount += 2;
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length - 2) * 2];
  y0 = points[(length - 2) * 2 + 1];
  x1 = points[(length - 1) * 2];
  y1 = points[(length - 1) * 2 + 1];
  perpX = -(y0 - y1);
  perpY = x0 - x1;
  dist = Math.sqrt(perpX * perpX + perpY * perpY);
  perpX /= dist;
  perpY /= dist;
  perpX *= width;
  perpY *= width;
  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
  if (!closedShape) {
    if (style.cap === "round") {
      indexCount += round(
        x1 - perpX * (innerWeight - outerWeight) * 0.5,
        y1 - perpY * (innerWeight - outerWeight) * 0.5,
        x1 - perpX * innerWeight,
        y1 - perpY * innerWeight,
        x1 + perpX * outerWeight,
        y1 + perpY * outerWeight,
        verts,
        false
      ) + 2;
    } else if (style.cap === "square") {
      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);
    }
  }
  const eps2 = curveEps * curveEps;
  for (let i3 = indexStart; i3 < indexCount + indexStart - 2; ++i3) {
    x0 = verts[i3 * 2];
    y0 = verts[i3 * 2 + 1];
    x1 = verts[(i3 + 1) * 2];
    y1 = verts[(i3 + 1) * 2 + 1];
    x22 = verts[(i3 + 2) * 2];
    y2 = verts[(i3 + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x22 * (y0 - y1)) < eps2) {
      continue;
    }
    indices.push(i3, i3 + 1, i3 + 2);
  }
}
var init_buildLine = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs"() {
    init_Point();
    init_const6();
    init_getOrientationOfPoints();
  }
});

// ../../node_modules/.pnpm/earcut@2.2.4/node_modules/earcut/src/earcut.js
var require_earcut = __commonJS({
  "../../node_modules/.pnpm/earcut@2.2.4/node_modules/earcut/src/earcut.js"(exports2, module2) {
    "use strict";
    module2.exports = earcut2;
    module2.exports.default = earcut2;
    function earcut2(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev)
        return triangles;
      var minX, minY, maxX, maxY, x3, y2, invSize;
      if (hasHoles)
        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i3 = dim; i3 < outerLen; i3 += dim) {
          x3 = data[i3];
          y2 = data[i3 + 1];
          if (x3 < minX)
            minX = x3;
          if (y2 < minY)
            minY = y2;
          if (x3 > maxX)
            maxX = x3;
          if (y2 > maxY)
            maxY = y2;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
      return triangles;
    }
    function linkedList(data, start, end, dim, clockwise) {
      var i3, last;
      if (clockwise === signedArea(data, start, end, dim) > 0) {
        for (i3 = start; i3 < end; i3 += dim)
          last = insertNode(i3, data[i3], data[i3 + 1], last);
      } else {
        for (i3 = end - dim; i3 >= start; i3 -= dim)
          last = insertNode(i3, data[i3], data[i3 + 1], last);
      }
      if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints(start, end) {
      if (!start)
        return start;
      if (!end)
        end = start;
      var p3 = start, again;
      do {
        again = false;
        if (!p3.steiner && (equals(p3, p3.next) || area(p3.prev, p3, p3.next) === 0)) {
          removeNode(p3);
          p3 = end = p3.prev;
          if (p3 === p3.next)
            break;
          again = true;
        } else {
          p3 = p3.next;
        }
      } while (again || p3 !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear)
        return;
      if (!pass && invSize)
        indexCurve(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev.i / dim | 0);
          triangles.push(ear.i / dim | 0);
          triangles.push(next.i / dim | 0);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      var a2 = ear.prev, b2 = ear, c2 = ear.next;
      if (area(a2, b2, c2) >= 0)
        return false;
      var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var p3 = c2.next;
      while (p3 !== a2) {
        if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0)
          return false;
        p3 = p3.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      var a2 = ear.prev, b2 = ear, c2 = ear.next;
      if (area(a2, b2, c2) >= 0)
        return false;
      var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
      var p3 = ear.prevZ, n2 = ear.nextZ;
      while (p3 && p3.z >= minZ && n2 && n2.z <= maxZ) {
        if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && p3 !== a2 && p3 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0)
          return false;
        p3 = p3.prevZ;
        if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
          return false;
        n2 = n2.nextZ;
      }
      while (p3 && p3.z >= minZ) {
        if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && p3 !== a2 && p3 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0)
          return false;
        p3 = p3.prevZ;
      }
      while (n2 && n2.z <= maxZ) {
        if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
          return false;
        n2 = n2.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      var p3 = start;
      do {
        var a2 = p3.prev, b2 = p3.next.next;
        if (!equals(a2, b2) && intersects(a2, p3, p3.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
          triangles.push(a2.i / dim | 0);
          triangles.push(p3.i / dim | 0);
          triangles.push(b2.i / dim | 0);
          removeNode(p3);
          removeNode(p3.next);
          p3 = start = b2;
        }
        p3 = p3.next;
      } while (p3 !== start);
      return filterPoints(p3);
    }
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
      var a2 = start;
      do {
        var b2 = a2.next.next;
        while (b2 !== a2.prev) {
          if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
            var c2 = splitPolygon(a2, b2);
            a2 = filterPoints(a2, a2.next);
            c2 = filterPoints(c2, c2.next);
            earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
            earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
            return;
          }
          b2 = b2.next;
        }
        a2 = a2.next;
      } while (a2 !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [], i3, len, start, end, list;
      for (i3 = 0, len = holeIndices.length; i3 < len; i3++) {
        start = holeIndices[i3] * dim;
        end = i3 < len - 1 ? holeIndices[i3 + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next)
          list.steiner = true;
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i3 = 0; i3 < queue.length; i3++) {
        outerNode = eliminateHole(queue[i3], outerNode);
      }
      return outerNode;
    }
    function compareX(a2, b2) {
      return a2.x - b2.x;
    }
    function eliminateHole(hole, outerNode) {
      var bridge = findHoleBridge(hole, outerNode);
      if (!bridge) {
        return outerNode;
      }
      var bridgeReverse = splitPolygon(bridge, hole);
      filterPoints(bridgeReverse, bridgeReverse.next);
      return filterPoints(bridge, bridge.next);
    }
    function findHoleBridge(hole, outerNode) {
      var p3 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m3;
      do {
        if (hy <= p3.y && hy >= p3.next.y && p3.next.y !== p3.y) {
          var x3 = p3.x + (hy - p3.y) * (p3.next.x - p3.x) / (p3.next.y - p3.y);
          if (x3 <= hx && x3 > qx) {
            qx = x3;
            m3 = p3.x < p3.next.x ? p3 : p3.next;
            if (x3 === hx)
              return m3;
          }
        }
        p3 = p3.next;
      } while (p3 !== outerNode);
      if (!m3)
        return null;
      var stop = m3, mx = m3.x, my = m3.y, tanMin = Infinity, tan;
      p3 = m3;
      do {
        if (hx >= p3.x && p3.x >= mx && hx !== p3.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p3.x, p3.y)) {
          tan = Math.abs(hy - p3.y) / (hx - p3.x);
          if (locallyInside(p3, hole) && (tan < tanMin || tan === tanMin && (p3.x > m3.x || p3.x === m3.x && sectorContainsSector(m3, p3)))) {
            m3 = p3;
            tanMin = tan;
          }
        }
        p3 = p3.next;
      } while (p3 !== stop);
      return m3;
    }
    function sectorContainsSector(m3, p3) {
      return area(m3.prev, m3, p3.prev) < 0 && area(p3.next, m3, m3.next) < 0;
    }
    function indexCurve(start, minX, minY, invSize) {
      var p3 = start;
      do {
        if (p3.z === 0)
          p3.z = zOrder(p3.x, p3.y, minX, minY, invSize);
        p3.prevZ = p3.prev;
        p3.nextZ = p3.next;
        p3 = p3.next;
      } while (p3 !== start);
      p3.prevZ.nextZ = null;
      p3.prevZ = null;
      sortLinked(p3);
    }
    function sortLinked(list) {
      var i3, p3, q2, e3, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p3 = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p3) {
          numMerges++;
          q2 = p3;
          pSize = 0;
          for (i3 = 0; i3 < inSize; i3++) {
            pSize++;
            q2 = q2.nextZ;
            if (!q2)
              break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q2) {
            if (pSize !== 0 && (qSize === 0 || !q2 || p3.z <= q2.z)) {
              e3 = p3;
              p3 = p3.nextZ;
              pSize--;
            } else {
              e3 = q2;
              q2 = q2.nextZ;
              qSize--;
            }
            if (tail)
              tail.nextZ = e3;
            else
              list = e3;
            e3.prevZ = tail;
            tail = e3;
          }
          p3 = q2;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x3, y2, minX, minY, invSize) {
      x3 = (x3 - minX) * invSize | 0;
      y2 = (y2 - minY) * invSize | 0;
      x3 = (x3 | x3 << 8) & 16711935;
      x3 = (x3 | x3 << 4) & 252645135;
      x3 = (x3 | x3 << 2) & 858993459;
      x3 = (x3 | x3 << 1) & 1431655765;
      y2 = (y2 | y2 << 8) & 16711935;
      y2 = (y2 | y2 << 4) & 252645135;
      y2 = (y2 | y2 << 2) & 858993459;
      y2 = (y2 | y2 << 1) & 1431655765;
      return x3 | y2 << 1;
    }
    function getLeftmost(start) {
      var p3 = start, leftmost = start;
      do {
        if (p3.x < leftmost.x || p3.x === leftmost.x && p3.y < leftmost.y)
          leftmost = p3;
        p3 = p3.next;
      } while (p3 !== start);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }
    function isValidDiagonal(a2, b2) {
      return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && // dones't intersect other edges
      (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && // locally visible
      (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || // does not create opposite-facing sectors
      equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
    }
    function area(p3, q2, r2) {
      return (q2.y - p3.y) * (r2.x - q2.x) - (q2.x - p3.x) * (r2.y - q2.y);
    }
    function equals(p1, p22) {
      return p1.x === p22.x && p1.y === p22.y;
    }
    function intersects(p1, q1, p22, q2) {
      var o1 = sign2(area(p1, q1, p22));
      var o2 = sign2(area(p1, q1, q2));
      var o3 = sign2(area(p22, q2, p1));
      var o4 = sign2(area(p22, q2, q1));
      if (o1 !== o2 && o3 !== o4)
        return true;
      if (o1 === 0 && onSegment(p1, p22, q1))
        return true;
      if (o2 === 0 && onSegment(p1, q2, q1))
        return true;
      if (o3 === 0 && onSegment(p22, p1, q2))
        return true;
      if (o4 === 0 && onSegment(p22, q1, q2))
        return true;
      return false;
    }
    function onSegment(p3, q2, r2) {
      return q2.x <= Math.max(p3.x, r2.x) && q2.x >= Math.min(p3.x, r2.x) && q2.y <= Math.max(p3.y, r2.y) && q2.y >= Math.min(p3.y, r2.y);
    }
    function sign2(num2) {
      return num2 > 0 ? 1 : num2 < 0 ? -1 : 0;
    }
    function intersectsPolygon(a2, b2) {
      var p3 = a2;
      do {
        if (p3.i !== a2.i && p3.next.i !== a2.i && p3.i !== b2.i && p3.next.i !== b2.i && intersects(p3, p3.next, a2, b2))
          return true;
        p3 = p3.next;
      } while (p3 !== a2);
      return false;
    }
    function locallyInside(a2, b2) {
      return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
    }
    function middleInside(a2, b2) {
      var p3 = a2, inside = false, px = (a2.x + b2.x) / 2, py = (a2.y + b2.y) / 2;
      do {
        if (p3.y > py !== p3.next.y > py && p3.next.y !== p3.y && px < (p3.next.x - p3.x) * (py - p3.y) / (p3.next.y - p3.y) + p3.x)
          inside = !inside;
        p3 = p3.next;
      } while (p3 !== a2);
      return inside;
    }
    function splitPolygon(a2, b2) {
      var a22 = new Node2(a2.i, a2.x, a2.y), b22 = new Node2(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
      a2.next = b2;
      b2.prev = a2;
      a22.next = an;
      an.prev = a22;
      b22.next = a22;
      a22.prev = b22;
      bp.next = b22;
      b22.prev = bp;
      return b22;
    }
    function insertNode(i3, x3, y2, last) {
      var p3 = new Node2(i3, x3, y2);
      if (!last) {
        p3.prev = p3;
        p3.next = p3;
      } else {
        p3.next = last.next;
        p3.prev = last;
        last.next.prev = p3;
        last.next = p3;
      }
      return p3;
    }
    function removeNode(p3) {
      p3.next.prev = p3.prev;
      p3.prev.next = p3.next;
      if (p3.prevZ)
        p3.prevZ.nextZ = p3.nextZ;
      if (p3.nextZ)
        p3.nextZ.prevZ = p3.prevZ;
    }
    function Node2(i3, x3, y2) {
      this.i = i3;
      this.x = x3;
      this.y = y2;
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut2.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) {
        for (var i3 = 0, len = holeIndices.length; i3 < len; i3++) {
          var start = holeIndices[i3] * dim;
          var end = i3 < len - 1 ? holeIndices[i3 + 1] * dim : data.length;
          polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
      }
      var trianglesArea = 0;
      for (i3 = 0; i3 < triangles.length; i3 += 3) {
        var a2 = triangles[i3] * dim;
        var b2 = triangles[i3 + 1] * dim;
        var c2 = triangles[i3 + 2] * dim;
        trianglesArea += Math.abs(
          (data[a2] - data[c2]) * (data[b2 + 1] - data[a2 + 1]) - (data[a2] - data[b2]) * (data[c2 + 1] - data[a2 + 1])
        );
      }
      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data, start, end, dim) {
      var sum = 0;
      for (var i3 = start, j3 = end - dim; i3 < end; i3 += dim) {
        sum += (data[j3] - data[i3]) * (data[i3 + 1] + data[j3 + 1]);
        j3 = i3;
      }
      return sum;
    }
    earcut2.flatten = function(data) {
      var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i3 = 0; i3 < data.length; i3++) {
        for (var j3 = 0; j3 < data[i3].length; j3++) {
          for (var d3 = 0; d3 < dim; d3++)
            result.vertices.push(data[i3][j3][d3]);
        }
        if (i3 > 0) {
          holeIndex += data[i3 - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs
function triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
  const triangles = (0, import_earcut.default)(points, holes, 2);
  if (!triangles) {
    return;
  }
  for (let i3 = 0; i3 < triangles.length; i3 += 3) {
    indices[indicesOffset++] = triangles[i3] + verticesOffset;
    indices[indicesOffset++] = triangles[i3 + 1] + verticesOffset;
    indices[indicesOffset++] = triangles[i3 + 2] + verticesOffset;
  }
  let index = verticesOffset * verticesStride;
  for (let i3 = 0; i3 < points.length; i3 += 2) {
    vertices[index] = points[i3];
    vertices[index + 1] = points[i3 + 1];
    index += verticesStride;
  }
}
var import_earcut;
var init_triangulateWithHoles = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs"() {
    import_earcut = __toESM(require_earcut(), 1);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs
var emptyArray, buildPolygon;
var init_buildPolygon = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs"() {
    init_triangulateWithHoles();
    emptyArray = [];
    buildPolygon = {
      build(shape, points) {
        for (let i3 = 0; i3 < shape.points.length; i3++) {
          points[i3] = shape.points[i3];
        }
        return points;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs
var buildRectangle;
var init_buildRectangle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs"() {
    buildRectangle = {
      build(shape, points) {
        const rectData = shape;
        const x3 = rectData.x;
        const y2 = rectData.y;
        const width = rectData.width;
        const height = rectData.height;
        if (!(width >= 0 && height >= 0)) {
          return points;
        }
        points[0] = x3;
        points[1] = y2;
        points[2] = x3 + width;
        points[3] = y2;
        points[4] = x3 + width;
        points[5] = y2 + height;
        points[6] = x3;
        points[7] = y2 + height;
        return points;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        let count2 = 0;
        verticesOffset *= verticesStride;
        vertices[verticesOffset + count2] = points[0];
        vertices[verticesOffset + count2 + 1] = points[1];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[2];
        vertices[verticesOffset + count2 + 1] = points[3];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[6];
        vertices[verticesOffset + count2 + 1] = points[7];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[4];
        vertices[verticesOffset + count2 + 1] = points[5];
        count2 += verticesStride;
        const verticesIndex = verticesOffset / verticesStride;
        indices[indicesOffset++] = verticesIndex;
        indices[indicesOffset++] = verticesIndex + 1;
        indices[indicesOffset++] = verticesIndex + 2;
        indices[indicesOffset++] = verticesIndex + 1;
        indices[indicesOffset++] = verticesIndex + 3;
        indices[indicesOffset++] = verticesIndex + 2;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs
var buildTriangle;
var init_buildTriangle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs"() {
    buildTriangle = {
      build(shape, points) {
        points[0] = shape.x;
        points[1] = shape.y;
        points[2] = shape.x2;
        points[3] = shape.y2;
        points[4] = shape.x3;
        points[5] = shape.y3;
        return points;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        let count2 = 0;
        verticesOffset *= verticesStride;
        vertices[verticesOffset + count2] = points[0];
        vertices[verticesOffset + count2 + 1] = points[1];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[2];
        vertices[verticesOffset + count2 + 1] = points[3];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[4];
        vertices[verticesOffset + count2 + 1] = points[5];
        const verticesIndex = verticesOffset / verticesStride;
        indices[indicesOffset++] = verticesIndex;
        indices[indicesOffset++] = verticesIndex + 1;
        indices[indicesOffset++] = verticesIndex + 2;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs
function buildContextBatches(context4) {
  const vertices = [];
  const uvs = [];
  const indices = [];
  const geometryData = {
    vertices,
    uvs,
    indices
  };
  const batches = [];
  for (let i3 = 0; i3 < context4.instructions.length; i3++) {
    const instruction = context4.instructions[i3];
    if (instruction.action === "texture") {
      addTextureToGeometryData(instruction.data, batches, geometryData);
    } else if (instruction.action === "fill" || instruction.action === "stroke") {
      const isStroke = instruction.action === "stroke";
      const shapePath = instruction.data.path.shapePath;
      const style = instruction.data.style;
      const hole = instruction.data.hole;
      if (isStroke && hole) {
        addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);
      }
      addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);
    }
  }
  return batches;
}
function addTextureToGeometryData(data, batches, geometryData) {
  const { vertices, uvs, indices } = geometryData;
  const indexOffset = indices.length;
  const vertOffset = vertices.length / 2;
  const points = [];
  const build = buildMap.rectangle;
  const rect = tempRect;
  const texture = data.image;
  rect.x = data.dx;
  rect.y = data.dy;
  rect.width = data.dw;
  rect.height = data.dh;
  const matrix = data.transform;
  build.build(rect, points);
  if (matrix) {
    transformVertices(points, matrix);
  }
  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
  const textureUvs = texture.layout.uvs;
  uvs.push(
    textureUvs.x0,
    textureUvs.y0,
    textureUvs.x1,
    textureUvs.y1,
    textureUvs.x3,
    textureUvs.y3,
    textureUvs.x2,
    textureUvs.y2
  );
  const graphicsBatch = BigPool.get(BatchableGraphics);
  graphicsBatch.indexOffset = indexOffset;
  graphicsBatch.indexSize = indices.length - indexOffset;
  graphicsBatch.vertexOffset = vertOffset;
  graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;
  graphicsBatch.color = data.style;
  graphicsBatch.alpha = data.alpha;
  graphicsBatch.texture = texture;
  graphicsBatch.geometryData = geometryData;
  batches.push(graphicsBatch);
}
function addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {
  const { vertices, uvs, indices } = geometryData;
  const lastIndex = shapePath.shapePrimitives.length - 1;
  shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i3) => {
    const indexOffset = indices.length;
    const vertOffset = vertices.length / 2;
    const points = [];
    const build = buildMap[shape.type];
    build.build(shape, points);
    if (matrix) {
      transformVertices(points, matrix);
    }
    if (!isStroke) {
      if (hole && lastIndex === i3) {
        if (lastIndex !== 0) {
          console.warn("[Pixi Graphics] only the last shape have be cut out");
        }
        const holeIndices = [];
        const otherPoints = points.slice();
        const holeArrays = getHoleArrays(hole.shapePath);
        holeArrays.forEach((holePoints) => {
          holeIndices.push(otherPoints.length / 2);
          otherPoints.push(...holePoints);
        });
        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);
      } else {
        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
      }
    } else {
      const close = shape.closePath ?? true;
      const lineStyle = style;
      buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);
    }
    const uvsOffset = uvs.length / 2;
    const texture = style.texture;
    if (texture !== Texture.WHITE) {
      const textureMatrix = style.matrix;
      if (matrix) {
        textureMatrix.append(matrix.clone().invert());
      }
      buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
    } else {
      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
    }
    const graphicsBatch = BigPool.get(BatchableGraphics);
    graphicsBatch.indexOffset = indexOffset;
    graphicsBatch.indexSize = indices.length - indexOffset;
    graphicsBatch.vertexOffset = vertOffset;
    graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;
    graphicsBatch.color = style.color;
    graphicsBatch.alpha = style.alpha;
    graphicsBatch.texture = texture;
    graphicsBatch.geometryData = geometryData;
    batches.push(graphicsBatch);
  });
}
function getHoleArrays(shape) {
  if (!shape)
    return [];
  const holePrimitives = shape.shapePrimitives;
  const holeArrays = [];
  for (let k3 = 0; k3 < holePrimitives.length; k3++) {
    const holePrimitive = holePrimitives[k3].shape;
    const holePoints = [];
    const holeBuilder = buildMap[holePrimitive.type];
    holeBuilder.build(holePrimitive, holePoints);
    holeArrays.push(holePoints);
  }
  return holeArrays;
}
var buildMap, tempRect;
var init_buildContextBatches = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs"() {
    init_Rectangle();
    init_buildUvs();
    init_transformVertices();
    init_Texture();
    init_PoolGroup();
    init_BatchableGraphics();
    init_buildCircle();
    init_buildLine();
    init_buildPolygon();
    init_buildRectangle();
    init_buildTriangle();
    init_triangulateWithHoles();
    buildMap = {
      rectangle: buildRectangle,
      polygon: buildPolygon,
      triangle: buildTriangle,
      circle: buildCircle,
      ellipse: buildCircle,
      roundedRectangle: buildCircle
    };
    tempRect = new Rectangle();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs
var GpuGraphicsContext, GraphicsContextRenderData, GraphicsContextSystem;
var init_GraphicsContextSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs"() {
    init_Extensions();
    init_BatchGeometry();
    init_getTextureBatchBindGroup();
    init_Batcher();
    init_InstructionSet();
    init_PoolGroup();
    init_buildContextBatches();
    GpuGraphicsContext = class {
    };
    GraphicsContextRenderData = class {
      constructor() {
        this.geometry = new BatchGeometry();
        this.instructions = new InstructionSet();
      }
      init() {
        this.geometry.reset();
        this.instructions.reset();
      }
    };
    GraphicsContextSystem = class {
      constructor() {
        this._activeBatchers = [];
        this._gpuContextHash = {};
        this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);
        this._needsContextNeedsRebuild = [];
      }
      prerender() {
        this._returnActiveBatchers();
      }
      getContextRenderData(context4) {
        return this._graphicsDataContextHash[context4.uid] || this._initContextRenderData(context4);
      }
      // Context management functions
      updateGpuContext(context4) {
        let gpuContext = this._gpuContextHash[context4.uid] || this._initContext(context4);
        if (context4.dirty) {
          if (gpuContext) {
            this._cleanGraphicsContextData(context4);
          } else {
            gpuContext = this._initContext(context4);
          }
          const contextBatches = buildContextBatches(context4);
          let size3 = 0;
          const batchMode = context4.batchMode;
          let isBatchable = true;
          if (context4.customShader || batchMode === "no-batch") {
            isBatchable = false;
          } else if (batchMode === "auto") {
            for (let i3 = 0; i3 < contextBatches.length; i3++) {
              size3 += contextBatches[i3].vertexSize;
              if (size3 > 400) {
                isBatchable = false;
                break;
              }
            }
          }
          gpuContext = this._gpuContextHash[context4.uid] = {
            isBatchable,
            batches: contextBatches
          };
          context4.dirty = false;
        }
        return gpuContext;
      }
      getGpuContext(context4) {
        return this._gpuContextHash[context4.uid] || this._initContext(context4);
      }
      _returnActiveBatchers() {
        for (let i3 = 0; i3 < this._activeBatchers.length; i3++) {
          BigPool.return(this._activeBatchers[i3]);
        }
        this._activeBatchers.length = 0;
      }
      _initContextRenderData(context4) {
        const graphicsData = BigPool.get(GraphicsContextRenderData);
        const batches = this._gpuContextHash[context4.uid].batches;
        let vertexSize = 0;
        let indexSize = 0;
        batches.forEach((batch) => {
          batch.applyTransform = false;
          vertexSize += batch.geometryData.vertices.length;
          indexSize += batch.geometryData.indices.length;
        });
        const batcher = BigPool.get(Batcher);
        this._activeBatchers.push(batcher);
        batcher.ensureAttributeBuffer(vertexSize);
        batcher.ensureIndexBuffer(indexSize);
        batcher.begin();
        for (let i3 = 0; i3 < batches.length; i3++) {
          const batch = batches[i3];
          batcher.add(batch);
        }
        batcher.finish(graphicsData.instructions);
        const geometry = graphicsData.geometry;
        geometry.indexBuffer.data = batcher.indexBuffer;
        geometry.buffers[0].data = batcher.attributeBuffer.float32View;
        geometry.indexBuffer.update(batcher.indexSize * 4);
        geometry.buffers[0].update(batcher.attributeSize * 4);
        const drawBatches = batcher.batches;
        for (let i3 = 0; i3 < drawBatches.length; i3++) {
          const batch = drawBatches[i3];
          batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);
        }
        this._graphicsDataContextHash[context4.uid] = graphicsData;
        return graphicsData;
      }
      _initContext(context4) {
        const gpuContext = new GpuGraphicsContext();
        this._gpuContextHash[context4.uid] = gpuContext;
        context4.on("update", this.onGraphicsContextUpdate, this);
        context4.on("destroy", this.onGraphicsContextDestroy, this);
        return this._gpuContextHash[context4.uid];
      }
      onGraphicsContextUpdate(context4) {
        this._needsContextNeedsRebuild.push(context4);
      }
      onGraphicsContextDestroy(context4) {
        this._cleanGraphicsContextData(context4);
        this._gpuContextHash[context4.uid] = null;
      }
      _cleanGraphicsContextData(context4) {
        const gpuContext = this._gpuContextHash[context4.uid];
        if (!gpuContext.isBatchable) {
          if (this._graphicsDataContextHash[context4.uid]) {
            BigPool.return(this.getContextRenderData(context4));
            this._graphicsDataContextHash[context4.uid] = null;
          }
        }
        if (gpuContext.batches) {
          gpuContext.batches.forEach((batch) => {
            BigPool.return(batch);
          });
        }
      }
      destroy() {
        for (const context4 of this._needsContextNeedsRebuild) {
          this._cleanGraphicsContextData(context4);
          this._gpuContextHash[context4.uid] = null;
        }
        this._needsContextNeedsRebuild.length = 0;
      }
    };
    GraphicsContextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "graphicsContext"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs
function color32BitToUniform(abgr, out3, offset) {
  out3[offset++] = (abgr & 255) / 255;
  out3[offset++] = (abgr >> 8 & 255) / 255;
  out3[offset++] = (abgr >> 16 & 255) / 255;
  out3[offset++] = (abgr >> 24 & 255) / 255;
}
var init_colorToUniform = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs
var GraphicsPipe;
var init_GraphicsPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs"() {
    init_Extensions();
    init_State();
    init_PoolGroup();
    init_colorToUniform();
    init_BatchableGraphics();
    GraphicsPipe = class {
      constructor(renderer, adaptor) {
        this.state = State.for2d();
        this._renderableBatchesHash = /* @__PURE__ */ Object.create(null);
        this.renderer = renderer;
        this._adaptor = adaptor;
        this._adaptor.init();
      }
      validateRenderable(renderable) {
        const context4 = renderable.view.context;
        const wasBatched = !!this._renderableBatchesHash[renderable.uid];
        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context4);
        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {
          return true;
        }
        return false;
      }
      addRenderable(renderable, instructionSet) {
        const gpuContext = this.renderer.graphicsContext.updateGpuContext(renderable.view.context);
        if (renderable.view._didUpdate) {
          renderable.view._didUpdate = false;
          this._rebuild(renderable);
        }
        if (gpuContext.isBatchable) {
          this._addToBatcher(renderable, instructionSet);
        } else {
          this.renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            type: "graphics",
            renderable
          });
        }
      }
      updateRenderable(renderable) {
        const batches = this._renderableBatchesHash[renderable.uid];
        if (batches) {
          for (let i3 = 0; i3 < batches.length; i3++) {
            const batch = batches[i3];
            batch.batcher.updateElement(batch);
          }
        }
      }
      destroyRenderable(renderable) {
        this._removeBatchForRenderable(renderable.uid);
      }
      execute({ renderable }) {
        if (!renderable.isRenderable)
          return;
        const renderer = this.renderer;
        const context4 = renderable.view.context;
        const contextSystem = renderer.graphicsContext;
        if (!contextSystem.getGpuContext(context4).batches.length) {
          return;
        }
        const shader = context4.customShader || this._adaptor.shader;
        this.state.blendMode = renderable.layerBlendMode;
        const localUniforms = shader.resources.localUniforms.uniforms;
        localUniforms.uTransformMatrix = renderable.layerTransform;
        localUniforms.uRound = renderer._roundPixels | renderable.view.roundPixels;
        color32BitToUniform(
          renderable.layerColor,
          localUniforms.uColor,
          0
        );
        this._adaptor.execute(this, renderable);
      }
      _rebuild(renderable) {
        const wasBatched = !!this._renderableBatchesHash[renderable.uid];
        const gpuContext = this.renderer.graphicsContext.updateGpuContext(renderable.view.context);
        if (wasBatched) {
          this._removeBatchForRenderable(renderable.uid);
        }
        if (gpuContext.isBatchable) {
          this._initBatchesForRenderable(renderable);
        }
        renderable.view.batched = gpuContext.isBatchable;
      }
      _addToBatcher(renderable, instructionSet) {
        const batchPipe = this.renderer.renderPipes.batch;
        const batches = this._getBatchesForRenderable(renderable);
        for (let i3 = 0; i3 < batches.length; i3++) {
          const batch = batches[i3];
          batchPipe.addToBatch(batch, instructionSet);
        }
      }
      _getBatchesForRenderable(renderable) {
        return this._renderableBatchesHash[renderable.uid] || this._initBatchesForRenderable(renderable);
      }
      _initBatchesForRenderable(renderable) {
        const context4 = renderable.view.context;
        const gpuContext = this.renderer.graphicsContext.getGpuContext(context4);
        const roundPixels = this.renderer._roundPixels | renderable.view.roundPixels;
        const batches = gpuContext.batches.map((batch) => {
          const batchClone = BigPool.get(BatchableGraphics);
          batch.copyTo(batchClone);
          batchClone.renderable = renderable;
          batchClone.roundPixels = roundPixels;
          return batchClone;
        });
        this._renderableBatchesHash[renderable.uid] = batches;
        renderable.on("destroyed", () => {
          this.destroyRenderable(renderable);
        });
        return batches;
      }
      _removeBatchForRenderable(renderableUid) {
        this._renderableBatchesHash[renderableUid].forEach((batch) => {
          BigPool.return(batch);
        });
        this._renderableBatchesHash[renderableUid] = null;
      }
      destroy() {
        this.renderer = null;
        this._adaptor.destroy();
        this._adaptor = null;
        this.state = null;
        for (const i3 in this._renderableBatchesHash) {
          this._removeBatchForRenderable(i3);
        }
        this._renderableBatchesHash = null;
      }
    };
    GraphicsPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "graphics"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs
var BatchableMesh;
var init_BatchableMesh = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs"() {
    BatchableMesh = class {
      constructor() {
        this.batcher = null;
        this.batch = null;
        this.roundPixels = 0;
      }
      get blendMode() {
        return this.renderable.layerBlendMode;
      }
      reset() {
        this.renderable = null;
        this.texture = null;
        this.batcher = null;
        this.batch = null;
      }
      packIndex(indexBuffer, index, indicesOffset) {
        const indices = this.renderable.view.geometry.indices;
        for (let i3 = 0; i3 < indices.length; i3++) {
          indexBuffer[index++] = indices[i3] + indicesOffset;
        }
      }
      packAttributes(float32View, uint32View, index, textureId) {
        const renderable = this.renderable;
        const view = this.renderable.view;
        const geometry = view.geometry;
        const wt = renderable.layerTransform;
        const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;
        const a2 = wt.a;
        const b2 = wt.b;
        const c2 = wt.c;
        const d3 = wt.d;
        const tx = wt.tx;
        const ty = wt.ty;
        const positions = geometry.positions;
        const uvs = geometry.uvs;
        const abgr = renderable.layerColor;
        for (let i3 = 0; i3 < positions.length; i3 += 2) {
          const x3 = positions[i3];
          const y2 = positions[i3 + 1];
          float32View[index] = a2 * x3 + c2 * y2 + tx;
          float32View[index + 1] = b2 * x3 + d3 * y2 + ty;
          float32View[index + 2] = uvs[i3];
          float32View[index + 3] = uvs[i3 + 1];
          uint32View[index + 4] = abgr;
          uint32View[index + 5] = textureIdAndRound;
          index += 6;
        }
      }
      get vertexSize() {
        return this.renderable.view.geometry.positions.length / 2;
      }
      get indexSize() {
        return this.renderable.view.geometry.indices.length;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs
var MeshPipe;
var init_MeshPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs"() {
    init_Extensions();
    init_Matrix();
    init_BindGroup();
    init_UniformGroup();
    init_PoolGroup();
    init_colorToUniform();
    init_BatchableMesh();
    MeshPipe = class {
      constructor(renderer, adaptor) {
        this.localUniforms = new UniformGroup({
          uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          uRound: { value: 0, type: "f32" }
        });
        this.localUniformsBindGroup = new BindGroup({
          0: this.localUniforms
        });
        this._renderableHash = /* @__PURE__ */ Object.create(null);
        this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null);
        this.renderer = renderer;
        this._adaptor = adaptor;
        this._adaptor.init();
      }
      validateRenderable(renderable) {
        const renderableData = this._getRenderableData(renderable);
        const wasBatched = renderableData.batched;
        const isBatched = renderable.view.batched;
        renderableData.batched = isBatched;
        if (wasBatched !== isBatched) {
          return true;
        } else if (isBatched) {
          const geometry = renderable.view._geometry;
          if (geometry.indices.length !== renderableData.indexSize || geometry.positions.length !== renderableData.vertexSize) {
            renderableData.indexSize = geometry.indices.length;
            renderableData.vertexSize = geometry.positions.length;
            return true;
          }
          const batchableMesh = this._getBatchableMesh(renderable);
          const texture = renderable.view.texture;
          if (batchableMesh.texture._source !== texture._source) {
            if (batchableMesh.texture._source !== texture._source) {
              return batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);
            }
          }
        }
        return false;
      }
      addRenderable(renderable, instructionSet) {
        const batcher = this.renderer.renderPipes.batch;
        const { batched } = this._getRenderableData(renderable);
        if (batched) {
          const gpuBatchableMesh = this._getBatchableMesh(renderable);
          gpuBatchableMesh.texture = renderable.view._texture;
          batcher.addToBatch(gpuBatchableMesh);
        } else {
          batcher.break(instructionSet);
          instructionSet.add({
            type: "mesh",
            renderable
          });
        }
      }
      updateRenderable(renderable) {
        if (renderable.view.batched) {
          const gpuBatchableMesh = this._gpuBatchableMeshHash[renderable.uid];
          gpuBatchableMesh.texture = renderable.view._texture;
          gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);
        }
      }
      destroyRenderable(renderable) {
        this._renderableHash[renderable.uid] = null;
        const gpuMesh = this._gpuBatchableMeshHash[renderable.uid];
        BigPool.return(gpuMesh);
        this._gpuBatchableMeshHash[renderable.uid] = null;
      }
      execute({ renderable }) {
        if (!renderable.isRenderable)
          return;
        const view = renderable.view;
        view.state.blendMode = renderable.layerBlendMode;
        const localUniforms = this.localUniforms;
        localUniforms.uniforms.uTransformMatrix = renderable.layerTransform;
        localUniforms.uniforms.uRound = this.renderer._roundPixels | renderable.view.roundPixels;
        localUniforms.update();
        color32BitToUniform(
          renderable.layerColor,
          localUniforms.uniforms.uColor,
          0
        );
        this._adaptor.execute(this, renderable);
      }
      _getRenderableData(renderable) {
        return this._renderableHash[renderable.uid] || this._initRenderableData(renderable);
      }
      _initRenderableData(renderable) {
        const view = renderable.view;
        this._renderableHash[renderable.uid] = {
          batched: view.batched,
          indexSize: view._geometry.indices.length,
          vertexSize: view._geometry.positions.length
        };
        renderable.on("destroyed", () => {
          this.destroyRenderable(renderable);
        });
        return this._renderableHash[renderable.uid];
      }
      _getBatchableMesh(renderable) {
        return this._gpuBatchableMeshHash[renderable.uid] || this._initBatchableMesh(renderable);
      }
      _initBatchableMesh(renderable) {
        const gpuMesh = BigPool.get(BatchableMesh);
        gpuMesh.renderable = renderable;
        gpuMesh.texture = renderable.view._texture;
        gpuMesh.roundPixels = this.renderer._roundPixels | renderable.view.roundPixels;
        this._gpuBatchableMeshHash[renderable.uid] = gpuMesh;
        gpuMesh.renderable = renderable;
        return gpuMesh;
      }
      destroy() {
        for (const i3 in this._gpuBatchableMeshHash) {
          if (this._gpuBatchableMeshHash[i3]) {
            BigPool.return(this._gpuBatchableMeshHash[i3]);
          }
        }
        this._gpuBatchableMeshHash = null;
        this._renderableHash = null;
        this.localUniforms = null;
        this.localUniformsBindGroup = null;
        this._adaptor.destroy();
        this._adaptor = null;
        this.renderer = null;
      }
    };
    MeshPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "mesh"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs
var BatchableSprite;
var init_BatchableSprite = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs"() {
    BatchableSprite = class {
      constructor() {
        this.vertexSize = 4;
        this.indexSize = 6;
        this.location = 0;
        this.batcher = null;
        this.batch = null;
        this.roundPixels = 0;
      }
      get blendMode() {
        return this.renderable.layerBlendMode;
      }
      packAttributes(float32View, uint32View, index, textureId) {
        const sprite = this.renderable;
        const texture = this.texture;
        const wt = sprite.layerTransform;
        const a2 = wt.a;
        const b2 = wt.b;
        const c2 = wt.c;
        const d3 = wt.d;
        const tx = wt.tx;
        const ty = wt.ty;
        const bounds = this.bounds;
        const w0 = bounds[1];
        const w1 = bounds[0];
        const h0 = bounds[3];
        const h1 = bounds[2];
        const uvs = texture._layout.uvs;
        const argb = sprite.layerColor;
        const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;
        float32View[index + 0] = a2 * w1 + c2 * h1 + tx;
        float32View[index + 1] = d3 * h1 + b2 * w1 + ty;
        float32View[index + 2] = uvs.x0;
        float32View[index + 3] = uvs.y0;
        uint32View[index + 4] = argb;
        uint32View[index + 5] = textureIdAndRound;
        float32View[index + 6] = a2 * w0 + c2 * h1 + tx;
        float32View[index + 7] = d3 * h1 + b2 * w0 + ty;
        float32View[index + 8] = uvs.x1;
        float32View[index + 9] = uvs.y1;
        uint32View[index + 10] = argb;
        uint32View[index + 11] = textureIdAndRound;
        float32View[index + 12] = a2 * w0 + c2 * h0 + tx;
        float32View[index + 13] = d3 * h0 + b2 * w0 + ty;
        float32View[index + 14] = uvs.x2;
        float32View[index + 15] = uvs.y2;
        uint32View[index + 16] = argb;
        uint32View[index + 17] = textureIdAndRound;
        float32View[index + 18] = a2 * w1 + c2 * h0 + tx;
        float32View[index + 19] = d3 * h0 + b2 * w1 + ty;
        float32View[index + 20] = uvs.x3;
        float32View[index + 21] = uvs.y3;
        uint32View[index + 22] = argb;
        uint32View[index + 23] = textureIdAndRound;
      }
      packIndex(indexBuffer, index, indicesOffset) {
        indexBuffer[index] = indicesOffset + 0;
        indexBuffer[index + 1] = indicesOffset + 1;
        indexBuffer[index + 2] = indicesOffset + 2;
        indexBuffer[index + 3] = indicesOffset + 0;
        indexBuffer[index + 4] = indicesOffset + 2;
        indexBuffer[index + 5] = indicesOffset + 3;
      }
      reset() {
        this.renderable = null;
        this.texture = null;
        this.batcher = null;
        this.batch = null;
        this.bounds = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs
var gpuSpriteHash, SpritePipe;
var init_SpritePipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs"() {
    init_Extensions();
    init_PoolGroup();
    init_BatchableSprite();
    SpritePipe = class {
      constructor(renderer) {
        this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
        gpuSpriteHash = this._gpuSpriteHash;
      }
      addRenderable(renderable, _instructionSet) {
        const gpuSprite = this._getGpuSprite(renderable);
        if (renderable.view._didUpdate)
          this._updateBatchableSprite(renderable, gpuSprite);
        this._renderer.renderPipes.batch.addToBatch(gpuSprite);
      }
      updateRenderable(renderable) {
        const gpuSprite = gpuSpriteHash[renderable.uid];
        if (renderable.view._didUpdate)
          this._updateBatchableSprite(renderable, gpuSprite);
        gpuSprite.batcher.updateElement(gpuSprite);
      }
      validateRenderable(renderable) {
        const texture = renderable.view._texture;
        const gpuSprite = this._getGpuSprite(renderable);
        if (gpuSprite.texture._source !== texture._source) {
          return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);
        }
        return false;
      }
      destroyRenderable(renderable) {
        const batchableSprite = gpuSpriteHash[renderable.uid];
        BigPool.return(batchableSprite);
        gpuSpriteHash[renderable.uid] = null;
      }
      _updateBatchableSprite(renderable, batchableSprite) {
        const view = renderable.view;
        view._didUpdate = false;
        batchableSprite.bounds = view.bounds;
        batchableSprite.texture = view._texture;
      }
      _getGpuSprite(renderable) {
        return gpuSpriteHash[renderable.uid] || this._initGPUSprite(renderable);
      }
      _initGPUSprite(renderable) {
        const batchableSprite = BigPool.get(BatchableSprite);
        batchableSprite.renderable = renderable;
        const view = renderable.view;
        batchableSprite.texture = view._texture;
        batchableSprite.bounds = view.bounds;
        batchableSprite.roundPixels = this._renderer._roundPixels | view.roundPixels;
        gpuSpriteHash[renderable.uid] = batchableSprite;
        renderable.view._didUpdate = false;
        renderable.on("destroyed", () => {
          this.destroyRenderable(renderable);
        });
        return batchableSprite;
      }
      destroy() {
        for (const i3 in this._gpuSpriteHash) {
          BigPool.return(this._gpuSpriteHash[i3]);
        }
        this._gpuSpriteHash = null;
        this._renderer = null;
      }
    };
    SpritePipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "sprite"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/ProxyRenderable.mjs
var ProxyRenderable;
var init_ProxyRenderable = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/ProxyRenderable.mjs"() {
    init_eventemitter3();
    init_uid();
    ProxyRenderable = class extends eventemitter3_default {
      constructor({ original, view }) {
        super();
        this.uid = uid("renderable");
        this.didViewUpdate = false;
        this.view = view;
        if (original) {
          this.init(original);
        }
      }
      init(original) {
        this._original = original;
        this.layerTransform = original.layerTransform;
      }
      get layerColor() {
        return this._original.layerColor;
      }
      get layerBlendMode() {
        return this._original.layerBlendMode;
      }
      get layerVisibleRenderable() {
        return this._original.layerVisibleRenderable;
      }
      get isRenderable() {
        return this._original.isRenderable;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/mesh/shared/MeshView.mjs
var tempPolygon, MeshView;
var init_MeshView = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/mesh/shared/MeshView.mjs"() {
    init_Polygon();
    init_State();
    init_Texture();
    init_View();
    init_uid();
    tempPolygon = new Polygon();
    MeshView = class {
      constructor(options) {
        this.uid = uid("meshView");
        this.renderPipeId = "mesh";
        this.canBundle = true;
        this.owner = emptyViewObserver;
        this.state = State.for2d();
        this.roundPixels = 0;
        this.shader = options.shader;
        this.texture = options.texture ?? this.shader?.texture ?? Texture.WHITE;
        this._geometry = options.geometry;
        this._geometry.on("update", this.onUpdate, this);
      }
      set shader(value) {
        if (this._shader === value)
          return;
        this._shader = value;
        this.onUpdate();
      }
      get shader() {
        return this._shader;
      }
      set geometry(value) {
        if (this._geometry === value)
          return;
        this._geometry?.off("update", this.onUpdate, this);
        value.on("update", this.onUpdate, this);
        this._geometry = value;
        this.onUpdate();
      }
      get geometry() {
        return this._geometry;
      }
      set texture(value) {
        if (this._texture === value)
          return;
        if (this.shader) {
          this.shader.texture = value;
        }
        this._texture = value;
        this.onUpdate();
      }
      get texture() {
        return this._texture;
      }
      get batched() {
        if (this._shader)
          return false;
        if (this._geometry.batchMode === "auto") {
          return this._geometry.positions.length / 2 <= 100;
        }
        return this._geometry.batchMode === "batch";
      }
      addBounds(bounds) {
        bounds.addVertexData(this.geometry.positions, 0, this.geometry.positions.length);
      }
      containsPoint(point) {
        const { x: x3, y: y2 } = point;
        const vertices = this.geometry.getBuffer("aPosition").data;
        const points = tempPolygon.points;
        const indices = this.geometry.getIndex().data;
        const len = indices.length;
        const step = this.geometry.topology === "triangle-strip" ? 3 : 1;
        for (let i3 = 0; i3 + 2 < len; i3 += step) {
          const ind0 = indices[i3] * 2;
          const ind1 = indices[i3 + 1] * 2;
          const ind2 = indices[i3 + 2] * 2;
          points[0] = vertices[ind0];
          points[1] = vertices[ind0 + 1];
          points[2] = vertices[ind1];
          points[3] = vertices[ind1 + 1];
          points[4] = vertices[ind2];
          points[5] = vertices[ind2 + 1];
          if (tempPolygon.contains(x3, y2)) {
            return true;
          }
        }
        return false;
      }
      /** Called when the geometry is updated. */
      onUpdate() {
        this.owner.onViewUpdate();
      }
      /**
       * Destroys this sprite renderable and optionally its texture.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
       * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
       */
      destroy(options = false) {
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          this._texture.destroy(destroyTextureSource);
        }
        this._texture = null;
        this._geometry = null;
        this._shader = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs
var _MeshGeometry, MeshGeometry;
var init_MeshGeometry = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs"() {
    init_Buffer();
    init_const5();
    init_Geometry();
    init_deprecation();
    _MeshGeometry = class extends Geometry {
      constructor(...args) {
        let options = args[0] ?? {};
        if (options instanceof Float32Array) {
          deprecation(v8_0_0, "use new MeshGeometry({ positions, uvs, indices }) instead");
          options = {
            positions: options,
            uvs: args[1],
            indices: args[2]
          };
        }
        options = { ..._MeshGeometry.defaultOptions, ...options };
        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
        const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);
        const positionBuffer = new Buffer2({
          data: positions,
          label: "attribute-mesh-positions",
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
        });
        const uvBuffer = new Buffer2({
          data: uvs,
          label: "attribute-mesh-uvs",
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
        });
        const indexBuffer = new Buffer2({
          data: indices,
          label: "index-mesh-buffer",
          usage: BufferUsage.INDEX | BufferUsage.COPY_DST
        });
        super({
          attributes: {
            aPosition: {
              buffer: positionBuffer,
              shaderLocation: 0,
              format: "float32x2",
              stride: 2 * 4,
              offset: 0
            },
            aUV: {
              buffer: uvBuffer,
              shaderLocation: 1,
              format: "float32x2",
              stride: 2 * 4,
              offset: 0
            }
          },
          indexBuffer,
          topology: options.topology
        });
        this.batchMode = "auto";
      }
      get positions() {
        return this.attributes.aPosition.buffer.data;
      }
      set positions(value) {
        this.attributes.aPosition.buffer.data = value;
      }
      get uvs() {
        return this.attributes.aUV.buffer.data;
      }
      set uvs(value) {
        this.attributes.aUV.buffer.data = value;
      }
      get indices() {
        return this.indexBuffer.data;
      }
      set indices(value) {
        this.indexBuffer.data = value;
      }
    };
    MeshGeometry = _MeshGeometry;
    MeshGeometry.defaultOptions = {
      topology: "triangle-list"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/sprite-tiling/QuadGeometry.mjs
var QuadGeometry;
var init_QuadGeometry = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/sprite-tiling/QuadGeometry.mjs"() {
    init_MeshGeometry();
    QuadGeometry = class extends MeshGeometry {
      constructor() {
        super({
          positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
          uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
          indices: new Uint32Array([0, 1, 2, 0, 2, 3])
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs
var tilingBit, tilingBitGl;
var init_tilingBit = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs"() {
    tilingBit = {
      name: "tiling-bit",
      vertex: {
        header: (
          /* wgsl */
          `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
        ),
        main: (
          /* wgsl */
          `
            vUV = (tilingUniforms.uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
        )
      },
      fragment: {
        header: (
          /* wgsl */
          `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
        ),
        main: (
          /* wgsl */
          `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
        )
      }
    };
    tilingBitGl = {
      name: "tiling-bit",
      vertex: {
        header: (
          /* glsl */
          `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `
        ),
        main: (
          /* glsl */
          `
            vUV = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
        )
      },
      fragment: {
        header: (
          /* glsl */
          `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `
        ),
        main: (
          /* glsl */
          `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0
    
        `
        )
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs
var TilingSpriteShader;
var init_TilingSpriteShader = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs"() {
    init_Matrix();
    init_compileHighShaderToProgram();
    init_localUniformBit();
    init_roundPixelsBit();
    init_Shader();
    init_UniformGroup();
    init_tilingBit();
    TilingSpriteShader = class extends Shader {
      constructor(options) {
        const gpuProgram = compileHighShaderGpuProgram({
          name: "tiling-sprite-shader",
          bits: [
            localUniformBit,
            tilingBit,
            roundPixelsBit
          ]
        });
        const glProgram = compileHighShaderGlProgram({
          name: "tiling-sprite-shader",
          bits: [
            localUniformBitGl,
            tilingBitGl,
            roundPixelsBitGl
          ]
        });
        const tilingUniforms = new UniformGroup({
          uMapCoord: { value: new Matrix(), type: "mat3x3<f32>" },
          uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },
          uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },
          uTextureTransform: { value: new Matrix(), type: "mat3x3<f32>" },
          uSizeAnchor: { value: new Float32Array([100, 200, 0.5, 0.5]), type: "vec4<f32>" }
        });
        super({
          glProgram,
          gpuProgram,
          resources: {
            tilingUniforms,
            uTexture: options.texture.source,
            uSampler: options.texture.source.style
          }
        });
      }
      get texture() {
        return this._texture;
      }
      set texture(value) {
        if (this._texture === value)
          return;
        this._texture = value;
        this.resources.uTexture = value.source;
        this.resources.uSampler = value.source.style;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs
function applyMatrix(array, stride, offset, matrix) {
  let index = 0;
  const size3 = array.length / (stride || 2);
  const a2 = matrix.a;
  const b2 = matrix.b;
  const c2 = matrix.c;
  const d3 = matrix.d;
  const tx = matrix.tx;
  const ty = matrix.ty;
  offset *= stride;
  while (index < size3) {
    const x3 = array[offset];
    const y2 = array[offset + 1];
    array[offset] = a2 * x3 + c2 * y2 + tx;
    array[offset + 1] = b2 * x3 + d3 * y2 + ty;
    offset += stride;
    index++;
  }
}
var sharedQuad, TilingSpritePipe;
var init_TilingSpritePipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs"() {
    init_Extensions();
    init_Matrix();
    init_ProxyRenderable();
    init_MeshView();
    init_QuadGeometry();
    init_TilingSpriteShader();
    sharedQuad = new QuadGeometry();
    TilingSpritePipe = class {
      constructor(renderer) {
        this._renderableHash = /* @__PURE__ */ Object.create(null);
        this._gpuBatchedTilingSprite = /* @__PURE__ */ Object.create(null);
        this._gpuTilingSprite = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      validateRenderable(renderable) {
        const textureMatrix = renderable.view.texture.textureMatrix;
        let rebuild = false;
        const renderableData = this._getRenderableData(renderable);
        if (renderableData.batched !== textureMatrix.isSimple) {
          renderableData.batched = textureMatrix.isSimple;
          rebuild = true;
        }
        return rebuild;
      }
      addRenderable(renderable, instructionSet) {
        if (renderable.view._didUpdate) {
          renderable.view._didUpdate = false;
          this._rebuild(renderable);
        }
        const { batched } = this._getRenderableData(renderable);
        if (batched) {
          const batchableTilingSprite = this._getBatchedTilingSprite(renderable);
          this._renderer.renderPipes.mesh.addRenderable(batchableTilingSprite, instructionSet);
        } else {
          const gpuTilingSprite = this._getGpuTilingSprite(renderable);
          this._renderer.renderPipes.mesh.addRenderable(gpuTilingSprite.meshRenderable, instructionSet);
        }
      }
      updateRenderable(renderable) {
        if (renderable.view._didUpdate) {
          renderable.view._didUpdate = false;
          this._rebuild(renderable);
        }
        const { batched } = this._getRenderableData(renderable);
        if (batched) {
          const batchableTilingSprite = this._getBatchedTilingSprite(renderable);
          this._renderer.renderPipes.mesh.updateRenderable(batchableTilingSprite);
        } else {
          const gpuTilingSprite = this._getGpuTilingSprite(renderable);
          this._renderer.renderPipes.mesh.updateRenderable(gpuTilingSprite.meshRenderable);
        }
      }
      destroyRenderable(renderable) {
        this._renderableHash[renderable.uid] = null;
        this._gpuTilingSprite[renderable.uid] = null;
        this._gpuBatchedTilingSprite[renderable.uid] = null;
      }
      _getRenderableData(renderable) {
        return this._renderableHash[renderable.uid] || this._initRenderableData(renderable);
      }
      _initRenderableData(renderable) {
        const renderableData = {
          batched: true
        };
        this._renderableHash[renderable.uid] = renderableData;
        this.validateRenderable(renderable);
        renderable.on("destroyed", () => {
          this.destroyRenderable(renderable);
        });
        return renderableData;
      }
      _rebuild(renderable) {
        const renderableData = this._getRenderableData(renderable);
        const view = renderable.view;
        const textureMatrix = view.texture.textureMatrix;
        if (renderableData.batched) {
          const batchedMesh = this._getBatchedTilingSprite(renderable);
          batchedMesh.view.texture = view.texture;
          const style = view.texture.source.style;
          if (style.addressMode !== "repeat") {
            style.addressMode = "repeat";
            style.update();
          }
          this._updateBatchPositions(renderable);
          this._updateBatchUvs(renderable);
        } else {
          const gpuTilingSprite = this._getGpuTilingSprite(renderable);
          const { meshRenderable } = gpuTilingSprite;
          const meshView = meshRenderable.view;
          meshView.shader.texture = view.texture;
          const tilingUniforms = meshView.shader.resources.tilingUniforms;
          const originalWidth = view.width;
          const originalHeight = view.height;
          const tilingSpriteWidth = view.texture.width;
          const tilingSpriteHeight = view.texture.height;
          const matrix = view._tileTransform.matrix;
          const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;
          uTextureTransform.set(
            matrix.a * tilingSpriteWidth / originalWidth,
            matrix.b * tilingSpriteWidth / originalHeight,
            matrix.c * tilingSpriteHeight / originalWidth,
            matrix.d * tilingSpriteHeight / originalHeight,
            matrix.tx / originalWidth,
            matrix.ty / originalHeight
          );
          uTextureTransform.invert();
          tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;
          tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;
          tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;
          tilingUniforms.uniforms.uTextureTransform = uTextureTransform;
          tilingUniforms.uniforms.uSizeAnchor[0] = originalWidth;
          tilingUniforms.uniforms.uSizeAnchor[1] = originalHeight;
          tilingUniforms.uniforms.uSizeAnchor[2] = renderable.view.anchor.x;
          tilingUniforms.uniforms.uSizeAnchor[3] = renderable.view.anchor.y;
          tilingUniforms.update();
        }
      }
      _getGpuTilingSprite(renderable) {
        return this._gpuTilingSprite[renderable.uid] || this._initGpuTilingSprite(renderable);
      }
      _initGpuTilingSprite(renderable) {
        const view = renderable.view;
        const style = view.texture.source.style;
        style.addressMode = "repeat";
        style.update();
        const meshView = new MeshView({
          geometry: sharedQuad,
          shader: new TilingSpriteShader({
            texture: view.texture
          })
        });
        const meshRenderable = new ProxyRenderable({
          original: renderable,
          view: meshView
        });
        const textureMatrix = new Matrix();
        const gpuTilingSpriteData = {
          meshRenderable,
          textureMatrix
        };
        this._gpuTilingSprite[renderable.uid] = gpuTilingSpriteData;
        return gpuTilingSpriteData;
      }
      _getBatchedTilingSprite(renderable) {
        return this._gpuBatchedTilingSprite[renderable.uid] || this._initBatchedTilingSprite(renderable);
      }
      _initBatchedTilingSprite(renderable) {
        const meshView = new MeshView({
          geometry: new QuadGeometry(),
          texture: renderable.view.texture
        });
        meshView.roundPixels = this._renderer._roundPixels | renderable.view.roundPixels;
        const batchableMeshRenderable = new ProxyRenderable({
          original: renderable,
          view: meshView
        });
        this._gpuBatchedTilingSprite[renderable.uid] = batchableMeshRenderable;
        return batchableMeshRenderable;
      }
      _updateBatchPositions(renderable) {
        const meshRenderable = this._getBatchedTilingSprite(renderable);
        const view = renderable.view;
        const positionBuffer = meshRenderable.view.geometry.getBuffer("aPosition");
        const positions = positionBuffer.data;
        const anchorX = view.anchor.x;
        const anchorY = view.anchor.y;
        positions[0] = -anchorX * view.width;
        positions[1] = -anchorY * view.height;
        positions[2] = (1 - anchorX) * view.width;
        positions[3] = -anchorY * view.height;
        positions[4] = (1 - anchorX) * view.width;
        positions[5] = (1 - anchorY) * view.height;
        positions[6] = -anchorX * view.width;
        positions[7] = (1 - anchorY) * view.height;
      }
      _updateBatchUvs(renderable) {
        const view = renderable.view;
        const width = view.texture.frameWidth;
        const height = view.texture.frameHeight;
        const meshRenderable = this._getBatchedTilingSprite(renderable);
        const uvBuffer = meshRenderable.view.geometry.getBuffer("aUV");
        const uvs = uvBuffer.data;
        let anchorX = 0;
        let anchorY = 0;
        if (view._applyAnchorToTexture) {
          anchorX = view.anchor.x;
          anchorY = view.anchor.y;
        }
        uvs[0] = uvs[6] = -anchorX;
        uvs[2] = uvs[4] = 1 - anchorX;
        uvs[1] = uvs[3] = -anchorY;
        uvs[5] = uvs[7] = 1 - anchorY;
        const textureMatrix = Matrix.shared;
        textureMatrix.copyFrom(view._tileTransform.matrix);
        textureMatrix.tx /= view.width;
        textureMatrix.ty /= view.height;
        textureMatrix.invert();
        textureMatrix.scale(view.width / width, view.height / height);
        applyMatrix(uvs, 2, 0, textureMatrix);
      }
      destroy() {
        this._renderableHash = null;
        this._gpuTilingSprite = null;
        this._gpuBatchedTilingSprite = null;
        this._renderer = null;
      }
    };
    TilingSpritePipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "tilingSprite"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsView.mjs
var GraphicsView;
var init_GraphicsView = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsView.mjs"() {
    init_View();
    init_uid();
    init_GraphicsContext();
    GraphicsView = class {
      constructor(graphicsContext) {
        this.uid = uid("graphicsView");
        this.canBundle = true;
        this.owner = emptyViewObserver;
        this.renderPipeId = "graphics";
        this.roundPixels = 0;
        this._context = graphicsContext || new GraphicsContext();
        this._context.on("update", this.onGraphicsContextUpdate, this);
      }
      set context(context4) {
        if (context4 === this._context)
          return;
        this._context.off("update", this.onGraphicsContextUpdate, this);
        this._context = context4;
        this._context.on("update", this.onGraphicsContextUpdate, this);
        this.onGraphicsContextUpdate();
      }
      get context() {
        return this._context;
      }
      addBounds(bounds) {
        bounds.addBounds(this._context.bounds);
      }
      containsPoint(point) {
        return this._context.containsPoint(point);
      }
      onGraphicsContextUpdate() {
        this._didUpdate = true;
        this.owner.onViewUpdate();
      }
      /**
       * Destroys this graphics renderable and optionally its context.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context
       * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context
       * @param {boolean} [options.context=false] - Should destroy the context
       */
      destroy(options = false) {
        this.owner = null;
        const destroyContext = typeof options === "boolean" ? options : options?.context;
        if (destroyContext) {
          this._context.destroy(options);
        }
        this._context = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/batchSamplersUniformGroup.mjs
var sampleValues, batchSamplersUniformGroup;
var init_batchSamplersUniformGroup = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/batchSamplersUniformGroup.mjs"() {
    init_const3();
    init_UniformGroup();
    sampleValues = new Int32Array(MAX_TEXTURES);
    for (let i3 = 0; i3 < MAX_TEXTURES; i3++) {
      sampleValues[i3] = i3;
    }
    batchSamplersUniformGroup = new UniformGroup({
      uSamplers: { value: sampleValues, type: `u32`, size: MAX_TEXTURES }
    }, { isStatic: true });
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs
var localUniformMSDFBit;
var init_localUniformMSDFBit = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs"() {
    localUniformMSDFBit = {
      name: "local-uniform-msdf-bit",
      vertex: {
        header: (
          /* wgsl */
          `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
        ),
        main: (
          /* wgsl */
          `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
        ),
        end: (
          /* wgsl */
          `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        )
      },
      fragment: {
        header: (
          /* wgsl */
          `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `
        ),
        main: (
          /* wgsl */
          ` 
            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);
        `
        )
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs
var mSDFBit, mSDFBitGl;
var init_mSDFBit = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs"() {
    mSDFBit = {
      name: "msdf-bit",
      fragment: {
        header: (
          /* wgsl */
          `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                return alpha;
            }
        `
        )
      }
    };
    mSDFBitGl = {
      name: "msdf-bit",
      fragment: {
        header: (
          /* glsl */
          `
            float calculateMSDFAlpha(vec4 msdfColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                return alpha;
            }

            uniform float uDistance;
        `
        ),
        main: (
          /* glsl */
          `

            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);
        `
        )
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs
var SdfShader;
var init_SdfShader = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs"() {
    init_Matrix();
    init_const3();
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_localUniformBit();
    init_roundPixelsBit();
    init_batchSamplersUniformGroup();
    init_Shader();
    init_UniformGroup();
    init_localUniformMSDFBit();
    init_mSDFBit();
    SdfShader = class extends Shader {
      constructor() {
        const uniforms = new UniformGroup({
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uDistance: { value: 4, type: "f32" },
          uRound: { value: 0, type: "f32" }
        });
        const gpuProgram = compileHighShaderGpuProgram({
          name: "sdf-shader",
          bits: [
            colorBit,
            generateTextureBatchBit(MAX_TEXTURES),
            localUniformMSDFBit,
            mSDFBit,
            roundPixelsBit
          ]
        });
        const glProgram = compileHighShaderGlProgram({
          name: "sdf-shader",
          bits: [
            colorBitGl,
            generateTextureBatchBitGl(MAX_TEXTURES),
            localUniformBitGl,
            mSDFBitGl,
            roundPixelsBitGl
          ]
        });
        super({
          glProgram,
          gpuProgram,
          resources: {
            localUniforms: uniforms,
            batchSamplers: batchSamplersUniformGroup
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs
function generateTextStyleKey(style) {
  const key2 = [];
  let index = 0;
  for (let i3 = 0; i3 < valuesToIterateForKeys.length; i3++) {
    const prop = valuesToIterateForKeys[i3];
    key2[index++] = style[prop];
  }
  index = addFillStyleKey(style._fill, key2, index);
  index = addStokeStyleKey(style._stroke, key2, index);
  return key2.join("-");
}
function addFillStyleKey(fillStyle, key2, index) {
  if (!fillStyle)
    return index;
  key2[index++] = fillStyle.color;
  key2[index++] = fillStyle.alpha;
  key2[index++] = fillStyle.fill?.uid;
  return index;
}
function addStokeStyleKey(strokeStyle, key2, index) {
  if (!strokeStyle)
    return index;
  index = addFillStyleKey(strokeStyle, key2, index);
  key2[index++] = strokeStyle.width;
  key2[index++] = strokeStyle.alignment;
  key2[index++] = strokeStyle.cap;
  key2[index++] = strokeStyle.join;
  key2[index++] = strokeStyle.miterLimit;
  return index;
}
var valuesToIterateForKeys;
var init_generateTextStyleKey = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs"() {
    valuesToIterateForKeys = [
      "_fontFamily",
      "_fontStyle",
      "_fontVariant",
      "_fontWeight",
      "_breakWords",
      "_align",
      "_leading",
      "_letterSpacing",
      "_lineHeight",
      "_textBaseline",
      "_whiteSpace",
      "_wordWrap",
      "_wordWrapWidth",
      "_padding",
      "_cssOverrides"
    ];
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/TextStyle.mjs
function convertV7Tov8Style(style) {
  const oldStyle = style;
  if (typeof oldStyle.dropShadow === "boolean") {
    deprecation(v8_0_0, "dropShadow is now an object, not a boolean");
    style.dropShadow = {
      alpha: oldStyle.dropShadowAlpha ?? 1,
      angle: oldStyle.dropShadowAngle,
      blur: oldStyle.dropShadowBlur ?? 0,
      color: oldStyle.dropShadowColor,
      distance: oldStyle.dropShadowDistance
    };
  }
  if (oldStyle.strokeThickness) {
    deprecation(v8_0_0, "strokeThickness is now a part of stroke");
    const color = oldStyle.stroke;
    style.stroke = {
      color,
      width: oldStyle.strokeThickness
    };
  }
  if (Array.isArray(oldStyle.fill)) {
    deprecation(v8_0_0, "gradient fill is now a fill pattern: `new FillGradient(...)`");
    const gradientFill = new FillGradient(0, 0, 0, style.fontSize * 1.7);
    const fills = oldStyle.fill.map((color) => Color.shared.setValue(color).toNumber());
    fills.forEach((number, index) => {
      const ratio = oldStyle.fillGradientStops[index] ?? index / fills.length;
      gradientFill.addColorStop(ratio, number);
    });
    style.fill = {
      fill: gradientFill
    };
  }
}
var _TextStyle, TextStyle;
var init_TextStyle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/TextStyle.mjs"() {
    init_eventemitter3();
    init_Color();
    init_deprecation();
    init_FillGradient();
    init_GraphicsContext();
    init_convertFillInputToFillStyle();
    init_generateTextStyleKey();
    _TextStyle = class extends eventemitter3_default {
      constructor(style = {}) {
        super();
        convertV7Tov8Style(style);
        const fullStyle = { ..._TextStyle.defaultTextStyle, ...style };
        for (const key2 in _TextStyle.defaultTextStyle) {
          const thisKey = key2;
          this[thisKey] = fullStyle[key2];
        }
        this.dropShadow = null;
        if (typeof fullStyle.fill === "string") {
          this.fontSize = parseInt(fullStyle.fontSize, 10);
        } else {
          this.fontSize = fullStyle.fontSize;
        }
        if (style.dropShadow) {
          if (style.dropShadow instanceof Boolean) {
            if (style.dropShadow === true) {
              this.dropShadow = {
                ..._TextStyle.defaultTextStyle.dropShadow
              };
            }
          } else {
            this.dropShadow = {
              ..._TextStyle.defaultTextStyle.dropShadow,
              ...style.dropShadow
            };
          }
        }
        this.update();
      }
      get align() {
        return this._align;
      }
      set align(value) {
        this._align = value;
        this.update();
      }
      get breakWords() {
        return this._breakWords;
      }
      set breakWords(value) {
        this._breakWords = value;
        this.update();
      }
      get dropShadow() {
        return this._dropShadow;
      }
      set dropShadow(value) {
        this._dropShadow = value;
        this.update();
      }
      get fontFamily() {
        return this._fontFamily;
      }
      set fontFamily(value) {
        this._fontFamily = value;
        this.update();
      }
      get fontSize() {
        return this._fontSize;
      }
      set fontSize(value) {
        this._fontSize = value;
        this.update();
      }
      get fontStyle() {
        return this._fontStyle;
      }
      set fontStyle(value) {
        this._fontStyle = value;
        this.update();
      }
      get fontVariant() {
        return this._fontVariant;
      }
      set fontVariant(value) {
        this._fontVariant = value;
        this.update();
      }
      get fontWeight() {
        return this._fontWeight;
      }
      set fontWeight(value) {
        this._fontWeight = value;
        this.update();
      }
      get leading() {
        return this._leading;
      }
      set leading(value) {
        this._leading = value;
        this.update();
      }
      get letterSpacing() {
        return this._letterSpacing;
      }
      set letterSpacing(value) {
        this._letterSpacing = value;
        this.update();
      }
      get lineHeight() {
        return this._lineHeight;
      }
      set lineHeight(value) {
        this._lineHeight = value;
        this.update();
      }
      get padding() {
        return this._padding;
      }
      set padding(value) {
        this._padding = value;
        this.update();
      }
      get textBaseline() {
        return this._textBaseline;
      }
      set textBaseline(value) {
        this._textBaseline = value;
        this.update();
      }
      get whiteSpace() {
        return this._whiteSpace;
      }
      set whiteSpace(value) {
        this._whiteSpace = value;
        this.update();
      }
      get wordWrap() {
        return this._wordWrap;
      }
      set wordWrap(value) {
        this._wordWrap = value;
        this.update();
      }
      get wordWrapWidth() {
        return this._wordWrapWidth;
      }
      set wordWrapWidth(value) {
        this._wordWrapWidth = value;
        this.update();
      }
      get fill() {
        return this._originalFill;
      }
      set fill(value) {
        if (value === this._originalFill)
          return;
        this._originalFill = value;
        this._fill = convertFillInputToFillStyle(value, GraphicsContext.defaultFillStyle);
        this.update();
      }
      get stroke() {
        return this._originalStroke;
      }
      set stroke(value) {
        if (value === this._originalFill)
          return;
        this._originalFill = value;
        this._stroke = convertFillInputToFillStyle(value, GraphicsContext.defaultStrokeStyle);
        this.update();
      }
      _generateKey() {
        this._styleKey = generateTextStyleKey(this);
        return this._styleKey;
      }
      update() {
        this._styleKey = null;
        this.emit("update", this);
      }
      get styleKey() {
        return this._styleKey || this._generateKey();
      }
      clone() {
        return new _TextStyle({
          align: this.align,
          breakWords: this.breakWords,
          dropShadow: this.dropShadow,
          fill: this._fill,
          fontFamily: this.fontFamily,
          fontSize: this.fontSize,
          fontStyle: this.fontStyle,
          fontVariant: this.fontVariant,
          fontWeight: this.fontWeight,
          leading: this.leading,
          letterSpacing: this.letterSpacing,
          lineHeight: this.lineHeight,
          padding: this.padding,
          stroke: this._stroke,
          textBaseline: this.textBaseline,
          whiteSpace: this.whiteSpace,
          wordWrap: this.wordWrap,
          wordWrapWidth: this.wordWrapWidth
        });
      }
      /**
       * Destroys this text style.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style
       * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style
       */
      destroy(options = false) {
        this.removeAllListeners();
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          if (this._fill?.texture) {
            this._fill.texture.destroy(destroyTextureSource);
          }
          if (this._originalFill?.texture) {
            this._originalFill.texture.destroy(destroyTextureSource);
          }
          if (this._stroke?.texture) {
            this._stroke.texture.destroy(destroyTextureSource);
          }
          if (this._originalStroke?.texture) {
            this._originalStroke.texture.destroy(destroyTextureSource);
          }
        }
        this._fill = null;
        this._stroke = null;
        this.dropShadow = null;
        this._originalStroke = null;
        this._originalFill = null;
      }
    };
    TextStyle = _TextStyle;
    TextStyle.defaultTextStyle = {
      /**
       * See {@link TextStyle.align}
       * @type {'left'|'center'|'right'|'justify'}
       */
      align: "left",
      /** See {@link TextStyle.breakWords} */
      breakWords: false,
      /** See {@link TextStyle.dropShadow} */
      dropShadow: {
        alpha: 1,
        angle: Math.PI / 6,
        blur: 0,
        color: "black",
        distance: 5
      },
      /**
       * See {@link TextStyle.fill}
       * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
       */
      fill: "black",
      /**
       * See {@link TextStyle.fontFamily}
       * @type {string|string[]}
       */
      fontFamily: "Arial",
      /**
       * See {@link TextStyle.fontSize}
       * @type {number|string}
       */
      fontSize: 26,
      /**
       * See {@link TextStyle.fontStyle}
       * @type {'normal'|'italic'|'oblique'}
       */
      fontStyle: "normal",
      /**
       * See {@link TextStyle.fontVariant}
       * @type {'normal'|'small-caps'}
       */
      fontVariant: "normal",
      /**
       * See {@link TextStyle.fontWeight}
       * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
       */
      fontWeight: "normal",
      /** See {@link TextStyle.leading} */
      leading: 0,
      /** See {@link TextStyle.letterSpacing} */
      letterSpacing: 0,
      /** See {@link TextStyle.lineHeight} */
      lineHeight: 0,
      /** See {@link TextStyle.padding} */
      padding: 0,
      /**
       * See {@link TextStyle.stroke}
       * @type {string|number}
       */
      stroke: null,
      /**
       * See {@link TextStyle.textBaseline}
       * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
       */
      textBaseline: "alphabetic",
      /** See {@link TextStyle.trim} */
      trim: false,
      /**
       * See {@link TextStyle.whiteSpace}
       * @type {'normal'|'pre'|'pre-line'}
       */
      whiteSpace: "pre",
      /** See {@link TextStyle.wordWrap} */
      wordWrap: false,
      /** See {@link TextStyle.wordWrapWidth} */
      wordWrapWidth: 100
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs
var CanvasPoolClass, CanvasPool;
var init_CanvasPool = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs"() {
    init_pow2();
    init_settings();
    CanvasPoolClass = class {
      constructor(canvasOptions) {
        this._canvasPool = /* @__PURE__ */ Object.create(null);
        this.canvasOptions = canvasOptions || {};
        this.enableFullScreen = false;
      }
      /**
       * Creates texture with params that were specified in pool constructor.
       * @param pixelWidth - Width of texture in pixels.
       * @param pixelHeight - Height of texture in pixels.
       */
      _createCanvasAndContext(pixelWidth, pixelHeight) {
        const canvas3 = settings.ADAPTER.createCanvas();
        canvas3.width = pixelWidth;
        canvas3.height = pixelHeight;
        const context4 = canvas3.getContext("2d");
        return { canvas: canvas3, context: context4 };
      }
      /**
       * Gets a Power-of-Two render texture or fullScreen texture
       * @param minWidth - The minimum width of the render texture.
       * @param minHeight - The minimum height of the render texture.
       * @param resolution - The resolution of the render texture.
       * @returns The new render texture.
       */
      getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {
        minWidth = Math.ceil(minWidth * resolution - 1e-6);
        minHeight = Math.ceil(minHeight * resolution - 1e-6);
        minWidth = nextPow2(minWidth);
        minHeight = nextPow2(minHeight);
        const key2 = (minWidth << 17) + (minHeight << 1);
        if (!this._canvasPool[key2]) {
          this._canvasPool[key2] = [];
        }
        let canvasAndContext = this._canvasPool[key2].pop();
        if (!canvasAndContext) {
          canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);
        }
        return canvasAndContext;
      }
      /**
       * Place a render texture back into the pool.
       * @param canvasAndContext
       */
      returnCanvasAndContext(canvasAndContext) {
        const { width, height } = canvasAndContext.canvas;
        const key2 = (width << 17) + (height << 1);
        this._canvasPool[key2].push(canvasAndContext);
      }
      clear() {
        this._canvasPool = {};
      }
    };
    CanvasPool = new CanvasPoolClass();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs
function fontStringFromTextStyle(style) {
  const fontSizeString = typeof style.fontSize === "number" ? `${style.fontSize}px` : style.fontSize;
  let fontFamilies = style.fontFamily;
  if (!Array.isArray(style.fontFamily)) {
    fontFamilies = style.fontFamily.split(",");
  }
  for (let i3 = fontFamilies.length - 1; i3 >= 0; i3--) {
    let fontFamily = fontFamilies[i3].trim();
    if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
      fontFamily = `"${fontFamily}"`;
    }
    fontFamilies[i3] = fontFamily;
  }
  return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
}
var genericFontFamilies;
var init_fontStringFromTextStyle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs"() {
    genericFontFamilies = [
      "serif",
      "sans-serif",
      "monospace",
      "cursive",
      "fantasy",
      "system-ui"
    ];
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs
var contextSettings, _CanvasTextMetrics, CanvasTextMetrics;
var init_CanvasTextMetrics = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs"() {
    init_settings();
    init_fontStringFromTextStyle();
    contextSettings = {
      // TextMetrics requires getImageData readback for measuring fonts.
      willReadFrequently: true
    };
    _CanvasTextMetrics = class {
      /**
       * Checking that we can use modern canvas 2D API.
       *
       * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.
       * @see TextMetrics.experimentalLetterSpacing
       * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing
       * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441
       */
      static get experimentalLetterSpacingSupported() {
        let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;
        if (result !== void 0) {
          const proto = settings.ADAPTER.getCanvasRenderingContext2D().prototype;
          result = _CanvasTextMetrics._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
        }
        return result;
      }
      /**
       * @param text - the text that was measured
       * @param style - the style that was measured
       * @param width - the measured width of the text
       * @param height - the measured height of the text
       * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style
       * @param lineWidths - an array of the line widths for each line matched to `lines`
       * @param lineHeight - the measured line height for this style
       * @param maxLineWidth - the maximum line width for all measured lines
       * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont
       */
      constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
        this.text = text;
        this.style = style;
        this.width = width;
        this.height = height;
        this.lines = lines;
        this.lineWidths = lineWidths;
        this.lineHeight = lineHeight;
        this.maxLineWidth = maxLineWidth;
        this.fontProperties = fontProperties;
      }
      /**
       * Measures the supplied string of text and returns a Rectangle.
       * @param text - The text to measure.
       * @param style - The text style to use for measuring
       * @param canvas - optional specification of the canvas to use for measuring.
       * @param wordWrap
       * @returns Measured width and height of the text.
       */
      static measureText(text = " ", style, canvas3 = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {
        const textKey = `${text}:${style.styleKey}`;
        if (_CanvasTextMetrics._measurementCache[textKey])
          return _CanvasTextMetrics._measurementCache[textKey];
        const font = fontStringFromTextStyle(style);
        const fontProperties = _CanvasTextMetrics.measureFont(font);
        if (fontProperties.fontSize === 0) {
          fontProperties.fontSize = style.fontSize;
          fontProperties.ascent = style.fontSize;
        }
        const context4 = _CanvasTextMetrics.__context;
        context4.font = font;
        const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas3) : text;
        const lines = outputText.split(/(?:\r\n|\r|\n)/);
        const lineWidths = new Array(lines.length);
        let maxLineWidth = 0;
        for (let i3 = 0; i3 < lines.length; i3++) {
          const lineWidth = _CanvasTextMetrics._measureText(lines[i3], style.letterSpacing, context4);
          lineWidths[i3] = lineWidth;
          maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        const strokeWidth = style._stroke?.width || 0;
        let width = maxLineWidth + strokeWidth;
        if (style.dropShadow) {
          width += style.dropShadow.distance;
        }
        const lineHeight = style.lineHeight || fontProperties.fontSize + strokeWidth;
        let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth * 2) + (lines.length - 1) * (lineHeight + style.leading);
        if (style.dropShadow) {
          height += style.dropShadow.distance;
        }
        const measurements = new _CanvasTextMetrics(
          text,
          style,
          width,
          height,
          lines,
          lineWidths,
          lineHeight + style.leading,
          maxLineWidth,
          fontProperties
        );
        return measurements;
      }
      static _measureText(text, letterSpacing, context4) {
        let useExperimentalLetterSpacing = false;
        if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {
          if (_CanvasTextMetrics.experimentalLetterSpacing) {
            context4.letterSpacing = `${letterSpacing}px`;
            context4.textLetterSpacing = `${letterSpacing}px`;
            useExperimentalLetterSpacing = true;
          } else {
            context4.letterSpacing = "0px";
            context4.textLetterSpacing = "0px";
          }
        }
        let width = context4.measureText(text).width;
        if (width > 0) {
          if (useExperimentalLetterSpacing) {
            width -= letterSpacing;
          } else {
            width += (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;
          }
        }
        return width;
      }
      /**
       * Applies newlines to a string to have it optimally fit into the horizontal
       * bounds set by the Text object's wordWrapWidth property.
       * @param text - String to apply word wrapping to
       * @param style - the style to use when wrapping
       * @param canvas - optional specification of the canvas to use for measuring.
       * @returns New string with new lines applied where required
       */
      static _wordWrap(text, style, canvas3 = _CanvasTextMetrics._canvas) {
        const context4 = canvas3.getContext("2d", contextSettings);
        let width = 0;
        let line = "";
        let lines = "";
        const cache = /* @__PURE__ */ Object.create(null);
        const { letterSpacing, whiteSpace } = style;
        const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);
        const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);
        let canPrependSpaces = !collapseSpaces;
        const wordWrapWidth = style.wordWrapWidth + letterSpacing;
        const tokens = _CanvasTextMetrics._tokenize(text);
        for (let i3 = 0; i3 < tokens.length; i3++) {
          let token = tokens[i3];
          if (_CanvasTextMetrics._isNewline(token)) {
            if (!collapseNewlines) {
              lines += _CanvasTextMetrics._addLine(line);
              canPrependSpaces = !collapseSpaces;
              line = "";
              width = 0;
              continue;
            }
            token = " ";
          }
          if (collapseSpaces) {
            const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);
            const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);
            if (currIsBreakingSpace && lastIsBreakingSpace) {
              continue;
            }
          }
          const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context4);
          if (tokenWidth > wordWrapWidth) {
            if (line !== "") {
              lines += _CanvasTextMetrics._addLine(line);
              line = "";
              width = 0;
            }
            if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {
              const characters = _CanvasTextMetrics.wordWrapSplit(token);
              for (let j3 = 0; j3 < characters.length; j3++) {
                let char = characters[j3];
                let lastChar = char;
                let k3 = 1;
                while (characters[j3 + k3]) {
                  const nextChar = characters[j3 + k3];
                  if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j3, style.breakWords)) {
                    char += nextChar;
                  } else {
                    break;
                  }
                  lastChar = nextChar;
                  k3++;
                }
                j3 += k3 - 1;
                const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context4);
                if (characterWidth + width > wordWrapWidth) {
                  lines += _CanvasTextMetrics._addLine(line);
                  canPrependSpaces = false;
                  line = "";
                  width = 0;
                }
                line += char;
                width += characterWidth;
              }
            } else {
              if (line.length > 0) {
                lines += _CanvasTextMetrics._addLine(line);
                line = "";
                width = 0;
              }
              const isLastToken = i3 === tokens.length - 1;
              lines += _CanvasTextMetrics._addLine(token, !isLastToken);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
          } else {
            if (tokenWidth + width > wordWrapWidth) {
              canPrependSpaces = false;
              lines += _CanvasTextMetrics._addLine(line);
              line = "";
              width = 0;
            }
            if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {
              line += token;
              width += tokenWidth;
            }
          }
        }
        lines += _CanvasTextMetrics._addLine(line, false);
        return lines;
      }
      /**
       * Convienience function for logging each line added during the wordWrap method.
       * @param line    - The line of text to add
       * @param newLine - Add new line character to end
       * @returns A formatted line
       */
      static _addLine(line, newLine = true) {
        line = _CanvasTextMetrics._trimRight(line);
        line = newLine ? `${line}
` : line;
        return line;
      }
      /**
       * Gets & sets the widths of calculated characters in a cache object
       * @param key            - The key
       * @param letterSpacing  - The letter spacing
       * @param cache          - The cache
       * @param context        - The canvas context
       * @returns The from cache.
       */
      static _getFromCache(key2, letterSpacing, cache, context4) {
        let width = cache[key2];
        if (typeof width !== "number") {
          width = _CanvasTextMetrics._measureText(key2, letterSpacing, context4) + letterSpacing;
          cache[key2] = width;
        }
        return width;
      }
      /**
       * Determines whether we should collapse breaking spaces.
       * @param whiteSpace - The TextStyle property whiteSpace
       * @returns Should collapse
       */
      static _collapseSpaces(whiteSpace) {
        return whiteSpace === "normal" || whiteSpace === "pre-line";
      }
      /**
       * Determines whether we should collapse newLine chars.
       * @param whiteSpace - The white space
       * @returns should collapse
       */
      static _collapseNewlines(whiteSpace) {
        return whiteSpace === "normal";
      }
      /**
       * Trims breaking whitespaces from string.
       * @param text - The text
       * @returns Trimmed string
       */
      static _trimRight(text) {
        if (typeof text !== "string") {
          return "";
        }
        for (let i3 = text.length - 1; i3 >= 0; i3--) {
          const char = text[i3];
          if (!_CanvasTextMetrics.isBreakingSpace(char)) {
            break;
          }
          text = text.slice(0, -1);
        }
        return text;
      }
      /**
       * Determines if char is a newline.
       * @param char - The character
       * @returns True if newline, False otherwise.
       */
      static _isNewline(char) {
        if (typeof char !== "string") {
          return false;
        }
        return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));
      }
      /**
       * Determines if char is a breaking whitespace.
       *
       * It allows one to determine whether char should be a breaking whitespace
       * For example certain characters in CJK langs or numbers.
       * It must return a boolean.
       * @param char - The character
       * @param [_nextChar] - The next character
       * @returns True if whitespace, False otherwise.
       */
      static isBreakingSpace(char, _nextChar) {
        if (typeof char !== "string") {
          return false;
        }
        return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));
      }
      /**
       * Splits a string into words, breaking-spaces and newLine characters
       * @param text - The text
       * @returns A tokenized array
       */
      static _tokenize(text) {
        const tokens = [];
        let token = "";
        if (typeof text !== "string") {
          return tokens;
        }
        for (let i3 = 0; i3 < text.length; i3++) {
          const char = text[i3];
          const nextChar = text[i3 + 1];
          if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {
            if (token !== "") {
              tokens.push(token);
              token = "";
            }
            tokens.push(char);
            continue;
          }
          token += char;
        }
        if (token !== "") {
          tokens.push(token);
        }
        return tokens;
      }
      /**
       * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
       *
       * It allows one to customise which words should break
       * Examples are if the token is CJK or numbers.
       * It must return a boolean.
       * @param _token - The token
       * @param breakWords - The style attr break words
       * @returns Whether to break word or not
       */
      static canBreakWords(_token, breakWords) {
        return breakWords;
      }
      /**
       * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
       *
       * It allows one to determine whether a pair of characters
       * should be broken by newlines
       * For example certain characters in CJK langs or numbers.
       * It must return a boolean.
       * @param _char - The character
       * @param _nextChar - The next character
       * @param _token - The token/word the characters are from
       * @param _index - The index in the token of the char
       * @param _breakWords - The style attr break words
       * @returns whether to break word or not
       */
      static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
        return true;
      }
      /**
       * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
       *
       * It is called when a token (usually a word) has to be split into separate pieces
       * in order to determine the point to break a word.
       * It must return an array of characters.
       * @param token - The token to split
       * @returns The characters of the token
       * @see CanvasTextMetrics.graphemeSegmenter
       */
      static wordWrapSplit(token) {
        return _CanvasTextMetrics.graphemeSegmenter(token);
      }
      /**
       * Calculates the ascent, descent and fontSize of a given font-style
       * @param font - String representing the style of the font
       * @returns Font properties object
       */
      static measureFont(font) {
        if (_CanvasTextMetrics._fonts[font]) {
          return _CanvasTextMetrics._fonts[font];
        }
        const context4 = _CanvasTextMetrics._context;
        context4.font = font;
        const metrics = context4.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);
        const properties = {
          ascent: metrics.actualBoundingBoxAscent,
          descent: metrics.actualBoundingBoxDescent,
          fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
        };
        _CanvasTextMetrics._fonts[font] = properties;
        return properties;
      }
      /**
       * Clear font metrics in metrics cache.
       * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
       */
      static clearMetrics(font = "") {
        if (font) {
          delete _CanvasTextMetrics._fonts[font];
        } else {
          _CanvasTextMetrics._fonts = {};
        }
      }
      /**
       * Cached canvas element for measuring text
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      static get _canvas() {
        if (!_CanvasTextMetrics.__canvas) {
          let canvas3;
          try {
            const c2 = new OffscreenCanvas(0, 0);
            const context4 = c2.getContext("2d", contextSettings);
            if (context4?.measureText) {
              _CanvasTextMetrics.__canvas = c2;
              return c2;
            }
            canvas3 = settings.ADAPTER.createCanvas();
          } catch (ex) {
            canvas3 = settings.ADAPTER.createCanvas();
          }
          canvas3.width = canvas3.height = 10;
          _CanvasTextMetrics.__canvas = canvas3;
        }
        return _CanvasTextMetrics.__canvas;
      }
      /**
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      static get _context() {
        if (!_CanvasTextMetrics.__context) {
          _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext("2d", contextSettings);
        }
        return _CanvasTextMetrics.__context;
      }
    };
    CanvasTextMetrics = _CanvasTextMetrics;
    CanvasTextMetrics.METRICS_STRING = "|\xC9q\xC5";
    CanvasTextMetrics.BASELINE_SYMBOL = "M";
    CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;
    CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;
    CanvasTextMetrics.graphemeSegmenter = (() => {
      if (typeof Intl?.Segmenter === "function") {
        const segmenter = new Intl.Segmenter();
        return (s2) => [...segmenter.segment(s2)].map((x3) => x3.segment);
      }
      return (s2) => [...s2];
    })();
    CanvasTextMetrics.experimentalLetterSpacing = false;
    CanvasTextMetrics._fonts = {};
    CanvasTextMetrics._newlines = [
      10,
      // line feed
      13
      // carriage return
    ];
    CanvasTextMetrics._breakingSpaces = [
      9,
      // character tabulation
      32,
      // space
      8192,
      // en quad
      8193,
      // em quad
      8194,
      // en space
      8195,
      // em space
      8196,
      // three-per-em space
      8197,
      // four-per-em space
      8198,
      // six-per-em space
      8200,
      // punctuation space
      8201,
      // thin space
      8202,
      // hair space
      8287,
      // medium mathematical space
      12288
      // ideographic space
    ];
    CanvasTextMetrics._measurementCache = {};
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs
function getCanvasFillStyle(fillStyle, context4) {
  if (fillStyle.texture === Texture.WHITE && !fillStyle.fill) {
    return Color.shared.setValue(fillStyle.color).toHex();
  } else if (!fillStyle.fill) {
    const pattern = context4.createPattern(fillStyle.texture.source.resource, "repeat");
    const tempMatrix9 = fillStyle.matrix.copyTo(Matrix.shared);
    tempMatrix9.scale(fillStyle.texture.frameWidth, fillStyle.texture.frameHeight);
    pattern.setTransform(tempMatrix9);
    return pattern;
  } else if (fillStyle.fill instanceof FillPattern) {
    const fillPattern = fillStyle.fill;
    const pattern = context4.createPattern(fillPattern.texture.source.resource, "repeat");
    const tempMatrix9 = fillPattern.transform.copyTo(Matrix.shared);
    tempMatrix9.scale(fillPattern.texture.frameWidth, fillPattern.texture.frameHeight);
    pattern.setTransform(tempMatrix9);
    return pattern;
  } else if (fillStyle.fill instanceof FillGradient) {
    const fillGradient = fillStyle.fill;
    if (fillGradient.type === "linear") {
      const gradient = context4.createLinearGradient(
        fillGradient.x0,
        fillGradient.y0,
        fillGradient.x1,
        fillGradient.y1
      );
      fillGradient.gradientStops.forEach((stop) => {
        gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());
      });
      return gradient;
    }
  }
  warn("FillStyle not recognised", fillStyle);
  return "red";
}
var init_getCanvasFillStyle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs"() {
    init_Color();
    init_Matrix();
    init_Texture();
    init_warn();
    init_FillGradient();
    init_FillPattern();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/bitmap/utils/resolveCharacters.mjs
function resolveCharacters(chars) {
  if (chars === "") {
    return [];
  }
  if (typeof chars === "string") {
    chars = [chars];
  }
  const result = [];
  for (let i3 = 0, j3 = chars.length; i3 < j3; i3++) {
    const item = chars[i3];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
      }
      if (item[0].length === 0 || item[1].length === 0) {
        throw new Error("[BitmapFont]: Invalid character delimiter.");
      }
      const startCode = item[0].charCodeAt(0);
      const endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (let i22 = startCode, j22 = endCode; i22 <= j22; i22++) {
        result.push(String.fromCharCode(i22));
      }
    } else {
      result.push(...Array.from(item));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
}
var init_resolveCharacters = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/bitmap/utils/resolveCharacters.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/bitmap/DynamicBitmapFont.mjs
var DynamicBitmapFont;
var init_DynamicBitmapFont = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/bitmap/DynamicBitmapFont.mjs"() {
    init_Color();
    init_Rectangle();
    init_CanvasPool();
    init_ImageSource();
    init_Texture();
    init_deprecation();
    init_CanvasTextMetrics();
    init_fontStringFromTextStyle();
    init_getCanvasFillStyle();
    init_AbstractBitmapFont();
    init_resolveCharacters();
    DynamicBitmapFont = class extends AbstractBitmapFont {
      constructor(options) {
        super();
        this.resolution = 1;
        this.pages = [];
        this._padding = 4;
        this._measureCache = /* @__PURE__ */ Object.create(null);
        this._currentChars = [];
        this._currentX = 0;
        this._currentY = 0;
        this._currentPageIndex = -1;
        this._skipKerning = false;
        const dynamicOptions = options;
        const style = dynamicOptions.style.clone();
        style.fontSize = this.baseMeasurementFontSize;
        if (dynamicOptions.overrideFill) {
          style._fill.color = 16777215;
          style._fill.alpha = 1;
          style._fill.texture = Texture.WHITE;
          style._fill.fill = null;
        }
        this._style = style;
        this._skipKerning = dynamicOptions.skipKerning ?? false;
        this.resolution = dynamicOptions.resolution ?? 1;
        this._padding = dynamicOptions.padding ?? 4;
        const font = fontStringFromTextStyle(style);
        const writable = this;
        writable.fontMetrics = CanvasTextMetrics.measureFont(font);
        writable.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;
      }
      ensureCharacters(chars) {
        const charList = resolveCharacters(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self2) => self2.indexOf(char) === index);
        if (!charList.length)
          return;
        this._currentChars = [...this._currentChars, ...charList];
        let pageData;
        if (this._currentPageIndex === -1) {
          pageData = this._nextPage();
        } else {
          pageData = this.pages[this._currentPageIndex];
        }
        let { canvas: canvas3, context: context4 } = pageData.canvasAndContext;
        let textureSource = pageData.texture.source;
        const style = this._style;
        let currentX = this._currentX;
        let currentY = this._currentY;
        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;
        const padding = this._padding * fontScale;
        const widthScale = style.fontStyle === "italic" ? 2 : 1;
        let maxCharHeight = 0;
        let skipTexture = false;
        for (let i3 = 0; i3 < charList.length; i3++) {
          const char = charList[i3];
          const metrics = CanvasTextMetrics.measureText(char, style, canvas3, false);
          const width = widthScale * metrics.width * fontScale;
          const height = metrics.height * fontScale;
          const paddedWidth = width + padding * 2;
          const paddedHeight = height + padding * 2;
          skipTexture = false;
          if (char !== "\n" && char !== "\r" && char !== "	" && char !== " ") {
            skipTexture = true;
            maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));
          }
          if (currentX + paddedWidth > 512) {
            currentY += maxCharHeight;
            maxCharHeight = paddedHeight;
            currentX = 0;
            if (currentY + maxCharHeight > 512) {
              textureSource.update();
              const pageData2 = this._nextPage();
              canvas3 = pageData2.canvasAndContext.canvas;
              context4 = pageData2.canvasAndContext.context;
              textureSource = pageData2.texture.source;
              currentY = 0;
            }
          }
          const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);
          this.chars[char] = {
            id: char.codePointAt(0),
            xOffset: -this._padding,
            yOffset: -this._padding,
            xAdvance,
            kerning: {}
          };
          if (skipTexture) {
            this._drawGlyph(
              context4,
              metrics,
              currentX + padding,
              currentY + padding,
              fontScale,
              style
            );
            const px = textureSource.width * fontScale;
            const py = textureSource.height * fontScale;
            const frame = new Rectangle(
              currentX / px,
              currentY / py,
              paddedWidth / px,
              paddedHeight / py
            );
            this.chars[char].texture = new Texture({
              source: textureSource,
              layout: {
                frame
              }
            });
            currentX += Math.ceil(paddedWidth);
          }
        }
        textureSource.update();
        this._currentX = currentX;
        this._currentY = currentY;
        this._skipKerning && this._applyKerning(charList, context4);
      }
      /**
       * @deprecated since 8.0.0
       * The map of base page textures (i.e., sheets of glyphs).
       */
      get pageTextures() {
        deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
        return this.pages;
      }
      _applyKerning(newChars, context4) {
        const measureCache = this._measureCache;
        for (let i3 = 0; i3 < newChars.length; i3++) {
          const first = newChars[i3];
          for (let j3 = 0; j3 < this._currentChars.length; j3++) {
            const second = this._currentChars[j3];
            let c1 = measureCache[first];
            if (!c1)
              c1 = measureCache[first] = context4.measureText(first).width;
            let c2 = measureCache[second];
            if (!c2)
              c2 = measureCache[second] = context4.measureText(second).width;
            let total = context4.measureText(first + second).width;
            let amount = total - (c1 + c2);
            if (amount) {
              this.chars[first].kerning[second] = amount;
            }
            total = context4.measureText(first + second).width;
            amount = total - (c1 + c2);
            if (amount) {
              this.chars[second].kerning[first] = amount;
            }
          }
        }
      }
      _nextPage() {
        this._currentPageIndex++;
        const textureResolution = this.resolution;
        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(512, 512, textureResolution);
        this._setupContext(canvasAndContext.context, this._style, textureResolution);
        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);
        const texture = new Texture({
          source: new ImageSource({
            resource: canvasAndContext.canvas,
            resolution,
            alphaMode: "premultiply-alpha-on-upload"
          })
        });
        const pageData = {
          canvasAndContext,
          texture
        };
        this.pages[this._currentPageIndex] = pageData;
        return pageData;
      }
      // canvas style!
      _setupContext(context4, style, resolution) {
        style.fontSize = this.baseRenderedFontSize;
        context4.scale(resolution, resolution);
        context4.font = fontStringFromTextStyle(style);
        style.fontSize = this.baseMeasurementFontSize;
        context4.textBaseline = style.textBaseline;
        const stroke = style._stroke;
        const strokeThickness = stroke?.width ?? 0;
        if (stroke) {
          context4.lineWidth = strokeThickness;
          context4.lineJoin = stroke.join;
          context4.miterLimit = stroke.miterLimit;
          context4.strokeStyle = getCanvasFillStyle(stroke, context4);
        }
        if (style._fill) {
          context4.fillStyle = getCanvasFillStyle(style._fill, context4);
        }
        if (style.dropShadow) {
          const shadowOptions = style.dropShadow;
          const rgb = Color.shared.setValue(shadowOptions.color).toArray();
          const dropShadowBlur = shadowOptions.blur * resolution;
          const dropShadowDistance = shadowOptions.distance * resolution;
          context4.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;
          context4.shadowBlur = dropShadowBlur;
          context4.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
          context4.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;
        } else {
          context4.shadowColor = "black";
          context4.shadowBlur = 0;
          context4.shadowOffsetX = 0;
          context4.shadowOffsetY = 0;
        }
      }
      _drawGlyph(context4, metrics, x3, y2, fontScale, style) {
        const char = metrics.text;
        const fontProperties = metrics.fontProperties;
        const stroke = style._stroke;
        const strokeThickness = (stroke?.width ?? 0) * fontScale;
        const tx = x3 + strokeThickness / 2;
        const ty = y2 - strokeThickness / 2;
        const descent = fontProperties.descent * fontScale;
        const lineHeight = metrics.lineHeight * fontScale;
        if (style.stroke && strokeThickness) {
          context4.strokeText(char, tx, ty + lineHeight - descent);
        }
        if (style._fill) {
          context4.fillText(char, tx, ty + lineHeight - descent);
        }
      }
      destroy() {
        super.destroy();
        for (let i3 = 0; i3 < this.pages.length; i3++) {
          const { canvasAndContext, texture } = this.pages[i3];
          CanvasPool.returnCanvasAndContext(canvasAndContext);
          texture.destroy(true);
        }
        this.pages = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/bitmap/utils/getBitmapTextLayout.mjs
function getBitmapTextLayout(chars, style, font) {
  const layoutData = {
    width: 0,
    height: 0,
    offsetY: 0,
    scale: style.fontSize / font.baseMeasurementFontSize,
    lines: [{
      width: 0,
      charPositions: [],
      spaceWidth: 0,
      spacesIndex: [],
      chars: []
    }]
  };
  layoutData.offsetY = font.baseLineOffset;
  let currentLine = layoutData.lines[0];
  let previousChar = null;
  let firstWord = true;
  const currentWord = {
    spaceWord: false,
    width: 0,
    start: 0,
    index: 0,
    // use index to not modify the array as we use it a lot!
    positions: [],
    chars: []
  };
  const nextWord = (word) => {
    const start = currentLine.width;
    for (let j3 = 0; j3 < currentWord.index; j3++) {
      const position = word.positions[j3];
      currentLine.chars.push(word.chars[j3]);
      currentLine.charPositions.push(position + start);
    }
    currentLine.width += word.width;
    firstWord = false;
    currentWord.width = 0;
    currentWord.index = 0;
    currentWord.chars.length = 0;
  };
  const nextLine = () => {
    let index = currentLine.chars.length - 1;
    let lastChar = currentLine.chars[index];
    while (lastChar === " ") {
      currentLine.width -= font.chars[lastChar].xAdvance;
      lastChar = currentLine.chars[--index];
    }
    layoutData.width = Math.max(layoutData.width, currentLine.width);
    currentLine = {
      width: 0,
      charPositions: [],
      chars: [],
      spaceWidth: 0,
      spacesIndex: []
    };
    firstWord = true;
    layoutData.lines.push(currentLine);
    layoutData.height += font.lineHeight;
  };
  const scale3 = font.baseMeasurementFontSize / style.fontSize;
  const adjustedLetterSpacing = style.letterSpacing * scale3;
  const adjustedWordWrapWidth = style.wordWrapWidth * scale3;
  for (let i3 = 0; i3 < chars.length + 1; i3++) {
    let char;
    const isEnd = i3 === chars.length;
    if (!isEnd) {
      char = chars[i3];
    }
    const charData = font.chars[char];
    const isSpace = /(?:\s)/.test(char);
    const isWordBreak = isSpace || char === "\r" || char === "\n" || isEnd;
    if (isWordBreak) {
      const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;
      if (addWordToNextLine) {
        nextLine();
        nextWord(currentWord);
        if (!isEnd) {
          currentLine.charPositions.push(0);
        }
      } else {
        currentWord.start = currentLine.width;
        nextWord(currentWord);
        if (!isEnd) {
          currentLine.charPositions.push(0);
        }
      }
      if (char === "\r" || char === "\n") {
        if (currentLine.width !== 0) {
          nextLine();
        }
      } else if (!isEnd) {
        const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;
        currentLine.width += spaceWidth;
        currentLine.spaceWidth = spaceWidth;
        currentLine.spacesIndex.push(currentLine.charPositions.length);
        currentLine.chars.push(char);
      }
    } else {
      const kerning = charData.kerning[previousChar] || 0;
      const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;
      currentWord.positions[currentWord.index++] = currentWord.width + kerning;
      currentWord.chars.push(char);
      currentWord.width += nextCharWidth;
    }
    previousChar = char;
  }
  nextLine();
  if (style.align === "center") {
    alignCenter(layoutData);
  } else if (style.align === "right") {
    alignRight(layoutData);
  } else if (style.align === "justify") {
    alignJustify(layoutData);
  }
  return layoutData;
}
function alignCenter(measurementData) {
  for (let i3 = 0; i3 < measurementData.lines.length; i3++) {
    const line = measurementData.lines[i3];
    const offset = measurementData.width / 2 - line.width / 2;
    for (let j3 = 0; j3 < line.charPositions.length; j3++) {
      line.charPositions[j3] += offset;
    }
  }
}
function alignRight(measurementData) {
  for (let i3 = 0; i3 < measurementData.lines.length; i3++) {
    const line = measurementData.lines[i3];
    const offset = measurementData.width - line.width;
    for (let j3 = 0; j3 < line.charPositions.length; j3++) {
      line.charPositions[j3] += offset;
    }
  }
}
function alignJustify(measurementData) {
  const width = measurementData.width;
  for (let i3 = 0; i3 < measurementData.lines.length; i3++) {
    const line = measurementData.lines[i3];
    let indy = 0;
    let spaceIndex = line.spacesIndex[indy++];
    let offset = 0;
    const totalSpaces = line.spacesIndex.length;
    const newSpaceWidth = (width - line.width) / totalSpaces;
    const spaceWidth = newSpaceWidth;
    for (let j3 = 0; j3 < line.charPositions.length; j3++) {
      if (j3 === spaceIndex) {
        spaceIndex = line.spacesIndex[indy++];
        offset += spaceWidth;
      }
      line.charPositions[j3] += offset;
    }
  }
}
var init_getBitmapTextLayout = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/bitmap/utils/getBitmapTextLayout.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/bitmap/BitmapFontManager.mjs
var BitmapFontManagerClass, BitmapFontManager;
var init_BitmapFontManager = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/bitmap/BitmapFontManager.mjs"() {
    init_Cache();
    init_TextStyle();
    init_DynamicBitmapFont();
    init_getBitmapTextLayout();
    init_resolveCharacters();
    BitmapFontManagerClass = class {
      constructor() {
        this.ALPHA = [["a", "z"], ["A", "Z"], " "];
        this.NUMERIC = [["0", "9"]];
        this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
        this.ASCII = [[" ", "~"]];
        this.defaultOptions = {
          chars: this.ALPHANUMERIC,
          resolution: 1,
          padding: 4,
          skipKerning: false
        };
      }
      getFont(text, style) {
        let fontFamilyKey = style.fontFamily;
        let overrideFill = true;
        if (style._fill.fill) {
          fontFamilyKey += style._fill.fill.uid;
          overrideFill = false;
        }
        if (!Cache.has(fontFamilyKey)) {
          Cache.set(
            fontFamilyKey,
            new DynamicBitmapFont({
              style,
              overrideFill,
              ...this.defaultOptions
            })
          );
        }
        const dynamicFont = Cache.get(fontFamilyKey);
        dynamicFont.ensureCharacters?.(text);
        return dynamicFont;
      }
      getLayout(text, style) {
        const bitmapFont = this.getFont(text, style);
        return getBitmapTextLayout(text.split(""), style, bitmapFont);
      }
      measureText(text, style) {
        return this.getLayout(text, style);
      }
      /**
       * Generates a bitmap-font for the given style and character set
       * @param name - The name of the custom font to use with BitmapText.
       * @param textStyle - Style options to render with BitmapFont.
       * @param options - Setup options for font or name of the font.
       * @returns Font generated by style options.
       * @example
       * import { BitmapFontManager, BitmapText } from 'pixi.js';
       *
       * BitmapFontManager.install('TitleFont', {
       *     fontFamily: 'Arial',
       *     fontSize: 12,
       *     strokeThickness: 2,
       *     fill: 'purple',
       * });
       *
       * const title = new Text({ text: 'This is the title', fontFamily: 'TitleFont', renderMode: 'bitmap' });
       */
      install(name, textStyle, options) {
        if (!name) {
          throw new Error("[BitmapFontManager] Property `name` is required.");
        }
        options = { ...this.defaultOptions, ...options };
        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
        const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;
        const font = new DynamicBitmapFont({
          style,
          overrideFill,
          skipKerning: options.skipKerning,
          padding: options.padding,
          resolution: options.resolution
        });
        const flatChars = resolveCharacters(options.chars);
        font.ensureCharacters(flatChars.join(""));
        Cache.set(name, font);
        return font;
      }
    };
    BitmapFontManager = new BitmapFontManagerClass();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/bitmap/BitmapTextPipe.mjs
var GraphicsProxyRenderable, BitmapTextPipe;
var init_BitmapTextPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/bitmap/BitmapTextPipe.mjs"() {
    init_Cache();
    init_Extensions();
    init_ProxyRenderable();
    init_PoolGroup();
    init_GraphicsView();
    init_SdfShader();
    init_BitmapFontManager();
    init_getBitmapTextLayout();
    GraphicsProxyRenderable = class extends ProxyRenderable {
      constructor() {
        super({
          view: new GraphicsView()
        });
      }
    };
    BitmapTextPipe = class {
      constructor(renderer) {
        this._gpuBitmapText = {};
        this._renderer = renderer;
      }
      validateRenderable(renderable) {
        const graphicsRenderable = this._getGpuBitmapText(renderable);
        if (renderable.view._didUpdate) {
          renderable.view._didUpdate = false;
          this._updateContext(renderable, graphicsRenderable.view.context);
        }
        const rebuild = this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);
        return rebuild;
      }
      addRenderable(renderable, instructionSet) {
        const graphicsRenderable = this._getGpuBitmapText(renderable);
        if (renderable.view._didUpdate) {
          renderable.view._didUpdate = false;
          this._updateContext(renderable, graphicsRenderable.view.context);
        }
        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);
        if (graphicsRenderable.view.context.customShader) {
          this._updateDistanceField(renderable);
        }
      }
      destroyRenderable(renderable) {
        this._destroyRenderableByUid(renderable.uid);
      }
      _destroyRenderableByUid(renderableUid) {
        BigPool.return(this._gpuBitmapText[renderableUid]);
        this._gpuBitmapText[renderableUid] = null;
      }
      updateRenderable(renderable) {
        const graphicsRenderable = this._getGpuBitmapText(renderable);
        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);
        if (graphicsRenderable.view.context.customShader) {
          this._updateDistanceField(renderable);
        }
      }
      _updateContext(renderable, context4) {
        const view = renderable.view;
        const bitmapFont = BitmapFontManager.getFont(view.text, view._style);
        context4.clear();
        if (bitmapFont.distanceField.type !== "none") {
          if (!context4.customShader) {
            if (!this._sdfShader) {
              this._sdfShader = new SdfShader();
            }
            context4.customShader = this._sdfShader;
          }
        }
        const chars = Array.from(view.text);
        const style = view._style;
        let currentY = (style._stroke?.width || 0) / 2;
        currentY += bitmapFont.baseLineOffset;
        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont);
        let index = 0;
        const padding = style.padding;
        const scale3 = bitmapTextLayout.scale;
        context4.translate(
          -view.anchor._x * bitmapTextLayout.width - padding,
          -view.anchor._y * (bitmapTextLayout.height + bitmapTextLayout.offsetY) - padding
        ).scale(scale3, scale3);
        const tint = style._fill.color;
        for (let i3 = 0; i3 < bitmapTextLayout.lines.length; i3++) {
          const line = bitmapTextLayout.lines[i3];
          for (let j3 = 0; j3 < line.charPositions.length; j3++) {
            const char = chars[index++];
            const charData = bitmapFont.chars[char];
            if (charData?.texture) {
              context4.texture(
                charData.texture,
                tint,
                Math.round(line.charPositions[j3] + charData.xOffset),
                Math.round(currentY + charData.yOffset)
              );
            }
          }
          currentY += bitmapFont.lineHeight;
        }
      }
      _getGpuBitmapText(renderable) {
        return this._gpuBitmapText[renderable.uid] || this._initGpuText(renderable);
      }
      _initGpuText(renderable) {
        renderable.view._style.update();
        const proxyRenderable = BigPool.get(GraphicsProxyRenderable, renderable);
        this._gpuBitmapText[renderable.uid] = proxyRenderable;
        proxyRenderable.view.roundPixels = this._renderer._roundPixels | renderable.view.roundPixels;
        this._updateContext(renderable, proxyRenderable.view.context);
        renderable.on("destroyed", () => {
          this.destroyRenderable(renderable);
        });
        return this._gpuBitmapText[renderable.uid];
      }
      _updateDistanceField(renderable) {
        const context4 = this._getGpuBitmapText(renderable).view.context;
        const view = renderable.view;
        const fontFamily = view._style.fontFamily;
        const dynamicFont = Cache.get(fontFamily);
        const { a: a2, b: b2, c: c2, d: d3 } = renderable.layerTransform;
        const dx = Math.sqrt(a2 * a2 + b2 * b2);
        const dy = Math.sqrt(c2 * c2 + d3 * d3);
        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
        const fontScale = dynamicFont.baseRenderedFontSize / view._style.fontSize;
        const resolution = view.resolution ?? this._renderer.resolution;
        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale) * resolution;
        context4.customShader.resources.localUniforms.uniforms.uDistance = distance;
      }
      destroy() {
        for (const uid4 in this._gpuBitmapText) {
          this._destroyRenderableByUid(uid4);
        }
        this._gpuBitmapText = null;
        this._sdfShader?.destroy(true);
        this._sdfShader = null;
        this._renderer = null;
      }
    };
    BitmapTextPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "bitmapText"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs
var CanvasTextPipe;
var init_CanvasTextPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs"() {
    init_Extensions();
    init_PoolGroup();
    init_updateQuadBounds();
    init_BatchableSprite();
    CanvasTextPipe = class {
      constructor(renderer) {
        this._gpuText = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      validateRenderable(renderable) {
        const gpuText = this._getGpuText(renderable);
        const newKey = renderable.view._getKey();
        if (gpuText.currentKey !== newKey) {
          const view = renderable.view;
          const resolution = view.resolution ?? this._renderer.resolution;
          const { width, height } = this._renderer.canvasText.getTextureSize(
            view.text,
            resolution,
            view._style
          );
          if (
            // is only being used by this text:
            this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1 && width === gpuText.texture._source.width && height === gpuText.texture._source.height
          ) {
            return false;
          }
          return true;
        }
        return false;
      }
      addRenderable(renderable, _instructionSet) {
        const gpuText = this._getGpuText(renderable);
        const batchableSprite = gpuText.batchableSprite;
        if (renderable.view._didUpdate) {
          this._updateText(renderable);
        }
        this._renderer.renderPipes.batch.addToBatch(batchableSprite);
      }
      updateRenderable(renderable) {
        const gpuText = this._getGpuText(renderable);
        const batchableSprite = gpuText.batchableSprite;
        if (renderable.view._didUpdate) {
          this._updateText(renderable);
        }
        batchableSprite.batcher.updateElement(batchableSprite);
      }
      destroyRenderable(renderable) {
        this._destroyRenderableById(renderable.uid);
      }
      _destroyRenderableById(renderableUid) {
        const gpuText = this._gpuText[renderableUid];
        this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
        BigPool.return(gpuText.batchableSprite);
        this._gpuText[renderableUid] = null;
      }
      _updateText(renderable) {
        const newKey = renderable.view._getKey();
        const gpuText = this._getGpuText(renderable);
        const batchableSprite = gpuText.batchableSprite;
        if (gpuText.currentKey !== newKey) {
          this._updateGpuText(renderable);
        }
        renderable.view._didUpdate = false;
        const padding = renderable.view._style.padding;
        updateQuadBounds(batchableSprite.bounds, renderable.view.anchor, batchableSprite.texture, padding);
      }
      _updateGpuText(renderable) {
        const gpuText = this._getGpuText(renderable);
        const batchableSprite = gpuText.batchableSprite;
        const view = renderable.view;
        if (gpuText.texture) {
          this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
        }
        const resolution = view.resolution ?? this._renderer.resolution;
        gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getTexture(
          view.text,
          resolution,
          view._style,
          view._getKey()
        );
        gpuText.currentKey = view._getKey();
        batchableSprite.texture = gpuText.texture;
      }
      _getGpuText(renderable) {
        return this._gpuText[renderable.uid] || this._initGpuText(renderable);
      }
      _initGpuText(renderable) {
        const view = renderable.view;
        view._style.update();
        const gpuTextData = {
          texture: null,
          currentKey: "--",
          batchableSprite: BigPool.get(BatchableSprite)
        };
        gpuTextData.batchableSprite.renderable = renderable;
        gpuTextData.batchableSprite.bounds = [0, 1, 0, 0];
        gpuTextData.batchableSprite.roundPixels = this._renderer._roundPixels | renderable.view.roundPixels;
        this._gpuText[renderable.uid] = gpuTextData;
        this._updateText(renderable);
        renderable.on("destroyed", () => {
          this.destroyRenderable(renderable);
        });
        return gpuTextData;
      }
      destroy() {
        for (const i3 in this._gpuText) {
          this._destroyRenderableById(i3);
        }
        this._gpuText = null;
        this._renderer = null;
      }
    };
    CanvasTextPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "text"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/utils/getPo2TextureFromSource.mjs
function getPo2TextureFromSource(image, width, height, resolution) {
  const bounds = tempBounds3;
  bounds.minX = 0;
  bounds.minY = 0;
  bounds.maxX = image.width / resolution | 0;
  bounds.maxY = image.height / resolution | 0;
  const texture = TexturePool.getOptimalTexture(
    bounds.width,
    bounds.height,
    resolution,
    false
  );
  texture.source.uploadMethodId = "image";
  texture.source.resource = image;
  texture.source.alphaMode = "premultiply-alpha-on-upload";
  texture.frameWidth = width / resolution;
  texture.frameHeight = height / resolution;
  texture.source.update();
  texture.layout.updateUvs();
  return texture;
}
var tempBounds3;
var init_getPo2TextureFromSource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/utils/getPo2TextureFromSource.mjs"() {
    init_TexturePool();
    init_Bounds();
    tempBounds3 = new Bounds();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs
var CanvasTextSystem;
var init_CanvasTextSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs"() {
    init_Color();
    init_Extensions();
    init_pow2();
    init_CanvasPool();
    init_TexturePool();
    init_getPo2TextureFromSource();
    init_CanvasTextMetrics();
    init_fontStringFromTextStyle();
    init_getCanvasFillStyle();
    CanvasTextSystem = class {
      constructor() {
        this._activeTextures = {};
      }
      getTextureSize(text, resolution, style) {
        const measured = CanvasTextMetrics.measureText(text || " ", style);
        let width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
        let height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
        width = Math.ceil(width - 1e-6);
        height = Math.ceil(height - 1e-6);
        width = nextPow2(width);
        height = nextPow2(height);
        return { width, height };
      }
      getTexture(text, resolution, style, textKey) {
        if (this._activeTextures[textKey]) {
          this._increaseReferenceCount(textKey);
          return this._activeTextures[textKey].texture;
        }
        const measured = CanvasTextMetrics.measureText(text || " ", style);
        const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
        const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);
        const { canvas: canvas3 } = canvasAndContext;
        this.renderTextToCanvas(text, style, resolution, canvasAndContext);
        const texture = getPo2TextureFromSource(canvas3, width, height, resolution);
        this._activeTextures[textKey] = {
          canvasAndContext,
          texture,
          usageCount: 1
        };
        return texture;
      }
      _increaseReferenceCount(textKey) {
        this._activeTextures[textKey].usageCount++;
      }
      decreaseReferenceCount(textKey) {
        const activeTexture = this._activeTextures[textKey];
        activeTexture.usageCount--;
        if (activeTexture.usageCount === 0) {
          CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);
          TexturePool.returnTexture(activeTexture.texture);
          const source3 = activeTexture.texture.source;
          source3.resource = null;
          source3.uploadMethodId = "unknown";
          source3.alphaMode = "no-premultiply-alpha";
          this._activeTextures[textKey] = null;
        }
      }
      getReferenceCount(textKey) {
        return this._activeTextures[textKey].usageCount;
      }
      /**
       * Renders text to its canvas, and updates its texture.
       *
       * By default this is used internally to ensure the texture is correct before rendering,
       * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,
       * and then shared across multiple Sprites.
       * @param text
       * @param style
       * @param resolution
       * @param canvasAndContext
       */
      renderTextToCanvas(text, style, resolution, canvasAndContext) {
        const { canvas: canvas3, context: context4 } = canvasAndContext;
        const font = fontStringFromTextStyle(style);
        const measured = CanvasTextMetrics.measureText(text || " ", style);
        const lines = measured.lines;
        const lineHeight = measured.lineHeight;
        const lineWidths = measured.lineWidths;
        const maxLineWidth = measured.maxLineWidth;
        const fontProperties = measured.fontProperties;
        const height = canvas3.height;
        context4.resetTransform();
        context4.scale(resolution, resolution);
        context4.clearRect(0, 0, measured.width + 4, measured.height + 4);
        if (style._stroke?.width) {
          const strokeStyle = style._stroke;
          context4.lineWidth = strokeStyle.width;
          context4.miterLimit = strokeStyle.miterLimit;
          context4.lineJoin = strokeStyle.join;
          context4.lineCap = strokeStyle.cap;
        }
        context4.font = font;
        let linePositionX;
        let linePositionY;
        const passesCount = style.dropShadow ? 2 : 1;
        for (let i3 = 0; i3 < passesCount; ++i3) {
          const isShadowPass = style.dropShadow && i3 === 0;
          const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
          const dsOffsetShadow = dsOffsetText * resolution;
          if (isShadowPass) {
            context4.fillStyle = "black";
            context4.strokeStyle = "black";
            const shadowOptions = style.dropShadow;
            const dropShadowColor = shadowOptions.color;
            const dropShadowAlpha = shadowOptions.alpha;
            context4.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();
            const dropShadowBlur = shadowOptions.blur * resolution;
            const dropShadowDistance = shadowOptions.distance * resolution;
            context4.shadowBlur = dropShadowBlur;
            context4.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
            context4.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;
          } else {
            context4.globalAlpha = style._fill?.alpha ?? 1;
            context4.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context4) : null;
            if (style._stroke?.width) {
              context4.strokeStyle = getCanvasFillStyle(style._stroke, context4);
            }
            context4.shadowColor = "black";
          }
          let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
          if (lineHeight - fontProperties.fontSize < 0) {
            linePositionYShift = 0;
          }
          const strokeWidth = style._stroke?.width ?? 0;
          for (let i22 = 0; i22 < lines.length; i22++) {
            linePositionX = strokeWidth / 2;
            linePositionY = strokeWidth / 2 + i22 * lineHeight + fontProperties.ascent + linePositionYShift;
            if (style.align === "right") {
              linePositionX += maxLineWidth - lineWidths[i22];
            } else if (style.align === "center") {
              linePositionX += (maxLineWidth - lineWidths[i22]) / 2;
            }
            if (style._stroke) {
              this._drawLetterSpacing(
                lines[i22],
                style,
                canvasAndContext,
                linePositionX + style.padding,
                linePositionY + style.padding - dsOffsetText,
                true
              );
            }
            if (style._fill !== void 0) {
              this._drawLetterSpacing(
                lines[i22],
                style,
                canvasAndContext,
                linePositionX + style.padding,
                linePositionY + style.padding - dsOffsetText
              );
            }
          }
        }
      }
      /**
       * Render the text with letter-spacing.
       * @param text - The text to draw
       * @param style
       * @param canvasAndContext
       * @param x - Horizontal position to draw the text
       * @param y - Vertical position to draw the text
       * @param isStroke - Is this drawing for the outside stroke of the
       *  text? If not, it's for the inside fill
       */
      _drawLetterSpacing(text, style, canvasAndContext, x3, y2, isStroke = false) {
        const { context: context4 } = canvasAndContext;
        const letterSpacing = style.letterSpacing;
        let useExperimentalLetterSpacing = false;
        if (CanvasTextMetrics.experimentalLetterSpacingSupported) {
          if (CanvasTextMetrics.experimentalLetterSpacing) {
            context4.letterSpacing = `${letterSpacing}px`;
            context4.textLetterSpacing = `${letterSpacing}px`;
            useExperimentalLetterSpacing = true;
          } else {
            context4.letterSpacing = "0px";
            context4.textLetterSpacing = "0px";
          }
        }
        if (letterSpacing === 0 || useExperimentalLetterSpacing) {
          if (isStroke) {
            context4.strokeText(text, x3, y2);
          } else {
            context4.fillText(text, x3, y2);
          }
          return;
        }
        let currentPosition = x3;
        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);
        let previousWidth = context4.measureText(text).width;
        let currentWidth = 0;
        for (let i3 = 0; i3 < stringArray.length; ++i3) {
          const currentChar = stringArray[i3];
          if (isStroke) {
            context4.strokeText(currentChar, currentPosition, y2);
          } else {
            context4.fillText(currentChar, currentPosition, y2);
          }
          let textStr = "";
          for (let j3 = i3 + 1; j3 < stringArray.length; ++j3) {
            textStr += stringArray[j3];
          }
          currentWidth = context4.measureText(textStr).width;
          currentPosition += previousWidth - currentWidth + letterSpacing;
          previousWidth = currentWidth;
        }
      }
      destroy() {
        this._activeTextures = null;
      }
    };
    CanvasTextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "canvasText"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/HTMLTextPipe.mjs
var HTMLTextPipe;
var init_HTMLTextPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/HTMLTextPipe.mjs"() {
    init_Extensions();
    init_Texture();
    init_PoolGroup();
    init_updateQuadBounds();
    init_BatchableSprite();
    HTMLTextPipe = class {
      constructor(renderer) {
        this._gpuText = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      validateRenderable(renderable) {
        const gpuText = this._getGpuText(renderable);
        const newKey = renderable.view._getKey();
        if (gpuText.textureNeedsUploading) {
          gpuText.textureNeedsUploading = false;
          return true;
        }
        if (gpuText.currentKey !== newKey) {
          return true;
        }
        return false;
      }
      addRenderable(renderable) {
        const gpuText = this._getGpuText(renderable);
        const batchableSprite = gpuText.batchableSprite;
        if (renderable.view._didUpdate) {
          this._updateText(renderable);
        }
        this._renderer.renderPipes.batch.addToBatch(batchableSprite);
      }
      updateRenderable(renderable) {
        const gpuText = this._getGpuText(renderable);
        const batchableSprite = gpuText.batchableSprite;
        if (renderable.view._didUpdate) {
          this._updateText(renderable);
        }
        batchableSprite.batcher.updateElement(batchableSprite);
      }
      destroyRenderable(renderable) {
        this._destroyRenderableById(renderable.uid);
      }
      _destroyRenderableById(renderableUid) {
        const gpuText = this._gpuText[renderableUid];
        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);
        BigPool.return(gpuText.batchableSprite);
        this._gpuText[renderableUid] = null;
      }
      _updateText(renderable) {
        const newKey = renderable.view._getKey();
        const gpuText = this._getGpuText(renderable);
        const batchableSprite = gpuText.batchableSprite;
        if (gpuText.currentKey !== newKey) {
          this._updateGpuText(renderable).catch((e3) => {
            console.error(e3);
          });
        }
        renderable.view._didUpdate = false;
        const padding = renderable.view._style.padding;
        updateQuadBounds(batchableSprite.bounds, renderable.view.anchor, batchableSprite.texture, padding);
      }
      async _updateGpuText(renderable) {
        renderable.view._didUpdate = false;
        const gpuText = this._getGpuText(renderable);
        if (gpuText.generatingTexture)
          return;
        const newKey = renderable.view._getKey();
        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);
        gpuText.generatingTexture = true;
        gpuText.currentKey = newKey;
        const view = renderable.view;
        const resolution = view.resolution ?? this._renderer.resolution;
        const texture = await this._renderer.htmlText.getManagedTexture(
          view.text,
          resolution,
          view._style,
          view._getKey()
        );
        const batchableSprite = gpuText.batchableSprite;
        batchableSprite.texture = gpuText.texture = texture;
        gpuText.generatingTexture = false;
        gpuText.textureNeedsUploading = true;
        renderable.view.onUpdate();
        const padding = renderable.view._style.padding;
        updateQuadBounds(batchableSprite.bounds, renderable.view.anchor, batchableSprite.texture, padding);
      }
      _getGpuText(renderable) {
        return this._gpuText[renderable.uid] || this._initGpuText(renderable);
      }
      _initGpuText(renderable) {
        const view = renderable.view;
        view._style.update();
        const gpuTextData = {
          texture: Texture.EMPTY,
          currentKey: "--",
          batchableSprite: BigPool.get(BatchableSprite),
          textureNeedsUploading: false,
          generatingTexture: false
        };
        const batchableSprite = gpuTextData.batchableSprite;
        batchableSprite.renderable = renderable;
        batchableSprite.texture = Texture.EMPTY;
        batchableSprite.bounds = [0, 1, 0, 0];
        batchableSprite.roundPixels = this._renderer._roundPixels | renderable.view.roundPixels;
        this._gpuText[renderable.uid] = gpuTextData;
        renderable.on("destroyed", () => {
          this.destroyRenderable(renderable);
        });
        return gpuTextData;
      }
      destroy() {
        for (const i3 in this._gpuText) {
          this._destroyRenderableById(i3);
        }
        this._gpuText = null;
        this._renderer = null;
      }
    };
    HTMLTextPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "htmlText"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/isSafari.mjs
function isSafari() {
  const { userAgent } = settings.ADAPTER.getNavigator();
  return /^((?!chrome|android).)*safari/i.test(userAgent);
}
var init_isSafari = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/isSafari.mjs"() {
    init_settings();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/utils/extractFontFamilies.mjs
function extractFontFamilies(text, fontFamily) {
  const regex = /font-family:([^;"\s]+)/g;
  const matches = text.match(regex);
  const fontFamilies = [fontFamily];
  const dedupe = {};
  dedupe[fontFamily] = true;
  if (matches) {
    matches.forEach((match) => {
      const fontFamily2 = match.split(":")[1].trim();
      if (!dedupe[fontFamily2]) {
        fontFamilies.push(fontFamily2);
        dedupe[fontFamily2] = true;
      }
    });
  }
  return fontFamilies;
}
var init_extractFontFamilies = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/utils/extractFontFamilies.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/utils/loadFontAsBase64.mjs
async function loadFontAsBase64(url2) {
  const response = await settings.ADAPTER.fetch(url2);
  const blob = await response.blob();
  const reader = new FileReader();
  const dataSrc = await new Promise((resolve2, reject) => {
    reader.onloadend = () => resolve2(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
  return dataSrc;
}
var init_loadFontAsBase64 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/utils/loadFontAsBase64.mjs"() {
    init_settings();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/utils/loadFontCSS.mjs
async function loadFontCSS(style, url2) {
  const dataSrc = await loadFontAsBase64(url2);
  return `@font-face {
        font-family: "${style.fontFamily}";
        src: url('${dataSrc}');
        font-weight: ${style.fontWeight};
        font-style: ${style.fontStyle};
    }`;
}
var init_loadFontCSS = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/utils/loadFontCSS.mjs"() {
    init_loadFontAsBase64();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/utils/getFontCss.mjs
async function getFontCss(fontFamilies, style) {
  const fontPromises = fontFamilies.filter((fontFamily) => Cache.has(fontFamily)).map((fontFamily, i3) => {
    if (!FontStylePromiseCache.has(fontFamily)) {
      const { url: url2 } = Cache.get(fontFamily);
      if (i3 === 0) {
        FontStylePromiseCache.set(fontFamily, loadFontCSS(style, url2));
      } else {
        FontStylePromiseCache.set(fontFamily, loadFontCSS({
          ...HTMLTextSystem.defaultFontOptions,
          fontFamily
        }, url2));
      }
    }
    return FontStylePromiseCache.get(fontFamily);
  });
  return (await Promise.all(fontPromises)).join("\n");
}
var init_getFontCss = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/utils/getFontCss.mjs"() {
    init_Cache();
    init_HTMLTextSystem();
    init_loadFontCSS();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/utils/getSVGUrl.mjs
function getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {
  const { domElement, styleElement, svgRoot } = htmlTextData;
  domElement.innerHTML = text;
  domElement.setAttribute("style", `transform: scale(${resolution});
${style.cssStyle}`);
  styleElement.textContent = fontCSS;
  const { width, height } = htmlTextData.image;
  svgRoot.setAttribute("width", width.toString());
  svgRoot.setAttribute("height", height.toString());
  return new XMLSerializer().serializeToString(svgRoot);
}
var init_getSVGUrl = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/utils/getSVGUrl.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/utils/getTemporaryCanvasFromImage.mjs
function getTemporaryCanvasFromImage(image, resolution) {
  const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(
    image.width,
    image.height,
    resolution
  );
  const { context: context4 } = canvasAndContext;
  context4.clearRect(0, 0, image.width, image.height);
  context4.drawImage(image, 0, 0);
  CanvasPool.returnCanvasAndContext(canvasAndContext);
  return canvasAndContext.canvas;
}
var init_getTemporaryCanvasFromImage = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/utils/getTemporaryCanvasFromImage.mjs"() {
    init_CanvasPool();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/utils/loadSVGImage.mjs
function loadSVGImage(image, url2, delay) {
  return new Promise(async (resolve2) => {
    if (delay) {
      await new Promise((resolve22) => setTimeout(resolve22, 100));
    }
    image.onload = () => {
      resolve2();
    };
    image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url2)}`;
    image.crossOrigin = "anonymous";
  });
}
var init_loadSVGImage = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/utils/loadSVGImage.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/utils/measureHtmlText..mjs
function measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {
  htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());
  const { domElement, styleElement, svgRoot } = htmlTextRenderData;
  domElement.innerHTML = text;
  domElement.setAttribute("style", style.cssStyle);
  if (fontStyleCSS) {
    styleElement.textContent = fontStyleCSS;
  }
  document.body.appendChild(svgRoot);
  const contentBounds = domElement.getBoundingClientRect();
  svgRoot.remove();
  const descenderPadding = CanvasTextMetrics.measureFont(style.fontStyle).descent;
  return {
    width: contentBounds.width,
    height: contentBounds.height + descenderPadding
  };
}
var tempHTMLTextRenderData;
var init_measureHtmlText = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/utils/measureHtmlText..mjs"() {
    init_CanvasTextMetrics();
    init_HTMLTextSystem();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/HTMLTextSystem.mjs
var nssvg, nsxhtml, FontStylePromiseCache, HTMLTextRenderData, HTMLTextSystem;
var init_HTMLTextSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/HTMLTextSystem.mjs"() {
    init_Extensions();
    init_TexturePool();
    init_types();
    init_isSafari();
    init_warn();
    init_PoolGroup();
    init_extractFontFamilies();
    init_getFontCss();
    init_getPo2TextureFromSource();
    init_getSVGUrl();
    init_getTemporaryCanvasFromImage();
    init_loadSVGImage();
    init_measureHtmlText();
    nssvg = "http://www.w3.org/2000/svg";
    nsxhtml = "http://www.w3.org/1999/xhtml";
    FontStylePromiseCache = /* @__PURE__ */ new Map();
    HTMLTextRenderData = class {
      constructor() {
        this.svgRoot = document.createElementNS(nssvg, "svg");
        this.foreignObject = document.createElementNS(nssvg, "foreignObject");
        this.domElement = document.createElementNS(nsxhtml, "div");
        this.styleElement = document.createElementNS(nsxhtml, "style");
        this.image = new Image();
        const { foreignObject, svgRoot, styleElement, domElement } = this;
        foreignObject.setAttribute("width", "10000");
        foreignObject.setAttribute("height", "10000");
        foreignObject.style.overflow = "hidden";
        svgRoot.appendChild(foreignObject);
        foreignObject.appendChild(styleElement);
        foreignObject.appendChild(domElement);
      }
    };
    HTMLTextSystem = class {
      constructor(renderer) {
        this._activeTextures = {};
        this._renderer = renderer;
        this._createCanvas = renderer.type === RendererType.WEBGPU;
      }
      getTexture(options) {
        return this._buildTexturePromise(options.text, options.resolution, options.style);
      }
      getManagedTexture(text, resolution, style, textKey) {
        if (this._activeTextures[textKey]) {
          this._increaseReferenceCount(textKey);
          return this._activeTextures[textKey].promise;
        }
        const promise4 = this._buildTexturePromise(text, resolution, style).then((texture) => {
          this._activeTextures[textKey].texture = texture;
          return texture;
        });
        this._activeTextures[textKey] = {
          texture: null,
          promise: promise4,
          usageCount: 1
        };
        return promise4;
      }
      async _buildTexturePromise(text, resolution, style) {
        const htmlTextData = BigPool.get(HTMLTextRenderData);
        const fontFamilies = extractFontFamilies(text, style.fontFamily);
        const fontCSS = await getFontCss(fontFamilies, style);
        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);
        const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
        const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
        const image = htmlTextData.image;
        image.width = width | 0;
        image.height = height | 0;
        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);
        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);
        let resource = image;
        if (this._createCanvas) {
          resource = getTemporaryCanvasFromImage(image, resolution);
        }
        const texture = getPo2TextureFromSource(resource, resource.width, resource.height, resolution);
        if (this._createCanvas) {
          this._renderer.texture.initSource(texture.source);
        }
        BigPool.return(htmlTextData);
        return texture;
      }
      _increaseReferenceCount(textKey) {
        this._activeTextures[textKey].usageCount++;
      }
      decreaseReferenceCount(textKey) {
        const activeTexture = this._activeTextures[textKey];
        if (!activeTexture)
          return;
        activeTexture.usageCount--;
        if (activeTexture.usageCount === 0) {
          if (activeTexture.texture) {
            this._cleanUp(activeTexture);
          } else {
            activeTexture.promise.then((texture) => {
              activeTexture.texture = texture;
              this._cleanUp(activeTexture);
            }).catch(() => {
              warn("HTMLTextSystem: Failed to clean texture");
            });
          }
          this._activeTextures[textKey] = null;
        }
      }
      _cleanUp(activeTexture) {
        TexturePool.returnTexture(activeTexture.texture);
        activeTexture.texture.source.resource = null;
        activeTexture.texture.source.uploadMethodId = "unknown";
      }
      getReferenceCount(textKey) {
        return this._activeTextures[textKey].usageCount;
      }
      destroy() {
        this._activeTextures = null;
      }
    };
    HTMLTextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "htmlText"
    };
    HTMLTextSystem.defaultFontOptions = {
      fontFamily: "Arial",
      fontStyle: "normal",
      fontWeight: "normal"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs
var BatcherPipe;
var init_BatcherPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs"() {
    init_Extensions();
    init_State();
    init_BatchGeometry();
    init_Batcher();
    BatcherPipe = class {
      constructor(renderer, adaptor) {
        this.state = State.for2d();
        this._batches = /* @__PURE__ */ Object.create(null);
        this._geometries = /* @__PURE__ */ Object.create(null);
        this.renderer = renderer;
        this._adaptor = adaptor;
        this._adaptor.init();
      }
      buildStart(instructionSet) {
        if (!this._batches[instructionSet.uid]) {
          const batcher = new Batcher();
          this._batches[instructionSet.uid] = batcher;
          this._geometries[batcher.uid] = new BatchGeometry();
        }
        this._activeBatch = this._batches[instructionSet.uid];
        this._activeGeometry = this._geometries[this._activeBatch.uid];
        this._activeBatch.begin();
      }
      addToBatch(batchableObject) {
        this._activeBatch.add(batchableObject);
      }
      break(instructionSet) {
        this._activeBatch.break(instructionSet);
      }
      buildEnd(instructionSet) {
        const activeBatch = this._activeBatch;
        const geometry = this._activeGeometry;
        activeBatch.finish(instructionSet);
        geometry.indexBuffer.data = activeBatch.indexBuffer;
        geometry.indexBuffer.update(activeBatch.indexSize * 4);
        geometry.buffers[0].data = activeBatch.attributeBuffer.float32View;
      }
      upload(instructionSet) {
        const batcher = this._batches[instructionSet.uid];
        const geometry = this._geometries[batcher.uid];
        if (batcher.dirty) {
          batcher.dirty = false;
          geometry.buffers[0].update(batcher.attributeSize * 4);
        }
      }
      execute(batch) {
        if (batch.action === "startBatch") {
          const batcher = batch.batcher;
          const geometry = this._geometries[batcher.uid];
          this._adaptor.start(this, geometry);
        }
        this._adaptor.execute(this, batch);
      }
      destroy() {
        this.state = null;
        this.renderer = null;
        this._adaptor.destroy();
        this._adaptor = null;
        for (const i3 in this._batches) {
          this._batches[i3].destroy();
        }
        this._batches = null;
        for (const i3 in this._geometries) {
          this._geometries[i3].destroy();
        }
        this._geometries = null;
      }
    };
    BatcherPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "batch"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/Filter.mjs
var _Filter, Filter;
var init_Filter = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/Filter.mjs"() {
    init_Shader();
    init_State();
    _Filter = class extends Shader {
      constructor(options) {
        options = { ..._Filter.defaultOptions, ...options };
        super(options);
        this.enabled = true;
        this._state = State.for2d();
        this.padding = options.padding;
        if (typeof options.antialias === "boolean") {
          this.antialias = options.antialias ? "on" : "off";
        } else {
          this.antialias = options.antialias ?? "inherit";
        }
        this.resolution = options.resolution;
        this.blendRequired = options.blendRequired;
        this.addResource("filterUniforms", 0, 0);
        this.addResource("uSampler", 0, 1);
      }
      /**
       * Applies the filter
       * @param filterManager - The renderer to retrieve the filter from
       * @param input - The input render target.
       * @param output - The target to output to.
       * @param clearMode - Should the output be cleared before rendering to it
       */
      apply(filterManager, input, output, clearMode) {
        filterManager.applyFilter(this, input, output, clearMode);
      }
      /**
       * Sets the blend mode of the filter.
       * @default "normal"
       */
      get blendMode() {
        return this._state.blendMode;
      }
      set blendMode(value) {
        this._state.blendMode = value;
      }
    };
    Filter = _Filter;
    Filter.defaultOptions = {
      blendMode: "normal",
      resolution: 1,
      padding: 0,
      antialias: "inherit",
      blendRequired: false
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/mask/mask.mjs
var fragment;
var init_mask = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/mask/mask.mjs"() {
    fragment = "in vec2 vMaskCoord;\nin vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mapTexture;\n\nuniform float alpha;\nuniform vec4 maskClamp;\n\nout vec4 fragColor;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    // TODO look into why this is needed\n    float npmAlpha = alpha; \n    vec4 original = texture(uSampler, vTextureCoord);\n    vec4 masky = texture(mapTexture, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    fragColor = original;\n}\n";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/mask/mask3.mjs
var vertex;
var init_mask3 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/mask/mask3.mjs"() {
    vertex = "in vec2 aPosition;\n\nout vec2 vTextureCoord;\nout vec2 vMaskCoord;\n\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nuniform vec4 outputTexture;\nuniform mat3 filterMatrix;\n\nvec4 filterVertexPosition(  vec2 aPosition )\n{\n    vec2 position = aPosition * outputFrame.zw + outputFrame.xy;\n       \n    position.x = position.x * (2.0 / outputTexture.x) - 1.0;\n    position.y = position.y * (2.0*outputTexture.z / outputTexture.y) - outputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord(  vec2 aPosition )\n{\n    return aPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvec2 getFilterCoord( vec2 aPosition )\n{\n    return  ( filterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}   \n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition(aPosition);\n    vTextureCoord = filterTextureCoord(aPosition);\n    vMaskCoord = getFilterCoord(aPosition);\n}\n";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/mask/mask2.mjs
var source;
var init_mask2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/mask/mask2.mjs"() {
    source = "struct GlobalFilterUniforms {\n  inputSize:vec4<f32>,\n  inputPixel:vec4<f32>,\n  inputClamp:vec4<f32>,\n  outputFrame:vec4<f32>,\n  globalFrame:vec4<f32>,\n  outputTexture:vec4<f32>,  \n};\n\nstruct MaskUniforms {\n  filterMatrix:mat3x3<f32>,\n  maskClamp:vec4<f32>,\n  alpha:f32,\n};\n\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uSampler: texture_2d<f32>;\n@group(0) @binding(2) var mySampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\n@group(1) @binding(1) var mapTexture: texture_2d<f32>;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.outputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.outputTexture.z / gfu.outputTexture.y) - gfu.outputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  \n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.filterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n\n  \n  return gfu.globalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var maskClamp = filterUniforms.maskClamp;\n\n     var clip = step(3.5,\n        step(maskClamp.x, filterUv.x) +\n        step(maskClamp.y, filterUv.y) +\n        step(filterUv.x, maskClamp.z) +\n        step(filterUv.y, maskClamp.w));\n\n    var mask = textureSample(mapTexture, mySampler, filterUv);\n    var source = textureSample(uSampler, mySampler, uv);\n    \n    var npmAlpha = 0.0;\n\n    var alphaMul = 1.0 - npmAlpha * (1.0 - mask.a);\n\n    var a = (alphaMul * mask.r) * clip;\n\n    return vec4(source.rgb * a, source.a) * a;\n  \n}";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs
var MaskFilter;
var init_MaskFilter = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs"() {
    init_Matrix();
    init_GlProgram();
    init_GpuProgram();
    init_UniformGroup();
    init_TextureMatrix();
    init_Filter();
    init_mask();
    init_mask3();
    init_mask2();
    MaskFilter = class extends Filter {
      constructor({ sprite }) {
        const textureMatrix = new TextureMatrix(sprite.texture);
        const filterUniforms = new UniformGroup({
          filterMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          maskClamp: { value: textureMatrix.uClampFrame, type: "vec4<f32>" },
          alpha: { value: 1, type: "f32" }
        });
        const gpuProgram = new GpuProgram({
          vertex: {
            source,
            entryPoint: "mainVertex"
          },
          fragment: {
            source,
            entryPoint: "mainFragment"
          }
        });
        const glProgram = GlProgram.from({
          vertex,
          fragment,
          name: "mask-filter"
        });
        super({
          gpuProgram,
          glProgram,
          resources: {
            filterUniforms,
            mapTexture: sprite.texture.source
          }
        });
        this.sprite = sprite;
        this._textureMatrix = textureMatrix;
      }
      apply(filterManager, input, output, clearMode) {
        this._textureMatrix.texture = this.sprite.texture;
        filterManager.calculateSpriteMatrix(
          this.resources.filterUniforms.uniforms.filterMatrix,
          this.sprite
        ).prepend(this._textureMatrix.mapCoord);
        this.resources.mapTexture = this.sprite.texture.source;
        filterManager.applyFilter(this, input, output, clearMode);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs
var tempBounds4, AlphaMaskEffect, AlphaMaskPipe;
var init_AlphaMaskPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs"() {
    init_Extensions();
    init_FilterEffect();
    init_MaskFilter();
    init_Bounds();
    init_getGlobalBounds();
    init_buildInstructions();
    init_Sprite();
    init_PoolGroup();
    init_Texture();
    init_TexturePool();
    tempBounds4 = new Bounds();
    AlphaMaskEffect = class extends FilterEffect {
      constructor() {
        super({
          filters: [new MaskFilter({
            sprite: new Sprite(Texture.EMPTY)
          })]
        });
      }
      get sprite() {
        return this.filters[0].sprite;
      }
      set sprite(value) {
        this.filters[0].sprite = value;
      }
    };
    AlphaMaskPipe = class {
      constructor(renderer) {
        this._activeMaskStage = [];
        this._renderer = renderer;
      }
      push(mask2, maskedContainer, instructionSet) {
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          type: "alphaMask",
          action: "pushMaskBegin",
          mask: mask2,
          canBundle: false,
          maskedContainer
        });
        if (mask2.renderMaskToTexture) {
          const maskContainer = mask2.mask;
          maskContainer.includeInBuild = true;
          collectAllRenderables(
            maskContainer,
            instructionSet,
            renderer.renderPipes
          );
          maskContainer.includeInBuild = false;
        }
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          type: "alphaMask",
          action: "pushMaskEnd",
          mask: mask2,
          maskedContainer,
          canBundle: false
        });
      }
      pop(mask2, _maskedContainer, instructionSet) {
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          type: "alphaMask",
          action: "popMaskEnd",
          mask: mask2,
          canBundle: false
        });
      }
      execute(instruction) {
        const renderer = this._renderer;
        const renderMask = instruction.mask.renderMaskToTexture;
        if (instruction.action === "pushMaskBegin") {
          const filterEffect = BigPool.get(AlphaMaskEffect);
          if (renderMask) {
            instruction.mask.mask.measurable = true;
            const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds4);
            instruction.mask.mask.measurable = false;
            bounds.ceil();
            const filterTexture = TexturePool.getOptimalTexture(
              bounds.width,
              bounds.height,
              1,
              false
            );
            const renderTarget = renderer.renderTarget.push(filterTexture, true);
            renderer.globalUniforms.push({
              projectionData: renderTarget,
              offset: bounds,
              worldColor: 4294967295
            });
            const sprite = filterEffect.sprite;
            sprite.texture = filterTexture;
            sprite.worldTransform.tx = bounds.minX;
            sprite.worldTransform.ty = bounds.minY;
            this._activeMaskStage.push({
              filterEffect,
              maskedContainer: instruction.maskedContainer,
              filterTexture
            });
          } else {
            filterEffect.sprite = instruction.mask.mask;
            this._activeMaskStage.push({
              filterEffect,
              maskedContainer: instruction.maskedContainer
            });
          }
        } else if (instruction.action === "pushMaskEnd") {
          const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];
          if (renderMask) {
            renderer.renderTarget.pop();
            renderer.globalUniforms.pop();
          }
          renderer.filter.push({
            type: "filter",
            action: "pushFilter",
            container: maskData.maskedContainer,
            filterEffect: maskData.filterEffect,
            canBundle: false
          });
        } else if (instruction.action === "popMaskEnd") {
          renderer.filter.pop();
          const maskData = this._activeMaskStage.pop();
          if (renderMask) {
            TexturePool.returnTexture(maskData.filterTexture);
          }
          BigPool.return(maskData.filterEffect);
        }
      }
      destroy() {
        this._renderer = null;
        this._activeMaskStage = null;
      }
    };
    AlphaMaskPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "alphaMask"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs
var ColorMaskPipe;
var init_ColorMaskPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs"() {
    init_Extensions();
    ColorMaskPipe = class {
      constructor(renderer) {
        this._colorStack = [];
        this._colorStackIndex = 0;
        this._currentColor = 0;
        this._renderer = renderer;
      }
      buildStart() {
        this._colorStack[0] = 15;
        this._colorStackIndex = 1;
        this._currentColor = 15;
      }
      push(mask2, _container, instructionSet) {
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        const colorStack = this._colorStack;
        colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask2.mask;
        const currentColor = this._colorStack[this._colorStackIndex];
        if (currentColor !== this._currentColor) {
          this._currentColor = currentColor;
          instructionSet.add({
            type: "colorMask",
            colorMask: currentColor,
            canBundle: false
          });
        }
        this._colorStackIndex++;
      }
      pop(_mask, _container, instructionSet) {
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        const colorStack = this._colorStack;
        this._colorStackIndex--;
        const currentColor = colorStack[this._colorStackIndex - 1];
        if (currentColor !== this._currentColor) {
          this._currentColor = currentColor;
          instructionSet.add({
            type: "colorMask",
            colorMask: currentColor,
            canBundle: false
          });
        }
      }
      execute(instruction) {
        const renderer = this._renderer;
        renderer.colorMask.setMask(instruction.colorMask);
      }
      destroy() {
        this._colorStack = null;
      }
    };
    ColorMaskPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "colorMask"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs
var CLEAR;
var init_const7 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs"() {
    CLEAR = /* @__PURE__ */ ((CLEAR2) => {
      CLEAR2[CLEAR2["NONE"] = 0] = "NONE";
      CLEAR2[CLEAR2["COLOR"] = 16384] = "COLOR";
      CLEAR2[CLEAR2["STENCIL"] = 1024] = "STENCIL";
      CLEAR2[CLEAR2["DEPTH"] = 256] = "DEPTH";
      CLEAR2[CLEAR2["COLOR_DEPTH"] = 16640] = "COLOR_DEPTH";
      CLEAR2[CLEAR2["COLOR_STENCIL"] = 17408] = "COLOR_STENCIL";
      CLEAR2[CLEAR2["DEPTH_STENCIL"] = 1280] = "DEPTH_STENCIL";
      CLEAR2[CLEAR2["ALL"] = 17664] = "ALL";
      return CLEAR2;
    })(CLEAR || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs
var STENCIL_MODES;
var init_const8 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs"() {
    STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {
      STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";
      STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";
      STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";
      STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 3] = "RENDERING_MASK_REMOVE";
      STENCIL_MODES2[STENCIL_MODES2["NONE"] = 4] = "NONE";
      return STENCIL_MODES2;
    })(STENCIL_MODES || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs
var StencilMaskPipe;
var init_StencilMaskPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs"() {
    init_Extensions();
    init_buildInstructions();
    init_const7();
    init_const8();
    StencilMaskPipe = class {
      constructor(renderer) {
        this._maskStackHash = {};
        this._maskHash = /* @__PURE__ */ new WeakMap();
        this._renderer = renderer;
      }
      push(mask2, _container, instructionSet) {
        const effect = mask2;
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
        instructionSet.add({
          type: "stencilMask",
          action: "pushMaskBegin",
          mask: mask2,
          canBundle: false
        });
        const maskContainer = effect.mask;
        maskContainer.includeInBuild = true;
        if (!this._maskHash.has(effect)) {
          this._maskHash.set(effect, {
            instructionsStart: 0,
            instructionsLength: 0
          });
        }
        const maskData = this._maskHash.get(effect);
        maskData.instructionsStart = instructionSet.instructionSize;
        collectAllRenderables(
          maskContainer,
          instructionSet,
          renderer.renderPipes
        );
        maskContainer.includeInBuild = false;
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          type: "stencilMask",
          action: "pushMaskEnd",
          mask: mask2,
          canBundle: false
        });
        const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;
        maskData.instructionsLength = instructionsLength;
        const renderTargetUid = renderer.renderTarget.renderTarget.uid;
        if (this._maskStackHash[renderTargetUid] === void 0) {
          this._maskStackHash[renderTargetUid] = 0;
        }
        this._maskStackHash[renderTargetUid]++;
      }
      pop(mask2, _container, instructionSet) {
        const effect = mask2;
        const renderer = this._renderer;
        const renderTargetUid = renderer.renderTarget.renderTarget.uid;
        this._maskStackHash[renderTargetUid]--;
        renderer.renderPipes.batch.break(instructionSet);
        renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
        instructionSet.add({
          type: "stencilMask",
          action: "popMaskBegin",
          canBundle: false
        });
        const maskData = this._maskHash.get(mask2);
        if (this._maskStackHash[renderTargetUid] !== 0) {
          for (let i3 = 0; i3 < maskData.instructionsLength; i3++) {
            instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];
          }
        }
        instructionSet.add({
          type: "stencilMask",
          action: "popMaskEnd",
          canBundle: false
        });
      }
      execute(instruction) {
        const renderer = this._renderer;
        const renderTargetUid = renderer.renderTarget.renderTarget.uid;
        let maskStackIndex = this._maskStackHash[renderTargetUid] ?? 0;
        if (instruction.action === "pushMaskBegin") {
          maskStackIndex++;
          renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);
          renderer.colorMask.setMask(0);
        } else if (instruction.action === "pushMaskEnd") {
          renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
          renderer.colorMask.setMask(15);
        } else if (instruction.action === "popMaskBegin") {
          maskStackIndex--;
          if (maskStackIndex !== 0) {
            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);
            renderer.colorMask.setMask(0);
          } else {
            renderer.renderTarget.clear(CLEAR.STENCIL);
          }
        } else if (instruction.action === "popMaskEnd") {
          if (maskStackIndex === 0) {
            renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);
          } else {
            renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
          }
          renderer.colorMask.setMask(15);
        }
        this._maskStackHash[renderTargetUid] = maskStackIndex;
      }
      destroy() {
        this._renderer = null;
        this._maskStackHash = null;
        this._maskHash = null;
      }
    };
    StencilMaskPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "stencilMask"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs
var _BackgroundSystem, BackgroundSystem;
var init_BackgroundSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs"() {
    init_Color();
    init_Extensions();
    _BackgroundSystem = class {
      constructor() {
        this._backgroundColorRgba = [0, 0, 0, 0];
        this.clearBeforeRender = true;
        this._backgroundColor = new Color(0);
        this.color = this._backgroundColor;
        this.alpha = 1;
      }
      /**
       * initiates the background system
       * @param options - the options for the background colors
       */
      init(options) {
        options = { ..._BackgroundSystem.defaultOptions, ...options };
        this.clearBeforeRender = options.clearBeforeRender;
        this.color = options.background || options.backgroundColor || this._backgroundColor;
        this.alpha = options.backgroundAlpha;
      }
      /** The background color to fill if not transparent */
      get color() {
        return this._backgroundColor;
      }
      set color(value) {
        this._backgroundColor.setValue(value);
        this._backgroundColorRgba = this._backgroundColor.toArray();
      }
      /** The background color alpha. Setting this to 0 will make the canvas transparent. */
      get alpha() {
        return this._backgroundColor.alpha;
      }
      set alpha(value) {
        this._backgroundColor.setAlpha(value);
      }
      /** The background color as an [R, G, B, A] array. */
      get colorRgba() {
        return this._backgroundColorRgba;
      }
      destroy() {
      }
    };
    BackgroundSystem = _BackgroundSystem;
    BackgroundSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "background",
      priority: 0
    };
    BackgroundSystem.defaultOptions = {
      /**
       * {@link WebGLOptions.backgroundAlpha}
       * @default 1
       */
      backgroundAlpha: 1,
      /**
       * {@link WebGLOptions.backgroundColor}
       * @default 0x000000
       */
      backgroundColor: 0,
      /**
       * {@link WebGLOptions.clearBeforeRender}
       * @default true
       */
      clearBeforeRender: true
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/blend-template.mjs
var blendTemplateFrag;
var init_blend_template = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/blend-template.mjs"() {
    blendTemplateFrag = "\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 fragColor;\n\nuniform float uBlend;\n\nuniform sampler2D uSampler;\nuniform sampler2D backTexture;\n\n{FUNCTIONS}\n\nvoid main()\n{ \n    vec4 back = texture(backTexture, vTextureCoord);\n    vec4 front = texture(uSampler, vTextureCoord);\n\n    {MAIN}\n}\n";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/blend-template2.mjs
var blendTemplateVert;
var init_blend_template2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/blend-template2.mjs"() {
    blendTemplateVert = "in vec2 aPosition;\nout vec2 vTextureCoord;\nout vec2 backgroundUv;\n\nuniform globalUniforms {\n  mat3 projectionMatrix;\n  mat3 worldTransformMatrix;\n  float worldAlpha;\n};\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nuniform vec4 backgroundFrame;\nuniform vec4 outputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * outputFrame.zw + outputFrame.xy;\n    \n    position.x = position.x * (2.0 / outputTexture.x) - 1.0;\n    position.y = position.y * (2.0*outputTexture.z / outputTexture.y) - outputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/blend-template3.mjs
var blendTemplate;
var init_blend_template3 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/blend-template3.mjs"() {
    blendTemplate = "struct GlobalUniforms {\n  projectionMatrix:mat3x3<f32>,\n  worldTransformMatrix:mat3x3<f32>,\n  worldAlpha: f32\n}\n\nstruct GlobalFilterUniforms {\n  inputSize:vec4<f32>,\n  inputPixel:vec4<f32>,\n  inputClamp:vec4<f32>,\n  outputFrame:vec4<f32>,\n  globalFrame:vec4<f32>,\n  outputTexture:vec4<f32>,\n};\n\nstruct BlendUniforms {\n  uBlend:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uSampler: texture_2d<f32>;\n@group(0) @binding(2) var mySampler : sampler;\n@group(0) @binding(3) var backTexture: texture_2d<f32>;\n\n@group(1) @binding(0) var<uniform> blendUniforms : BlendUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.outputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.outputTexture.z / gfu.outputTexture.y) - gfu.outputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  \n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n{FUNCTIONS}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>\n) -> @location(0) vec4<f32> {\n\n\n   var back =  textureSample(backTexture, mySampler, uv);\n   var front = textureSample(uSampler, mySampler, uv);\n   \n   var out = vec4<f32>(0.0,0.0,0.0,0.0);\n\n   {MAIN}\n\n   return out;\n}";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs
function compileBlendModeShader(options) {
  const { source: source3, functions, main } = options;
  return source3.replace("{FUNCTIONS}", functions).replace("{MAIN}", main);
}
var BlendModeFilter;
var init_BlendModeFilter = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs"() {
    init_GlProgram();
    init_GpuProgram();
    init_UniformGroup();
    init_Texture();
    init_Filter();
    init_blend_template();
    init_blend_template2();
    init_blend_template3();
    BlendModeFilter = class extends Filter {
      constructor(options) {
        const gpuOptions = options.gpu;
        const gpuSource = compileBlendModeShader({ source: blendTemplate, ...gpuOptions });
        const gpuProgram = new GpuProgram({
          vertex: {
            source: gpuSource,
            entryPoint: "mainVertex"
          },
          fragment: {
            source: gpuSource,
            entryPoint: "mainFragment"
          }
        });
        const glOptions = options.gl;
        const glSource = compileBlendModeShader({ source: blendTemplateFrag, ...glOptions });
        const glProgram = new GlProgram({
          vertex: blendTemplateVert,
          fragment: glSource
        });
        const uniformGroup = new UniformGroup({
          uBlend: {
            value: 1,
            type: "f32"
          }
        });
        super({
          gpuProgram,
          glProgram,
          blendRequired: true,
          resources: {
            blendUniforms: uniformGroup,
            backTexture: Texture.EMPTY
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.mjs
var hslgl;
var init_GLhls = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.mjs"() {
    hslgl = `
	float getLuminosity(vec3 c) {
		return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;
	}

	vec3 setLuminosity(vec3 c, float lum) {
		float modLum = lum - getLuminosity(c);
		vec3 color = c.rgb + vec3(modLum);

		// clip back into legal range
		modLum = getLuminosity(color);
		vec3 modLumVec = vec3(modLum);

		float cMin = min(color.r, min(color.g, color.b));
		float cMax = max(color.r, max(color.g, color.b));

		if(cMin < 0.0) {
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0) {
			color = mix(modLumVec, color, (1.0 - modLum) / (cMax - modLum));
		}

		return color;
	}

	float getSaturation(vec3 c) {
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	vec3 setSaturationMinMidMax(vec3 cSorted, float s) {
		vec3 colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x) {
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else {
			colorSorted.y = 0.0;
			colorSorted.z = 0.0;
		}

		colorSorted.x = 0.0;

		return colorSorted;
	}

	vec3 setSaturation(vec3 c, float s) {
		vec3 color = c;

		if(color.r <= color.g && color.r <= color.b) {
			if(color.g <= color.b) {
				color = setSaturationMinMidMax(color.rgb, s).rgb;
			}
			else {
				color = setSaturationMinMidMax(color.rbg, s).rbg;
			}
		}
		else if(color.g <= color.r && color.g <= color.b) {
			if(color.r <= color.b) {
				color = setSaturationMinMidMax(color.grb, s).grb;
			}
			else {
				color = setSaturationMinMidMax(color.gbr, s).gbr;
			}
		}
		else {
			// Using bgr for both fixes part of hue
			if(color.r <= color.g) {
				color = setSaturationMinMidMax(color.brg, s).brg;
			}
			else {
				color = setSaturationMinMidMax(color.bgr, s).bgr;
			}
		}

		return color;
	}
    `;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.mjs
var hslgpu;
var init_GPUhls = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.mjs"() {
    hslgpu = `
	fn getLuminosity(c: vec3<f32>) -> f32
	{
		return 0.3*c.r + 0.59*c.g + 0.11*c.b;
	}

	fn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32>
	{
		var modLum: f32 = lum - getLuminosity(c);
		var color: vec3<f32> = c.rgb + modLum;

		// clip back into legal range
		modLum = getLuminosity(color);
		let modLumVec = vec3<f32>(modLum);

		let cMin: f32 = min(color.r, min(color.g, color.b));
		let cMax: f32 = max(color.r, max(color.g, color.b));

		if(cMin < 0.0)
		{
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0)
		{
			color = mix(modLumVec, color, (1 - modLum) / (cMax - modLum));
		}

		return color;
	}

	fn getSaturation(c: vec3<f32>) -> f32
	{
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	fn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32>
	{
		var colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x)
		{
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else
		{
			colorSorted.y = 0;
			colorSorted.z = 0;
		}

		colorSorted.x = 0;

		return colorSorted;
	}

	fn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32>
	{
		var color = c;

		if (color.r <= color.g && color.r <= color.b)
		{
			if (color.g <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rgb, s)).rgb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rbg, s)).rbg;
			}
		}
		else if (color.g <= color.r && color.g <= color.b)
		{
			if (color.r <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.grb, s)).grb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.gbr, s)).gbr;
			}
		}
		else
		{
			// Using bgr for both fixes part of hue
			if (color.r <= color.g)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.brg, s)).brg;
			}
			else
			{
				color  = vec3<f32>(setSaturationMinMidMax(color.bgr, s)).bgr;
			}
		}

		return color;
	}
	`;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/ColorBlend.mjs
var ColorBlend;
var init_ColorBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/ColorBlend.mjs"() {
    init_BlendModeFilter();
    init_GLhls();
    init_GPUhls();
    ColorBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                ${hslgl}

                vec3 blendColor(vec3 base, vec3 blend,  float opacity)
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendColor(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                ${hslgpu}

                fn blendColorOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendColorOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/ColorBurnBlend.mjs
var ColorBurnBlend;
var init_ColorBurnBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/ColorBurnBlend.mjs"() {
    init_BlendModeFilter();
    ColorBurnBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0 - ((1.0 - base) / blend)), 0.0);
                }

                vec3 blendColorBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                fragColor = vec4(blendColorBurn(back.rgb, front.rgb, front.a), uBlend);
            `
          },
          gpu: {
            functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn blendColorBurn(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendColorBurn(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/ColorDodgeBlend.mjs
var ColorDodgeBlend;
var init_ColorDodgeBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/ColorDodgeBlend.mjs"() {
    init_BlendModeFilter();
    ColorDodgeBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float colorDodge(float base, float blend)
                {
                    return base / (1.0 - blend);
                }

                vec3 blendColorDodge(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendColorDodge(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return base / (1.0 - blend);
                }

                fn blendColorDodge(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                    out = vec4<f32>(blendColorDodge(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/DarkenBlend.mjs
var DarkenBlend;
var init_DarkenBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/DarkenBlend.mjs"() {
    init_BlendModeFilter();
    DarkenBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                vec3 blendDarken(vec3 base, vec3 blend, float opacity)
                {
                    return (min(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendDarken(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn blendDarken(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (min(blend,base) * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendDarken(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/DifferenceBlend.mjs
var DifferenceBlend;
var init_DifferenceBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/DifferenceBlend.mjs"() {
    init_BlendModeFilter();
    DifferenceBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                vec3 blendDifference(vec3 base, vec3 blend,  float opacity)
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                fragColor = vec4(blendDifference(back.rgb, front.rgb, front.a), uBlend);
            `
          },
          gpu: {
            functions: `
                fn blendDifference(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendDifference(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/DivideBlend.mjs
var DivideBlend;
var init_DivideBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/DivideBlend.mjs"() {
    init_BlendModeFilter();
    DivideBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float divide(float base, float blend)
                {
                    return (blend > 0.0) ? clamp(base / blend, 0.0, 1.0) : 1.0;
                }

                vec3 blendDivide(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendDivide(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn divide(base: f32, blend: f32) -> f32
                {
                    return select(1.0, clamp(base / blend, 0.0, 1.0), blend > 0.0);
                }

                fn blendDivide(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendDivide(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/ExclusionBlend.mjs
var ExclusionBlend;
var init_ExclusionBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/ExclusionBlend.mjs"() {
    init_BlendModeFilter();
    ExclusionBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                vec3 exclusion(vec3 base, vec3 blend)
                {
                    return base + blend - 2.0 * base * blend;
                }

                vec3 blendExclusion(vec3 base, vec3 blend, float opacity)
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendExclusion(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn exclusion(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return base+blend-2.0*base*blend;
                }

                fn blendExclusion(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendExclusion(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/HardLightBlend.mjs
var HardLightBlend;
var init_HardLightBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/HardLightBlend.mjs"() {
    init_BlendModeFilter();
    HardLightBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float hardLight(float base, float blend)
                {
                    return (blend < 0.5) ? 2.0 * base * blend : 1.0 - 2.0 * (1.0 - base) * (1.0 - blend);
                }

                vec3 blendHardLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                fragColor = vec4(blendHardLight(back.rgb, front.rgb, front.a), uBlend);
            `
          },
          gpu: {
            functions: `
                fn hardLight(base: f32, blend: f32) -> f32
                {
                    return select(1.0 - 2.0 * (1.0 - base) * (1.0 - blend), 2.0 * base * blend, blend < 0.5);
                }

                fn blendHardLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendHardLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/HardMixBlend.mjs
var HardMixBlend;
var init_HardMixBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/HardMixBlend.mjs"() {
    init_BlendModeFilter();
    HardMixBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float hardMix(float base, float blend)
                {
                    return (base + blend >= 1.0) ? 1.0 : 0.0;
                }

                vec3 blendHardMix(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blended = vec3(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                fragColor = vec4(blendHardMix(back.rgb, front.rgb, front.a), uBlend);
            `
          },
          gpu: {
            functions: `
                fn hardMix(base: f32, blend: f32) -> f32
                {
                    return select(0.0, 1.0, base + blend >= 1.0);
                }

                fn blendHardMix(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendHardMix(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/LightenBlend.mjs
var LightenBlend;
var init_LightenBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/LightenBlend.mjs"() {
    init_BlendModeFilter();
    LightenBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                vec3 blendLighten(vec3 base, vec3 blend, float opacity)
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendLighten(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn blendLighten(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendLighten(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/LinearBurnBlend.mjs
var LinearBurnBlend;
var init_LinearBurnBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/LinearBurnBlend.mjs"() {
    init_BlendModeFilter();
    LinearBurnBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float linearBurn(float base, float blend)
                {
                    return max(0.0, base + blend - 1.0);
                }

                vec3 blendLinearBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendLinearBurn(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn blendLinearBurn(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendLinearBurn(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/LinearDodgeBlend.mjs
var LinearDodgeBlend;
var init_LinearDodgeBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/LinearDodgeBlend.mjs"() {
    init_BlendModeFilter();
    LinearDodgeBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                vec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendLinearDodge(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1, base + blend);
                }

                fn blendLinearDodge(base:vec3<f32>, blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendLinearDodge(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/LinearLightBlend.mjs
var LinearLightBlend;
var init_LinearLightBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/LinearLightBlend.mjs"() {
    init_BlendModeFilter();
    LinearLightBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float linearBurn(float base, float blend) {
                    return max(0.0, base + blend - 1.0);
                }

                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                float linearLight(float base, float blend) {
                    return (blend <= 0.5) ? linearBurn(base,2.0*blend) : linearBurn(base,2.0*(blend-0.5));
                }

                vec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                fragColor = vec4(blendLinearLight(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base + blend);
                }

                fn linearLight(base: f32, blend: f32) -> f32
                {
                    return select(linearBurn(base,2.0*(blend-0.5)), linearBurn(base,2.0*blend), blend <= 0.5);
                }

                fn blendLinearLightOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendLinearLightOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/LuminosityBlend.mjs
var LuminosityBlend;
var init_LuminosityBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/LuminosityBlend.mjs"() {
    init_BlendModeFilter();
    init_GLhls();
    init_GPUhls();
    LuminosityBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                ${hslgl}

                vec3 blendLuminosity(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendLuminosity = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendLuminosity(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                ${hslgpu}

                fn blendLuminosity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendLuminosity: vec3<f32> = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendLuminosity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/NegationBlend.mjs
var NegationBlend;
var init_NegationBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/NegationBlend.mjs"() {
    init_BlendModeFilter();
    NegationBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                vec3 negation(vec3 base, vec3 blend)
                {
                    return 1.0-abs(1.0-base-blend);
                }

                vec3 blendNegation(vec3 base, vec3 blend, float opacity)
                {
                    return (negation(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendNegation(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn blendNegation(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return 1.0-abs(1.0-base-blend);
                }

                fn blendNegationOpacity(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (blendNegation(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendNegationOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/OverlayBlend.mjs
var OverlayBlend;
var init_OverlayBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/OverlayBlend.mjs"() {
    init_BlendModeFilter();
    OverlayBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float overlay(float base, float blend)
                {
                    return (blend < 0.5) ? (2.0*base*blend) : (1.0-2.0*(1.0-base)*(1.0-blend));
                }

                vec3 blendOverlay(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendOverlay(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn overlay(base: f32, blend: f32) -> f32
                {
                    return select((1.0-2.0*(1.0-base)*(1.0-blend)), (2.0*base*blend), base < 0.5);
                }

                fn blendOverlay(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendOverlay(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/PinLightBlend.mjs
var PinLightBlend;
var init_PinLightBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/PinLightBlend.mjs"() {
    init_BlendModeFilter();
    PinLightBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float pinLight(float base, float blend)
                {
                    return (blend <= 0.5) ? min(base, 2.0 * blend) : max(base, 2.0 * (blend - 0.5));
                }

                vec3 blendPinLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                fragColor = vec4(blendPinLight(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn pinLight(base: f32, blend: f32) -> f32
                {
                    return select(max(base,2.0*(blend-0.5)), min(base,2.0*blend), blend <= 0.5);
                }

                fn blendPinLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendPinLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/SaturationBlend.mjs
var SaturationBlend;
var init_SaturationBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/SaturationBlend.mjs"() {
    init_BlendModeFilter();
    init_GLhls();
    init_GPUhls();
    SaturationBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                ${hslgl}

                vec3 blendSaturation(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                fragColor = vec4(blendSaturation(back.rgb, front.rgb, front.a), uBlend);
            `
          },
          gpu: {
            functions: `
                ${hslgpu}

                fn blendSaturation(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendSaturation(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/SoftLightBlend.mjs
var SoftLightBlend;
var init_SoftLightBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/SoftLightBlend.mjs"() {
    init_BlendModeFilter();
    SoftLightBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float softLight(float base, float blend)
                {
                    return (blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));
                }

                vec3 blendSoftLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendSoftLight(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn softLight(base: f32, blend: f32) -> f32
                {
                    return select(2.0 * base * blend + base * base * (1.0 - 2.0 * blend), sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend), blend < 0.5);
                }

                fn blendSoftLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendSoftLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/SubtractBlend.mjs
var SubtractBlend;
var init_SubtractBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/SubtractBlend.mjs"() {
    init_BlendModeFilter();
    SubtractBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float subtract(float base, float blend)
                {
                    return max(0.0, base - blend);
                }

                vec3 blendSubtract(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendSubtract(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn subtract(base: f32, blend: f32) -> f32
                {
                    return max(0, base - blend);
                }

                fn blendSubtract(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendSubtract(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/VividLightBlend.mjs
var VividLightBlend;
var init_VividLightBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/blend-modes/VividLightBlend.mjs"() {
    init_BlendModeFilter();
    VividLightBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                float colorDodge(float base, float blend)
                {
                    return min(1.0, base / (1.0-blend));
                }

                float vividLight(float base, float blend)
                {
                    return (blend < 0.5) ? colorBurn(base,(2.0*blend)) : colorDodge(base,(2.0*(blend-0.5)));
                }

                vec3 blendVividLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                fragColor = vec4(blendVividLight(back.rgb, front.rgb, front.a), uBlend);
            `
          },
          gpu: {
            functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base / (1.0-blend));
                }

                fn vividLight(base: f32, blend: f32) -> f32
                {
                    return select(colorDodge(base,(2.0*(blend-0.5))), colorBurn(base,(2.0*blend)), blend<0.5);
                }

                fn blendVividLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendVividLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs
var BLEND_MODE_FILTERS, BlendModePipe;
var init_BlendModePipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs"() {
    init_Extensions();
    init_ColorBlend();
    init_ColorBurnBlend();
    init_ColorDodgeBlend();
    init_DarkenBlend();
    init_DifferenceBlend();
    init_DivideBlend();
    init_ExclusionBlend();
    init_HardLightBlend();
    init_HardMixBlend();
    init_LightenBlend();
    init_LinearBurnBlend();
    init_LinearDodgeBlend();
    init_LinearLightBlend();
    init_LuminosityBlend();
    init_NegationBlend();
    init_OverlayBlend();
    init_PinLightBlend();
    init_SaturationBlend();
    init_SoftLightBlend();
    init_SubtractBlend();
    init_VividLightBlend();
    init_FilterEffect();
    init_warn();
    BLEND_MODE_FILTERS = {
      color: ColorBlend,
      "color-burn": ColorBurnBlend,
      "color-dodge": ColorDodgeBlend,
      darken: DarkenBlend,
      difference: DifferenceBlend,
      divide: DivideBlend,
      exclusion: ExclusionBlend,
      "hard-light": HardLightBlend,
      "hard-mix": HardMixBlend,
      lighten: LightenBlend,
      "linear-burn": LinearBurnBlend,
      "linear-dodge": LinearDodgeBlend,
      "linear-light": LinearLightBlend,
      luminosity: LuminosityBlend,
      negation: NegationBlend,
      overlay: OverlayBlend,
      "pin-light": PinLightBlend,
      saturation: SaturationBlend,
      "soft-light": SoftLightBlend,
      subtract: SubtractBlend,
      "vivid-light": VividLightBlend
    };
    BlendModePipe = class {
      constructor(renderer) {
        this._isAdvanced = false;
        this._filterHash = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      setBlendMode(renderable, blendMode, instructionSet) {
        if (this._activeBlendMode === blendMode) {
          if (this._isAdvanced)
            this._renderableList.push(renderable);
          return;
        }
        this._activeBlendMode = blendMode;
        if (this._isAdvanced) {
          this._endAdvancedBlendMode(instructionSet);
        }
        this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];
        if (this._isAdvanced) {
          this._beginAdvancedBlendMode(instructionSet);
          this._renderableList.push(renderable);
        }
      }
      _beginAdvancedBlendMode(instructionSet) {
        this._renderer.renderPipes.batch.break(instructionSet);
        const blendMode = this._activeBlendMode;
        if (!BLEND_MODE_FILTERS[blendMode]) {
          warn(`Unable to assign 'BLEND_MODES.${blendMode}' using the blend mode pipeline`);
          return;
        }
        if (!this._filterHash[blendMode]) {
          this._filterHash[blendMode] = new FilterEffect({
            filters: [new BLEND_MODE_FILTERS[blendMode]()]
          });
        }
        const instruction = {
          type: "filter",
          action: "pushFilter",
          renderables: [],
          filterEffect: this._filterHash[blendMode],
          canBundle: false
        };
        this._renderableList = instruction.renderables;
        instructionSet.add(instruction);
      }
      _endAdvancedBlendMode(instructionSet) {
        this._renderableList = null;
        this._renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          type: "filter",
          action: "popFilter",
          canBundle: false
        });
      }
      buildStart() {
        this._isAdvanced = false;
      }
      buildEnd(instructionSet) {
        if (this._isAdvanced) {
          this._endAdvancedBlendMode(instructionSet);
        }
      }
      destroy() {
        this._renderer = null;
        this._renderableList = null;
        for (const i3 in this._filterHash) {
          this._filterHash[i3].destroy();
        }
        this._filterHash = null;
      }
    };
    BlendModePipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "blendMode"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs
var _ExtractSystem, ExtractSystem;
var init_ExtractSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs"() {
    init_Extensions();
    init_Container();
    init_Texture();
    _ExtractSystem = class {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this._renderer = renderer;
      }
      _normalizeOptions(options, defaults = {}) {
        if (options instanceof Container || options instanceof Texture) {
          return {
            target: options,
            ...defaults
          };
        }
        return {
          ...defaults,
          ...options
        };
      }
      async image(options) {
        const image = new Image();
        image.src = await this.base64(options);
        return image;
      }
      async base64(options) {
        options = this._normalizeOptions(
          options,
          _ExtractSystem.defaultImageOptions
        );
        const { format: format3, quality } = options;
        const canvas3 = this.canvas(options);
        if (canvas3.toBlob !== void 0) {
          return new Promise((resolve2, reject) => {
            canvas3.toBlob((blob) => {
              if (!blob) {
                reject(new Error("ICanvas.toBlob failed!"));
                return;
              }
              const reader = new FileReader();
              reader.onload = () => resolve2(reader.result);
              reader.onerror = reject;
              reader.readAsDataURL(blob);
            }, format3, quality);
          });
        }
        if (canvas3.toDataURL !== void 0) {
          return canvas3.toDataURL(format3, quality);
        }
        if (canvas3.convertToBlob !== void 0) {
          const blob = await canvas3.convertToBlob({ type: format3, quality });
          return new Promise((resolve2, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve2(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          });
        }
        throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
      }
      canvas(options) {
        options = this._normalizeOptions(options);
        const target = options.target;
        const renderer = this._renderer;
        const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);
        const canvas3 = renderer.texture.generateCanvas(texture);
        if (target instanceof Container) {
          texture.destroy();
        }
        return canvas3;
      }
      pixels(options) {
        options = this._normalizeOptions(options);
        const target = options.target;
        const renderer = this._renderer;
        const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);
        const pixelInfo = renderer.texture.getPixels(texture);
        if (target instanceof Container) {
          texture.destroy();
        }
        return pixelInfo;
      }
      texture(options) {
        options = this._normalizeOptions(options);
        if (options.target instanceof Texture)
          return options.target;
        return this._renderer.textureGenerator.generateTexture(options);
      }
      download(options) {
        options = this._normalizeOptions(options);
        const canvas3 = this.canvas(options);
        const link = document.createElement("a");
        link.download = options.filename ?? "image.png";
        link.href = canvas3.toDataURL("image/png");
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
      log(options) {
        const width = options.width ?? 200;
        options = this._normalizeOptions(options);
        const canvas3 = this.canvas(options);
        const base64 = canvas3.toDataURL();
        console.log(`[Pixi Texture] ${canvas3.width}px ${canvas3.height}px`);
        const style = [
          "font-size: 1px;",
          `padding: ${width}px ${300}px;`,
          `background: url(${base64}) no-repeat;`,
          "background-size: contain;"
        ].join(" ");
        console.log("%c ", style);
      }
      destroy() {
        this._renderer = null;
      }
    };
    ExtractSystem = _ExtractSystem;
    ExtractSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "extract"
    };
    ExtractSystem.defaultImageOptions = {
      format: "png",
      quality: 1
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs
var RenderTexture;
var init_RenderTexture = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs"() {
    init_TextureSource();
    init_Texture();
    RenderTexture = class extends Texture {
      static create(options) {
        return new Texture({
          source: new TextureSource(options)
        });
      }
      resize(width, height, resolution) {
        this.source.resize(width, height, resolution);
        return this;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs
var tempRect2, tempBounds5, noColor, GenerateTextureSystem;
var init_GenerateTextureSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs"() {
    init_Color();
    init_Extensions();
    init_Matrix();
    init_Rectangle();
    init_Bounds();
    init_getLocalBounds();
    init_Container();
    init_RenderTexture();
    tempRect2 = new Rectangle();
    tempBounds5 = new Bounds();
    noColor = [0, 0, 0, 0];
    GenerateTextureSystem = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      /**
       * A Useful function that returns a texture of the display object that can then be used to create sprites
       * This can be quite useful if your container is complicated and needs to be reused multiple times.
       * @param {GenerateTextureOptions | Container} options - Generate texture options.
       * @param {Container} [options.container] - If not given, the renderer's resolution is used.
       * @param {Rectangle} options.region - The region of the container, that shall be rendered,
       *        if no region is specified, defaults to the local bounds of the container.
       * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.
       * @returns a shiny new texture of the container passed in
       */
      generateTexture(options) {
        if (options instanceof Container) {
          options = {
            target: options,
            frame: void 0,
            textureSourceOptions: {},
            resolution: void 0
          };
        }
        const resolution = options.resolution || this._renderer.resolution;
        const container = options.target;
        let clearColor = options.clearColor;
        if (clearColor) {
          const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;
          clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();
        } else {
          clearColor = noColor;
        }
        const region = options.frame?.copyTo(tempRect2) || getLocalBounds(container, tempBounds5).rectangle;
        region.width = Math.max(region.width, 1 / resolution) | 0;
        region.height = Math.max(region.height, 1 / resolution) | 0;
        const target = RenderTexture.create({
          ...options.textureSourceOptions,
          width: region.width,
          height: region.height,
          resolution
        });
        const transform = Matrix.shared.translate(-region.x, -region.y);
        this._renderer.render({
          container,
          transform,
          target,
          clearColor
        });
        return target;
      }
      destroy() {
        const writeable = this;
        writeable._renderer = null;
      }
    };
    GenerateTextureSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "textureGenerator"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs
var GlobalUniformSystem;
var init_GlobalUniformSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs"() {
    init_Extensions();
    init_Matrix();
    init_Point();
    init_BindGroup();
    init_UniformGroup();
    GlobalUniformSystem = class {
      constructor(renderer) {
        this._stackIndex = 0;
        this._globalUniformDataStack = [];
        this._uniformsPool = [];
        this._activeUniforms = [];
        this._bindGroupPool = [];
        this._activeBindGroups = [];
        this._renderer = renderer;
      }
      reset() {
        this._stackIndex = 0;
        for (let i3 = 0; i3 < this._activeUniforms.length; i3++) {
          this._uniformsPool.push(this._activeUniforms[i3]);
        }
        for (let i3 = 0; i3 < this._activeBindGroups.length; i3++) {
          this._bindGroupPool.push(this._activeBindGroups[i3]);
        }
        this._activeUniforms.length = 0;
        this._activeBindGroups.length = 0;
      }
      start(options) {
        this.reset();
        this.push(options);
      }
      bind({
        projectionData,
        worldTransformMatrix,
        worldColor,
        offset
      }) {
        const renderTarget = this._renderer.renderTarget.renderTarget;
        const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
          projectionData: renderTarget,
          worldTransformMatrix: new Matrix(),
          worldColor: 4294967295,
          offset: new Point()
        };
        const globalUniformData = {
          projectionMatrix: projectionData?.projectionMatrix || renderTarget.projectionMatrix,
          resolution: projectionData?.size || renderTarget.size,
          worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,
          worldColor: worldColor || currentGlobalUniformData.worldColor,
          offset: offset || currentGlobalUniformData.offset,
          bindGroup: null
        };
        const uniformGroup = this._uniformsPool.pop() || this._createUniforms();
        this._activeUniforms.push(uniformGroup);
        const uniforms = uniformGroup.uniforms;
        uniforms.projectionMatrix = globalUniformData.projectionMatrix;
        uniforms.uResolution = globalUniformData.resolution;
        uniforms.worldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);
        uniforms.worldTransformMatrix.tx -= globalUniformData.offset.x;
        uniforms.worldTransformMatrix.ty -= globalUniformData.offset.y;
        uniforms.worldAlpha = (globalUniformData.worldColor >> 24 & 255) / 255;
        uniformGroup.update();
        let bindGroup;
        if (this._renderer.renderPipes.uniformBatch) {
          bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);
        } else {
          this._renderer.uniformBuffer.updateUniformGroup(uniformGroup);
          bindGroup = this._bindGroupPool.pop() || new BindGroup();
          this._activeBindGroups.push(bindGroup);
          bindGroup.setResource(uniformGroup, 0);
        }
        globalUniformData.bindGroup = bindGroup;
        this._currentGlobalUniformData = globalUniformData;
      }
      push(options) {
        this.bind(options);
        this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
      }
      pop() {
        this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];
      }
      get bindGroup() {
        return this._currentGlobalUniformData.bindGroup;
      }
      get uniformGroup() {
        return this._currentGlobalUniformData.bindGroup.resources[0];
      }
      _createUniforms() {
        const globalUniforms = new UniformGroup({
          projectionMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          worldTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>
          worldAlpha: { value: 1, type: "f32" },
          uResolution: { value: [0, 0], type: "vec2<f32>" }
        }, {
          ubo: true,
          isStatic: true
        });
        return globalUniforms;
      }
      destroy() {
        const writeable = this;
        writeable._renderer = null;
      }
    };
    GlobalUniformSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "globalUniforms"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUBOElements.mjs
function createUBOElements(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    size: 0
  }));
  let size3 = 0;
  let chunkSize = 0;
  let offset = 0;
  for (let i3 = 0; i3 < uboElements.length; i3++) {
    const uboElement = uboElements[i3];
    size3 = WGSL_TO_STD40_SIZE[uboElement.data.type];
    if (!size3) {
      throw new Error(`Unknown type ${uboElement.data.type}`);
    }
    if (uboElement.data.size > 1) {
      size3 = Math.max(size3, 16) * uboElement.data.size;
    }
    uboElement.size = size3;
    if (chunkSize % size3 !== 0 && chunkSize < 16) {
      const lineUpValue = chunkSize % size3 % 16;
      chunkSize += lineUpValue;
      offset += lineUpValue;
    }
    if (chunkSize + size3 > 16) {
      offset = Math.ceil(offset / 16) * 16;
      uboElement.offset = offset;
      offset += size3;
      chunkSize = size3;
    } else {
      uboElement.offset = offset;
      chunkSize += size3;
      offset += size3;
    }
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}
var WGSL_TO_STD40_SIZE;
var init_createUBOElements = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUBOElements.mjs"() {
    WGSL_TO_STD40_SIZE = {
      "f32": 4,
      "vec2<f32>": 8,
      "vec3<f32>": 12,
      "vec4<f32>": 16,
      "mat2x2<f32>": 16 * 3,
      "mat3x3<f32>": 16 * 3,
      "mat4x4<f32>": 16 * 4
      // float:  4,
      // vec2:   8,
      // vec3:   12,
      // vec4:   16,
      // int:      4,
      // ivec2:    8,
      // ivec3:    12,
      // ivec4:    16,
      // uint:     4,
      // uvec2:    8,
      // uvec3:    12,
      // uvec4:    16,
      // bool:     4,
      // bvec2:    8,
      // bvec3:    12,
      // bvec4:    16,
      // mat2:     16 * 2,
      // mat3:     16 * 3,
      // mat4:     16 * 4,
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformBufferParsers.mjs
var uniformBufferParsers;
var init_uniformBufferParsers = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformBufferParsers.mjs"() {
    uniformBufferParsers = [
      // uploading pixi matrix object to mat3
      {
        type: "mat3x3<f32>",
        test: (data) => data.value.a !== void 0,
        code: (name) => `
                var ${name}_matrix = uv.${name}.toArray(true);

                data[offset] = ${name}_matrix[0];
                data[offset+1] = ${name}_matrix[1];
                data[offset+2] = ${name}_matrix[2];

                data[offset + 4] = ${name}_matrix[3];
                data[offset + 5] = ${name}_matrix[4];
                data[offset + 6] = ${name}_matrix[5];

                data[offset + 8] = ${name}_matrix[6];
                data[offset + 9] = ${name}_matrix[7];
                data[offset + 10] = ${name}_matrix[8];
            `
      },
      {
        type: "vec4<f32>",
        test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.width !== void 0,
        code: (name) => `
                        v = uv.${name};

                        data[offset] = v.x;
                        data[offset+1] = v.y;
                        data[offset+2] = v.width;
                        data[offset+3] = v.height;
                    `
      },
      {
        type: "vec2<f32>",
        test: (data) => data.type === "vec2<f32>" && data.size === 1 && data.value.x !== void 0,
        code: (name) => `
                    v = uv.${name};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                `
      }
      // uploading a pixi point as a vec2 with caching layer
      // {
      //     test: (data: any, uniform: any): boolean =>
      //         data.type === 'vec2' && data.size === 1 && uniform.x !== undefined,
      //     code: (name: string): string =>
      //         `
      //             v = uv.${name};
      //             data[offset] = v.x;
      //             data[offset+1] = v.y;
      //         `,
      // },
      // caching layer for a vec2
      // {
      //     test: (data: any): boolean =>
      //         data.type === 'vec2' && data.size === 1,
      //     code: (name: string): string =>
      //         `
      //             cv = ud["${name}"].value;
      //             v = uv["${name}"];
      //             if(cv[0] !== v[0] || cv[1] !== v[1])
      //             {
      //                 cv[0] = v[0];
      //                 cv[1] = v[1];
      //                 gl.uniform2f(ud["${name}"].location, v[0], v[1]);
      //             }
      //         `,
      // },
      // upload a pixi rectangle as a vec4 with caching layer
      // {
      //     test: (data: any, uniform: any): boolean =>
      //         data.type === 'vec4' && data.size === 1 && uniform.width !== undefined,
      //     code: (name: string): string =>
      //         `
      //                 v = uv.${name};
      //                 data[offset] = v.x;
      //                 data[offset+1] = v.y;
      //                 data[offset+2] = v.width;
      //                 data[offset+3] = v.height;
      //             `,
      // },
      // a caching layer for vec4 uploading
      // {
      //     test: (data: any): boolean =>
      //         data.type === 'vec4' && data.size === 1,
      //     code: (name: string): string =>
      //         `
      //             cv = ud["${name}"].value;
      //             v = uv["${name}"];
      //             if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
      //             {
      //                 cv[0] = v[0];
      //                 cv[1] = v[1];
      //                 cv[2] = v[2];
      //                 cv[3] = v[3];
      //                 gl.uniform4f(ud["${name}"].location, v[0], v[1], v[2], v[3])
      //             }`,
      // },
    ];
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUniformBufferSync.mjs
function generateUniformBufferSync(uboElements) {
  const funcFragments = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
    `];
  let prev = 0;
  for (let i3 = 0; i3 < uboElements.length; i3++) {
    const uboElement = uboElements[i3];
    const name = uboElement.data.name;
    let parsed = false;
    let offset = 0;
    for (let j3 = 0; j3 < uniformBufferParsers.length; j3++) {
      const uniformParser = uniformBufferParsers[j3];
      if (uniformParser.test(uboElement.data)) {
        offset = uboElement.offset / 4;
        funcFragments.push(
          `offset += ${offset - prev};`,
          uniformBufferParsers[j3].code(name)
        );
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      if (uboElement.data.size > 1) {
        const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
        const elementSize = uboElement.data.value.length / uboElement.data.size;
        const remainder = (4 - elementSize % 4) % 4;
        offset = uboElement.offset / 4;
        funcFragments.push(
          /* wgsl */
          `
                    v = uv.${name};
                    offset += ${offset - prev};

                    let arrayOffset = offset;
                    
                    t = 0;

                    for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
                    {
                        for(var j = 0; j < ${elementSize}; j++)
                        {
                            data[arrayOffset++] = v[t++];
                        }
                        ${remainder !== 0 ? "arrayOffset += ${remainder};" : ""}
                    }
                `
        );
      } else {
        const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
        offset = uboElement.offset / 4;
        funcFragments.push(
          /* wgsl */
          `
                    v = uv.${name};
                    offset += ${offset - prev};
                    ${template};
                `
        );
      }
    }
    prev = offset;
  }
  const fragmentSrc = funcFragments.join("\n");
  return new Function(
    "uv",
    "data",
    "offset",
    fragmentSrc
  );
}
var UBO_TO_SINGLE_SETTERS;
var init_createUniformBufferSync = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUniformBufferSync.mjs"() {
    init_createUBOElements();
    init_uniformBufferParsers();
    UBO_TO_SINGLE_SETTERS = {
      "f32": `
        data[offset] = v;
    `,
      "vec2<f32>": `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
      "vec3<f32>": `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
      "vec4<f32>": `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
      "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
      "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
      "mat4x4<f32>": `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformBufferSystem.mjs
var UniformBufferSystem;
var init_UniformBufferSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformBufferSystem.mjs"() {
    init_Extensions();
    init_Buffer();
    init_const5();
    init_createUBOElements();
    init_createUniformBufferSync();
    UniformBufferSystem = class {
      constructor() {
        this._syncFunctionHash = /* @__PURE__ */ Object.create(null);
      }
      ensureUniformGroup(uniformGroup) {
        if (!uniformGroup._syncFunction) {
          this._initUniformGroup(uniformGroup);
        }
      }
      _initUniformGroup(uniformGroup) {
        const uniformGroupSignature = uniformGroup.signature;
        let uniformData = this._syncFunctionHash[uniformGroupSignature];
        if (!uniformData) {
          const elements = Object.keys(uniformGroup.uniformStructures).map((i3) => uniformGroup.uniformStructures[i3]);
          const layout = createUBOElements(elements);
          const syncFunction = generateUniformBufferSync(layout.uboElements);
          uniformData = this._syncFunctionHash[uniformGroupSignature] = {
            layout,
            syncFunction
          };
        }
        uniformGroup._syncFunction = uniformData.syncFunction;
        uniformGroup.buffer = new Buffer2({
          data: new Float32Array(uniformData.layout.size / 4),
          usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
        });
        return uniformGroup._syncFunction;
      }
      syncUniformGroup(uniformGroup, data, offset) {
        const syncFunction = uniformGroup._syncFunction || this._initUniformGroup(uniformGroup);
        data || (data = uniformGroup.buffer.data);
        offset || (offset = 0);
        syncFunction(uniformGroup.uniforms, data, offset);
        return true;
      }
      updateUniformGroup(uniformGroup) {
        if (uniformGroup.isStatic && !uniformGroup.dirtyId)
          return false;
        uniformGroup.dirtyId = 0;
        const synced = this.syncUniformGroup(uniformGroup);
        uniformGroup.buffer.update();
        return synced;
      }
      destroy() {
        this._syncFunctionHash = null;
      }
    };
    UniformBufferSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "uniformBuffer"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/sayHello.mjs
function sayHello(type2) {
  if (saidHello) {
    return;
  }
  if (settings.ADAPTER.getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
    const args = [
      `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type2}) http://www.pixijs.com/

`,
      "background: #E72264; padding:5px 0;",
      "background: #6CA2EA; padding:5px 0;",
      "background: #B5D33D; padding:5px 0;",
      "background: #FED23F; padding:5px 0;",
      "color: #FFFFFF; background: #E72264; padding:5px 0;",
      "color: #E72264; background: #FFFFFF; padding:5px 0;"
    ];
    globalThis.console.log(...args);
  } else if (globalThis.console) {
    globalThis.console.log(`PixiJS ${VERSION} - ${type2} - http://www.pixijs.com/`);
  }
  saidHello = true;
}
var saidHello, VERSION;
var init_sayHello = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/sayHello.mjs"() {
    init_settings();
    saidHello = false;
    VERSION = "8.0.0-beta.3";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs
var HelloSystem;
var init_HelloSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs"() {
    init_Extensions();
    init_sayHello();
    HelloSystem = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      /**
       * It all starts here! This initiates every system, passing in the options for any system by name.
       * @param options - the config for the renderer and all its systems
       */
      init(options) {
        if (options.hello) {
          sayHello(this._renderer.name);
        }
      }
    };
    HelloSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "hello",
      priority: 0
    };
    HelloSystem.defaultOptions = {
      /**
       * {@link WebGLOptions.hello}
       * @default false
       */
      hello: false
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs
var _TextureGCSystem, TextureGCSystem;
var init_TextureGCSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs"() {
    init_Extensions();
    _TextureGCSystem = class {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this._renderer = renderer;
        this.count = 0;
        this.checkCount = 0;
      }
      init(options) {
        options = { ..._TextureGCSystem.defaultOptions, ...options };
        this.checkCountMax = options.textureGCCheckCountMax;
        this.maxIdle = options.textureGCAMaxIdle;
        this.active = options.textureGCActive;
      }
      /**
       * Checks to see when the last time a texture was used.
       * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
       */
      postrender() {
        if (!this._renderer.renderingToScreen) {
          return;
        }
        this.count++;
        if (!this.active)
          return;
        this.checkCount++;
        if (this.checkCount > this.checkCountMax) {
          this.checkCount = 0;
          this.run();
        }
      }
      /**
       * Checks to see when the last time a texture was used.
       * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
       */
      run() {
        const managedTextures = this._renderer.texture.managedTextures;
        for (let i3 = 0; i3 < managedTextures.length; i3++) {
          const texture = managedTextures[i3];
          if (texture.resource && texture.touched > -1 && this.count - texture.touched > this.maxIdle) {
            texture.touched = -1;
            texture.unload();
          }
        }
      }
      destroy() {
        this._renderer = null;
      }
    };
    TextureGCSystem = _TextureGCSystem;
    TextureGCSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "textureGC"
    };
    TextureGCSystem.defaultOptions = {
      textureGCActive: true,
      textureGCAMaxIdle: 60 * 60,
      textureGCCheckCountMax: 600
    };
    extensions.add(TextureGCSystem);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs
var CanvasSource;
var init_CanvasSource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs"() {
    init_settings();
    init_TextureSource();
    CanvasSource = class extends TextureSource {
      constructor(options) {
        if (!options.resource) {
          options.resource = settings.ADAPTER.createCanvas();
        }
        if (!options.width) {
          options.width = options.resource.width;
          if (!options.autoDensity) {
            options.width /= options.resolution;
          }
        }
        if (!options.height) {
          options.height = options.resource.height;
          if (!options.autoDensity) {
            options.height /= options.resolution;
          }
        }
        options.alphaMode ?? (options.alphaMode = "premultiply-alpha-on-upload");
        super(options);
        this.uploadMethodId = "image";
        this.autoDensity = options.autoDensity;
        const canvas3 = options.resource;
        if (this.pixelWidth !== canvas3.width || this.pixelWidth !== canvas3.height) {
          this.resizeCanvas();
        }
      }
      resizeCanvas() {
        if (this.autoDensity) {
          this.resource.style.width = `${this.width}px`;
          this.resource.style.height = `${this.height}px`;
        }
        this.resource.width = this.pixelWidth;
        this.resource.height = this.pixelHeight;
      }
      resize(width = this.width, height = this.height, resolution = this._resolution) {
        super.resize(width, height, resolution);
        this.resizeCanvas();
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs
function getCanvasTexture(canvas3, options) {
  if (!canvasCache.has(canvas3)) {
    const texture = new Texture({
      source: new CanvasSource({
        resource: canvas3,
        ...options
      })
    });
    canvasCache.set(canvas3, texture);
  }
  return canvasCache.get(canvas3);
}
var canvasCache;
var init_getCanvasTexture = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs"() {
    init_CanvasSource();
    init_Texture();
    canvasCache = /* @__PURE__ */ new Map();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs
var _ViewSystem, ViewSystem;
var init_ViewSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs"() {
    init_Extensions();
    init_Rectangle();
    init_settings();
    init_deprecation();
    init_getCanvasTexture();
    _ViewSystem = class {
      get resolution() {
        return this.texture.source._resolution;
      }
      set resolution(value) {
        this.texture.source.resize(
          this.texture.source.width,
          this.texture.source.height,
          value
        );
      }
      /**
       * initiates the view system
       * @param options - the options for the view
       */
      init(options) {
        options = {
          ..._ViewSystem.defaultOptions,
          ...options
        };
        if (options.element) {
          deprecation(v8_0_0, "ViewSystem.element has been renamed to ViewSystem.canvas");
          options.canvas = options.element;
        }
        this.screen = new Rectangle(0, 0, options.width, options.height);
        this.canvas = options.canvas || settings.ADAPTER.createCanvas();
        this.antialias = !!options.antialias;
        this.texture = getCanvasTexture(this.canvas, options);
        this.multiView = !!options.multiView;
        if (this.autoDensity) {
          this.canvas.style.width = `${this.texture.width}px`;
          this.canvas.style.height = `${this.texture.height}px`;
        }
      }
      /**
       * Resizes the screen and canvas to the specified dimensions.
       * @param desiredScreenWidth - The new width of the screen.
       * @param desiredScreenHeight - The new height of the screen.
       * @param resolution
       */
      resize(desiredScreenWidth, desiredScreenHeight, resolution) {
        this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);
        this.screen.width = this.texture.frameWidth;
        this.screen.height = this.texture.frameHeight;
        if (this.autoDensity) {
          this.canvas.style.width = `${desiredScreenWidth}px`;
          this.canvas.style.height = `${desiredScreenHeight}px`;
        }
      }
      /**
       * Destroys this System and optionally removes the canvas from the dom.
       * @param {options | false} options - The options for destroying the view, or "false".
       * @param options.removeView - Whether to remove the view element from the DOM. Defaults to `false`.
       */
      destroy(options = false) {
        const removeView = typeof options === "boolean" ? options : !!options?.removeView;
        if (removeView && this.canvas.parentNode) {
          this.canvas.parentNode.removeChild(this.canvas);
        }
      }
    };
    ViewSystem = _ViewSystem;
    ViewSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "view",
      priority: 0
    };
    ViewSystem.defaultOptions = {
      /**
       * {@link WebGLOptions.width}
       * @default 800
       */
      width: 800,
      /**
       * {@link WebGLOptions.height}
       * @default 600
       */
      height: 600,
      /**
       * {@link WebGLOptions.resolution}
       * @type {number}
       * @default settings.RESOLUTION
       */
      resolution: settings.RESOLUTION,
      /**
       * {@link WebGLOptions.autoDensity}
       * @default false
       */
      autoDensity: false,
      /**
       * {@link WebGLOptions.antialias}
       * @default false
       */
      antialias: false
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs
var SharedSystems, SharedRenderPipes;
var init_SharedSystems = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs"() {
    init_AccessibilitySystem();
    init_FilterPipe();
    init_FilterSystem();
    init_LayerPipe();
    init_LayerSystem();
    init_GraphicsContextSystem();
    init_GraphicsPipe();
    init_MeshPipe();
    init_SpritePipe();
    init_TilingSpritePipe();
    init_BitmapTextPipe();
    init_CanvasTextPipe();
    init_CanvasTextSystem();
    init_HTMLTextPipe();
    init_HTMLTextSystem();
    init_BatcherPipe();
    init_AlphaMaskPipe();
    init_ColorMaskPipe();
    init_StencilMaskPipe();
    init_BackgroundSystem();
    init_BlendModePipe();
    init_ExtractSystem();
    init_GenerateTextureSystem();
    init_GlobalUniformSystem();
    init_UniformBufferSystem();
    init_HelloSystem();
    init_TextureGCSystem();
    init_ViewSystem();
    SharedSystems = [
      BackgroundSystem,
      FilterSystem,
      GraphicsContextSystem,
      GlobalUniformSystem,
      HelloSystem,
      ViewSystem,
      CanvasTextSystem,
      HTMLTextSystem,
      LayerSystem,
      UniformBufferSystem,
      TextureGCSystem,
      GenerateTextureSystem,
      ExtractSystem,
      AccessibilitySystem
    ];
    SharedRenderPipes = [
      BlendModePipe,
      BatcherPipe,
      SpritePipe,
      LayerPipe,
      MeshPipe,
      GraphicsPipe,
      CanvasTextPipe,
      HTMLTextPipe,
      BitmapTextPipe,
      TilingSpritePipe,
      FilterPipe,
      AlphaMaskPipe,
      StencilMaskPipe,
      ColorMaskPipe
    ];
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs
var BindGroupSystem;
var init_BindGroupSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs"() {
    init_Extensions();
    BindGroupSystem = class {
      constructor(renderer) {
        this._hash = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
      getBindGroup(bindGroup, program, groupIndex) {
        bindGroup.updateKey();
        const gpuBindGroup = this._hash[bindGroup.key] || this._createBindGroup(bindGroup, program, groupIndex);
        return gpuBindGroup;
      }
      _createBindGroup(group, program, groupIndex) {
        const device = this._gpu.device;
        const groupLayout = program.layout[groupIndex];
        const entries = [];
        for (const j3 in groupLayout) {
          const resource = group.resources[j3] ?? group.resources[groupLayout[j3]];
          let gpuResource;
          if (resource.resourceType === "uniformGroup") {
            const uniformGroup = resource;
            this._renderer.uniformBuffer.updateUniformGroup(uniformGroup);
            const buffer2 = uniformGroup.buffer;
            gpuResource = {
              buffer: this._renderer.buffer.getGPUBuffer(buffer2),
              offset: 0,
              size: buffer2.descriptor.size
            };
          } else if (resource.resourceType === "buffer") {
            const buffer2 = resource;
            gpuResource = {
              buffer: this._renderer.buffer.getGPUBuffer(buffer2),
              offset: 0,
              size: buffer2.descriptor.size
            };
          } else if (resource.resourceType === "bufferResource") {
            const bufferResource = resource;
            gpuResource = {
              buffer: this._renderer.buffer.getGPUBuffer(bufferResource.buffer),
              offset: bufferResource.offset,
              size: bufferResource.size
            };
          } else if (resource.resourceType === "textureSampler") {
            const sampler = resource;
            gpuResource = this._renderer.texture.getGpuSampler(sampler);
          } else if (resource.resourceType === "textureSource") {
            const texture = resource;
            gpuResource = this._renderer.texture.getGpuSource(texture).createView({});
          }
          entries.push({
            binding: groupLayout[j3],
            resource: gpuResource
          });
        }
        const gpuBindGroup = device.createBindGroup({
          layout: program._gpuLayout.bindGroups[groupIndex],
          entries
        });
        this._hash[group.key] = gpuBindGroup;
        return gpuBindGroup;
      }
      destroy() {
        for (const key2 of Object.keys(this._hash)) {
          this._hash[key2] = null;
        }
        this._hash = null;
        const writeable = this;
        writeable._renderer = null;
      }
    };
    BindGroupSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "bindGroup"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs
var BufferSystem;
var init_GpuBufferSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs"() {
    init_Extensions();
    init_fastCopy();
    BufferSystem = class {
      constructor() {
        this._gpuBuffers = /* @__PURE__ */ Object.create(null);
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
      getGPUBuffer(buffer2) {
        return this._gpuBuffers[buffer2.uid] || this.createGPUBuffer(buffer2);
      }
      updateBuffer(buffer2) {
        const gpuBuffer = this._gpuBuffers[buffer2.uid] || this.createGPUBuffer(buffer2);
        if (buffer2._updateID && buffer2.data) {
          buffer2._updateID = 0;
          this._gpu.device.queue.writeBuffer(gpuBuffer, 0, buffer2.data.buffer, 0, buffer2._updateSize);
        }
        return gpuBuffer;
      }
      /** dispose all WebGL resources of all managed buffers */
      destroyAll() {
        for (const id in this._gpuBuffers) {
          this._gpuBuffers[id].destroy();
        }
        this._gpuBuffers = {};
      }
      createGPUBuffer(buffer2) {
        const gpuBuffer = this._gpu.device.createBuffer(buffer2.descriptor);
        buffer2._updateID = 0;
        if (buffer2.data) {
          fastCopy(buffer2.data.buffer, gpuBuffer.getMappedRange());
          gpuBuffer.unmap();
        }
        this._gpuBuffers[buffer2.uid] = gpuBuffer;
        buffer2.on("update", this.updateBuffer, this);
        buffer2.on("change", this.onBufferChange, this);
        buffer2.on("destroy", this.onBufferDestroy, this);
        return gpuBuffer;
      }
      onBufferChange(buffer2) {
        let gpuBuffer = this._gpuBuffers[buffer2.uid];
        gpuBuffer.destroy();
        gpuBuffer = this.createGPUBuffer(buffer2);
        buffer2._updateID = 0;
      }
      /**
       * Disposes buffer
       * @param buffer - buffer with data
       */
      onBufferDestroy(buffer2) {
        const gpuBuffer = this._gpuBuffers[buffer2.uid];
        gpuBuffer.destroy();
        this._gpuBuffers[buffer2.uid] = null;
      }
      destroy() {
        for (const k3 of Object.keys(this._gpuBuffers)) {
          const key2 = Number(k3);
          const gpuBuffer = this._gpuBuffers[key2];
          gpuBuffer.destroy();
          this._gpuBuffers[key2] = null;
        }
        this._gpuBuffers = null;
        const writeable = this;
        writeable._renderer = null;
      }
    };
    BufferSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "buffer"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs
var GpuColorMaskSystem;
var init_GpuColorMaskSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs"() {
    init_Extensions();
    GpuColorMaskSystem = class {
      constructor(renderer) {
        this._colorMaskCache = 15;
        this._renderer = renderer;
      }
      setMask(colorMask) {
        if (this._colorMaskCache === colorMask)
          return;
        this._colorMaskCache = colorMask;
        this._renderer.pipeline.setColorMask(colorMask);
      }
      destroy() {
        const writeable = this;
        writeable._renderer = null;
        this._colorMaskCache = null;
      }
    };
    GpuColorMaskSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "colorMask"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs
var GpuDeviceSystem;
var init_GpuDeviceSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs"() {
    init_Extensions();
    GpuDeviceSystem = class {
      /**
       * @param {WebGPURenderer} renderer - The renderer this System works for.
       */
      constructor(renderer) {
        this._renderer = renderer;
      }
      async init() {
        if (this._initPromise)
          return this._initPromise;
        this._initPromise = this._createDeviceAndAdaptor({}).then((gpu) => {
          this.gpu = gpu;
          this._renderer.runners.contextChange.emit(this.gpu);
        });
        return this._initPromise;
      }
      /**
       * Handle the context change event
       * @param gpu
       */
      contextChange(gpu) {
        this._renderer.gpu = gpu;
      }
      /**
       * Helper class to create a WebGL Context
       * @param {object} options - An options object that gets passed in to the canvas element containing the
       *    context attributes
       * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
       * @returns {WebGLRenderingContext} the WebGL context
       */
      async _createDeviceAndAdaptor(options) {
        const adapter = await navigator.gpu.requestAdapter(options);
        const device = await adapter.requestDevice();
        return { adapter, device };
      }
      destroy() {
        this.gpu = null;
        this._renderer = null;
      }
    };
    GpuDeviceSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "device"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs
var GpuEncoderSystem;
var init_GpuEncoderSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs"() {
    init_Extensions();
    GpuEncoderSystem = class {
      constructor(renderer) {
        this._boundBindGroup = /* @__PURE__ */ Object.create(null);
        this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      start() {
        this.commandFinished = new Promise((resolve2) => {
          this._resolveCommandFinished = resolve2;
        });
        this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();
      }
      beginRenderPass(renderTarget, gpuRenderTarget) {
        if (this.renderPassEncoder) {
          this.renderPassEncoder.end();
        }
        this._clearCache();
        this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);
        this._setViewport(renderTarget.viewport);
      }
      _setViewport(viewport) {
        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
      }
      setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {
        const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);
        this.setPipeline(pipeline);
      }
      setPipeline(pipeline) {
        if (this._boundPipeline === pipeline)
          return;
        this._boundPipeline = pipeline;
        this.renderPassEncoder.setPipeline(pipeline);
      }
      _setVertexBuffer(index, buffer2) {
        if (this._boundVertexBuffer[index] === buffer2)
          return;
        this._boundVertexBuffer[index] = buffer2;
        this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer2));
      }
      _setIndexBuffer(buffer2) {
        if (this._boundIndexBuffer === buffer2)
          return;
        this._boundIndexBuffer = buffer2;
        this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer2), "uint32");
      }
      setBindGroup(index, bindGroup, program) {
        if (this._boundBindGroup[index] === bindGroup)
          return;
        this._boundBindGroup[index] = bindGroup;
        bindGroup.touch(this._renderer.textureGC.count);
        const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);
        this.renderPassEncoder.setBindGroup(index, gpuBindGroup);
      }
      setGeometry(geometry) {
        for (const i3 in geometry.attributes) {
          const attribute = geometry.attributes[i3];
          this._setVertexBuffer(attribute.shaderLocation, attribute.buffer);
        }
        if (geometry.indexBuffer) {
          this._setIndexBuffer(geometry.indexBuffer);
        }
      }
      _setShaderBindGroups(shader, skipSync) {
        for (const i3 in shader.groups) {
          const bindGroup = shader.groups[i3];
          if (!skipSync) {
            this._syncBindGroup(bindGroup);
          }
          this.setBindGroup(i3, bindGroup, shader.gpuProgram);
        }
      }
      _syncBindGroup(bindGroup) {
        for (const j3 in bindGroup.resources) {
          const resource = bindGroup.resources[j3];
          if (resource.isUniformGroup) {
            this._renderer.uniformBuffer.updateUniformGroup(resource);
          }
        }
      }
      draw(options) {
        const { geometry, shader, state, topology, size: size3, start, instanceCount, skipSync } = options;
        this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);
        this.setGeometry(geometry);
        this._setShaderBindGroups(shader, skipSync);
        if (geometry.indexBuffer) {
          this.renderPassEncoder.drawIndexed(size3 || geometry.indexBuffer.data.length, instanceCount || 1, start || 0);
        } else {
          this.renderPassEncoder.draw(size3 || geometry.getSize(), instanceCount || 1, start || 0);
        }
      }
      finishRenderPass() {
        if (this.renderPassEncoder) {
          this.renderPassEncoder.end();
          this.renderPassEncoder = null;
        }
      }
      postrender() {
        this.finishRenderPass();
        this._gpu.device.queue.submit([this.commandEncoder.finish()]);
        this._resolveCommandFinished();
      }
      // restores a render pass if finishRenderPass was called
      // not optimised as really used for debugging!
      // used when we want to stop drawing and log a texture..
      restoreRenderPass() {
        const descriptor = this._renderer.renderTarget.getDescriptor(
          this._renderer.renderTarget.renderTarget,
          false,
          [0, 0, 0, 1]
        );
        this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);
        const boundPipeline = this._boundPipeline;
        const boundVertexBuffer = { ...this._boundVertexBuffer };
        const boundIndexBuffer = this._boundIndexBuffer;
        const boundBindGroup = { ...this._boundBindGroup };
        this._clearCache();
        const viewport = this._renderer.renderTarget.renderTarget.viewport;
        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
        this.setPipeline(boundPipeline);
        for (const i3 in boundVertexBuffer) {
          this._setVertexBuffer(i3, boundVertexBuffer[i3]);
        }
        for (const i3 in boundBindGroup) {
          this.setBindGroup(i3, boundBindGroup[i3], null);
        }
        this._setIndexBuffer(boundIndexBuffer);
      }
      _clearCache() {
        for (let i3 = 0; i3 < 16; i3++) {
          this._boundBindGroup[i3] = null;
          this._boundVertexBuffer[i3] = null;
        }
        this._boundIndexBuffer = null;
        this._boundPipeline = null;
      }
      destroy() {
        const writeable = this;
        writeable._renderer = null;
        this._gpu = null;
        this._boundBindGroup = null;
        this._boundVertexBuffer = null;
        this._boundIndexBuffer = null;
        this._boundPipeline = null;
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
    };
    GpuEncoderSystem.extension = {
      type: [ExtensionType.WebGPUSystem],
      name: "encoder"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs
var GpuStencilSystem;
var init_GpuStencilSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs"() {
    init_Extensions();
    init_const8();
    GpuStencilSystem = class {
      constructor(renderer) {
        this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
        renderer.renderTarget.onRenderTargetChange.add(this);
      }
      onRenderTargetChange(renderTarget) {
        let stencilState = this._renderTargetStencilState[renderTarget.uid];
        if (!stencilState) {
          stencilState = this._renderTargetStencilState[renderTarget.uid] = {
            stencilMode: STENCIL_MODES.DISABLED,
            stencilReference: 0
          };
        }
        this._activeRenderTarget = renderTarget;
        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
      }
      setStencilMode(stencilMode, stencilReference) {
        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
        stencilState.stencilMode = stencilMode;
        stencilState.stencilReference = stencilReference;
        const renderer = this._renderer;
        renderer.pipeline.setStencilMode(stencilMode);
        renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);
      }
      destroy() {
        this._renderer.renderTarget.onRenderTargetChange.remove(this);
        const writeable = this;
        writeable._renderer = null;
        this._activeRenderTarget = null;
        this._renderTargetStencilState = null;
      }
    };
    GpuStencilSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "stencil"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs
var BufferResource;
var init_BufferResource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs"() {
    init_eventemitter3();
    init_uid();
    BufferResource = class extends eventemitter3_default {
      constructor({ buffer: buffer2, offset, size: size3 }) {
        super();
        this.uid = uid("buffer");
        this.touched = 0;
        this.resourceType = "bufferResource";
        this.resourceId = uid("buffer");
        this.bufferResource = true;
        this.buffer = buffer2;
        this.offset = offset;
        this.size = size3;
        this.buffer.on("change", this.onBufferChange, this);
      }
      onBufferChange() {
        this.resourceId = uid("buffer");
        this.emit("change", this);
      }
      destroy(destroyBuffer = false) {
        if (destroyBuffer) {
          this.buffer.destroy();
        }
        this.buffer = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UniformBufferBatch.mjs
var UniformBufferBatch;
var init_UniformBufferBatch = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UniformBufferBatch.mjs"() {
    UniformBufferBatch = class {
      constructor({ minUniformOffsetAlignment: minUniformOffsetAlignment2 }) {
        this._minUniformOffsetAlignment = 256;
        this.byteIndex = 0;
        this._minUniformOffsetAlignment = minUniformOffsetAlignment2;
        this.data = new Float32Array(65535);
      }
      clear() {
        this.byteIndex = 0;
      }
      addEmptyGroup(size3) {
        if (size3 > this._minUniformOffsetAlignment / 4) {
          throw new Error(`UniformBufferBatch: array is too large: ${size3 * 4}`);
        }
        const start = this.byteIndex;
        let newSize = start + size3 * 4;
        newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;
        if (newSize > this.data.length * 4) {
          throw new Error("UniformBufferBatch: ubo batch got too big");
        }
        this.byteIndex = newSize;
        return start;
      }
      addGroup(array) {
        const offset = this.addEmptyGroup(array.length);
        for (let i3 = 0; i3 < array.length; i3++) {
          this.data[offset / 4 + i3] = array[i3];
        }
        return offset;
      }
      destroy() {
        this._buffer.destroy();
        this._buffer = null;
        this.data = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs
var minUniformOffsetAlignment, GpuUniformBatchPipe;
var init_GpuUniformBatchPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs"() {
    init_Extensions();
    init_Buffer();
    init_BufferResource();
    init_const5();
    init_UniformBufferBatch();
    init_BindGroup();
    minUniformOffsetAlignment = 128;
    GpuUniformBatchPipe = class {
      constructor(renderer) {
        this._bindGroupHash = /* @__PURE__ */ Object.create(null);
        this._buffers = [];
        this._bindGroups = [];
        this._bufferResources = [];
        this._renderer = renderer;
        this._batchBuffer = new UniformBufferBatch({ minUniformOffsetAlignment });
        const totalBuffers = 256 / minUniformOffsetAlignment;
        for (let i3 = 0; i3 < totalBuffers; i3++) {
          let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;
          if (i3 === 0)
            usage |= BufferUsage.COPY_SRC;
          this._buffers.push(new Buffer2({
            data: this._batchBuffer.data,
            usage
          }));
        }
      }
      renderEnd() {
        this._uploadBindGroups();
        this._resetBindGroups();
      }
      _resetBindGroups() {
        for (const i3 in this._bindGroupHash) {
          this._bindGroupHash[i3] = null;
        }
        this._batchBuffer.clear();
      }
      // just works for single bind groups for now
      getUniformBindGroup(group, duplicate) {
        if (!duplicate && this._bindGroupHash[group.uid]) {
          return this._bindGroupHash[group.uid];
        }
        this._renderer.uniformBuffer.ensureUniformGroup(group);
        const data = group.buffer.data;
        const offset = this._batchBuffer.addEmptyGroup(data.length);
        this._renderer.uniformBuffer.syncUniformGroup(group, this._batchBuffer.data, offset / 4);
        this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);
        return this._bindGroupHash[group.uid];
      }
      getUniformBufferResource(group) {
        this._renderer.uniformBuffer.updateUniformGroup(group);
        const data = group.buffer.data;
        const offset = this._batchBuffer.addGroup(data);
        return this._getBufferResource(offset / minUniformOffsetAlignment);
      }
      getArrayBindGroup(data) {
        const offset = this._batchBuffer.addGroup(data);
        return this._getBindGroup(offset / minUniformOffsetAlignment);
      }
      getArrayBufferResource(data) {
        const offset = this._batchBuffer.addGroup(data);
        const index = offset / minUniformOffsetAlignment;
        return this._getBufferResource(index);
      }
      _getBufferResource(index) {
        if (!this._bufferResources[index]) {
          const buffer2 = this._buffers[index % 2];
          this._bufferResources[index] = new BufferResource({
            buffer: buffer2,
            offset: (index / 2 | 0) * 256,
            size: minUniformOffsetAlignment
          });
        }
        return this._bufferResources[index];
      }
      _getBindGroup(index) {
        if (!this._bindGroups[index]) {
          const bindGroup = new BindGroup({
            0: this._getBufferResource(index)
          });
          this._bindGroups[index] = bindGroup;
        }
        return this._bindGroups[index];
      }
      _uploadBindGroups() {
        const bufferSystem = this._renderer.buffer;
        const firstBuffer = this._buffers[0];
        firstBuffer.update(this._batchBuffer.byteIndex);
        bufferSystem.updateBuffer(firstBuffer);
        const commandEncoder = this._renderer.gpu.device.createCommandEncoder();
        for (let i3 = 1; i3 < this._buffers.length; i3++) {
          const buffer2 = this._buffers[i3];
          commandEncoder.copyBufferToBuffer(
            bufferSystem.getGPUBuffer(firstBuffer),
            minUniformOffsetAlignment,
            bufferSystem.getGPUBuffer(buffer2),
            0,
            this._batchBuffer.byteIndex
          );
        }
        this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);
      }
      destroy() {
        for (let i3 = 0; i3 < this._bindGroups.length; i3++) {
          this._bindGroups[i3].destroy();
        }
        this._bindGroups = null;
        this._bindGroupHash = null;
        for (let i3 = 0; i3 < this._buffers.length; i3++) {
          this._buffers[i3].destroy();
        }
        this._buffers = null;
        for (let i3 = 0; i3 < this._bufferResources.length; i3++) {
          this._bufferResources[i3].destroy();
        }
        this._bufferResources = null;
        this._batchBuffer.destroy();
        this._bindGroupHash = null;
        this._renderer = null;
      }
    };
    GpuUniformBatchPipe.extension = {
      type: [
        ExtensionType.WebGPUPipes
      ],
      name: "uniformBatch"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBufferPipe.mjs
var UniformBindGroup, GpuUniformBufferPipe;
var init_GpuUniformBufferPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBufferPipe.mjs"() {
    init_Extensions();
    init_PoolGroup();
    init_Buffer();
    init_const5();
    init_BindGroup();
    UniformBindGroup = class extends BindGroup {
      constructor() {
        super({
          0: new Buffer2({
            data: new Float32Array(128),
            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
          })
        });
      }
      get buffer() {
        return this.resources[0];
      }
      get data() {
        return this.resources[0].data;
      }
    };
    GpuUniformBufferPipe = class {
      constructor(renderer) {
        this._activeBindGroups = [];
        this._activeBindGroupIndex = 0;
        this._renderer = renderer;
      }
      getUniformBindGroup(uniformGroup) {
        const renderer = this._renderer;
        renderer.uniformBuffer.ensureUniformGroup(uniformGroup);
        const bindGroup = BigPool.get(UniformBindGroup);
        renderer.uniformBuffer.syncUniformGroup(uniformGroup, bindGroup.data, 0);
        bindGroup.buffer.update(uniformGroup.buffer.data.byteLength);
        this._activeBindGroups[this._activeBindGroupIndex++] = bindGroup;
        return bindGroup;
      }
      renderEnd() {
        for (let i3 = 0; i3 < this._activeBindGroupIndex; i3++) {
          BigPool.return(this._activeBindGroups[i3]);
        }
        this._activeBindGroupIndex = 0;
      }
    };
    GpuUniformBufferPipe.extension = {
      type: [
        ExtensionType.WebGPUPipes
      ],
      name: "uniformBuffer"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs
var GpuStencilModesToPixi;
var init_GpuStencilModesToPixi = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs"() {
    init_const8();
    GpuStencilModesToPixi = [];
    GpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;
    GpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {
      format: "stencil8",
      depthCompare: "always",
      depthWriteEnabled: false,
      stencilWriteMask: 0,
      stencilReadMask: 0,
      stencilBack: {
        compare: "always",
        passOp: "keep"
      }
    };
    GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {
      format: "stencil8",
      depthCompare: "always",
      depthWriteEnabled: false,
      stencilBack: {
        compare: "always",
        passOp: "increment-clamp"
      }
    };
    GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {
      format: "stencil8",
      depthCompare: "always",
      depthWriteEnabled: false,
      stencilBack: {
        compare: "always",
        passOp: "increment-clamp"
      }
    };
    GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {
      format: "stencil8",
      depthCompare: "always",
      depthWriteEnabled: false,
      stencilBack: {
        compare: "always",
        passOp: "decrement-clamp"
      }
    };
    GpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {
      format: "stencil8",
      depthCompare: "always",
      depthWriteEnabled: false,
      stencilWriteMask: 0,
      stencilBack: {
        compare: "equal",
        passOp: "keep"
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs
function getKey(geometryId, programId, stateId, blendModeId, stencilStateId, multiSampleCount, colorMask, topology) {
  return geometryId << 26 | programId << 18 | colorMask << 14 | stateId << 8 | blendModeId << 3 | topology << 1 | stencilStateId << 4 | multiSampleCount;
}
var topologyStringToId, PipelineSystem;
var init_PipelineSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs"() {
    init_Extensions();
    init_const8();
    init_createIdFromString();
    init_GpuStencilModesToPixi();
    topologyStringToId = {
      "point-list": 0,
      "line-list": 1,
      "line-strip": 2,
      "triangle-list": 3,
      "triangle-strip": 4
    };
    PipelineSystem = class {
      constructor(renderer) {
        this._moduleCache = /* @__PURE__ */ Object.create(null);
        this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);
        this._pipeCache = /* @__PURE__ */ Object.create(null);
        this._colorMask = 15;
        this._multisampleCount = 1;
        this._renderer = renderer;
      }
      contextChange(gpu) {
        this._gpu = gpu;
        this.setStencilMode(STENCIL_MODES.DISABLED);
      }
      setMultisampleCount(multisampleCount) {
        this._multisampleCount = multisampleCount;
      }
      setColorMask(colorMask) {
        this._colorMask = colorMask;
      }
      setStencilMode(stencilMode) {
        this._stencilMode = stencilMode;
        this._stencilState = GpuStencilModesToPixi[stencilMode];
      }
      setPipeline(geometry, program, state, passEncoder) {
        const pipeline = this.getPipeline(geometry, program, state);
        passEncoder.setPipeline(pipeline);
      }
      getPipeline(geometry, program, state, topology) {
        if (!geometry._layoutKey) {
          this._generateBufferKey(geometry);
        }
        if (!program._layoutKey) {
          this._generateProgramKey(program);
          this._renderer.shader.createProgramLayout(program);
        }
        topology = topology || geometry.topology;
        const key2 = getKey(
          geometry._layoutKey,
          program._layoutKey,
          state.data,
          state._blendModeId,
          this._stencilMode,
          this._multisampleCount,
          this._colorMask,
          topologyStringToId[topology]
        );
        if (this._pipeCache[key2])
          return this._pipeCache[key2];
        this._pipeCache[key2] = this._createPipeline(geometry, program, state, topology);
        return this._pipeCache[key2];
      }
      _createPipeline(geometry, program, state, topology) {
        const device = this._gpu.device;
        const buffers = this._createVertexBufferLayouts(geometry);
        const blendModes = this._renderer.state.getColorTargets(state);
        let depthStencil = this._stencilState;
        depthStencil = GpuStencilModesToPixi[this._stencilMode];
        blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;
        const descriptor = {
          // TODO later check if its helpful to create..
          // layout,
          vertex: {
            module: this._getModule(program.vertex.source),
            entryPoint: program.vertex.entryPoint,
            // geometry..
            buffers
          },
          fragment: {
            module: this._getModule(program.fragment.source),
            entryPoint: program.fragment.entryPoint,
            targets: blendModes
          },
          primitive: {
            topology,
            cullMode: state.cullMode
          },
          layout: program._gpuLayout.pipeline,
          multisample: {
            count: this._multisampleCount
          },
          depthStencil,
          label: `PIXI Pipeline`
        };
        const pipeline = device.createRenderPipeline(descriptor);
        return pipeline;
      }
      _getModule(code) {
        return this._moduleCache[code] || this._createModule(code);
      }
      _createModule(code) {
        const device = this._gpu.device;
        this._moduleCache[code] = device.createShaderModule({
          code
        });
        return this._moduleCache[code];
      }
      _generateProgramKey(program) {
        const { vertex: vertex3, fragment: fragment3 } = program;
        const bigKey = vertex3.source + fragment3.source + vertex3.entryPoint + fragment3.entryPoint;
        program._layoutKey = createIdFromString(bigKey, "program");
        return program._layoutKey;
      }
      _generateBufferKey(geometry) {
        const keyGen = [];
        let index = 0;
        const attributeKeys = Object.keys(geometry.attributes).sort();
        for (let i3 = 0; i3 < attributeKeys.length; i3++) {
          const attribute = geometry.attributes[attributeKeys[i3]];
          keyGen[index++] = attribute.shaderLocation;
          keyGen[index++] = attribute.offset;
          keyGen[index++] = attribute.format;
          keyGen[index++] = attribute.stride;
        }
        const stringKey = keyGen.join("");
        geometry._layoutKey = createIdFromString(stringKey, "geometry");
        return geometry._layoutKey;
      }
      _createVertexBufferLayouts(geometry) {
        if (this._bufferLayoutsCache[geometry._layoutKey]) {
          return this._bufferLayoutsCache[geometry._layoutKey];
        }
        const vertexBuffersLayout = [];
        geometry.buffers.forEach((buffer2) => {
          const bufferEntry = {
            arrayStride: 0,
            stepMode: "vertex",
            attributes: []
          };
          const bufferEntryAttributes = bufferEntry.attributes;
          for (const i3 in geometry.attributes) {
            const attribute = geometry.attributes[i3];
            if (attribute.buffer === buffer2) {
              bufferEntry.arrayStride = attribute.stride;
              bufferEntryAttributes.push({
                shaderLocation: attribute.shaderLocation,
                offset: attribute.offset,
                format: attribute.format
              });
            }
          }
          if (bufferEntryAttributes.length) {
            vertexBuffersLayout.push(bufferEntry);
          }
        });
        this._bufferLayoutsCache[geometry._layoutKey] = vertexBuffersLayout;
        return vertexBuffersLayout;
      }
      destroy() {
        const writeable = this;
        writeable._renderer = null;
        this._bufferLayoutsCache = null;
      }
    };
    PipelineSystem.extension = {
      type: [ExtensionType.WebGPUSystem],
      name: "pipeline"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs
function isRenderingToScreen(renderTarget) {
  const resource = renderTarget.colorTexture.source.resource;
  return resource instanceof HTMLCanvasElement && document.body.contains(resource);
}
var init_isRenderingToScreen = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs
function calculateProjection(pm, x3, y2, width, height, flipY) {
  const sign2 = flipY ? 1 : -1;
  pm.identity();
  pm.a = 1 / width * 2;
  pm.d = sign2 * (1 / height * 2);
  pm.tx = -1 - x3 * pm.a;
  pm.ty = -sign2 - y2 * pm.d;
  return pm;
}
var init_calculateProjection = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs
var _RenderTarget, RenderTarget;
var init_RenderTarget = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs"() {
    init_Matrix();
    init_Rectangle();
    init_uid();
    init_calculateProjection();
    init_TextureSource();
    init_Texture();
    _RenderTarget = class {
      constructor(descriptor = {}) {
        this.uid = uid("renderTarget");
        this.width = 0;
        this.height = 0;
        this.resolution = 1;
        this.colorTextures = [];
        this.dirtyId = 0;
        this.isRoot = false;
        this._projectionMatrix = new Matrix();
        this._size = new Float32Array(2);
        descriptor = { ..._RenderTarget.defaultDescriptor, ...descriptor };
        this.width = descriptor.width;
        this.height = descriptor.height;
        this.resolution = descriptor.resolution;
        this.stencil = descriptor.stencil;
        this._viewport = new Rectangle(0, 0, this.width, this.height);
        if (typeof descriptor.colorTextures === "number") {
          for (let i3 = 0; i3 < descriptor.colorTextures; i3++) {
            this.colorTextures.push(new Texture({
              source: new TextureSource({
                width: this.width,
                height: this.height,
                resolution: descriptor.resolution,
                antialias: descriptor.antialias
              })
            }));
          }
        } else {
          this.colorTextures = [...descriptor.colorTextures];
          const colorSource = this.colorTexture.source;
          this._resize(colorSource.width, colorSource.height, colorSource._resolution);
        }
        this.colorTexture.source.on("resize", this.onSourceResize, this);
        if (descriptor.depthTexture) {
          this.depthTexture = new Texture({
            source: new TextureSource({
              width: this.width,
              height: this.height,
              resolution: this.resolution,
              format: "stencil8"
              // sampleCount: handled by the render target system..
            })
          });
        }
      }
      get size() {
        const _size = this._size;
        _size[0] = this.pixelWidth;
        _size[1] = this.pixelHeight;
        return _size;
      }
      get pixelWidth() {
        return this.width * this.resolution;
      }
      get pixelHeight() {
        return this.height * this.resolution;
      }
      get colorTexture() {
        return this.colorTextures[0];
      }
      get projectionMatrix() {
        const texture = this.colorTexture;
        calculateProjection(this._projectionMatrix, 0, 0, texture.frameWidth, texture.frameHeight, !this.isRoot);
        return this._projectionMatrix;
      }
      get viewport() {
        const texture = this.colorTexture;
        const source3 = texture.source;
        const pixelWidth = source3.pixelWidth;
        const pixelHeight = source3.pixelHeight;
        const viewport = this._viewport;
        const frame = texture.layout.frame;
        viewport.x = frame.x * pixelWidth | 0;
        viewport.y = frame.y * pixelHeight | 0;
        viewport.width = frame.width * pixelWidth | 0;
        viewport.height = frame.height * pixelHeight | 0;
        return viewport;
      }
      onSourceResize(source3) {
        this._resize(source3.width, source3.height, source3._resolution, true);
      }
      _resize(width, height, resolution = this.resolution, skipColorTexture = false) {
        this.width = width;
        this.height = height;
        this.resolution = resolution;
        this.dirtyId++;
        this.colorTextures.forEach((colorTexture, i3) => {
          if (skipColorTexture && i3 === 0)
            return;
          colorTexture.source.resize(width, height, resolution);
        });
        if (this.depthTexture) {
          this.depthTexture.source.resize(width, height, resolution);
        }
      }
      destroy() {
        throw new Error("Method not implemented.");
      }
    };
    RenderTarget = _RenderTarget;
    RenderTarget.defaultDescriptor = {
      width: 0,
      height: 0,
      resolution: 1,
      colorTextures: 1,
      stencil: true,
      antialias: false
      // save on perf by default!
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs
var GpuRenderTarget;
var init_GpuRenderTarget = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs"() {
    GpuRenderTarget = class {
      constructor() {
        this.contexts = [];
        this.msaaTextures = [];
        this.msaaSamples = 1;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs
var GpuRenderTargetSystem;
var init_GpuRenderTargetSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs"() {
    init_Extensions();
    init_Matrix();
    init_const7();
    init_isRenderingToScreen();
    init_RenderTarget();
    init_SystemRunner();
    init_TextureSource();
    init_Texture();
    init_getCanvasTexture();
    init_GpuRenderTarget();
    GpuRenderTargetSystem = class {
      constructor(renderer) {
        this.rootProjectionMatrix = new Matrix();
        this.onRenderTargetChange = new SystemRunner("onRenderTargetChange");
        this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();
        this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
        this._renderTargetStack = [];
        this._defaultClearColor = [0, 0, 0, 0];
        this._renderer = renderer;
      }
      renderStart({
        target,
        clear,
        clearColor
      }) {
        this.rootRenderTarget = this.getRenderTarget(target);
        this.rootProjectionMatrix = this.rootRenderTarget.projectionMatrix;
        this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);
        this._renderTargetStack.length = 0;
        this._renderer.encoder.start();
        this.push(
          this.rootRenderTarget,
          clear,
          clearColor ?? this._renderer.background.colorRgba
        );
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
      bind(renderSurface, clear = true, clearColor) {
        const renderTarget = this.getRenderTarget(renderSurface);
        const didChange = this.renderTarget !== renderTarget;
        this.renderTarget = renderTarget;
        this._startRenderPass(clear, clearColor);
        if (didChange) {
          this.onRenderTargetChange.emit(renderTarget);
        }
        return renderTarget;
      }
      /**
       * returns the gpu texture for the first color texture in the render target
       * mainly used by the filter manager to get copy the texture for blending
       * @param renderTarget
       * @returns a gpu texture
       */
      _getGpuColorTexture(renderTarget) {
        const gpuRenderTarget = this._getGpuRenderTarget(renderTarget);
        if (gpuRenderTarget.contexts[0]) {
          return gpuRenderTarget.contexts[0].getCurrentTexture();
        }
        return this._renderer.texture.getGpuSource(
          renderTarget.colorTextures[0].source
        );
      }
      getDescriptor(renderTarget, clear, clearValue) {
        if (typeof clear === "boolean") {
          clear = clear ? CLEAR.ALL : CLEAR.NONE;
        }
        const gpuRenderTarget = this._getGpuRenderTarget(renderTarget);
        const colorAttachments = renderTarget.colorTextures.map(
          (texture, i3) => {
            const context4 = gpuRenderTarget.contexts[i3];
            let view;
            let resolveTarget;
            if (context4) {
              const currentTexture = context4.getCurrentTexture();
              const canvasTextureView = currentTexture.createView();
              view = canvasTextureView;
            } else {
              view = this._renderer.texture.getTextureView(texture);
            }
            if (gpuRenderTarget.msaaTextures[i3]) {
              resolveTarget = view;
              view = this._renderer.texture.getTextureView(
                gpuRenderTarget.msaaTextures[i3]
              );
            }
            const loadOp = clear & CLEAR.COLOR ? "clear" : "load";
            clearValue ?? (clearValue = this._defaultClearColor);
            return {
              view,
              // assign each frame based on the swap chain!
              resolveTarget,
              clearValue,
              storeOp: "store",
              loadOp
            };
          }
        );
        let depthStencilAttachment;
        if (renderTarget.depthTexture) {
          const stencilLoadOp = clear & CLEAR.STENCIL ? "clear" : "load";
          depthStencilAttachment = {
            view: this._renderer.texture.getGpuSource(renderTarget.depthTexture.source).createView(),
            stencilStoreOp: "store",
            stencilLoadOp
          };
        }
        const descriptor = {
          colorAttachments,
          depthStencilAttachment
        };
        return descriptor;
      }
      clear(clear = CLEAR.ALL, clearColor) {
        if (!clear)
          return;
        this._startRenderPass(
          clear,
          clearColor
        );
      }
      push(renderSurface, clear = CLEAR.ALL, clearColor) {
        const renderTarget = this.bind(renderSurface, clear, clearColor);
        this._renderTargetStack.push(renderTarget);
        return renderTarget;
      }
      pop() {
        this._renderTargetStack.pop();
        this.bind(
          this._renderTargetStack[this._renderTargetStack.length - 1],
          false
        );
      }
      getRenderTarget(renderSurface) {
        return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);
      }
      copyToTexture(sourceRenderSurfaceTexture, destinationTexture, origin, size3) {
        const renderer = this._renderer;
        const baseGpuTexture = renderer.renderTarget._getGpuColorTexture(
          sourceRenderSurfaceTexture
        );
        const backGpuTexture = renderer.texture.getGpuSource(
          destinationTexture.source
        );
        renderer.encoder.commandEncoder.copyTextureToTexture(
          {
            texture: baseGpuTexture,
            origin
          },
          {
            texture: backGpuTexture
          },
          size3
        );
        return destinationTexture;
      }
      restart() {
        this.bind(this.rootRenderTarget, CLEAR.NONE);
      }
      destroy() {
        const writeable = this;
        writeable._renderer = null;
        this._renderSurfaceToRenderTargetHash.clear();
      }
      _startRenderPass(clear = true, clearColor) {
        const renderTarget = this.renderTarget;
        const gpuRenderTarget = this._getGpuRenderTarget(renderTarget);
        if (renderTarget.width !== gpuRenderTarget.width || renderTarget.height !== gpuRenderTarget.height) {
          this._resizeGpuRenderTarget(renderTarget);
        }
        const descriptor = this.getDescriptor(renderTarget, clear, clearColor);
        gpuRenderTarget.descriptor = descriptor;
        this._renderer.encoder.beginRenderPass(renderTarget, gpuRenderTarget);
        this._renderer.pipeline.setMultisampleCount(gpuRenderTarget.msaaSamples);
      }
      _initRenderTarget(renderSurface) {
        let renderTarget = null;
        if (renderSurface instanceof HTMLCanvasElement) {
          renderSurface = getCanvasTexture(renderSurface);
        }
        if (renderSurface instanceof RenderTarget) {
          renderTarget = renderSurface;
        } else if (renderSurface instanceof Texture) {
          renderTarget = new RenderTarget({
            colorTextures: [renderSurface],
            depthTexture: renderSurface.source.depthStencil
          });
        }
        renderTarget.isRoot = true;
        this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);
        return renderTarget;
      }
      _getGpuRenderTarget(renderTarget) {
        return this._gpuRenderTargetHash[renderTarget.uid] || this._initGpuRenderTarget(renderTarget);
      }
      _initGpuRenderTarget(renderTarget) {
        renderTarget.isRoot = true;
        const gpuRenderTarget = new GpuRenderTarget();
        renderTarget.colorTextures.forEach((colorTexture, i3) => {
          if (colorTexture.source.resource instanceof HTMLCanvasElement) {
            const context4 = renderTarget.colorTexture.source.resource.getContext(
              "webgpu"
            );
            try {
              context4.configure({
                device: this._gpu.device,
                // eslint-disable-next-line max-len
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
                format: "bgra8unorm",
                alphaMode: "opaque"
              });
            } catch (e3) {
              console.error(e3);
            }
            gpuRenderTarget.contexts[i3] = context4;
          }
          gpuRenderTarget.msaa = colorTexture.source.antialias;
          if (colorTexture.source.antialias) {
            const msaaTexture = new TextureSource({
              width: 0,
              height: 0,
              sampleCount: 4
            });
            gpuRenderTarget.msaaTextures[i3] = msaaTexture;
          }
        });
        if (gpuRenderTarget.msaa) {
          gpuRenderTarget.msaaSamples = 4;
          if (renderTarget.depthTexture) {
            renderTarget.depthTexture.source.sampleCount = 4;
          }
        }
        this._gpuRenderTargetHash[renderTarget.uid] = gpuRenderTarget;
        return gpuRenderTarget;
      }
      _resizeGpuRenderTarget(renderTarget) {
        const gpuRenderTarget = this._getGpuRenderTarget(renderTarget);
        gpuRenderTarget.width = renderTarget.width;
        gpuRenderTarget.height = renderTarget.height;
        if (gpuRenderTarget.msaa) {
          renderTarget.colorTextures.forEach((colorTexture, i3) => {
            const msaaTexture = gpuRenderTarget.msaaTextures[i3];
            msaaTexture?.resize(
              colorTexture.source.width,
              colorTexture.source.height,
              colorTexture.source._resolution
            );
          });
        }
      }
    };
    GpuRenderTargetSystem.extension = {
      type: [ExtensionType.WebGPUSystem],
      name: "renderTarget"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs
var GpuShaderSystem;
var init_GpuShaderSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs"() {
    init_Extensions();
    GpuShaderSystem = class {
      contextChange(gpu) {
        this._gpu = gpu;
      }
      createProgramLayout(program) {
        const device = this._gpu.device;
        if (!program._gpuLayout) {
          if (program.gpuLayout) {
            const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));
            const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };
            program._gpuLayout = {
              bindGroups,
              pipeline: device.createPipelineLayout(pipelineLayoutDesc)
            };
          } else {
            program._gpuLayout = {
              bindGroups: null,
              pipeline: "auto"
            };
          }
        }
      }
      destroy() {
        this._gpu = null;
      }
    };
    GpuShaderSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "shader"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs
var GpuBlendModesToPixi;
var init_GpuBlendModesToPixi = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs"() {
    GpuBlendModesToPixi = {};
    GpuBlendModesToPixi.normal = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.add = {
      alpha: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.multiply = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "dst",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.screen = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.overlay = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.none = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "zero",
        dstFactor: "zero",
        operation: "add"
      }
    };
    GpuBlendModesToPixi["normal-npm"] = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      }
    };
    GpuBlendModesToPixi["add-npm"] = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "add"
      },
      color: {
        srcFactor: "src-alpha",
        dstFactor: "one",
        operation: "add"
      }
    };
    GpuBlendModesToPixi["screen-npm"] = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.erase = {
      alpha: {
        srcFactor: "zero",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "zero",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs
var GpuStateSystem;
var init_GpuStateSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs"() {
    init_Extensions();
    init_State();
    init_GpuBlendModesToPixi();
    GpuStateSystem = class {
      constructor() {
        this.defaultState = new State();
        this.defaultState.blend = true;
      }
      contextChange(gpu) {
        this.gpu = gpu;
      }
      getColorTargets(state) {
        const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;
        return [
          {
            format: "bgra8unorm",
            writeMask: 0,
            blend
          }
        ];
      }
      destroy() {
        this.gpu = null;
      }
    };
    GpuStateSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "state"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs
var gpuUploadBufferImageResource;
var init_gpuUploadBufferImageResource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs"() {
    gpuUploadBufferImageResource = {
      type: "image",
      upload(source3, gpuTexture, gpu) {
        const resource = source3.resource;
        const total = (source3.pixelWidth | 0) * (source3.pixelHeight | 0);
        const bytesPerPixel = resource.byteLength / total;
        gpu.device.queue.writeTexture(
          { texture: gpuTexture },
          resource,
          {
            offset: 0,
            rowsPerImage: source3.pixelWidth,
            bytesPerRow: source3.pixelWidth * bytesPerPixel
          },
          {
            width: source3.pixelWidth,
            height: source3.pixelHeight,
            depthOrArrayLayers: 1
          }
        );
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs
var gpuUploadImageResource;
var init_gpuUploadImageSource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs"() {
    gpuUploadImageResource = {
      type: "image",
      upload(source3, gpuTexture, gpu) {
        const resource = source3.resource;
        if (!resource)
          return;
        const width = source3.resourceWidth || source3.pixelWidth;
        const height = source3.resourceHeight || source3.pixelHeight;
        const premultipliedAlpha = source3.alphaMode === "premultiply-alpha-on-upload";
        gpu.device.queue.copyExternalImageToTexture(
          { source: resource },
          { texture: gpuTexture, premultipliedAlpha },
          {
            width,
            height
          }
        );
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs
var gpuUploadVideoResource;
var init_gpuUploadVideoSource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs"() {
    init_gpuUploadImageSource();
    gpuUploadVideoResource = {
      type: "video",
      upload(source3, gpuTexture, gpu) {
        gpuUploadImageResource.upload(source3, gpuTexture, gpu);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs
var GpuMipmapGenerator;
var init_GpuMipmapGenerator = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs"() {
    GpuMipmapGenerator = class {
      constructor(device) {
        this.device = device;
        this.sampler = device.createSampler({ minFilter: "linear" });
        this.pipelines = {};
      }
      _getMipmapPipeline(format3) {
        let pipeline = this.pipelines[format3];
        if (!pipeline) {
          if (!this.mipmapShaderModule) {
            this.mipmapShaderModule = this.device.createShaderModule({
              code: (
                /* wgsl */
                `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
              )
            });
          }
          pipeline = this.device.createRenderPipeline({
            layout: "auto",
            vertex: {
              module: this.mipmapShaderModule,
              entryPoint: "vertexMain"
            },
            fragment: {
              module: this.mipmapShaderModule,
              entryPoint: "fragmentMain",
              targets: [{ format: format3 }]
            }
          });
          this.pipelines[format3] = pipeline;
        }
        return pipeline;
      }
      /**
       * Generates mipmaps for the given GPUTexture from the data in level 0.
       * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.
       * @returns {module:External.GPUTexture} - The originally passed texture
       */
      generateMipmap(texture) {
        const pipeline = this._getMipmapPipeline(texture.format);
        if (texture.dimension === "3d" || texture.dimension === "1d") {
          throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
        }
        let mipTexture = texture;
        const arrayLayerCount = texture.depthOrArrayLayers || 1;
        const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;
        if (!renderToSource) {
          const mipTextureDescriptor = {
            size: {
              width: Math.ceil(texture.width / 2),
              height: Math.ceil(texture.height / 2),
              depthOrArrayLayers: arrayLayerCount
            },
            format: texture.format,
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
            mipLevelCount: texture.mipLevelCount - 1
          };
          mipTexture = this.device.createTexture(mipTextureDescriptor);
        }
        const commandEncoder = this.device.createCommandEncoder({});
        const bindGroupLayout = pipeline.getBindGroupLayout(0);
        for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {
          let srcView = texture.createView({
            baseMipLevel: 0,
            mipLevelCount: 1,
            dimension: "2d",
            baseArrayLayer: arrayLayer,
            arrayLayerCount: 1
          });
          let dstMipLevel = renderToSource ? 1 : 0;
          for (let i3 = 1; i3 < texture.mipLevelCount; ++i3) {
            const dstView = mipTexture.createView({
              baseMipLevel: dstMipLevel++,
              mipLevelCount: 1,
              dimension: "2d",
              baseArrayLayer: arrayLayer,
              arrayLayerCount: 1
            });
            const passEncoder = commandEncoder.beginRenderPass({
              colorAttachments: [{
                view: dstView,
                storeOp: "store",
                loadOp: "clear",
                clearValue: { r: 0, g: 0, b: 0, a: 0 }
              }]
            });
            const bindGroup = this.device.createBindGroup({
              layout: bindGroupLayout,
              entries: [{
                binding: 0,
                resource: this.sampler
              }, {
                binding: 1,
                resource: srcView
              }]
            });
            passEncoder.setPipeline(pipeline);
            passEncoder.setBindGroup(0, bindGroup);
            passEncoder.draw(3, 1, 0, 0);
            passEncoder.end();
            srcView = dstView;
          }
        }
        if (!renderToSource) {
          const mipLevelSize = {
            width: Math.ceil(texture.width / 2),
            height: Math.ceil(texture.height / 2),
            depthOrArrayLayers: arrayLayerCount
          };
          for (let i3 = 1; i3 < texture.mipLevelCount; ++i3) {
            commandEncoder.copyTextureToTexture({
              texture: mipTexture,
              mipLevel: i3 - 1
            }, {
              texture,
              mipLevel: i3
            }, mipLevelSize);
            mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);
            mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);
          }
        }
        this.device.queue.submit([commandEncoder.finish()]);
        if (!renderToSource) {
          mipTexture.destroy();
        }
        return texture;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs
var GpuTextureSystem;
var init_GpuTextureSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs"() {
    init_Extensions();
    init_settings();
    init_CanvasPool();
    init_BindGroup();
    init_gpuUploadBufferImageResource();
    init_gpuUploadImageSource();
    init_gpuUploadVideoSource();
    init_GpuMipmapGenerator();
    GpuTextureSystem = class {
      constructor(renderer) {
        this.managedTextures = [];
        this._gpuSources = /* @__PURE__ */ Object.create(null);
        this._gpuSamplers = /* @__PURE__ */ Object.create(null);
        this._bindGroupHash = /* @__PURE__ */ Object.create(null);
        this._textureViewHash = /* @__PURE__ */ Object.create(null);
        this._uploads = {
          image: gpuUploadImageResource,
          buffer: gpuUploadBufferImageResource,
          video: gpuUploadVideoResource
        };
        this._renderer = renderer;
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
      initSource(source3) {
        if (source3.autoGenerateMipmaps) {
          const biggestDimension = Math.max(source3.pixelWidth, source3.pixelHeight);
          source3.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
        }
        const textureDescriptor = {
          size: { width: source3.pixelWidth || 1, height: source3.pixelHeight || 1 },
          format: source3.format,
          sampleCount: source3.sampleCount,
          mipLevelCount: source3.mipLevelCount,
          dimension: source3.dimension,
          usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
        };
        const gpuTexture = this._gpu.device.createTexture(textureDescriptor);
        this._gpuSources[source3.uid] = gpuTexture;
        source3.on("update", this.onSourceUpdate, this);
        source3.on("resize", this.onSourceResize, this);
        source3.on("destroy", this.onSourceDestroy, this);
        source3.on("unload", this.onSourceUnload, this);
        this.managedTextures.push(source3);
        this.onSourceUpdate(source3);
        return gpuTexture;
      }
      onSourceUpdate(source3) {
        const gpuTexture = this.getGpuSource(source3);
        if (!gpuTexture)
          return;
        if (this._uploads[source3.uploadMethodId]) {
          this._uploads[source3.uploadMethodId].upload(source3, gpuTexture, this._gpu);
        }
        if (source3.autoGenerateMipmaps && source3.mipLevelCount > 1) {
          if (!this._mipmapGenerator) {
            this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);
          }
          this._mipmapGenerator.generateMipmap(gpuTexture);
        }
      }
      onSourceUnload(source3) {
        const gpuTexture = this._gpuSources[source3.uid];
        if (gpuTexture) {
          this._gpuSources[source3.uid] = null;
          gpuTexture.destroy();
        }
      }
      onSourceDestroy(source3) {
        source3.off("update", this.onSourceUpdate, this);
        source3.off("unload", this.onSourceUnload, this);
        source3.off("destroy", this.onSourceDestroy, this);
        source3.off("resize", this.onSourceResize, this);
        this.managedTextures.splice(this.managedTextures.indexOf(source3), 1);
        this.onSourceUnload(source3);
      }
      onSourceResize(source3) {
        const gpuTexture = this._gpuSources[source3.uid];
        if (gpuTexture.width !== source3.pixelWidth || gpuTexture.height !== source3.pixelHeight) {
          this._textureViewHash[source3.uid] = null;
          this._bindGroupHash[source3.uid] = null;
          this.onSourceUnload(source3);
          this.initSource(source3);
        }
      }
      _initSampler(sampler) {
        this._gpuSamplers[sampler.resourceId] = this._gpu.device.createSampler(sampler);
        return this._gpuSamplers[sampler.resourceId];
      }
      getGpuSampler(sampler) {
        return this._gpuSamplers[sampler.resourceId] || this._initSampler(sampler);
      }
      getGpuSource(source3) {
        return this._gpuSources[source3.uid] || this.initSource(source3);
      }
      getTextureBindGroup(texture) {
        return this._bindGroupHash[texture.id] ?? this._createTextureBindGroup(texture);
      }
      _createTextureBindGroup(texture) {
        const source3 = texture.source;
        const bindGroupId = source3.uid;
        this._bindGroupHash[bindGroupId] = new BindGroup({
          0: source3,
          1: source3.style
        });
        return this._bindGroupHash[bindGroupId];
      }
      getTextureView(texture) {
        const source3 = texture.source;
        return this._textureViewHash[source3.uid] ?? this._createTextureView(source3);
      }
      _createTextureView(texture) {
        this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();
        return this._textureViewHash[texture.uid];
      }
      generateCanvas(texture) {
        const renderer = this._renderer;
        const commandEncoder = renderer.gpu.device.createCommandEncoder();
        const canvas3 = settings.ADAPTER.createCanvas();
        canvas3.width = texture.source.pixelWidth;
        canvas3.height = texture.source.pixelHeight;
        const context4 = canvas3.getContext("webgpu");
        context4.configure({
          device: renderer.gpu.device,
          // eslint-disable-next-line max-len
          usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
          format: "bgra8unorm",
          alphaMode: "premultiplied"
        });
        commandEncoder.copyTextureToTexture({
          texture: renderer.texture.getGpuSource(texture.source),
          origin: {
            x: 0,
            y: 0
          }
        }, {
          texture: context4.getCurrentTexture()
        }, {
          width: canvas3.width,
          height: canvas3.height
        });
        renderer.gpu.device.queue.submit([commandEncoder.finish()]);
        return canvas3;
      }
      getPixels(texture) {
        const webGPUCanvas = this.generateCanvas(texture);
        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);
        const context4 = canvasAndContext.context;
        context4.drawImage(webGPUCanvas, 0, 0);
        const { width, height } = webGPUCanvas;
        const imageData = context4.getImageData(0, 0, width, height);
        const pixels = new Uint8ClampedArray(imageData.data.buffer);
        CanvasPool.returnCanvasAndContext(canvasAndContext);
        return { pixels, width, height };
      }
      destroy() {
        for (const k3 of Object.keys(this._gpuSources)) {
          const key2 = Number(k3);
          const gpuTexture = this._gpuSources[key2];
          gpuTexture.destroy();
          this._gpuSources[key2] = null;
        }
        for (const k3 of Object.keys(this._bindGroupHash)) {
          const key2 = Number(k3);
          const bindGroup = this._bindGroupHash[key2];
          bindGroup.destroy();
          this._bindGroupHash[key2] = null;
        }
        this._gpu = null;
        this._mipmapGenerator = null;
        this._gpuSources = null;
        this._bindGroupHash = null;
        this._textureViewHash = null;
        this._gpuSamplers = null;
      }
    };
    GpuTextureSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "texture"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs
var WebGPURenderer_exports = {};
__export(WebGPURenderer_exports, {
  WebGPURenderer: () => WebGPURenderer
});
var DefaultWebGPUSystems, DefaultWebGPUPipes, DefaultWebGPUAdapters, systems, renderPipes, renderPipeAdaptors, WebGPURenderer;
var init_WebGPURenderer = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs"() {
    init_Extensions();
    init_GpuGraphicsAdaptor();
    init_GpuMeshAdapter();
    init_GpuBatchAdaptor();
    init_AbstractRenderer();
    init_SharedSystems();
    init_types();
    init_BindGroupSystem();
    init_GpuBufferSystem();
    init_GpuColorMaskSystem();
    init_GpuDeviceSystem();
    init_GpuEncoderSystem();
    init_GpuStencilSystem();
    init_GpuUniformBatchPipe();
    init_GpuUniformBufferPipe();
    init_PipelineSystem();
    init_GpuRenderTargetSystem();
    init_GpuShaderSystem();
    init_GpuStateSystem();
    init_GpuTextureSystem();
    DefaultWebGPUSystems = [
      ...SharedSystems,
      GpuDeviceSystem,
      BufferSystem,
      GpuTextureSystem,
      GpuRenderTargetSystem,
      GpuEncoderSystem,
      GpuShaderSystem,
      GpuStateSystem,
      PipelineSystem,
      GpuColorMaskSystem,
      GpuStencilSystem,
      BindGroupSystem
    ];
    DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe, GpuUniformBufferPipe];
    DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];
    systems = [];
    renderPipes = [];
    renderPipeAdaptors = [];
    extensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);
    extensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);
    extensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);
    extensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);
    WebGPURenderer = class extends AbstractRenderer {
      constructor() {
        const systemConfig = {
          name: "webgpu",
          type: RendererType.WEBGPU,
          systems,
          renderPipes,
          renderPipeAdaptors
        };
        super(systemConfig);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs
var GlGraphicsAdaptor;
var init_GlGraphicsAdaptor = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs"() {
    init_Extensions();
    init_Matrix();
    init_const3();
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_localUniformBit();
    init_roundPixelsBit();
    init_batchSamplersUniformGroup();
    init_Shader();
    init_UniformGroup();
    GlGraphicsAdaptor = class {
      init() {
        const uniforms = new UniformGroup({
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" }
        });
        const glProgram = compileHighShaderGlProgram({
          name: "graphics",
          bits: [
            colorBitGl,
            generateTextureBatchBitGl(MAX_TEXTURES),
            localUniformBitGl,
            roundPixelsBitGl
          ]
        });
        this.shader = new Shader({
          glProgram,
          resources: {
            localUniforms: uniforms,
            batchSamplers: batchSamplersUniformGroup
          }
        });
      }
      execute(graphicsPipe, renderable) {
        const context4 = renderable.view.context;
        const shader = context4.customShader || this.shader;
        const renderer = graphicsPipe.renderer;
        const contextSystem = renderer.graphicsContext;
        const {
          geometry,
          instructions
        } = contextSystem.getContextRenderData(context4);
        renderer.shader.bind(shader);
        renderer.shader.bindUniformBlock(renderer.globalUniforms.uniformGroup, "globalUniforms");
        renderer.geometry.bind(geometry, shader.glProgram);
        const batches = instructions.instructions;
        for (let i3 = 0; i3 < instructions.instructionSize; i3++) {
          const batch = batches[i3];
          if (batch.size) {
            for (let j3 = 0; j3 < batch.textures.textures.length; j3++) {
              renderer.texture.bind(batch.textures.textures[j3], j3);
            }
            renderer.geometry.draw("triangle-list", batch.size, batch.start);
          }
        }
      }
      destroy() {
        this.shader.destroy(true);
        this.shader = null;
      }
    };
    GlGraphicsAdaptor.extension = {
      type: [
        ExtensionType.WebGLPipesAdaptor
      ],
      name: "graphics"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs
var GlMeshAdaptor;
var init_GlMeshAdaptor = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs"() {
    init_Extensions();
    init_compileHighShaderToProgram();
    init_localUniformBit();
    init_roundPixelsBit();
    init_textureBit();
    init_Shader();
    init_Texture();
    GlMeshAdaptor = class {
      init() {
        const glProgram = compileHighShaderGlProgram({
          name: "mesh",
          bits: [
            localUniformBitGl,
            textureBitGl,
            roundPixelsBitGl
          ]
        });
        this._shader = new Shader({
          glProgram,
          resources: {
            uTexture: Texture.EMPTY.source
          }
        });
        this._shader.addResource("globalUniforms", 0, 0);
        this._shader.addResource("localUniforms", 1, 0);
      }
      execute(meshPipe, renderable) {
        const renderer = meshPipe.renderer;
        const view = renderable.view;
        let shader = view._shader;
        if (!shader) {
          shader = this._shader;
          const source3 = view.texture.source;
          shader.resources.uTexture = source3;
          shader.resources.uSampler = source3.style;
        }
        shader.groups[0] = renderer.globalUniforms.bindGroup;
        shader.groups[1] = meshPipe.localUniformsBindGroup;
        renderer.encoder.draw({
          geometry: view._geometry,
          shader,
          state: view.state
        });
      }
      destroy() {
        this._shader.destroy(true);
        this._shader = null;
      }
    };
    GlMeshAdaptor.extension = {
      type: [
        ExtensionType.WebGLPipesAdaptor
      ],
      name: "mesh"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs
var GlBatchAdaptor;
var init_GlBatchAdaptor = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs"() {
    init_Extensions();
    init_Matrix();
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_roundPixelsBit();
    init_batchSamplersUniformGroup();
    init_Shader();
    init_UniformGroup();
    init_State();
    init_const3();
    GlBatchAdaptor = class {
      constructor() {
        this._didUpload = false;
        this._tempState = State.for2d();
      }
      init() {
        const uniforms = new UniformGroup({
          tint: { value: new Float32Array([1, 1, 1, 1]), type: "f32" },
          translationMatrix: { value: new Matrix(), type: "mat3x3<f32>" }
        });
        const glProgram = compileHighShaderGlProgram({
          name: "batch",
          bits: [
            colorBitGl,
            generateTextureBatchBitGl(MAX_TEXTURES),
            roundPixelsBitGl
          ]
        });
        this._shader = new Shader({
          glProgram,
          resources: {
            uniforms,
            batchSamplers: batchSamplersUniformGroup
          }
        });
      }
      start(batchPipe, geometry) {
        const renderer = batchPipe.renderer;
        renderer.shader.bind(this._shader, this._didUpload);
        renderer.shader.bindUniformBlock(renderer.globalUniforms.uniformGroup, "globalUniforms", 0);
        renderer.geometry.bind(geometry, this._shader.glProgram);
      }
      execute(batchPipe, batch) {
        const renderer = batchPipe.renderer;
        this._didUpload = true;
        this._tempState.blendMode = batch.blendMode;
        renderer.state.set(this._tempState);
        const textures = batch.textures.textures;
        for (let i3 = 0; i3 < textures.length; i3++) {
          renderer.texture.bind(textures[i3], i3);
        }
        renderer.geometry.draw("triangle-list", batch.size, batch.start);
      }
      destroy() {
        this._shader.destroy(true);
        this._shader = null;
      }
    };
    GlBatchAdaptor.extension = {
      type: [
        ExtensionType.WebGLPipesAdaptor
      ],
      name: "batch"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs
var BUFFER_TYPE;
var init_const9 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs"() {
    BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE22) => {
      BUFFER_TYPE22[BUFFER_TYPE22["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
      BUFFER_TYPE22[BUFFER_TYPE22["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
      BUFFER_TYPE22[BUFFER_TYPE22["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
      return BUFFER_TYPE22;
    })(BUFFER_TYPE || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs
var GlBuffer;
var init_GlBuffer = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs"() {
    GlBuffer = class {
      constructor(buffer2, type2) {
        this.buffer = buffer2 || null;
        this.updateID = -1;
        this.byteLength = -1;
        this.type = type2;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs
var GlBufferSystem;
var init_GlBufferSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs"() {
    init_Extensions();
    init_const5();
    init_const9();
    init_GlBuffer();
    GlBufferSystem = class {
      /**
       * @param {Renderer} renderer - The renderer this System works for.
       */
      constructor(renderer) {
        this._gpuBuffers = /* @__PURE__ */ Object.create(null);
        this._boundBufferBases = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      /**
       * @ignore
       */
      destroy() {
        const writeable = this;
        this.destroyAll(true);
        this._renderer = null;
        this._gl = null;
        this._gpuBuffers = null;
        writeable._boundBufferBases = null;
      }
      /** Sets up the renderer context and necessary buffers. */
      contextChange() {
        this.destroyAll(true);
        this._gl = this._renderer.gl;
      }
      getGlBuffer(buffer2) {
        return this._gpuBuffers[buffer2.uid] || this.createGLBuffer(buffer2);
      }
      /**
       * This binds specified buffer. On first run, it will create the webGL buffers for the context too
       * @param buffer - the buffer to bind to the renderer
       */
      bind(buffer2) {
        const { _gl: gl } = this;
        const glBuffer = this.getGlBuffer(buffer2);
        gl.bindBuffer(glBuffer.type, glBuffer.buffer);
      }
      /**
       * Binds an uniform buffer to at the given index.
       *
       * A cache is used so a buffer will not be bound again if already bound.
       * @param buffer - the buffer to bind
       * @param index - the base index to bind it to.
       */
      bindBufferBase(buffer2, index) {
        const { _gl: gl } = this;
        if (this._boundBufferBases[index] !== buffer2) {
          const glBuffer = this.getGlBuffer(buffer2);
          this._boundBufferBases[index] = buffer2;
          gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
        }
      }
      /**
       * Binds a buffer whilst also binding its range.
       * This will make the buffer start from the offset supplied rather than 0 when it is read.
       * @param buffer - the buffer to bind
       * @param index - the base index to bind at, defaults to 0
       * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc
       */
      bindBufferRange(buffer2, index, offset) {
        const { _gl: gl } = this;
        offset = offset || 0;
        const glBuffer = this.getGlBuffer(buffer2);
        gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);
      }
      /**
       * Will ensure the data in the buffer is uploaded to the GPU.
       * @param {Buffer} buffer - the buffer to update
       */
      updateBuffer(buffer2) {
        const { _gl: gl } = this;
        const glBuffer = this.getGlBuffer(buffer2);
        if (buffer2._updateID === glBuffer.updateID) {
          return glBuffer;
        }
        glBuffer.updateID = buffer2._updateID;
        gl.bindBuffer(glBuffer.type, glBuffer.buffer);
        if (glBuffer.byteLength >= buffer2.data.byteLength) {
          gl.bufferSubData(glBuffer.type, 0, buffer2.data, 0, buffer2._updateSize / 4);
        } else {
          const drawType = buffer2.descriptor.usage & BufferUsage.STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
          glBuffer.byteLength = buffer2.data.byteLength;
          gl.bufferData(glBuffer.type, buffer2.data, drawType);
        }
        return glBuffer;
      }
      /**
       * dispose all WebGL resources of all managed buffers
       * @param {boolean} [contextLost=false] - If context was lost, we suppress `gl.delete` calls
       */
      destroyAll(contextLost) {
        const gl = this._gl;
        if (!contextLost) {
          for (const id in this._gpuBuffers) {
            gl.deleteBuffer(this._gpuBuffers[id].buffer);
          }
        }
        this._gpuBuffers = {};
      }
      /**
       * Disposes buffer
       * @param {Buffer} buffer - buffer with data
       * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray
       */
      onBufferDestroy(buffer2, contextLost) {
        const glBuffer = this._gpuBuffers[buffer2.uid];
        const gl = this._gl;
        if (!contextLost) {
          gl.deleteBuffer(glBuffer.buffer);
        }
        this._gpuBuffers[buffer2.uid] = null;
      }
      /**
       * creates and attaches a GLBuffer object tied to the current context.
       * @param buffer
       * @protected
       */
      createGLBuffer(buffer2) {
        const { _gl: gl } = this;
        let type2 = BUFFER_TYPE.ARRAY_BUFFER;
        if (buffer2.descriptor.usage & BufferUsage.INDEX) {
          type2 = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
        } else if (buffer2.descriptor.usage & BufferUsage.UNIFORM) {
          type2 = BUFFER_TYPE.UNIFORM_BUFFER;
        }
        const glBuffer = new GlBuffer(gl.createBuffer(), type2);
        this._gpuBuffers[buffer2.uid] = glBuffer;
        buffer2.on("destroy", this.onBufferDestroy, this);
        return glBuffer;
      }
    };
    GlBufferSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "buffer"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs
var GlContextSystem;
var init_GlContextSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs"() {
    init_Extensions();
    init_warn();
    GlContextSystem = class {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this._renderer = renderer;
        this.webGLVersion = 1;
        this.extensions = /* @__PURE__ */ Object.create(null);
        this.supports = {
          uint32Indices: false
        };
        this.handleContextLost = this.handleContextLost.bind(this);
        this.handleContextRestored = this.handleContextRestored.bind(this);
      }
      /**
       * `true` if the context is lost
       * @readonly
       */
      get isLost() {
        return !this.gl || this.gl.isContextLost();
      }
      /**
       * Handles the context change event.
       * @param {WebGLRenderingContext} gl - New WebGL context.
       */
      contextChange(gl) {
        this.gl = gl;
        this._renderer.gl = gl;
        if (gl.isContextLost() && gl.getExtension("WEBGL_lose_context")) {
          gl.getExtension("WEBGL_lose_context").restoreContext();
        }
      }
      init(options) {
        if (options?.context) {
          this.initFromContext(options.context);
        } else {
          const alpha = this._renderer.background.alpha < 1;
          const premultipliedAlpha = options.premultipliedAlpha ?? true;
          const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;
          this.initFromOptions({
            alpha,
            premultipliedAlpha,
            antialias,
            stencil: true,
            preserveDrawingBuffer: options.preserveDrawingBuffer,
            powerPreference: options.powerPreference
          });
        }
      }
      /**
       * Initializes the context.
       * @protected
       * @param {WebGLRenderingContext} gl - WebGL context
       */
      initFromContext(gl) {
        this.gl = gl;
        this.validateContext(gl);
        this._renderer.runners.contextChange.emit(gl);
        const element = this._renderer.view.canvas;
        element.addEventListener("webglcontextlost", this.handleContextLost, false);
        element.addEventListener("webglcontextrestored", this.handleContextRestored, false);
      }
      /**
       * Initialize from context options
       * @protected
       * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
       * @param {object} options - context attributes
       */
      initFromOptions(options) {
        const gl = this.createContext(this._renderer.view.canvas, options);
        this.initFromContext(gl);
      }
      /**
       * Helper class to create a WebGL Context
       * @param canvas - the canvas element that we will get the context from
       * @param options - An options object that gets passed in to the canvas element containing the
       *    context attributes
       * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
       * @returns {WebGLRenderingContext} the WebGL context
       */
      createContext(canvas3, options) {
        const gl = canvas3.getContext("webgl2", options);
        this.webGLVersion = 2;
        this.gl = gl;
        this.getExtensions();
        return this.gl;
      }
      /** Auto-populate the {@link ContextSystem.extensions extensions}. */
      getExtensions() {
        const { gl } = this;
        const common = {
          anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
          floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
          s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
          s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
          // eslint-disable-line camelcase
          etc: gl.getExtension("WEBGL_compressed_texture_etc"),
          etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
          pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
          atc: gl.getExtension("WEBGL_compressed_texture_atc"),
          astc: gl.getExtension("WEBGL_compressed_texture_astc")
        };
        Object.assign(this.extensions, common, {
          // Floats and half-floats
          colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
        });
      }
      /**
       * Handles a lost webgl context
       * @param {WebGLContextEvent} event - The context lost event.
       */
      handleContextLost(event) {
        event.preventDefault();
      }
      /** Handles a restored webgl context. */
      handleContextRestored() {
        this._renderer.runners.contextChange.emit(this.gl);
      }
      destroy() {
        const element = this._renderer.view.canvas;
        this._renderer = null;
        element.removeEventListener("webglcontextlost", this.handleContextLost);
        element.removeEventListener("webglcontextrestored", this.handleContextRestored);
        this.gl.useProgram(null);
        if (this.extensions.loseContext) {
          this.extensions.loseContext.loseContext();
        }
      }
      /**
       * Validate context.
       * @param {WebGLRenderingContext} gl - Render context.
       */
      validateContext(gl) {
        const attributes = gl.getContextAttributes();
        const isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
        if (isWebGl2) {
          this.webGLVersion = 2;
        }
        if (attributes && !attributes.stencil) {
          warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        }
        const hasUint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
        this.supports.uint32Indices = hasUint32;
        if (!hasUint32) {
          warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
        }
      }
    };
    GlContextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "context"
    };
    GlContextSystem.defaultOptions = {
      /**
       * {@link WebGLOptions.context}
       * @default null
       */
      context: null,
      /**
       * {@link WebGLOptions.premultipliedAlpha}
       * @default true
       */
      premultipliedAlpha: true,
      /**
       * {@link WebGLOptions.preserveDrawingBuffer}
       * @default false
       */
      preserveDrawingBuffer: false,
      /**
       * {@link WebGLOptions.powerPreference}
       * @default default
       */
      powerPreference: "default"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs
var GL_FORMATS, GL_TARGETS, GL_TYPES;
var init_const10 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs"() {
    GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2) => {
      GL_FORMATS2[GL_FORMATS2["RGBA"] = 6408] = "RGBA";
      GL_FORMATS2[GL_FORMATS2["RGB"] = 6407] = "RGB";
      GL_FORMATS2[GL_FORMATS2["RG"] = 33319] = "RG";
      GL_FORMATS2[GL_FORMATS2["RED"] = 6403] = "RED";
      GL_FORMATS2[GL_FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
      GL_FORMATS2[GL_FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
      GL_FORMATS2[GL_FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
      GL_FORMATS2[GL_FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
      GL_FORMATS2[GL_FORMATS2["ALPHA"] = 6406] = "ALPHA";
      GL_FORMATS2[GL_FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
      GL_FORMATS2[GL_FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
      GL_FORMATS2[GL_FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
      GL_FORMATS2[GL_FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
      return GL_FORMATS2;
    })(GL_FORMATS || {});
    GL_TARGETS = /* @__PURE__ */ ((GL_TARGETS2) => {
      GL_TARGETS2[GL_TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
      return GL_TARGETS2;
    })(GL_TARGETS || {});
    GL_TYPES = /* @__PURE__ */ ((GL_TYPES2) => {
      GL_TYPES2[GL_TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
      GL_TYPES2[GL_TYPES2["BYTE"] = 5120] = "BYTE";
      GL_TYPES2[GL_TYPES2["SHORT"] = 5122] = "SHORT";
      GL_TYPES2[GL_TYPES2["INT"] = 5124] = "INT";
      GL_TYPES2[GL_TYPES2["FLOAT"] = 5126] = "FLOAT";
      GL_TYPES2[GL_TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
      GL_TYPES2[GL_TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
      return GL_TYPES2;
    })(GL_TYPES || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlInfoFromFormat.mjs
function getGlInfoFromFormat(format3) {
  return infoMap[format3] ?? infoMap.float32;
}
var infoMap;
var init_getGlInfoFromFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlInfoFromFormat.mjs"() {
    init_const10();
    infoMap = {
      uint8x2: { type: GL_TYPES.UNSIGNED_BYTE, size: 2, normalised: false },
      uint8x4: { type: GL_TYPES.UNSIGNED_BYTE, size: 4, normalised: false },
      sint8x2: { type: GL_TYPES.BYTE, size: 2, normalised: false },
      sint8x4: { type: GL_TYPES.BYTE, size: 4, normalised: false },
      unorm8x2: { type: GL_TYPES.UNSIGNED_BYTE, size: 2, normalised: true },
      unorm8x4: { type: GL_TYPES.UNSIGNED_BYTE, size: 4, normalised: true },
      snorm8x2: { type: GL_TYPES.BYTE, size: 2, normalised: true },
      snorm8x4: { type: GL_TYPES.BYTE, size: 4, normalised: true },
      uint16x2: { type: GL_TYPES.UNSIGNED_SHORT, size: 2, normalised: false },
      uint16x4: { type: GL_TYPES.UNSIGNED_SHORT, size: 4, normalised: false },
      sint16x2: { type: GL_TYPES.SHORT, size: 2, normalised: false },
      sint16x4: { type: GL_TYPES.SHORT, size: 4, normalised: false },
      unorm16x2: { type: GL_TYPES.UNSIGNED_SHORT, size: 2, normalised: true },
      unorm16x4: { type: GL_TYPES.UNSIGNED_SHORT, size: 4, normalised: true },
      snorm16x2: { type: GL_TYPES.SHORT, size: 2, normalised: true },
      snorm16x4: { type: GL_TYPES.SHORT, size: 4, normalised: true },
      float16x2: { type: GL_TYPES.HALF_FLOAT, size: 2, normalised: false },
      float16x4: { type: GL_TYPES.HALF_FLOAT, size: 4, normalised: false },
      float32: { type: GL_TYPES.FLOAT, size: 1, normalised: false },
      float32x2: { type: GL_TYPES.FLOAT, size: 2, normalised: false },
      float32x3: { type: GL_TYPES.FLOAT, size: 3, normalised: false },
      float32x4: { type: GL_TYPES.FLOAT, size: 4, normalised: false },
      uint32: { type: GL_TYPES.UNSIGNED_INT, size: 1, normalised: false },
      uint32x2: { type: GL_TYPES.UNSIGNED_INT, size: 2, normalised: false },
      uint32x3: { type: GL_TYPES.UNSIGNED_INT, size: 3, normalised: false },
      uint32x4: { type: GL_TYPES.UNSIGNED_INT, size: 4, normalised: false },
      sint32: { type: GL_TYPES.INT, size: 1, normalised: false },
      sint32x2: { type: GL_TYPES.INT, size: 2, normalised: false },
      sint32x3: { type: GL_TYPES.INT, size: 3, normalised: false },
      sint32x4: { type: GL_TYPES.INT, size: 4, normalised: false }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs
var byteSizeMap, topologyToGlMap, GlGeometrySystem;
var init_GlGeometrySystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs"() {
    init_Extensions();
    init_warn();
    init_getGlInfoFromFormat();
    byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
    topologyToGlMap = {
      "point-list": 0,
      "line-list": 1,
      "line-strip": 3,
      "triangle-list": 4,
      "triangle-strip": 5
    };
    GlGeometrySystem = class {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this._geometryVaoHash = {};
        this._renderer = renderer;
        this._activeGeometry = null;
        this._activeVao = null;
        this.hasVao = true;
        this.hasInstance = true;
        this.canUseUInt32ElementIndex = true;
      }
      /** Sets up the renderer context and necessary buffers. */
      contextChange() {
        this.gl = this._renderer.gl;
      }
      /**
       * Binds geometry so that is can be drawn. Creating a Vao if required
       * @param geometry - Instance of geometry to bind.
       * @param program - Instance of program to use vao for.
       */
      bind(geometry, program) {
        const gl = this.gl;
        this._activeGeometry = geometry;
        const vao = this.getVao(geometry, program);
        if (this._activeVao !== vao) {
          this._activeVao = vao;
          gl.bindVertexArray(vao);
        }
        this.updateBuffers();
      }
      /** Reset and unbind any active VAO and geometry. */
      reset() {
        this.unbind();
      }
      /** Update buffers of the currently bound geometry. */
      updateBuffers() {
        const geometry = this._activeGeometry;
        const bufferSystem = this._renderer.buffer;
        for (let i3 = 0; i3 < geometry.buffers.length; i3++) {
          const buffer2 = geometry.buffers[i3];
          bufferSystem.updateBuffer(buffer2);
        }
      }
      /**
       * Check compatibility between a geometry and a program
       * @param geometry - Geometry instance.
       * @param program - Program instance.
       */
      checkCompatibility(geometry, program) {
        const geometryAttributes = geometry.attributes;
        const shaderAttributes = program.attributeData;
        for (const j3 in shaderAttributes) {
          if (!geometryAttributes[j3]) {
            throw new Error(`shader and geometry incompatible, geometry missing the "${j3}" attribute`);
          }
        }
      }
      /**
       * Takes a geometry and program and generates a unique signature for them.
       * @param geometry - To get signature from.
       * @param program - To test geometry against.
       * @returns - Unique signature of the geometry and program
       */
      getSignature(geometry, program) {
        const attribs = geometry.attributes;
        const shaderAttributes = program.attributeData;
        const strings = ["g", geometry.uid];
        for (const i3 in attribs) {
          if (shaderAttributes[i3]) {
            strings.push(i3, shaderAttributes[i3].location);
          }
        }
        return strings.join("-");
      }
      getVao(geometry, program) {
        return this._geometryVaoHash[geometry.uid]?.[program.key] || this.initGeometryVao(geometry, program);
      }
      /**
       * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
       * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the
       * attribute locations.
       * @param geometry - Instance of geometry to to generate Vao for.
       * @param program
       * @param _incRefCount - Increment refCount of all geometry buffers.
       */
      initGeometryVao(geometry, program, _incRefCount = true) {
        const gl = this._renderer.gl;
        const bufferSystem = this._renderer.buffer;
        this._renderer.shader.getProgramData(program);
        this.checkCompatibility(geometry, program);
        const signature = this.getSignature(geometry, program);
        if (!this._geometryVaoHash[geometry.uid]) {
          this._geometryVaoHash[geometry.uid] = /* @__PURE__ */ Object.create(null);
          geometry.on("destroy", this.onGeometryDestroy, this);
        }
        const vaoObjectHash = this._geometryVaoHash[geometry.uid];
        let vao = vaoObjectHash[signature];
        if (vao) {
          vaoObjectHash[program.key] = vao;
          return vao;
        }
        const buffers = geometry.buffers;
        const attributes = geometry.attributes;
        const tempStride = {};
        const tempStart = {};
        for (const j3 in buffers) {
          tempStride[j3] = 0;
          tempStart[j3] = 0;
        }
        for (const j3 in attributes) {
          if (!attributes[j3].size && program.attributeData[j3]) {
            attributes[j3].size = program.attributeData[j3].size;
          } else if (!attributes[j3].size) {
            warn(`PIXI Geometry attribute '${j3}' size cannot be determined (likely the bound shader does not have the attribute)`);
          }
          tempStride[attributes[j3].buffer.uid] += attributes[j3].size * byteSizeMap[attributes[j3].type];
        }
        for (const j3 in attributes) {
          const attribute = attributes[j3];
          const attribSize = attribute.size;
          if (attribute.stride === void 0) {
            if (tempStride[attribute.buffer.uid] === attribSize * byteSizeMap[attribute.type]) {
              attribute.stride = 0;
            } else {
              attribute.stride = tempStride[attribute.buffer.uid];
            }
          }
          if (attribute.start === void 0) {
            attribute.start = tempStart[attribute.buffer.uid];
            tempStart[attribute.buffer.uid] += attribSize * byteSizeMap[attribute.type];
          }
        }
        vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        for (let i3 = 0; i3 < buffers.length; i3++) {
          const buffer2 = buffers[i3];
          bufferSystem.bind(buffer2);
        }
        this.activateVao(geometry, program);
        vaoObjectHash[program.key] = vao;
        vaoObjectHash[signature] = vao;
        gl.bindVertexArray(null);
        return vao;
      }
      /**
       * Disposes geometry.
       * @param geometry - Geometry with buffers. Only VAO will be disposed
       * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray
       */
      onGeometryDestroy(geometry, contextLost) {
        const vaoObjectHash = this._geometryVaoHash[geometry.uid];
        const gl = this.gl;
        if (vaoObjectHash) {
          if (contextLost) {
            for (const i3 in vaoObjectHash) {
              if (this._activeVao !== vaoObjectHash[i3]) {
                this.unbind();
              }
              gl.deleteVertexArray(vaoObjectHash[i3]);
            }
          }
          this._geometryVaoHash[geometry.uid] = null;
        }
      }
      /**
       * Dispose all WebGL resources of all managed geometries.
       * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls
       */
      destroyAll(contextLost = false) {
        const gl = this.gl;
        for (const i3 in this._geometryVaoHash) {
          if (contextLost) {
            for (const j3 in this._geometryVaoHash[i3]) {
              const vaoObjectHash = this._geometryVaoHash[i3];
              if (this._activeVao !== vaoObjectHash) {
                this.unbind();
              }
              gl.deleteVertexArray(vaoObjectHash[j3]);
            }
          }
          this._geometryVaoHash[i3] = null;
        }
      }
      /**
       * Activate vertex array object.
       * @param geometry - Geometry instance.
       * @param program - Shader program instance.
       */
      activateVao(geometry, program) {
        const gl = this._renderer.gl;
        const bufferSystem = this._renderer.buffer;
        const attributes = geometry.attributes;
        if (geometry.indexBuffer) {
          bufferSystem.bind(geometry.indexBuffer);
        }
        let lastBuffer = null;
        for (const j3 in attributes) {
          const attribute = attributes[j3];
          const buffer2 = attribute.buffer;
          const glBuffer = bufferSystem.getGlBuffer(buffer2);
          if (program.attributeData[j3]) {
            if (lastBuffer !== glBuffer) {
              bufferSystem.bind(buffer2);
              lastBuffer = glBuffer;
            }
            const location = program.attributeData[j3].location;
            gl.enableVertexAttribArray(location);
            const glInfo = getGlInfoFromFormat(attribute.format);
            gl.vertexAttribPointer(
              location,
              glInfo.size,
              glInfo.type,
              // attribute.type || gl.FLOAT,
              glInfo.normalised,
              attribute.stride,
              attribute.offset
            );
            if (attribute.instance) {
              if (this.hasInstance) {
                gl.vertexAttribDivisor(location, 1);
              } else {
                throw new Error("geometry error, GPU Instancing is not supported on this device");
              }
            }
          }
        }
      }
      /**
       * Draws the currently bound geometry.
       * @param topology - The type primitive to render.
       * @param size - The number of elements to be rendered. If not specified, all vertices after the
       *  starting vertex will be drawn.
       * @param start - The starting vertex in the geometry to start drawing from. If not specified,
       *  drawing will start from the first vertex.
       * @param instanceCount - The number of instances of the set of elements to execute. If not specified,
       *  all instances will be drawn.
       */
      draw(topology, size3, start, instanceCount) {
        const { gl } = this._renderer;
        const geometry = this._activeGeometry;
        const glTopology = topologyToGlMap[geometry.topology || topology];
        if (geometry.indexBuffer) {
          const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
          const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
          if (geometry.instanced) {
            gl.drawElementsInstanced(glTopology, size3 || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, geometry.instanceCount || 1);
          } else {
            gl.drawElements(glTopology, size3 || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
          }
        } else if (geometry.instanced) {
          gl.drawArraysInstanced(glTopology, start, size3 || geometry.getSize(), instanceCount || 1);
        } else {
          gl.drawArrays(glTopology, start, size3 || geometry.getSize());
        }
        return this;
      }
      /** Unbind/reset everything. */
      unbind() {
        this.gl.bindVertexArray(null);
        this._activeVao = null;
        this._activeGeometry = null;
      }
      destroy() {
        this._renderer = null;
        this.gl = null;
        this._activeVao = null;
        this._activeGeometry = null;
      }
    };
    GlGeometrySystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "geometry"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs
var bigTriangleProgram, bigTriangleShader, _GlBackBufferSystem, GlBackBufferSystem;
var init_GlBackBufferSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs"() {
    init_Extensions();
    init_Shader();
    init_State();
    init_TextureSource();
    init_Texture();
    init_GlProgram();
    bigTriangleProgram = new GlProgram({
      vertex: `
        out vec2 vUv;

        void main() {
            vUv = vec2((gl_VertexID << 1) & 2, (gl_VertexID & 2));

            gl_Position = vec4(vUv * 2.0f + -1.0f, 0.0f, 1.0f);

            // flip dem UVs
            vUv.y = 1.0f - vUv.y;
        }`,
      fragment: `
        in vec2 vUv;
        out vec4 fragColor;

        uniform sampler2D uTexture;

        void main() {
            fragColor = texture(uTexture, vUv);
        }`,
      name: "big-triangle"
    });
    bigTriangleShader = new Shader({
      glProgram: bigTriangleProgram,
      resources: {
        uTexture: Texture.WHITE.source
      }
    });
    _GlBackBufferSystem = class {
      constructor(renderer) {
        this.useBackBuffer = false;
        this._useBackBufferThisRender = false;
        this._renderer = renderer;
      }
      init(options = {}) {
        const { useBackBuffer, antialias } = { ..._GlBackBufferSystem.defaultOptions, ...options };
        this.useBackBuffer = useBackBuffer;
        this._antialias = antialias;
      }
      renderStart({ target, clear, clearColor }) {
        this._useBackBufferThisRender = this.useBackBuffer && !!target;
        if (this.useBackBuffer) {
          const renderTarget = this._renderer.renderTarget.getRenderTarget(target);
          this._targetTexture = renderTarget.colorTexture;
          target = this._getBackBufferTexture(renderTarget.colorTexture);
        }
        clearColor ?? (clearColor = this._renderer.background.colorRgba);
        this._renderer.renderTarget.start(target, clear, clearColor);
      }
      renderEnd() {
        this._presentBackBuffer();
      }
      _presentBackBuffer() {
        const renderer = this._renderer;
        renderer.renderTarget.finishRenderPass();
        if (!this._useBackBufferThisRender)
          return;
        const gl = renderer.gl;
        renderer.renderTarget.bind(this._targetTexture, false);
        bigTriangleShader.resources.uTexture = this._backBufferTexture.source;
        renderer.shader.bind(bigTriangleShader, false);
        renderer.state.set(State.for2d());
        gl.drawArrays(gl.TRIANGLES, 0, 3);
      }
      _getBackBufferTexture(targetTexture) {
        const source3 = targetTexture.source;
        this._backBufferTexture = this._backBufferTexture || new Texture({
          source: new TextureSource({
            width: source3.width,
            height: source3.height,
            resolution: source3._resolution,
            antialias: this._antialias
          })
        });
        this._backBufferTexture.source.resize(
          source3.width,
          source3.height,
          source3._resolution
        );
        return this._backBufferTexture;
      }
      destroy() {
        if (this._backBufferTexture) {
          this._backBufferTexture.destroy();
          this._backBufferTexture = null;
        }
      }
    };
    GlBackBufferSystem = _GlBackBufferSystem;
    GlBackBufferSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "backBuffer"
    };
    GlBackBufferSystem.defaultOptions = {
      useBackBuffer: false
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs
var GlColorMaskSystem;
var init_GlColorMaskSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs"() {
    init_Extensions();
    GlColorMaskSystem = class {
      constructor(renderer) {
        this._colorMaskCache = 15;
        this._renderer = renderer;
      }
      setMask(colorMask) {
        if (this._colorMaskCache === colorMask)
          return;
        this._colorMaskCache = colorMask;
        this._renderer.gl.colorMask(
          !!(colorMask & 8),
          !!(colorMask & 4),
          !!(colorMask & 2),
          !!(colorMask & 1)
        );
      }
    };
    GlColorMaskSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "colorMask"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs
var GlEncoderSystem;
var init_GlEncoderSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs"() {
    init_Extensions();
    GlEncoderSystem = class {
      constructor(renderer) {
        this.commandFinished = Promise.resolve();
        this._renderer = renderer;
      }
      setGeometry(geometry, shader) {
        this._renderer.geometry.bind(geometry, shader.glProgram);
      }
      finishRenderPass() {
      }
      draw(options) {
        const renderer = this._renderer;
        const { geometry, shader, state, skipSync, topology: type2, size: size3, start, instanceCount } = options;
        renderer.shader.bind(shader, skipSync);
        renderer.geometry.bind(geometry, renderer.shader.activeProgram);
        if (state) {
          renderer.state.set(state);
        }
        renderer.geometry.draw(type2, size3, start, instanceCount);
      }
      destroy() {
        const writeable = this;
        writeable._renderer = null;
      }
    };
    GlEncoderSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "encoder"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs
var GlRenderTarget;
var init_GlRenderTarget = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs"() {
    GlRenderTarget = class {
      constructor() {
        this.width = -1;
        this.height = -1;
        this.msaaRenderBuffer = [];
        this.msaa = false;
        this.dirtyId = -1;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTargetSystem.mjs
var GlRenderTargetSystem;
var init_GlRenderTargetSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTargetSystem.mjs"() {
    init_Extensions();
    init_Matrix();
    init_isRenderingToScreen();
    init_RenderTarget();
    init_SystemRunner();
    init_Texture();
    init_getCanvasTexture();
    init_const7();
    init_GlRenderTarget();
    GlRenderTargetSystem = class {
      constructor(renderer) {
        this.onRenderTargetChange = new SystemRunner("onRenderTargetChange");
        this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();
        this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
        this._renderTargetStack = [];
        this._defaultClearColor = [0, 0, 0, 0];
        this._clearColorCache = [0, 0, 0, 0];
        this._viewPortCache = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
        this.rootProjectionMatrix = new Matrix();
        this._renderer = renderer;
      }
      contextChange(gl) {
        this._gl = gl;
      }
      start(rootRenderSurface, clear = true, clearColor) {
        this._renderTargetStack.length = 0;
        const renderTarget = this.getRenderTarget(rootRenderSurface);
        this.rootRenderTarget = renderTarget;
        this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);
        this.rootProjectionMatrix = renderTarget.projectionMatrix;
        this.push(renderTarget, clear, clearColor);
      }
      bind(renderSurface, clear = true, clearColor) {
        const renderTarget = this.getRenderTarget(renderSurface);
        this.renderTarget = renderTarget;
        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);
        if (renderTarget.dirtyId !== gpuRenderTarget.dirtyId) {
          gpuRenderTarget.dirtyId = renderTarget.dirtyId;
          this._resizeGpuRenderTarget(renderTarget);
        }
        const gl = this._gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);
        renderTarget.colorTextures.forEach((texture) => {
          this._renderer.texture.unbind(texture);
        });
        const viewport = renderTarget.viewport;
        let viewPortY = viewport.y;
        if (renderTarget.isRoot) {
          viewPortY = this._renderer.view.canvas.height - viewport.height;
        }
        const viewPortCache = this._viewPortCache;
        if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {
          viewPortCache.x = viewport.x;
          viewPortCache.y = viewPortY;
          viewPortCache.width = viewport.width;
          viewPortCache.height = viewport.height;
          gl.viewport(
            viewport.x,
            viewPortY,
            viewport.width,
            viewport.height
          );
        }
        this.clear(clear, clearColor);
        this.onRenderTargetChange.emit(renderTarget);
        return renderTarget;
      }
      clear(clear, clearColor) {
        if (!clear)
          return;
        if (typeof clear === "boolean") {
          clear = clear ? CLEAR.ALL : CLEAR.NONE;
        }
        const gl = this._gl;
        if (clear & CLEAR.COLOR) {
          clearColor ?? (clearColor = this._defaultClearColor);
          const clearColorCache = this._clearColorCache;
          const clearColorArray = clearColor;
          if (clearColorCache[0] !== clearColorArray[0] || clearColorCache[1] !== clearColorArray[1] || clearColorCache[2] !== clearColorArray[2] || clearColorCache[3] !== clearColorArray[3]) {
            clearColorCache[0] = clearColorArray[0];
            clearColorCache[1] = clearColorArray[1];
            clearColorCache[2] = clearColorArray[2];
            clearColorCache[3] = clearColorArray[3];
            gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);
          }
        }
        gl.clear(clear);
      }
      push(renderSurface, clear = true, clearColor) {
        const renderTarget = this.bind(renderSurface, clear, clearColor);
        this._renderTargetStack.push(renderTarget);
        return renderTarget;
      }
      pop() {
        this._renderTargetStack.pop();
        this.bind(this._renderTargetStack[this._renderTargetStack.length - 1], false);
      }
      getRenderTarget(renderSurface) {
        return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);
      }
      _initRenderTarget(renderSurface) {
        let renderTarget = null;
        if (renderSurface instanceof HTMLCanvasElement) {
          renderSurface = getCanvasTexture(renderSurface);
        }
        if (renderSurface instanceof RenderTarget) {
          renderTarget = renderSurface;
        } else if (renderSurface instanceof Texture) {
          renderTarget = new RenderTarget({
            colorTextures: [renderSurface]
          });
          if (renderSurface.source.resource instanceof HTMLCanvasElement) {
            renderTarget.isRoot = true;
          }
          renderSurface.source.on("destroy", () => {
            renderTarget.destroy();
          });
        }
        this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);
        return renderTarget;
      }
      finishRenderPass(renderTarget) {
        renderTarget = renderTarget || this.renderTarget;
        const glRenderTarget = this.getGpuRenderTarget(renderTarget);
        if (!glRenderTarget.msaa)
          return;
        const gl = this._renderer.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);
        gl.blitFramebuffer(
          0,
          0,
          glRenderTarget.width,
          glRenderTarget.height,
          0,
          0,
          glRenderTarget.width,
          glRenderTarget.height,
          gl.COLOR_BUFFER_BIT,
          gl.NEAREST
        );
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);
      }
      copyToTexture(sourceRenderSurfaceTexture, destinationTexture, origin, size3) {
        const renderer = this._renderer;
        const glRenderTarget = this.getGpuRenderTarget(sourceRenderSurfaceTexture);
        const gl = renderer.gl;
        this.finishRenderPass(sourceRenderSurfaceTexture);
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
        renderer.texture.bind(destinationTexture, 0);
        gl.copyTexSubImage2D(
          gl.TEXTURE_2D,
          0,
          0,
          0,
          origin.x,
          origin.y,
          size3.width,
          size3.height
        );
        return destinationTexture;
      }
      getGpuRenderTarget(renderTarget) {
        return this._gpuRenderTargetHash[renderTarget.uid] || this._initGpuRenderTarget(renderTarget);
      }
      _initGpuRenderTarget(renderTarget) {
        const renderer = this._renderer;
        const gl = renderer.gl;
        const glRenderTarget = new GlRenderTarget();
        if (renderTarget.colorTexture.source.resource instanceof HTMLCanvasElement) {
          this._gpuRenderTargetHash[renderTarget.uid] = glRenderTarget;
          glRenderTarget.framebuffer = null;
          return glRenderTarget;
        }
        this._initColor(renderTarget, glRenderTarget);
        if (renderTarget.stencil) {
          this._initStencil(glRenderTarget);
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        this._gpuRenderTargetHash[renderTarget.uid] = glRenderTarget;
        return glRenderTarget;
      }
      _resizeGpuRenderTarget(renderTarget) {
        if (renderTarget.isRoot)
          return;
        const glRenderTarget = this.getGpuRenderTarget(renderTarget);
        this._resizeColor(renderTarget, glRenderTarget);
        if (renderTarget.stencil) {
          this._resizeStencil(glRenderTarget);
        }
      }
      _initColor(renderTarget, glRenderTarget) {
        const renderer = this._renderer;
        const gl = renderer.gl;
        const resolveTargetFramebuffer = gl.createFramebuffer();
        glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);
        glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;
        glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;
        renderTarget.colorTextures.forEach((colorTexture, i3) => {
          const source3 = colorTexture.source;
          if (source3.antialias) {
            glRenderTarget.msaa = true;
          }
          renderer.texture.bindSource(source3, 0);
          const glSource = renderer.texture.getGlSource(source3);
          const glTexture = glSource.texture;
          gl.framebufferTexture2D(
            gl.FRAMEBUFFER,
            gl.COLOR_ATTACHMENT0 + i3,
            3553,
            // texture.target,
            glTexture,
            0
          );
        });
        if (glRenderTarget.msaa) {
          const viewFramebuffer = gl.createFramebuffer();
          glRenderTarget.framebuffer = viewFramebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
          renderTarget.colorTextures.forEach((_2, i3) => {
            const msaaRenderBuffer = gl.createRenderbuffer();
            glRenderTarget.msaaRenderBuffer[i3] = msaaRenderBuffer;
          });
        } else {
          glRenderTarget.framebuffer = resolveTargetFramebuffer;
        }
      }
      _resizeColor(renderTarget, glRenderTarget) {
        const source3 = renderTarget.colorTexture.source;
        glRenderTarget.width = source3.pixelWidth;
        glRenderTarget.height = source3.pixelHeight;
        renderTarget.colorTextures.forEach((colorTexture, i3) => {
          if (i3 === 0)
            return;
          colorTexture.source.resize(source3.width, source3.height, source3._resolution);
        });
        if (glRenderTarget.msaa) {
          const renderer = this._renderer;
          const gl = renderer.gl;
          const viewFramebuffer = glRenderTarget.framebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
          renderTarget.colorTextures.forEach((colorTexture, i3) => {
            const source22 = colorTexture.source;
            renderer.texture.bindSource(source22, 0);
            const glSource = renderer.texture.getGlSource(source22);
            const glInternalFormat = glSource.internalFormat;
            const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i3];
            gl.bindRenderbuffer(
              gl.RENDERBUFFER,
              msaaRenderBuffer
            );
            gl.renderbufferStorageMultisample(
              gl.RENDERBUFFER,
              4,
              glInternalFormat,
              source22.pixelWidth,
              source22.pixelHeight
            );
            gl.framebufferRenderbuffer(
              gl.FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0 + i3,
              gl.RENDERBUFFER,
              msaaRenderBuffer
            );
          });
        }
      }
      _initStencil(glRenderTarget) {
        const gl = this._renderer.gl;
        const depthStencilRenderBuffer = gl.createRenderbuffer();
        glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;
        gl.bindRenderbuffer(
          gl.RENDERBUFFER,
          depthStencilRenderBuffer
        );
        gl.framebufferRenderbuffer(
          gl.FRAMEBUFFER,
          gl.DEPTH_STENCIL_ATTACHMENT,
          gl.RENDERBUFFER,
          depthStencilRenderBuffer
        );
      }
      _resizeStencil(glRenderTarget) {
        const gl = this._renderer.gl;
        gl.bindRenderbuffer(
          gl.RENDERBUFFER,
          glRenderTarget.depthStencilRenderBuffer
        );
        if (glRenderTarget.msaa) {
          gl.renderbufferStorageMultisample(
            gl.RENDERBUFFER,
            4,
            gl.DEPTH24_STENCIL8,
            glRenderTarget.width,
            glRenderTarget.height
          );
        } else {
          gl.renderbufferStorage(
            gl.RENDERBUFFER,
            gl.DEPTH24_STENCIL8,
            glRenderTarget.width,
            glRenderTarget.height
          );
        }
      }
    };
    GlRenderTargetSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "renderTarget"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs
var GlStencilSystem;
var init_GlStencilSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs"() {
    init_Extensions();
    init_GpuStencilModesToPixi();
    init_const8();
    GlStencilSystem = class {
      constructor(renderer) {
        this._stencilCache = {
          enabled: false,
          stencilReference: 0,
          stencilMode: STENCIL_MODES.NONE
        };
        this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
        renderer.renderTarget.onRenderTargetChange.add(this);
      }
      contextChange(gl) {
        this._gl = gl;
        this._comparisonFuncMapping = {
          always: gl.ALWAYS,
          never: gl.NEVER,
          equal: gl.EQUAL,
          "not-equal": gl.NOTEQUAL,
          less: gl.LESS,
          "less-equal": gl.LEQUAL,
          greater: gl.GREATER,
          "greater-equal": gl.GEQUAL
        };
        this._stencilOpsMapping = {
          keep: gl.KEEP,
          zero: gl.ZERO,
          replace: gl.REPLACE,
          invert: gl.INVERT,
          "increment-clamp": gl.INCR,
          "decrement-clamp": gl.DECR,
          "increment-wrap": gl.INCR_WRAP,
          "decrement-wrap": gl.DECR_WRAP
        };
      }
      onRenderTargetChange(renderTarget) {
        if (this._activeRenderTarget === renderTarget)
          return;
        this._activeRenderTarget = renderTarget;
        let stencilState = this._renderTargetStencilState[renderTarget.uid];
        if (!stencilState) {
          stencilState = this._renderTargetStencilState[renderTarget.uid] = {
            stencilMode: STENCIL_MODES.DISABLED,
            stencilReference: 0
          };
        }
        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
      }
      setStencilMode(stencilMode, stencilReference) {
        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
        const gl = this._gl;
        const mode = GpuStencilModesToPixi[stencilMode];
        const _stencilCache = this._stencilCache;
        stencilState.stencilMode = stencilMode;
        stencilState.stencilReference = stencilReference;
        if (stencilMode === STENCIL_MODES.DISABLED) {
          if (this._stencilCache.enabled) {
            this._stencilCache.enabled = false;
            gl.disable(gl.STENCIL_TEST);
          }
          return;
        }
        if (!this._stencilCache.enabled) {
          this._stencilCache.enabled = true;
          gl.enable(gl.STENCIL_TEST);
        }
        if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference) {
          _stencilCache.stencilMode = stencilMode;
          _stencilCache.stencilReference = stencilReference;
          gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 255);
          gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);
        }
      }
    };
    GlStencilSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "stencil"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs
var GlProgramData;
var init_GlProgramData = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs"() {
    GlProgramData = class {
      /**
       * Makes a new Pixi program.
       * @param program - webgl program
       * @param uniformData - uniforms
       */
      constructor(program, uniformData) {
        this.program = program;
        this.uniformData = uniformData;
        this.uniformGroups = {};
        this.uniformDirtyGroups = {};
        this.uniformBlockBindings = {};
      }
      /** Destroys this program. */
      destroy() {
        this.uniformData = null;
        this.uniformGroups = null;
        this.uniformDirtyGroups = null;
        this.uniformBlockBindings = null;
        this.program = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs
function compileShader(gl, type2, src) {
  const shader = gl.createShader(type2);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}
var init_compileShader = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs
function booleanArray(size3) {
  const array = new Array(size3);
  for (let i3 = 0; i3 < array.length; i3++) {
    array[i3] = false;
  }
  return array;
}
function defaultValue(type2, size3) {
  switch (type2) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size3);
    case "vec3":
      return new Float32Array(3 * size3);
    case "vec4":
      return new Float32Array(4 * size3);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size3);
    case "ivec3":
      return new Int32Array(3 * size3);
    case "ivec4":
      return new Int32Array(4 * size3);
    case "uvec2":
      return new Uint32Array(2 * size3);
    case "uvec3":
      return new Uint32Array(3 * size3);
    case "uvec4":
      return new Uint32Array(4 * size3);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size3);
    case "bvec3":
      return booleanArray(3 * size3);
    case "bvec4":
      return booleanArray(4 * size3);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var init_defaultValue = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapSize.mjs
function mapSize(type2) {
  return GLSL_TO_SIZE[type2];
}
var GLSL_TO_SIZE;
var init_mapSize = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapSize.mjs"() {
    GLSL_TO_SIZE = {
      float: 1,
      vec2: 2,
      vec3: 3,
      vec4: 4,
      int: 1,
      ivec2: 2,
      ivec3: 3,
      ivec4: 4,
      uint: 1,
      uvec2: 2,
      uvec3: 3,
      uvec4: 4,
      bool: 1,
      bvec2: 2,
      bvec3: 3,
      bvec4: 4,
      mat2: 4,
      mat3: 9,
      mat4: 16,
      sampler2D: 1
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs
function mapType(gl, type2) {
  if (!GL_TABLE) {
    const typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (let i3 = 0; i3 < typeNames.length; ++i3) {
      const tn = typeNames[i3];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type2];
}
var GL_TABLE, GL_TO_GLSL_TYPES;
var init_mapType = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs"() {
    GL_TABLE = null;
    GL_TO_GLSL_TYPES = {
      FLOAT: "float",
      FLOAT_VEC2: "vec2",
      FLOAT_VEC3: "vec3",
      FLOAT_VEC4: "vec4",
      INT: "int",
      INT_VEC2: "ivec2",
      INT_VEC3: "ivec3",
      INT_VEC4: "ivec4",
      UNSIGNED_INT: "uint",
      UNSIGNED_INT_VEC2: "uvec2",
      UNSIGNED_INT_VEC3: "uvec3",
      UNSIGNED_INT_VEC4: "uvec4",
      BOOL: "bool",
      BOOL_VEC2: "bvec2",
      BOOL_VEC3: "bvec3",
      BOOL_VEC4: "bvec4",
      FLOAT_MAT2: "mat2",
      FLOAT_MAT3: "mat3",
      FLOAT_MAT4: "mat4",
      SAMPLER_2D: "sampler2D",
      INT_SAMPLER_2D: "sampler2D",
      UNSIGNED_INT_SAMPLER_2D: "sampler2D",
      SAMPLER_CUBE: "samplerCube",
      INT_SAMPLER_CUBE: "samplerCube",
      UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
      SAMPLER_2D_ARRAY: "sampler2DArray",
      INT_SAMPLER_2D_ARRAY: "sampler2DArray",
      UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getAttributeData.mjs
function getAttributeData(program, gl) {
  const attributes = {};
  const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i3 = 0; i3 < totalAttributes; i3++) {
    const attribData = gl.getActiveAttrib(program, i3);
    if (attribData.name.startsWith("gl_")) {
      continue;
    }
    const type2 = mapType(gl, attribData.type);
    const data = {
      type: type2,
      name: attribData.name,
      size: mapSize(type2),
      location: gl.getAttribLocation(program, attribData.name)
    };
    attributes[attribData.name] = data;
  }
  return attributes;
}
var init_getAttributeData = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getAttributeData.mjs"() {
    init_mapSize();
    init_mapType();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformBufferData.mjs
function getUniformBufferData(program, gl) {
  const uniformBlocks = {};
  const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
  for (let i3 = 0; i3 < totalUniformsBlocks; i3++) {
    const name = gl.getActiveUniformBlockName(program, i3);
    const uniformBlockIndex = gl.getUniformBlockIndex(program, name);
    const size3 = gl.getActiveUniformBlockParameter(program, i3, gl.UNIFORM_BLOCK_DATA_SIZE);
    uniformBlocks[name] = {
      name,
      index: uniformBlockIndex,
      size: size3
    };
  }
  return uniformBlocks;
}
var init_getUniformBufferData = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformBufferData.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs
function getUniformData(program, gl) {
  const uniforms = {};
  const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i3 = 0; i3 < totalUniforms; i3++) {
    const uniformData = gl.getActiveUniform(program, i3);
    const name = uniformData.name.replace(/\[.*?\]$/, "");
    const isArray = !!uniformData.name.match(/\[.*?\]$/);
    const type2 = mapType(gl, uniformData.type);
    uniforms[name] = {
      name,
      index: i3,
      type: type2,
      size: uniformData.size,
      isArray,
      value: defaultValue(type2, uniformData.size)
    };
  }
  return uniforms;
}
var init_getUniformData = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs"() {
    init_defaultValue();
    init_mapType();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs
function logPrettyShaderError(gl, shader) {
  const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index) => `${index}: ${line}`);
  const shaderLog = gl.getShaderInfoLog(shader);
  const splitShader = shaderLog.split("\n");
  const dedupe = {};
  const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n2) => {
    if (n2 && !dedupe[n2]) {
      dedupe[n2] = true;
      return true;
    }
    return false;
  });
  const logArgs = [""];
  lineNumbers.forEach((number) => {
    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  const fragmentSourceToLog = shaderSrc.join("\n");
  logArgs[0] = fragmentSourceToLog;
  console.error(shaderLog);
  console.groupCollapsed("click to view full shader code");
  console.warn(...logArgs);
  console.groupEnd();
}
function logProgramError(gl, program, vertexShader, fragmentShader) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, vertexShader);
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, fragmentShader);
    }
    console.error("PixiJS Error: Could not initialize shader.");
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
  }
}
var init_logProgramError = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs
function generateProgram(gl, program) {
  const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);
  const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);
  const webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader);
  gl.attachShader(webGLProgram, glFragShader);
  const transformFeedbackVaryings = program.transformFeedbackVaryings;
  if (transformFeedbackVaryings) {
    if (typeof gl.transformFeedbackVaryings !== "function") {
      warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
    } else {
      gl.transformFeedbackVaryings(
        webGLProgram,
        transformFeedbackVaryings.names,
        transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS
      );
    }
  }
  gl.linkProgram(webGLProgram);
  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
    logProgramError(gl, webGLProgram, glVertShader, glFragShader);
  }
  program.attributeData = getAttributeData(webGLProgram, gl);
  program.uniformData = getUniformData(webGLProgram, gl);
  program.uniformBlockData = getUniformBufferData(webGLProgram, gl);
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  const uniformData = {};
  for (const i3 in program.uniformData) {
    const data = program.uniformData[i3];
    uniformData[i3] = {
      location: gl.getUniformLocation(webGLProgram, i3),
      value: defaultValue(data.type, data.size)
    };
  }
  const glProgram = new GlProgramData(webGLProgram, uniformData);
  return glProgram;
}
var init_generateProgram = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs"() {
    init_warn();
    init_GlProgramData();
    init_compileShader();
    init_defaultValue();
    init_getAttributeData();
    init_getUniformBufferData();
    init_getUniformData();
    init_logProgramError();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs
var defaultSyncData, GlShaderSystem;
var init_GlShaderSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs"() {
    init_Extensions();
    init_BufferResource();
    init_UniformGroup();
    init_TextureSource();
    init_TextureStyle();
    init_generateProgram();
    defaultSyncData = {
      textureCount: 0,
      blockIndex: 0
    };
    GlShaderSystem = class {
      constructor(renderer) {
        this.activeProgram = null;
        this._programDataHash = /* @__PURE__ */ Object.create(null);
        this._nextIndex = 0;
        this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null);
        this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      contextChange(gl) {
        this._gl = gl;
        this._maxBindings = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);
      }
      bind(shader, skipSync) {
        this._setProgram(shader.glProgram);
        if (skipSync)
          return;
        defaultSyncData.textureCount = 0;
        defaultSyncData.blockIndex = 0;
        const gl = this._gl;
        const programData = this.getProgramData(shader.glProgram);
        for (const i3 in shader.groups) {
          const bindGroup = shader.groups[i3];
          for (const j3 in bindGroup.resources) {
            const resource = bindGroup.resources[j3];
            if (resource instanceof UniformGroup) {
              if (resource.ubo) {
                this.bindUniformBlock(
                  resource,
                  shader.uniformBindMap[i3][j3],
                  defaultSyncData.blockIndex++
                );
              } else {
                this._updateUniformGroup(resource);
              }
            } else if (resource instanceof BufferResource) {
              this.bindUniformBlock(
                resource,
                shader.uniformBindMap[i3][j3],
                defaultSyncData.blockIndex++
              );
            } else if (resource instanceof TextureSource) {
              this._renderer.texture.bind(resource, defaultSyncData.textureCount);
              const uniformName = shader.uniformBindMap[i3][j3];
              const uniformData = programData.uniformData[uniformName];
              if (uniformData) {
                if (uniformData.value !== defaultSyncData.textureCount) {
                  gl.uniform1i(uniformData.location, defaultSyncData.textureCount);
                }
                defaultSyncData.textureCount++;
              }
            } else if (resource instanceof TextureStyle) {
            }
          }
        }
      }
      _updateUniformGroup(uniformGroup) {
        this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this.activeProgram, defaultSyncData);
      }
      bindUniformBlock(uniformGroup, name, index = 0) {
        const bufferSystem = this._renderer.buffer;
        const programData = this.getProgramData(this.activeProgram);
        const isBufferResource = uniformGroup.bufferResource;
        if (isBufferResource) {
          this._renderer.uniformBuffer.updateUniformGroup(uniformGroup);
        }
        bufferSystem.updateBuffer(uniformGroup.buffer);
        let boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid];
        if (boundIndex === void 0) {
          const nextIndex = this._nextIndex++ % this._maxBindings;
          const currentBoundUniformGroup = this._boundIndexToUniformsHash[nextIndex];
          if (currentBoundUniformGroup) {
            this._boundUniformsIdsToIndexHash[currentBoundUniformGroup.uid] = void 0;
          }
          boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid] = nextIndex;
          this._boundIndexToUniformsHash[nextIndex] = uniformGroup;
          if (isBufferResource) {
            bufferSystem.bindBufferRange(uniformGroup.buffer, nextIndex, uniformGroup.offset);
          } else {
            bufferSystem.bindBufferBase(uniformGroup.buffer, nextIndex);
          }
        }
        const gl = this._gl;
        const uniformBlockIndex = this.activeProgram.uniformBlockData[name].index;
        if (programData.uniformBlockBindings[index] === boundIndex)
          return;
        programData.uniformBlockBindings[index] = boundIndex;
        gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundIndex);
      }
      _setProgram(program) {
        if (this.activeProgram === program)
          return;
        this.activeProgram = program;
        const programData = this.getProgramData(program);
        this._gl.useProgram(programData.program);
      }
      getProgramData(program) {
        return this._programDataHash[program.key] || this._createProgramData(program);
      }
      _createProgramData(program) {
        const key2 = program.key;
        this._programDataHash[key2] = generateProgram(this._gl, program);
        return this._programDataHash[key2];
      }
      destroy() {
        for (const key2 of Object.keys(this._programDataHash)) {
          const programData = this._programDataHash[key2];
          programData.destroy();
          this._programDataHash[key2] = null;
        }
        this._programDataHash = null;
        this._boundUniformsIdsToIndexHash = null;
      }
    };
    GlShaderSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "shader"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/unsafeEvalSupported.mjs
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    const func2 = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func2({ a: "b" }, "a", "b") === true;
  } catch (e3) {
    unsafeEval = false;
  }
  return unsafeEval;
}
var unsafeEval;
var init_unsafeEvalSupported = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/unsafeEvalSupported.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/uniformParsers.mjs
var uniformParsers;
var init_uniformParsers = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/uniformParsers.mjs"() {
    init_Texture();
    uniformParsers = [
      // a float cache layer
      {
        test: (data) => data.type === "float" && data.size === 1 && !data.isArray,
        code: (name) => `
            if(uv["${name}"] !== ud["${name}"].value)
            {
                ud["${name}"].value = uv["${name}"]
                gl.uniform1f(ud["${name}"].location, uv["${name}"])
            }
            `
      },
      // handling samplers
      {
        test: (data, uniform) => (
          // eslint-disable-next-line max-len,no-eq-null,eqeqeq
          (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform instanceof Texture)
        ),
        code: (name) => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${name}"], t);

            if(ud["${name}"].value !== t)
            {
                ud["${name}"].value = t;
                gl.uniform1i(ud["${name}"].location, t);
; // eslint-disable-line max-len
            }`
      },
      // uploading pixi matrix object to mat3
      {
        test: (data, uniform) => data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== void 0,
        code: (name) => (
          // TODO and some smart caching dirty ids here!
          `
            gl.uniformMatrix3fv(ud["${name}"].location, false, uv["${name}"].toArray(true));
            `
        )
      },
      // uploading a pixi point as a vec2 with caching layer
      {
        test: (data, uniform) => data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== void 0,
        code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${name}"].location, v.x, v.y);
                }`
      },
      // caching layer for a vec2
      {
        test: (data) => data.type === "vec2" && data.size === 1 && !data.isArray,
        code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${name}"].location, v[0], v[1]);
                }
            `
      },
      // upload a pixi rectangle as a vec4 with caching layer
      {
        test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== void 0,
        code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${name}"].location, v.x, v.y, v.width, v.height)
                }`
      },
      // upload a pixi color as vec4 with caching layer
      {
        test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.red !== void 0,
        code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${name}"].location, v.red, v.green, v.blue, v.alpha)
                }`
      },
      // upload a pixi color as a vec3 with caching layer
      {
        test: (data, uniform) => data.type === "vec3" && data.size === 1 && !data.isArray && uniform.red !== void 0,
        code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
    
                    gl.uniform3f(ud["${name}"].location, v.red, v.green, v.blue)
                }`
      },
      // a caching layer for vec4 uploading
      {
        test: (data) => data.type === "vec4" && data.size === 1 && !data.isArray,
        code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${name}"].location, v[0], v[1], v[2], v[3])
                }`
      }
    ];
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateUniformsSync.mjs
function generateUniformsSync(group, uniformData) {
  const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
  for (const i3 in group.uniforms) {
    const data = uniformData[i3];
    if (!data) {
      if (group.uniforms[i3] instanceof UniformGroup) {
        if (group.uniforms[i3].ubo) {
          funcFragments.push(`
                        renderer.shader.bindUniformBlock(uv.${i3}, "${i3}");
                    `);
        } else {
          funcFragments.push(`
                        renderer.shader.updateUniformGroup(uv.${i3});
                    `);
        }
      } else if (group.uniforms[i3] instanceof BufferResource) {
        funcFragments.push(`
                        renderer.shader.bindBufferResource(uv.${i3}, "${i3}");
                    `);
      }
      continue;
    }
    const uniform = group.uniforms[i3];
    let parsed = false;
    for (let j3 = 0; j3 < uniformParsers.length; j3++) {
      if (uniformParsers[j3].test(data, uniform)) {
        funcFragments.push(uniformParsers[j3].code(i3, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      const templateType = data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
      const template = templateType[data.type].replace("location", `ud["${i3}"].location`);
      funcFragments.push(`
            cu = ud["${i3}"];
            cv = cu.value;
            v = uv["${i3}"];
            ${template};`);
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
}
var GLSL_TO_SINGLE_SETTERS_CACHED, GLSL_TO_ARRAY_SETTERS;
var init_generateUniformsSync = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateUniformsSync.mjs"() {
    init_BufferResource();
    init_UniformGroup();
    init_uniformParsers();
    GLSL_TO_SINGLE_SETTERS_CACHED = {
      float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
      vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
      vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
      vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
      int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
      ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
      ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
      ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
      uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
      uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
      uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
      uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
      bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
      bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
      bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
      bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
      mat2: "gl.uniformMatrix2fv(location, false, v)",
      mat3: "gl.uniformMatrix3fv(location, false, v)",
      mat4: "gl.uniformMatrix4fv(location, false, v)",
      sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
      samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
      sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
    };
    GLSL_TO_ARRAY_SETTERS = {
      float: `gl.uniform1fv(location, v)`,
      vec2: `gl.uniform2fv(location, v)`,
      vec3: `gl.uniform3fv(location, v)`,
      vec4: "gl.uniform4fv(location, v)",
      mat4: "gl.uniformMatrix4fv(location, false, v)",
      mat3: "gl.uniformMatrix3fv(location, false, v)",
      mat2: "gl.uniformMatrix2fv(location, false, v)",
      int: "gl.uniform1iv(location, v)",
      ivec2: "gl.uniform2iv(location, v)",
      ivec3: "gl.uniform3iv(location, v)",
      ivec4: "gl.uniform4iv(location, v)",
      uint: "gl.uniform1uiv(location, v)",
      uvec2: "gl.uniform2uiv(location, v)",
      uvec3: "gl.uniform3uiv(location, v)",
      uvec4: "gl.uniform4uiv(location, v)",
      bool: "gl.uniform1iv(location, v)",
      bvec2: "gl.uniform2iv(location, v)",
      bvec3: "gl.uniform3iv(location, v)",
      bvec4: "gl.uniform4iv(location, v)",
      sampler2D: "gl.uniform1iv(location, v)",
      samplerCube: "gl.uniform1iv(location, v)",
      sampler2DArray: "gl.uniform1iv(location, v)"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs
var GlUniformGroupSystem;
var init_GlUniformGroupSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs"() {
    init_Extensions();
    init_unsafeEvalSupported();
    init_generateUniformsSync();
    GlUniformGroupSystem = class {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this.destroyed = false;
        this._cache = {};
        this._uniformGroupSyncHash = {};
        this._renderer = renderer;
        this._systemCheck();
        this.gl = null;
        this._cache = {};
      }
      /**
       * Overrideable function by `@pixi/unsafe-eval` to silence
       * throwing an error if platform doesn't support unsafe-evals.
       * @private
       */
      _systemCheck() {
        if (!unsafeEvalSupported()) {
          throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
        }
      }
      contextChange(gl) {
        this.gl = gl;
      }
      /**
       * Uploads the uniforms values to the currently bound shader.
       * @param group - the uniforms values that be applied to the current shader
       * @param program
       * @param syncData
       * @param syncData.textureCount
       */
      updateUniformGroup(group, program, syncData) {
        const programData = this._renderer.shader.getProgramData(program);
        if (!group.isStatic || group.dirtyId !== programData.uniformDirtyGroups[group.uid]) {
          programData.uniformDirtyGroups[group.uid] = group.dirtyId;
          const syncFunc = this._getUniformSyncFunction(group, program);
          syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);
        }
      }
      /**
       * Overrideable by the @pixi/unsafe-eval package to use static syncUniforms instead.
       * @param group
       * @param program
       */
      _getUniformSyncFunction(group, program) {
        return this._uniformGroupSyncHash[group.signature]?.[program.key] || this._createUniformSyncFunction(group, program);
      }
      _createUniformSyncFunction(group, program) {
        const uniformGroupSyncHash = this._uniformGroupSyncHash[group.signature] || (this._uniformGroupSyncHash[group.signature] = {});
        const id = this._getSignature(group, program.uniformData, "u");
        if (!this._cache[id]) {
          this._cache[id] = generateUniformsSync(group, program.uniformData);
        }
        uniformGroupSyncHash[program.key] = this._cache[id];
        return uniformGroupSyncHash[program.key];
      }
      /**
       * Takes a uniform group and data and generates a unique signature for them.
       * @param group - The uniform group to get signature of
       * @param group.uniforms
       * @param uniformData - Uniform information generated by the shader
       * @param preFix
       * @returns Unique signature of the uniform group
       */
      _getSignature(group, uniformData, preFix) {
        const uniforms = group.uniforms;
        const strings = [`${preFix}-`];
        for (const i3 in uniforms) {
          strings.push(i3);
          if (uniformData[i3]) {
            strings.push(uniformData[i3].type);
          }
        }
        return strings.join("-");
      }
      /** Destroys this System and removes all its textures. */
      destroy() {
        this._renderer = null;
        this.destroyed = true;
        this._cache = null;
      }
    };
    GlUniformGroupSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "uniformGroup"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs
function mapWebGLBlendModesToPixi(gl) {
  const blendMap = {};
  blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.add = [gl.ONE, gl.ONE];
  blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.none = [0, 0];
  blendMap["normal-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap["add-npm"] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  blendMap["screen-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  return blendMap;
}
var init_mapWebGLBlendModesToPixi = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs
var BLEND2, OFFSET2, CULLING2, DEPTH_TEST2, WINDING2, DEPTH_MASK2, _GlStateSystem, GlStateSystem;
var init_GlStateSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs"() {
    init_Extensions();
    init_State();
    init_mapWebGLBlendModesToPixi();
    BLEND2 = 0;
    OFFSET2 = 1;
    CULLING2 = 2;
    DEPTH_TEST2 = 3;
    WINDING2 = 4;
    DEPTH_MASK2 = 5;
    _GlStateSystem = class {
      constructor() {
        this.gl = null;
        this.stateId = 0;
        this.polygonOffset = 0;
        this.blendMode = "none";
        this._blendEq = false;
        this.map = [];
        this.map[BLEND2] = this.setBlend;
        this.map[OFFSET2] = this.setOffset;
        this.map[CULLING2] = this.setCullFace;
        this.map[DEPTH_TEST2] = this.setDepthTest;
        this.map[WINDING2] = this.setFrontFace;
        this.map[DEPTH_MASK2] = this.setDepthMask;
        this.checks = [];
        this.defaultState = new State();
        this.defaultState.blend = true;
      }
      contextChange(gl) {
        this.gl = gl;
        this.blendModesMap = mapWebGLBlendModesToPixi(gl);
        this.set(this.defaultState);
        this.reset();
      }
      /**
       * Sets the current state
       * @param {*} state - The state to set.
       */
      set(state) {
        state = state || this.defaultState;
        if (this.stateId !== state.data) {
          let diff = this.stateId ^ state.data;
          let i3 = 0;
          while (diff) {
            if (diff & 1) {
              this.map[i3].call(this, !!(state.data & 1 << i3));
            }
            diff = diff >> 1;
            i3++;
          }
          this.stateId = state.data;
        }
        for (let i3 = 0; i3 < this.checks.length; i3++) {
          this.checks[i3](this, state);
        }
      }
      /**
       * Sets the state, when previous state is unknown.
       * @param {*} state - The state to set
       */
      forceState(state) {
        state = state || this.defaultState;
        for (let i3 = 0; i3 < this.map.length; i3++) {
          this.map[i3].call(this, !!(state.data & 1 << i3));
        }
        for (let i3 = 0; i3 < this.checks.length; i3++) {
          this.checks[i3](this, state);
        }
        this.stateId = state.data;
      }
      /**
       * Sets whether to enable or disable blending.
       * @param value - Turn on or off WebGl blending.
       */
      setBlend(value) {
        this._updateCheck(_GlStateSystem._checkBlendMode, value);
        this.gl[value ? "enable" : "disable"](this.gl.BLEND);
      }
      /**
       * Sets whether to enable or disable polygon offset fill.
       * @param value - Turn on or off webgl polygon offset testing.
       */
      setOffset(value) {
        this._updateCheck(_GlStateSystem._checkPolygonOffset, value);
        this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
      }
      /**
       * Sets whether to enable or disable depth test.
       * @param value - Turn on or off webgl depth testing.
       */
      setDepthTest(value) {
        this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
      }
      /**
       * Sets whether to enable or disable depth mask.
       * @param value - Turn on or off webgl depth mask.
       */
      setDepthMask(value) {
        this.gl.depthMask(value);
      }
      /**
       * Sets whether to enable or disable cull face.
       * @param {boolean} value - Turn on or off webgl cull face.
       */
      setCullFace(value) {
        this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
      }
      /**
       * Sets the gl front face.
       * @param {boolean} value - true is clockwise and false is counter-clockwise
       */
      setFrontFace(value) {
        this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
      }
      /**
       * Sets the blend mode.
       * @param {number} value - The blend mode to set to.
       */
      setBlendMode(value) {
        if (!this.blendModesMap[value]) {
          value = "normal";
        }
        if (value === this.blendMode) {
          return;
        }
        this.blendMode = value;
        const mode = this.blendModesMap[value];
        const gl = this.gl;
        if (mode.length === 2) {
          gl.blendFunc(mode[0], mode[1]);
        } else {
          gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
        }
        if (mode.length === 6) {
          this._blendEq = true;
          gl.blendEquationSeparate(mode[4], mode[5]);
        } else if (this._blendEq) {
          this._blendEq = false;
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        }
      }
      /**
       * Sets the polygon offset.
       * @param {number} value - the polygon offset
       * @param {number} scale - the polygon offset scale
       */
      setPolygonOffset(value, scale3) {
        this.gl.polygonOffset(value, scale3);
      }
      // used
      /** Resets all the logic and disables the VAOs. */
      reset() {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
        this.forceState(this.defaultState);
        this._blendEq = true;
        this.blendMode = "";
        this.setBlendMode("normal");
      }
      /**
       * Checks to see which updates should be checked based on which settings have been activated.
       *
       * For example, if blend is enabled then we should check the blend modes each time the state is changed
       * or if polygon fill is activated then we need to check if the polygon offset changes.
       * The idea is that we only check what we have too.
       * @param func - the checking function to add or remove
       * @param value - should the check function be added or removed.
       */
      _updateCheck(func2, value) {
        const index = this.checks.indexOf(func2);
        if (value && index === -1) {
          this.checks.push(func2);
        } else if (!value && index !== -1) {
          this.checks.splice(index, 1);
        }
      }
      /**
       * A private little wrapper function that we call to check the blend mode.
       * @param system - the System to perform the state check on
       * @param state - the state that the blendMode will pulled from
       */
      static _checkBlendMode(system, state) {
        system.setBlendMode(state.blendMode);
      }
      /**
       * A private little wrapper function that we call to check the polygon offset.
       * @param system - the System to perform the state check on
       * @param state - the state that the blendMode will pulled from
       */
      static _checkPolygonOffset(system, state) {
        system.setPolygonOffset(1, state.polygonOffset);
      }
      /**
       * @ignore
       */
      destroy() {
        this.gl = null;
        this.checks.length = 0;
      }
    };
    GlStateSystem = _GlStateSystem;
    GlStateSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "state"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs
var GlTexture;
var init_GlTexture = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs"() {
    init_const10();
    GlTexture = class {
      constructor(texture) {
        this.target = GL_TARGETS.TEXTURE_2D;
        this.texture = texture;
        this.width = -1;
        this.height = -1;
        this.type = GL_TYPES.UNSIGNED_BYTE;
        this.internalFormat = GL_FORMATS.RGBA;
        this.format = GL_FORMATS.RGBA;
        this.samplerType = 0;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs
var glUploadBufferImageResource;
var init_glUploadBufferImageResource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs"() {
    glUploadBufferImageResource = {
      id: "image",
      upload(source3, glTexture, gl) {
        if (glTexture.width === source3.width || glTexture.height === source3.height) {
          gl.texSubImage2D(
            gl.TEXTURE_2D,
            0,
            0,
            0,
            glTexture.format,
            glTexture.type,
            source3.resource
          );
        } else {
          gl.texImage2D(
            glTexture.target,
            0,
            glTexture.internalFormat,
            source3.width,
            source3.height,
            0,
            glTexture.format,
            glTexture.type,
            source3.resource
          );
        }
        glTexture.width = source3.width;
        glTexture.height = source3.height;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs
var glUploadImageResource;
var init_glUploadImageResource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs"() {
    glUploadImageResource = {
      id: "image",
      upload(source3, glTexture, gl) {
        const premultipliedAlpha = source3.alphaMode === "premultiply-alpha-on-upload";
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);
        const glWidth = glTexture.width;
        const glHeight = glTexture.height;
        const textureWidth = source3.pixelWidth;
        const textureHeight = source3.pixelHeight;
        const resourceWidth = source3.resourceWidth;
        const resourceHeight = source3.resourceHeight;
        if (resourceWidth < textureWidth || resourceHeight < textureHeight) {
          if (glWidth !== textureWidth || glHeight !== textureHeight) {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              textureWidth,
              textureHeight,
              0,
              glTexture.format,
              glTexture.type,
              null
            );
          }
          gl.texSubImage2D(
            gl.TEXTURE_2D,
            0,
            0,
            0,
            resourceWidth,
            resourceHeight,
            glTexture.format,
            glTexture.type,
            source3.resource
          );
        } else if (glWidth === textureWidth || glHeight === textureHeight) {
          gl.texSubImage2D(
            gl.TEXTURE_2D,
            0,
            0,
            0,
            glTexture.format,
            glTexture.type,
            source3.resource
          );
        } else {
          gl.texImage2D(
            glTexture.target,
            0,
            glTexture.internalFormat,
            textureWidth,
            textureHeight,
            0,
            glTexture.format,
            glTexture.type,
            source3.resource
          );
        }
        glTexture.width = textureWidth;
        glTexture.height = textureHeight;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs
var glUploadVideoResource;
var init_glUploadVideoResource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs"() {
    init_glUploadImageResource();
    glUploadVideoResource = {
      id: "video",
      upload(source3, glTexture, gl) {
        if (!source3.isValid) {
          gl.texImage2D(
            glTexture.target,
            0,
            glTexture.internalFormat,
            1,
            1,
            0,
            glTexture.format,
            glTexture.type,
            null
          );
          return;
        }
        glUploadImageResource.upload(source3, glTexture, gl);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs
var scaleModeToGlFilter, mipmapScaleModeToGlFilter, wrapModeToGlAddress, compareModeToGlCompare;
var init_pixiToGlMaps = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs"() {
    scaleModeToGlFilter = {
      linear: 9729,
      nearest: 9728
    };
    mipmapScaleModeToGlFilter = {
      linear: {
        linear: 9987,
        nearest: 9985
      },
      nearest: {
        linear: 9986,
        nearest: 9984
      }
    };
    wrapModeToGlAddress = {
      "clamp-to-edge": 33071,
      repeat: 10497,
      "mirror-repeat": 33648
    };
    compareModeToGlCompare = {
      never: 512,
      less: 513,
      equal: 514,
      "less-equal": 515,
      greater: 516,
      "not-equal": 517,
      "greater-equal": 518,
      always: 519
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs
function applyStyleParams(style, gl, mipmaps, anisotropicExt, glFunctionName, firstParam) {
  const castParam = firstParam;
  gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeToGlAddress[style.addressModeU]);
  gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeToGlAddress[style.addressModeV]);
  gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeToGlAddress[style.addressModeW]);
  gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);
  if (mipmaps) {
    const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];
    gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);
  } else {
    gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);
  }
  if (anisotropicExt && style.maxAnisotropy > 1) {
    const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
    gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
  }
  if (style.compare) {
    gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);
  }
}
var init_applyStyleParams = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs"() {
    init_pixiToGlMaps();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs
function mapFormatToGlFormat(gl) {
  return {
    // 8-bit formats
    r8unorm: gl.RED,
    r8snorm: gl.RED,
    r8uint: gl.RED,
    r8sint: gl.RED,
    // 16-bit formats
    r16uint: gl.RED,
    r16sint: gl.RED,
    r16float: gl.RED,
    rg8unorm: gl.RG,
    rg8snorm: gl.RG,
    rg8uint: gl.RG,
    rg8sint: gl.RG,
    // 32-bit formats
    r32uint: gl.RED,
    r32sint: gl.RED,
    r32float: gl.RED,
    rg16uint: gl.RG,
    rg16sint: gl.RG,
    rg16float: gl.RG,
    rgba8unorm: gl.RGBA,
    "rgba8unorm-srgb": gl.RGBA,
    // Packed 32-bit formats
    rgba8snorm: gl.RGBA,
    rgba8uint: gl.RGBA,
    rgba8sint: gl.RGBA,
    bgra8unorm: gl.RGBA,
    "bgra8unorm-srgb": gl.RGBA,
    rgb9e5ufloat: gl.RGB,
    rgb10a2unorm: gl.RGBA,
    rg11b10ufloat: gl.RGB,
    // 64-bit formats
    rg32uint: gl.RG,
    rg32sint: gl.RG,
    rg32float: gl.RG,
    rgba16uint: gl.RGBA,
    rgba16sint: gl.RGBA,
    rgba16float: gl.RGBA,
    // 128-bit formats
    rgba32uint: gl.RGBA,
    rgba32sint: gl.RGBA,
    rgba32float: gl.RGBA,
    // Depth/stencil formats
    stencil8: gl.STENCIL_INDEX8,
    depth16unorm: gl.DEPTH_COMPONENT,
    depth24plus: gl.DEPTH_COMPONENT,
    "depth24plus-stencil8": gl.DEPTH_STENCIL,
    depth32float: gl.DEPTH_COMPONENT,
    "depth32float-stencil8": gl.DEPTH_STENCIL
  };
}
var init_mapFormatToGlFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs
function mapFormatToGlInternalFormat(gl) {
  return {
    // 8-bit formats
    r8unorm: gl.R8,
    r8snorm: gl.R8_SNORM,
    r8uint: gl.R8UI,
    r8sint: gl.R8I,
    // 16-bit formats
    r16uint: gl.R16UI,
    r16sint: gl.R16I,
    r16float: gl.R16F,
    rg8unorm: gl.RG8,
    rg8snorm: gl.RG8_SNORM,
    rg8uint: gl.RG8UI,
    rg8sint: gl.RG8I,
    // 32-bit formats
    r32uint: gl.R32UI,
    r32sint: gl.R32I,
    r32float: gl.R32F,
    rg16uint: gl.RG16UI,
    rg16sint: gl.RG16I,
    rg16float: gl.RG16F,
    rgba8unorm: gl.RGBA,
    "rgba8unorm-srgb": gl.SRGB8_ALPHA8,
    // Packed 32-bit formats
    rgba8snorm: gl.RGBA8_SNORM,
    rgba8uint: gl.RGBA8UI,
    rgba8sint: gl.RGBA8I,
    bgra8unorm: gl.RGBA8,
    "bgra8unorm-srgb": gl.SRGB8_ALPHA8,
    rgb9e5ufloat: gl.RGB9_E5,
    rgb10a2unorm: gl.RGB10_A2,
    rg11b10ufloat: gl.R11F_G11F_B10F,
    // 64-bit formats
    rg32uint: gl.RG32UI,
    rg32sint: gl.RG32I,
    rg32float: gl.RG32F,
    rgba16uint: gl.RGBA16UI,
    rgba16sint: gl.RGBA16I,
    rgba16float: gl.RGBA16F,
    // 128-bit formats
    rgba32uint: gl.RGBA32UI,
    rgba32sint: gl.RGBA32I,
    rgba32float: gl.RGBA32F,
    // Depth/stencil formats
    stencil8: gl.STENCIL_INDEX8,
    depth16unorm: gl.DEPTH_COMPONENT16,
    depth24plus: gl.DEPTH_COMPONENT24,
    "depth24plus-stencil8": gl.DEPTH24_STENCIL8,
    depth32float: gl.DEPTH_COMPONENT32F,
    "depth32float-stencil8": gl.DEPTH32F_STENCIL8
  };
}
var init_mapFormatToGlInternalFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs
function mapFormatToGlType(gl) {
  return {
    // 8-bit formats
    r8unorm: gl.UNSIGNED_BYTE,
    r8snorm: gl.BYTE,
    r8uint: gl.UNSIGNED_BYTE,
    r8sint: gl.BYTE,
    // 16-bit formats
    r16uint: gl.UNSIGNED_SHORT,
    r16sint: gl.SHORT,
    r16float: gl.HALF_FLOAT,
    rg8unorm: gl.UNSIGNED_BYTE,
    rg8snorm: gl.BYTE,
    rg8uint: gl.UNSIGNED_BYTE,
    rg8sint: gl.BYTE,
    // 32-bit formats
    r32uint: gl.UNSIGNED_INT,
    r32sint: gl.INT,
    r32float: gl.FLOAT,
    rg16uint: gl.UNSIGNED_SHORT,
    rg16sint: gl.SHORT,
    rg16float: gl.HALF_FLOAT,
    rgba8unorm: gl.UNSIGNED_BYTE,
    "rgba8unorm-srgb": gl.UNSIGNED_BYTE,
    // Packed 32-bit formats
    rgba8snorm: gl.BYTE,
    rgba8uint: gl.UNSIGNED_BYTE,
    rgba8sint: gl.BYTE,
    bgra8unorm: gl.UNSIGNED_BYTE,
    "bgra8unorm-srgb": gl.UNSIGNED_BYTE,
    rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,
    rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,
    rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,
    // 64-bit formats
    rg32uint: gl.UNSIGNED_INT,
    rg32sint: gl.INT,
    rg32float: gl.FLOAT,
    rgba16uint: gl.UNSIGNED_SHORT,
    rgba16sint: gl.SHORT,
    rgba16float: gl.HALF_FLOAT,
    // 128-bit formats
    rgba32uint: gl.UNSIGNED_INT,
    rgba32sint: gl.INT,
    rgba32float: gl.FLOAT,
    // Depth/stencil formats
    stencil8: gl.UNSIGNED_BYTE,
    depth16unorm: gl.UNSIGNED_SHORT,
    depth24plus: gl.UNSIGNED_INT,
    "depth24plus-stencil8": gl.UNSIGNED_INT_24_8,
    depth32float: gl.FLOAT,
    "depth32float-stencil8": gl.FLOAT_32_UNSIGNED_INT_24_8_REV
  };
}
var init_mapFormatToGlType = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs
var TEMP_RECT, BYTES_PER_PIXEL, GlTextureSystem;
var init_GlTextureSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs"() {
    init_Extensions();
    init_Rectangle();
    init_settings();
    init_Texture();
    init_GlTexture();
    init_glUploadBufferImageResource();
    init_glUploadImageResource();
    init_glUploadVideoResource();
    init_applyStyleParams();
    init_mapFormatToGlFormat();
    init_mapFormatToGlInternalFormat();
    init_mapFormatToGlType();
    TEMP_RECT = new Rectangle();
    BYTES_PER_PIXEL = 4;
    GlTextureSystem = class {
      constructor(renderer) {
        this.managedTextures = [];
        this._glTextures = /* @__PURE__ */ Object.create(null);
        this._glSamplers = /* @__PURE__ */ Object.create(null);
        this._boundTextures = [];
        this._activeTextureLocation = -1;
        this._boundSamplers = /* @__PURE__ */ Object.create(null);
        this._uploads = {
          image: glUploadImageResource,
          buffer: glUploadBufferImageResource,
          video: glUploadVideoResource
        };
        this._useSeparateSamplers = false;
        this._renderer = renderer;
      }
      contextChange(gl) {
        this._gl = gl;
        if (!this._mapFormatToInternalFormat) {
          this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl);
          this._mapFormatToType = mapFormatToGlType(gl);
          this._mapFormatToFormat = mapFormatToGlFormat(gl);
        }
        for (let i3 = 0; i3 < 16; i3++) {
          this.bind(Texture.EMPTY, i3);
        }
      }
      bind(texture, location = 0) {
        const source3 = texture.source;
        if (texture) {
          this.bindSource(source3, location);
          if (this._useSeparateSamplers) {
            this._bindSampler(source3.style, location);
          }
        } else {
          this.bindSource(null, location);
          if (this._useSeparateSamplers) {
            this._bindSampler(null, location);
          }
        }
      }
      bindSource(source3, location = 0) {
        const gl = this._gl;
        source3.touched = this._renderer.textureGC.count;
        if (this._boundTextures[location] !== source3) {
          this._boundTextures[location] = source3;
          this._activateLocation(location);
          source3 = source3 || Texture.EMPTY.source;
          const glTexture = this.getGlSource(source3);
          gl.bindTexture(glTexture.target, glTexture.texture);
        }
      }
      _bindSampler(style, location = 0) {
        const gl = this._gl;
        if (!style) {
          this._boundSamplers[location] = null;
          gl.bindSampler(location, null);
          return;
        }
        const sampler = this._getGlSampler(style);
        if (this._boundSamplers[location] !== sampler) {
          this._boundSamplers[location] = sampler;
          gl.bindSampler(location, sampler);
        }
      }
      unbind(texture) {
        const source3 = texture.source;
        const boundTextures = this._boundTextures;
        const gl = this._gl;
        for (let i3 = 0; i3 < boundTextures.length; i3++) {
          if (boundTextures[i3] === source3) {
            this._activateLocation(i3);
            const glTexture = this.getGlSource(source3);
            gl.bindTexture(glTexture.target, null);
            boundTextures[i3] = null;
          }
        }
      }
      _activateLocation(location) {
        if (this._activeTextureLocation !== location) {
          this._activeTextureLocation = location;
          this._gl.activeTexture(this._gl.TEXTURE0 + location);
        }
      }
      _initSource(source3) {
        const gl = this._gl;
        const glTexture = new GlTexture(gl.createTexture());
        glTexture.type = this._mapFormatToType[source3.format];
        glTexture.internalFormat = this._mapFormatToInternalFormat[source3.format];
        glTexture.format = this._mapFormatToFormat[source3.format];
        if (source3.autoGenerateMipmaps) {
          const biggestDimension = Math.max(source3.width, source3.height);
          source3.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
        }
        this._glTextures[source3.uid] = glTexture;
        source3.on("update", this.onSourceUpdate, this);
        source3.on("resize", this.onSourceUpdate, this);
        source3.on("styleChange", this.onStyleChange, this);
        source3.on("destroy", this.onSourceDestroy, this);
        source3.on("unload", this.onSourceUnload, this);
        this.managedTextures.push(source3);
        this.onSourceUpdate(source3);
        this.onStyleChange(source3);
        return glTexture;
      }
      onStyleChange(source3) {
        const gl = this._gl;
        const glTexture = this._glTextures[source3.uid];
        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
        this._boundTextures[this._activeTextureLocation] = source3;
        applyStyleParams(
          source3.style,
          gl,
          source3.mipLevelCount > 1,
          this._renderer.context.extensions.anisotropicFiltering,
          "texParameteri",
          gl.TEXTURE_2D
        );
      }
      onSourceUnload(source3) {
        const glTexture = this._glTextures[source3.uid];
        if (!glTexture)
          return;
        this.unbind(source3);
        this._glTextures[source3.uid] = null;
        this._gl.deleteTexture(glTexture.texture);
      }
      onSourceUpdate(source3) {
        const gl = this._gl;
        const glTexture = this.getGlSource(source3);
        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
        this._boundTextures[this._activeTextureLocation] = source3;
        if (this._uploads[source3.uploadMethodId]) {
          this._uploads[source3.uploadMethodId].upload(source3, glTexture, this._gl);
          if (source3.autoGenerateMipmaps && source3.mipLevelCount > 1) {
            gl.generateMipmap(glTexture.target);
          }
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source3.pixelWidth, source3.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
      }
      onSourceDestroy(source3) {
        source3.off("destroy", this.onSourceDestroy, this);
        source3.off("update", this.onSourceUpdate, this);
        source3.off("unload", this.onSourceUnload, this);
        this.managedTextures.splice(this.managedTextures.indexOf(source3), 1);
        this.onSourceUnload(source3);
      }
      _initSampler(style) {
        const gl = this._gl;
        const glSampler = this._gl.createSampler();
        this._glSamplers[style.resourceId] = glSampler;
        applyStyleParams(
          style,
          gl,
          this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,
          this._renderer.context.extensions.anisotropicFiltering,
          "samplerParameteri",
          glSampler
        );
        return this._glSamplers[style.resourceId];
      }
      _getGlSampler(sampler) {
        return this._glSamplers[sampler.resourceId] || this._initSampler(sampler);
      }
      getGlSource(source3) {
        return this._glTextures[source3.uid] || this._initSource(source3);
      }
      generateCanvas(texture) {
        const { pixels, width, height } = this.getPixels(texture);
        const canvas3 = settings.ADAPTER.createCanvas();
        canvas3.width = width;
        canvas3.height = height;
        const ctx3 = canvas3.getContext("2d");
        if (ctx3) {
          const imageData = ctx3.createImageData(width, height);
          imageData.data.set(pixels);
          ctx3.putImageData(imageData, 0, 0);
        }
        return canvas3;
      }
      getPixels(texture) {
        const resolution = texture.source.resolution;
        const frame = TEMP_RECT;
        frame.x = texture.frameX;
        frame.y = texture.frameY;
        frame.width = texture.frameWidth;
        frame.height = texture.frameHeight;
        const width = Math.max(Math.round(frame.width * resolution), 1);
        const height = Math.max(Math.round(frame.height * resolution), 1);
        const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
        const renderer = this._renderer;
        const renderTarget = renderer.renderTarget.getRenderTarget(texture);
        const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);
        const gl = renderer.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);
        gl.readPixels(
          Math.round(frame.x * resolution),
          Math.round(frame.y * resolution),
          width,
          height,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          pixels
        );
        if (false) {
          unpremultiplyAlpha(pixels);
        }
        return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };
      }
      destroy() {
        const writeable = this;
        writeable._renderer = null;
      }
    };
    GlTextureSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "texture"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs
var WebGLRenderer_exports = {};
__export(WebGLRenderer_exports, {
  WebGLRenderer: () => WebGLRenderer
});
var DefaultWebGLSystems, DefaultWebGLPipes, DefaultWebGLAdapters, systems2, renderPipes2, renderPipeAdaptors2, WebGLRenderer;
var init_WebGLRenderer = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs"() {
    init_Extensions();
    init_GlGraphicsAdaptor();
    init_GlMeshAdaptor();
    init_GlBatchAdaptor();
    init_AbstractRenderer();
    init_SharedSystems();
    init_types();
    init_GlBufferSystem();
    init_GlContextSystem();
    init_GlGeometrySystem();
    init_GlBackBufferSystem();
    init_GlColorMaskSystem();
    init_GlEncoderSystem();
    init_GlRenderTargetSystem();
    init_GlStencilSystem();
    init_GlShaderSystem();
    init_GlUniformGroupSystem();
    init_GlStateSystem();
    init_GlTextureSystem();
    DefaultWebGLSystems = [
      ...SharedSystems,
      GlBackBufferSystem,
      GlContextSystem,
      GlBufferSystem,
      GlTextureSystem,
      GlRenderTargetSystem,
      GlGeometrySystem,
      GlUniformGroupSystem,
      GlShaderSystem,
      GlEncoderSystem,
      GlStateSystem,
      GlStencilSystem,
      GlColorMaskSystem
    ];
    DefaultWebGLPipes = [...SharedRenderPipes];
    DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];
    systems2 = [];
    renderPipes2 = [];
    renderPipeAdaptors2 = [];
    extensions.handleByNamedList(ExtensionType.WebGLSystem, systems2);
    extensions.handleByNamedList(ExtensionType.WebGLPipes, renderPipes2);
    extensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors2);
    extensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);
    WebGLRenderer = class extends AbstractRenderer {
      constructor() {
        const systemConfig = {
          name: "webgl2",
          type: RendererType.WEBGL,
          systems: systems2,
          renderPipes: renderPipes2,
          renderPipeAdaptors: renderPipeAdaptors2
        };
        super(systemConfig);
      }
    };
  }
});

// ../../node_modules/.pnpm/eventemitter3@4.0.7/node_modules/eventemitter3/index.js
var require_eventemitter32 = __commonJS({
  "../../node_modules/.pnpm/eventemitter3@4.0.7/node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix2 = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix2 = false;
    }
    function EE(fn, context4, once) {
      this.fn = fn;
      this.context = context4;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context4, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context4 || emitter, once), evt = prefix2 ? prefix2 + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix2 ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i3 = 0, l3 = handlers.length, ee = new Array(l3); i3 < l3; i3++) {
        ee[i3] = handlers[i3].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i3;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i3 = 1, args = new Array(len - 1); i3 < len; i3++) {
          args[i3 - 1] = arguments[i3];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j3;
        for (i3 = 0; i3 < length; i3++) {
          if (listeners[i3].once)
            this.removeListener(event, listeners[i3].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i3].fn.call(listeners[i3].context);
              break;
            case 2:
              listeners[i3].fn.call(listeners[i3].context, a1);
              break;
            case 3:
              listeners[i3].fn.call(listeners[i3].context, a1, a2);
              break;
            case 4:
              listeners[i3].fn.call(listeners[i3].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j3 = 1, args = new Array(len - 1); j3 < len; j3++) {
                  args[j3 - 1] = arguments[j3];
                }
              listeners[i3].fn.apply(listeners[i3].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context4) {
      return addListener(this, event, fn, context4, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context4) {
      return addListener(this, event, fn, context4, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context4, once) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context4 || listeners.context === context4)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i3 = 0, events = [], length = listeners.length; i3 < length; i3++) {
          if (listeners[i3].fn !== fn || once && !listeners[i3].once || context4 && listeners[i3].context !== context4) {
            events.push(listeners[i3]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix2 ? prefix2 + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix2;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter2;
    }
  }
});

// ../../node_modules/.pnpm/punycode@1.4.1/node_modules/punycode/punycode.js
var require_punycode = __commonJS({
  "../../node_modules/.pnpm/punycode@1.4.1/node_modules/punycode/punycode.js"(exports2, module2) {
    (function(root) {
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key2;
      function error(type2) {
        throw new RangeError(errors[type2]);
      }
      function map5(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map5(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map5(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k3 = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k3 += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k3 + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output = [], inputLength = input.length, out3, i3 = 0, n2 = initialN, bias = initialBias, basic, j3, index, oldi, w2, k3, digit, t2, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j3 = 0; j3 < basic; ++j3) {
          if (input.charCodeAt(j3) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j3));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i3, w2 = 1, k3 = base; ; k3 += base) {
            if (index >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i3) / w2)) {
              error("overflow");
            }
            i3 += digit * w2;
            t2 = k3 <= bias ? tMin : k3 >= bias + tMax ? tMax : k3 - bias;
            if (digit < t2) {
              break;
            }
            baseMinusT = base - t2;
            if (w2 > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w2 *= baseMinusT;
          }
          out3 = output.length + 1;
          bias = adapt(i3 - oldi, out3, oldi == 0);
          if (floor(i3 / out3) > maxInt - n2) {
            error("overflow");
          }
          n2 += floor(i3 / out3);
          i3 %= out3;
          output.splice(i3++, 0, n2);
        }
        return ucs2encode(output);
      }
      function encode(input) {
        var n2, delta, handledCPCount, basicLength, bias, j3, m3, q2, k3, t2, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n2 = initialN;
        delta = 0;
        bias = initialBias;
        for (j3 = 0; j3 < inputLength; ++j3) {
          currentValue = input[j3];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m3 = maxInt, j3 = 0; j3 < inputLength; ++j3) {
            currentValue = input[j3];
            if (currentValue >= n2 && currentValue < m3) {
              m3 = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m3 - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m3 - n2) * handledCPCountPlusOne;
          n2 = m3;
          for (j3 = 0; j3 < inputLength; ++j3) {
            currentValue = input[j3];
            if (currentValue < n2 && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n2) {
              for (q2 = delta, k3 = base; ; k3 += base) {
                t2 = k3 <= bias ? tMin : k3 >= bias + tMax ? tMax : k3 - bias;
                if (q2 < t2) {
                  break;
                }
                qMinusT = q2 - t2;
                baseMinusT = base - t2;
                output.push(
                  stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
                );
                q2 = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q2, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n2;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      }
      punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "1.4.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define("punycode", function() {
          return punycode;
        });
      } else if (freeExports && freeModule) {
        if (module2.exports == freeExports) {
          freeModule.exports = punycode;
        } else {
          for (key2 in punycode) {
            punycode.hasOwnProperty(key2) && (freeExports[key2] = punycode[key2]);
          }
        }
      } else {
        root.punycode = punycode;
      }
    })(exports2);
  }
});

// ../../node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "../../node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../../node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "../../node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// ../../node_modules/.pnpm/has-proto@1.0.1/node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "../../node_modules/.pnpm/has-proto@1.0.1/node_modules/has-proto/index.js"(exports2, module2) {
    "use strict";
    var test = {
      foo: {}
    };
    var $Object = Object;
    module2.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
    };
  }
});

// ../../node_modules/.pnpm/function-bind@1.1.1/node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "../../node_modules/.pnpm/function-bind@1.1.1/node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i3 = 0; i3 < boundLength; i3++) {
        boundArgs.push("$" + i3);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// ../../node_modules/.pnpm/function-bind@1.1.1/node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../../node_modules/.pnpm/function-bind@1.1.1/node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// ../../node_modules/.pnpm/has@1.0.3/node_modules/has/src/index.js
var require_src = __commonJS({
  "../../node_modules/.pnpm/has@1.0.3/node_modules/has/src/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// ../../node_modules/.pnpm/get-intrinsic@1.2.1/node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "../../node_modules/.pnpm/get-intrinsic@1.2.1/node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e3) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e3) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x3) {
      return x3.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e3) {
        errorProto = getProto(getProto(e3));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i3 = 1, isOwn = true; i3 < parts.length; i3 += 1) {
        var part = parts[i3];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i3 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// ../../node_modules/.pnpm/call-bind@1.0.2/node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "../../node_modules/.pnpm/call-bind@1.0.2/node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e3) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind(originalFunction) {
      var func2 = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func2, "length");
        if (desc.configurable) {
          $defineProperty(
            func2,
            "length",
            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func2;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// ../../node_modules/.pnpm/call-bind@1.0.2/node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "../../node_modules/.pnpm/call-bind@1.0.2/node_modules/call-bind/callBound.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// (disabled):../../node_modules/.pnpm/object-inspect@1.12.3/node_modules/object-inspect/util.inspect
var require_util = __commonJS({
  "(disabled):../../node_modules/.pnpm/object-inspect@1.12.3/node_modules/object-inspect/util.inspect"() {
  }
});

// ../../node_modules/.pnpm/object-inspect@1.12.3/node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "../../node_modules/.pnpm/object-inspect@1.12.3/node_modules/object-inspect/index.js"(exports2, module2) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize3 = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O2) {
      return O2.__proto__;
    } : null);
    function addNumericSeparator(num2, str) {
      if (num2 === Infinity || num2 === -Infinity || num2 !== num2 || num2 && num2 > -1e3 && num2 < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num2 === "number") {
        var int = num2 < 0 ? -$floor(-num2) : $floor(num2);
        if (int !== num2) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module2.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i3 = 0; i3 < attrs.length; i3++) {
          s2 += " " + attrs[i3].name + "=" + wrapQuotes(quote(attrs[i3].value), "double", opts);
        }
        s2 += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s2 += "...";
        }
        s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s2;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key2) {
            mapParts.push(inspect(key2, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize3.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s2, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s2 + quoteChar;
    }
    function quote(s2) {
      return $replace.call(String(s2), /"/g, "&quot;");
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e3) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e3) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key2) {
      return key2 in this;
    };
    function has(obj, key2) {
      return hasOwn.call(obj, key2);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f3) {
      if (f3.name) {
        return f3.name;
      }
      var m3 = $match.call(functionToString.call(f3), /^function\s*([\w$]+)/);
      if (m3) {
        return m3[1];
      }
      return null;
    }
    function indexOf(xs, x3) {
      if (xs.indexOf) {
        return xs.indexOf(x3);
      }
      for (var i3 = 0, l3 = xs.length; i3 < l3; i3++) {
        if (xs[i3] === x3) {
          return i3;
        }
      }
      return -1;
    }
    function isMap(x3) {
      if (!mapSize3 || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        mapSize3.call(x3);
        try {
          setSize.call(x3);
        } catch (s2) {
          return true;
        }
        return x3 instanceof Map;
      } catch (e3) {
      }
      return false;
    }
    function isWeakMap(x3) {
      if (!weakMapHas || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x3, weakMapHas);
        try {
          weakSetHas.call(x3, weakSetHas);
        } catch (s2) {
          return true;
        }
        return x3 instanceof WeakMap;
      } catch (e3) {
      }
      return false;
    }
    function isWeakRef(x3) {
      if (!weakRefDeref || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x3);
        return true;
      } catch (e3) {
      }
      return false;
    }
    function isSet(x3) {
      if (!setSize || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        setSize.call(x3);
        try {
          mapSize3.call(x3);
        } catch (m3) {
          return true;
        }
        return x3 instanceof Set;
      } catch (e3) {
      }
      return false;
    }
    function isWeakSet(x3) {
      if (!weakSetHas || !x3 || typeof x3 !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x3, weakSetHas);
        try {
          weakMapHas.call(x3, weakMapHas);
        } catch (s2) {
          return true;
        }
        return x3 instanceof WeakSet;
      } catch (e3) {
      }
      return false;
    }
    function isElement(x3) {
      if (!x3 || typeof x3 !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x3 instanceof HTMLElement) {
        return true;
      }
      return typeof x3.nodeName === "string" && typeof x3.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s2 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s2, "single", opts);
    }
    function lowbyte(c2) {
      var n2 = c2.charCodeAt(0);
      var x3 = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n2];
      if (x3) {
        return "\\" + x3;
      }
      return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type2) {
      return type2 + " { ? }";
    }
    function collectionOf(type2, size3, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type2 + " (" + size3 + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i3 = 0; i3 < xs.length; i3++) {
        if (indexOf(xs[i3], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i3 = 0; i3 < obj.length; i3++) {
          xs[i3] = has(obj, i3) ? inspect(obj[i3], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k3 = 0; k3 < syms.length; k3++) {
          symMap["$" + syms[k3]] = syms[k3];
        }
      }
      for (var key2 in obj) {
        if (!has(obj, key2)) {
          continue;
        }
        if (isArr && String(Number(key2)) === key2 && key2 < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key2] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key2)) {
          xs.push(inspect(key2, obj) + ": " + inspect(obj[key2], obj));
        } else {
          xs.push(key2 + ": " + inspect(obj[key2], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j3 = 0; j3 < syms.length; j3++) {
          if (isEnumerable.call(obj, syms[j3])) {
            xs.push("[" + inspect(syms[j3]) + "]: " + inspect(obj[syms[j3]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// ../../node_modules/.pnpm/side-channel@1.0.4/node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "../../node_modules/.pnpm/side-channel@1.0.4/node_modules/side-channel/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key2) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key2) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key2) {
      var node = listGetNode(objects, key2);
      return node && node.value;
    };
    var listSet = function(objects, key2, value) {
      var node = listGetNode(objects, key2);
      if (node) {
        node.value = value;
      } else {
        objects.next = {
          // eslint-disable-line no-param-reassign
          key: key2,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key2) {
      return !!listGetNode(objects, key2);
    };
    module2.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key2) {
          if (!channel.has(key2)) {
            throw new $TypeError("Side channel does not contain " + inspect(key2));
          }
        },
        get: function(key2) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key2);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key2);
            }
          } else {
            if ($o) {
              return listGet($o, key2);
            }
          }
        },
        has: function(key2) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key2);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key2);
            }
          } else {
            if ($o) {
              return listHas($o, key2);
            }
          }
          return false;
        },
        set: function(key2, value) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key2, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key2, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key2, value);
          }
        }
      };
      return channel;
    };
  }
});

// ../../node_modules/.pnpm/qs@6.11.2/node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "../../node_modules/.pnpm/qs@6.11.2/node_modules/qs/lib/formats.js"(exports2, module2) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module2.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// ../../node_modules/.pnpm/qs@6.11.2/node_modules/qs/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/qs@6.11.2/node_modules/qs/lib/utils.js"(exports2, module2) {
    "use strict";
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i3 = 0; i3 < 256; ++i3) {
        array.push("%" + ((i3 < 16 ? "0" : "") + i3.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j3 = 0; j3 < obj.length; ++j3) {
            if (typeof obj[j3] !== "undefined") {
              compacted.push(obj[j3]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source3, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i3 = 0; i3 < source3.length; ++i3) {
        if (typeof source3[i3] !== "undefined") {
          obj[i3] = source3[i3];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source3, options) {
      if (!source3) {
        return target;
      }
      if (typeof source3 !== "object") {
        if (isArray(target)) {
          target.push(source3);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source3)) {
            target[source3] = true;
          }
        } else {
          return [target, source3];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source3);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source3)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source3)) {
        source3.forEach(function(item, i3) {
          if (has.call(target, i3)) {
            var targetItem = target[i3];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i3] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i3] = item;
          }
        });
        return target;
      }
      return Object.keys(source3).reduce(function(acc, key2) {
        var value = source3[key2];
        if (has.call(acc, key2)) {
          acc[key2] = merge2(acc[key2], value, options);
        } else {
          acc[key2] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source3) {
      return Object.keys(source3).reduce(function(acc, key2) {
        acc[key2] = source3[key2];
        return acc;
      }, target);
    };
    var decode = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e3) {
        return strWithoutPlus;
      }
    };
    var encode = function encode2(str, defaultEncoder, charset, kind, format3) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out3 = "";
      for (var i3 = 0; i3 < string.length; ++i3) {
        var c2 = string.charCodeAt(i3);
        if (c2 === 45 || c2 === 46 || c2 === 95 || c2 === 126 || c2 >= 48 && c2 <= 57 || c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || format3 === formats.RFC1738 && (c2 === 40 || c2 === 41)) {
          out3 += string.charAt(i3);
          continue;
        }
        if (c2 < 128) {
          out3 = out3 + hexTable[c2];
          continue;
        }
        if (c2 < 2048) {
          out3 = out3 + (hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63]);
          continue;
        }
        if (c2 < 55296 || c2 >= 57344) {
          out3 = out3 + (hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63]);
          continue;
        }
        i3 += 1;
        c2 = 65536 + ((c2 & 1023) << 10 | string.charCodeAt(i3) & 1023);
        out3 += hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
      }
      return out3;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i3 = 0; i3 < queue.length; ++i3) {
        var item = queue[i3];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j3 = 0; j3 < keys.length; ++j3) {
          var key2 = keys[j3];
          var val = obj[key2];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key2 });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a2, b2) {
      return [].concat(a2, b2);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i3 = 0; i3 < val.length; i3 += 1) {
          mapped.push(fn(val[i3]));
        }
        return mapped;
      }
      return fn(val);
    };
    module2.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// ../../node_modules/.pnpm/qs@6.11.2/node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/.pnpm/qs@6.11.2/node_modules/qs/lib/stringify.js"(exports2, module2) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix2) {
        return prefix2 + "[]";
      },
      comma: "comma",
      indices: function indices(prefix2, key2) {
        return prefix2 + "[" + key2 + "]";
      },
      repeat: function repeat(prefix2) {
        return prefix2;
      }
    };
    var isArray = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v3) {
      return typeof v3 === "string" || typeof v3 === "number" || typeof v3 === "boolean" || typeof v3 === "symbol" || typeof v3 === "bigint";
    };
    var sentinel = {};
    var stringify = function stringify2(object, prefix2, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format3, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix2, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix2, defaults.encoder, charset, "key", format3) : prefix2;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix2 : encoder(prefix2, defaults.encoder, charset, "key", format3);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format3))];
        }
        return [formatter(prefix2) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix2 + "[]" : prefix2;
      for (var j3 = 0; j3 < objKeys.length; ++j3) {
        var key2 = objKeys[j3];
        var value = typeof key2 === "object" && typeof key2.value !== "undefined" ? key2.value : obj[key2];
        if (skipNulls && value === null) {
          continue;
        }
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key2) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key2 : "[" + key2 + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify2(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          strictNullHandling,
          skipNulls,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder,
          filter,
          sort,
          allowDots,
          serializeDate,
          format3,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format3 = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format3 = opts.format;
      }
      var formatter = formats.formatters[format3];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format: format3,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i3 = 0; i3 < objKeys.length; ++i3) {
        var key2 = objKeys[i3];
        if (options.skipNulls && obj[key2] === null) {
          continue;
        }
        pushToArray(keys, stringify(
          obj[key2],
          key2,
          generateArrayPrefix,
          commaRoundTrip,
          options.strictNullHandling,
          options.skipNulls,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix2 = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix2 += "utf8=%26%2310003%3B&";
        } else {
          prefix2 += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix2 + joined : "";
    };
  }
});

// ../../node_modules/.pnpm/qs@6.11.2/node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/.pnpm/qs@6.11.2/node_modules/qs/lib/parse.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = { __proto__: null };
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i3;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i3 = 0; i3 < parts.length; ++i3) {
          if (parts[i3].indexOf("utf8=") === 0) {
            if (parts[i3] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i3] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i3;
            i3 = parts.length;
          }
        }
      }
      for (i3 = 0; i3 < parts.length; ++i3) {
        if (i3 === skipIndex) {
          continue;
        }
        var part = parts[i3];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key2, val;
        if (pos === -1) {
          key2 = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key2 = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        if (has.call(obj, key2)) {
          obj[key2] = utils.combine(obj[key2], val);
        } else {
          obj[key2] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i3 = chain.length - 1; i3 >= 0; --i3) {
        var obj;
        var root = chain[i3];
        if (root === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var index = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key2 = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key2);
      var parent = segment ? key2.slice(0, segment.index) : key2;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i3 = 0;
      while (options.depth > 0 && (segment = child.exec(key2)) !== null && i3 < options.depth) {
        i3 += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        keys.push("[" + key2.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i3 = 0; i3 < keys.length; ++i3) {
        var key2 = keys[i3];
        var newObj = parseKeys(key2, tempObj[key2], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// ../../node_modules/.pnpm/qs@6.11.2/node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/qs@6.11.2/node_modules/qs/lib/index.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify();
    var parse2 = require_parse();
    var formats = require_formats();
    module2.exports = {
      formats,
      parse: parse2,
      stringify
    };
  }
});

// ../../node_modules/.pnpm/url@0.11.3/node_modules/url/url.js
var require_url = __commonJS({
  "../../node_modules/.pnpm/url@0.11.3/node_modules/url/url.js"(exports2) {
    "use strict";
    var punycode = require_punycode();
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.host = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.query = null;
      this.pathname = null;
      this.path = null;
      this.href = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/;
    var delims = [
      "<",
      ">",
      '"',
      "`",
      " ",
      "\r",
      "\n",
      "	"
    ];
    var unwise = [
      "{",
      "}",
      "|",
      "\\",
      "^",
      "`"
    ].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = [
      "%",
      "/",
      "?",
      ";",
      "#"
    ].concat(autoEscape);
    var hostEndingChars = [
      "/",
      "?",
      "#"
    ];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var unsafeProtocol = {
      javascript: true,
      "javascript:": true
    };
    var hostlessProtocol = {
      javascript: true,
      "javascript:": true
    };
    var slashedProtocol = {
      http: true,
      https: true,
      ftp: true,
      gopher: true,
      file: true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    var querystring = require_lib();
    function urlParse(url2, parseQueryString, slashesDenoteHost) {
      if (url2 && typeof url2 === "object" && url2 instanceof Url) {
        return url2;
      }
      var u3 = new Url();
      u3.parse(url2, parseQueryString, slashesDenoteHost);
      return u3;
    }
    Url.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {
      if (typeof url2 !== "string") {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url2);
      }
      var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, "/");
      url2 = uSplit.join(splitter);
      var rest = url2;
      rest = rest.trim();
      if (!slashesDenoteHost && url2.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.path = rest;
          this.href = rest;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = "";
            this.query = {};
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
        var slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (var i3 = 0; i3 < hostEndingChars.length; i3++) {
          var hec = rest.indexOf(hostEndingChars[i3]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }
        hostEnd = -1;
        for (var i3 = 0; i3 < nonHostChars.length; i3++) {
          var hec = rest.indexOf(nonHostChars[i3]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost();
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i3 = 0, l3 = hostparts.length; i3 < l3; i3++) {
            var part = hostparts[i3];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j3 = 0, k3 = part.length; j3 < k3; j3++) {
                if (part.charCodeAt(j3) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j3];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i3);
                var notHost = hostparts.slice(i3 + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = "/" + notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        } else {
          this.hostname = this.hostname.toLowerCase();
        }
        if (!ipv6Hostname) {
          this.hostname = punycode.toASCII(this.hostname);
        }
        var p3 = this.port ? ":" + this.port : "";
        var h2 = this.hostname || "";
        this.host = h2 + p3;
        this.href += this.host;
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest[0] !== "/") {
            rest = "/" + rest;
          }
        }
      }
      if (!unsafeProtocol[lowerProto]) {
        for (var i3 = 0, l3 = autoEscape.length; i3 < l3; i3++) {
          var ae = autoEscape[i3];
          if (rest.indexOf(ae) === -1) {
            continue;
          }
          var esc = encodeURIComponent(ae);
          if (esc === ae) {
            esc = escape(ae);
          }
          rest = rest.split(ae).join(esc);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "/";
      }
      if (this.pathname || this.search) {
        var p3 = this.pathname || "";
        var s2 = this.search || "";
        this.path = p3 + s2;
      }
      this.href = this.format();
      return this;
    };
    function urlFormat(obj) {
      if (typeof obj === "string") {
        obj = urlParse(obj);
      }
      if (!(obj instanceof Url)) {
        return Url.prototype.format.call(obj);
      }
      return obj.format();
    }
    Url.prototype.format = function() {
      var auth = this.auth || "";
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
      }
      var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
        if (this.port) {
          host += ":" + this.port;
        }
      }
      if (this.query && typeof this.query === "object" && Object.keys(this.query).length) {
        query = querystring.stringify(this.query, {
          arrayFormat: "repeat",
          addQueryPrefix: false
        });
      }
      var search = this.search || query && "?" + query || "";
      if (protocol && protocol.substr(-1) !== ":") {
        protocol += ":";
      }
      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname.charAt(0) !== "/") {
          pathname = "/" + pathname;
        }
      } else if (!host) {
        host = "";
      }
      if (hash && hash.charAt(0) !== "#") {
        hash = "#" + hash;
      }
      if (search && search.charAt(0) !== "?") {
        search = "?" + search;
      }
      pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
      search = search.replace("#", "%23");
      return protocol + host + pathname + search + hash;
    };
    function urlResolve(source3, relative) {
      return urlParse(source3, false, true).resolve(relative);
    }
    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    function urlResolveObject(source3, relative) {
      if (!source3) {
        return relative;
      }
      return urlParse(source3, false, true).resolveObject(relative);
    }
    Url.prototype.resolveObject = function(relative) {
      if (typeof relative === "string") {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }
      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }
      result.hash = relative.hash;
      if (relative.href === "") {
        result.href = result.format();
        return result;
      }
      if (relative.slashes && !relative.protocol) {
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== "protocol") {
            result[rkey] = relative[rkey];
          }
        }
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.pathname = "/";
          result.path = result.pathname;
        }
        result.href = result.format();
        return result;
      }
      if (relative.protocol && relative.protocol !== result.protocol) {
        if (!slashedProtocol[relative.protocol]) {
          var keys = Object.keys(relative);
          for (var v3 = 0; v3 < keys.length; v3++) {
            var k3 = keys[v3];
            result[k3] = relative[k3];
          }
          result.href = result.format();
          return result;
        }
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || "").split("/");
          while (relPath.length && !(relative.host = relPath.shift())) {
          }
          if (!relative.host) {
            relative.host = "";
          }
          if (!relative.hostname) {
            relative.hostname = "";
          }
          if (relPath[0] !== "") {
            relPath.unshift("");
          }
          if (relPath.length < 2) {
            relPath.unshift("");
          }
          result.pathname = relPath.join("/");
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        if (result.pathname || result.search) {
          var p3 = result.pathname || "";
          var s2 = result.search || "";
          result.path = p3 + s2;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }
      var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
      if (psychotic) {
        result.hostname = "";
        result.port = null;
        if (result.host) {
          if (srcPath[0] === "") {
            srcPath[0] = result.host;
          } else {
            srcPath.unshift(result.host);
          }
        }
        result.host = "";
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === "") {
              relPath[0] = relative.host;
            } else {
              relPath.unshift(relative.host);
            }
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      if (isRelAbs) {
        result.host = relative.host || relative.host === "" ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath) {
          srcPath = [];
        }
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (relative.search != null) {
        if (psychotic) {
          result.host = srcPath.shift();
          result.hostname = result.host;
          var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.hostname = authInHost.shift();
            result.host = result.hostname;
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        if (result.pathname !== null || result.search !== null) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.href = result.format();
        return result;
      }
      if (!srcPath.length) {
        result.pathname = null;
        if (result.search) {
          result.path = "/" + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
      var up = 0;
      for (var i3 = srcPath.length; i3 >= 0; i3--) {
        last = srcPath[i3];
        if (last === ".") {
          srcPath.splice(i3, 1);
        } else if (last === "..") {
          srcPath.splice(i3, 1);
          up++;
        } else if (up) {
          srcPath.splice(i3, 1);
          up--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
      if (psychotic) {
        result.hostname = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        result.host = result.hostname;
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.hostname = authInHost.shift();
          result.host = result.hostname;
        }
      }
      mustEndAbs = mustEndAbs || result.host && srcPath.length;
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
      }
      if (srcPath.length > 0) {
        result.pathname = srcPath.join("/");
      } else {
        result.pathname = null;
        result.path = null;
      }
      if (result.pathname !== null || result.search !== null) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };
    Url.prototype.parseHost = function() {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    exports2.parse = urlParse;
    exports2.resolve = urlResolve;
    exports2.resolveObject = urlResolveObject;
    exports2.format = urlFormat;
    exports2.Url = Url;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/point/Point.mjs
var Point3, tempPoint2;
var init_Point2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/point/Point.mjs"() {
    Point3 = class _Point {
      /**
       * Creates a new `Point`
       * @param {number} [x=0] - position of the point on the x axis
       * @param {number} [y=0] - position of the point on the y axis
       */
      constructor(x3 = 0, y2 = 0) {
        this.x = 0;
        this.y = 0;
        this.x = x3;
        this.y = y2;
      }
      /**
       * Creates a clone of this point
       * @returns A clone of this point
       */
      clone() {
        return new _Point(this.x, this.y);
      }
      /**
       * Copies `x` and `y` from the given point into this point
       * @param p - The point to copy from
       * @returns The point instance itself
       */
      copyFrom(p3) {
        this.set(p3.x, p3.y);
        return this;
      }
      /**
       * Copies this point's x and y into the given point (`p`).
       * @param p - The point to copy to. Can be any of type that is or extends `PointData`
       * @returns The point (`p`) with values updated
       */
      copyTo(p3) {
        p3.set(this.x, this.y);
        return p3;
      }
      /**
       * Accepts another point (`p`) and returns `true` if the given point is equal to this point
       * @param p - The point to check
       * @returns Returns `true` if both `x` and `y` are equal
       */
      equals(p3) {
        return p3.x === this.x && p3.y === this.y;
      }
      /**
       * Sets the point to a new `x` and `y` position.
       * If `y` is omitted, both `x` and `y` will be set to `x`.
       * @param {number} [x=0] - position of the point on the `x` axis
       * @param {number} [y=x] - position of the point on the `y` axis
       * @returns The point instance itself
       */
      set(x3 = 0, y2 = x3) {
        this.x = x3;
        this.y = y2;
        return this;
      }
      toString() {
        return `[@pixi/math:Point x=${this.x} y=${this.y}]`;
      }
      static get shared() {
        tempPoint2.x = 0;
        tempPoint2.y = 0;
        return tempPoint2;
      }
    };
    tempPoint2 = new Point3();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/FederatedEvent.mjs
var FederatedEvent2;
var init_FederatedEvent2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/FederatedEvent.mjs"() {
    init_Point2();
    FederatedEvent2 = class _FederatedEvent {
      /**
       * @param manager - The event boundary which manages this event. Propagation can only occur
       *  within the boundary's jurisdiction.
       */
      constructor(manager) {
        this.bubbles = true;
        this.cancelBubble = true;
        this.cancelable = false;
        this.composed = false;
        this.defaultPrevented = false;
        this.eventPhase = _FederatedEvent.prototype.NONE;
        this.propagationStopped = false;
        this.propagationImmediatelyStopped = false;
        this.layer = new Point3();
        this.page = new Point3();
        this.NONE = 0;
        this.CAPTURING_PHASE = 1;
        this.AT_TARGET = 2;
        this.BUBBLING_PHASE = 3;
        this.manager = manager;
      }
      /** @readonly */
      get layerX() {
        return this.layer.x;
      }
      /** @readonly */
      get layerY() {
        return this.layer.y;
      }
      /** @readonly */
      get pageX() {
        return this.page.x;
      }
      /** @readonly */
      get pageY() {
        return this.page.y;
      }
      /**
       * Fallback for the deprecated @code{InteractionEvent.data}.
       * @deprecated since 7.0.0
       */
      get data() {
        return this;
      }
      /** The propagation path for this event. Alias for {@link EventBoundary.propagationPath}. */
      composedPath() {
        if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
          this.path = this.target ? this.manager.propagationPath(this.target) : [];
        }
        return this.path;
      }
      /**
       * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw an {@code Error}.
       * @deprecated
       * @param _type
       * @param _bubbles
       * @param _cancelable
       */
      initEvent(_type, _bubbles, _cancelable) {
        throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
      }
      /**
       * Unimplemented method included for implementing the DOM interface {@code UIEvent}. It will throw an {@code Error}.
       * @deprecated
       * @param _typeArg
       * @param _bubblesArg
       * @param _cancelableArg
       * @param _viewArg
       * @param _detailArg
       */
      initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
        throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
      }
      /** Prevent default behavior of PixiJS and the user agent. */
      preventDefault() {
        if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
          this.nativeEvent.preventDefault();
        }
        this.defaultPrevented = true;
      }
      /**
       * Stop this event from propagating to any addition listeners, including on the
       * {@link FederatedEventTarget.currentTarget currentTarget} and also the following
       * event targets on the propagation path.
       */
      stopImmediatePropagation() {
        this.propagationImmediatelyStopped = true;
      }
      /**
       * Stop this event from propagating to the next {@link FederatedEventTarget}. The rest of the listeners
       * on the {@link FederatedEventTarget.currentTarget currentTarget} will still be notified.
       */
      stopPropagation() {
        this.propagationStopped = true;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/extensions/Extensions.mjs
var ExtensionType3, normalizeExtension3, normalizeExtensionPriority2, extensions3;
var init_Extensions2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/extensions/Extensions.mjs"() {
    ExtensionType3 = /* @__PURE__ */ ((ExtensionType22) => {
      ExtensionType22["Renderer"] = "renderer";
      ExtensionType22["Application"] = "application";
      ExtensionType22["WebGLPipes"] = "webgl-pipes";
      ExtensionType22["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";
      ExtensionType22["WebGLSystem"] = "webgl-system";
      ExtensionType22["WebGPUPipes"] = "webgpu-pipes";
      ExtensionType22["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";
      ExtensionType22["WebGPUSystem"] = "webgpu-system";
      ExtensionType22["CanvasSystem"] = "canvas-system";
      ExtensionType22["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";
      ExtensionType22["CanvasPipes"] = "canvas-pipes";
      ExtensionType22["Asset"] = "asset";
      ExtensionType22["LoadParser"] = "load-parser";
      ExtensionType22["ResolveParser"] = "resolve-parser";
      ExtensionType22["CacheParser"] = "cache-parser";
      ExtensionType22["DetectionParser"] = "detection-parser";
      ExtensionType22["MaskEffect"] = "mask-effect";
      ExtensionType22["BlendMode"] = "blend-mode";
      ExtensionType22["TextureSource"] = "texture-source";
      return ExtensionType22;
    })(ExtensionType3 || {});
    normalizeExtension3 = (ext) => {
      if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
        if (!ext.extension) {
          throw new Error("Extension class must have an extension object");
        }
        const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
        ext = { ...metadata, ref: ext };
      }
      if (typeof ext === "object") {
        ext = { ...ext };
      } else {
        throw new Error("Invalid extension type");
      }
      if (typeof ext.type === "string") {
        ext.type = [ext.type];
      }
      return ext;
    };
    normalizeExtensionPriority2 = (ext, defaultPriority) => normalizeExtension3(ext).priority ?? defaultPriority;
    extensions3 = {
      /** @ignore */
      _addHandlers: {},
      /** @ignore */
      _removeHandlers: {},
      /** @ignore */
      _queue: {},
      /**
       * Remove extensions from PixiJS.
       * @param extensions - Extensions to be removed.
       * @returns {extensions} For chaining.
       */
      remove(...extensions22) {
        extensions22.map(normalizeExtension3).forEach((ext) => {
          ext.type.forEach((type2) => this._removeHandlers[type2]?.(ext));
        });
        return this;
      },
      /**
       * Register new extensions with PixiJS.
       * @param extensions - The spread of extensions to add to PixiJS.
       * @returns {extensions} For chaining.
       */
      add(...extensions22) {
        extensions22.map(normalizeExtension3).forEach((ext) => {
          ext.type.forEach((type2) => {
            const handlers = this._addHandlers;
            const queue = this._queue;
            if (!handlers[type2]) {
              queue[type2] = queue[type2] || [];
              queue[type2].push(ext);
            } else {
              handlers[type2](ext);
            }
          });
        });
        return this;
      },
      /**
       * Internal method to handle extensions by name.
       * @param type - The extension type.
       * @param onAdd  - Function for handling when extensions are added/registered passes {@link ExtensionFormat}.
       * @param onRemove  - Function for handling when extensions are removed/unregistered passes {@link ExtensionFormat}.
       * @returns {extensions} For chaining.
       */
      handle(type2, onAdd, onRemove) {
        const addHandlers = this._addHandlers;
        const removeHandlers = this._removeHandlers;
        if (addHandlers[type2] || removeHandlers[type2]) {
          throw new Error(`Extension type ${type2} already has a handler`);
        }
        addHandlers[type2] = onAdd;
        removeHandlers[type2] = onRemove;
        const queue = this._queue;
        if (queue[type2]) {
          queue[type2].forEach((ext) => onAdd(ext));
          delete queue[type2];
        }
        return this;
      },
      /**
       * Handle a type, but using a map by `name` property.
       * @param type - Type of extension to handle.
       * @param map - The object map of named extensions.
       * @returns {extensions} For chaining.
       */
      handleByMap(type2, map5) {
        return this.handle(
          type2,
          (extension) => {
            map5[extension.name] = extension.ref;
          },
          (extension) => {
            delete map5[extension.name];
          }
        );
      },
      /**
       * Handle a type, but using a list of extensions with a `name` property.
       * @param type - Type of extension to handle.
       * @param map - The array of named extensions.
       * @param defaultPriority - Fallback priority if none is defined.
       * @returns {extensions} For chaining.
       */
      handleByNamedList(type2, map5, defaultPriority = -1) {
        return this.handle(
          type2,
          (extension) => {
            const index = map5.findIndex((item) => item.name === extension.name);
            if (index >= 0)
              return;
            map5.push({ name: extension.name, value: extension.ref });
            map5.sort((a2, b2) => normalizeExtensionPriority2(b2.value, defaultPriority) - normalizeExtensionPriority2(a2.value, defaultPriority));
          },
          (extension) => {
            const index = map5.findIndex((item) => item.name === extension.name);
            if (index !== -1) {
              map5.splice(index, 1);
            }
          }
        );
      },
      /**
       * Handle a type, but using a list of extensions.
       * @param type - Type of extension to handle.
       * @param list - The list of extensions.
       * @param defaultPriority - The default priority to use if none is specified.
       * @returns {extensions} For chaining.
       */
      handleByList(type2, list, defaultPriority = -1) {
        return this.handle(
          type2,
          (extension) => {
            if (list.includes(extension.ref)) {
              return;
            }
            list.push(extension.ref);
            list.sort((a2, b2) => normalizeExtensionPriority2(b2, defaultPriority) - normalizeExtensionPriority2(a2, defaultPriority));
          },
          (extension) => {
            const index = list.indexOf(extension.ref);
            if (index !== -1) {
              list.splice(index, 1);
            }
          }
        );
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/color/Color.mjs
var _Color3, Color3;
var init_Color2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/color/Color.mjs"() {
    init_colord();
    init_names();
    k([names_default]);
    _Color3 = class {
      /**
       * @param {ColorSource} value - Optional value to use, if not provided, white is used.
       */
      constructor(value = 16777215) {
        this._value = null;
        this._components = new Float32Array(4);
        this._components.fill(1);
        this._int = 16777215;
        this.value = value;
      }
      /** Get red component (0 - 1) */
      get red() {
        return this._components[0];
      }
      /** Get green component (0 - 1) */
      get green() {
        return this._components[1];
      }
      /** Get blue component (0 - 1) */
      get blue() {
        return this._components[2];
      }
      /** Get alpha component (0 - 1) */
      get alpha() {
        return this._components[3];
      }
      /**
       * Set the value, suitable for chaining
       * @param value
       * @see Color.value
       */
      setValue(value) {
        this.value = value;
        return this;
      }
      /**
       * The current color source.
       *
       * When setting:
       * - Setting to an instance of `Color` will copy its color source and components.
       * - Otherwise, `Color` will try to normalize the color source and set the components.
       *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.
       *
       * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter
       * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.
       *
       * When getting:
       * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},
       *   {@link Color.premultiply premultiply} or {@link Color.round round}).
       * - Otherwise, the color source used when setting is returned.
       * @type {ColorSource}
       */
      set value(value) {
        if (value instanceof _Color3) {
          this._value = this._cloneSource(value._value);
          this._int = value._int;
          this._components.set(value._components);
        } else if (value === null) {
          throw new Error("Cannot set Color#value to null");
        } else if (this._value === null || !this._isSourceEqual(this._value, value)) {
          this._normalize(value);
          this._value = this._cloneSource(value);
        }
      }
      get value() {
        return this._value;
      }
      /**
       * Copy a color source internally.
       * @param value - Color source
       */
      _cloneSource(value) {
        if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
          return value;
        } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
          return value.slice(0);
        } else if (typeof value === "object" && value !== null) {
          return { ...value };
        }
        return value;
      }
      /**
       * Equality check for color sources.
       * @param value1 - First color source
       * @param value2 - Second color source
       * @returns `true` if the color sources are equal, `false` otherwise.
       */
      _isSourceEqual(value1, value2) {
        const type1 = typeof value1;
        const type2 = typeof value2;
        if (type1 !== type2) {
          return false;
        } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
          return value1 === value2;
        } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
          if (value1.length !== value2.length) {
            return false;
          }
          return value1.every((v3, i3) => v3 === value2[i3]);
        } else if (value1 !== null && value2 !== null) {
          const keys1 = Object.keys(value1);
          const keys2 = Object.keys(value2);
          if (keys1.length !== keys2.length) {
            return false;
          }
          return keys1.every((key2) => value1[key2] === value2[key2]);
        }
        return value1 === value2;
      }
      /**
       * Convert to a RGBA color object.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }
       */
      toRgba() {
        const [r2, g2, b2, a2] = this._components;
        return { r: r2, g: g2, b: b2, a: a2 };
      }
      /**
       * Convert to a RGB color object.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }
       */
      toRgb() {
        const [r2, g2, b2] = this._components;
        return { r: r2, g: g2, b: b2 };
      }
      /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */
      toRgbaString() {
        const [r2, g2, b2] = this.toUint8RgbArray();
        return `rgba(${r2},${g2},${b2},${this.alpha})`;
      }
      toUint8RgbArray(out3) {
        const [r2, g2, b2] = this._components;
        if (!this._arrayRgb) {
          this._arrayRgb = [];
        }
        out3 = out3 || this._arrayRgb;
        out3[0] = Math.round(r2 * 255);
        out3[1] = Math.round(g2 * 255);
        out3[2] = Math.round(b2 * 255);
        return out3;
      }
      toArray(out3) {
        if (!this._arrayRgba) {
          this._arrayRgba = [];
        }
        out3 = out3 || this._arrayRgba;
        const [r2, g2, b2, a2] = this._components;
        out3[0] = r2;
        out3[1] = g2;
        out3[2] = b2;
        out3[3] = a2;
        return out3;
      }
      toRgbArray(out3) {
        if (!this._arrayRgb) {
          this._arrayRgb = [];
        }
        out3 = out3 || this._arrayRgb;
        const [r2, g2, b2] = this._components;
        out3[0] = r2;
        out3[1] = g2;
        out3[2] = b2;
        return out3;
      }
      /**
       * Convert to a hexadecimal number.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toNumber(); // returns 16777215
       */
      toNumber() {
        return this._int;
      }
      /**
       * Convert to a BGR number
       * @example
       * import { Color } from 'pixi.js';
       * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff
       */
      toBgrNumber() {
        const [r2, g2, b2] = this.toUint8RgbArray();
        return (b2 << 16) + (g2 << 8) + r2;
      }
      /**
       * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
       * @example
       * import { Color } from 'pixi.js';
       * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
       * @returns {number} - The color as a number in little endian format.
       */
      toLittleEndianNumber() {
        const value = this._int;
        return (value >> 16) + (value & 65280) + ((value & 255) << 16);
      }
      /**
       * Multiply with another color. This action is destructive, and will
       * override the previous `value` property to be `null`.
       * @param {ColorSource} value - The color to multiply by.
       */
      multiply(value) {
        const [r2, g2, b2, a2] = _Color3._temp.setValue(value)._components;
        this._components[0] *= r2;
        this._components[1] *= g2;
        this._components[2] *= b2;
        this._components[3] *= a2;
        this._refreshInt();
        this._value = null;
        return this;
      }
      /**
       * Converts color to a premultiplied alpha format. This action is destructive, and will
       * override the previous `value` property to be `null`.
       * @param alpha - The alpha to multiply by.
       * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
       * @returns {Color} - Itself.
       */
      premultiply(alpha, applyToRGB = true) {
        if (applyToRGB) {
          this._components[0] *= alpha;
          this._components[1] *= alpha;
          this._components[2] *= alpha;
        }
        this._components[3] = alpha;
        this._refreshInt();
        this._value = null;
        return this;
      }
      /**
       * Premultiplies alpha with current color.
       * @param {number} alpha - The alpha to multiply by.
       * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
       * @returns {number} tint multiplied by alpha
       */
      toPremultiplied(alpha, applyToRGB = true) {
        if (alpha === 1) {
          return (255 << 24) + this._int;
        }
        if (alpha === 0) {
          return applyToRGB ? 0 : this._int;
        }
        let r2 = this._int >> 16 & 255;
        let g2 = this._int >> 8 & 255;
        let b2 = this._int & 255;
        if (applyToRGB) {
          r2 = r2 * alpha + 0.5 | 0;
          g2 = g2 * alpha + 0.5 | 0;
          b2 = b2 * alpha + 0.5 | 0;
        }
        return (alpha * 255 << 24) + (r2 << 16) + (g2 << 8) + b2;
      }
      /**
       * Convert to a hexidecimal string.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toHex(); // returns "#ffffff"
       */
      toHex() {
        const hexString = this._int.toString(16);
        return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
      }
      /**
       * Convert to a hexidecimal string with alpha.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toHexa(); // returns "#ffffffff"
       */
      toHexa() {
        const alphaValue = Math.round(this._components[3] * 255);
        const alphaString = alphaValue.toString(16);
        return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
      }
      /**
       * Set alpha, suitable for chaining.
       * @param alpha
       */
      setAlpha(alpha) {
        this._components[3] = this._clamp(alpha);
        return this;
      }
      /**
       * Normalize the input value into rgba
       * @param value - Input value
       */
      _normalize(value) {
        let r2;
        let g2;
        let b2;
        let a2;
        if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
          const int = value;
          r2 = (int >> 16 & 255) / 255;
          g2 = (int >> 8 & 255) / 255;
          b2 = (int & 255) / 255;
          a2 = 1;
        } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
          value = this._clamp(value);
          [r2, g2, b2, a2 = 1] = value;
        } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
          value = this._clamp(value, 0, 255);
          [r2, g2, b2, a2 = 255] = value;
          r2 /= 255;
          g2 /= 255;
          b2 /= 255;
          a2 /= 255;
        } else if (typeof value === "string" || typeof value === "object") {
          if (typeof value === "string") {
            const match = _Color3.HEX_PATTERN.exec(value);
            if (match) {
              value = `#${match[2]}`;
            }
          }
          const color = w(value);
          if (color.isValid()) {
            ({ r: r2, g: g2, b: b2, a: a2 } = color.rgba);
            r2 /= 255;
            g2 /= 255;
            b2 /= 255;
          }
        }
        if (r2 !== void 0) {
          this._components[0] = r2;
          this._components[1] = g2;
          this._components[2] = b2;
          this._components[3] = a2;
          this._refreshInt();
        } else {
          throw new Error(`Unable to convert color ${value}`);
        }
      }
      /** Refresh the internal color rgb number */
      _refreshInt() {
        this._clamp(this._components);
        const [r2, g2, b2] = this._components;
        this._int = (r2 * 255 << 16) + (g2 * 255 << 8) + (b2 * 255 | 0);
      }
      /**
       * Clamps values to a range. Will override original values
       * @param value - Value(s) to clamp
       * @param min - Minimum value
       * @param max - Maximum value
       */
      _clamp(value, min = 0, max = 1) {
        if (typeof value === "number") {
          return Math.min(Math.max(value, min), max);
        }
        value.forEach((v3, i3) => {
          value[i3] = Math.min(Math.max(v3, min), max);
        });
        return value;
      }
      /**
       * Check if the value is a color-like object
       * @param value - Value to check
       * @returns True if the value is a color-like object
       * @static
       * @example
       * import { Color } from 'pixi.js';
       * Color.isColorLike('white'); // returns true
       * Color.isColorLike(0xffffff); // returns true
       * Color.isColorLike([1, 1, 1]); // returns true
       */
      static isColorLike(value) {
        return typeof value === "number" || typeof value === "string" || value instanceof Number || value instanceof _Color3 || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;
      }
    };
    Color3 = _Color3;
    Color3.shared = new _Color3();
    Color3._temp = new _Color3();
    Color3.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/misc/const.mjs
var PI_23, RAD_TO_DEG3, DEG_TO_RAD3;
var init_const11 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/misc/const.mjs"() {
    PI_23 = Math.PI * 2;
    RAD_TO_DEG3 = 180 / Math.PI;
    DEG_TO_RAD3 = Math.PI / 180;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs
var Matrix3, tempMatrix6, identityMatrix2;
var init_Matrix2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"() {
    init_const11();
    init_Point2();
    Matrix3 = class _Matrix {
      /**
       * @param a - x scale
       * @param b - y skew
       * @param c - x skew
       * @param d - y scale
       * @param tx - x translation
       * @param ty - y translation
       */
      constructor(a2 = 1, b2 = 0, c2 = 0, d3 = 1, tx = 0, ty = 0) {
        this.array = null;
        this.a = a2;
        this.b = b2;
        this.c = c2;
        this.d = d3;
        this.tx = tx;
        this.ty = ty;
      }
      /**
       * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
       *
       * a = array[0]
       * b = array[1]
       * c = array[3]
       * d = array[4]
       * tx = array[2]
       * ty = array[5]
       * @param array - The array that the matrix will be populated from.
       */
      fromArray(array) {
        this.a = array[0];
        this.b = array[1];
        this.c = array[3];
        this.d = array[4];
        this.tx = array[2];
        this.ty = array[5];
      }
      /**
       * Sets the matrix properties.
       * @param a - Matrix component
       * @param b - Matrix component
       * @param c - Matrix component
       * @param d - Matrix component
       * @param tx - Matrix component
       * @param ty - Matrix component
       * @returns This matrix. Good for chaining method calls.
       */
      set(a2, b2, c2, d3, tx, ty) {
        this.a = a2;
        this.b = b2;
        this.c = c2;
        this.d = d3;
        this.tx = tx;
        this.ty = ty;
        return this;
      }
      /**
       * Creates an array from the current Matrix object.
       * @param transpose - Whether we need to transpose the matrix or not
       * @param [out=new Float32Array(9)] - If provided the array will be assigned to out
       * @returns The newly created array which contains the matrix
       */
      toArray(transpose, out3) {
        if (!this.array) {
          this.array = new Float32Array(9);
        }
        const array = out3 || this.array;
        if (transpose) {
          array[0] = this.a;
          array[1] = this.b;
          array[2] = 0;
          array[3] = this.c;
          array[4] = this.d;
          array[5] = 0;
          array[6] = this.tx;
          array[7] = this.ty;
          array[8] = 1;
        } else {
          array[0] = this.a;
          array[1] = this.c;
          array[2] = this.tx;
          array[3] = this.b;
          array[4] = this.d;
          array[5] = this.ty;
          array[6] = 0;
          array[7] = 0;
          array[8] = 1;
        }
        return array;
      }
      /**
       * Get a new position with the current transformation applied.
       * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
       * @param pos - The origin
       * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
       * @returns {Point} The new point, transformed through this matrix
       */
      apply(pos, newPos) {
        newPos = newPos || new Point3();
        const x3 = pos.x;
        const y2 = pos.y;
        newPos.x = this.a * x3 + this.c * y2 + this.tx;
        newPos.y = this.b * x3 + this.d * y2 + this.ty;
        return newPos;
      }
      /**
       * Get a new position with the inverse of the current transformation applied.
       * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
       * @param pos - The origin
       * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
       * @returns {Point} The new point, inverse-transformed through this matrix
       */
      applyInverse(pos, newPos) {
        newPos = newPos || new Point3();
        const a2 = this.a;
        const b2 = this.b;
        const c2 = this.c;
        const d3 = this.d;
        const tx = this.tx;
        const ty = this.ty;
        const id = 1 / (a2 * d3 + c2 * -b2);
        const x3 = pos.x;
        const y2 = pos.y;
        newPos.x = d3 * id * x3 + -c2 * id * y2 + (ty * c2 - tx * d3) * id;
        newPos.y = a2 * id * y2 + -b2 * id * x3 + (-ty * a2 + tx * b2) * id;
        return newPos;
      }
      /**
       * Translates the matrix on the x and y.
       * @param x - How much to translate x by
       * @param y - How much to translate y by
       * @returns This matrix. Good for chaining method calls.
       */
      translate(x3, y2) {
        this.tx += x3;
        this.ty += y2;
        return this;
      }
      /**
       * Applies a scale transformation to the matrix.
       * @param x - The amount to scale horizontally
       * @param y - The amount to scale vertically
       * @returns This matrix. Good for chaining method calls.
       */
      scale(x3, y2) {
        this.a *= x3;
        this.d *= y2;
        this.c *= x3;
        this.b *= y2;
        this.tx *= x3;
        this.ty *= y2;
        return this;
      }
      /**
       * Applies a rotation transformation to the matrix.
       * @param angle - The angle in radians.
       * @returns This matrix. Good for chaining method calls.
       */
      rotate(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const a1 = this.a;
        const c1 = this.c;
        const tx1 = this.tx;
        this.a = a1 * cos - this.b * sin;
        this.b = a1 * sin + this.b * cos;
        this.c = c1 * cos - this.d * sin;
        this.d = c1 * sin + this.d * cos;
        this.tx = tx1 * cos - this.ty * sin;
        this.ty = tx1 * sin + this.ty * cos;
        return this;
      }
      /**
       * Appends the given Matrix to this Matrix.
       * @param matrix - The matrix to append.
       * @returns This matrix. Good for chaining method calls.
       */
      append(matrix) {
        const a1 = this.a;
        const b1 = this.b;
        const c1 = this.c;
        const d1 = this.d;
        this.a = matrix.a * a1 + matrix.b * c1;
        this.b = matrix.a * b1 + matrix.b * d1;
        this.c = matrix.c * a1 + matrix.d * c1;
        this.d = matrix.c * b1 + matrix.d * d1;
        this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
        this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
        return this;
      }
      /**
       * Appends two matrix's and sets the result to this matrix. AB = A * B
       * @param a - The matrix to append.
       * @param b - The matrix to append.
       * @returns This matrix. Good for chaining method calls.
       */
      appendFrom(a2, b2) {
        const a1 = a2.a;
        const b1 = a2.b;
        const c1 = a2.c;
        const d1 = a2.d;
        const tx = a2.tx;
        const ty = a2.ty;
        const a22 = b2.a;
        const b22 = b2.b;
        const c2 = b2.c;
        const d22 = b2.d;
        this.a = a1 * a22 + b1 * c2;
        this.b = a1 * b22 + b1 * d22;
        this.c = c1 * a22 + d1 * c2;
        this.d = c1 * b22 + d1 * d22;
        this.tx = tx * a22 + ty * c2 + b2.tx;
        this.ty = tx * b22 + ty * d22 + b2.ty;
        return this;
      }
      /**
       * Sets the matrix based on all the available properties
       * @param x - Position on the x axis
       * @param y - Position on the y axis
       * @param pivotX - Pivot on the x axis
       * @param pivotY - Pivot on the y axis
       * @param scaleX - Scale on the x axis
       * @param scaleY - Scale on the y axis
       * @param rotation - Rotation in radians
       * @param skewX - Skew on the x axis
       * @param skewY - Skew on the y axis
       * @returns This matrix. Good for chaining method calls.
       */
      setTransform(x3, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
        this.a = Math.cos(rotation + skewY) * scaleX;
        this.b = Math.sin(rotation + skewY) * scaleX;
        this.c = -Math.sin(rotation - skewX) * scaleY;
        this.d = Math.cos(rotation - skewX) * scaleY;
        this.tx = x3 - (pivotX * this.a + pivotY * this.c);
        this.ty = y2 - (pivotX * this.b + pivotY * this.d);
        return this;
      }
      /**
       * Prepends the given Matrix to this Matrix.
       * @param matrix - The matrix to prepend
       * @returns This matrix. Good for chaining method calls.
       */
      prepend(matrix) {
        const tx1 = this.tx;
        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
          const a1 = this.a;
          const c1 = this.c;
          this.a = a1 * matrix.a + this.b * matrix.c;
          this.b = a1 * matrix.b + this.b * matrix.d;
          this.c = c1 * matrix.a + this.d * matrix.c;
          this.d = c1 * matrix.b + this.d * matrix.d;
        }
        this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
        this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
        return this;
      }
      /**
       * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
       * @param transform - The transform to apply the properties to.
       * @returns The transform with the newly applied properties
       */
      decompose(transform) {
        const a2 = this.a;
        const b2 = this.b;
        const c2 = this.c;
        const d3 = this.d;
        const pivot = transform.pivot;
        const skewX = -Math.atan2(-c2, d3);
        const skewY = Math.atan2(b2, a2);
        const delta = Math.abs(skewX + skewY);
        if (delta < 1e-5 || Math.abs(PI_23 - delta) < 1e-5) {
          transform.rotation = skewY;
          transform.skew.x = transform.skew.y = 0;
        } else {
          transform.rotation = 0;
          transform.skew.x = skewX;
          transform.skew.y = skewY;
        }
        transform.scale.x = Math.sqrt(a2 * a2 + b2 * b2);
        transform.scale.y = Math.sqrt(c2 * c2 + d3 * d3);
        transform.position.x = this.tx + (pivot.x * a2 + pivot.y * c2);
        transform.position.y = this.ty + (pivot.x * b2 + pivot.y * d3);
        return transform;
      }
      /**
       * Inverts this matrix
       * @returns This matrix. Good for chaining method calls.
       */
      invert() {
        const a1 = this.a;
        const b1 = this.b;
        const c1 = this.c;
        const d1 = this.d;
        const tx1 = this.tx;
        const n2 = a1 * d1 - b1 * c1;
        this.a = d1 / n2;
        this.b = -b1 / n2;
        this.c = -c1 / n2;
        this.d = a1 / n2;
        this.tx = (c1 * this.ty - d1 * tx1) / n2;
        this.ty = -(a1 * this.ty - b1 * tx1) / n2;
        return this;
      }
      /** Checks if this matrix is an identity matrix */
      isIdentity() {
        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
      }
      /**
       * Resets this Matrix to an identity (default) matrix.
       * @returns This matrix. Good for chaining method calls.
       */
      identity() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
        return this;
      }
      /**
       * Creates a new Matrix object with the same values as this one.
       * @returns A copy of this matrix. Good for chaining method calls.
       */
      clone() {
        const matrix = new _Matrix();
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      }
      /**
       * Changes the values of the given matrix to be the same as the ones in this matrix
       * @param matrix - The matrix to copy to.
       * @returns The matrix given in parameter with its values updated.
       */
      copyTo(matrix) {
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      }
      /**
       * Changes the values of the matrix to be the same as the ones in given matrix
       * @param matrix - The matrix to copy from.
       * @returns this
       */
      copyFrom(matrix) {
        this.a = matrix.a;
        this.b = matrix.b;
        this.c = matrix.c;
        this.d = matrix.d;
        this.tx = matrix.tx;
        this.ty = matrix.ty;
        return this;
      }
      toString() {
        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
      }
      /**
       * A default (identity) matrix
       * @readonly
       */
      static get IDENTITY() {
        return identityMatrix2.identity();
      }
      /**
       * A temp matrix
       * @readonly
       */
      static get shared() {
        return tempMatrix6.identity();
      }
    };
    tempMatrix6 = new Matrix3();
    identityMatrix2 = new Matrix3();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs
var ObservablePoint3;
var init_ObservablePoint2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs"() {
    ObservablePoint3 = class _ObservablePoint {
      /**
       * Creates a new `ObservablePoint`
       * @param observer - Observer to pass to listen for change events.
       * @param {number} [x=0] - position of the point on the x axis
       * @param {number} [y=0] - position of the point on the y axis
       */
      constructor(observer, x3, y2) {
        this._x = x3 || 0;
        this._y = y2 || 0;
        this._observer = observer;
      }
      /**
       * Creates a clone of this point.
       * @param observer - Optional observer to pass to the new observable point.
       * @returns a copy of this observable point
       */
      clone(observer) {
        return new _ObservablePoint(observer ?? this._observer, this._x, this._y);
      }
      /**
       * Sets the point to a new `x` and `y` position.
       * If `y` is omitted, both `x` and `y` will be set to `x`.
       * @param {number} [x=0] - position of the point on the x axis
       * @param {number} [y=x] - position of the point on the y axis
       * @returns The observable point instance itself
       */
      set(x3 = 0, y2 = x3) {
        if (this._x !== x3 || this._y !== y2) {
          this._x = x3;
          this._y = y2;
          this._observer.onUpdate();
        }
        return this;
      }
      /**
       * Copies x and y from the given point (`p`)
       * @param p - The point to copy from. Can be any of type that is or extends `PointData`
       * @returns The observable point instance itself
       */
      copyFrom(p3) {
        if (this._x !== p3.x || this._y !== p3.y) {
          this._x = p3.x;
          this._y = p3.y;
          this._observer.onUpdate();
        }
        return this;
      }
      /**
       * Copies this point's x and y into that of the given point (`p`)
       * @param p - The point to copy to. Can be any of type that is or extends `PointData`
       * @returns The point (`p`) with values updated
       */
      copyTo(p3) {
        p3.set(this._x, this._y);
        return p3;
      }
      /**
       * Accepts another point (`p`) and returns `true` if the given point is equal to this point
       * @param p - The point to check
       * @returns Returns `true` if both `x` and `y` are equal
       */
      equals(p3) {
        return p3.x === this._x && p3.y === this._y;
      }
      toString() {
        return `[@pixi/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;
      }
      /** Position of the observable point on the x axis. */
      get x() {
        return this._x;
      }
      set x(value) {
        if (this._x !== value) {
          this._x = value;
          this._observer.onUpdate(this);
        }
      }
      /** Position of the observable point on the y axis. */
      get y() {
        return this._y;
      }
      set y(value) {
        if (this._y !== value) {
          this._y = value;
          this._observer.onUpdate(this);
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/data/uid.mjs
function uid3(name = "default") {
  if (uidCache2[name] === void 0) {
    uidCache2[name] = -1;
  }
  return ++uidCache2[name];
}
var uidCache2;
var init_uid2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/data/uid.mjs"() {
    uidCache2 = {
      default: -1
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/logging/deprecation.mjs
function deprecation3(version, message, ignoreDepth = 3) {
  if (warnings3[message]) {
    return;
  }
  let stack = new Error().stack;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (console.groupCollapsed) {
      console.groupCollapsed(
        "%cPixiJS Deprecation Warning: %c%s",
        "color:#614108;background:#fffbe6",
        "font-weight:normal;color:#614108;background:#fffbe6",
        `${message}
Deprecated since v${version}`
      );
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
      console.warn(stack);
    }
  }
  warnings3[message] = true;
}
var warnings3, v8_0_02;
var init_deprecation2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/logging/deprecation.mjs"() {
    warnings3 = {};
    v8_0_02 = "8.0.0";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/data/removeItems.mjs
function removeItems3(arr, startIdx, removeCount) {
  const length = arr.length;
  let i3;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  const len = length - removeCount;
  for (i3 = startIdx; i3 < len; ++i3) {
    arr[i3] = arr[i3 + removeCount];
  }
  arr.length = len;
}
var init_removeItems2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/data/removeItems.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs
var childrenHelperMixin2;
var init_childrenHelperMixin2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs"() {
    init_removeItems2();
    init_deprecation2();
    childrenHelperMixin2 = {
      allowChildren: true,
      /**
       * Removes all children from this container that are within the begin and end indexes.
       * @param beginIndex - The beginning position.
       * @param endIndex - The ending position. Default value is size of the container.
       * @returns - List of removed children
       * @memberof Container#
       */
      removeChildren(beginIndex = 0, endIndex) {
        const end = endIndex ?? this.children.length;
        const range = end - beginIndex;
        const removed = [];
        if (range > 0 && range <= end) {
          for (let i3 = end - 1; i3 >= beginIndex; i3--) {
            const child = this.children[i3];
            if (!child)
              continue;
            if (this.layerGroup) {
              this.layerGroup.removeChild(child);
            }
            removed.push(child);
            child.parent = null;
          }
          removeItems3(this.children, beginIndex, end);
          for (let i3 = 0; i3 < removed.length; ++i3) {
            this.emit("childRemoved", removed[i3], this, i3);
            removed[i3].emit("removed", this);
          }
          return removed;
        } else if (range === 0 && this.children.length === 0) {
          return removed;
        }
        throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
      },
      /**
       * Removes a child from the specified index position.
       * @param index - The index to get the child from
       * @returns The child that was removed.
       * @memberof Container#
       */
      removeChildAt(index) {
        const child = this.getChildAt(index);
        return this.removeChild(child);
      },
      /**
       * Returns the child at the specified index
       * @param index - The index to get the child at
       * @returns - The child at the given index, if any.
       * @memberof Container#
       */
      getChildAt(index) {
        if (index < 0 || index >= this.children.length) {
          throw new Error(`getChildAt: Index (${index}) does not exist.`);
        }
        return this.children[index];
      },
      /**
       * Changes the position of an existing child in the container container
       * @param child - The child Container instance for which you want to change the index number
       * @param index - The resulting index number for the child container
       * @memberof Container#
       */
      setChildIndex(child, index) {
        if (index < 0 || index >= this.children.length) {
          throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
        }
        this.getChildIndex(child);
        this.addChildAt(child, index);
      },
      /**
       * Returns the index position of a child Container instance
       * @param child - The Container instance to identify
       * @returns - The index position of the child container to identify
       * @memberof Container#
       */
      getChildIndex(child) {
        const index = this.children.indexOf(child);
        if (index === -1) {
          throw new Error("The supplied Container must be a child of the caller");
        }
        return index;
      },
      /**
       * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.
       * If the child is already in this container, it will be moved to the specified index.
       * @param {Container} child - The child to add.
       * @param {number} index - The absolute index where the child will be positioned at the end of the operation.
       * @returns {Container} The child that was added.
       * @memberof Container#
       */
      addChildAt(child, index) {
        if (!this.allowChildren) {
          deprecation3(v8_0_02, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
        }
        const { children } = this;
        if (index < 0 || index > children.length) {
          throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);
        }
        if (child.parent) {
          const currentIndex = child.parent.children.indexOf(child);
          if (child.parent === this && currentIndex === index) {
            return child;
          }
          if (currentIndex !== -1) {
            child.parent.children.splice(currentIndex, 1);
          }
        }
        if (index === children.length) {
          children.push(child);
        } else {
          children.splice(index, 0, child);
        }
        child.parent = this;
        child.didChange = true;
        child.didViewUpdate = false;
        child._updateFlags = 15;
        if (this.layerGroup) {
          this.layerGroup.addChild(child);
        }
        if (this.sortableChildren)
          this.sortDirty = true;
        this.emit("childAdded", child, this, index);
        child.emit("added", this);
        return child;
      },
      /**
       * Swaps the position of 2 Containers within this container.
       * @param child - First container to swap
       * @param child2 - Second container to swap
       */
      swapChildren(child, child2) {
        if (child === child2) {
          return;
        }
        const index1 = this.getChildIndex(child);
        const index2 = this.getChildIndex(child2);
        this.children[index1] = child2;
        this.children[index2] = child;
      },
      /** Remove the Container from its parent Container. If the Container has no parent, do nothing. */
      removeFromParent() {
        this.parent?.removeChild(this);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/FilterEffect.mjs
function getFilterEffect2(filters) {
  const filterEffect = filterEffectsPool2.pop() || new FilterEffect2();
  filterEffect.filters = filters;
  return filterEffect;
}
function returnFilterEffect2(effect) {
  effect.filters = null;
  filterEffectsPool2.push(effect);
}
var FilterEffect2, filterEffectsPool2;
var init_FilterEffect2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/FilterEffect.mjs"() {
    FilterEffect2 = class {
      constructor(options) {
        this.pipe = "filter";
        this.priority = 1;
        this.filters = options?.filters;
      }
      destroy() {
        for (let i3 = 0; i3 < this.filters.length; i3++) {
          this.filters[i3].destroy();
        }
        this.filters = null;
      }
    };
    filterEffectsPool2 = [];
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/pool/Pool.mjs
var Pool3;
var init_Pool2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/pool/Pool.mjs"() {
    Pool3 = class {
      constructor(ClassType, initialSize) {
        this._pool = [];
        this._count = 0;
        this._index = 0;
        this._classType = ClassType;
        if (initialSize) {
          this.prepopulate(initialSize);
        }
      }
      prepopulate(total) {
        for (let i3 = 0; i3 < total; i3++) {
          this._pool[this._index++] = new this._classType();
        }
        this._count += total;
      }
      get(data) {
        let item;
        if (this._index > 0) {
          item = this._pool[--this._index];
        } else {
          item = new this._classType();
        }
        item.init?.(data);
        return item;
      }
      return(item) {
        item.reset?.();
        this._pool[this._index++] = item;
      }
      get totalSize() {
        return this._count;
      }
      get totalFree() {
        return this._pool.length;
      }
      get totalUsed() {
        return this._count - this._pool.length;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs
var PoolGroupClass2, BigPool2;
var init_PoolGroup2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"() {
    init_Pool2();
    PoolGroupClass2 = class {
      constructor() {
        this._poolsByClass = /* @__PURE__ */ new Map();
      }
      prepopulate(Class, total) {
        const classPool = this.getPool(Class);
        classPool.prepopulate(total);
      }
      get(Class, data) {
        const pool = this.getPool(Class);
        return pool.get(data);
      }
      return(item) {
        const pool = this.getPool(item.constructor);
        pool.return(item);
      }
      getPool(ClassType) {
        if (!this._poolsByClass.has(ClassType)) {
          this._poolsByClass.set(ClassType, new Pool3(ClassType));
        }
        return this._poolsByClass.get(ClassType);
      }
      /** gets the usage stats of each pool in the system */
      stats() {
        const stats = {};
        this._poolsByClass.forEach((pool) => {
          const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;
          stats[name] = {
            free: pool.totalFree,
            used: pool.totalUsed,
            size: pool.totalSize
          };
        });
        return stats;
      }
    };
    BigPool2 = new PoolGroupClass2();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs
var MaskEffectManagerClass2, MaskEffectManager2;
var init_MaskEffectManager2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs"() {
    init_Extensions2();
    init_PoolGroup2();
    MaskEffectManagerClass2 = class {
      constructor() {
        this._effectClasses = [];
        this._tests = [];
        this._initialized = false;
      }
      init() {
        if (this._initialized)
          return;
        this._initialized = true;
        this._effectClasses.forEach((test) => {
          this.add({
            test: test.test,
            maskClass: test
          });
        });
      }
      add(test) {
        this._tests.push(test);
      }
      getMaskEffect(item) {
        if (!this._initialized)
          this.init();
        for (let i3 = 0; i3 < this._tests.length; i3++) {
          const test = this._tests[i3];
          if (test.test(item)) {
            return BigPool2.get(test.maskClass, item);
          }
        }
        return item;
      }
      returnMaskEffect(effect) {
        BigPool2.return(effect);
      }
    };
    MaskEffectManager2 = new MaskEffectManagerClass2();
    extensions3.handleByList(ExtensionType3.MaskEffect, MaskEffectManager2._effectClasses);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs
var effectsMixin2;
var init_effectsMixin2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs"() {
    init_FilterEffect2();
    init_MaskEffectManager2();
    effectsMixin2 = {
      _mask: null,
      _filters: null,
      effects: [],
      addEffect(effect) {
        const index = this.effects.indexOf(effect);
        if (index !== -1)
          return;
        this.effects.push(effect);
        this.effects.sort((a2, b2) => a2.priority - b2.priority);
        if (!this.isLayerRoot && this.layerGroup) {
          this.layerGroup.structureDidChange = true;
        }
        this._updateIsSimple();
      },
      removeEffect(effect) {
        const index = this.effects.indexOf(effect);
        if (index === -1)
          return;
        this.effects.splice(index, 1);
        if (!this.isLayerRoot && this.layerGroup) {
          this.layerGroup.structureDidChange = true;
        }
        this._updateIsSimple();
      },
      set mask(value) {
        this._mask || (this._mask = { mask: null, effect: null });
        if (this._mask.mask === value)
          return;
        if (this._mask.effect) {
          this.removeEffect(this._mask.effect);
          MaskEffectManager2.returnMaskEffect(this._mask.effect);
          this._mask.effect = null;
        }
        this._mask.mask = value;
        if (value === null || value === void 0)
          return;
        const effect = MaskEffectManager2.getMaskEffect(value);
        this._mask.effect = effect;
        this.addEffect(effect);
      },
      get mask() {
        return this._mask?.mask;
      },
      set filters(value) {
        if (!Array.isArray(value) && value !== null)
          value = [value];
        this._filters || (this._filters = { filters: null, effect: null });
        if (this._filters.filters === value)
          return;
        if (this._filters.effect) {
          this.removeEffect(this._filters.effect);
          returnFilterEffect2(this._filters.effect);
          this._filters.effect = null;
        }
        this._filters.filters = value;
        if (!value)
          return;
        const effect = getFilterEffect2(value);
        this._filters.effect = effect;
        this.addEffect(effect);
      },
      get filters() {
        return this._filters?.filters;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs
var findMixin2;
var init_findMixin2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs"() {
    init_deprecation2();
    findMixin2 = {
      label: null,
      /** @deprecated since 8.0.0 */
      get name() {
        deprecation3(v8_0_02, "Container.name property has been removed, use Container.label instead");
        return this.label;
      },
      /** @deprecated since 8.0.0 */
      set name(value) {
        deprecation3(v8_0_02, "Container.name property has been removed, use Container.label instead");
        this.label = value;
      },
      /**
       * @method getChildByName
       * @memberof Container#
       * @deprecated since 8.0.0
       * @see Container#getChildByLabel
       * @param {string} name - Instance name.
       * @param {boolean}[deep=false] - Whether to search recursively
       * @returns {Container} The child with the specified name.
       */
      getChildByName(name, deep = false) {
        return this.getChildByLabel(name, deep);
      },
      /**
       * Returns the first child in the container with the specified label.
       *
       * Recursive searches are done in a pre-order traversal.
       * @method getChildByLabel
       * @memberof Container#
       * @param {string|RegExp} label - Instance label.
       * @param {boolean}[deep=false] - Whether to search recursively
       * @returns {Container} The child with the specified label.
       */
      getChildByLabel(label, deep = false) {
        const children = this.children;
        for (let i3 = 0; i3 < children.length; i3++) {
          const child = children[i3];
          if (child.label === label || label instanceof RegExp && label.test(child.label))
            return child;
        }
        if (deep) {
          for (let i3 = 0; i3 < children.length; i3++) {
            const child = children[i3];
            const found = child.getChildByLabel(label, true);
            if (found) {
              return found;
            }
          }
        }
        return null;
      },
      /**
       * Returns all children in the container with the specified label.
       * @method getChildrenByLabel
       * @memberof Container#
       * @param {string|RegExp} label - Instance label.
       * @param {boolean}[deep=false] - Whether to search recursively
       * @param {Container[]} [out=[]] - The array to store matching children in.
       * @returns {Container[]} An array of children with the specified label.
       */
      getChildrenByLabel(label, deep = false, out3 = []) {
        const children = this.children;
        for (let i3 = 0; i3 < children.length; i3++) {
          const child = children[i3];
          if (child.label === label || label instanceof RegExp && label.test(child.label)) {
            out3.push(child);
          }
        }
        if (deep) {
          for (let i3 = 0; i3 < children.length; i3++) {
            children[i3].getChildrenByLabel(label, true, out3);
          }
        }
        return out3;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs
var tempPoints4, Rectangle3;
var init_Rectangle2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs"() {
    init_Point2();
    tempPoints4 = [new Point3(), new Point3(), new Point3(), new Point3()];
    Rectangle3 = class _Rectangle {
      /**
       * @param x - The X coordinate of the upper-left corner of the rectangle
       * @param y - The Y coordinate of the upper-left corner of the rectangle
       * @param width - The overall width of the rectangle
       * @param height - The overall height of the rectangle
       */
      constructor(x3 = 0, y2 = 0, width = 0, height = 0) {
        this.type = "rectangle";
        this.x = Number(x3);
        this.y = Number(y2);
        this.width = Number(width);
        this.height = Number(height);
      }
      /** Returns the left edge of the rectangle. */
      get left() {
        return this.x;
      }
      /** Returns the right edge of the rectangle. */
      get right() {
        return this.x + this.width;
      }
      /** Returns the top edge of the rectangle. */
      get top() {
        return this.y;
      }
      /** Returns the bottom edge of the rectangle. */
      get bottom() {
        return this.y + this.height;
      }
      /** A constant empty rectangle. */
      static get EMPTY() {
        return new _Rectangle(0, 0, 0, 0);
      }
      /**
       * Creates a clone of this Rectangle
       * @returns a copy of the rectangle
       */
      clone() {
        return new _Rectangle(this.x, this.y, this.width, this.height);
      }
      /**
       * Converts a Bounds object to a Rectangle object.
       * @param bounds - The bounds to copy and convert to a rectangle.
       * @returns Returns itself.
       */
      copyFromBounds(bounds) {
        this.x = bounds.minX;
        this.y = bounds.minY;
        this.width = bounds.maxX - bounds.minX;
        this.height = bounds.maxY - bounds.minY;
        return this;
      }
      /**
       * Copies another rectangle to this one.
       * @param rectangle - The rectangle to copy from.
       * @returns Returns itself.
       */
      copyFrom(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
      }
      /**
       * Copies this rectangle to another one.
       * @param rectangle - The rectangle to copy to.
       * @returns Returns given parameter.
       */
      copyTo(rectangle) {
        rectangle.copyFrom(this);
        return rectangle;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this Rectangle
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coordinates are within this Rectangle
       */
      contains(x3, y2) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x3 >= this.x && x3 < this.x + this.width) {
          if (y2 >= this.y && y2 < this.y + this.height) {
            return true;
          }
        }
        return false;
      }
      /**
       * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
       * Returns true only if the area of the intersection is >0, this means that Rectangles
       * sharing a side are not overlapping. Another side effect is that an arealess rectangle
       * (width or height equal to zero) can't intersect any other rectangle.
       * @param {Rectangle} other - The Rectangle to intersect with `this`.
       * @param {Matrix} transform - The transformation matrix of `other`.
       * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
       */
      intersects(other, transform) {
        if (!transform) {
          const x02 = this.x < other.x ? other.x : this.x;
          const x12 = this.right > other.right ? other.right : this.right;
          if (x12 <= x02) {
            return false;
          }
          const y02 = this.y < other.y ? other.y : this.y;
          const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
          return y12 > y02;
        }
        const x0 = this.left;
        const x1 = this.right;
        const y0 = this.top;
        const y1 = this.bottom;
        if (x1 <= x0 || y1 <= y0) {
          return false;
        }
        const lt = tempPoints4[0].set(other.left, other.top);
        const lb = tempPoints4[1].set(other.left, other.bottom);
        const rt = tempPoints4[2].set(other.right, other.top);
        const rb = tempPoints4[3].set(other.right, other.bottom);
        if (rt.x <= lt.x || lb.y <= lt.y) {
          return false;
        }
        const s2 = Math.sign(transform.a * transform.d - transform.b * transform.c);
        if (s2 === 0) {
          return false;
        }
        transform.apply(lt, lt);
        transform.apply(lb, lb);
        transform.apply(rt, rt);
        transform.apply(rb, rb);
        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
          return false;
        }
        const nx = s2 * (lb.y - lt.y);
        const ny = s2 * (lt.x - lb.x);
        const n00 = nx * x0 + ny * y0;
        const n10 = nx * x1 + ny * y0;
        const n01 = nx * x0 + ny * y1;
        const n11 = nx * x1 + ny * y1;
        if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
          return false;
        }
        const mx = s2 * (lt.y - rt.y);
        const my = s2 * (rt.x - lt.x);
        const m00 = mx * x0 + my * y0;
        const m10 = mx * x1 + my * y0;
        const m01 = mx * x0 + my * y1;
        const m11 = mx * x1 + my * y1;
        if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
          return false;
        }
        return true;
      }
      /**
       * Pads the rectangle making it grow in all directions.
       * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
       * @param paddingX - The horizontal padding amount.
       * @param paddingY - The vertical padding amount.
       * @returns Returns itself.
       */
      pad(paddingX = 0, paddingY = paddingX) {
        this.x -= paddingX;
        this.y -= paddingY;
        this.width += paddingX * 2;
        this.height += paddingY * 2;
        return this;
      }
      /**
       * Fits this rectangle around the passed one.
       * @param rectangle - The rectangle to fit.
       * @returns Returns itself.
       */
      fit(rectangle) {
        const x1 = Math.max(this.x, rectangle.x);
        const x22 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
        const y1 = Math.max(this.y, rectangle.y);
        const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = Math.max(x22 - x1, 0);
        this.y = y1;
        this.height = Math.max(y2 - y1, 0);
        return this;
      }
      /**
       * Enlarges rectangle that way its corners lie on grid
       * @param resolution - resolution
       * @param eps - precision
       * @returns Returns itself.
       */
      ceil(resolution = 1, eps = 1e-3) {
        const x22 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
        const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
        this.x = Math.floor((this.x + eps) * resolution) / resolution;
        this.y = Math.floor((this.y + eps) * resolution) / resolution;
        this.width = x22 - this.x;
        this.height = y2 - this.y;
        return this;
      }
      /**
       * Enlarges this rectangle to include the passed rectangle.
       * @param rectangle - The rectangle to include.
       * @returns Returns itself.
       */
      enlarge(rectangle) {
        const x1 = Math.min(this.x, rectangle.x);
        const x22 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
        const y1 = Math.min(this.y, rectangle.y);
        const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = x22 - x1;
        this.y = y1;
        this.height = y2 - y1;
        return this;
      }
      /**
       * Returns the framing rectangle of the rectangle as a Rectangle object
       * @param out - optional rectangle to store the result
       * @returns The framing rectangle
       */
      getBounds(out3) {
        out3 = out3 || new _Rectangle();
        out3.copyFrom(this);
        return out3;
      }
      toString() {
        return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs
var Bounds2;
var init_Bounds2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs"() {
    init_Matrix2();
    init_Rectangle2();
    Bounds2 = class _Bounds {
      constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
        this._matrixStack = [];
        this.matrix = new Matrix3();
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      }
      get rectangle() {
        if (!this._rectangle) {
          this._rectangle = new Rectangle3();
        }
        const rectangle = this._rectangle;
        if (this.minX > this.maxX || this.minY > this.maxY) {
          rectangle.x = 0;
          rectangle.y = 0;
          rectangle.width = 0;
          rectangle.height = 0;
        } else {
          rectangle.copyFromBounds(this);
        }
        return rectangle;
      }
      clear() {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
        this._matrixStack.length = 0;
        this.matrix.identity();
      }
      pushMatrix(matrix) {
        this._matrixStack.push(matrix);
        if (this._matrixStack.length > 1) {
          this.matrix.copyFrom(this._matrixStack[this._matrixStack.length - 2]);
          this.matrix.append(matrix);
        } else {
          this.matrix.copyFrom(matrix);
        }
      }
      popMatrix() {
        this._matrixStack.pop();
        if (this._matrixStack.length > 1) {
          this.matrix.copyFrom(this._matrixStack[this._matrixStack.length - 2]);
          this.matrix.append(this._matrixStack[this._matrixStack.length - 1]);
        } else if (this._matrixStack.length === 1) {
          this.matrix.copyFrom(this._matrixStack[0]);
        } else {
          this.matrix.identity();
        }
      }
      setMatrix(matrix) {
        this.matrix.copyFrom(matrix);
      }
      set(x0, y0, x1, y1) {
        this.minX = x0;
        this.minY = y0;
        this.maxX = x1;
        this.maxY = y1;
      }
      /**
       * Adds sprite frame
       * @param x0 - left X of frame
       * @param y0 - top Y of frame
       * @param x1 - right X of frame
       * @param y1 - bottom Y of frame
       */
      addFrame(x0, y0, x1, y1) {
        const matrix = this.matrix;
        const a2 = matrix.a;
        const b2 = matrix.b;
        const c2 = matrix.c;
        const d3 = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        let minX = this.minX;
        let minY = this.minY;
        let maxX = this.maxX;
        let maxY = this.maxY;
        let x3 = a2 * x0 + c2 * y0 + tx;
        let y2 = b2 * x0 + d3 * y0 + ty;
        minX = x3 < minX ? x3 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x3 > maxX ? x3 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x3 = a2 * x1 + c2 * y0 + tx;
        y2 = b2 * x1 + d3 * y0 + ty;
        minX = x3 < minX ? x3 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x3 > maxX ? x3 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x3 = a2 * x0 + c2 * y1 + tx;
        y2 = b2 * x0 + d3 * y1 + ty;
        minX = x3 < minX ? x3 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x3 > maxX ? x3 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x3 = a2 * x1 + c2 * y1 + tx;
        y2 = b2 * x1 + d3 * y1 + ty;
        minX = x3 < minX ? x3 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x3 > maxX ? x3 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      }
      addRect(rect) {
        this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height);
      }
      addBounds(bounds) {
        this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
      }
      addBoundsMask(mask2) {
        this.minX = this.minX > mask2.minX ? this.minX : mask2.minX;
        this.minY = this.minY > mask2.minY ? this.minY : mask2.minY;
        this.maxX = this.maxX < mask2.maxX ? this.maxX : mask2.maxX;
        this.maxY = this.maxY < mask2.maxY ? this.maxY : mask2.maxY;
      }
      applyMatrix(matrix) {
        const minX = this.minX;
        const minY = this.minY;
        const maxX = this.maxX;
        const maxY = this.maxY;
        const { a: a2, b: b2, c: c2, d: d3, tx, ty } = matrix;
        let x3 = a2 * minX + c2 * minY + tx;
        let y2 = b2 * minX + d3 * minY + ty;
        this.minX = x3;
        this.minY = y2;
        this.maxX = x3;
        this.maxY = y2;
        x3 = a2 * maxX + c2 * minY + tx;
        y2 = b2 * maxX + d3 * minY + ty;
        this.minX = x3 < this.minX ? x3 : this.minX;
        this.minY = y2 < this.minY ? y2 : this.minY;
        this.maxX = x3 > this.maxX ? x3 : this.maxX;
        this.maxY = y2 > this.maxY ? y2 : this.maxY;
        x3 = a2 * minX + c2 * maxY + tx;
        y2 = b2 * minX + d3 * maxY + ty;
        this.minX = x3 < this.minX ? x3 : this.minX;
        this.minY = y2 < this.minY ? y2 : this.minY;
        this.maxX = x3 > this.maxX ? x3 : this.maxX;
        this.maxY = y2 > this.maxY ? y2 : this.maxY;
        x3 = a2 * maxX + c2 * maxY + tx;
        y2 = b2 * maxX + d3 * maxY + ty;
        this.minX = x3 < this.minX ? x3 : this.minX;
        this.minY = y2 < this.minY ? y2 : this.minY;
        this.maxX = x3 > this.maxX ? x3 : this.maxX;
        this.maxY = y2 > this.maxY ? y2 : this.maxY;
      }
      fit(rect) {
        if (this.minX < rect.left)
          this.minX = rect.left;
        if (this.maxX > rect.right)
          this.maxX = rect.right;
        if (this.minY < rect.top)
          this.minY = rect.top;
        if (this.maxY > rect.bottom)
          this.maxY = rect.bottom;
        return this;
      }
      pad(paddingX, paddingY = paddingX) {
        this.minX -= paddingX;
        this.maxX += paddingX;
        this.minY -= paddingY;
        this.maxY += paddingY;
        return this;
      }
      ceil() {
        this.minX = Math.floor(this.minX);
        this.minY = Math.floor(this.minY);
        this.maxX = Math.ceil(this.maxX);
        this.maxY = Math.ceil(this.maxY);
        return this;
      }
      clone() {
        return new _Bounds(this.minX, this.minY, this.maxX, this.maxY);
      }
      scale(x3, y2 = x3) {
        this.minX *= x3;
        this.minY *= y2;
        this.maxX *= x3;
        this.maxY *= y2;
        return this;
      }
      get x() {
        return this.minX;
      }
      get y() {
        return this.minY;
      }
      get width() {
        return this.maxX - this.minX;
      }
      get height() {
        return this.maxY - this.minY;
      }
      get isPositive() {
        return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
      }
      get isValid() {
        return this.minX + this.minY !== Infinity;
      }
      /**
       * Adds screen vertices from array
       * @param vertexData - calculated vertices
       * @param beginOffset - begin offset
       * @param endOffset - end offset, excluded
       */
      addVertexData(vertexData, beginOffset, endOffset) {
        let minX = this.minX;
        let minY = this.minY;
        let maxX = this.maxX;
        let maxY = this.maxY;
        const matrix = this.matrix;
        const a2 = matrix.a;
        const b2 = matrix.b;
        const c2 = matrix.c;
        const d3 = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        for (let i3 = beginOffset; i3 < endOffset; i3 += 2) {
          const localX = vertexData[i3];
          const localY = vertexData[i3 + 1];
          const x3 = a2 * localX + c2 * localY + tx;
          const y2 = b2 * localX + d3 * localY + ty;
          minX = x3 < minX ? x3 : minX;
          minY = y2 < minY ? y2 : minY;
          maxX = x3 > maxX ? x3 : maxX;
          maxY = y2 > maxY ? y2 : maxY;
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      }
      toString() {
        return `[@pixi:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/utils/updateLocalTransform.mjs
function updateLocalTransform2(lt, container) {
  const scale3 = container._scale;
  const pivot = container._pivot;
  const position = container._position;
  const sx = scale3._x;
  const sy = scale3._y;
  const px = pivot._x;
  const py = pivot._y;
  lt.a = container._cx * sx;
  lt.b = container._sx * sx;
  lt.c = container._cy * sy;
  lt.d = container._sy * sy;
  lt.tx = position._x - (px * lt.a + py * lt.c);
  lt.ty = position._y - (px * lt.b + py * lt.d);
}
var init_updateLocalTransform2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/utils/updateLocalTransform.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs
function getGlobalBounds2(target, skipUpdateTransform, bounds) {
  bounds.clear();
  let parentTransform;
  if (target.parent) {
    if (!skipUpdateTransform) {
      parentTransform = updateTransformBackwards2(target, new Matrix3());
    } else {
      parentTransform = target.parent.worldTransform;
    }
  } else {
    parentTransform = Matrix3.IDENTITY;
  }
  _getGlobalBounds2(target, bounds, parentTransform, skipUpdateTransform);
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  return bounds;
}
function _getGlobalBounds2(target, bounds, parentTransform, skipUpdateTransform) {
  if (!target.visible || !target.measurable)
    return;
  let worldTransform;
  if (!skipUpdateTransform) {
    if (target.didChange) {
      updateLocalTransform2(target.localTransform, target);
    }
    worldTransform = Matrix3.shared.appendFrom(target.localTransform, parentTransform).clone();
  } else {
    worldTransform = target.worldTransform;
  }
  const parentBounds = bounds;
  const preserveBounds = !!target.effects.length;
  if (preserveBounds) {
    bounds = bounds.clone();
  }
  if (target.view) {
    bounds.setMatrix(worldTransform);
    target.view.addBounds(bounds);
  }
  for (let i3 = 0; i3 < target.children.length; i3++) {
    _getGlobalBounds2(target.children[i3], bounds, worldTransform, skipUpdateTransform);
  }
  if (preserveBounds) {
    for (let i3 = 0; i3 < target.effects.length; i3++) {
      target.effects[i3].addBounds?.(bounds);
    }
    parentBounds.setMatrix(Matrix3.IDENTITY);
    parentBounds.addBounds(bounds);
  }
}
function updateTransformBackwards2(target, parentTransform) {
  const parent = target.parent;
  if (parent) {
    updateTransformBackwards2(parent, parentTransform);
    if (parent.didChange) {
      updateLocalTransform2(parent.localTransform, parent);
    }
    parentTransform.append(parent.localTransform);
  }
  return parentTransform;
}
var init_getGlobalBounds2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs"() {
    init_Matrix2();
    init_updateLocalTransform2();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/logging/warn.mjs
function warn2(...args) {
  if (warnCount2 === maxWarnings2)
    return;
  warnCount2++;
  if (warnCount2 === maxWarnings2) {
    console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");
  } else {
    console.warn("PixiJS Warning: ", ...args);
  }
}
var warnCount2, maxWarnings2;
var init_warn2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/logging/warn.mjs"() {
    warnCount2 = 0;
    maxWarnings2 = 500;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs
function getLocalBounds2(target, bounds, relativeMatrix) {
  bounds.clear();
  relativeMatrix || (relativeMatrix = new Matrix3());
  if (target.view) {
    bounds.setMatrix(relativeMatrix);
    target.view.addBounds(bounds);
  }
  for (let i3 = 0; i3 < target.children.length; i3++) {
    _getLocalBounds2(target.children[i3], bounds, relativeMatrix, target);
  }
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  return bounds;
}
function _getLocalBounds2(target, bounds, parentTransform, rootContainer) {
  if (!target.visible || !target.measurable)
    return;
  if (target.didChange) {
    updateLocalTransform2(target.localTransform, target);
  }
  const localTransform = target.localTransform;
  const relativeTransform = Matrix3.shared.appendFrom(localTransform, parentTransform).clone();
  const parentBounds = bounds;
  const preserveBounds = !!target.effects.length;
  if (preserveBounds) {
    bounds = new Bounds2();
  }
  if (target.view) {
    bounds.setMatrix(relativeTransform);
    target.view.addBounds(bounds);
  }
  for (let i3 = 0; i3 < target.children.length; i3++) {
    _getLocalBounds2(target.children[i3], bounds, relativeTransform, rootContainer);
  }
  if (preserveBounds) {
    for (let i3 = 0; i3 < target.effects.length; i3++) {
      target.effects[i3].addLocalBounds?.(bounds, rootContainer);
    }
    parentBounds.setMatrix(Matrix3.IDENTITY);
    parentBounds.addBounds(bounds);
  }
}
var init_getLocalBounds2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs"() {
    init_Matrix2();
    init_updateLocalTransform2();
    init_Bounds2();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs
var tempBounds6, tempMatrix7, measureMixin2;
var init_measureMixin2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs"() {
    init_Matrix2();
    init_Bounds2();
    init_getGlobalBounds2();
    init_getLocalBounds2();
    tempBounds6 = new Bounds2();
    tempMatrix7 = new Matrix3();
    measureMixin2 = {
      get width() {
        return Math.abs(this.scale.x * getLocalBounds2(this, tempBounds6, tempMatrix7).width);
      },
      set width(value) {
        const localWidth = getLocalBounds2(this, tempBounds6, tempMatrix7).width;
        if (localWidth !== 0) {
          this.scale.x = value / localWidth;
        } else {
          this.scale.x = 1;
        }
      },
      get height() {
        return Math.abs(this.scale.y * getLocalBounds2(this, tempBounds6, tempMatrix7).height);
      },
      set height(value) {
        const localHeight = getLocalBounds2(this, tempBounds6, tempMatrix7).height;
        if (localHeight !== 0) {
          this.scale.y = value / localHeight;
        } else {
          this.scale.y = 1;
        }
      },
      /**
       * Retrieves the local bounds of the container as a Bounds object.
       * @param rect - Optional rectangle to store the result of the bounds calculation.
       * @returns - The bounding area.
       */
      getLocalBounds(rect) {
        const bounds = getLocalBounds2(this, new Bounds2(), tempMatrix7);
        return rect ? rect.copyFromBounds(bounds) : bounds.rectangle.clone();
      },
      /**
       * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.
       * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from
       *  being updated. This means the calculation returned MAY be out of date BUT will give you a
       *  nice performance boost.
       * @param rect - Optional rectangle to store the result of the bounds calculation.
       * @returns - The minimum axis-aligned rectangle in world space that fits around this object.
       */
      getBounds(skipUpdate, rect) {
        const bounds = getGlobalBounds2(this, skipUpdate, tempBounds6);
        return rect ? rect.copyFromBounds(bounds) : bounds.rectangle.clone();
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs
var onRenderMixin2;
var init_onRenderMixin2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs"() {
    onRenderMixin2 = {
      _onRender: null,
      set onRender(func2) {
        const layerGroup = this.layerGroup;
        if (!func2) {
          if (this._onRender) {
            layerGroup?.removeOnRender(this);
          }
          this._onRender = null;
          return;
        }
        if (!this._onRender) {
          layerGroup?.addOnRender(this);
        }
        this._onRender = func2;
      },
      get onRender() {
        return this._onRender;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs
function sortChildren2(a2, b2) {
  return a2._zIndex - b2._zIndex;
}
var sortMixin2;
var init_sortMixin2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs"() {
    sortMixin2 = {
      _zIndex: 0,
      sortDirty: false,
      sortableChildren: false,
      get zIndex() {
        return this._zIndex;
      },
      /** The depth of the object. Setting this value, will automatically set the parent to be sortable */
      set zIndex(value) {
        if (this._zIndex === value)
          return;
        this._zIndex = value;
        this.depthOfChildModified();
      },
      depthOfChildModified() {
        if (this.parent) {
          this.parent.sortableChildren = true;
          this.parent.sortDirty = true;
        }
        if (this.layerGroup && !this.isLayerRoot) {
          this.layerGroup.structureDidChange = true;
        }
      },
      sortChildren() {
        if (!this.sortDirty)
          return;
        this.sortDirty = false;
        this.children.sort(sortChildren2);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs
var toLocalGlobalMixin2;
var init_toLocalGlobalMixin2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs"() {
    init_Matrix2();
    init_Point2();
    init_getGlobalBounds2();
    init_updateLocalTransform2();
    toLocalGlobalMixin2 = {
      /**
       * Returns the global position of the container.
       * @param point - The optional point to write the global value to.
       * @param skipUpdate - Should we skip the update transform.
       * @returns - The updated point.
       * @memberof Container#
       */
      getGlobalPosition(point = new Point3(), skipUpdate = false) {
        if (this.parent) {
          this.parent.toGlobal(this._position, point, skipUpdate);
        } else {
          point.x = this._position.x;
          point.y = this._position.y;
        }
        return point;
      },
      /**
       * Calculates the global position of the container.
       * @param position - The world origin to calculate from.
       * @param point - A Point object in which to store the value, optional
       *  (otherwise will create a new Point).
       * @param skipUpdate - Should we skip the update transform.
       * @returns - A point object representing the position of this object.
       * @memberof Container#
       */
      toGlobal(position, point, skipUpdate = false) {
        if (!skipUpdate) {
          if (this.didChange) {
            updateLocalTransform2(this.localTransform, this);
          }
          const globalMatrix = updateTransformBackwards2(this, new Matrix3());
          globalMatrix.append(this.localTransform);
          return globalMatrix.apply(position, point);
        }
        return this.worldTransform.apply(position, point);
      },
      /**
       * Calculates the local position of the container relative to another point.
       * @param position - The world origin to calculate from.
       * @param from - The Container to calculate the global position from.
       * @param point - A Point object in which to store the value, optional
       *  (otherwise will create a new Point).
       * @param skipUpdate - Should we skip the update transform
       * @returns - A point object representing the position of this object
       * @memberof Container#
       */
      toLocal(position, from, point, skipUpdate) {
        if (from) {
          position = from.toGlobal(position, point, skipUpdate);
        }
        if (!skipUpdate) {
          if (this.didChange) {
            updateLocalTransform2(this.localTransform, this);
          }
          const globalMatrix = updateTransformBackwards2(this, new Matrix3());
          globalMatrix.append(this.localTransform);
          return globalMatrix.applyInverse(position, point);
        }
        return this.worldTransform.applyInverse(position, point);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs
var InstructionSet2;
var init_InstructionSet2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs"() {
    init_uid2();
    InstructionSet2 = class {
      constructor() {
        this.uid = uid3("instructionSet");
        this.instructions = [];
        this.instructionSize = 0;
      }
      reset() {
        this.instructionSize = 0;
      }
      add(instruction) {
        this.instructions[this.instructionSize++] = instruction;
      }
      log() {
        this.instructions.length = this.instructionSize;
        console.table(this.instructions, ["type", "action"]);
      }
      lastInstruction() {
        return this.instructions[this.instructionSize - 1];
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/LayerGroup.mjs
var LayerGroup2;
var init_LayerGroup2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/LayerGroup.mjs"() {
    init_Matrix2();
    init_InstructionSet2();
    LayerGroup2 = class {
      constructor(root) {
        this.type = "layer";
        this.root = null;
        this.canBundle = false;
        this.layerGroupParent = null;
        this.layerGroupChildren = [];
        this._children = [];
        this.worldTransform = new Matrix3();
        this.worldColor = 4294967295;
        this.childrenToUpdate = /* @__PURE__ */ Object.create(null);
        this.updateTick = 0;
        this.childrenRenderablesToUpdate = { list: [], index: 0 };
        this.structureDidChange = true;
        this.instructionSet = new InstructionSet2();
        this._onRenderContainers = [];
        this.root = root;
        this.addChild(root);
      }
      get localTransform() {
        return this.root.localTransform;
      }
      get layerTransform() {
        return this.root.layerTransform;
      }
      addLayerGroupChild(layerGroupChild) {
        if (layerGroupChild.layerGroupParent) {
          layerGroupChild.layerGroupParent._removeLayerGroupChild(layerGroupChild);
        }
        layerGroupChild.layerGroupParent = this;
        this.onChildUpdate(layerGroupChild.root);
        this.layerGroupChildren.push(layerGroupChild);
      }
      _removeLayerGroupChild(layerGroupChild) {
        if (layerGroupChild.root.didChange) {
          this._removeChildFromUpdate(layerGroupChild.root);
        }
        const index = this.layerGroupChildren.indexOf(layerGroupChild);
        if (index > -1) {
          this.layerGroupChildren.splice(index, 1);
        }
        layerGroupChild.layerGroupParent = null;
      }
      addChild(child) {
        this.structureDidChange = true;
        if (child !== this.root) {
          this._children.push(child);
          child.updateTick = -1;
          if (child.parent === this.root) {
            child.relativeLayerDepth = 1;
          } else {
            child.relativeLayerDepth = child.parent.relativeLayerDepth + 1;
          }
          if (child._onRender) {
            this.addOnRender(child);
          }
        }
        if (child.layerGroup) {
          if (child.layerGroup.root === child) {
            this.addLayerGroupChild(child.layerGroup);
            return;
          }
        } else {
          child.layerGroup = this;
          child.didChange = true;
        }
        const children = child.children;
        if (!child.isLayerRoot) {
          this.onChildUpdate(child);
        }
        for (let i3 = 0; i3 < children.length; i3++) {
          this.addChild(children[i3]);
        }
      }
      removeChild(child) {
        this.structureDidChange = true;
        if (child._onRender) {
          this.removeOnRender(child);
        }
        if (child.layerGroup.root !== child) {
          const children = child.children;
          for (let i3 = 0; i3 < children.length; i3++) {
            this.removeChild(children[i3]);
          }
          if (child.didChange) {
            child.layerGroup._removeChildFromUpdate(child);
          }
          child.layerGroup = null;
        } else {
          this._removeLayerGroupChild(child.layerGroup);
        }
        const index = this._children.indexOf(child);
        if (index > -1) {
          this._children.splice(index, 1);
        }
      }
      onChildUpdate(child) {
        let childrenToUpdate = this.childrenToUpdate[child.relativeLayerDepth];
        if (!childrenToUpdate) {
          childrenToUpdate = this.childrenToUpdate[child.relativeLayerDepth] = {
            index: 0,
            list: []
          };
        }
        childrenToUpdate.list[childrenToUpdate.index++] = child;
      }
      // SHOULD THIS BE HERE?
      updateRenderable(container) {
        if (container.layerVisibleRenderable < 3)
          return;
        container.didViewUpdate = false;
        this.instructionSet.renderPipes[container.view.renderPipeId].updateRenderable(container);
      }
      onChildViewUpdate(child) {
        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;
      }
      _removeChildFromUpdate(child) {
        const childrenToUpdate = this.childrenToUpdate[child.relativeLayerDepth];
        if (!childrenToUpdate) {
          return;
        }
        const index = childrenToUpdate.list.indexOf(child);
        if (index > -1) {
          childrenToUpdate.list.splice(index, 1);
        }
        childrenToUpdate.index--;
      }
      get isRenderable() {
        const worldAlpha = this.worldColor >> 24 & 255;
        return this.root.localVisibleRenderable === 3 && worldAlpha > 0;
      }
      /**
       * adding a container to the onRender list will make sure the user function
       * passed in to the user defined 'onRender` callBack
       * @param container - the container to add to the onRender list
       */
      addOnRender(container) {
        this._onRenderContainers.push(container);
      }
      removeOnRender(container) {
        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);
      }
      runOnRender() {
        this._onRenderContainers.forEach((container) => {
          container._onRender();
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs
function definedProps2(obj) {
  return Object.fromEntries(
    Object.entries(obj).filter(([_k, v3]) => v3 !== void 0)
  );
}
var init_definedProps2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/Container.mjs
var defaultSkew2, defaultPivot2, defaultScale2, UPDATE_COLOR2, UPDATE_BLEND2, UPDATE_VISIBLE2, Container4;
var init_Container2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/Container.mjs"() {
    init_eventemitter3();
    init_Color2();
    init_Matrix2();
    init_const11();
    init_ObservablePoint2();
    init_uid2();
    init_deprecation2();
    init_childrenHelperMixin2();
    init_effectsMixin2();
    init_findMixin2();
    init_measureMixin2();
    init_onRenderMixin2();
    init_sortMixin2();
    init_toLocalGlobalMixin2();
    init_LayerGroup2();
    init_definedProps2();
    defaultSkew2 = new ObservablePoint3(null);
    defaultPivot2 = new ObservablePoint3(null);
    defaultScale2 = new ObservablePoint3(null, 1, 1);
    UPDATE_COLOR2 = 1;
    UPDATE_BLEND2 = 2;
    UPDATE_VISIBLE2 = 4;
    Container4 = class _Container extends eventemitter3_default {
      constructor(options = {}) {
        super();
        this.uid = uid3("renderable");
        this._updateFlags = 15;
        this.isLayerRoot = false;
        this.layerGroup = null;
        this.didChange = false;
        this.didViewUpdate = false;
        this.relativeLayerDepth = 0;
        this.children = [];
        this.parent = null;
        this.includeInBuild = true;
        this.measurable = true;
        this.isSimple = true;
        this.updateTick = -1;
        this.localTransform = new Matrix3();
        this.layerTransform = new Matrix3();
        this.destroyed = false;
        this._position = new ObservablePoint3(this, 0, 0);
        this._scale = defaultScale2;
        this._pivot = defaultPivot2;
        this._skew = defaultSkew2;
        this._cx = 1;
        this._sx = 0;
        this._cy = 0;
        this._sy = 1;
        this._rotation = 0;
        this.localColor = 4294967295;
        this.layerColor = 4294967295;
        this.localBlendMode = "inherit";
        this.layerBlendMode = "normal";
        this.localVisibleRenderable = 3;
        this.layerVisibleRenderable = 3;
        if (options.view) {
          this.view = options.view;
          this.view.owner = this;
          options.view = void 0;
        }
        Object.assign(this, definedProps2(options));
        this.children = [];
        options.children?.forEach((child) => this.addChild(child));
        this.effects = [];
        options.effects?.forEach((effect) => this.addEffect(effect));
      }
      /**
       * Mixes all enumerable properties and methods from a source object to Container.
       * @param source - The source of properties and methods to mix in.
       */
      static mixin(source3) {
        Object.defineProperties(_Container.prototype, Object.getOwnPropertyDescriptors(source3));
      }
      /**
       * Adds one or more children to the container.
       *
       * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
       * @param {...Container} children - The Container(s) to add to the container
       * @returns {Container} - The first child that was added.
       */
      addChild(...children) {
        if (!this.allowChildren) {
          deprecation3(v8_0_02, "addChild: Only Containers will be allowed to add children in v8.0.0");
        }
        if (children.length > 1) {
          for (let i3 = 0; i3 < children.length; i3++) {
            this.addChild(children[i3]);
          }
          return children[0];
        }
        const child = children[0];
        if (child.parent === this) {
          this.children.splice(this.children.indexOf(child), 1);
          this.children.push(child);
          if (this.layerGroup && !this.isLayerRoot) {
            this.layerGroup.structureDidChange = true;
          }
          return child;
        }
        if (child.parent) {
          child.parent.removeChild(child);
        }
        this.children.push(child);
        if (this.sortableChildren)
          this.sortDirty = true;
        child.parent = this;
        child.didChange = true;
        child.didViewUpdate = false;
        child._updateFlags = 15;
        if (this.layerGroup) {
          this.layerGroup.addChild(child);
        }
        this.emit("childAdded", child, this, this.children.length - 1);
        child.emit("added", this);
        if (child._zIndex !== 0) {
          child.depthOfChildModified();
        }
        return child;
      }
      /**
       * Removes one or more children from the container.
       * @param {...Container} children - The Container(s) to remove
       * @returns {Container} The first child that was removed.
       */
      removeChild(...children) {
        if (children.length > 1) {
          for (let i3 = 0; i3 < children.length; i3++) {
            this.removeChild(children[i3]);
          }
          return children[0];
        }
        const child = children[0];
        const index = this.children.indexOf(child);
        if (index > -1) {
          this.children.splice(index, 1);
          if (this.layerGroup) {
            this.layerGroup.removeChild(child);
          }
        }
        child.parent = null;
        this.emit("childRemoved", child, this, index);
        child.emit("removed", this);
        return child;
      }
      /**
       * @param point
       * @internal
       */
      onUpdate(point) {
        if (point) {
          if (point === this._skew) {
            this._updateSkew();
          }
        }
        if (this.didChange)
          return;
        this.didChange = true;
        if (this.isLayerRoot) {
          const layerGroupParent = this.layerGroup.layerGroupParent;
          if (layerGroupParent) {
            layerGroupParent.onChildUpdate(this);
          }
        } else if (this.layerGroup) {
          this.layerGroup.onChildUpdate(this);
        }
      }
      /** @internal */
      onViewUpdate() {
        if (this.didViewUpdate)
          return;
        this.didViewUpdate = true;
        if (this.layerGroup) {
          this.layerGroup.onChildViewUpdate(this);
        }
      }
      set layer(value) {
        if (this.isLayerRoot && value === false) {
          throw new Error("[Pixi] cannot undo a layer just yet");
        }
        if (value) {
          this.enableLayer();
        }
      }
      get layer() {
        return this.isLayerRoot;
      }
      enableLayer() {
        if (this.layerGroup && this.layerGroup.root === this)
          return;
        this.isLayerRoot = true;
        const parentLayerGroup = this.layerGroup;
        if (parentLayerGroup) {
          parentLayerGroup.removeChild(this);
        }
        this.layerGroup = new LayerGroup2(this);
        if (parentLayerGroup) {
          for (let i3 = 0; i3 < parentLayerGroup.layerGroupChildren.length; i3++) {
            const childLayerGroup = parentLayerGroup.layerGroupChildren[i3];
            let parent = childLayerGroup.root;
            while (parent) {
              if (parent === this) {
                this.layerGroup.addLayerGroupChild(childLayerGroup);
                break;
              }
              parent = parent.parent;
            }
          }
          parentLayerGroup.addLayerGroupChild(this.layerGroup);
        }
        this._updateIsSimple();
      }
      /**
       * @ignore
       */
      _updateIsSimple() {
        this.isSimple = !this.isLayerRoot && this.effects.length === 0;
      }
      get worldTransform() {
        this._worldTransform || (this._worldTransform = new Matrix3());
        if (this.layerGroup) {
          if (this.isLayerRoot) {
            this._worldTransform.copyFrom(this.layerGroup.worldTransform);
          } else {
            this._worldTransform.appendFrom(this.layerTransform, this.layerGroup.worldTransform);
          }
        }
        return this._worldTransform;
      }
      /// ////// transform related stuff
      /**
       * The position of the container on the x axis relative to the local coordinates of the parent.
       * An alias to position.x
       */
      get x() {
        return this._position.x;
      }
      set x(value) {
        this._position.x = value;
      }
      /**
       * The position of the container on the y axis relative to the local coordinates of the parent.
       * An alias to position.y
       */
      get y() {
        return this._position.y;
      }
      set y(value) {
        this._position.y = value;
      }
      get position() {
        return this._position;
      }
      set position(value) {
        this._position.copyFrom(value);
      }
      /**
       * The rotation of the object in radians.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get rotation() {
        return this._rotation;
      }
      set rotation(value) {
        if (this._rotation !== value) {
          this._rotation = value;
          this.onUpdate(this._skew);
        }
      }
      /**
       * The angle of the object in degrees.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get angle() {
        return this.rotation * RAD_TO_DEG3;
      }
      set angle(value) {
        this.rotation = value * DEG_TO_RAD3;
      }
      get pivot() {
        if (this._pivot === defaultPivot2) {
          this._pivot = new ObservablePoint3(this, 0, 0);
        }
        return this._pivot;
      }
      set pivot(value) {
        if (this._pivot === defaultPivot2) {
          this._pivot = new ObservablePoint3(this, 0, 0);
        }
        this._pivot.copyFrom(value);
      }
      get skew() {
        if (this._skew === defaultSkew2) {
          this._skew = new ObservablePoint3(this, 0, 0);
        }
        return this._skew;
      }
      get scale() {
        if (this._scale === defaultScale2) {
          this._scale = new ObservablePoint3(this, 1, 1);
        }
        return this._scale;
      }
      set scale(value) {
        if (this._scale === defaultScale2) {
          this._scale = new ObservablePoint3(this, 0, 0);
        }
        this._scale.copyFrom(value);
      }
      /** Called when the skew or the rotation changes. */
      _updateSkew() {
        const rotation = this._rotation;
        const skew = this._skew;
        this._cx = Math.cos(rotation + skew._y);
        this._sx = Math.sin(rotation + skew._y);
        this._cy = -Math.sin(rotation - skew._x);
        this._sy = Math.cos(rotation - skew._x);
      }
      /// ///// color related stuff
      set alpha(value) {
        value = value * 255 | 0;
        if (value === (this.localColor >> 24 & 255))
          return;
        this.localColor = this.localColor & 16777215 | value << 24;
        this._updateFlags |= UPDATE_COLOR2;
        this.onUpdate();
      }
      get alpha() {
        return (this.localColor >> 24 & 255) / 255;
      }
      set tint(value) {
        const tempColor = Color3.shared.setValue(value);
        const bgr = tempColor.toBgrNumber();
        if (bgr === (this.localColor & 16777215))
          return;
        this.localColor = this.localColor & 4278190080 | bgr & 16777215;
        this._updateFlags |= UPDATE_COLOR2;
        this.onUpdate();
      }
      get tint() {
        const bgr = this.localColor & 16777215;
        return ((bgr & 255) << 16) + (bgr & 65280) + (bgr >> 16 & 255);
      }
      /// //////////////// blend related stuff
      set blendMode(value) {
        if (this.localBlendMode === value)
          return;
        if (this.layerGroup && !this.isLayerRoot) {
          this.layerGroup.structureDidChange = true;
        }
        this._updateFlags |= UPDATE_BLEND2;
        this.localBlendMode = value;
        this.onUpdate();
      }
      get blendMode() {
        return this.localBlendMode;
      }
      /// ///////// VISIBILITY / RENDERABLE /////////////////
      get visible() {
        return !!(this.localVisibleRenderable & 2);
      }
      // visible -  the renderable is not shown, also the transform is not updated
      set visible(value) {
        const valueNumber = value ? 1 : 0;
        if ((this.localVisibleRenderable & 2) >> 1 === valueNumber)
          return;
        if (this.layerGroup && !this.isLayerRoot) {
          this.layerGroup.structureDidChange = true;
        }
        this._updateFlags |= UPDATE_VISIBLE2;
        this.localVisibleRenderable = this.localVisibleRenderable & 1 | valueNumber << 1;
        this.onUpdate();
      }
      get renderable() {
        return !!(this.localVisibleRenderable & 1);
      }
      set renderable(value) {
        const valueNumber = value ? 1 : 0;
        if ((this.localVisibleRenderable & 1) === valueNumber)
          return;
        this.localVisibleRenderable = this.localVisibleRenderable & 2 | valueNumber;
        this._updateFlags |= UPDATE_VISIBLE2;
        if (this.layerGroup && !this.isLayerRoot) {
          this.layerGroup.structureDidChange = true;
        }
        this.onUpdate();
      }
      get isRenderable() {
        const worldAlpha = this.layerColor >> 24 & 255;
        return this.localVisibleRenderable === 3 && worldAlpha > 0;
      }
      /**
       * Removes all internal references and listeners as well as removes children from the display list.
       * Do not use a Container after calling `destroy`.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
       *  method called as well. 'options' will be passed on to those calls.
       * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children
       * is set to true it should destroy the texture of the child sprite
       * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
       * If options.children is set to true it should destroy the texture source of the child sprite
       * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
       * If options.children is set to true it should destroy the context of the child graphics
       */
      destroy(options = false) {
        if (this.destroyed)
          return;
        this.destroyed = true;
        this.removeFromParent();
        this.parent = null;
        this._mask = null;
        this._filters = null;
        this.effects = null;
        this._position = null;
        this._scale = null;
        this._pivot = null;
        this._skew = null;
        this.emit("destroyed");
        this.removeAllListeners();
        const destroyChildren = typeof options === "boolean" ? options : options?.children;
        const oldChildren = this.removeChildren(0, this.children.length);
        if (destroyChildren) {
          for (let i3 = 0; i3 < oldChildren.length; ++i3) {
            oldChildren[i3].destroy(options);
          }
        }
        if (this.view) {
          this.view.destroy(options);
          this.view.owner = null;
        }
      }
    };
    Container4.mixin(childrenHelperMixin2);
    Container4.mixin(toLocalGlobalMixin2);
    Container4.mixin(onRenderMixin2);
    Container4.mixin(measureMixin2);
    Container4.mixin(effectsMixin2);
    Container4.mixin(findMixin2);
    Container4.mixin(sortMixin2);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/settings/utils/isMobile.mjs
var isMobileCall3, isMobile4;
var init_isMobile3 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/settings/utils/isMobile.mjs"() {
    init_esm();
    isMobileCall3 = isMobile.default ?? isMobile;
    isMobile4 = isMobileCall3(globalThis.navigator);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs
var accessibilityTarget2;
var init_accessibilityTarget2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs"() {
    accessibilityTarget2 = {
      /**
       *  Flag for if the object is accessible. If true AccessibilityManager will overlay a
       *   shadow div with attributes set
       * @member {boolean}
       * @memberof Container#
       */
      accessible: false,
      /**
       * Sets the title attribute of the shadow div
       * If accessibleTitle AND accessibleHint has not been this will default to 'container [tabIndex]'
       * @member {?string}
       * @memberof Container#
       */
      accessibleTitle: null,
      /**
       * Sets the aria-label attribute of the shadow div
       * @member {string}
       * @memberof Container#
       */
      accessibleHint: null,
      /**
       * @member {number}
       * @memberof Container#
       * @private
       * @todo Needs docs.
       */
      tabIndex: 0,
      /**
       * @member {boolean}
       * @memberof Container#
       * @todo Needs docs.
       */
      _accessibleActive: false,
      /**
       * @member {boolean}
       * @memberof Container#
       * @todo Needs docs.
       */
      _accessibleDiv: null,
      /**
       * Specify the type of div the accessible layer is. Screen readers treat the element differently
       * depending on this type. Defaults to button.
       * @member {string}
       * @memberof Container#
       * @default 'button'
       */
      accessibleType: "button",
      /**
       * Specify the pointer-events the accessible div will use
       * Defaults to auto.
       * @member {string}
       * @memberof Container#
       * @default 'auto'
       */
      accessiblePointerEvents: "auto",
      /**
       * Setting to false will prevent any children inside this container to
       * be accessible. Defaults to true.
       * @member {boolean}
       * @memberof Container#
       * @default true
       */
      accessibleChildren: true,
      renderId: -1
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs
var KEY_CODE_TAB2, DIV_TOUCH_SIZE2, DIV_TOUCH_POS_X2, DIV_TOUCH_POS_Y2, DIV_TOUCH_ZINDEX2, DIV_HOOK_SIZE2, DIV_HOOK_POS_X2, DIV_HOOK_POS_Y2, DIV_HOOK_ZINDEX2, AccessibilitySystem2;
var init_AccessibilitySystem2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs"() {
    init_FederatedEvent2();
    init_Extensions2();
    init_Container2();
    init_isMobile3();
    init_removeItems2();
    init_accessibilityTarget2();
    Container4.mixin(accessibilityTarget2);
    KEY_CODE_TAB2 = 9;
    DIV_TOUCH_SIZE2 = 100;
    DIV_TOUCH_POS_X2 = 0;
    DIV_TOUCH_POS_Y2 = 0;
    DIV_TOUCH_ZINDEX2 = 2;
    DIV_HOOK_SIZE2 = 1;
    DIV_HOOK_POS_X2 = -1e3;
    DIV_HOOK_POS_Y2 = -1e3;
    DIV_HOOK_ZINDEX2 = 2;
    AccessibilitySystem2 = class {
      // 2fps
      // eslint-disable-next-line jsdoc/require-param
      /**
       * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer
       */
      // eslint-disable-next-line @typescript-eslint/no-parameter-properties
      constructor(renderer, _mobileInfo = isMobile4) {
        this._mobileInfo = _mobileInfo;
        this.debug = false;
        this._isActive = false;
        this._isMobileAccessibility = false;
        this._pool = [];
        this._renderId = 0;
        this._children = [];
        this._androidUpdateCount = 0;
        this._androidUpdateFrequency = 500;
        this._hookDiv = null;
        if (_mobileInfo.tablet || _mobileInfo.phone) {
          this._createTouchHook();
        }
        const div = document.createElement("div");
        div.style.width = `${DIV_TOUCH_SIZE2}px`;
        div.style.height = `${DIV_TOUCH_SIZE2}px`;
        div.style.position = "absolute";
        div.style.top = `${DIV_TOUCH_POS_X2}px`;
        div.style.left = `${DIV_TOUCH_POS_Y2}px`;
        div.style.zIndex = DIV_TOUCH_ZINDEX2.toString();
        this._div = div;
        this._renderer = renderer;
        this._onKeyDown = this._onKeyDown.bind(this);
        this._onMouseMove = this._onMouseMove.bind(this);
        globalThis.addEventListener("keydown", this._onKeyDown, false);
      }
      /**
       * Value of `true` if accessibility is currently active and accessibility layers are showing.
       * @member {boolean}
       * @readonly
       */
      get isActive() {
        return this._isActive;
      }
      /**
       * Value of `true` if accessibility is enabled for touch devices.
       * @member {boolean}
       * @readonly
       */
      get isMobileAccessibility() {
        return this._isMobileAccessibility;
      }
      get hookDiv() {
        return this._hookDiv;
      }
      /**
       * Creates the touch hooks.
       * @private
       */
      _createTouchHook() {
        const hookDiv = document.createElement("button");
        hookDiv.style.width = `${DIV_HOOK_SIZE2}px`;
        hookDiv.style.height = `${DIV_HOOK_SIZE2}px`;
        hookDiv.style.position = "absolute";
        hookDiv.style.top = `${DIV_HOOK_POS_X2}px`;
        hookDiv.style.left = `${DIV_HOOK_POS_Y2}px`;
        hookDiv.style.zIndex = DIV_HOOK_ZINDEX2.toString();
        hookDiv.style.backgroundColor = "#FF0000";
        hookDiv.title = "select to enable accessibility for this content";
        hookDiv.addEventListener("focus", () => {
          this._isMobileAccessibility = true;
          this._activate();
          this._destroyTouchHook();
        });
        document.body.appendChild(hookDiv);
        this._hookDiv = hookDiv;
      }
      /**
       * Destroys the touch hooks.
       * @private
       */
      _destroyTouchHook() {
        if (!this._hookDiv) {
          return;
        }
        document.body.removeChild(this._hookDiv);
        this._hookDiv = null;
      }
      /**
       * Activating will cause the Accessibility layer to be shown.
       * This is called when a user presses the tab key.
       * @private
       */
      _activate() {
        if (this._isActive) {
          return;
        }
        this._isActive = true;
        globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
        globalThis.removeEventListener("keydown", this._onKeyDown, false);
        this._renderer.runners.postrender.add(this);
        this._renderer.view.canvas.parentNode?.appendChild(this._div);
      }
      /**
       * Deactivating will cause the Accessibility layer to be hidden.
       * This is called when a user moves the mouse.
       * @private
       */
      _deactivate() {
        if (!this._isActive || this._isMobileAccessibility) {
          return;
        }
        this._isActive = false;
        globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
        globalThis.addEventListener("keydown", this._onKeyDown, false);
        this._renderer.runners.postrender.remove(this);
        this._div.parentNode?.removeChild(this._div);
      }
      /**
       * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
       * @private
       * @param {Container} container - The Container to check.
       */
      _updateAccessibleObjects(container) {
        if (!container.visible || !container.accessibleChildren) {
          return;
        }
        if (container.accessible && container.isInteractive()) {
          if (!container._accessibleActive) {
            this._addChild(container);
          }
          container.renderId = this._renderId;
        }
        const children = container.children;
        if (children) {
          for (let i3 = 0; i3 < children.length; i3++) {
            this._updateAccessibleObjects(children[i3]);
          }
        }
      }
      /**
       * Runner init called, view is available at this point.
       * @ignore
       */
      init(options) {
        this.debug = options?.debug ?? this.debug;
        this._renderer.runners.postrender.remove(this);
      }
      /**
       * Runner postrender was called, ensure that all divs are mapped correctly to their DisplayObjects.
       * Only fires while active.
       * @ignore
       */
      postrender() {
        const now = performance.now();
        if (this._mobileInfo.android.device && now < this._androidUpdateCount) {
          return;
        }
        this._androidUpdateCount = now + this._androidUpdateFrequency;
        if (!this._renderer.renderingToScreen || !this._renderer.view.canvas) {
          return;
        }
        if (this._renderer.lastObjectRendered) {
          this._updateAccessibleObjects(this._renderer.lastObjectRendered);
        }
        const { x: x3, y: y2, width, height } = this._renderer.view.canvas.getBoundingClientRect();
        const { width: viewWidth, height: viewHeight, resolution } = this._renderer;
        const sx = width / viewWidth * resolution;
        const sy = height / viewHeight * resolution;
        let div = this._div;
        div.style.left = `${x3}px`;
        div.style.top = `${y2}px`;
        div.style.width = `${viewWidth}px`;
        div.style.height = `${viewHeight}px`;
        for (let i3 = 0; i3 < this._children.length; i3++) {
          const child = this._children[i3];
          if (child.renderId !== this._renderId) {
            child._accessibleActive = false;
            removeItems3(this._children, i3, 1);
            this._div.removeChild(child._accessibleDiv);
            this._pool.push(child._accessibleDiv);
            child._accessibleDiv = null;
            i3--;
          } else {
            div = child._accessibleDiv;
            let hitArea = child.hitArea;
            const wt = child.worldTransform;
            if (child.hitArea) {
              div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;
              div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;
              div.style.width = `${hitArea.width * wt.a * sx}px`;
              div.style.height = `${hitArea.height * wt.d * sy}px`;
            } else {
              hitArea = child.getBounds();
              this.capHitArea(hitArea);
              div.style.left = `${hitArea.x * sx}px`;
              div.style.top = `${hitArea.y * sy}px`;
              div.style.width = `${hitArea.width * sx}px`;
              div.style.height = `${hitArea.height * sy}px`;
              if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
                div.title = child.accessibleTitle;
              }
              if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
                div.setAttribute("aria-label", child.accessibleHint);
              }
            }
            if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
              div.title = child.accessibleTitle;
              div.tabIndex = child.tabIndex;
              if (this.debug) {
                this.updateDebugHTML(div);
              }
            }
          }
        }
        this._renderId++;
      }
      /**
       * private function that will visually add the information to the
       * accessibility div
       * @param {HTMLElement} div -
       */
      updateDebugHTML(div) {
        div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
      }
      /**
       * Adjust the hit area based on the bounds of a display object
       * @param {Rectangle} hitArea - Bounds of the child
       */
      capHitArea(hitArea) {
        if (hitArea.x < 0) {
          hitArea.width += hitArea.x;
          hitArea.x = 0;
        }
        if (hitArea.y < 0) {
          hitArea.height += hitArea.y;
          hitArea.y = 0;
        }
        const { width: viewWidth, height: viewHeight } = this._renderer;
        if (hitArea.x + hitArea.width > viewWidth) {
          hitArea.width = viewWidth - hitArea.x;
        }
        if (hitArea.y + hitArea.height > viewHeight) {
          hitArea.height = viewHeight - hitArea.y;
        }
      }
      /**
       * Adds a Container to the accessibility manager
       * @private
       * @param {Container} container - The child to make accessible.
       */
      _addChild(container) {
        let div = this._pool.pop();
        if (!div) {
          div = document.createElement("button");
          div.style.width = `${DIV_TOUCH_SIZE2}px`;
          div.style.height = `${DIV_TOUCH_SIZE2}px`;
          div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
          div.style.position = "absolute";
          div.style.zIndex = DIV_TOUCH_ZINDEX2.toString();
          div.style.borderStyle = "none";
          if (navigator.userAgent.toLowerCase().includes("chrome")) {
            div.setAttribute("aria-live", "off");
          } else {
            div.setAttribute("aria-live", "polite");
          }
          if (navigator.userAgent.match(/rv:.*Gecko\//)) {
            div.setAttribute("aria-relevant", "additions");
          } else {
            div.setAttribute("aria-relevant", "text");
          }
          div.addEventListener("click", this._onClick.bind(this));
          div.addEventListener("focus", this._onFocus.bind(this));
          div.addEventListener("focusout", this._onFocusOut.bind(this));
        }
        div.style.pointerEvents = container.accessiblePointerEvents;
        div.type = container.accessibleType;
        if (container.accessibleTitle && container.accessibleTitle !== null) {
          div.title = container.accessibleTitle;
        } else if (!container.accessibleHint || container.accessibleHint === null) {
          div.title = `container ${container.tabIndex}`;
        }
        if (container.accessibleHint && container.accessibleHint !== null) {
          div.setAttribute("aria-label", container.accessibleHint);
        }
        if (this.debug) {
          this.updateDebugHTML(div);
        }
        container._accessibleActive = true;
        container._accessibleDiv = div;
        div.container = container;
        this._children.push(container);
        this._div.appendChild(container._accessibleDiv);
        container._accessibleDiv.tabIndex = container.tabIndex;
      }
      /**
       * Dispatch events with the EventSystem.
       * @param e
       * @param type
       * @private
       */
      _dispatchEvent(e3, type2) {
        const { container: target } = e3.target;
        const boundary = this._renderer.events.rootBoundary;
        const event = Object.assign(new FederatedEvent2(boundary), { target });
        boundary.rootTarget = this._renderer.lastObjectRendered;
        type2.forEach((type22) => boundary.dispatchEvent(event, type22));
      }
      /**
       * Maps the div button press to pixi's EventSystem (click)
       * @private
       * @param {MouseEvent} e - The click event.
       */
      _onClick(e3) {
        this._dispatchEvent(e3, ["click", "pointertap", "tap"]);
      }
      /**
       * Maps the div focus events to pixi's EventSystem (mouseover)
       * @private
       * @param {FocusEvent} e - The focus event.
       */
      _onFocus(e3) {
        if (!e3.target.getAttribute("aria-live")) {
          e3.target.setAttribute("aria-live", "assertive");
        }
        this._dispatchEvent(e3, ["mouseover"]);
      }
      /**
       * Maps the div focus events to pixi's EventSystem (mouseout)
       * @private
       * @param {FocusEvent} e - The focusout event.
       */
      _onFocusOut(e3) {
        if (!e3.target.getAttribute("aria-live")) {
          e3.target.setAttribute("aria-live", "polite");
        }
        this._dispatchEvent(e3, ["mouseout"]);
      }
      /**
       * Is called when a key is pressed
       * @private
       * @param {KeyboardEvent} e - The keydown event.
       */
      _onKeyDown(e3) {
        if (e3.keyCode !== KEY_CODE_TAB2) {
          return;
        }
        this._activate();
      }
      /**
       * Is called when the mouse moves across the renderer element
       * @private
       * @param {MouseEvent} e - The mouse event.
       */
      _onMouseMove(e3) {
        if (e3.movementX === 0 && e3.movementY === 0) {
          return;
        }
        this._deactivate();
      }
      /** Destroys the accessibility manager */
      destroy() {
        this._destroyTouchHook();
        this._div = null;
        globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
        globalThis.removeEventListener("keydown", this._onKeyDown);
        this._pool = null;
        this._children = null;
        this._renderer = null;
      }
    };
    AccessibilitySystem2.extension = {
      type: [
        ExtensionType3.WebGLSystem,
        ExtensionType3.WebGPUSystem
      ],
      name: "accessibility"
    };
    extensions3.add(AccessibilitySystem2);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/accessibility/init.mjs
var init_init7 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/accessibility/init.mjs"() {
    init_Extensions2();
    init_Container2();
    init_AccessibilitySystem2();
    init_accessibilityTarget2();
    extensions3.add(AccessibilitySystem2);
    Container4.mixin(accessibilityTarget2);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/ticker/const.mjs
var UPDATE_PRIORITY3;
var init_const12 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/ticker/const.mjs"() {
    UPDATE_PRIORITY3 = /* @__PURE__ */ ((UPDATE_PRIORITY22) => {
      UPDATE_PRIORITY22[UPDATE_PRIORITY22["INTERACTION"] = 50] = "INTERACTION";
      UPDATE_PRIORITY22[UPDATE_PRIORITY22["HIGH"] = 25] = "HIGH";
      UPDATE_PRIORITY22[UPDATE_PRIORITY22["NORMAL"] = 0] = "NORMAL";
      UPDATE_PRIORITY22[UPDATE_PRIORITY22["LOW"] = -25] = "LOW";
      UPDATE_PRIORITY22[UPDATE_PRIORITY22["UTILITY"] = -50] = "UTILITY";
      return UPDATE_PRIORITY22;
    })(UPDATE_PRIORITY3 || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/ticker/TickerListener.mjs
var TickerListener3;
var init_TickerListener2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/ticker/TickerListener.mjs"() {
    TickerListener3 = class {
      /**
       * Constructor
       * @private
       * @param fn - The listener function to be added for one update
       * @param context - The listener context
       * @param priority - The priority for emitting
       * @param once - If the handler should fire once
       */
      constructor(fn, context4 = null, priority = 0, once = false) {
        this.next = null;
        this.previous = null;
        this._destroyed = false;
        this._fn = fn;
        this._context = context4;
        this.priority = priority;
        this._once = once;
      }
      /**
       * Simple compare function to figure out if a function and context match.
       * @param fn - The listener function to be added for one update
       * @param context - The listener context
       * @returns `true` if the listener match the arguments
       */
      match(fn, context4 = null) {
        return this._fn === fn && this._context === context4;
      }
      /**
       * Emit by calling the current function.
       * @param ticker - The ticker emitting.
       * @returns Next ticker
       */
      emit(ticker) {
        if (this._fn) {
          if (this._context) {
            this._fn.call(this._context, ticker);
          } else {
            this._fn(ticker);
          }
        }
        const redirect = this.next;
        if (this._once) {
          this.destroy(true);
        }
        if (this._destroyed) {
          this.next = null;
        }
        return redirect;
      }
      /**
       * Connect to the list.
       * @param previous - Input node, previous listener
       */
      connect(previous) {
        this.previous = previous;
        if (previous.next) {
          previous.next.previous = this;
        }
        this.next = previous.next;
        previous.next = this;
      }
      /**
       * Destroy and don't use after this.
       * @param hard - `true` to remove the `next` reference, this
       *        is considered a hard destroy. Soft destroy maintains the next reference.
       * @returns The listener to redirect while emitting or removing.
       */
      destroy(hard = false) {
        this._destroyed = true;
        this._fn = null;
        this._context = null;
        if (this.previous) {
          this.previous.next = this.next;
        }
        if (this.next) {
          this.next.previous = this.previous;
        }
        const redirect = this.next;
        this.next = hard ? null : redirect;
        this.previous = null;
        return redirect;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/ticker/Ticker.mjs
var _Ticker3, Ticker3;
var init_Ticker2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/ticker/Ticker.mjs"() {
    init_const12();
    init_TickerListener2();
    _Ticker3 = class {
      constructor() {
        this.autoStart = false;
        this.deltaTime = 1;
        this.lastTime = -1;
        this.speed = 1;
        this.started = false;
        this._requestId = null;
        this._maxElapsedMS = 100;
        this._minElapsedMS = 0;
        this._protected = false;
        this._lastFrame = -1;
        this._head = new TickerListener3(null, null, Infinity);
        this.deltaMS = 1 / _Ticker3.targetFPMS;
        this.elapsedMS = 1 / _Ticker3.targetFPMS;
        this._tick = (time) => {
          this._requestId = null;
          if (this.started) {
            this.update(time);
            if (this.started && this._requestId === null && this._head.next) {
              this._requestId = requestAnimationFrame(this._tick);
            }
          }
        };
      }
      /**
       * Conditionally requests a new animation frame.
       * If a frame has not already been requested, and if the internal
       * emitter has listeners, a new frame is requested.
       * @private
       */
      _requestIfNeeded() {
        if (this._requestId === null && this._head.next) {
          this.lastTime = performance.now();
          this._lastFrame = this.lastTime;
          this._requestId = requestAnimationFrame(this._tick);
        }
      }
      /**
       * Conditionally cancels a pending animation frame.
       * @private
       */
      _cancelIfNeeded() {
        if (this._requestId !== null) {
          cancelAnimationFrame(this._requestId);
          this._requestId = null;
        }
      }
      /**
       * Conditionally requests a new animation frame.
       * If the ticker has been started it checks if a frame has not already
       * been requested, and if the internal emitter has listeners. If these
       * conditions are met, a new frame is requested. If the ticker has not
       * been started, but autoStart is `true`, then the ticker starts now,
       * and continues with the previous conditions to request a new frame.
       * @private
       */
      _startIfPossible() {
        if (this.started) {
          this._requestIfNeeded();
        } else if (this.autoStart) {
          this.start();
        }
      }
      /**
       * Register a handler for tick events. Calls continuously unless
       * it is removed or the ticker is stopped.
       * @param fn - The listener function to be added for updates
       * @param context - The listener context
       * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
       * @returns This instance of a ticker
       */
      add(fn, context4, priority = UPDATE_PRIORITY3.NORMAL) {
        return this._addListener(new TickerListener3(fn, context4, priority));
      }
      /**
       * Add a handler for the tick event which is only execute once.
       * @param fn - The listener function to be added for one update
       * @param context - The listener context
       * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
       * @returns This instance of a ticker
       */
      addOnce(fn, context4, priority = UPDATE_PRIORITY3.NORMAL) {
        return this._addListener(new TickerListener3(fn, context4, priority, true));
      }
      /**
       * Internally adds the event handler so that it can be sorted by priority.
       * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
       * before the rendering.
       * @private
       * @param listener - Current listener being added.
       * @returns This instance of a ticker
       */
      _addListener(listener) {
        let current = this._head.next;
        let previous = this._head;
        if (!current) {
          listener.connect(previous);
        } else {
          while (current) {
            if (listener.priority > current.priority) {
              listener.connect(previous);
              break;
            }
            previous = current;
            current = current.next;
          }
          if (!listener.previous) {
            listener.connect(previous);
          }
        }
        this._startIfPossible();
        return this;
      }
      /**
       * Removes any handlers matching the function and context parameters.
       * If no handlers are left after removing, then it cancels the animation frame.
       * @param fn - The listener function to be removed
       * @param context - The listener context to be removed
       * @returns This instance of a ticker
       */
      remove(fn, context4) {
        let listener = this._head.next;
        while (listener) {
          if (listener.match(fn, context4)) {
            listener = listener.destroy();
          } else {
            listener = listener.next;
          }
        }
        if (!this._head.next) {
          this._cancelIfNeeded();
        }
        return this;
      }
      /**
       * The number of listeners on this ticker, calculated by walking through linked list
       * @readonly
       * @member {number}
       */
      get count() {
        if (!this._head) {
          return 0;
        }
        let count2 = 0;
        let current = this._head;
        while (current = current.next) {
          count2++;
        }
        return count2;
      }
      /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */
      start() {
        if (!this.started) {
          this.started = true;
          this._requestIfNeeded();
        }
      }
      /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */
      stop() {
        if (this.started) {
          this.started = false;
          this._cancelIfNeeded();
        }
      }
      /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */
      destroy() {
        if (!this._protected) {
          this.stop();
          let listener = this._head.next;
          while (listener) {
            listener = listener.destroy(true);
          }
          this._head.destroy();
          this._head = null;
        }
      }
      /**
       * Triggers an update. An update entails setting the
       * current {@link Ticker#elapsedMS},
       * the current {@link Ticker#deltaTime},
       * invoking all listeners with current deltaTime,
       * and then finally setting {@link Ticker#lastTime}
       * with the value of currentTime that was provided.
       * This method will be called automatically by animation
       * frame callbacks if the ticker instance has been started
       * and listeners are added.
       * @param {number} [currentTime=performance.now()] - the current time of execution
       */
      update(currentTime = performance.now()) {
        let elapsedMS;
        if (currentTime > this.lastTime) {
          elapsedMS = this.elapsedMS = currentTime - this.lastTime;
          if (elapsedMS > this._maxElapsedMS) {
            elapsedMS = this._maxElapsedMS;
          }
          elapsedMS *= this.speed;
          if (this._minElapsedMS) {
            const delta = currentTime - this._lastFrame | 0;
            if (delta < this._minElapsedMS) {
              return;
            }
            this._lastFrame = currentTime - delta % this._minElapsedMS;
          }
          this.deltaMS = elapsedMS;
          this.deltaTime = this.deltaMS * _Ticker3.targetFPMS;
          const head = this._head;
          let listener = head.next;
          while (listener) {
            listener = listener.emit(this);
          }
          if (!head.next) {
            this._cancelIfNeeded();
          }
        } else {
          this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        }
        this.lastTime = currentTime;
      }
      /**
       * The frames per second at which this ticker is running.
       * The default is approximately 60 in most modern browsers.
       * **Note:** This does not factor in the value of
       * {@link Ticker#speed}, which is specific
       * to scaling {@link Ticker#deltaTime}.
       * @member {number}
       * @readonly
       */
      get FPS() {
        return 1e3 / this.elapsedMS;
      }
      /**
       * Manages the maximum amount of milliseconds allowed to
       * elapse between invoking {@link Ticker#update}.
       * This value is used to cap {@link Ticker#deltaTime},
       * but does not effect the measured value of {@link Ticker#FPS}.
       * When setting this property it is clamped to a value between
       * `0` and `Ticker.targetFPMS * 1000`.
       * @member {number}
       * @default 10
       */
      get minFPS() {
        return 1e3 / this._maxElapsedMS;
      }
      set minFPS(fps2) {
        const minFPS = Math.min(this.maxFPS, fps2);
        const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker3.targetFPMS);
        this._maxElapsedMS = 1 / minFPMS;
      }
      /**
       * Manages the minimum amount of milliseconds required to
       * elapse between invoking {@link Ticker#update}.
       * This will effect the measured value of {@link Ticker#FPS}.
       * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
       * Otherwise it will be at least `minFPS`
       * @member {number}
       * @default 0
       */
      get maxFPS() {
        if (this._minElapsedMS) {
          return Math.round(1e3 / this._minElapsedMS);
        }
        return 0;
      }
      set maxFPS(fps2) {
        if (fps2 === 0) {
          this._minElapsedMS = 0;
        } else {
          const maxFPS = Math.max(this.minFPS, fps2);
          this._minElapsedMS = 1 / (maxFPS / 1e3);
        }
      }
      /**
       * The shared ticker instance used by {@link AnimatedSprite} and by
       * {@link VideoResource} to update animation frames / video textures.
       *
       * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.
       *
       * The property {@link Ticker#autoStart} is set to `true` for this instance.
       * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
       * @example
       * import { Ticker } from 'pixi.js';
       *
       * const ticker = Ticker.shared;
       * // Set this to prevent starting this ticker when listeners are added.
       * // By default this is true only for the Ticker.shared instance.
       * ticker.autoStart = false;
       *
       * // FYI, call this to ensure the ticker is stopped. It should be stopped
       * // if you have not attempted to render anything yet.
       * ticker.stop();
       *
       * // Call this when you are ready for a running shared ticker.
       * ticker.start();
       * @example
       * import { autoDetectRenderer, Container } from 'pixi.js';
       *
       * // You may use the shared ticker to render...
       * const renderer = autoDetectRenderer();
       * const stage = new Container();
       * document.body.appendChild(renderer.view);
       * ticker.add((time) => renderer.render(stage));
       *
       * // Or you can just update it manually.
       * ticker.autoStart = false;
       * ticker.stop();
       * const animate = (time) => {
       *     ticker.update(time);
       *     renderer.render(stage);
       *     requestAnimationFrame(animate);
       * };
       * animate(performance.now());
       * @member {Ticker}
       * @static
       */
      static get shared() {
        if (!_Ticker3._shared) {
          const shared = _Ticker3._shared = new _Ticker3();
          shared.autoStart = true;
          shared._protected = true;
        }
        return _Ticker3._shared;
      }
      /**
       * The system ticker instance used by {@link BasePrepare} for core timing
       * functionality that shouldn't usually need to be paused, unlike the `shared`
       * ticker which drives visual animations and rendering which may want to be paused.
       *
       * The property {@link Ticker#autoStart} is set to `true` for this instance.
       * @member {Ticker}
       * @static
       */
      static get system() {
        if (!_Ticker3._system) {
          const system = _Ticker3._system = new _Ticker3();
          system.autoStart = true;
          system._protected = true;
        }
        return _Ticker3._system;
      }
    };
    Ticker3 = _Ticker3;
    Ticker3.targetFPMS = 0.06;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/ticker/TickerPlugin.mjs
var TickerPlugin3;
var init_TickerPlugin2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/ticker/TickerPlugin.mjs"() {
    init_Extensions2();
    init_const12();
    init_Ticker2();
    TickerPlugin3 = class {
      /**
       * Initialize the plugin with scope of application instance
       * @static
       * @private
       * @param {object} [options] - See application options
       */
      static init(options) {
        options = Object.assign({
          autoStart: true,
          sharedTicker: false
        }, options);
        Object.defineProperty(
          this,
          "ticker",
          {
            set(ticker) {
              if (this._ticker) {
                this._ticker.remove(this.render, this);
              }
              this._ticker = ticker;
              if (ticker) {
                ticker.add(this.render, this, UPDATE_PRIORITY3.LOW);
              }
            },
            get() {
              return this._ticker;
            }
          }
        );
        this.stop = () => {
          this._ticker.stop();
        };
        this.start = () => {
          this._ticker.start();
        };
        this._ticker = null;
        this.ticker = options.sharedTicker ? Ticker3.shared : new Ticker3();
        if (options.autoStart) {
          this.start();
        }
      }
      /**
       * Clean up the ticker, scoped to application.
       * @static
       * @private
       */
      static destroy() {
        if (this._ticker) {
          const oldTicker = this._ticker;
          this.ticker = null;
          oldTicker.destroy();
        }
      }
    };
    TickerPlugin3.extension = ExtensionType3.Application;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/app/ResizePlugin.mjs
var ResizePlugin2;
var init_ResizePlugin2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/app/ResizePlugin.mjs"() {
    init_Extensions2();
    ResizePlugin2 = class {
      /**
       * Initialize the plugin with scope of application instance
       * @static
       * @private
       * @param {object} [options] - See application options
       */
      static init(options) {
        Object.defineProperty(
          this,
          "resizeTo",
          /**
           * The HTML element or window to automatically resize the
           * renderer's view element to match width and height.
           * @member {Window|HTMLElement}
           * @name resizeTo
           * @memberof Application#
           */
          {
            set(dom) {
              globalThis.removeEventListener("resize", this.queueResize);
              this._resizeTo = dom;
              if (dom) {
                globalThis.addEventListener("resize", this.queueResize);
                this.resize();
              }
            },
            get() {
              return this._resizeTo;
            }
          }
        );
        this.queueResize = () => {
          if (!this._resizeTo) {
            return;
          }
          this._cancelResize();
          this._resizeId = requestAnimationFrame(() => this.resize());
        };
        this._cancelResize = () => {
          if (this._resizeId) {
            cancelAnimationFrame(this._resizeId);
            this._resizeId = null;
          }
        };
        this.resize = () => {
          if (!this._resizeTo) {
            return;
          }
          this._cancelResize();
          let width;
          let height;
          if (this._resizeTo === globalThis.window) {
            width = globalThis.innerWidth;
            height = globalThis.innerHeight;
          } else {
            const { clientWidth, clientHeight } = this._resizeTo;
            width = clientWidth;
            height = clientHeight;
          }
          this.renderer.resize(width, height);
          this.render();
        };
        this._resizeId = null;
        this._resizeTo = null;
        this.resizeTo = options.resizeTo || null;
      }
      /**
       * Clean up the ticker, scoped to application
       * @static
       * @private
       */
      static destroy() {
        globalThis.removeEventListener("resize", this.queueResize);
        this._cancelResize();
        this._cancelResize = null;
        this.queueResize = null;
        this.resizeTo = null;
        this.resize = null;
      }
    };
    ResizePlugin2.extension = ExtensionType3.Application;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/app/init.mjs
var init_init8 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/app/init.mjs"() {
    init_Extensions2();
    init_TickerPlugin2();
    init_ResizePlugin2();
    extensions3.add(ResizePlugin2);
    extensions3.add(TickerPlugin3);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs
var LoaderParserPriority2;
var init_LoaderParser2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs"() {
    LoaderParserPriority2 = /* @__PURE__ */ ((LoaderParserPriority22) => {
      LoaderParserPriority22[LoaderParserPriority22["Low"] = 0] = "Low";
      LoaderParserPriority22[LoaderParserPriority22["Normal"] = 1] = "Normal";
      LoaderParserPriority22[LoaderParserPriority22["High"] = 2] = "High";
      return LoaderParserPriority22;
    })(LoaderParserPriority2 || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs
var copySearchParams2;
var init_copySearchParams2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs"() {
    copySearchParams2 = (targetUrl, sourceUrl) => {
      const searchParams = sourceUrl.split("?")[1];
      if (searchParams) {
        targetUrl += `?${searchParams}`;
      }
      return targetUrl;
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/settings/adapter/adapter.mjs
var BrowserAdapter3, currentAdapter, DOMAdapter;
var init_adapter2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/settings/adapter/adapter.mjs"() {
    BrowserAdapter3 = {
      /**
       * Creates a canvas element of the given size.
       * This canvas is created using the browser's native canvas element.
       * @param width - width of the canvas
       * @param height - height of the canvas
       */
      createCanvas: (width, height) => {
        const canvas3 = document.createElement("canvas");
        canvas3.width = width;
        canvas3.height = height;
        return canvas3;
      },
      getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
      getWebGLRenderingContext: () => WebGLRenderingContext,
      getNavigator: () => navigator,
      getBaseUrl: () => document.baseURI ?? window.location.href,
      getFontFaceSet: () => document.fonts,
      fetch: (url2, options) => fetch(url2, options),
      parseXML: (xml) => {
        const parser = new DOMParser();
        return parser.parseFromString(xml, "text/xml");
      }
    };
    currentAdapter = BrowserAdapter3;
    DOMAdapter = {
      get() {
        return currentAdapter;
      },
      set(adapter) {
        currentAdapter = adapter;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/path.mjs
function assertPath3(path22) {
  if (typeof path22 !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path22)}`);
  }
}
function removeUrlParams3(url2) {
  const re = url2.split("?")[0];
  return re.split("#")[0];
}
function escapeRegExp3(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll3(str, find, replace) {
  return str.replace(new RegExp(escapeRegExp3(find), "g"), replace);
}
function normalizeStringPosix3(path22, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = -1;
  for (let i3 = 0; i3 <= path22.length; ++i3) {
    if (i3 < path22.length) {
      code = path22.charCodeAt(i3);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === i3 - 1 || dots === 1) {
      } else if (lastSlash !== i3 - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i3;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i3;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path22.slice(lastSlash + 1, i3)}`;
        } else {
          res = path22.slice(lastSlash + 1, i3);
        }
        lastSegmentLength = i3 - lastSlash - 1;
      }
      lastSlash = i3;
      dots = 0;
    } else if (code === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
var path3;
var init_path2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/path.mjs"() {
    init_adapter2();
    path3 = {
      /**
       * Converts a path to posix format.
       * @param path - The path to convert to posix
       */
      toPosix(path22) {
        return replaceAll3(path22, "\\", "/");
      },
      /**
       * Checks if the path is a URL e.g. http://, https://
       * @param path - The path to check
       */
      isUrl(path22) {
        return /^https?:/.test(this.toPosix(path22));
      },
      /**
       * Checks if the path is a data URL
       * @param path - The path to check
       */
      isDataUrl(path22) {
        return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path22);
      },
      /**
       * Checks if the path is a blob URL
       * @param path - The path to check
       */
      isBlobUrl(path22) {
        return path22.startsWith("blob:");
      },
      /**
       * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
       * This will return true for windows file paths
       * @param path - The path to check
       */
      hasProtocol(path22) {
        return /^[^/:]+:/.test(this.toPosix(path22));
      },
      /**
       * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
       * @param path - The path to get the protocol from
       */
      getProtocol(path22) {
        assertPath3(path22);
        path22 = this.toPosix(path22);
        const matchFile = /^file:\/\/\//.exec(path22);
        if (matchFile) {
          return matchFile[0];
        }
        const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path22);
        if (matchProtocol) {
          return matchProtocol[0];
        }
        return "";
      },
      /**
       * Converts URL to an absolute path.
       * When loading from a Web Worker, we must use absolute paths.
       * If the URL is already absolute we return it as is
       * If it's not, we convert it
       * @param url - The URL to test
       * @param customBaseUrl - The base URL to use
       * @param customRootUrl - The root URL to use
       */
      toAbsolute(url2, customBaseUrl, customRootUrl) {
        assertPath3(url2);
        if (this.isDataUrl(url2) || this.isBlobUrl(url2))
          return url2;
        const baseUrl = removeUrlParams3(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));
        const rootUrl = removeUrlParams3(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
        url2 = this.toPosix(url2);
        if (url2.startsWith("/")) {
          return path3.join(rootUrl, url2.slice(1));
        }
        const absolutePath = this.isAbsolute(url2) ? url2 : this.join(baseUrl, url2);
        return absolutePath;
      },
      /**
       * Normalizes the given path, resolving '..' and '.' segments
       * @param path - The path to normalize
       */
      normalize(path22) {
        assertPath3(path22);
        if (path22.length === 0)
          return ".";
        if (this.isDataUrl(path22) || this.isBlobUrl(path22))
          return path22;
        path22 = this.toPosix(path22);
        let protocol = "";
        const isAbsolute = path22.startsWith("/");
        if (this.hasProtocol(path22)) {
          protocol = this.rootname(path22);
          path22 = path22.slice(protocol.length);
        }
        const trailingSeparator = path22.endsWith("/");
        path22 = normalizeStringPosix3(path22, false);
        if (path22.length > 0 && trailingSeparator)
          path22 += "/";
        if (isAbsolute)
          return `/${path22}`;
        return protocol + path22;
      },
      /**
       * Determines if path is an absolute path.
       * Absolute paths can be urls, data urls, or paths on disk
       * @param path - The path to test
       */
      isAbsolute(path22) {
        assertPath3(path22);
        path22 = this.toPosix(path22);
        if (this.hasProtocol(path22))
          return true;
        return path22.startsWith("/");
      },
      /**
       * Joins all given path segments together using the platform-specific separator as a delimiter,
       * then normalizes the resulting path
       * @param segments - The segments of the path to join
       */
      join(...segments) {
        if (segments.length === 0) {
          return ".";
        }
        let joined;
        for (let i3 = 0; i3 < segments.length; ++i3) {
          const arg2 = segments[i3];
          assertPath3(arg2);
          if (arg2.length > 0) {
            if (joined === void 0)
              joined = arg2;
            else {
              const prevArg = segments[i3 - 1] ?? "";
              if (this.extname(prevArg)) {
                joined += `/../${arg2}`;
              } else {
                joined += `/${arg2}`;
              }
            }
          }
        }
        if (joined === void 0) {
          return ".";
        }
        return this.normalize(joined);
      },
      /**
       * Returns the directory name of a path
       * @param path - The path to parse
       */
      dirname(path22) {
        assertPath3(path22);
        if (path22.length === 0)
          return ".";
        path22 = this.toPosix(path22);
        let code = path22.charCodeAt(0);
        const hasRoot = code === 47;
        let end = -1;
        let matchedSlash = true;
        const proto = this.getProtocol(path22);
        const origpath = path22;
        path22 = path22.slice(proto.length);
        for (let i3 = path22.length - 1; i3 >= 1; --i3) {
          code = path22.charCodeAt(i3);
          if (code === 47) {
            if (!matchedSlash) {
              end = i3;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : this.isUrl(origpath) ? proto + path22 : proto;
        if (hasRoot && end === 1)
          return "//";
        return proto + path22.slice(0, end);
      },
      /**
       * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
       * @param path - The path to parse
       */
      rootname(path22) {
        assertPath3(path22);
        path22 = this.toPosix(path22);
        let root = "";
        if (path22.startsWith("/"))
          root = "/";
        else {
          root = this.getProtocol(path22);
        }
        if (this.isUrl(path22)) {
          const index = path22.indexOf("/", root.length);
          if (index !== -1) {
            root = path22.slice(0, index);
          } else
            root = path22;
          if (!root.endsWith("/"))
            root += "/";
        }
        return root;
      },
      /**
       * Returns the last portion of a path
       * @param path - The path to test
       * @param ext - Optional extension to remove
       */
      basename(path22, ext) {
        assertPath3(path22);
        if (ext)
          assertPath3(ext);
        path22 = removeUrlParams3(this.toPosix(path22));
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i3;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path22.length) {
          if (ext.length === path22.length && ext === path22)
            return "";
          let extIdx = ext.length - 1;
          let firstNonSlashEnd = -1;
          for (i3 = path22.length - 1; i3 >= 0; --i3) {
            const code = path22.charCodeAt(i3);
            if (code === 47) {
              if (!matchedSlash) {
                start = i3 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i3 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i3;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path22.length;
          return path22.slice(start, end);
        }
        for (i3 = path22.length - 1; i3 >= 0; --i3) {
          if (path22.charCodeAt(i3) === 47) {
            if (!matchedSlash) {
              start = i3 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i3 + 1;
          }
        }
        if (end === -1)
          return "";
        return path22.slice(start, end);
      },
      /**
       * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
       * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
       * the first character of the basename of path, an empty string is returned.
       * @param path - The path to parse
       */
      extname(path22) {
        assertPath3(path22);
        path22 = removeUrlParams3(this.toPosix(path22));
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        for (let i3 = path22.length - 1; i3 >= 0; --i3) {
          const code = path22.charCodeAt(i3);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i3 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i3 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i3;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path22.slice(startDot, end);
      },
      /**
       * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
       * @param path - The path to parse
       */
      parse(path22) {
        assertPath3(path22);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path22.length === 0)
          return ret;
        path22 = removeUrlParams3(this.toPosix(path22));
        let code = path22.charCodeAt(0);
        const isAbsolute = this.isAbsolute(path22);
        let start;
        const protocol = "";
        ret.root = this.rootname(path22);
        if (isAbsolute || this.hasProtocol(path22)) {
          start = 1;
        } else {
          start = 0;
        }
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let i3 = path22.length - 1;
        let preDotState = 0;
        for (; i3 >= start; --i3) {
          code = path22.charCodeAt(i3);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i3 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i3 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i3;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute)
              ret.base = ret.name = path22.slice(1, end);
            else
              ret.base = ret.name = path22.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path22.slice(1, startDot);
            ret.base = path22.slice(1, end);
          } else {
            ret.name = path22.slice(startPart, startDot);
            ret.base = path22.slice(startPart, end);
          }
          ret.ext = path22.slice(startDot, end);
        }
        ret.dir = this.dirname(path22);
        if (protocol)
          ret.dir = protocol + ret.dir;
        return ret;
      },
      sep: "/",
      delimiter: ":"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/convertToList.mjs
var convertToList2;
var init_convertToList2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/convertToList.mjs"() {
    convertToList2 = (input, transform, forceTransform = false) => {
      if (!Array.isArray(input)) {
        input = [input];
      }
      if (!transform) {
        return input;
      }
      return input.map((item) => {
        if (typeof item === "string" || forceTransform) {
          return transform(item);
        }
        return item;
      });
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/cache/Cache.mjs
var CacheClass2, Cache2;
var init_Cache2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/cache/Cache.mjs"() {
    init_warn2();
    init_convertToList2();
    CacheClass2 = class {
      constructor() {
        this._parsers = [];
        this._cache = /* @__PURE__ */ new Map();
        this._cacheMap = /* @__PURE__ */ new Map();
      }
      /** Clear all entries. */
      reset() {
        this._cacheMap.clear();
        this._cache.clear();
      }
      /**
       * Check if the key exists
       * @param key - The key to check
       */
      has(key2) {
        return this._cache.has(key2);
      }
      /**
       * Fetch entry by key
       * @param key - The key of the entry to get
       */
      get(key2) {
        const result = this._cache.get(key2);
        if (!result) {
          warn2(`[Assets] Asset id ${key2} was not found in the Cache`);
        }
        return result;
      }
      /**
       * Set a value by key or keys name
       * @param key - The key or keys to set
       * @param value - The value to store in the cache or from which cacheable assets will be derived.
       */
      set(key2, value) {
        const keys = convertToList2(key2);
        let cacheableAssets;
        for (let i3 = 0; i3 < this.parsers.length; i3++) {
          const parser = this.parsers[i3];
          if (parser.test(value)) {
            cacheableAssets = parser.getCacheableAssets(keys, value);
            break;
          }
        }
        const cacheableMap = new Map(Object.entries(cacheableAssets || {}));
        if (!cacheableAssets) {
          keys.forEach((key22) => {
            cacheableMap.set(key22, value);
          });
        }
        const cacheKeys = [...cacheableMap.keys()];
        const cachedAssets = {
          cacheKeys,
          keys
        };
        keys.forEach((key22) => {
          this._cacheMap.set(key22, cachedAssets);
        });
        cacheKeys.forEach((key22) => {
          if (this._cache.has(key22) && this._cache.get(key22) !== value) {
            warn2("[Cache] already has key:", key22);
          }
          this._cache.set(key22, cacheableMap.get(key22));
        });
      }
      /**
       * Remove entry by key
       *
       * This function will also remove any associated alias from the cache also.
       * @param key - The key of the entry to remove
       */
      remove(key2) {
        if (!this._cacheMap.has(key2)) {
          warn2(`[Assets] Asset id ${key2} was not found in the Cache`);
          return;
        }
        const cacheMap2 = this._cacheMap.get(key2);
        const cacheKeys = cacheMap2.cacheKeys;
        cacheKeys.forEach((key22) => {
          this._cache.delete(key22);
        });
        cacheMap2.keys.forEach((key22) => {
          this._cacheMap.delete(key22);
        });
      }
      /** All loader parsers registered */
      get parsers() {
        return this._parsers;
      }
    };
    Cache2 = new CacheClass2();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/NOOP.mjs
var NOOP2;
var init_NOOP2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/NOOP.mjs"() {
    NOOP2 = () => {
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/resourceToTexture.mjs
function autoDetectSource(options = {}) {
  for (let i3 = 0; i3 < sources.length; i3++) {
    const Source = sources[i3];
    if (Source.test(options.resource)) {
      return new Source(options);
    }
  }
  throw new Error(`Could not find a source type for resource: ${options.resource}`);
}
function resourceToTexture(options = {}, skipCache = false) {
  const { resource } = options;
  if (!skipCache && Cache2.has(resource)) {
    return Cache2.get(resource);
  }
  const texture = new Texture4({ source: autoDetectSource(options) });
  texture.on("destroy", () => {
    if (Cache2.has(resource)) {
      Cache2.remove(resource);
    }
  });
  if (!skipCache) {
    Cache2.set(resource, texture);
  }
  return texture;
}
var sources;
var init_resourceToTexture = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/resourceToTexture.mjs"() {
    init_Cache2();
    init_Extensions2();
    init_Texture2();
    sources = [];
    extensions3.handleByList(ExtensionType3.TextureSource, sources);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs
function createIdFromString2(value, groupId) {
  let id = idHash2[value];
  if (id === void 0) {
    if (idCounts2[groupId] === void 0) {
      idCounts2[groupId] = 1;
    }
    idHash2[value] = id = idCounts2[groupId]++;
  }
  return id;
}
var idCounts2, idHash2;
var init_createIdFromString2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs"() {
    idCounts2 = /* @__PURE__ */ Object.create(null);
    idHash2 = /* @__PURE__ */ Object.create(null);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs
var _TextureStyle2, TextureStyle2;
var init_TextureStyle2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs"() {
    init_eventemitter3();
    init_deprecation2();
    init_createIdFromString2();
    _TextureStyle2 = class extends eventemitter3_default {
      constructor(options = {}) {
        super();
        this.resourceType = "textureSampler";
        this.touched = 0;
        this._maxAnisotropy = 1;
        options = { ..._TextureStyle2.defaultOptions, ...options };
        this.addressMode = options.addressMode;
        this.addressModeU = options.addressModeU ?? this.addressModeU;
        this.addressModeV = options.addressModeV ?? this.addressModeV;
        this.addressModeW = options.addressModeW ?? this.addressModeW;
        this.scaleMode = options.scaleMode;
        this.magFilter = options.magFilter ?? this.magFilter;
        this.minFilter = options.minFilter ?? this.minFilter;
        this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;
        this.lodMinClamp = options.lodMinClamp;
        this.lodMaxClamp = options.lodMaxClamp;
        this.compare = options.compare;
        this.maxAnisotropy = options.maxAnisotropy ?? 1;
      }
      set addressMode(value) {
        this.addressModeU = value;
        this.addressModeV = value;
        this.addressModeW = value;
      }
      get addressMode() {
        return this.addressModeU;
      }
      set wrapMode(value) {
        deprecation3("8", "TextureStyle.wrapMode is now TextureStyle.addressMode");
        this.addressMode = value;
      }
      get wrapMode() {
        return this.addressMode;
      }
      set scaleMode(value) {
        this.magFilter = value;
        this.minFilter = value;
        this.mipmapFilter = value;
      }
      get scaleMode() {
        return this.magFilter;
      }
      set maxAnisotropy(value) {
        this._maxAnisotropy = Math.min(value, 16);
        if (this._maxAnisotropy > 1) {
          this.scaleMode = "linear";
        }
      }
      get maxAnisotropy() {
        return this._maxAnisotropy;
      }
      // TODO - move this to WebGL?
      get resourceId() {
        return this._resourceId || this._generateResourceId();
      }
      update() {
        this.emit("change", this);
        this._resourceId = null;
      }
      _generateResourceId() {
        const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
        this._resourceId = createIdFromString2(bigKey, "sampler");
        return this._resourceId;
      }
      /** Destroys the style */
      destroy() {
        this.emit("destroy", this);
        this.removeAllListeners();
      }
    };
    TextureStyle2 = _TextureStyle2;
    TextureStyle2.defaultOptions = {
      addressMode: "clamp-to-edge",
      scaleMode: "linear"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs
var _TextureSource2, TextureSource2;
var init_TextureSource2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs"() {
    init_eventemitter3();
    init_uid2();
    init_deprecation2();
    init_TextureStyle2();
    _TextureSource2 = class extends eventemitter3_default {
      // eslint-disable-next-line @typescript-eslint/no-parameter-properties
      constructor(options = {}) {
        super();
        this.options = options;
        this.uid = uid3("textureSource");
        this.resourceType = "textureSource";
        this.resourceId = uid3("textureResource");
        this.uploadMethodId = "unknown";
        this._resolution = 1;
        this.pixelWidth = 1;
        this.pixelHeight = 1;
        this.width = 1;
        this.height = 1;
        this.sampleCount = 1;
        this.mipLevelCount = 1;
        this.autoGenerateMipmaps = false;
        this.format = "rgba8unorm-srgb";
        this.dimension = "2d";
        this.antialias = false;
        this.depthStencil = true;
        this.touched = 0;
        this._batchTick = -1;
        this._textureBindLocation = -1;
        options = { ..._TextureSource2.defaultOptions, ...options };
        this.resource = options.resource;
        this._resolution = options.resolution;
        if (options.width) {
          this.pixelWidth = options.width * this._resolution;
        } else {
          this.pixelWidth = options.resource?.width ?? 1;
        }
        if (options.height) {
          this.pixelHeight = options.height * this._resolution;
        } else {
          this.pixelHeight = options.resource?.height ?? 1;
        }
        this.width = this.pixelWidth / this._resolution;
        this.height = this.pixelHeight / this._resolution;
        this.format = options.format;
        this.dimension = options.dimensions;
        this.mipLevelCount = options.mipLevelCount;
        this.autoGenerateMipmaps = options.autoGenerateMipmaps;
        this.sampleCount = options.sampleCount;
        this.antialias = options.antialias;
        this.alphaMode = options.alphaMode;
        const style = options.style ?? {};
        this.style = style instanceof TextureStyle2 ? style : new TextureStyle2(style);
        this.destroyed = false;
      }
      get source() {
        return this;
      }
      get style() {
        return this._style;
      }
      set style(value) {
        if (this.style === value)
          return;
        this._style?.off("change", this._onStyleChange, this);
        this._style = value;
        this._style?.on("change", this._onStyleChange, this);
        this._onStyleChange();
      }
      _onStyleChange() {
        this.emit("styleChange", this);
      }
      update() {
        this.emit("update", this);
      }
      /** Destroys this texture source */
      destroy() {
        this.destroyed = true;
        this.emit("destroy", this);
        if (this._style) {
          this._style.destroy();
          this._style = null;
        }
        this.uploadMethodId = null;
        this.resource = null;
        this.removeAllListeners();
      }
      unload() {
        this.resourceId++;
        this.emit("change", this);
        this.emit("unload", this);
      }
      get resourceWidth() {
        const { resource } = this;
        return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;
      }
      get resourceHeight() {
        const { resource } = this;
        return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;
      }
      get resolution() {
        return this._resolution;
      }
      set resolution(resolution) {
        if (this._resolution === resolution)
          return;
        this._resolution = resolution;
        this.width = this.pixelWidth / resolution;
        this.height = this.pixelHeight / resolution;
      }
      resize(width, height, resolution) {
        resolution = resolution || this._resolution;
        width = width || this.width;
        height = height || this.height;
        const newPixelWidth = Math.round(width * resolution);
        const newPixelHeight = Math.round(height * resolution);
        this.width = newPixelWidth / resolution;
        this.height = newPixelHeight / resolution;
        this._resolution = resolution;
        if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {
          return;
        }
        this.pixelWidth = newPixelWidth;
        this.pixelHeight = newPixelHeight;
        this.emit("resize", this);
        this.resourceId++;
        this.emit("change", this);
      }
      /** @deprecated since 8.0.0 */
      set wrapMode(value) {
        deprecation3(v8_0_02, "TextureSource.wrapMode property has been deprecated. Use TextureSource.style.addressMode instead.");
        this._style.wrapMode = value;
      }
      /** @deprecated since 8.0.0 */
      get wrapMode() {
        deprecation3(v8_0_02, "TextureSource.wrapMode property has been deprecated. Use TextureSource.style.addressMode instead.");
        return this._style.wrapMode;
      }
      /** @deprecated since 8.0.0 */
      set scaleMode(value) {
        deprecation3(v8_0_02, "TextureSource.scaleMode property has been deprecated. Use TextureSource.style.scaleMode instead.");
        this._style.scaleMode = value;
      }
      /** @deprecated since 8.0.0 */
      get scaleMode() {
        deprecation3(v8_0_02, "TextureSource.scaleMode property has been deprecated. Use TextureSource.style.scaleMode instead.");
        return this._style.scaleMode;
      }
      static test(_resource) {
        throw new Error("Unimplemented");
      }
    };
    TextureSource2 = _TextureSource2;
    TextureSource2.defaultOptions = {
      resolution: 1,
      format: "bgra8unorm",
      alphaMode: "no-premultiply-alpha",
      dimensions: "2d",
      mipLevelCount: 1,
      autoGenerateMipmaps: false,
      sampleCount: 1,
      antialias: false,
      style: {}
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/matrix/groupD8.mjs
function init3() {
  for (let i3 = 0; i3 < 16; i3++) {
    const row = [];
    rotationCayley3.push(row);
    for (let j3 = 0; j3 < 16; j3++) {
      const _ux = signum3(ux3[i3] * ux3[j3] + vx3[i3] * uy3[j3]);
      const _uy = signum3(uy3[i3] * ux3[j3] + vy3[i3] * uy3[j3]);
      const _vx = signum3(ux3[i3] * vx3[j3] + vx3[i3] * vy3[j3]);
      const _vy = signum3(uy3[i3] * vx3[j3] + vy3[i3] * vy3[j3]);
      for (let k3 = 0; k3 < 16; k3++) {
        if (ux3[k3] === _ux && uy3[k3] === _uy && vx3[k3] === _vx && vy3[k3] === _vy) {
          row.push(k3);
          break;
        }
      }
    }
  }
  for (let i3 = 0; i3 < 16; i3++) {
    const mat = new Matrix3();
    mat.set(ux3[i3], uy3[i3], vx3[i3], vy3[i3], 0, 0);
    rotationMatrices3.push(mat);
  }
}
var ux3, uy3, vx3, vy3, rotationCayley3, rotationMatrices3, signum3, groupD83;
var init_groupD82 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/matrix/groupD8.mjs"() {
    init_Matrix2();
    ux3 = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
    uy3 = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
    vx3 = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
    vy3 = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
    rotationCayley3 = [];
    rotationMatrices3 = [];
    signum3 = Math.sign;
    init3();
    groupD83 = {
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 0°       | East      |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      E: 0,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 45°↻     | Southeast |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      SE: 1,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 90°↻     | South     |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      S: 2,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 135°↻    | Southwest |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      SW: 3,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 180°     | West      |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      W: 4,
      /**
       * | Rotation    | Direction    |
       * |-------------|--------------|
       * | -135°/225°↻ | Northwest    |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      NW: 5,
      /**
       * | Rotation    | Direction    |
       * |-------------|--------------|
       * | -90°/270°↻  | North        |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      N: 6,
      /**
       * | Rotation    | Direction    |
       * |-------------|--------------|
       * | -45°/315°↻  | Northeast    |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      NE: 7,
      /**
       * Reflection about Y-axis.
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      MIRROR_VERTICAL: 8,
      /**
       * Reflection about the main diagonal.
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      MAIN_DIAGONAL: 10,
      /**
       * Reflection about X-axis.
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      MIRROR_HORIZONTAL: 12,
      /**
       * Reflection about reverse diagonal.
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      REVERSE_DIAGONAL: 14,
      /**
       * @memberof groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The X-component of the U-axis
       *    after rotating the axes.
       */
      uX: (ind) => ux3[ind],
      /**
       * @memberof groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The Y-component of the U-axis
       *    after rotating the axes.
       */
      uY: (ind) => uy3[ind],
      /**
       * @memberof groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The X-component of the V-axis
       *    after rotating the axes.
       */
      vX: (ind) => vx3[ind],
      /**
       * @memberof groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The Y-component of the V-axis
       *    after rotating the axes.
       */
      vY: (ind) => vy3[ind],
      /**
       * @memberof groupD8
       * @param {GD8Symmetry} rotation - symmetry whose opposite
       *   is needed. Only rotations have opposite symmetries while
       *   reflections don't.
       * @returns {GD8Symmetry} The opposite symmetry of `rotation`
       */
      inv: (rotation) => {
        if (rotation & 8) {
          return rotation & 15;
        }
        return -rotation & 7;
      },
      /**
       * Composes the two D8 operations.
       *
       * Taking `^` as reflection:
       *
       * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
       * |-------|-----|-----|-----|-----|------|-------|-------|-------|
       * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
       * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
       * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
       * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
       * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
       * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
       * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
       * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
       *
       * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
       * @memberof groupD8
       * @param {GD8Symmetry} rotationSecond - Second operation, which
       *   is the row in the above cayley table.
       * @param {GD8Symmetry} rotationFirst - First operation, which
       *   is the column in the above cayley table.
       * @returns {GD8Symmetry} Composed operation
       */
      add: (rotationSecond, rotationFirst) => rotationCayley3[rotationSecond][rotationFirst],
      /**
       * Reverse of `add`.
       * @memberof groupD8
       * @param {GD8Symmetry} rotationSecond - Second operation
       * @param {GD8Symmetry} rotationFirst - First operation
       * @returns {GD8Symmetry} Result
       */
      sub: (rotationSecond, rotationFirst) => rotationCayley3[rotationSecond][groupD83.inv(rotationFirst)],
      /**
       * Adds 180 degrees to rotation, which is a commutative
       * operation.
       * @memberof groupD8
       * @param {number} rotation - The number to rotate.
       * @returns {number} Rotated number
       */
      rotate180: (rotation) => rotation ^ 4,
      /**
       * Checks if the rotation angle is vertical, i.e. south
       * or north. It doesn't work for reflections.
       * @memberof groupD8
       * @param {GD8Symmetry} rotation - The number to check.
       * @returns {boolean} Whether or not the direction is vertical
       */
      isVertical: (rotation) => (rotation & 3) === 2,
      // rotation % 4 === 2
      /**
       * Approximates the vector `V(dx,dy)` into one of the
       * eight directions provided by `groupD8`.
       * @memberof groupD8
       * @param {number} dx - X-component of the vector
       * @param {number} dy - Y-component of the vector
       * @returns {GD8Symmetry} Approximation of the vector into
       *  one of the eight symmetries.
       */
      byDirection: (dx, dy) => {
        if (Math.abs(dx) * 2 <= Math.abs(dy)) {
          if (dy >= 0) {
            return groupD83.S;
          }
          return groupD83.N;
        } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
          if (dx > 0) {
            return groupD83.E;
          }
          return groupD83.W;
        } else if (dy > 0) {
          if (dx > 0) {
            return groupD83.SE;
          }
          return groupD83.SW;
        } else if (dx > 0) {
          return groupD83.NE;
        }
        return groupD83.NW;
      },
      /**
       * Helps sprite to compensate texture packer rotation.
       * @memberof groupD8
       * @param {Matrix} matrix - sprite world matrix
       * @param {GD8Symmetry} rotation - The rotation factor to use.
       * @param {number} tx - sprite anchoring
       * @param {number} ty - sprite anchoring
       */
      matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
        const mat = rotationMatrices3[groupD83.inv(rotation)];
        mat.tx = tx;
        mat.ty = ty;
        matrix.append(mat);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureLayout.mjs
var TextureLayout2;
var init_TextureLayout2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureLayout.mjs"() {
    init_eventemitter3();
    init_groupD82();
    init_Rectangle2();
    TextureLayout2 = class extends eventemitter3_default {
      constructor(options = {}) {
        super();
        this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };
        this.frame = options.frame || new Rectangle3(0, 0, 1, 1);
        this.orig = options.orig || this.frame;
        this.rotate = options.rotate ?? 0;
        this.trim = options.trim;
        this.defaultAnchor = options.defaultAnchor;
        this.defaultBorders = options.defaultBorders;
        this.updateUvs();
      }
      updateUvs() {
        const uvs = this.uvs;
        const frame = this.frame;
        let rotate = this.rotate;
        if (rotate) {
          const w2 = frame.width / 2;
          const h2 = frame.height / 2;
          const cX = frame.x + w2;
          const cY = frame.y + h2;
          rotate = groupD83.add(rotate, groupD83.NW);
          uvs.x0 = cX + w2 * groupD83.uX(rotate);
          uvs.y0 = cY + h2 * groupD83.uY(rotate);
          rotate = groupD83.add(rotate, 2);
          uvs.x1 = cX + w2 * groupD83.uX(rotate);
          uvs.y1 = cY + h2 * groupD83.uY(rotate);
          rotate = groupD83.add(rotate, 2);
          uvs.x2 = cX + w2 * groupD83.uX(rotate);
          uvs.y2 = cY + h2 * groupD83.uY(rotate);
          rotate = groupD83.add(rotate, 2);
          uvs.x3 = cX + w2 * groupD83.uX(rotate);
          uvs.y3 = cY + h2 * groupD83.uY(rotate);
        } else {
          uvs.x0 = frame.x;
          uvs.y0 = frame.y;
          uvs.x1 = frame.x + frame.width;
          uvs.y1 = frame.y;
          uvs.x2 = frame.x + frame.width;
          uvs.y2 = frame.y + frame.height;
          uvs.x3 = frame.x;
          uvs.y3 = frame.y + frame.height;
        }
      }
      update() {
        this.updateUvs();
        this.emit("update", this);
      }
      /** Destroys this TextureLayout */
      destroy() {
        this.emit("destroy", this);
        this.removeAllListeners();
        this.frame = null;
        this.orig = null;
        this.trim = null;
        this.defaultAnchor = null;
        this.uvs = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs
var tempMat3, TextureMatrix3;
var init_TextureMatrix2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs"() {
    init_Matrix2();
    tempMat3 = new Matrix3();
    TextureMatrix3 = class {
      /**
       * @param texture - observed texture
       * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
       */
      constructor(texture, clampMargin) {
        this.mapCoord = new Matrix3();
        this.uClampFrame = new Float32Array(4);
        this.uClampOffset = new Float32Array(2);
        this._textureID = -1;
        this._updateID = 0;
        this.clampOffset = 0;
        this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
        this.isSimple = false;
        this.texture = texture;
      }
      /** Texture property. */
      get texture() {
        return this._texture;
      }
      set texture(value) {
        if (this.texture === value)
          return;
        this._texture?.removeListener("update", this.update, this);
        this._texture = value;
        this._texture.addListener("update", this.update, this);
        this.update();
      }
      /**
       * Multiplies uvs array to transform
       * @param uvs - mesh uvs
       * @param [out=uvs] - output
       * @returns - output
       */
      multiplyUvs(uvs, out3) {
        if (out3 === void 0) {
          out3 = uvs;
        }
        const mat = this.mapCoord;
        for (let i3 = 0; i3 < uvs.length; i3 += 2) {
          const x3 = uvs[i3];
          const y2 = uvs[i3 + 1];
          out3[i3] = x3 * mat.a + y2 * mat.c + mat.tx;
          out3[i3 + 1] = x3 * mat.b + y2 * mat.d + mat.ty;
        }
        return out3;
      }
      update() {
        const tex = this._texture;
        this._updateID++;
        const uvs = tex.layout.uvs;
        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
        const orig = tex.layout.orig;
        const trim = tex.layout.trim;
        if (trim) {
          tempMat3.set(
            orig.width / trim.width,
            0,
            0,
            orig.height / trim.height,
            -trim.x / trim.width,
            -trim.y / trim.height
          );
          this.mapCoord.append(tempMat3);
        }
        const texBase = tex.source;
        const frame = this.uClampFrame;
        const margin = this.clampMargin / texBase._resolution;
        const offset = this.clampOffset;
        frame[0] = (tex.frameX + margin + offset) / texBase.width;
        frame[1] = (tex.frameY + margin + offset) / texBase.height;
        frame[2] = (tex.frameX + tex.frameWidth - margin + offset) / texBase.width;
        frame[3] = (tex.frameY + tex.frameHeight - margin + offset) / texBase.height;
        this.uClampOffset[0] = offset / texBase.pixelWidth;
        this.uClampOffset[1] = offset / texBase.pixelHeight;
        this.isSimple = tex.frameWidth === texBase.width && tex.frameHeight === texBase.height && tex.layout.rotate === 0;
        return true;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs
var Texture4;
var init_Texture2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"() {
    init_eventemitter3();
    init_Cache2();
    init_uid2();
    init_deprecation2();
    init_NOOP2();
    init_resourceToTexture();
    init_TextureSource2();
    init_TextureLayout2();
    init_TextureMatrix2();
    Texture4 = class _Texture extends eventemitter3_default {
      constructor({ source: source3, layout, label, frame } = {}) {
        super();
        this.id = uid3("texture");
        this.styleSourceKey = 0;
        this.label = label;
        this.source = source3?.source ?? new TextureSource2();
        layout = layout instanceof TextureLayout2 ? layout : new TextureLayout2(layout);
        if (frame) {
          const { width, height } = this._source;
          layout.frame.x = frame.x / width;
          layout.frame.y = frame.y / height;
          layout.frame.width = frame.width / width;
          layout.frame.height = frame.height / height;
          layout.updateUvs();
        }
        this.layout = layout;
        this.destroyed = false;
      }
      static from(id, skipCache = false) {
        if (typeof id === "string") {
          return Cache2.get(id);
        } else if (id instanceof TextureSource2) {
          return new _Texture({ source: id });
        }
        return resourceToTexture(id, skipCache);
      }
      set source(value) {
        if (this._source) {
          this._source.off("resize", this.onUpdate, this);
        }
        this._source = value;
        value.on("resize", this.onUpdate, this);
        this.emit("update", this);
      }
      get source() {
        return this._source;
      }
      get layout() {
        return this._layout;
      }
      set layout(value) {
        this._layout?.off("update", this.onUpdate, this);
        this._layout = value;
        value.on("update", this.onUpdate, this);
        this.emit("update", this);
      }
      get textureMatrix() {
        if (!this._textureMatrix) {
          this._textureMatrix = new TextureMatrix3(this);
        }
        return this._textureMatrix;
      }
      set frameWidth(value) {
        this._layout.frame.width = value / this._source.width;
      }
      get frameWidth() {
        return this._source.pixelWidth / this._source._resolution * this._layout.frame.width;
      }
      set frameHeight(value) {
        this._layout.frame.height = value / this._source.height;
      }
      get frameHeight() {
        return this._source.pixelHeight / this._source._resolution * this._layout.frame.height;
      }
      set frameX(value) {
        if (value === 0) {
          this._layout.frame.x = 0;
          return;
        }
        this._layout.frame.x = this._source.width / value;
      }
      get frameX() {
        return this._source.width * this._layout.frame.x;
      }
      set frameY(value) {
        if (value === 0) {
          this._layout.frame.y = 0;
          return;
        }
        this._layout.frame.y = this._source.height / value;
      }
      get frameY() {
        return this._source.height * this._layout.frame.y;
      }
      /** The width of the Texture in pixels. */
      get width() {
        return this._source.width * this._layout.orig.width;
      }
      /** The height of the Texture in pixels. */
      get height() {
        return this._source.height * this._layout.orig.height;
      }
      /**
       * Destroys this texture
       * @param destroySource - Destroy the source when the texture is destroyed.
       */
      destroy(destroySource = false) {
        if (this._layout) {
          this._layout.destroy();
          this._layout = null;
        }
        if (this._source) {
          if (destroySource) {
            this._source.destroy();
            this._source = null;
          }
        }
        this._textureMatrix = null;
        this.destroyed = true;
        this.emit("destroy", this);
        this.removeAllListeners();
      }
      /**
       * @internal
       */
      onUpdate() {
        this.emit("update", this);
      }
      /** @deprecated since 8.0.0 */
      get baseTexture() {
        deprecation3(v8_0_02, "Texture.baseTexture is now Texture.source");
        return this._source;
      }
    };
    Texture4.EMPTY = new Texture4({});
    Texture4.EMPTY.label = "EMPTY";
    Texture4.EMPTY.destroy = NOOP2;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/AbstractBitmapFont.mjs
var AbstractBitmapFont2;
var init_AbstractBitmapFont2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/AbstractBitmapFont.mjs"() {
    init_eventemitter3();
    init_deprecation2();
    AbstractBitmapFont2 = class extends eventemitter3_default {
      constructor() {
        super(...arguments);
        this.chars = /* @__PURE__ */ Object.create(null);
        this.lineHeight = 0;
        this.fontFamily = "";
        this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };
        this.baseLineOffset = 0;
        this.distanceField = { type: "none", range: 0 };
        this.pages = [];
        this.baseMeasurementFontSize = 100;
        this.baseRenderedFontSize = 100;
      }
      /**
       * @deprecated since 8.0.0
       * The name of the font face.
       */
      get font() {
        deprecation3(v8_0_02, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");
        return this.fontFamily;
      }
      /** @deprecated since 8.0.0 */
      get pageTextures() {
        deprecation3(v8_0_02, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
        return this.pages;
      }
      /**
       * @deprecated since 8.0.0
       * The size of the font face in pixels.
       */
      get size() {
        deprecation3(v8_0_02, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");
        return this.fontMetrics.fontSize;
      }
      /**
       * @deprecated since 8.0.0
       * The kind of distance field for this font or "none".
       */
      get distanceFieldRange() {
        deprecation3(v8_0_02, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");
        return this.distanceField.range;
      }
      /**
       * @deprecated since 8.0.0
       * The range of the distance field in pixels.
       */
      get distanceFieldType() {
        deprecation3(v8_0_02, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");
        return this.distanceField.type;
      }
      destroy() {
        this.emit("destroy", this);
        this.removeAllListeners();
        for (const i3 in this.chars) {
          this.chars[i3].texture.destroy();
        }
        this.chars = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/BitmapFont.mjs
var BitmapFont3;
var init_BitmapFont2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/BitmapFont.mjs"() {
    init_Rectangle2();
    init_Texture2();
    init_AbstractBitmapFont2();
    BitmapFont3 = class extends AbstractBitmapFont2 {
      constructor(options) {
        super();
        const { textures, data } = options;
        Object.keys(data.pages).forEach((key2) => {
          const pageData = data.pages[parseInt(key2, 10)];
          const texture = textures[pageData.id];
          this.pages.push({ texture });
        });
        Object.keys(data.chars).forEach((key2) => {
          const charData = data.chars[key2];
          const textureSource = textures[charData.page].source;
          const frame = new Rectangle3(
            charData.x / textureSource.width,
            charData.y / textureSource.height,
            charData.width / textureSource.width,
            charData.height / textureSource.height
          );
          const texture = new Texture4({
            source: textureSource,
            layout: {
              frame
            }
          });
          this.chars[key2] = {
            id: key2.codePointAt(0),
            xOffset: charData.xOffset,
            yOffset: charData.yOffset,
            xAdvance: charData.xAdvance,
            kerning: charData.kerning ?? {},
            texture
          };
        });
        this.baseRenderedFontSize = data.fontSize;
        const writable = this;
        writable.baseMeasurementFontSize = data.fontSize;
        writable.fontMetrics = {
          ascent: 0,
          descent: 0,
          fontSize: data.fontSize
        };
        writable.baseLineOffset = data.baseLineOffset;
        writable.lineHeight = data.lineHeight;
        writable.fontFamily = data.fontFamily;
        writable.distanceField = data.distanceField ?? {
          type: "none",
          range: 0
        };
      }
      destroy() {
        super.destroy();
        for (let i3 = 0; i3 < this.pages.length; i3++) {
          const { texture } = this.pages[i3];
          texture.destroy(true);
        }
        this.pages = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/asset/textFormat.mjs
var TextFormat2;
var init_textFormat2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/asset/textFormat.mjs"() {
    TextFormat2 = {
      test(data) {
        return typeof data === "string" && data.startsWith("info face=");
      },
      parse(txt) {
        const items = txt.match(/^[a-z]+\s+.+$/gm);
        const rawData = {
          info: [],
          common: [],
          page: [],
          char: [],
          chars: [],
          kerning: [],
          kernings: [],
          distanceField: []
        };
        for (const i3 in items) {
          const name = items[i3].match(/^[a-z]+/gm)[0];
          const attributeList = items[i3].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
          const itemData = {};
          for (const i22 in attributeList) {
            const split = attributeList[i22].split("=");
            const key2 = split[0];
            const strValue = split[1].replace(/"/gm, "");
            const floatValue = parseFloat(strValue);
            const value = isNaN(floatValue) ? strValue : floatValue;
            itemData[key2] = value;
          }
          rawData[name].push(itemData);
        }
        const font = {
          chars: {},
          pages: [],
          lineHeight: 0,
          fontSize: 0,
          fontFamily: "",
          distanceField: null,
          baseLineOffset: 0
        };
        const [info] = rawData.info;
        const [common] = rawData.common;
        const [distanceField] = rawData.distanceField ?? [];
        if (distanceField) {
          font.distanceField = {
            range: parseInt(distanceField.distanceRange, 10),
            type: distanceField.fieldType
          };
        }
        font.fontSize = parseInt(info.size, 10);
        font.fontFamily = info.face;
        font.lineHeight = parseInt(common.lineHeight, 10);
        const page = rawData.page;
        for (let i3 = 0; i3 < page.length; i3++) {
          font.pages.push({
            id: parseInt(page[i3].id, 10) || 0,
            file: page[i3].file
          });
        }
        const map5 = {};
        font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);
        const char = rawData.char;
        for (let i3 = 0; i3 < char.length; i3++) {
          const charNode = char[i3];
          const id = parseInt(charNode.id, 10);
          let letter = charNode.letter ?? charNode.char;
          if (letter === "space")
            letter = " ";
          map5[id] = letter;
          font.chars[letter] = {
            id,
            // texture deets..
            page: parseInt(charNode.page, 10) || 0,
            x: parseInt(charNode.x, 10),
            y: parseInt(charNode.y, 10),
            width: parseInt(charNode.width, 10),
            height: parseInt(charNode.height, 10),
            xOffset: parseInt(charNode.xoffset, 10),
            yOffset: parseInt(charNode.yoffset, 10),
            xAdvance: parseInt(charNode.xadvance, 10),
            kerning: {}
          };
        }
        const kerning = rawData.kerning || [];
        for (let i3 = 0; i3 < kerning.length; i3++) {
          const first = parseInt(kerning[i3].first, 10);
          const second = parseInt(kerning[i3].second, 10);
          const amount = parseInt(kerning[i3].amount, 10);
          font.chars[map5[second]].kerning[map5[first]] = amount;
        }
        return font;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/asset/xmlFormat.mjs
var XMLFormat2;
var init_xmlFormat2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/asset/xmlFormat.mjs"() {
    XMLFormat2 = {
      test(data) {
        const xml = data;
        return typeof xml !== "string" && "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
      },
      parse(xml) {
        const data = {
          chars: {},
          pages: [],
          lineHeight: 0,
          fontSize: 0,
          fontFamily: "",
          distanceField: null,
          baseLineOffset: 0
        };
        const info = xml.getElementsByTagName("info")[0];
        const common = xml.getElementsByTagName("common")[0];
        const distanceField = xml.getElementsByTagName("distanceField")[0];
        if (distanceField) {
          data.distanceField = {
            type: distanceField.getAttribute("fieldType"),
            range: parseInt(distanceField.getAttribute("distanceRange"), 10)
          };
        }
        const page = xml.getElementsByTagName("page");
        const char = xml.getElementsByTagName("char");
        const kerning = xml.getElementsByTagName("kerning");
        data.fontSize = parseInt(info.getAttribute("size"), 10);
        data.fontFamily = info.getAttribute("face");
        data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10);
        for (let i3 = 0; i3 < page.length; i3++) {
          data.pages.push({
            id: parseInt(page[i3].getAttribute("id"), 10) || 0,
            file: page[i3].getAttribute("file")
          });
        }
        const map5 = {};
        data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute("base"), 10);
        for (let i3 = 0; i3 < char.length; i3++) {
          const charNode = char[i3];
          const id = parseInt(charNode.getAttribute("id"), 10);
          let letter = charNode.getAttribute("letter") ?? charNode.getAttribute("char");
          if (letter === "space")
            letter = " ";
          map5[id] = letter;
          data.chars[letter] = {
            id,
            // texture deets..
            page: parseInt(charNode.getAttribute("page"), 10) || 0,
            x: parseInt(charNode.getAttribute("x"), 10),
            y: parseInt(charNode.getAttribute("y"), 10),
            width: parseInt(charNode.getAttribute("width"), 10),
            height: parseInt(charNode.getAttribute("height"), 10),
            // render deets..
            xOffset: parseInt(charNode.getAttribute("xoffset"), 10),
            yOffset: parseInt(charNode.getAttribute("yoffset"), 10),
            // + baseLineOffset,
            xAdvance: parseInt(charNode.getAttribute("xadvance"), 10),
            kerning: {}
          };
        }
        for (let i3 = 0; i3 < kerning.length; i3++) {
          const first = parseInt(kerning[i3].getAttribute("first"), 10);
          const second = parseInt(kerning[i3].getAttribute("second"), 10);
          const amount = parseInt(kerning[i3].getAttribute("amount"), 10);
          data.chars[map5[second]].kerning[map5[first]] = amount;
        }
        return data;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/asset/xmlStringFormat.mjs
var XMLStringFormat2;
var init_xmlStringFormat2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/asset/xmlStringFormat.mjs"() {
    init_adapter2();
    init_xmlFormat2();
    XMLStringFormat2 = {
      test(data) {
        if (typeof data === "string" && data.includes("<font>")) {
          return XMLFormat2.test(DOMAdapter.get().parseXML(data));
        }
        return false;
      },
      parse(data) {
        return XMLFormat2.parse(DOMAdapter.get().parseXML(data));
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/asset/loadBitmapFont.mjs
var validExtensions2, bitmapFontCachePlugin2, xmlBitmapFontLoader2;
var init_loadBitmapFont2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/asset/loadBitmapFont.mjs"() {
    init_LoaderParser2();
    init_copySearchParams2();
    init_Extensions2();
    init_adapter2();
    init_path2();
    init_BitmapFont2();
    init_textFormat2();
    init_xmlStringFormat2();
    validExtensions2 = [".xml", ".fnt"];
    bitmapFontCachePlugin2 = {
      extension: ExtensionType3.CacheParser,
      test: (asset) => asset instanceof BitmapFont3,
      getCacheableAssets(keys, asset) {
        const out3 = {};
        keys.forEach((key2) => {
          out3[key2] = asset;
        });
        out3[asset.fontFamily] = asset;
        return out3;
      }
    };
    xmlBitmapFontLoader2 = {
      extension: {
        type: ExtensionType3.LoadParser,
        priority: LoaderParserPriority2.Normal
      },
      test(url2) {
        return validExtensions2.includes(path3.extname(url2).toLowerCase());
      },
      async testParse(data) {
        return TextFormat2.test(data) || XMLStringFormat2.test(data);
      },
      async parse(asset, data, loader) {
        const bitmapFontData = TextFormat2.test(asset) ? TextFormat2.parse(asset) : XMLStringFormat2.parse(asset);
        const { src } = data;
        const { pages } = bitmapFontData;
        const textureUrls = [];
        for (let i3 = 0; i3 < pages.length; ++i3) {
          const pageFile = pages[i3].file;
          let imagePath = path3.join(path3.dirname(src), pageFile);
          imagePath = copySearchParams2(imagePath, src);
          textureUrls.push(imagePath);
        }
        const loadedTextures = await loader.load(textureUrls);
        const textures = textureUrls.map((url2) => loadedTextures[url2]);
        const bitmapFont = new BitmapFont3({
          data: bitmapFontData,
          textures
        });
        return bitmapFont;
      },
      async load(url2, _options) {
        const response = await DOMAdapter.get().fetch(url2);
        return await response.text();
      },
      unload(bitmapFont) {
        bitmapFont.destroy();
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs
var cacheTextureArray2;
var init_cacheTextureArray2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs"() {
    init_Extensions2();
    init_Texture2();
    cacheTextureArray2 = {
      extension: ExtensionType3.CacheParser,
      test: (asset) => Array.isArray(asset) && asset.every((t2) => t2 instanceof Texture4),
      getCacheableAssets: (keys, asset) => {
        const out3 = {};
        keys.forEach((key2) => {
          asset.forEach((item, i3) => {
            out3[key2 + (i3 === 0 ? "" : i3 + 1)] = item;
          });
        });
        return out3;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs
async function testImageFormat2(imageData) {
  if ("Image" in globalThis) {
    return new Promise((resolve2) => {
      const image = new Image();
      image.onload = () => {
        resolve2(true);
      };
      image.onerror = () => {
        resolve2(false);
      };
      image.src = imageData;
    });
  }
  if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
    try {
      const blob = await (await fetch(imageData)).blob();
      await createImageBitmap(blob);
    } catch (e3) {
      return false;
    }
    return true;
  }
  return false;
}
var init_testImageFormat2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs
var detectAvif2;
var init_detectAvif2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs"() {
    init_Extensions2();
    init_testImageFormat2();
    detectAvif2 = {
      extension: {
        type: ExtensionType3.DetectionParser,
        priority: 1
      },
      test: async () => testImageFormat2(
        // eslint-disable-next-line max-len
        "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
      ),
      add: async (formats) => [...formats, "avif"],
      remove: async (formats) => formats.filter((f3) => f3 !== "avif")
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs
var imageFormats2, detectDefaults2;
var init_detectDefaults2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs"() {
    init_Extensions2();
    imageFormats2 = ["png", "jpg", "jpeg"];
    detectDefaults2 = {
      extension: {
        type: ExtensionType3.DetectionParser,
        priority: -1
      },
      test: () => Promise.resolve(true),
      add: async (formats) => [...formats, ...imageFormats2],
      remove: async (formats) => formats.filter((f3) => !imageFormats2.includes(f3))
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs
function testVideoFormat2(mimeType) {
  if (inWorker2) {
    return false;
  }
  const video = document.createElement("video");
  return video.canPlayType(mimeType) !== "";
}
var inWorker2;
var init_testVideoFormat2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs"() {
    inWorker2 = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs
var detectMp42;
var init_detectMp42 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs"() {
    init_Extensions2();
    init_testVideoFormat2();
    detectMp42 = {
      extension: {
        type: ExtensionType3.DetectionParser,
        priority: 0
      },
      test: async () => testVideoFormat2("video/mp4"),
      add: async (formats) => [...formats, "mp4", "m4v"],
      remove: async (formats) => formats.filter((f3) => f3 !== "mp4" && f3 !== "m4v")
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs
var detectOgv2;
var init_detectOgv2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs"() {
    init_Extensions2();
    init_testVideoFormat2();
    detectOgv2 = {
      extension: {
        type: ExtensionType3.DetectionParser,
        priority: 0
      },
      test: async () => testVideoFormat2("video/ogg"),
      add: async (formats) => [...formats, "ogv"],
      remove: async (formats) => formats.filter((f3) => f3 !== "ogv")
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs
var detectWebm2;
var init_detectWebm2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs"() {
    init_Extensions2();
    init_testVideoFormat2();
    detectWebm2 = {
      extension: {
        type: ExtensionType3.DetectionParser,
        priority: 0
      },
      test: async () => testVideoFormat2("video/webm"),
      add: async (formats) => [...formats, "webm"],
      remove: async (formats) => formats.filter((f3) => f3 !== "webm")
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs
var detectWebp2;
var init_detectWebp2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs"() {
    init_Extensions2();
    init_testImageFormat2();
    detectWebp2 = {
      extension: {
        type: ExtensionType3.DetectionParser,
        priority: 0
      },
      test: async () => testImageFormat2(
        "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="
      ),
      add: async (formats) => [...formats, "webp"],
      remove: async (formats) => formats.filter((f3) => f3 !== "webp")
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs
function checkDataUrl2(url2, mimes) {
  if (Array.isArray(mimes)) {
    for (const mime of mimes) {
      if (url2.startsWith(`data:${mime}`))
        return true;
    }
    return false;
  }
  return url2.startsWith(`data:${mimes}`);
}
var init_checkDataUrl2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/checkExtension.mjs
function checkExtension2(url2, extension) {
  const tempURL = url2.split("?")[0];
  const ext = path3.extname(tempURL).toLowerCase();
  if (Array.isArray(extension)) {
    return extension.includes(ext);
  }
  return ext === extension;
}
var init_checkExtension2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/checkExtension.mjs"() {
    init_path2();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs
var validJSONExtension2, validJSONMIME2, loadJson2;
var init_loadJson2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs"() {
    init_Extensions2();
    init_adapter2();
    init_checkDataUrl2();
    init_checkExtension2();
    init_LoaderParser2();
    validJSONExtension2 = ".json";
    validJSONMIME2 = "application/json";
    loadJson2 = {
      extension: {
        type: ExtensionType3.LoadParser,
        priority: LoaderParserPriority2.Low
      },
      name: "loadJson",
      test(url2) {
        return checkDataUrl2(url2, validJSONMIME2) || checkExtension2(url2, validJSONExtension2);
      },
      async load(url2) {
        const response = await DOMAdapter.get().fetch(url2);
        const json = await response.json();
        return json;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs
var validTXTExtension2, validTXTMIME2, loadTxt2;
var init_loadTxt2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs"() {
    init_Extensions2();
    init_adapter2();
    init_checkDataUrl2();
    init_checkExtension2();
    init_LoaderParser2();
    validTXTExtension2 = ".txt";
    validTXTMIME2 = "text/plain";
    loadTxt2 = {
      name: "loadTxt",
      extension: {
        type: ExtensionType3.LoadParser,
        priority: LoaderParserPriority2.Low
      },
      test(url2) {
        return checkDataUrl2(url2, validTXTMIME2) || checkExtension2(url2, validTXTExtension2);
      },
      async load(url2) {
        const response = await DOMAdapter.get().fetch(url2);
        const txt = await response.text();
        return txt;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs
function getFontFamilyName2(url2) {
  const ext = path3.extname(url2);
  const name = path3.basename(url2, ext);
  const nameWithSpaces = name.replace(/(-|_)/g, " ");
  const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
  let valid = nameTokens.length > 0;
  for (const token of nameTokens) {
    if (!token.match(CSS_IDENT_TOKEN_REGEX2)) {
      valid = false;
      break;
    }
  }
  let fontFamilyName = nameTokens.join(" ");
  if (!valid) {
    fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`;
  }
  return fontFamilyName;
}
function encodeURIWhenNeeded2(uri) {
  if (validURICharactersRegex2.test(uri)) {
    return uri;
  }
  return encodeURI(uri);
}
var validWeights2, validFontExtensions2, validFontMIMEs2, CSS_IDENT_TOKEN_REGEX2, validURICharactersRegex2, loadWebFont2;
var init_loadWebFont2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs"() {
    init_Extensions2();
    init_adapter2();
    init_warn2();
    init_path2();
    init_Cache2();
    init_checkDataUrl2();
    init_checkExtension2();
    init_LoaderParser2();
    validWeights2 = [
      "normal",
      "bold",
      "100",
      "200",
      "300",
      "400",
      "500",
      "600",
      "700",
      "800",
      "900"
    ];
    validFontExtensions2 = [".ttf", ".otf", ".woff", ".woff2"];
    validFontMIMEs2 = [
      "font/ttf",
      "font/otf",
      "font/woff",
      "font/woff2"
    ];
    CSS_IDENT_TOKEN_REGEX2 = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
    validURICharactersRegex2 = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
    loadWebFont2 = {
      extension: {
        type: ExtensionType3.LoadParser,
        priority: LoaderParserPriority2.Low
      },
      name: "loadWebFont",
      test(url2) {
        return checkDataUrl2(url2, validFontMIMEs2) || checkExtension2(url2, validFontExtensions2);
      },
      async load(url2, options) {
        const fonts = DOMAdapter.get().getFontFaceSet();
        if (fonts) {
          const fontFaces = [];
          const name = options.data?.family ?? getFontFamilyName2(url2);
          const weights = options.data?.weights?.filter((weight) => validWeights2.includes(weight)) ?? ["normal"];
          const data = options.data ?? {};
          for (let i3 = 0; i3 < weights.length; i3++) {
            const weight = weights[i3];
            const font = new FontFace(name, `url(${encodeURIWhenNeeded2(url2)})`, {
              ...data,
              weight
            });
            await font.load();
            fonts.add(font);
            fontFaces.push(font);
          }
          Cache2.set(name, {
            url: url2,
            fontFaces
          });
          return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
        }
        warn2("[loadWebFont] FontFace API is not supported. Skipping loading font");
        return null;
      },
      unload(font) {
        (Array.isArray(font) ? font : [font]).forEach((t2) => {
          Cache2.remove(t2.family);
          DOMAdapter.get().getFontFaceSet().delete(t2);
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs
function SVGToGraphicsPath2(svgPath, path4) {
  const commands = svgPath.match(/[a-df-z][^a-df-z]*/gi);
  const data = svgPath.match(/[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/g)?.map(parseFloat);
  const betterCommands = [];
  commands.forEach((command) => {
    const data2 = command.match(/[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/g)?.map(parseFloat);
    const type2 = command[0];
    let totalInstructions = 1;
    if (data2) {
      totalInstructions = data2.length / commandSizeMap2[type2.toLowerCase()];
    }
    for (let i3 = 0; i3 < totalInstructions; i3++) {
      betterCommands.push(type2);
    }
  });
  let dataIndex = 0;
  let lastX = 0;
  let lastY = 0;
  for (let i3 = 0; i3 < betterCommands.length; i3++) {
    const type2 = betterCommands[i3];
    switch (type2) {
      case "M":
        lastX = data[dataIndex++];
        lastY = data[dataIndex++];
        path4.moveTo(lastX, lastY);
        break;
      case "m":
        lastX += data[dataIndex++];
        lastY += data[dataIndex++];
        path4.moveTo(lastX, lastY);
        break;
      case "H":
        lastX = data[dataIndex++];
        path4.lineTo(lastX, lastY);
        break;
      case "h":
        lastX += data[dataIndex++];
        path4.lineTo(lastX, lastY);
        break;
      case "V":
        lastY = data[dataIndex++];
        path4.lineTo(lastX, lastY);
        break;
      case "v":
        lastY += data[dataIndex++];
        path4.lineTo(lastX, lastY);
        break;
      case "L":
        lastX = data[dataIndex++];
        lastY = data[dataIndex++];
        path4.lineTo(lastX, lastY);
        break;
      case "l":
        lastX += data[dataIndex++];
        lastY += data[dataIndex++];
        path4.lineTo(lastX, lastY);
        break;
      case "C":
        lastX = data[dataIndex + 4];
        lastY = data[dataIndex + 5];
        path4.bezierCurveTo(
          data[dataIndex],
          data[dataIndex + 1],
          data[dataIndex + 2],
          data[dataIndex + 3],
          lastX,
          lastY
        );
        dataIndex += 6;
        break;
      case "c":
        path4.bezierCurveTo(
          lastX + data[dataIndex],
          lastY + data[dataIndex + 1],
          lastX + data[dataIndex + 2],
          lastY + data[dataIndex + 3],
          lastX + data[dataIndex + 4],
          lastY + data[dataIndex + 5]
        );
        lastX += data[dataIndex + 4];
        lastY += data[dataIndex + 5];
        dataIndex += 6;
        break;
      case "S":
        lastX = data[dataIndex + 2];
        lastY = data[dataIndex + 3];
        path4.bezierCurveToShort(
          data[dataIndex],
          data[dataIndex + 1],
          lastX,
          lastY
        );
        dataIndex += 4;
        break;
      case "s":
        path4.bezierCurveToShort(
          lastX + data[dataIndex],
          lastY + data[dataIndex + 1],
          lastX + data[dataIndex + 2],
          lastY + data[dataIndex + 3]
        );
        lastX += data[dataIndex + 2];
        lastY += data[dataIndex + 3];
        dataIndex += 4;
        break;
      case "Q":
        lastX = data[dataIndex + 2];
        lastY = data[dataIndex + 3];
        path4.quadraticCurveTo(
          data[dataIndex],
          data[dataIndex + 1],
          lastX,
          lastY
        );
        dataIndex += 4;
        break;
      case "q":
        path4.quadraticCurveTo(
          lastX + data[dataIndex],
          lastY + data[dataIndex + 1],
          lastX + data[dataIndex + 2],
          lastY + data[dataIndex + 3]
        );
        lastX += data[dataIndex + 2];
        lastY += data[dataIndex + 3];
        dataIndex += 4;
        break;
      case "T":
        lastX = data[dataIndex++];
        lastY = data[dataIndex++];
        path4.quadraticCurveToShort(
          lastX,
          lastY
        );
        break;
      case "t":
        lastX += data[dataIndex++];
        lastY += data[dataIndex++];
        path4.quadraticCurveToShort(
          lastX,
          lastY
        );
        break;
      case "A":
        lastX = data[dataIndex + 5];
        lastY = data[dataIndex + 6];
        path4.arcToSvg(
          data[dataIndex],
          data[dataIndex + 1],
          data[dataIndex + 2],
          data[dataIndex + 3],
          data[dataIndex + 4],
          lastX,
          lastY
        );
        dataIndex += 7;
        break;
      case "a":
        lastX += data[dataIndex + 5];
        lastY += data[dataIndex + 6];
        path4.arcToSvg(
          data[dataIndex],
          data[dataIndex + 1],
          data[dataIndex + 2],
          data[dataIndex + 3],
          data[dataIndex + 4],
          lastX,
          lastY
        );
        dataIndex += 7;
        break;
      case "Z":
      case "z":
        path4.closePath();
        break;
      default:
        warn2(`Unknown SVG path command: ${type2}`);
    }
  }
  return path4;
}
var commandSizeMap2;
var init_SVGToGraphicsPath2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs"() {
    init_warn2();
    commandSizeMap2 = {
      a: 7,
      c: 6,
      h: 1,
      l: 2,
      m: 2,
      q: 4,
      s: 4,
      t: 2,
      v: 1,
      z: 0
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/shapes/Circle.mjs
var Circle3;
var init_Circle2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/shapes/Circle.mjs"() {
    init_Rectangle2();
    Circle3 = class _Circle {
      /**
       * @param x - The X coordinate of the center of this circle
       * @param y - The Y coordinate of the center of this circle
       * @param radius - The radius of the circle
       */
      constructor(x3 = 0, y2 = 0, radius = 0) {
        this.type = "circle";
        this.x = x3;
        this.y = y2;
        this.radius = radius;
      }
      /**
       * Creates a clone of this Circle instance
       * @returns A copy of the Circle
       */
      clone() {
        return new _Circle(this.x, this.y, this.radius);
      }
      /**
       * Checks whether the x and y coordinates given are contained within this circle
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coordinates are within this Circle
       */
      contains(x3, y2) {
        if (this.radius <= 0) {
          return false;
        }
        const r2 = this.radius * this.radius;
        let dx = this.x - x3;
        let dy = this.y - y2;
        dx *= dx;
        dy *= dy;
        return dx + dy <= r2;
      }
      /**
       * Returns the framing rectangle of the circle as a Rectangle object
       * @param out
       * @returns The framing rectangle
       */
      getBounds(out3) {
        out3 = out3 || new Rectangle3();
        out3.x = this.x - this.radius;
        out3.y = this.y - this.radius;
        out3.width = this.radius * 2;
        out3.height = this.radius * 2;
        return out3;
      }
      /**
       * Copies another circle to this one.
       * @param circle - The circle to copy from.
       * @returns Returns itself.
       */
      copyFrom(circle) {
        this.x = circle.x;
        this.y = circle.y;
        this.radius = circle.radius;
        return this;
      }
      /**
       * Copies this circle to another one.
       * @param circle - The circle to copy to.
       * @returns Returns given parameter.
       */
      copyTo(circle) {
        circle.copyFrom(this);
        return circle;
      }
      toString() {
        return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs
var Ellipse3;
var init_Ellipse2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs"() {
    init_Rectangle2();
    Ellipse3 = class _Ellipse {
      /**
       * @param x - The X coordinate of the center of this ellipse
       * @param y - The Y coordinate of the center of this ellipse
       * @param halfWidth - The half width of this ellipse
       * @param halfHeight - The half height of this ellipse
       */
      constructor(x3 = 0, y2 = 0, halfWidth = 0, halfHeight = 0) {
        this.type = "ellipse";
        this.x = x3;
        this.y = y2;
        this.halfWidth = halfWidth;
        this.halfHeight = halfHeight;
      }
      /**
       * Creates a clone of this Ellipse instance
       * @returns {Ellipse} A copy of the ellipse
       */
      clone() {
        return new _Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);
      }
      /**
       * Checks whether the x and y coordinates given are contained within this ellipse
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coords are within this ellipse
       */
      contains(x3, y2) {
        if (this.halfWidth <= 0 || this.halfHeight <= 0) {
          return false;
        }
        let normx = (x3 - this.x) / this.halfWidth;
        let normy = (y2 - this.y) / this.halfHeight;
        normx *= normx;
        normy *= normy;
        return normx + normy <= 1;
      }
      /**
       * Returns the framing rectangle of the ellipse as a Rectangle object
       * @returns The framing rectangle
       */
      getBounds() {
        return new Rectangle3(this.x - this.halfWidth, this.y - this.halfHeight, this.halfWidth * 2, this.halfHeight * 2);
      }
      /**
       * Copies another ellipse to this one.
       * @param ellipse - The ellipse to copy from.
       * @returns Returns itself.
       */
      copyFrom(ellipse) {
        this.x = ellipse.x;
        this.y = ellipse.y;
        this.halfWidth = ellipse.halfWidth;
        this.halfHeight = ellipse.halfHeight;
        return this;
      }
      /**
       * Copies this ellipse to another one.
       * @param ellipse - The ellipse to copy to.
       * @returns Returns given parameter.
       */
      copyTo(ellipse) {
        ellipse.copyFrom(this);
        return ellipse;
      }
      toString() {
        return `[@pixi/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/shapes/Polygon.mjs
var Polygon3;
var init_Polygon2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/shapes/Polygon.mjs"() {
    init_Rectangle2();
    Polygon3 = class _Polygon {
      /**
       * @param {PointData[]|number[]} points - This can be an array of Points
       *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
       *  the arguments passed can be all the points of the polygon e.g.
       *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
       *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
       */
      constructor(...points) {
        this.type = "polygon";
        let flat = Array.isArray(points[0]) ? points[0] : points;
        if (typeof flat[0] !== "number") {
          const p3 = [];
          for (let i3 = 0, il = flat.length; i3 < il; i3++) {
            p3.push(flat[i3].x, flat[i3].y);
          }
          flat = p3;
        }
        this.points = flat;
        this.closePath = true;
      }
      /**
       * Creates a clone of this polygon.
       * @returns - A copy of the polygon.
       */
      clone() {
        const points = this.points.slice();
        const polygon = new _Polygon(points);
        polygon.closePath = this.closePath;
        return polygon;
      }
      /**
       * Checks whether the x and y coordinates passed to this function are contained within this polygon.
       * @param x - The X coordinate of the point to test.
       * @param y - The Y coordinate of the point to test.
       * @returns - Whether the x/y coordinates are within this polygon.
       */
      contains(x3, y2) {
        let inside = false;
        const length = this.points.length / 2;
        for (let i3 = 0, j3 = length - 1; i3 < length; j3 = i3++) {
          const xi = this.points[i3 * 2];
          const yi = this.points[i3 * 2 + 1];
          const xj = this.points[j3 * 2];
          const yj = this.points[j3 * 2 + 1];
          const intersect = yi > y2 !== yj > y2 && x3 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi;
          if (intersect) {
            inside = !inside;
          }
        }
        return inside;
      }
      /**
       * Returns the framing rectangle of the polygon as a Rectangle object
       * @param out - optional rectangle to store the result
       * @returns The framing rectangle
       */
      getBounds(out3) {
        out3 = out3 || new Rectangle3();
        const points = this.points;
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        for (let i3 = 0, n2 = points.length; i3 < n2; i3 += 2) {
          const x3 = points[i3];
          const y2 = points[i3 + 1];
          minX = x3 < minX ? x3 : minX;
          maxX = x3 > maxX ? x3 : maxX;
          minY = y2 < minY ? y2 : minY;
          maxY = y2 > maxY ? y2 : maxY;
        }
        out3.x = minX;
        out3.width = maxX - minX;
        out3.y = minY;
        out3.height = maxY - minY;
        return out3;
      }
      /**
       * Copies another polygon to this one.
       * @param polygon - The polygon to copy from.
       * @returns Returns itself.
       */
      copyFrom(polygon) {
        this.points = polygon.points.slice();
        this.closePath = polygon.closePath;
        return this;
      }
      /**
       * Copies this polygon to another one.
       * @param polygon - The polygon to copy to.
       * @returns Returns given parameter.
       */
      copyTo(polygon) {
        polygon.copyFrom(this);
        return polygon;
      }
      toString() {
        return `[@pixi/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
      }
      /**
       * Get the last X coordinate of the polygon
       * @readonly
       */
      get lastX() {
        return this.points[this.points.length - 2];
      }
      /**
       * Get the last Y coordinate of the polygon
       * @readonly
       */
      get lastY() {
        return this.points[this.points.length - 1];
      }
      /**
       * Get the first X coordinate of the polygon
       * @readonly
       */
      get x() {
        return this.points[this.points.length - 2];
      }
      /**
       * Get the first Y coordinate of the polygon
       * @readonly
       */
      get y() {
        return this.points[this.points.length - 1];
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs
var RoundedRectangle3;
var init_RoundedRectangle2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs"() {
    init_Rectangle2();
    RoundedRectangle3 = class _RoundedRectangle {
      /**
       * @param x - The X coordinate of the upper-left corner of the rounded rectangle
       * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
       * @param width - The overall width of this rounded rectangle
       * @param height - The overall height of this rounded rectangle
       * @param radius - Controls the radius of the rounded corners
       */
      constructor(x3 = 0, y2 = 0, width = 0, height = 0, radius = 20) {
        this.type = "roundedRectangle";
        this.x = x3;
        this.y = y2;
        this.width = width;
        this.height = height;
        this.radius = radius;
      }
      /**
       * Returns the framing rectangle of the rounded rectangle as a Rectangle object
       * @param out - optional rectangle to store the result
       * @returns The framing rectangle
       */
      getBounds(out3) {
        out3 = out3 || new Rectangle3();
        out3.x = this.x;
        out3.y = this.y;
        out3.width = this.width;
        out3.height = this.height;
        return out3;
      }
      /**
       * Creates a clone of this Rounded Rectangle.
       * @returns - A copy of the rounded rectangle.
       */
      clone() {
        return new _RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
      }
      /**
       * Copies another rectangle to this one.
       * @param rectangle - The rectangle to copy from.
       * @returns Returns itself.
       */
      copyFrom(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
      }
      /**
       * Copies this rectangle to another one.
       * @param rectangle - The rectangle to copy to.
       * @returns Returns given parameter.
       */
      copyTo(rectangle) {
        rectangle.copyFrom(this);
        return rectangle;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
       * @param x - The X coordinate of the point to test.
       * @param y - The Y coordinate of the point to test.
       * @returns - Whether the x/y coordinates are within this Rounded Rectangle.
       */
      contains(x3, y2) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x3 >= this.x && x3 <= this.x + this.width) {
          if (y2 >= this.y && y2 <= this.y + this.height) {
            const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
            if (y2 >= this.y + radius && y2 <= this.y + this.height - radius || x3 >= this.x + radius && x3 <= this.x + this.width - radius) {
              return true;
            }
            let dx = x3 - (this.x + radius);
            let dy = y2 - (this.y + radius);
            const radius2 = radius * radius;
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dx = x3 - (this.x + this.width - radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dy = y2 - (this.y + this.height - radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dx = x3 - (this.x + radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
          }
        }
        return false;
      }
      toString() {
        return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs
function buildAdaptiveBezier2(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY) {
  const scale3 = 1;
  let distanceTolerance = PATH_DISTANCE_EPSILON3 / scale3;
  distanceTolerance *= distanceTolerance;
  begin3(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);
  return points;
}
function begin3(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {
  recursive3(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);
  points.push(eX, eY);
}
function recursive3(x1, y1, x22, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
  if (level > RECURSION_LIMIT3) {
    return;
  }
  const pi = Math.PI;
  const x12 = (x1 + x22) / 2;
  const y12 = (y1 + y2) / 2;
  const x23 = (x22 + x3) / 2;
  const y23 = (y2 + y3) / 2;
  const x34 = (x3 + x4) / 2;
  const y34 = (y3 + y4) / 2;
  const x123 = (x12 + x23) / 2;
  const y123 = (y12 + y23) / 2;
  const x234 = (x23 + x34) / 2;
  const y234 = (y23 + y34) / 2;
  const x1234 = (x123 + x234) / 2;
  const y1234 = (y123 + y234) / 2;
  if (level > 0) {
    let dx = x4 - x1;
    let dy = y4 - y1;
    const d22 = Math.abs((x22 - x4) * dy - (y2 - y4) * dx);
    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);
    let da1;
    let da2;
    if (d22 > FLT_EPSILON3 && d3 > FLT_EPSILON3) {
      if ((d22 + d3) * (d22 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance3 < curveAngleToleranceEpsilon3) {
          points.push(x1234, y1234);
          return;
        }
        const a23 = Math.atan2(y3 - y2, x3 - x22);
        da1 = Math.abs(a23 - Math.atan2(y2 - y1, x22 - x1));
        da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da2 >= pi)
          da2 = 2 * pi - da2;
        if (da1 + da2 < mAngleTolerance3) {
          points.push(x1234, y1234);
          return;
        }
        if (mCuspLimit2 !== 0) {
          if (da1 > mCuspLimit2) {
            points.push(x22, y2);
            return;
          }
          if (da2 > mCuspLimit2) {
            points.push(x3, y3);
            return;
          }
        }
      }
    } else if (d22 > FLT_EPSILON3) {
      if (d22 * d22 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance3 < curveAngleToleranceEpsilon3) {
          points.push(x1234, y1234);
          return;
        }
        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x22) - Math.atan2(y2 - y1, x22 - x1));
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da1 < mAngleTolerance3) {
          points.push(x22, y2);
          points.push(x3, y3);
          return;
        }
        if (mCuspLimit2 !== 0) {
          if (da1 > mCuspLimit2) {
            points.push(x22, y2);
            return;
          }
        }
      }
    } else if (d3 > FLT_EPSILON3) {
      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance3 < curveAngleToleranceEpsilon3) {
          points.push(x1234, y1234);
          return;
        }
        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x22));
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da1 < mAngleTolerance3) {
          points.push(x22, y2);
          points.push(x3, y3);
          return;
        }
        if (mCuspLimit2 !== 0) {
          if (da1 > mCuspLimit2) {
            points.push(x3, y3);
            return;
          }
        }
      }
    } else {
      dx = x1234 - (x1 + x4) / 2;
      dy = y1234 - (y1 + y4) / 2;
      if (dx * dx + dy * dy <= distanceTolerance) {
        points.push(x1234, y1234);
        return;
      }
    }
  }
  recursive3(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);
  recursive3(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);
}
var RECURSION_LIMIT3, FLT_EPSILON3, PATH_DISTANCE_EPSILON3, curveAngleToleranceEpsilon3, mAngleTolerance3, mCuspLimit2;
var init_buildAdaptiveBezier2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs"() {
    RECURSION_LIMIT3 = 8;
    FLT_EPSILON3 = 11920929e-14;
    PATH_DISTANCE_EPSILON3 = 1;
    curveAngleToleranceEpsilon3 = 0.01;
    mAngleTolerance3 = 0;
    mCuspLimit2 = 0;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs
function buildAdaptiveQuadratic2(points, sX, sY, cp1x, cp1y, eX, eY) {
  const scale3 = 1;
  let distanceTolerance = PATH_DISTANCE_EPSILON4 / scale3;
  distanceTolerance *= distanceTolerance;
  begin4(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);
  return points;
}
function begin4(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {
  recursive4(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);
  points.push(eX, eY);
}
function recursive4(points, x1, y1, x22, y2, x3, y3, distanceTolerance, level) {
  if (level > RECURSION_LIMIT4) {
    return;
  }
  const pi = Math.PI;
  const x12 = (x1 + x22) / 2;
  const y12 = (y1 + y2) / 2;
  const x23 = (x22 + x3) / 2;
  const y23 = (y2 + y3) / 2;
  const x123 = (x12 + x23) / 2;
  const y123 = (y12 + y23) / 2;
  let dx = x3 - x1;
  let dy = y3 - y1;
  const d3 = Math.abs((x22 - x3) * dy - (y2 - y3) * dx);
  if (d3 > FLT_EPSILON4) {
    if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
      if (mAngleTolerance4 < curveAngleToleranceEpsilon4) {
        points.push(x123, y123);
        return;
      }
      let da = Math.abs(Math.atan2(y3 - y2, x3 - x22) - Math.atan2(y2 - y1, x22 - x1));
      if (da >= pi)
        da = 2 * pi - da;
      if (da < mAngleTolerance4) {
        points.push(x123, y123);
        return;
      }
    }
  } else {
    dx = x123 - (x1 + x3) / 2;
    dy = y123 - (y1 + y3) / 2;
    if (dx * dx + dy * dy <= distanceTolerance) {
      points.push(x123, y123);
      return;
    }
  }
  recursive4(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);
  recursive4(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);
}
var RECURSION_LIMIT4, FLT_EPSILON4, PATH_DISTANCE_EPSILON4, curveAngleToleranceEpsilon4, mAngleTolerance4;
var init_buildAdaptiveQuadratic2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs"() {
    RECURSION_LIMIT4 = 8;
    FLT_EPSILON4 = 11920929e-14;
    PATH_DISTANCE_EPSILON4 = 1;
    curveAngleToleranceEpsilon4 = 0.01;
    mAngleTolerance4 = 0;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs
function buildArc2(points, x3, y2, radius, start, end, clockwise, steps) {
  let dist = Math.abs(start - end);
  if (!clockwise && start > end) {
    dist = 2 * Math.PI - dist;
  } else if (clockwise && end > start) {
    dist = 2 * Math.PI - dist;
  }
  steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI)));
  steps = Math.max(steps, 3);
  let f3 = dist / steps;
  let t2 = start;
  f3 *= clockwise ? -1 : 1;
  for (let i3 = 0; i3 < steps + 1; i3++) {
    const cs = Math.cos(t2);
    const sn = Math.sin(t2);
    const nx = x3 + cs * radius;
    const ny = y2 + sn * radius;
    points.push(nx, ny);
    t2 += f3;
  }
}
var init_buildArc2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs
function buildArcTo2(points, x1, y1, x22, y2, radius) {
  const fromX = points[points.length - 2];
  const fromY = points[points.length - 1];
  const a1 = fromY - y1;
  const b1 = fromX - x1;
  const a2 = y2 - y1;
  const b2 = x22 - x1;
  const mm = Math.abs(a1 * b2 - b1 * a2);
  if (mm < 1e-8 || radius === 0) {
    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
      points.push(x1, y1);
    }
    return;
  }
  const dd = a1 * a1 + b1 * b1;
  const cc = a2 * a2 + b2 * b2;
  const tt = a1 * a2 + b1 * b2;
  const k1 = radius * Math.sqrt(dd) / mm;
  const k22 = radius * Math.sqrt(cc) / mm;
  const j1 = k1 * tt / dd;
  const j22 = k22 * tt / cc;
  const cx = k1 * b2 + k22 * b1;
  const cy = k1 * a2 + k22 * a1;
  const px = b1 * (k22 + j1);
  const py = a1 * (k22 + j1);
  const qx = b2 * (k1 + j22);
  const qy = a2 * (k1 + j22);
  const startAngle = Math.atan2(py - cy, px - cx);
  const endAngle = Math.atan2(qy - cy, qx - cx);
  buildArc2(
    points,
    cx + x1,
    cy + y1,
    radius,
    startAngle,
    endAngle,
    b1 * a2 > b2 * a1
  );
}
var init_buildArcTo2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs"() {
    init_buildArc2();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs
function approxUnitArc2(ang1, ang2) {
  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  const a2 = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;
  const x1 = Math.cos(ang1);
  const y1 = Math.sin(ang1);
  const x22 = Math.cos(ang1 + ang2);
  const y2 = Math.sin(ang1 + ang2);
  return [
    {
      x: x1 - y1 * a2,
      y: y1 + x1 * a2
    },
    {
      x: x22 + y2 * a2,
      y: y2 - x22 * a2
    },
    {
      x: x22,
      y: y2
    }
  ];
}
function buildArcToSvg2(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {
  if (rx === 0 || ry === 0) {
    return;
  }
  const sinPhi = Math.sin(xAxisRotation * TAU2 / 360);
  const cosPhi = Math.cos(xAxisRotation * TAU2 / 360);
  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;
  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;
  if (pxp === 0 && pyp === 0) {
    return;
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  getArcCenter2(
    px,
    py,
    cx,
    cy,
    rx,
    ry,
    largeArcFlag,
    sweepFlag,
    sinPhi,
    cosPhi,
    pxp,
    pyp,
    out2
  );
  let { ang1, ang2 } = out2;
  const { centerX, centerY } = out2;
  let ratio = Math.abs(ang2) / (TAU2 / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  const segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  let lastX = points[points.length - 2];
  let lastY = points[points.length - 1];
  const outCurvePoint = { x: 0, y: 0 };
  for (let i3 = 0; i3 < segments; i3++) {
    const curve = approxUnitArc2(ang1, ang2);
    const { x: x1, y: y1 } = mapToEllipse2(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    const { x: x22, y: y2 } = mapToEllipse2(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    const { x: x3, y: y3 } = mapToEllipse2(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    buildAdaptiveBezier2(
      points,
      lastX,
      lastY,
      x1,
      y1,
      x22,
      y2,
      x3,
      y3
    );
    lastX = x3;
    lastY = y3;
    ang1 += ang2;
  }
}
var TAU2, out2, mapToEllipse2, vectorAngle2, getArcCenter2;
var init_buildArcToSvg2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs"() {
    init_buildAdaptiveBezier2();
    TAU2 = Math.PI * 2;
    out2 = {
      centerX: 0,
      centerY: 0,
      ang1: 0,
      ang2: 0
    };
    mapToEllipse2 = ({ x: x3, y: y2 }, rx, ry, cosPhi, sinPhi, centerX, centerY, out22) => {
      x3 *= rx;
      y2 *= ry;
      const xp = cosPhi * x3 - sinPhi * y2;
      const yp = sinPhi * x3 + cosPhi * y2;
      out22.x = xp + centerX;
      out22.y = yp + centerY;
      return out22;
    };
    vectorAngle2 = (ux4, uy4, vx4, vy4) => {
      const sign2 = ux4 * vy4 - uy4 * vx4 < 0 ? -1 : 1;
      let dot = ux4 * vx4 + uy4 * vy4;
      if (dot > 1) {
        dot = 1;
      }
      if (dot < -1) {
        dot = -1;
      }
      return sign2 * Math.acos(dot);
    };
    getArcCenter2 = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out22) => {
      const rxSq = Math.pow(rx, 2);
      const rySq = Math.pow(ry, 2);
      const pxpSq = Math.pow(pxp, 2);
      const pypSq = Math.pow(pyp, 2);
      let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;
      if (radicant < 0) {
        radicant = 0;
      }
      radicant /= rxSq * pypSq + rySq * pxpSq;
      radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
      const centerXp = radicant * rx / ry * pyp;
      const centerYp = radicant * -ry / rx * pxp;
      const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;
      const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;
      const vx1 = (pxp - centerXp) / rx;
      const vy1 = (pyp - centerYp) / ry;
      const vx22 = (-pxp - centerXp) / rx;
      const vy22 = (-pyp - centerYp) / ry;
      const ang1 = vectorAngle2(1, 0, vx1, vy1);
      let ang2 = vectorAngle2(vx1, vy1, vx22, vy22);
      if (sweepFlag === 0 && ang2 > 0) {
        ang2 -= TAU2;
      }
      if (sweepFlag === 1 && ang2 < 0) {
        ang2 += TAU2;
      }
      out22.centerX = centerX;
      out22.centerY = centerY;
      out22.ang1 = ang1;
      out22.ang2 = ang2;
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs
var tempRectangle3, ShapePath2;
var init_ShapePath2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs"() {
    init_Circle2();
    init_Ellipse2();
    init_Polygon2();
    init_Rectangle2();
    init_RoundedRectangle2();
    init_Bounds2();
    init_buildAdaptiveBezier2();
    init_buildAdaptiveQuadratic2();
    init_buildArc2();
    init_buildArcTo2();
    init_buildArcToSvg2();
    tempRectangle3 = new Rectangle3();
    ShapePath2 = class {
      constructor(graphicsPath2D) {
        this.shapePrimitives = [];
        this._currentPoly = null;
        this._bounds = new Bounds2();
        this._graphicsPath2D = graphicsPath2D;
      }
      moveTo(x3, y2) {
        this.startPoly(x3, y2);
        return this;
      }
      lineTo(x3, y2) {
        this._ensurePoly();
        const points = this._currentPoly.points;
        const fromX = points[points.length - 2];
        const fromY = points[points.length - 1];
        if (fromX !== x3 || fromY !== y2) {
          points.push(x3, y2);
        }
        return this;
      }
      arc(x3, y2, radius, startAngle, endAngle, anticlockwise) {
        this._ensurePoly(false);
        const points = this._currentPoly.points;
        buildArc2(points, x3, y2, radius, startAngle, endAngle, anticlockwise);
        return this;
      }
      arcTo(x1, y1, x22, y2, radius) {
        this._ensurePoly();
        const points = this._currentPoly.points;
        buildArcTo2(points, x1, y1, x22, y2, radius);
        return this;
      }
      arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x3, y2) {
        const points = this._currentPoly.points;
        buildArcToSvg2(
          points,
          this._currentPoly.lastX,
          this._currentPoly.lastY,
          x3,
          y2,
          rx,
          ry,
          xAxisRotation,
          largeArcFlag,
          sweepFlag
        );
        return this;
      }
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x3, y2) {
        this._ensurePoly();
        const currentPoly = this._currentPoly;
        buildAdaptiveBezier2(
          this._currentPoly.points,
          currentPoly.lastX,
          currentPoly.lastY,
          cp1x,
          cp1y,
          cp2x,
          cp2y,
          x3,
          y2
        );
        return this;
      }
      quadraticCurveTo(cp1x, cp1y, x3, y2) {
        this._ensurePoly();
        const currentPoly = this._currentPoly;
        buildAdaptiveQuadratic2(
          this._currentPoly.points,
          currentPoly.lastX,
          currentPoly.lastY,
          cp1x,
          cp1y,
          x3,
          y2
        );
        return this;
      }
      closePath() {
        this.endPoly(true);
        return this;
      }
      addPath(path4, transform) {
        this.endPoly();
        if (transform && !transform.isIdentity()) {
          path4 = path4.clone(true);
          path4.transform(transform);
        }
        for (let i3 = 0; i3 < path4.instructions.length; i3++) {
          const instruction = path4.instructions[i3];
          this[instruction.action](...instruction.data);
        }
        return this;
      }
      finish(closePath = false) {
        this.endPoly(closePath);
      }
      rect(x3, y2, w2, h2, transform) {
        this.drawShape(new Rectangle3(x3, y2, w2, h2), transform);
        return this;
      }
      circle(x3, y2, radius, transform) {
        this.drawShape(new Circle3(x3, y2, radius), transform);
        return this;
      }
      poly(points, close, transform) {
        const polygon = new Polygon3(points);
        polygon.closePath = close;
        this.drawShape(polygon, transform);
      }
      ellipse(x3, y2, radiusX, radiusY, transform) {
        this.drawShape(new Ellipse3(x3, y2, radiusX, radiusY), transform);
        return this;
      }
      roundRect(x3, y2, w2, h2, radii, transform) {
        this.drawShape(new RoundedRectangle3(x3, y2, w2, h2, radii), transform);
        return this;
      }
      drawShape(shape, matrix) {
        this.endPoly();
        this.shapePrimitives.push({ shape, transform: matrix });
        return this;
      }
      startPoly(x3, y2) {
        let currentPoly = this._currentPoly;
        if (currentPoly) {
          this.endPoly();
        }
        currentPoly = new Polygon3();
        currentPoly.points.push(x3, y2);
        this._currentPoly = currentPoly;
        return this;
      }
      endPoly(closePath = false) {
        const shape = this._currentPoly;
        if (shape && shape.points.length > 2) {
          shape.closePath = closePath;
          this.shapePrimitives.push({ shape });
        }
        this._currentPoly = null;
        return this;
      }
      _ensurePoly(start = true) {
        if (this._currentPoly)
          return;
        this._currentPoly = new Polygon3();
        if (start) {
          const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];
          if (lastShape) {
            let lx = lastShape.shape.x;
            let ly = lastShape.shape.y;
            if (lastShape.transform.isIdentity()) {
              const t2 = lastShape.transform;
              const tempX = lx;
              lx = t2.a * lx + t2.c * ly + t2.tx;
              ly = t2.b * tempX + t2.d * ly + t2.ty;
            }
            this._currentPoly.points.push(lx, lx);
          } else {
            this._currentPoly.points.push(0, 0);
          }
        }
      }
      buildPath() {
        const path4 = this._graphicsPath2D;
        this.shapePrimitives.length = 0;
        this._currentPoly = null;
        for (let i3 = 0; i3 < path4.instructions.length; i3++) {
          const instruction = path4.instructions[i3];
          this[instruction.action](...instruction.data);
        }
        this.finish();
      }
      get bounds() {
        const bounds = this._bounds;
        bounds.clear();
        const shapePrimitives = this.shapePrimitives;
        for (let i3 = 0; i3 < shapePrimitives.length; i3++) {
          const shapePrimitive = shapePrimitives[i3];
          const boundsRect = shapePrimitive.shape.getBounds(tempRectangle3);
          if (shapePrimitive.transform) {
            bounds.pushMatrix(shapePrimitive.transform);
            bounds.addRect(boundsRect);
            bounds.popMatrix();
          } else {
            bounds.addRect(boundsRect);
          }
        }
        return bounds;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs
function adjustTransform2(currentMatrix, transform) {
  if (currentMatrix) {
    return currentMatrix.prepend(transform);
  }
  return transform.clone();
}
var GraphicsPath2;
var init_GraphicsPath2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs"() {
    init_Point2();
    init_uid2();
    init_warn2();
    init_SVGToGraphicsPath2();
    init_ShapePath2();
    GraphicsPath2 = class _GraphicsPath {
      constructor(instructions) {
        this.instructions = [];
        this.uid = uid3("graphicsPath");
        this._dirty = true;
        if (typeof instructions === "string") {
          SVGToGraphicsPath2(instructions, this);
        } else {
          this.instructions = instructions?.slice() ?? [];
        }
      }
      get shapePath() {
        if (!this._shapePath) {
          this._shapePath = new ShapePath2(this);
        }
        if (this._dirty) {
          this._dirty = false;
          this._shapePath.buildPath();
        }
        return this._shapePath;
      }
      addPath(path4, transform) {
        path4 = path4.clone();
        this.instructions.push({ action: "addPath", data: [path4, transform] });
        this._dirty = true;
        return this;
      }
      arc(...args) {
        this.instructions.push({ action: "arc", data: args });
        this._dirty = true;
        return this;
      }
      arcTo(...args) {
        this.instructions.push({ action: "arcTo", data: args });
        this._dirty = true;
        return this;
      }
      arcToSvg(...args) {
        this.instructions.push({ action: "arcToSvg", data: args });
        this._dirty = true;
        return this;
      }
      bezierCurveTo(...args) {
        this.instructions.push({ action: "bezierCurveTo", data: args });
        this._dirty = true;
        return this;
      }
      bezierCurveToShort(cp2x, cp2y, x3, y2) {
        const last = this.instructions[this.instructions.length - 1];
        const lastPoint = this._getLastPoint(Point3.shared);
        let cp1x = 0;
        let cp1y = 0;
        if (!last || last.action !== "bezierCurveTo") {
          cp1x = lastPoint.x;
          cp1y = lastPoint.y;
        } else {
          cp1x = last.data[2];
          cp1y = last.data[3];
          const currentX = lastPoint.x;
          const currentY = lastPoint.y;
          cp1x = currentX + (currentX - cp1x);
          cp1y = currentY + (currentY - cp1y);
        }
        this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x3, y2] });
        this._dirty = true;
        return this;
      }
      closePath() {
        this.instructions.push({ action: "closePath", data: [] });
        this._dirty = true;
        return this;
      }
      ellipse(...args) {
        this.instructions.push({ action: "ellipse", data: args });
        this._dirty = true;
        return this;
      }
      lineTo(...args) {
        this.instructions.push({ action: "lineTo", data: args });
        this._dirty = true;
        return this;
      }
      moveTo(...args) {
        this.instructions.push({ action: "moveTo", data: args });
        return this;
      }
      quadraticCurveTo(...args) {
        this.instructions.push({ action: "quadraticCurveTo", data: args });
        this._dirty = true;
        return this;
      }
      quadraticCurveToShort(x3, y2) {
        const last = this.instructions[this.instructions.length - 1];
        const lastPoint = this._getLastPoint(Point3.shared);
        let cpx1 = 0;
        let cpy1 = 0;
        if (!last || last.action !== "quadraticCurveTo") {
          cpx1 = lastPoint.x;
          cpy1 = lastPoint.y;
        } else {
          cpx1 = last.data[0];
          cpy1 = last.data[1];
          const currentX = lastPoint.x;
          const currentY = lastPoint.y;
          cpx1 = currentX + (currentX - cpx1);
          cpy1 = currentY + (currentY - cpy1);
        }
        this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x3, y2] });
        this._dirty = true;
        return this;
      }
      rect(x3, y2, w2, h2, transform) {
        this.instructions.push({ action: "rect", data: [x3, y2, w2, h2, transform] });
        this._dirty = true;
        return this;
      }
      circle(x3, y2, radius, transform) {
        this.instructions.push({ action: "circle", data: [x3, y2, radius, transform] });
        this._dirty = true;
        return this;
      }
      roundRect(...args) {
        this.instructions.push({ action: "roundRect", data: args });
        this._dirty = true;
        return this;
      }
      poly(...args) {
        this.instructions.push({ action: "poly", data: args });
        this._dirty = true;
        return this;
      }
      // eslint-disable-next-line max-len
      star(x3, y2, points, radius, innerRadius, rotation = 0, transform) {
        innerRadius = innerRadius || radius / 2;
        const startAngle = -1 * Math.PI / 2 + rotation;
        const len = points * 2;
        const delta = Math.PI * 2 / len;
        const polygon = [];
        for (let i3 = 0; i3 < len; i3++) {
          const r2 = i3 % 2 ? innerRadius : radius;
          const angle = i3 * delta + startAngle;
          polygon.push(
            x3 + r2 * Math.cos(angle),
            y2 + r2 * Math.sin(angle)
          );
        }
        this.poly(polygon, true, transform);
        return this;
      }
      clone(deep = false) {
        const newGraphicsPath2D = new _GraphicsPath();
        if (!deep) {
          newGraphicsPath2D.instructions = this.instructions.slice();
        } else {
          for (let i3 = 0; i3 < this.instructions.length; i3++) {
            const instruction = this.instructions[i3];
            newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });
          }
        }
        return newGraphicsPath2D;
      }
      clear() {
        this.instructions.length = 0;
        this._dirty = true;
        return this;
      }
      transform(matrix) {
        if (matrix.isIdentity())
          return this;
        const a2 = matrix.a;
        const b2 = matrix.b;
        const c2 = matrix.c;
        const d3 = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        let x3 = 0;
        let y2 = 0;
        let cpx1 = 0;
        let cpy1 = 0;
        let cpx2 = 0;
        let cpy2 = 0;
        let rx = 0;
        let ry = 0;
        for (let i3 = 0; i3 < this.instructions.length; i3++) {
          const instruction = this.instructions[i3];
          const data = instruction.data;
          switch (instruction.action) {
            case "moveTo":
            case "lineTo":
              x3 = data[0];
              y2 = data[1];
              data[0] = a2 * x3 + c2 * y2 + tx;
              data[1] = b2 * x3 + d3 * y2 + ty;
              break;
            case "bezierCurveTo":
              cpx1 = data[0];
              cpy1 = data[1];
              cpx2 = data[2];
              cpy2 = data[3];
              x3 = data[4];
              y2 = data[5];
              data[0] = a2 * cpx1 + c2 * cpy1 + tx;
              data[1] = b2 * cpx1 + d3 * cpy1 + ty;
              data[2] = a2 * cpx2 + c2 * cpy2 + tx;
              data[3] = b2 * cpx2 + d3 * cpy2 + ty;
              data[4] = a2 * x3 + c2 * y2 + tx;
              data[5] = b2 * x3 + d3 * y2 + ty;
              break;
            case "quadraticCurveTo":
              cpx1 = data[0];
              cpy1 = data[1];
              x3 = data[2];
              y2 = data[3];
              data[0] = a2 * cpx1 + c2 * cpy1 + tx;
              data[1] = b2 * cpx1 + d3 * cpy1 + ty;
              data[2] = a2 * x3 + c2 * y2 + tx;
              data[3] = b2 * x3 + d3 * y2 + ty;
              break;
            case "arcToSvg":
              x3 = data[5];
              y2 = data[6];
              rx = data[0];
              ry = data[1];
              data[0] = a2 * rx + c2 * ry;
              data[1] = b2 * rx + d3 * ry;
              data[5] = a2 * x3 + c2 * y2 + tx;
              data[6] = b2 * x3 + d3 * y2 + ty;
              break;
            case "rect":
              data[4] = adjustTransform2(data[4], matrix);
              break;
            case "ellipse":
              data[8] = adjustTransform2(data[8], matrix);
              break;
            case "roundRect":
              data[5] = adjustTransform2(data[5], matrix);
              break;
            case "addPath":
              data[0].transform(matrix);
              break;
            default:
              warn2("unknown transform action", instruction.action);
              break;
          }
        }
        this._dirty = true;
        return this;
      }
      get bounds() {
        return this.shapePath.bounds;
      }
      _getLastPoint(out3) {
        let index = this.instructions.length - 1;
        let lastInstruction = this.instructions[index];
        if (!lastInstruction) {
          out3.x = 0;
          out3.y = 0;
          return out3;
        }
        while (lastInstruction.action === "closePath") {
          index--;
          if (index < 0) {
            out3.x = 0;
            out3.y = 0;
            return out3;
          }
          lastInstruction = this.instructions[index];
        }
        let x3;
        let y2;
        let transform;
        switch (lastInstruction.action) {
          case "moveTo":
          case "lineTo":
            out3.x = lastInstruction.data[0];
            out3.y = lastInstruction.data[1];
            break;
          case "quadraticCurveTo":
            out3.x = lastInstruction.data[2];
            out3.y = lastInstruction.data[3];
            break;
          case "bezierCurveTo":
            out3.x = lastInstruction.data[4];
            out3.y = lastInstruction.data[5];
            break;
          case "arc":
          case "arcToSvg":
            out3.x = lastInstruction.data[5];
            out3.y = lastInstruction.data[6];
            break;
          case "addPath":
            out3.x = lastInstruction.data[0].lastX;
            out3.y = lastInstruction.data[2].lastY;
            break;
          case "rect":
            transform = lastInstruction.data[4];
            x3 = lastInstruction.data[0];
            y2 = lastInstruction.data[1];
            if (transform) {
              const { a: a2, b: b2, c: c2, d: d3, tx, ty } = transform;
              out3.x = a2 * x3 + c2 * y2 + tx;
              out3.y = b2 * x3 + d3 * y2 + ty;
            } else {
              out3.x = x3;
              out3.y = y2;
            }
            break;
          default:
            warn2(`${lastInstruction.action} is not supported yet`);
            break;
        }
        return out3;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs
function SVGParser2(svg, graphicsContext) {
  if (typeof svg === "string") {
    const div = document.createElement("div");
    div.innerHTML = svg.trim();
    svg = div.querySelector("svg");
  }
  const session = {
    context: graphicsContext,
    path: new GraphicsPath2()
  };
  renderChildren2(svg, session, null, null);
  return graphicsContext;
}
function renderChildren2(svg, session, fillStyle, strokeStyle) {
  const children = svg.children;
  const { fillStyle: f1, strokeStyle: s1 } = parseStyle2(svg);
  if (f1 && fillStyle) {
    fillStyle = { ...fillStyle, ...f1 };
  } else if (f1) {
    fillStyle = f1;
  }
  if (s1 && strokeStyle) {
    strokeStyle = { ...strokeStyle, ...s1 };
  } else if (s1) {
    strokeStyle = s1;
  }
  session.context.fillStyle = fillStyle;
  session.context.strokeStyle = strokeStyle;
  let x3;
  let y2;
  let x1;
  let y1;
  let x22;
  let y22;
  let cx;
  let cy;
  let r2;
  let rx;
  let ry;
  let points;
  let pointsString;
  let d3;
  let graphicsPath;
  let width;
  let height;
  switch (svg.nodeName.toLowerCase()) {
    case "path":
      d3 = svg.getAttribute("d");
      graphicsPath = new GraphicsPath2(d3);
      session.context.path(graphicsPath);
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "circle":
      cx = parseFloatAttribute2(svg, "cx", 0);
      cy = parseFloatAttribute2(svg, "cy", 0);
      r2 = parseFloatAttribute2(svg, "r", 0);
      session.context.ellipse(cx, cy, r2, r2);
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "rect":
      x3 = parseFloatAttribute2(svg, "x", 0);
      y2 = parseFloatAttribute2(svg, "y", 0);
      width = parseFloatAttribute2(svg, "width", 0);
      height = parseFloatAttribute2(svg, "height", 0);
      rx = parseFloatAttribute2(svg, "rx", 0);
      ry = parseFloatAttribute2(svg, "ry", 0);
      if (rx || ry) {
        session.context.roundRect(x3, y2, width, height, rx || ry);
      } else {
        session.context.rect(x3, y2, width, height);
      }
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "ellipse":
      cx = parseFloatAttribute2(svg, "cx", 0);
      cy = parseFloatAttribute2(svg, "cy", 0);
      rx = parseFloatAttribute2(svg, "rx", 0);
      ry = parseFloatAttribute2(svg, "ry", 0);
      session.context.beginPath();
      session.context.ellipse(cx, cy, rx, ry);
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "line":
      x1 = parseFloatAttribute2(svg, "x1", 0);
      y1 = parseFloatAttribute2(svg, "y1", 0);
      x22 = parseFloatAttribute2(svg, "x2", 0);
      y22 = parseFloatAttribute2(svg, "y2", 0);
      session.context.beginPath();
      session.context.moveTo(x1, y1);
      session.context.lineTo(x22, y22);
      if (strokeStyle)
        session.context.stroke();
      break;
    case "polygon":
      pointsString = svg.getAttribute("points");
      points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
      session.context.poly(points, true);
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "polyline":
      pointsString = svg.getAttribute("points");
      points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
      session.context.poly(points, false);
      if (strokeStyle)
        session.context.stroke();
      break;
    case "g":
    case "svg":
      break;
    default: {
      console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);
      break;
    }
  }
  for (let i3 = 0; i3 < children.length; i3++) {
    renderChildren2(children[i3], session, fillStyle, strokeStyle);
  }
}
function parseFloatAttribute2(svg, id, defaultValue3) {
  const value = svg.getAttribute(id);
  return value ? Number(value) : defaultValue3;
}
function parseStyle2(svg) {
  const style = svg.getAttribute("style");
  const strokeStyle = {};
  const fillStyle = {};
  let useFill = false;
  let useStroke = false;
  if (style) {
    const styleParts = style.split(";");
    for (let i3 = 0; i3 < styleParts.length; i3++) {
      const stylePart = styleParts[i3];
      const [key2, value] = stylePart.split(":");
      switch (key2) {
        case "stroke":
          if (value !== "none") {
            strokeStyle.color = Color3.shared.setValue(value).toNumber();
            useStroke = true;
          }
          break;
        case "stroke-width":
          strokeStyle.width = Number(value);
          break;
        case "fill":
          if (value !== "none") {
            useFill = true;
            fillStyle.color = Color3.shared.setValue(value).toNumber();
          }
          break;
        case "fill-opacity":
          fillStyle.alpha = Number(value);
          break;
        case "stroke-opacity":
          strokeStyle.alpha = Number(value);
          break;
        case "opacity":
          fillStyle.alpha = Number(value);
          strokeStyle.alpha = Number(value);
          break;
      }
    }
  } else {
    const stroke = svg.getAttribute("stroke");
    if (stroke && stroke !== "none") {
      useStroke = true;
      strokeStyle.color = Color3.shared.setValue(stroke).toNumber();
      strokeStyle.width = parseFloatAttribute2(svg, "stroke-width", 1);
    }
    const fill = svg.getAttribute("fill");
    if (fill && fill !== "none") {
      useFill = true;
      fillStyle.color = Color3.shared.setValue(fill).toNumber();
    }
  }
  return {
    strokeStyle: useStroke ? strokeStyle : null,
    fillStyle: useFill ? fillStyle : null
  };
}
var init_SVGParser2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs"() {
    init_Color2();
    init_GraphicsPath2();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs
var ImageSource2, canvas2, size2, ctx2;
var init_ImageSource2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs"() {
    init_Extensions2();
    init_adapter2();
    init_NOOP2();
    init_Texture2();
    init_TextureSource2();
    ImageSource2 = class extends TextureSource2 {
      constructor() {
        super(...arguments);
        this.uploadMethodId = "image";
      }
      static test(resource) {
        return typeof HTMLImageElement !== "undefined" && resource instanceof HTMLImageElement || typeof ImageBitmap !== "undefined" && resource instanceof ImageBitmap;
      }
    };
    ImageSource2.extension = ExtensionType3.TextureSource;
    canvas2 = DOMAdapter.get().createCanvas();
    size2 = 1;
    canvas2.width = size2;
    canvas2.height = size2;
    ctx2 = canvas2.getContext("2d");
    ctx2.fillStyle = "#ffffff";
    ctx2.fillRect(0, 0, size2, size2);
    ctx2.beginPath();
    ctx2.moveTo(0, 0);
    ctx2.lineTo(size2, 0);
    ctx2.lineTo(size2, size2);
    ctx2.closePath();
    ctx2.fillStyle = "#ffffff";
    ctx2.fill();
    Texture4.WHITE = new Texture4({
      source: new ImageSource2({
        resource: canvas2
      })
    });
    Texture4.WHITE.label = "WHITE";
    Texture4.WHITE.destroy = NOOP2;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs
var _FillGradient2, FillGradient2;
var init_FillGradient2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs"() {
    init_Color2();
    init_Matrix2();
    init_ImageSource2();
    init_Texture2();
    init_adapter2();
    init_uid2();
    _FillGradient2 = class {
      constructor(x0, y0, x1, y1) {
        this.uid = uid3("fillGradient");
        this.type = "linear";
        this.gradientStops = [];
        this.x0 = x0;
        this.y0 = y0;
        this.x1 = x1;
        this.y1 = y1;
      }
      addColorStop(offset, color) {
        this.gradientStops.push({ offset, color: Color3.shared.setValue(color).toHex() });
        return this;
      }
      // TODO move to the system!
      buildLinearGradient() {
        const defaultSize = _FillGradient2.defaultTextureSize;
        const { gradientStops } = this;
        const canvas3 = DOMAdapter.get().createCanvas();
        canvas3.width = defaultSize;
        canvas3.height = defaultSize;
        const ctx3 = canvas3.getContext("2d");
        const gradient = ctx3.createLinearGradient(0, 0, _FillGradient2.defaultTextureSize, 1);
        for (let i3 = 0; i3 < gradientStops.length; i3++) {
          const stop = gradientStops[i3];
          gradient.addColorStop(stop.offset, stop.color);
        }
        ctx3.fillStyle = gradient;
        ctx3.fillRect(0, 0, defaultSize, defaultSize);
        this.texture = new Texture4({
          source: new ImageSource2({
            resource: canvas3,
            style: {
              addressModeU: "clamp-to-edge",
              addressModeV: "repeat"
            }
          })
        });
        const { x0, y0, x1, y1 } = this;
        const m3 = new Matrix3();
        const dx = x1 - x0;
        const dy = y1 - y0;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        m3.translate(-x0, -y0);
        m3.scale(1 / defaultSize, 1 / defaultSize);
        m3.rotate(-angle);
        m3.scale(256 / dist, 1);
        this.transform = m3;
      }
    };
    FillGradient2 = _FillGradient2;
    FillGradient2.defaultTextureSize = 256;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs
var repetitionMap2, FillPattern2;
var init_FillPattern2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs"() {
    init_Matrix2();
    init_uid2();
    repetitionMap2 = {
      repeat: {
        addressModeU: "repeat",
        addressModeV: "repeat"
      },
      "repeat-x": {
        addressModeU: "repeat",
        addressModeV: "clamp-to-edge"
      },
      "repeat-y": {
        addressModeU: "clamp-to-edge",
        addressModeV: "repeat"
      },
      "no-repeat": {
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      }
    };
    FillPattern2 = class {
      constructor(texture, repetition) {
        this.uid = uid3("fillPattern");
        this.transform = new Matrix3();
        this.texture = texture;
        this.transform.scale(
          1 / texture.frameWidth,
          1 / texture.frameHeight
        );
        if (repetition) {
          texture.source.style.addressModeU = repetitionMap2[repetition].addressModeU;
          texture.source.style.addressModeV = repetitionMap2[repetition].addressModeV;
        }
      }
      setTransform(transform) {
        const texture = this.texture;
        this.transform.copyFrom(transform);
        this.transform.invert();
        this.transform.scale(
          1 / texture.frameWidth,
          1 / texture.frameHeight
        );
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs
function convertFillInputToFillStyle2(value, defaultStyle) {
  if (!value) {
    return null;
  }
  let fillStyleToParse;
  let styleToMerge;
  if (value?.fill) {
    styleToMerge = value.fill;
    fillStyleToParse = { ...defaultStyle, ...value };
  } else {
    styleToMerge = value;
    fillStyleToParse = defaultStyle;
  }
  if (Color3.isColorLike(styleToMerge)) {
    const temp = Color3.shared.setValue(styleToMerge ?? 0);
    const opts = {
      ...fillStyleToParse,
      color: temp.toNumber(),
      alpha: temp.alpha === 1 ? fillStyleToParse.alpha : temp.alpha,
      texture: Texture4.WHITE
    };
    return opts;
  } else if (styleToMerge instanceof FillPattern2) {
    const pattern = styleToMerge;
    return {
      ...fillStyleToParse,
      color: 16777215,
      texture: pattern.texture,
      matrix: pattern.transform,
      fill: fillStyleToParse.fill ?? null
    };
  } else if (styleToMerge instanceof FillGradient2) {
    const gradient = styleToMerge;
    gradient.buildLinearGradient();
    return {
      ...fillStyleToParse,
      color: 16777215,
      texture: gradient.texture,
      matrix: gradient.transform
    };
  }
  const style = { ...defaultStyle, ...value };
  if (style.texture !== Texture4.WHITE) {
    const m3 = style.matrix || new Matrix3();
    m3.scale(1 / style.texture.frameWidth, 1 / style.texture.frameHeight);
    style.matrix = m3;
    style.color = 16777215;
  }
  style.color = Color3.shared.setValue(style.color).toNumber();
  return style;
}
var init_convertFillInputToFillStyle2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs"() {
    init_Color2();
    init_Matrix2();
    init_Texture2();
    init_FillGradient2();
    init_FillPattern2();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs
var tmpPoint2, tempMatrix8, _GraphicsContext2, GraphicsContext2;
var init_GraphicsContext2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs"() {
    init_eventemitter3();
    init_Color2();
    init_Matrix2();
    init_Point2();
    init_Texture2();
    init_uid2();
    init_deprecation2();
    init_Bounds2();
    init_GraphicsPath2();
    init_SVGParser2();
    init_convertFillInputToFillStyle2();
    tmpPoint2 = new Point3();
    tempMatrix8 = new Matrix3();
    _GraphicsContext2 = class extends eventemitter3_default {
      constructor() {
        super(...arguments);
        this.uid = uid3("graphicsContext");
        this.dirty = true;
        this.batchMode = "auto";
        this.instructions = [];
        this._activePath = new GraphicsPath2();
        this._transform = new Matrix3();
        this._fillStyle = { ..._GraphicsContext2.defaultFillStyle };
        this._strokeStyle = { ..._GraphicsContext2.defaultStrokeStyle };
        this._stateStack = [];
        this._tick = 0;
        this._bounds = new Bounds2();
        this._boundsDirty = true;
      }
      get fillStyle() {
        return this._fillStyle;
      }
      set fillStyle(value) {
        this._fillStyle = convertFillInputToFillStyle2(value, _GraphicsContext2.defaultFillStyle);
      }
      get strokeStyle() {
        return this._strokeStyle;
      }
      set strokeStyle(value) {
        this._strokeStyle = convertFillInputToFillStyle2(value, _GraphicsContext2.defaultStrokeStyle);
      }
      texture(texture, tint, dx, dy, dw, dh) {
        this.instructions.push({
          action: "texture",
          data: {
            image: texture,
            dx: dx || 0,
            dy: dy || 0,
            dw: dw || texture.frameWidth,
            dh: dh || texture.frameHeight,
            transform: this._transform.clone(),
            alpha: this._fillStyle.alpha,
            style: tint ? Color3.shared.setValue(tint).toNumber() : 0
          }
        });
        this.onUpdate();
        return this;
      }
      beginPath() {
        this._activePath = new GraphicsPath2();
        return this;
      }
      fill(style, alpha) {
        let path4;
        const lastInstruction = this.instructions[this.instructions.length - 1];
        if (this._tick === 0 && lastInstruction && lastInstruction.action === "stroke") {
          path4 = lastInstruction.data.path;
        } else {
          path4 = this._activePath.clone();
        }
        if (!path4)
          return this;
        if (style) {
          if (alpha !== void 0 && typeof style === "number") {
            deprecation3("8.0.0", "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");
            style = { color: style, alpha };
          }
          this._fillStyle = convertFillInputToFillStyle2(style, _GraphicsContext2.defaultFillStyle);
        }
        this.instructions.push({
          action: "fill",
          // TODO copy fill style!
          data: { style: this.fillStyle, path: path4 }
        });
        this.onUpdate();
        this._activePath.instructions.length = 0;
        this._tick = 0;
        return this;
      }
      stroke(style) {
        let path4;
        const lastInstruction = this.instructions[this.instructions.length - 1];
        if (this._tick === 0 && lastInstruction && lastInstruction.action === "fill") {
          path4 = lastInstruction.data.path;
        } else {
          path4 = this._activePath.clone();
        }
        if (!path4)
          return this;
        if (style) {
          this._strokeStyle = convertFillInputToFillStyle2(style, _GraphicsContext2.defaultStrokeStyle);
        }
        this.instructions.push({
          action: "stroke",
          // TODO copy fill style!
          data: { style: this.strokeStyle, path: path4 }
        });
        this.onUpdate();
        this._activePath.instructions.length = 0;
        this._tick = 0;
        return this;
      }
      cut() {
        for (let i3 = 0; i3 < 2; i3++) {
          const lastInstruction = this.instructions[this.instructions.length - 1 - i3];
          const holePath = this._activePath.clone();
          if (lastInstruction) {
            if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {
              lastInstruction.data.hole = holePath;
            }
          }
        }
        this._activePath.instructions.length = 0;
        return this;
      }
      arc(x3, y2, radius, startAngle, endAngle, counterclockwise) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.arc(
          t2.a * x3 + t2.c * y2 + t2.tx,
          t2.b * x3 + t2.d * y2 + t2.ty,
          radius,
          startAngle,
          endAngle,
          counterclockwise
        );
        return this;
      }
      arcTo(x1, y1, x22, y2, radius) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.arcTo(
          t2.a * x1 + t2.c * y1 + t2.tx,
          t2.b * x1 + t2.d * y1 + t2.ty,
          t2.a * x22 + t2.c * y2 + t2.tx,
          t2.b * x22 + t2.d * y2 + t2.ty,
          radius
        );
        return this;
      }
      arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x3, y2) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.arcToSvg(
          rx,
          ry,
          xAxisRotation,
          // should we rotate this with transform??
          largeArcFlag,
          sweepFlag,
          t2.a * x3 + t2.c * y2 + t2.tx,
          t2.b * x3 + t2.d * y2 + t2.ty
        );
        return this;
      }
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x3, y2) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.bezierCurveTo(
          t2.a * cp1x + t2.c * cp1y + t2.tx,
          t2.b * cp1x + t2.d * cp1y + t2.ty,
          t2.a * cp2x + t2.c * cp2y + t2.tx,
          t2.b * cp2x + t2.d * cp2y + t2.ty,
          t2.a * x3 + t2.c * y2 + t2.tx,
          t2.b * x3 + t2.d * y2 + t2.ty
        );
        return this;
      }
      closePath() {
        this._tick++;
        this._activePath?.closePath();
        return this;
      }
      ellipse(x3, y2, radiusX, radiusY) {
        this._tick++;
        this._activePath.ellipse(x3, y2, radiusX, radiusY, this._transform.clone());
        return this;
      }
      circle(x3, y2, radius) {
        this._tick++;
        this._activePath.circle(x3, y2, radius, this._transform.clone());
        return this;
      }
      path(path4) {
        this._tick++;
        this._activePath.addPath(path4, this._transform.clone());
        return this;
      }
      lineTo(x3, y2) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.lineTo(
          t2.a * x3 + t2.c * y2 + t2.tx,
          t2.b * x3 + t2.d * y2 + t2.ty
        );
        return this;
      }
      moveTo(x3, y2) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.moveTo(
          t2.a * x3 + t2.c * y2 + t2.tx,
          t2.b * x3 + t2.d * y2 + t2.ty
        );
        return this;
      }
      quadraticCurveTo(cpx, cpy, x3, y2) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.quadraticCurveTo(
          t2.a * cpx + t2.c * cpy + t2.tx,
          t2.b * cpx + t2.d * cpy + t2.ty,
          t2.a * x3 + t2.c * y2 + t2.tx,
          t2.b * x3 + t2.d * y2 + t2.ty
        );
      }
      rect(x3, y2, w2, h2) {
        this._tick++;
        this._activePath.rect(x3, y2, w2, h2, this._transform.clone());
        return this;
      }
      roundRect(x3, y2, w2, h2, radii) {
        this._tick++;
        this._activePath.roundRect(x3, y2, w2, h2, radii, this._transform.clone());
        return this;
      }
      poly(points, close) {
        this._tick++;
        this._activePath.poly(points, close, this._transform.clone());
        return this;
      }
      star(x3, y2, points, radius, innerRadius, rotation) {
        this._tick++;
        this._activePath.star(x3, y2, points, radius, innerRadius, rotation, this._transform.clone());
        return this;
      }
      svg(svg) {
        this._tick++;
        SVGParser2(svg, this);
      }
      restore() {
        const state = this._stateStack.pop();
        if (state) {
          this._transform = state.transform;
          this._fillStyle = state.fillStyle;
          this._strokeStyle = state.strokeStyle;
        }
      }
      save() {
        this._stateStack.push({
          transform: this._transform.clone(),
          fillStyle: { ...this._fillStyle },
          strokeStyle: { ...this._strokeStyle }
        });
      }
      getTransform() {
        return this._transform;
      }
      resetTransform() {
        this._transform.identity();
        return this;
      }
      rotate(angle) {
        this._transform.rotate(angle);
        return this;
      }
      scale(x3, y2 = x3) {
        this._transform.scale(x3, y2);
        return this;
      }
      setTransform(a2, b2, c2, d3, dx, dy) {
        if (a2 instanceof Matrix3) {
          this._transform.set(a2.a, a2.b, a2.c, a2.d, a2.tx, a2.ty);
          return this;
        }
        this._transform.set(a2, b2, c2, d3, dx, dy);
        return this;
      }
      transform(a2, b2, c2, d3, dx, dy) {
        if (a2 instanceof Matrix3) {
          this._transform.append(a2);
          return this;
        }
        tempMatrix8.set(a2, b2, c2, d3, dx, dy);
        this._transform.append(tempMatrix8);
        return this;
      }
      translate(x3, y2) {
        this._transform.translate(x3, y2);
        return this;
      }
      clear() {
        this.instructions.length = 0;
        this.resetTransform();
        this.onUpdate();
        return this;
      }
      onUpdate() {
        if (this.dirty)
          return;
        this.emit("update", this, 16);
        this.dirty = true;
        this._boundsDirty = true;
      }
      get bounds() {
        if (!this._boundsDirty)
          return this._bounds;
        const bounds = this._bounds;
        bounds.clear();
        for (let i3 = 0; i3 < this.instructions.length; i3++) {
          const instruction = this.instructions[i3];
          const action = instruction.action;
          if (action === "fill") {
            const data = instruction.data;
            bounds.addBounds(data.path.bounds);
          } else if (action === "texture") {
            const data = instruction.data;
            bounds.pushMatrix(data.transform);
            bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh);
            bounds.popMatrix();
          }
        }
        return bounds;
      }
      /**
       * Check to see if a point is contained within this geometry.
       * @param point - Point to check if it's contained.
       * @returns {boolean} `true` if the point is contained within geometry.
       */
      containsPoint(point) {
        const instructions = this.instructions;
        let hasHit = false;
        instructions.forEach((instruction) => {
          const data = instruction.data;
          const path4 = data.path;
          if (!instruction.action || !path4)
            return;
          const style = data.style;
          const shapes = path4.shapePath?.shapePrimitives;
          this._forEachShape(shapes, (shape) => {
            if (!style || !shape)
              return;
            if (typeof style !== "number" && style.matrix) {
              style.matrix.applyInverse(point, tmpPoint2);
            } else {
              tmpPoint2.copyFrom(point);
            }
            hasHit = shape.contains(tmpPoint2.x, tmpPoint2.y);
            const holes = data.hole;
            if (!holes)
              return;
            const holeShapes = holes.shapePath?.shapePrimitives;
            if (!holeShapes)
              return;
            this._forEachShape(holeShapes, (hole) => {
              if (hole.contains(tmpPoint2.x, tmpPoint2.y)) {
                hasHit = false;
              }
            });
          });
        });
        return hasHit;
      }
      _forEachShape(shapes, callback) {
        shapes?.forEach((shapePrimitive) => {
          const shape = shapePrimitive?.shape;
          if (shape) {
            callback(shape);
          }
        });
      }
      /**
       * Destroys the GraphicsData object.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?
       * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?
       */
      destroy(options = false) {
        this._stateStack.length = 0;
        this._transform = null;
        this.emit("destroy", this);
        this.removeAllListeners();
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          if (this._fillStyle.texture) {
            this._fillStyle.texture.destroy(destroyTextureSource);
          }
          if (this._strokeStyle.texture) {
            this._strokeStyle.texture.destroy(destroyTextureSource);
          }
        }
        this._fillStyle = null;
        this._strokeStyle = null;
        this.instructions = null;
        this._activePath = null;
        this._bounds = null;
        this._stateStack = null;
        this.customShader = null;
        this._transform = null;
      }
    };
    GraphicsContext2 = _GraphicsContext2;
    GraphicsContext2.defaultFillStyle = {
      color: 0,
      alpha: 1,
      texture: Texture4.WHITE,
      matrix: null,
      fill: null
    };
    GraphicsContext2.defaultStrokeStyle = {
      width: 1,
      color: 0,
      alpha: 1,
      alignment: 0.5,
      miterLimit: 10,
      cap: "butt",
      join: "miter",
      texture: Texture4.WHITE,
      matrix: null,
      fill: null
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs
var SVG_XML2, validSVGExtension2, validSVGMIME2, loadSvg2;
var init_loadSVG2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs"() {
    init_Extensions2();
    init_GraphicsContext2();
    init_adapter2();
    init_checkDataUrl2();
    init_checkExtension2();
    init_LoaderParser2();
    SVG_XML2 = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
    validSVGExtension2 = ".svg";
    validSVGMIME2 = "image/svg+xml";
    loadSvg2 = {
      extension: {
        type: ExtensionType3.LoadParser,
        priority: LoaderParserPriority2.Low
      },
      name: "loadSVG",
      test(url2) {
        return checkDataUrl2(url2, validSVGMIME2) || checkExtension2(url2, validSVGExtension2);
      },
      async testParse(data) {
        return typeof data === "string" && data.startsWith("data:image/svg+xml") || typeof data === "string" && SVG_XML2.test(data);
      },
      async parse(asset) {
        const context4 = new GraphicsContext2();
        context4.svg(asset);
        return context4;
      },
      async load(url2) {
        const response = await DOMAdapter.get().fetch(url2);
        return response.text();
      },
      unload(asset) {
        asset.destroy(true);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs
function processX2(base, ids, depth, result, tags) {
  const id = ids[depth];
  for (let i3 = 0; i3 < id.length; i3++) {
    const value = id[i3];
    if (depth < ids.length - 1) {
      processX2(base.replace(result[depth], value), ids, depth + 1, result, tags);
    } else {
      tags.push(base.replace(result[depth], value));
    }
  }
}
function createStringVariations2(string) {
  const regex = /\{(.*?)\}/g;
  const result = string.match(regex);
  const tags = [];
  if (result) {
    const ids = [];
    result.forEach((vars) => {
      const split = vars.substring(1, vars.length - 1).split(",");
      ids.push(split);
    });
    processX2(string, ids, 0, result, tags);
  } else {
    tags.push(string);
  }
  return tags;
}
var init_createStringVariations = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs
var isSingleItem2;
var init_isSingleItem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs"() {
    isSingleItem2 = (item) => !Array.isArray(item);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/resolver/Resolver.mjs
var Resolver2;
var init_Resolver = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/resolver/Resolver.mjs"() {
    init_warn2();
    init_path2();
    init_convertToList2();
    init_createStringVariations();
    init_isSingleItem();
    Resolver2 = class {
      constructor() {
        this._defaultBundleIdentifierOptions = {
          connector: "-",
          createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
          extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
        };
        this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
        this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
        this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
        this._assetMap = {};
        this._preferredOrder = [];
        this._parsers = [];
        this._resolverHash = {};
        this._bundles = {};
      }
      /**
       * Override how the resolver deals with generating bundle ids.
       * must be called before any bundles are added
       * @param bundleIdentifier - the bundle identifier options
       */
      setBundleIdentifier(bundleIdentifier) {
        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
        if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
          throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
        }
      }
      /**
       * Let the resolver know which assets you prefer to use when resolving assets.
       * Multiple prefer user defined rules can be added.
       * @example
       * resolver.prefer({
       *     // first look for something with the correct format, and then then correct resolution
       *     priority: ['format', 'resolution'],
       *     params:{
       *         format:'webp', // prefer webp images
       *         resolution: 2, // prefer a resolution of 2
       *     }
       * })
       * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
       * resolver.resolveUrl('foo') // => 'bar@2x.webp'
       * @param preferOrders - the prefer options
       */
      prefer(...preferOrders) {
        preferOrders.forEach((prefer) => {
          this._preferredOrder.push(prefer);
          if (!prefer.priority) {
            prefer.priority = Object.keys(prefer.params);
          }
        });
        this._resolverHash = {};
      }
      /**
       * Set the base path to prepend to all urls when resolving
       * @example
       * resolver.basePath = 'https://home.com/';
       * resolver.add('foo', 'bar.ong');
       * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
       * @param basePath - the base path to use
       */
      set basePath(basePath) {
        this._basePath = basePath;
      }
      get basePath() {
        return this._basePath;
      }
      /**
       * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
       * default value for browsers is `window.location.origin`
       * @example
       * // Application hosted on https://home.com/some-path/index.html
       * resolver.basePath = 'https://home.com/some-path/';
       * resolver.rootPath = 'https://home.com/';
       * resolver.add('foo', '/bar.png');
       * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
       * @param rootPath - the root path to use
       */
      set rootPath(rootPath) {
        this._rootPath = rootPath;
      }
      get rootPath() {
        return this._rootPath;
      }
      /**
       * All the active URL parsers that help the parser to extract information and create
       * an asset object-based on parsing the URL itself.
       *
       * Can be added using the extensions API
       * @example
       * resolver.add('foo', [
       *     {
       *         resolution: 2,
       *         format: 'png',
       *         src: 'image@2x.png',
       *     },
       *     {
       *         resolution:1,
       *         format:'png',
       *         src: 'image.png',
       *     },
       * ]);
       *
       * // With a url parser the information such as resolution and file format could extracted from the url itself:
       * extensions.add({
       *     extension: ExtensionType.ResolveParser,
       *     test: loadTextures.test, // test if url ends in an image
       *     parse: (value: string) =>
       *     ({
       *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
       *         format: value.split('.').pop(),
       *         src: value,
       *     }),
       * });
       *
       * // Now resolution and format can be extracted from the url
       * resolver.add('foo', [
       *     'image@2x.png',
       *     'image.png',
       * ]);
       */
      get parsers() {
        return this._parsers;
      }
      /** Used for testing, this resets the resolver to its initial state */
      reset() {
        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
        this._assetMap = {};
        this._preferredOrder = [];
        this._resolverHash = {};
        this._rootPath = null;
        this._basePath = null;
        this._manifest = null;
        this._bundles = {};
        this._defaultSearchParams = null;
      }
      /**
       * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.
       * @param searchParams - the default url parameters to append when resolving urls
       */
      setDefaultSearchParams(searchParams) {
        if (typeof searchParams === "string") {
          this._defaultSearchParams = searchParams;
        } else {
          const queryValues = searchParams;
          this._defaultSearchParams = Object.keys(queryValues).map((key2) => `${encodeURIComponent(key2)}=${encodeURIComponent(queryValues[key2])}`).join("&");
        }
      }
      /**
       * Returns the aliases for a given asset
       * @param asset - the asset to get the aliases for
       */
      getAlias(asset) {
        const { alias, name, src, srcs } = asset;
        const aliasesToUse = convertToList2(
          alias || name || src || srcs,
          (value) => {
            if (typeof value === "string")
              return value;
            if (Array.isArray(value))
              return value.map((v3) => v3?.src ?? v3?.srcs ?? v3);
            if (value?.src || value?.srcs)
              return value.src ?? value.srcs;
            return value;
          },
          true
        );
        return aliasesToUse;
      }
      /**
       * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
       * generally a manifest would be built using a tool.
       * @param manifest - the manifest to add to the resolver
       */
      addManifest(manifest) {
        if (this._manifest) {
          warn2("[Resolver] Manifest already exists, this will be overwritten");
        }
        this._manifest = manifest;
        manifest.bundles.forEach((bundle) => {
          this.addBundle(bundle.name, bundle.assets);
        });
      }
      /**
       * This adds a bundle of assets in one go so that you can resolve them as a group.
       * For example you could add a bundle for each screen in you pixi app
       * @example
       * resolver.addBundle('animals', {
       *     bunny: 'bunny.png',
       *     chicken: 'chicken.png',
       *     thumper: 'thumper.png',
       * });
       *
       * const resolvedAssets = await resolver.resolveBundle('animals');
       * @param bundleId - The id of the bundle to add
       * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
       */
      addBundle(bundleId, assets) {
        const assetNames = [];
        if (Array.isArray(assets)) {
          assets.forEach((asset) => {
            const srcs = asset.src ?? asset.srcs;
            const aliases = asset.alias ?? asset.name;
            let ids;
            if (typeof aliases === "string") {
              const bundleAssetId = this._createBundleAssetId(bundleId, aliases);
              assetNames.push(bundleAssetId);
              ids = [aliases, bundleAssetId];
            } else {
              const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));
              assetNames.push(...bundleIds);
              ids = [...aliases, ...bundleIds];
            }
            this.add({
              ...asset,
              ...{
                alias: ids,
                src: srcs
              }
            });
          });
        } else {
          Object.keys(assets).forEach((key2) => {
            const aliases = [key2, this._createBundleAssetId(bundleId, key2)];
            if (typeof assets[key2] === "string") {
              this.add({
                alias: aliases,
                src: assets[key2]
              });
            } else if (Array.isArray(assets[key2])) {
              this.add({
                alias: aliases,
                src: assets[key2]
              });
            } else {
              const asset = assets[key2];
              const assetSrc = asset.src ?? asset.srcs;
              this.add({
                ...asset,
                ...{
                  alias: aliases,
                  src: Array.isArray(assetSrc) ? assetSrc : [assetSrc]
                }
              });
            }
            assetNames.push(...aliases);
          });
        }
        this._bundles[bundleId] = assetNames;
      }
      /**
       * Tells the resolver what keys are associated with witch asset.
       * The most important thing the resolver does
       * @example
       * // Single key, single asset:
       * resolver.add({alias: 'foo', src: 'bar.png');
       * resolver.resolveUrl('foo') // => 'bar.png'
       *
       * // Multiple keys, single asset:
       * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});
       * resolver.resolveUrl('foo') // => 'bar.png'
       * resolver.resolveUrl('boo') // => 'bar.png'
       *
       * // Multiple keys, multiple assets:
       * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});
       * resolver.resolveUrl('foo') // => 'bar.png'
       *
       * // Add custom data attached to the resolver
       * Resolver.add({
       *     alias: 'bunnyBooBooSmooth',
       *     src: 'bunny{png,webp}',
       *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options
       * });
       *
       * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }
       * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver
       */
      add(aliases) {
        const assets = [];
        if (Array.isArray(aliases)) {
          assets.push(...aliases);
        } else {
          assets.push(aliases);
        }
        let keyCheck;
        keyCheck = (key2) => {
          if (this.hasKey(key2)) {
            warn2(`[Resolver] already has key: ${key2} overwriting`);
          }
        };
        const assetArray = convertToList2(assets);
        assetArray.forEach((asset) => {
          const { src, srcs } = asset;
          let { data, format: format3, loadParser } = asset;
          const srcsToUse = convertToList2(src || srcs).map((src2) => {
            if (typeof src2 === "string") {
              return createStringVariations2(src2);
            }
            return Array.isArray(src2) ? src2 : [src2];
          });
          const aliasesToUse = this.getAlias(asset);
          Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
          const resolvedAssets = [];
          srcsToUse.forEach((srcs2) => {
            srcs2.forEach((src2) => {
              let formattedAsset = {};
              if (typeof src2 !== "object") {
                formattedAsset.src = src2;
                for (let i3 = 0; i3 < this._parsers.length; i3++) {
                  const parser = this._parsers[i3];
                  if (parser.test(src2)) {
                    formattedAsset = parser.parse(src2);
                    break;
                  }
                }
              } else {
                data = src2.data ?? data;
                format3 = src2.format ?? format3;
                loadParser = src2.loadParser ?? loadParser;
                formattedAsset = {
                  ...formattedAsset,
                  ...src2
                };
              }
              if (!aliasesToUse) {
                throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
              }
              formattedAsset = this._buildResolvedAsset(formattedAsset, {
                aliases: aliasesToUse,
                data,
                format: format3,
                loadParser
              });
              resolvedAssets.push(formattedAsset);
            });
          });
          aliasesToUse.forEach((alias) => {
            this._assetMap[alias] = resolvedAssets;
          });
        });
      }
      // TODO: this needs an overload like load did in Assets
      /**
       * If the resolver has had a manifest set via setManifest, this will return the assets urls for
       * a given bundleId or bundleIds.
       * @example
       * // Manifest Example
       * const manifest = {
       *     bundles: [
       *         {
       *             name: 'load-screen',
       *             assets: [
       *                 {
       *                     alias: 'background',
       *                     src: 'sunset.png',
       *                 },
       *                 {
       *                     alias: 'bar',
       *                     src: 'load-bar.{png,webp}',
       *                 },
       *             ],
       *         },
       *         {
       *             name: 'game-screen',
       *             assets: [
       *                 {
       *                     alias: 'character',
       *                     src: 'robot.png',
       *                 },
       *                 {
       *                     alias: 'enemy',
       *                     src: 'bad-guy.png',
       *                 },
       *             ],
       *         },
       *     ]
       * };
       *
       * resolver.setManifest(manifest);
       * const resolved = resolver.resolveBundle('load-screen');
       * @param bundleIds - The bundle ids to resolve
       * @returns All the bundles assets or a hash of assets for each bundle specified
       */
      resolveBundle(bundleIds) {
        const singleAsset = isSingleItem2(bundleIds);
        bundleIds = convertToList2(bundleIds);
        const out3 = {};
        bundleIds.forEach((bundleId) => {
          const assetNames = this._bundles[bundleId];
          if (assetNames) {
            const results = this.resolve(assetNames);
            const assets = {};
            for (const key2 in results) {
              const asset = results[key2];
              assets[this._extractAssetIdFromBundle(bundleId, key2)] = asset;
            }
            out3[bundleId] = assets;
          }
        });
        return singleAsset ? out3[bundleIds[0]] : out3;
      }
      /**
       * Does exactly what resolve does, but returns just the URL rather than the whole asset object
       * @param key - The key or keys to resolve
       * @returns - The URLs associated with the key(s)
       */
      resolveUrl(key2) {
        const result = this.resolve(key2);
        if (typeof key2 !== "string") {
          const out3 = {};
          for (const i3 in result) {
            out3[i3] = result[i3].src;
          }
          return out3;
        }
        return result.src;
      }
      resolve(keys) {
        const singleAsset = isSingleItem2(keys);
        keys = convertToList2(keys);
        const result = {};
        keys.forEach((key2) => {
          if (!this._resolverHash[key2]) {
            if (this._assetMap[key2]) {
              let assets = this._assetMap[key2];
              const bestAsset = assets[0];
              const preferredOrder = this._getPreferredOrder(assets);
              preferredOrder?.priority.forEach((priorityKey) => {
                preferredOrder.params[priorityKey].forEach((value) => {
                  const filteredAssets = assets.filter((asset) => {
                    if (asset[priorityKey]) {
                      return asset[priorityKey] === value;
                    }
                    return false;
                  });
                  if (filteredAssets.length) {
                    assets = filteredAssets;
                  }
                });
              });
              this._resolverHash[key2] = assets[0] ?? bestAsset;
            } else {
              this._resolverHash[key2] = this._buildResolvedAsset({
                alias: [key2],
                src: key2
              }, {});
            }
          }
          result[key2] = this._resolverHash[key2];
        });
        return singleAsset ? result[keys[0]] : result;
      }
      /**
       * Checks if an asset with a given key exists in the resolver
       * @param key - The key of the asset
       */
      hasKey(key2) {
        return !!this._assetMap[key2];
      }
      /**
       * Checks if a bundle with the given key exists in the resolver
       * @param key - The key of the bundle
       */
      hasBundle(key2) {
        return !!this._bundles[key2];
      }
      /**
       * Internal function for figuring out what prefer criteria an asset should use.
       * @param assets
       */
      _getPreferredOrder(assets) {
        for (let i3 = 0; i3 < assets.length; i3++) {
          const asset = assets[0];
          const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
          if (preferred) {
            return preferred;
          }
        }
        return this._preferredOrder[0];
      }
      /**
       * Appends the default url parameters to the url
       * @param url - The url to append the default parameters to
       * @returns - The url with the default parameters appended
       */
      _appendDefaultSearchParams(url2) {
        if (!this._defaultSearchParams)
          return url2;
        const paramConnector = /\?/.test(url2) ? "&" : "?";
        return `${url2}${paramConnector}${this._defaultSearchParams}`;
      }
      _buildResolvedAsset(formattedAsset, data) {
        const { aliases, data: assetData, loadParser, format: format3 } = data;
        if (this._basePath || this._rootPath) {
          formattedAsset.src = path3.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
        }
        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];
        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
        formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };
        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;
        formattedAsset.format = format3 ?? formattedAsset.src.split(".").pop();
        formattedAsset.srcs = formattedAsset.src;
        formattedAsset.name = formattedAsset.alias;
        return formattedAsset;
      }
    };
    Resolver2.RETINA_PREFIX = /@([0-9\.]+)x/;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs
function getResolutionOfUrl3(url2, defaultValue3 = 1) {
  const resolution = Resolver2.RETINA_PREFIX?.exec(url2);
  if (resolution) {
    return parseFloat(resolution[1]);
  }
  return defaultValue3;
}
var init_getResolutionOfUrl2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs"() {
    init_Resolver();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/WorkerManager.mjs
var UUID2, MAX_WORKERS2, WHITE_PNG2, checkImageBitmapCode2, workerCode2, workerURL2, WorkerManagerClass2, WorkerManager2;
var init_WorkerManager2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/WorkerManager.mjs"() {
    UUID2 = 0;
    WHITE_PNG2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    checkImageBitmapCode2 = {
      id: "checkImageBitmap",
      code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${WHITE_PNG2}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
    };
    workerCode2 = {
      id: "loadImageBitmap",
      code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
    };
    WorkerManagerClass2 = class {
      constructor() {
        this._initialized = false;
        this._createdWorkers = 0;
        this._workerPool = [];
        this._queue = [];
        this._resolveHash = {};
      }
      isImageBitmapSupported() {
        if (this._isImageBitmapSupported !== void 0)
          return this._isImageBitmapSupported;
        this._isImageBitmapSupported = new Promise((resolve2) => {
          const workerURL22 = URL.createObjectURL(new Blob(
            [checkImageBitmapCode2.code],
            { type: "application/javascript" }
          ));
          const worker = new Worker(workerURL22);
          worker.addEventListener("message", (event) => {
            worker.terminate();
            URL.revokeObjectURL(workerURL22);
            resolve2(event.data);
          });
        });
        return this._isImageBitmapSupported;
      }
      loadImageBitmap(src) {
        return this._run("loadImageBitmap", [src]);
      }
      async _initWorkers() {
        if (this._initialized)
          return;
        this._initialized = true;
      }
      _getWorker() {
        if (MAX_WORKERS2 === void 0) {
          MAX_WORKERS2 = navigator.hardwareConcurrency || 4;
        }
        let worker = this._workerPool.pop();
        if (!worker && this._createdWorkers < MAX_WORKERS2) {
          if (!workerURL2) {
            workerURL2 = URL.createObjectURL(new Blob([workerCode2.code], { type: "application/javascript" }));
          }
          this._createdWorkers++;
          worker = new Worker(workerURL2);
          worker.addEventListener("message", (event) => {
            this._complete(event.data);
            this._returnWorker(event.target);
            this._next();
          });
        }
        return worker;
      }
      _returnWorker(worker) {
        this._workerPool.push(worker);
      }
      _complete(data) {
        if (data.error !== void 0) {
          this._resolveHash[data.uuid].reject(data.error);
        } else {
          this._resolveHash[data.uuid].resolve(data.data);
        }
        this._resolveHash[data.uuid] = null;
      }
      async _run(id, args) {
        await this._initWorkers();
        const promise4 = new Promise((resolve2, reject) => {
          this._queue.push({ id, arguments: args, resolve: resolve2, reject });
        });
        this._next();
        return promise4;
      }
      _next() {
        if (!this._queue.length)
          return;
        const worker = this._getWorker();
        if (!worker) {
          return;
        }
        const toDo = this._queue.pop();
        const id = toDo.id;
        this._resolveHash[UUID2] = { resolve: toDo.resolve, reject: toDo.reject };
        worker.postMessage({
          data: toDo.arguments,
          uuid: UUID2++,
          id
        });
      }
    };
    WorkerManager2 = new WorkerManagerClass2();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs
function createTexture2(source3, loader, url2) {
  const texture = new Texture4({
    source: source3,
    label: url2
  });
  const unload = () => {
    delete loader.promiseCache[url2];
    if (Cache2.has(url2)) {
      Cache2.remove(url2);
    }
  };
  texture.once("destroy", () => {
    if (url2 in loader.promiseCache) {
      warn2("[Assets] A BaseTexture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the BaseTexture.");
      unload();
    }
  });
  texture.source.once("destroy", () => {
    if (!source3.destroyed) {
      warn2("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.");
      unload();
    }
  });
  return texture;
}
var init_createTexture2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs"() {
    init_Texture2();
    init_warn2();
    init_Cache2();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs
async function loadImageBitmap2(url2) {
  const response = await DOMAdapter.get().fetch(url2);
  if (!response.ok) {
    throw new Error(`[loadImageBitmap] Failed to fetch ${url2}: ${response.status} ${response.statusText}`);
  }
  const imageBlob = await response.blob();
  const imageBitmap = await createImageBitmap(imageBlob);
  return imageBitmap;
}
var validImageExtensions2, validImageMIMEs2, loadTextures2;
var init_loadTextures2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs"() {
    init_Extensions2();
    init_ImageSource2();
    init_adapter2();
    init_getResolutionOfUrl2();
    init_checkDataUrl2();
    init_checkExtension2();
    init_LoaderParser2();
    init_WorkerManager2();
    init_createTexture2();
    validImageExtensions2 = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
    validImageMIMEs2 = [
      "image/jpeg",
      "image/png",
      "image/webp",
      "image/avif"
    ];
    loadTextures2 = {
      name: "loadTextures",
      extension: {
        type: ExtensionType3.LoadParser,
        priority: LoaderParserPriority2.High
      },
      config: {
        preferWorkers: true,
        preferCreateImageBitmap: true,
        crossOrigin: "anonymous"
      },
      test(url2) {
        return checkDataUrl2(url2, validImageMIMEs2) || checkExtension2(url2, validImageExtensions2);
      },
      async load(url2, asset, loader) {
        let src = null;
        if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {
          if (this.config.preferWorkers && await WorkerManager2.isImageBitmapSupported()) {
            src = await WorkerManager2.loadImageBitmap(url2);
          } else {
            src = await loadImageBitmap2(url2);
          }
        } else {
          src = await new Promise((resolve2) => {
            src = new Image();
            src.crossOrigin = this.config.crossOrigin;
            src.src = url2;
            if (src.complete) {
              resolve2(src);
            } else {
              src.onload = () => {
                resolve2(src);
              };
            }
          });
        }
        const base = new ImageSource2({
          resource: src,
          alphaMode: "premultiply-alpha-on-upload",
          resolution: asset.data?.resolution || getResolutionOfUrl3(url2),
          ...asset.data
        });
        return createTexture2(base, loader, url2);
      },
      unload(texture) {
        texture.destroy(true);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs
async function detectVideoAlphaMode3() {
  promise3 ?? (promise3 = (async () => {
    const canvas3 = document.createElement("canvas");
    const gl = canvas3.getContext("webgl");
    if (!gl) {
      return "premultiply-alpha-on-upload";
    }
    const video = await new Promise((resolve2) => {
      const video2 = document.createElement("video");
      video2.onloadeddata = () => resolve2(video2);
      video2.onerror = () => resolve2(null);
      video2.autoplay = false;
      video2.crossOrigin = "anonymous";
      video2.preload = "auto";
      video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";
      video2.load();
    });
    if (!video) {
      return "premultiply-alpha-on-upload";
    }
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    const framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      texture,
      0
    );
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
    const pixel = new Uint8Array(4);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
    gl.deleteFramebuffer(framebuffer);
    gl.deleteTexture(texture);
    gl.getExtension("WEBGL_lose_context")?.loseContext();
    return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
  })());
  return promise3;
}
var promise3;
var init_detectVideoAlphaMode2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs
var _VideoSource2, VideoSource2;
var init_VideoSource2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs"() {
    init_Extensions2();
    init_Ticker2();
    init_detectVideoAlphaMode2();
    init_TextureSource2();
    _VideoSource2 = class extends TextureSource2 {
      constructor(options) {
        super(options);
        this.isReady = false;
        this.uploadMethodId = "video";
        options = {
          ..._VideoSource2.defaultOptions,
          ...options
        };
        this._autoUpdate = true;
        this._isConnectedToTicker = false;
        this._updateFPS = options.updateFPS || 0;
        this._msToNextUpdate = 0;
        this.autoPlay = options.autoPlay !== false;
        this.alphaMode = options.alphaMode ?? "premultiply-alpha-on-upload";
        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);
        this._videoFrameRequestCallbackHandle = null;
        this._load = null;
        this._resolve = null;
        this._reject = null;
        this._onCanPlay = this._onCanPlay.bind(this);
        this._onError = this._onError.bind(this);
        this._onPlayStart = this._onPlayStart.bind(this);
        this._onPlayStop = this._onPlayStop.bind(this);
        this._onSeeked = this._onSeeked.bind(this);
        if (options.autoLoad !== false) {
          void this.load();
        }
      }
      /** Update the video frame if the source is not destroyed and meets certain conditions. */
      updateFrame() {
        if (this.destroyed) {
          return;
        }
        if (this._updateFPS) {
          const elapsedMS = Ticker3.shared.elapsedMS * this.resource.playbackRate;
          this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
        }
        if (!this._updateFPS || this._msToNextUpdate <= 0) {
          this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
        }
        if (this.isValid) {
          this.update();
        }
      }
      /** Callback to update the video frame and potentially request the next frame update. */
      _videoFrameRequestCallback() {
        this.updateFrame();
        if (this.destroyed) {
          this._videoFrameRequestCallbackHandle = null;
        } else {
          this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(
            this._videoFrameRequestCallback
          );
        }
      }
      /**
       * Checks if the resource has valid dimensions.
       * @returns {boolean} True if width and height are set, otherwise false.
       */
      get isValid() {
        return !!this.resource.videoWidth && !!this.resource.videoHeight;
      }
      /**
       * Start preloading the video resource.
       * @returns {Promise<this>} Handle the validate event
       */
      async load() {
        if (this._load) {
          return this._load;
        }
        const source3 = this.resource;
        if ((source3.readyState === source3.HAVE_ENOUGH_DATA || source3.readyState === source3.HAVE_FUTURE_DATA) && source3.width && source3.height) {
          source3.complete = true;
        }
        source3.addEventListener("play", this._onPlayStart);
        source3.addEventListener("pause", this._onPlayStop);
        source3.addEventListener("seeked", this._onSeeked);
        if (!this._isSourceReady()) {
          const options = this.options;
          if (!options.preload) {
            source3.addEventListener("canplay", this._onCanPlay);
          }
          source3.addEventListener("canplaythrough", this._onCanPlay);
          source3.addEventListener("error", this._onError, true);
        } else {
          this._onCanPlay();
        }
        this.alphaMode = await detectVideoAlphaMode3();
        this._load = new Promise((resolve2, reject) => {
          if (this.isValid) {
            resolve2(this);
          } else {
            this._resolve = resolve2;
            this._reject = reject;
            source3.load();
          }
        });
        return this._load;
      }
      /**
       * Handle video error events.
       * @param event - The error event
       */
      _onError(event) {
        this.resource.removeEventListener("error", this._onError, true);
        this.emit("error", event);
        if (this._reject) {
          this._reject(event);
          this._reject = null;
          this._resolve = null;
        }
      }
      /**
       * Checks if the underlying source is playing.
       * @returns True if playing.
       */
      _isSourcePlaying() {
        const source3 = this.resource;
        return !source3.paused && !source3.ended;
      }
      /**
       * Checks if the underlying source is ready for playing.
       * @returns True if ready.
       */
      _isSourceReady() {
        const source3 = this.resource;
        return source3.readyState > 2;
      }
      /** Runs the update loop when the video is ready to play. */
      _onPlayStart() {
        if (!this.isValid) {
          this._onCanPlay();
        }
        this._configureAutoUpdate();
      }
      /** Stops the update loop when a pause event is triggered. */
      _onPlayStop() {
        this._configureAutoUpdate();
      }
      /** Handles behavior when the video completes seeking to the current playback position. */
      _onSeeked() {
        if (this._autoUpdate && !this._isSourcePlaying()) {
          this._msToNextUpdate = 0;
          this.updateFrame();
          this._msToNextUpdate = 0;
        }
      }
      /** Fired when the video is loaded and ready to play. */
      _onCanPlay() {
        const source3 = this.resource;
        source3.removeEventListener("canplay", this._onCanPlay);
        source3.removeEventListener("canplaythrough", this._onCanPlay);
        if (this.isValid) {
          this.isReady = true;
          this.resize(source3.videoWidth, source3.videoHeight);
        }
        this._msToNextUpdate = 0;
        this.updateFrame();
        this._msToNextUpdate = 0;
        if (this._resolve) {
          this._resolve(this);
          this._resolve = null;
          this._reject = null;
        }
        if (this._isSourcePlaying()) {
          this._onPlayStart();
        } else if (this.autoPlay) {
          void this.resource.play();
        }
      }
      /** Cleans up resources and event listeners associated with this texture. */
      destroy() {
        this._configureAutoUpdate();
        const source3 = this.resource;
        if (source3) {
          source3.removeEventListener("play", this._onPlayStart);
          source3.removeEventListener("pause", this._onPlayStop);
          source3.removeEventListener("seeked", this._onSeeked);
          source3.removeEventListener("canplay", this._onCanPlay);
          source3.removeEventListener("canplaythrough", this._onCanPlay);
          source3.removeEventListener("error", this._onError, true);
          source3.pause();
          source3.src = "";
          source3.load();
        }
        super.destroy();
      }
      /** Should the base texture automatically update itself, set to true by default. */
      get autoUpdate() {
        return this._autoUpdate;
      }
      set autoUpdate(value) {
        if (value !== this._autoUpdate) {
          this._autoUpdate = value;
          this._configureAutoUpdate();
        }
      }
      /**
       * How many times a second to update the texture from the video.
       * Leave at 0 to update at every render.
       * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
       */
      get updateFPS() {
        return this._updateFPS;
      }
      set updateFPS(value) {
        if (value !== this._updateFPS) {
          this._updateFPS = value;
          this._configureAutoUpdate();
        }
      }
      /**
       * Configures the updating mechanism based on the current state and settings.
       *
       * This method decides between using the browser's native video frame callback or a custom ticker
       * for updating the video frame. It ensures optimal performance and responsiveness
       * based on the video's state, playback status, and the desired frames-per-second setting.
       *
       * - If `_autoUpdate` is enabled and the video source is playing:
       *   - It will prefer the native video frame callback if available and no specific FPS is set.
       *   - Otherwise, it will use a custom ticker for manual updates.
       * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.
       */
      _configureAutoUpdate() {
        if (this._autoUpdate && this._isSourcePlaying()) {
          if (!this._updateFPS && this.source.requestVideoFrameCallback) {
            if (this._isConnectedToTicker) {
              Ticker3.shared.remove(this.updateFrame, this);
              this._isConnectedToTicker = false;
              this._msToNextUpdate = 0;
            }
            if (this._videoFrameRequestCallbackHandle === null) {
              this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(
                this._videoFrameRequestCallback
              );
            }
          } else {
            if (this._videoFrameRequestCallbackHandle !== null) {
              this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
              this._videoFrameRequestCallbackHandle = null;
            }
            if (!this._isConnectedToTicker) {
              Ticker3.shared.add(this.updateFrame, this);
              this._isConnectedToTicker = true;
              this._msToNextUpdate = 0;
            }
          }
        } else {
          if (this._videoFrameRequestCallbackHandle !== null) {
            this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
            this._videoFrameRequestCallbackHandle = null;
          }
          if (this._isConnectedToTicker) {
            Ticker3.shared.remove(this.updateFrame, this);
            this._isConnectedToTicker = false;
            this._msToNextUpdate = 0;
          }
        }
      }
      static test(resource) {
        return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement || globalThis.VideoFrame && resource instanceof VideoFrame;
      }
    };
    VideoSource2 = _VideoSource2;
    VideoSource2.extension = ExtensionType3.TextureSource;
    VideoSource2.defaultOptions = {
      ...TextureSource2.defaultOptions,
      autoLoad: true,
      autoPlay: true,
      updateFPS: 0,
      crossorigin: true,
      loop: false,
      muted: true,
      playsinline: true,
      preload: false
    };
    VideoSource2.MIME_TYPES = {
      ogv: "video/ogg",
      mov: "video/quicktime",
      m4v: "video/mp4"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs
function crossOrigin2(element, url2, crossorigin) {
  if (crossorigin === void 0 && !url2.startsWith("data:")) {
    element.crossOrigin = determineCrossOrigin3(url2);
  } else if (crossorigin !== false) {
    element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
  }
}
function determineCrossOrigin3(url2, loc = globalThis.location) {
  if (url2.startsWith("data:")) {
    return "";
  }
  loc = loc || globalThis.location;
  const parsedUrl = new URL(url2, document.baseURI);
  if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {
    return "anonymous";
  }
  return "";
}
var validVideoExtensions2, validVideoMIMEs2, loadVideoTextures2;
var init_loadVideoTextures2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs"() {
    init_Extensions2();
    init_VideoSource2();
    init_detectVideoAlphaMode2();
    init_getResolutionOfUrl2();
    init_checkDataUrl2();
    init_checkExtension2();
    init_createTexture2();
    validVideoExtensions2 = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"];
    validVideoMIMEs2 = validVideoExtensions2.map((ext) => `video/${ext.substring(1)}`);
    loadVideoTextures2 = {
      name: "loadVideo",
      extension: {
        type: ExtensionType3.LoadParser
      },
      config: null,
      test(url2) {
        const isValidDataUrl = checkDataUrl2(url2, validVideoMIMEs2);
        const isValidExtension = checkExtension2(url2, validVideoExtensions2);
        return isValidDataUrl || isValidExtension;
      },
      async load(url2, asset, loader) {
        const options = {
          ...VideoSource2.defaultOptions,
          resolution: asset.data?.resolution || getResolutionOfUrl3(url2),
          alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode3(),
          ...asset.data
        };
        const videoElement = document.createElement("video");
        const attributeMap = {
          preload: options.autoLoad !== false ? "auto" : void 0,
          "webkit-playsinline": options.playsinline !== false ? "" : void 0,
          playsinline: options.playsinline !== false ? "" : void 0,
          muted: options.muted === true ? "" : void 0,
          loop: options.loop === true ? "" : void 0,
          autoplay: options.autoPlay !== false ? "" : void 0
        };
        Object.keys(attributeMap).forEach((key2) => {
          const value = attributeMap[key2];
          if (value !== void 0)
            videoElement.setAttribute(key2, value);
        });
        if (options.muted === true) {
          videoElement.muted = true;
        }
        crossOrigin2(videoElement, url2, options.crossorigin);
        const sourceElement = document.createElement("source");
        let mime;
        if (url2.startsWith("data:")) {
          mime = url2.slice(5, url2.indexOf(";"));
        } else if (!url2.startsWith("blob:")) {
          const ext = url2.split("?")[0].slice(url2.lastIndexOf(".") + 1).toLowerCase();
          mime = VideoSource2.MIME_TYPES[ext] || `video/${ext}`;
        }
        sourceElement.src = url2;
        if (mime) {
          sourceElement.type = mime;
        }
        videoElement.appendChild(sourceElement);
        const base = new VideoSource2({ ...options, resource: videoElement });
        return createTexture2(base, loader, url2);
      },
      unload(texture) {
        texture.destroy(true);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs
var resolveTextureUrl2;
var init_resolveTextureUrl2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs"() {
    init_Extensions2();
    init_loadTextures2();
    init_Resolver();
    resolveTextureUrl2 = {
      extension: ExtensionType3.ResolveParser,
      test: loadTextures2.test,
      parse: (value) => ({
        resolution: parseFloat(Resolver2.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
        format: value.split(".").pop(),
        src: value
      })
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/init.mjs
var assetKeyMap2;
var init_init9 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/init.mjs"() {
    init_Extensions2();
    init_loadBitmapFont2();
    init_cacheTextureArray2();
    init_detectAvif2();
    init_detectDefaults2();
    init_detectMp42();
    init_detectOgv2();
    init_detectWebm2();
    init_detectWebp2();
    init_loadJson2();
    init_loadTxt2();
    init_loadWebFont2();
    init_loadSVG2();
    init_loadTextures2();
    init_loadVideoTextures2();
    init_resolveTextureUrl2();
    extensions3.add(
      cacheTextureArray2,
      detectDefaults2,
      detectAvif2,
      detectWebp2,
      detectMp42,
      detectOgv2,
      detectWebm2,
      loadJson2,
      loadTxt2,
      loadWebFont2,
      loadSvg2,
      loadTextures2,
      loadVideoTextures2,
      resolveTextureUrl2,
      // TODO: these should probably be moved to its own init, along with splitting out all the
      // text pipeline stuff
      xmlBitmapFontLoader2,
      bitmapFontCachePlugin2
    );
    assetKeyMap2 = {
      loader: ExtensionType3.LoadParser,
      resolver: ExtensionType3.ResolveParser,
      cache: ExtensionType3.CacheParser,
      detection: ExtensionType3.DetectionParser
    };
    extensions3.handle(ExtensionType3.Asset, (extension) => {
      const ref = extension.ref;
      Object.entries(assetKeyMap2).filter(([key2]) => !!ref[key2]).forEach(([key2, type2]) => extensions3.add(Object.assign(
        ref[key2],
        // Allow the function to optionally define it's own
        // ExtensionMetadata, the use cases here is priority for LoaderParsers
        { extension: ref[key2].extension ?? type2 }
      )));
    }, (extension) => {
      const ref = extension.ref;
      Object.keys(assetKeyMap2).filter((key2) => !!ref[key2]).forEach((key2) => extensions3.remove(ref[key2]));
    });
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/EventTicker.mjs
var EventsTickerClass2, EventsTicker2;
var init_EventTicker2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/EventTicker.mjs"() {
    init_const12();
    init_Ticker2();
    EventsTickerClass2 = class {
      constructor() {
        this.interactionFrequency = 10;
        this._deltaTime = 0;
        this._didMove = false;
        this._tickerAdded = false;
        this._pauseUpdate = true;
      }
      /**
       * Initializes the event ticker.
       * @param events - The event system.
       */
      init(events) {
        this.removeTickerListener();
        this.events = events;
        this.interactionFrequency = 10;
        this._deltaTime = 0;
        this._didMove = false;
        this._tickerAdded = false;
        this._pauseUpdate = true;
      }
      /** Whether to pause the update checks or not. */
      get pauseUpdate() {
        return this._pauseUpdate;
      }
      set pauseUpdate(paused) {
        this._pauseUpdate = paused;
      }
      /** Adds the ticker listener. */
      addTickerListener() {
        if (this._tickerAdded || !this.domElement) {
          return;
        }
        Ticker3.system.add(this._tickerUpdate, this, UPDATE_PRIORITY3.INTERACTION);
        this._tickerAdded = true;
      }
      /** Removes the ticker listener. */
      removeTickerListener() {
        if (!this._tickerAdded) {
          return;
        }
        Ticker3.system.remove(this._tickerUpdate, this);
        this._tickerAdded = false;
      }
      /** Sets flag to not fire extra events when the user has already moved there mouse */
      pointerMoved() {
        this._didMove = true;
      }
      /** Updates the state of interactive objects. */
      _update() {
        if (!this.domElement || this._pauseUpdate) {
          return;
        }
        if (this._didMove) {
          this._didMove = false;
          return;
        }
        const rootPointerEvent = this.events["_rootPointerEvent"];
        if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
          return;
        }
        globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
          clientX: rootPointerEvent.clientX,
          clientY: rootPointerEvent.clientY
        }));
      }
      /**
       * Updates the state of interactive objects if at least {@link interactionFrequency}
       * milliseconds have passed since the last invocation.
       *
       * Invoked by a throttled ticker update from {@link Ticker.system}.
       * @param ticker - The throttled ticker.
       */
      _tickerUpdate(ticker) {
        this._deltaTime += ticker.deltaTime;
        if (this._deltaTime < this.interactionFrequency) {
          return;
        }
        this._deltaTime = 0;
        this._update();
      }
    };
    EventsTicker2 = new EventsTickerClass2();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs
var FederatedMouseEvent2;
var init_FederatedMouseEvent2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs"() {
    init_Point2();
    init_FederatedEvent2();
    FederatedMouseEvent2 = class extends FederatedEvent2 {
      constructor() {
        super(...arguments);
        this.client = new Point3();
        this.movement = new Point3();
        this.offset = new Point3();
        this.global = new Point3();
        this.screen = new Point3();
      }
      /** @readonly */
      get clientX() {
        return this.client.x;
      }
      /** @readonly */
      get clientY() {
        return this.client.y;
      }
      /**
       * Alias for {@link FederatedMouseEvent.clientX this.clientX}.
       * @readonly
       */
      get x() {
        return this.clientX;
      }
      /**
       * Alias for {@link FederatedMouseEvent.clientY this.clientY}.
       * @readonly
       */
      get y() {
        return this.clientY;
      }
      /** @readonly */
      get movementX() {
        return this.movement.x;
      }
      /** @readonly */
      get movementY() {
        return this.movement.y;
      }
      /** @readonly */
      get offsetX() {
        return this.offset.x;
      }
      /** @readonly */
      get offsetY() {
        return this.offset.y;
      }
      /** @readonly */
      get globalX() {
        return this.global.x;
      }
      /** @readonly */
      get globalY() {
        return this.global.y;
      }
      /**
       * The pointer coordinates in the renderer's screen. Alias for {@code screen.x}.
       * @readonly
       */
      get screenX() {
        return this.screen.x;
      }
      /**
       * The pointer coordinates in the renderer's screen. Alias for {@code screen.y}.
       * @readonly
       */
      get screenY() {
        return this.screen.y;
      }
      /**
       * This will return the local coordinates of the specified container for this InteractionData
       * @param {Container} container - The Container that you would like the local
       *  coords off
       * @param {PointData} point - A Point object in which to store the value, optional (otherwise
       *  will create a new point)
       * @param {PointData} globalPos - A Point object containing your custom global coords, optional
       *  (otherwise will use the current global coords)
       * @returns - A point containing the coordinates of the InteractionData position relative
       *  to the Container
       */
      getLocalPosition(container, point, globalPos) {
        return container.worldTransform.applyInverse(globalPos || this.global, point);
      }
      /**
       * Whether the modifier key was pressed when this event natively occurred.
       * @param key - The modifier key.
       */
      getModifierState(key2) {
        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key2);
      }
      /**
       * Not supported.
       * @param _typeArg
       * @param _canBubbleArg
       * @param _cancelableArg
       * @param _viewArg
       * @param _detailArg
       * @param _screenXArg
       * @param _screenYArg
       * @param _clientXArg
       * @param _clientYArg
       * @param _ctrlKeyArg
       * @param _altKeyArg
       * @param _shiftKeyArg
       * @param _metaKeyArg
       * @param _buttonArg
       * @param _relatedTargetArg
       * @deprecated since 7.0.0
       */
      // eslint-disable-next-line max-params
      initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
        throw new Error("Method not implemented.");
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs
var FederatedPointerEvent3;
var init_FederatedPointerEvent2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs"() {
    init_FederatedMouseEvent2();
    FederatedPointerEvent3 = class extends FederatedMouseEvent2 {
      constructor() {
        super(...arguments);
        this.width = 0;
        this.height = 0;
        this.isPrimary = false;
      }
      // Only included for completeness for now
      getCoalescedEvents() {
        if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
          return [this];
        }
        return [];
      }
      // Only included for completeness for now
      getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!");
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs
var FederatedWheelEvent2;
var init_FederatedWheelEvent2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs"() {
    init_FederatedMouseEvent2();
    FederatedWheelEvent2 = class extends FederatedMouseEvent2 {
      constructor() {
        super(...arguments);
        this.DOM_DELTA_PIXEL = 0;
        this.DOM_DELTA_LINE = 1;
        this.DOM_DELTA_PAGE = 2;
      }
    };
    FederatedWheelEvent2.DOM_DELTA_PIXEL = 0;
    FederatedWheelEvent2.DOM_DELTA_LINE = 1;
    FederatedWheelEvent2.DOM_DELTA_PAGE = 2;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/EventBoundary.mjs
var PROPAGATION_LIMIT2, tempHitLocation2, tempLocalMapping2, EventBoundary2;
var init_EventBoundary2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/EventBoundary.mjs"() {
    init_eventemitter3();
    init_Point2();
    init_warn2();
    init_EventTicker2();
    init_FederatedMouseEvent2();
    init_FederatedPointerEvent2();
    init_FederatedWheelEvent2();
    PROPAGATION_LIMIT2 = 2048;
    tempHitLocation2 = new Point3();
    tempLocalMapping2 = new Point3();
    EventBoundary2 = class {
      /**
       * @param rootTarget - The holder of the event boundary.
       */
      constructor(rootTarget) {
        this.dispatch = new eventemitter3_default();
        this.moveOnAll = false;
        this.enableGlobalMoveEvents = true;
        this.mappingState = {
          trackingData: {}
        };
        this.eventPool = /* @__PURE__ */ new Map();
        this._allInteractiveElements = [];
        this._hitElements = [];
        this._isPointerMoveEvent = false;
        this.rootTarget = rootTarget;
        this.hitPruneFn = this.hitPruneFn.bind(this);
        this.hitTestFn = this.hitTestFn.bind(this);
        this.mapPointerDown = this.mapPointerDown.bind(this);
        this.mapPointerMove = this.mapPointerMove.bind(this);
        this.mapPointerOut = this.mapPointerOut.bind(this);
        this.mapPointerOver = this.mapPointerOver.bind(this);
        this.mapPointerUp = this.mapPointerUp.bind(this);
        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
        this.mapWheel = this.mapWheel.bind(this);
        this.mappingTable = {};
        this.addEventMapping("pointerdown", this.mapPointerDown);
        this.addEventMapping("pointermove", this.mapPointerMove);
        this.addEventMapping("pointerout", this.mapPointerOut);
        this.addEventMapping("pointerleave", this.mapPointerOut);
        this.addEventMapping("pointerover", this.mapPointerOver);
        this.addEventMapping("pointerup", this.mapPointerUp);
        this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
        this.addEventMapping("wheel", this.mapWheel);
      }
      /**
       * Adds an event mapping for the event `type` handled by `fn`.
       *
       * Event mappings can be used to implement additional or custom events. They take an event
       * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events
       * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.
       *
       * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden
       * instead.
       * @param type - The type of upstream event to map.
       * @param fn - The mapping method. The context of this function must be bound manually, if desired.
       */
      addEventMapping(type2, fn) {
        if (!this.mappingTable[type2]) {
          this.mappingTable[type2] = [];
        }
        this.mappingTable[type2].push({
          fn,
          priority: 0
        });
        this.mappingTable[type2].sort((a2, b2) => a2.priority - b2.priority);
      }
      /**
       * Dispatches the given event
       * @param e
       * @param type
       */
      dispatchEvent(e3, type2) {
        e3.propagationStopped = false;
        e3.propagationImmediatelyStopped = false;
        this.propagate(e3, type2);
        this.dispatch.emit(type2 || e3.type, e3);
      }
      /**
       * Maps the given upstream event through the event boundary and propagates it downstream.
       * @param e
       */
      mapEvent(e3) {
        if (!this.rootTarget) {
          return;
        }
        const mappers = this.mappingTable[e3.type];
        if (mappers) {
          for (let i3 = 0, j3 = mappers.length; i3 < j3; i3++) {
            mappers[i3].fn(e3);
          }
        } else {
          warn2(`[EventBoundary]: Event mapping not defined for ${e3.type}`);
        }
      }
      /**
       * Finds the Container that is the target of a event at the given coordinates.
       *
       * The passed (x,y) coordinates are in the world space above this event boundary.
       * @param x
       * @param y
       */
      hitTest(x3, y2) {
        EventsTicker2.pauseUpdate = true;
        const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
        const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
        const invertedPath = this[fn](
          this.rootTarget,
          this.rootTarget.eventMode,
          tempHitLocation2.set(x3, y2),
          this.hitTestFn,
          this.hitPruneFn
        );
        return invertedPath && invertedPath[0];
      }
      /**
       * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its
       * target {@code e.target}.
       * @param e - The event to propagate.
       * @param type
       */
      propagate(e3, type2) {
        if (!e3.target) {
          return;
        }
        const composedPath = e3.composedPath();
        e3.eventPhase = e3.CAPTURING_PHASE;
        for (let i3 = 0, j3 = composedPath.length - 1; i3 < j3; i3++) {
          e3.currentTarget = composedPath[i3];
          this.notifyTarget(e3, type2);
          if (e3.propagationStopped || e3.propagationImmediatelyStopped)
            return;
        }
        e3.eventPhase = e3.AT_TARGET;
        e3.currentTarget = e3.target;
        this.notifyTarget(e3, type2);
        if (e3.propagationStopped || e3.propagationImmediatelyStopped)
          return;
        e3.eventPhase = e3.BUBBLING_PHASE;
        for (let i3 = composedPath.length - 2; i3 >= 0; i3--) {
          e3.currentTarget = composedPath[i3];
          this.notifyTarget(e3, type2);
          if (e3.propagationStopped || e3.propagationImmediatelyStopped)
            return;
        }
      }
      /**
       * Emits the event {@code e} to all interactive containers. The event is propagated in the bubbling phase always.
       *
       * This is used in the `globalpointermove` event.
       * @param e - The emitted event.
       * @param type - The listeners to notify.
       * @param targets - The targets to notify.
       */
      all(e3, type2, targets = this._allInteractiveElements) {
        if (targets.length === 0)
          return;
        e3.eventPhase = e3.BUBBLING_PHASE;
        const events = Array.isArray(type2) ? type2 : [type2];
        for (let i3 = targets.length - 1; i3 >= 0; i3--) {
          events.forEach((event) => {
            e3.currentTarget = targets[i3];
            this.notifyTarget(e3, event);
          });
        }
      }
      /**
       * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed
       * {@code target}. The last element in the path is {@code target}.
       * @param target
       */
      propagationPath(target) {
        const propagationPath = [target];
        for (let i3 = 0; i3 < PROPAGATION_LIMIT2 && (target !== this.rootTarget && target.parent); i3++) {
          if (!target.parent) {
            throw new Error("Cannot find propagation path to disconnected target");
          }
          propagationPath.push(target.parent);
          target = target.parent;
        }
        propagationPath.reverse();
        return propagationPath;
      }
      hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
        let shouldReturn = false;
        if (this._interactivePrune(currentTarget))
          return null;
        if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
          EventsTicker2.pauseUpdate = false;
        }
        if (currentTarget.interactiveChildren && currentTarget.children) {
          const children = currentTarget.children;
          for (let i3 = children.length - 1; i3 >= 0; i3--) {
            const child = children[i3];
            const nestedHit = this.hitTestMoveRecursive(
              child,
              this._isInteractive(eventMode) ? eventMode : child.eventMode,
              location,
              testFn,
              pruneFn,
              ignore || pruneFn(currentTarget, location)
            );
            if (nestedHit) {
              if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                continue;
              }
              const isInteractive = currentTarget.isInteractive();
              if (nestedHit.length > 0 || isInteractive) {
                if (isInteractive)
                  this._allInteractiveElements.push(currentTarget);
                nestedHit.push(currentTarget);
              }
              if (this._hitElements.length === 0)
                this._hitElements = nestedHit;
              shouldReturn = true;
            }
          }
        }
        const isInteractiveMode = this._isInteractive(eventMode);
        const isInteractiveTarget = currentTarget.isInteractive();
        if (isInteractiveTarget && isInteractiveTarget)
          this._allInteractiveElements.push(currentTarget);
        if (ignore || this._hitElements.length > 0)
          return null;
        if (shouldReturn)
          return this._hitElements;
        if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {
          return isInteractiveTarget ? [currentTarget] : [];
        }
        return null;
      }
      /**
       * Recursive implementation for {@link EventBoundary.hitTest hitTest}.
       * @param currentTarget - The Container that is to be hit tested.
       * @param eventMode - The event mode for the `currentTarget` or one of its parents.
       * @param location - The location that is being tested for overlap.
       * @param testFn - Callback that determines whether the target passes hit testing. This callback
       *  can assume that `pruneFn` failed to prune the container.
       * @param pruneFn - Callback that determiness whether the target and all of its children
       *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees
       *  of the scene graph.
       * @returns An array holding the hit testing target and all its ancestors in order. The first element
       *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite
       *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.
       */
      hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
        if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
          return null;
        }
        if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
          EventsTicker2.pauseUpdate = false;
        }
        if (currentTarget.interactiveChildren && currentTarget.children) {
          const children = currentTarget.children;
          const relativeLocation = location;
          for (let i3 = children.length - 1; i3 >= 0; i3--) {
            const child = children[i3];
            const nestedHit = this.hitTestRecursive(
              child,
              this._isInteractive(eventMode) ? eventMode : child.eventMode,
              relativeLocation,
              testFn,
              pruneFn
            );
            if (nestedHit) {
              if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                continue;
              }
              const isInteractive = currentTarget.isInteractive();
              if (nestedHit.length > 0 || isInteractive)
                nestedHit.push(currentTarget);
              return nestedHit;
            }
          }
        }
        const isInteractiveMode = this._isInteractive(eventMode);
        const isInteractiveTarget = currentTarget.isInteractive();
        if (isInteractiveMode && testFn(currentTarget, location)) {
          return isInteractiveTarget ? [currentTarget] : [];
        }
        return null;
      }
      _isInteractive(int) {
        return int === "static" || int === "dynamic";
      }
      _interactivePrune(container) {
        if (!container || !container.visible || !container.renderable) {
          return true;
        }
        if (container.eventMode === "none") {
          return true;
        }
        if (container.eventMode === "passive" && !container.interactiveChildren) {
          return true;
        }
        return false;
      }
      /**
       * Checks whether the container or any of its children cannot pass the hit test at all.
       *
       * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}
       * and {@link Container._mask} for pruning.
       * @param container
       * @param location
       */
      hitPruneFn(container, location) {
        if (container.hitArea) {
          container.worldTransform.applyInverse(location, tempLocalMapping2);
          if (!container.hitArea.contains(tempLocalMapping2.x, tempLocalMapping2.y)) {
            return true;
          }
        }
        if (container.effects && container.effects.length) {
          for (let i3 = 0; i3 < container.effects.length; i3++) {
            const effect = container.effects[i3];
            if (effect.containsPoint) {
              const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);
              if (!effectContainsPoint) {
                return true;
              }
            }
          }
        }
        return false;
      }
      /**
       * Checks whether the container passes hit testing for the given location.
       * @param container
       * @param location
       * @returns - Whether `container` passes hit testing for `location`.
       */
      hitTestFn(container, location) {
        if (container.hitArea) {
          return true;
        }
        if (container.view?.containsPoint) {
          container.worldTransform.applyInverse(location, tempLocalMapping2);
          return container.view.containsPoint(tempLocalMapping2);
        }
        return false;
      }
      /**
       * Notify all the listeners to the event's `currentTarget`.
       *
       * If the `currentTarget` contains the property `on<type>`, then it is called here,
       * simulating the behavior from version 6.x and prior.
       * @param e - The event passed to the target.
       * @param type
       */
      notifyTarget(e3, type2) {
        type2 = type2 ?? e3.type;
        const handlerKey = `on${type2}`;
        e3.currentTarget[handlerKey]?.(e3);
        const key2 = e3.eventPhase === e3.CAPTURING_PHASE || e3.eventPhase === e3.AT_TARGET ? `${type2}capture` : type2;
        this._notifyListeners(e3, key2);
        if (e3.eventPhase === e3.AT_TARGET) {
          this._notifyListeners(e3, type2);
        }
      }
      /**
       * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.
       *
       * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.
       * @param from
       */
      mapPointerDown(from) {
        if (!(from instanceof FederatedPointerEvent3)) {
          warn2("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const e3 = this.createPointerEvent(from);
        this.dispatchEvent(e3, "pointerdown");
        if (e3.pointerType === "touch") {
          this.dispatchEvent(e3, "touchstart");
        } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
          const isRightButton = e3.button === 2;
          this.dispatchEvent(e3, isRightButton ? "rightdown" : "mousedown");
        }
        const trackingData = this.trackingData(from.pointerId);
        trackingData.pressTargetsByButton[from.button] = e3.composedPath();
        this.freeEvent(e3);
      }
      /**
       * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.
       *
       * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,
       * `mousemove`, and `touchmove` events are fired as well for specific pointer types.
       * @param from - The upstream `pointermove` event.
       */
      mapPointerMove(from) {
        if (!(from instanceof FederatedPointerEvent3)) {
          warn2("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        this._allInteractiveElements.length = 0;
        this._hitElements.length = 0;
        this._isPointerMoveEvent = true;
        const e3 = this.createPointerEvent(from);
        this._isPointerMoveEvent = false;
        const isMouse = e3.pointerType === "mouse" || e3.pointerType === "pen";
        const trackingData = this.trackingData(from.pointerId);
        const outTarget = this.findMountedTarget(trackingData.overTargets);
        if (trackingData.overTargets?.length > 0 && outTarget !== e3.target) {
          const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
          const outEvent = this.createPointerEvent(from, outType, outTarget);
          this.dispatchEvent(outEvent, "pointerout");
          if (isMouse)
            this.dispatchEvent(outEvent, "mouseout");
          if (!e3.composedPath().includes(outTarget)) {
            const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
            leaveEvent.eventPhase = leaveEvent.AT_TARGET;
            while (leaveEvent.target && !e3.composedPath().includes(leaveEvent.target)) {
              leaveEvent.currentTarget = leaveEvent.target;
              this.notifyTarget(leaveEvent);
              if (isMouse)
                this.notifyTarget(leaveEvent, "mouseleave");
              leaveEvent.target = leaveEvent.target.parent;
            }
            this.freeEvent(leaveEvent);
          }
          this.freeEvent(outEvent);
        }
        if (outTarget !== e3.target) {
          const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
          const overEvent = this.clonePointerEvent(e3, overType);
          this.dispatchEvent(overEvent, "pointerover");
          if (isMouse)
            this.dispatchEvent(overEvent, "mouseover");
          let overTargetAncestor = outTarget?.parent;
          while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
            if (overTargetAncestor === e3.target)
              break;
            overTargetAncestor = overTargetAncestor.parent;
          }
          const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
          if (didPointerEnter) {
            const enterEvent = this.clonePointerEvent(e3, "pointerenter");
            enterEvent.eventPhase = enterEvent.AT_TARGET;
            while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
              enterEvent.currentTarget = enterEvent.target;
              this.notifyTarget(enterEvent);
              if (isMouse)
                this.notifyTarget(enterEvent, "mouseenter");
              enterEvent.target = enterEvent.target.parent;
            }
            this.freeEvent(enterEvent);
          }
          this.freeEvent(overEvent);
        }
        const allMethods = [];
        const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
        this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e3, "pointermove");
        allowGlobalPointerEvents && allMethods.push("globalpointermove");
        if (e3.pointerType === "touch") {
          this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e3, "touchmove");
          allowGlobalPointerEvents && allMethods.push("globaltouchmove");
        }
        if (isMouse) {
          this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e3, "mousemove");
          allowGlobalPointerEvents && allMethods.push("globalmousemove");
          this.cursor = e3.target?.cursor;
        }
        if (allMethods.length > 0) {
          this.all(e3, allMethods);
        }
        this._allInteractiveElements.length = 0;
        this._hitElements.length = 0;
        trackingData.overTargets = e3.composedPath();
        this.freeEvent(e3);
      }
      /**
       * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.
       *
       * The tracking data for the specific pointer gets a new `overTarget`.
       * @param from - The upstream `pointerover` event.
       */
      mapPointerOver(from) {
        if (!(from instanceof FederatedPointerEvent3)) {
          warn2("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const trackingData = this.trackingData(from.pointerId);
        const e3 = this.createPointerEvent(from);
        const isMouse = e3.pointerType === "mouse" || e3.pointerType === "pen";
        this.dispatchEvent(e3, "pointerover");
        if (isMouse)
          this.dispatchEvent(e3, "mouseover");
        if (e3.pointerType === "mouse")
          this.cursor = e3.target?.cursor;
        const enterEvent = this.clonePointerEvent(e3, "pointerenter");
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
          enterEvent.currentTarget = enterEvent.target;
          this.notifyTarget(enterEvent);
          if (isMouse)
            this.notifyTarget(enterEvent, "mouseenter");
          enterEvent.target = enterEvent.target.parent;
        }
        trackingData.overTargets = e3.composedPath();
        this.freeEvent(e3);
        this.freeEvent(enterEvent);
      }
      /**
       * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.
       *
       * The tracking data for the specific pointer is cleared of a `overTarget`.
       * @param from - The upstream `pointerout` event.
       */
      mapPointerOut(from) {
        if (!(from instanceof FederatedPointerEvent3)) {
          warn2("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const trackingData = this.trackingData(from.pointerId);
        if (trackingData.overTargets) {
          const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
          const outTarget = this.findMountedTarget(trackingData.overTargets);
          const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
          this.dispatchEvent(outEvent);
          if (isMouse)
            this.dispatchEvent(outEvent, "mouseout");
          const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
          leaveEvent.eventPhase = leaveEvent.AT_TARGET;
          while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
            leaveEvent.currentTarget = leaveEvent.target;
            this.notifyTarget(leaveEvent);
            if (isMouse)
              this.notifyTarget(leaveEvent, "mouseleave");
            leaveEvent.target = leaveEvent.target.parent;
          }
          trackingData.overTargets = null;
          this.freeEvent(outEvent);
          this.freeEvent(leaveEvent);
        }
        this.cursor = null;
      }
      /**
       * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,
       * and `click`/`rightclick`/`pointertap` events, in that order.
       *
       * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific
       * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,
       * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for
       * specific pointer types.
       * @param from - The upstream `pointerup` event.
       */
      mapPointerUp(from) {
        if (!(from instanceof FederatedPointerEvent3)) {
          warn2("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const now = performance.now();
        const e3 = this.createPointerEvent(from);
        this.dispatchEvent(e3, "pointerup");
        if (e3.pointerType === "touch") {
          this.dispatchEvent(e3, "touchend");
        } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
          const isRightButton = e3.button === 2;
          this.dispatchEvent(e3, isRightButton ? "rightup" : "mouseup");
        }
        const trackingData = this.trackingData(from.pointerId);
        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        let clickTarget = pressTarget;
        if (pressTarget && !e3.composedPath().includes(pressTarget)) {
          let currentTarget = pressTarget;
          while (currentTarget && !e3.composedPath().includes(currentTarget)) {
            e3.currentTarget = currentTarget;
            this.notifyTarget(e3, "pointerupoutside");
            if (e3.pointerType === "touch") {
              this.notifyTarget(e3, "touchendoutside");
            } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
              const isRightButton = e3.button === 2;
              this.notifyTarget(e3, isRightButton ? "rightupoutside" : "mouseupoutside");
            }
            currentTarget = currentTarget.parent;
          }
          delete trackingData.pressTargetsByButton[from.button];
          clickTarget = currentTarget;
        }
        if (clickTarget) {
          const clickEvent = this.clonePointerEvent(e3, "click");
          clickEvent.target = clickTarget;
          clickEvent.path = null;
          if (!trackingData.clicksByButton[from.button]) {
            trackingData.clicksByButton[from.button] = {
              clickCount: 0,
              target: clickEvent.target,
              timeStamp: now
            };
          }
          const clickHistory = trackingData.clicksByButton[from.button];
          if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
            ++clickHistory.clickCount;
          } else {
            clickHistory.clickCount = 1;
          }
          clickHistory.target = clickEvent.target;
          clickHistory.timeStamp = now;
          clickEvent.detail = clickHistory.clickCount;
          if (clickEvent.pointerType === "mouse") {
            const isRightButton = clickEvent.button === 2;
            this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
          } else if (clickEvent.pointerType === "touch") {
            this.dispatchEvent(clickEvent, "tap");
          }
          this.dispatchEvent(clickEvent, "pointertap");
          this.freeEvent(clickEvent);
        }
        this.freeEvent(e3);
      }
      /**
       * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original
       * `pointerdown` target to `rootTarget`.
       *
       * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the
       * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)
       *
       * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer
       * types. The tracking data for the specific pointer is cleared of a `pressTarget`.
       * @param from - The upstream `pointerupoutside` event.
       */
      mapPointerUpOutside(from) {
        if (!(from instanceof FederatedPointerEvent3)) {
          warn2("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const trackingData = this.trackingData(from.pointerId);
        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        const e3 = this.createPointerEvent(from);
        if (pressTarget) {
          let currentTarget = pressTarget;
          while (currentTarget) {
            e3.currentTarget = currentTarget;
            this.notifyTarget(e3, "pointerupoutside");
            if (e3.pointerType === "touch") {
              this.notifyTarget(e3, "touchendoutside");
            } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
              this.notifyTarget(e3, e3.button === 2 ? "rightupoutside" : "mouseupoutside");
            }
            currentTarget = currentTarget.parent;
          }
          delete trackingData.pressTargetsByButton[from.button];
        }
        this.freeEvent(e3);
      }
      /**
       * Maps the upstream `wheel` event to a downstream `wheel` event.
       * @param from - The upstream `wheel` event.
       */
      mapWheel(from) {
        if (!(from instanceof FederatedWheelEvent2)) {
          warn2("EventBoundary cannot map a non-wheel event as a wheel event");
          return;
        }
        const wheelEvent = this.createWheelEvent(from);
        this.dispatchEvent(wheelEvent);
        this.freeEvent(wheelEvent);
      }
      /**
       * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.
       *
       * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`
       * or `pointerover` target was unmounted from the scene graph.
       * @param propagationPath - The propagation path was valid in the past.
       * @returns - The most specific event-target still mounted at the same location in the scene graph.
       */
      findMountedTarget(propagationPath) {
        if (!propagationPath) {
          return null;
        }
        let currentTarget = propagationPath[0];
        for (let i3 = 1; i3 < propagationPath.length; i3++) {
          if (propagationPath[i3].parent === currentTarget) {
            currentTarget = propagationPath[i3];
          } else {
            break;
          }
        }
        return currentTarget;
      }
      /**
       * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.
       *
       * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
       * @param from - The {@code originalEvent} for the returned event.
       * @param [type=from.type] - The type of the returned event.
       * @param target - The target of the returned event.
       */
      createPointerEvent(from, type2, target) {
        const event = this.allocateEvent(FederatedPointerEvent3);
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
        if (typeof type2 === "string") {
          event.type = type2;
        }
        return event;
      }
      /**
       * Creates a wheel event whose {@code originalEvent} is {@code from}.
       *
       * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
       * @param from - The upstream wheel event.
       */
      createWheelEvent(from) {
        const event = this.allocateEvent(FederatedWheelEvent2);
        this.copyWheelData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        event.target = this.hitTest(event.global.x, event.global.y);
        return event;
      }
      /**
       * Clones the event {@code from}, with an optional {@code type} override.
       *
       * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
       * @param from - The event to clone.
       * @param [type=from.type] - The type of the returned event.
       */
      clonePointerEvent(from, type2) {
        const event = this.allocateEvent(FederatedPointerEvent3);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from.originalEvent;
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.target = from.target;
        event.path = from.composedPath().slice();
        event.type = type2 ?? event.type;
        return event;
      }
      /**
       * Copies wheel {@link FederatedWheelEvent} data from {@code from} into {@code to}.
       *
       * The following properties are copied:
       * + deltaMode
       * + deltaX
       * + deltaY
       * + deltaZ
       * @param from
       * @param to
       */
      copyWheelData(from, to) {
        to.deltaMode = from.deltaMode;
        to.deltaX = from.deltaX;
        to.deltaY = from.deltaY;
        to.deltaZ = from.deltaZ;
      }
      /**
       * Copies pointer {@link FederatedPointerEvent} data from {@code from} into {@code to}.
       *
       * The following properties are copied:
       * + pointerId
       * + width
       * + height
       * + isPrimary
       * + pointerType
       * + pressure
       * + tangentialPressure
       * + tiltX
       * + tiltY
       * @param from
       * @param to
       */
      copyPointerData(from, to) {
        if (!(from instanceof FederatedPointerEvent3 && to instanceof FederatedPointerEvent3))
          return;
        to.pointerId = from.pointerId;
        to.width = from.width;
        to.height = from.height;
        to.isPrimary = from.isPrimary;
        to.pointerType = from.pointerType;
        to.pressure = from.pressure;
        to.tangentialPressure = from.tangentialPressure;
        to.tiltX = from.tiltX;
        to.tiltY = from.tiltY;
        to.twist = from.twist;
      }
      /**
       * Copies mouse {@link FederatedMouseEvent} data from {@code from} to {@code to}.
       *
       * The following properties are copied:
       * + altKey
       * + button
       * + buttons
       * + clientX
       * + clientY
       * + metaKey
       * + movementX
       * + movementY
       * + pageX
       * + pageY
       * + x
       * + y
       * + screen
       * + shiftKey
       * + global
       * @param from
       * @param to
       */
      copyMouseData(from, to) {
        if (!(from instanceof FederatedMouseEvent2 && to instanceof FederatedMouseEvent2))
          return;
        to.altKey = from.altKey;
        to.button = from.button;
        to.buttons = from.buttons;
        to.client.copyFrom(from.client);
        to.ctrlKey = from.ctrlKey;
        to.metaKey = from.metaKey;
        to.movement.copyFrom(from.movement);
        to.screen.copyFrom(from.screen);
        to.shiftKey = from.shiftKey;
        to.global.copyFrom(from.global);
      }
      /**
       * Copies base {@link FederatedEvent} data from {@code from} into {@code to}.
       *
       * The following properties are copied:
       * + isTrusted
       * + srcElement
       * + timeStamp
       * + type
       * @param from - The event to copy data from.
       * @param to - The event to copy data into.
       */
      copyData(from, to) {
        to.isTrusted = from.isTrusted;
        to.srcElement = from.srcElement;
        to.timeStamp = performance.now();
        to.type = from.type;
        to.detail = from.detail;
        to.view = from.view;
        to.which = from.which;
        to.layer.copyFrom(from.layer);
        to.page.copyFrom(from.page);
      }
      /**
       * @param id - The pointer ID.
       * @returns The tracking data stored for the given pointer. If no data exists, a blank
       *  state will be created.
       */
      trackingData(id) {
        if (!this.mappingState.trackingData[id]) {
          this.mappingState.trackingData[id] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null
          };
        }
        return this.mappingState.trackingData[id];
      }
      /**
       * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.
       *
       * This allocation is constructor-agnostic, as long as it only takes one argument - this event
       * boundary.
       * @param constructor - The event's constructor.
       */
      allocateEvent(constructor) {
        if (!this.eventPool.has(constructor)) {
          this.eventPool.set(constructor, []);
        }
        const event = this.eventPool.get(constructor).pop() || new constructor(this);
        event.eventPhase = event.NONE;
        event.currentTarget = null;
        event.path = null;
        event.target = null;
        return event;
      }
      /**
       * Frees the event and puts it back into the event pool.
       *
       * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.
       *
       * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}
       * not be freed. This is because of the possibility that the same event is freed twice, which can cause
       * it to be allocated twice & result in overwriting.
       * @param event - The event to be freed.
       * @throws Error if the event is managed by another event boundary.
       */
      freeEvent(event) {
        if (event.manager !== this)
          throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        const constructor = event.constructor;
        if (!this.eventPool.has(constructor)) {
          this.eventPool.set(constructor, []);
        }
        this.eventPool.get(constructor).push(event);
      }
      /**
       * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag
       * is set on the event.
       * @param e - The event to call each listener with.
       * @param type - The event key.
       */
      _notifyListeners(e3, type2) {
        const listeners = e3.currentTarget._events[type2];
        if (!listeners)
          return;
        if (!e3.currentTarget.isInteractive())
          return;
        if ("fn" in listeners) {
          if (listeners.once)
            e3.currentTarget.removeListener(type2, listeners.fn, void 0, true);
          listeners.fn.call(listeners.context, e3);
        } else {
          for (let i3 = 0, j3 = listeners.length; i3 < j3 && !e3.propagationImmediatelyStopped; i3++) {
            if (listeners[i3].once)
              e3.currentTarget.removeListener(type2, listeners[i3].fn, void 0, true);
            listeners[i3].fn.call(listeners[i3].context, e3);
          }
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/EventSystem.mjs
var MOUSE_POINTER_ID2, TOUCH_TO_POINTER2, _EventSystem2, EventSystem2;
var init_EventSystem2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/EventSystem.mjs"() {
    init_Extensions2();
    init_EventBoundary2();
    init_EventTicker2();
    init_FederatedPointerEvent2();
    init_FederatedWheelEvent2();
    MOUSE_POINTER_ID2 = 1;
    TOUCH_TO_POINTER2 = {
      touchstart: "pointerdown",
      touchend: "pointerup",
      touchendoutside: "pointerupoutside",
      touchmove: "pointermove",
      touchcancel: "pointercancel"
    };
    _EventSystem2 = class {
      /**
       * @param {Renderer} renderer
       */
      constructor(renderer) {
        this.supportsTouchEvents = "ontouchstart" in globalThis;
        this.supportsPointerEvents = !!globalThis.PointerEvent;
        this.domElement = null;
        this.resolution = 1;
        this.renderer = renderer;
        this.rootBoundary = new EventBoundary2(null);
        EventsTicker2.init(this);
        this.autoPreventDefault = true;
        this._eventsAdded = false;
        this._rootPointerEvent = new FederatedPointerEvent3(null);
        this._rootWheelEvent = new FederatedWheelEvent2(null);
        this.cursorStyles = {
          default: "inherit",
          pointer: "pointer"
        };
        this.features = new Proxy({ ..._EventSystem2.defaultEventFeatures }, {
          set: (target, key2, value) => {
            if (key2 === "globalMove") {
              this.rootBoundary.enableGlobalMoveEvents = value;
            }
            target[key2] = value;
            return true;
          }
        });
        this._onPointerDown = this._onPointerDown.bind(this);
        this._onPointerMove = this._onPointerMove.bind(this);
        this._onPointerUp = this._onPointerUp.bind(this);
        this._onPointerOverOut = this._onPointerOverOut.bind(this);
        this.onWheel = this.onWheel.bind(this);
      }
      /**
       * The default interaction mode for all display objects.
       * @see Container.eventMode
       * @type {EventMode}
       * @readonly
       * @since 7.2.0
       */
      static get defaultEventMode() {
        return this._defaultEventMode;
      }
      /**
       * Runner init called, view is available at this point.
       * @ignore
       */
      init(options) {
        const { canvas: canvas3, resolution } = this.renderer;
        this.setTargetElement(canvas3);
        this.resolution = resolution;
        _EventSystem2._defaultEventMode = options.eventMode ?? "passive";
        Object.assign(this.features, options.eventFeatures ?? {});
        this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
      }
      /**
       * Handle changing resolution.
       * @ignore
       */
      resolutionChange(resolution) {
        this.resolution = resolution;
      }
      /** Destroys all event listeners and detaches the renderer. */
      destroy() {
        this.setTargetElement(null);
        this.renderer = null;
        this._currentCursor = null;
      }
      /**
       * Sets the current cursor mode, handling any callbacks or CSS style changes.
       * @param mode - cursor mode, a key from the cursorStyles dictionary
       */
      setCursor(mode) {
        mode = mode || "default";
        let applyStyles = true;
        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
          applyStyles = false;
        }
        if (this._currentCursor === mode) {
          return;
        }
        this._currentCursor = mode;
        const style = this.cursorStyles[mode];
        if (style) {
          switch (typeof style) {
            case "string":
              if (applyStyles) {
                this.domElement.style.cursor = style;
              }
              break;
            case "function":
              style(mode);
              break;
            case "object":
              if (applyStyles) {
                Object.assign(this.domElement.style, style);
              }
              break;
          }
        } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
          this.domElement.style.cursor = mode;
        }
      }
      /**
       * The global pointer event.
       * Useful for getting the pointer position without listening to events.
       * @since 7.2.0
       */
      get pointer() {
        return this._rootPointerEvent;
      }
      /**
       * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch event.
       */
      _onPointerDown(nativeEvent) {
        if (!this.features.click)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const events = this._normalizeToPointerData(nativeEvent);
        if (this.autoPreventDefault && events[0].isNormalized) {
          const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
          if (cancelable) {
            nativeEvent.preventDefault();
          }
        }
        for (let i3 = 0, j3 = events.length; i3 < j3; i3++) {
          const nativeEvent2 = events[i3];
          const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);
          this.rootBoundary.mapEvent(federatedEvent);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch events.
       */
      _onPointerMove(nativeEvent) {
        if (!this.features.move)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        EventsTicker2.pointerMoved();
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for (let i3 = 0, j3 = normalizedEvents.length; i3 < j3; i3++) {
          const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i3]);
          this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch event.
       */
      _onPointerUp(nativeEvent) {
        if (!this.features.click)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        let target = nativeEvent.target;
        if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
          target = nativeEvent.composedPath()[0];
        }
        const outside = target !== this.domElement ? "outside" : "";
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for (let i3 = 0, j3 = normalizedEvents.length; i3 < j3; i3++) {
          const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i3]);
          event.type += outside;
          this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch event.
       */
      _onPointerOverOut(nativeEvent) {
        if (!this.features.click)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for (let i3 = 0, j3 = normalizedEvents.length; i3 < j3; i3++) {
          const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i3]);
          this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.
       * @param nativeEvent - The native wheel event.
       */
      onWheel(nativeEvent) {
        if (!this.features.wheel)
          return;
        const wheelEvent = this.normalizeWheelEvent(nativeEvent);
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        this.rootBoundary.mapEvent(wheelEvent);
      }
      /**
       * Sets the {@link EventSystem#domElement domElement} and binds event listeners.
       *
       * To deregister the current DOM element without setting a new one, pass {@code null}.
       * @param element - The new DOM element.
       */
      setTargetElement(element) {
        this._removeEvents();
        this.domElement = element;
        EventsTicker2.domElement = element;
        this._addEvents();
      }
      /** Register event listeners on {@link Renderer#domElement this.domElement}. */
      _addEvents() {
        if (this._eventsAdded || !this.domElement) {
          return;
        }
        EventsTicker2.addTickerListener();
        const style = this.domElement.style;
        if (style) {
          if (globalThis.navigator.msPointerEnabled) {
            style.msContentZooming = "none";
            style.msTouchAction = "none";
          } else if (this.supportsPointerEvents) {
            style.touchAction = "none";
          }
        }
        if (this.supportsPointerEvents) {
          globalThis.document.addEventListener("pointermove", this._onPointerMove, true);
          this.domElement.addEventListener("pointerdown", this._onPointerDown, true);
          this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true);
          this.domElement.addEventListener("pointerover", this._onPointerOverOut, true);
          globalThis.addEventListener("pointerup", this._onPointerUp, true);
        } else {
          globalThis.document.addEventListener("mousemove", this._onPointerMove, true);
          this.domElement.addEventListener("mousedown", this._onPointerDown, true);
          this.domElement.addEventListener("mouseout", this._onPointerOverOut, true);
          this.domElement.addEventListener("mouseover", this._onPointerOverOut, true);
          globalThis.addEventListener("mouseup", this._onPointerUp, true);
          if (this.supportsTouchEvents) {
            this.domElement.addEventListener("touchstart", this._onPointerDown, true);
            this.domElement.addEventListener("touchend", this._onPointerUp, true);
            this.domElement.addEventListener("touchmove", this._onPointerMove, true);
          }
        }
        this.domElement.addEventListener("wheel", this.onWheel, {
          passive: true,
          capture: true
        });
        this._eventsAdded = true;
      }
      /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */
      _removeEvents() {
        if (!this._eventsAdded || !this.domElement) {
          return;
        }
        EventsTicker2.removeTickerListener();
        const style = this.domElement.style;
        if (globalThis.navigator.msPointerEnabled) {
          style.msContentZooming = "";
          style.msTouchAction = "";
        } else if (this.supportsPointerEvents) {
          style.touchAction = "";
        }
        if (this.supportsPointerEvents) {
          globalThis.document.removeEventListener("pointermove", this._onPointerMove, true);
          this.domElement.removeEventListener("pointerdown", this._onPointerDown, true);
          this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true);
          this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true);
          globalThis.removeEventListener("pointerup", this._onPointerUp, true);
        } else {
          globalThis.document.removeEventListener("mousemove", this._onPointerMove, true);
          this.domElement.removeEventListener("mousedown", this._onPointerDown, true);
          this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true);
          this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true);
          globalThis.removeEventListener("mouseup", this._onPointerUp, true);
          if (this.supportsTouchEvents) {
            this.domElement.removeEventListener("touchstart", this._onPointerDown, true);
            this.domElement.removeEventListener("touchend", this._onPointerUp, true);
            this.domElement.removeEventListener("touchmove", this._onPointerMove, true);
          }
        }
        this.domElement.removeEventListener("wheel", this.onWheel, true);
        this.domElement = null;
        this._eventsAdded = false;
      }
      /**
       * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The
       * resulting value is stored in the point. This takes into account the fact that the DOM
       * element could be scaled and positioned anywhere on the screen.
       * @param  {PointData} point - the point that the result will be stored in
       * @param  {number} x - the x coord of the position to map
       * @param  {number} y - the y coord of the position to map
       */
      mapPositionToPoint(point, x3, y2) {
        const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
          x: 0,
          y: 0,
          width: this.domElement.width,
          height: this.domElement.height,
          left: 0,
          top: 0
        };
        const resolutionMultiplier = 1 / this.resolution;
        point.x = (x3 - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
        point.y = (y2 - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
      }
      /**
       * Ensures that the original event object contains all data that a regular pointer event would have
       * @param event - The original event data from a touch or mouse event
       * @returns An array containing a single normalized pointer event, in the case of a pointer
       *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
       */
      _normalizeToPointerData(event) {
        const normalizedEvents = [];
        if (this.supportsTouchEvents && event instanceof TouchEvent) {
          for (let i3 = 0, li = event.changedTouches.length; i3 < li; i3++) {
            const touch = event.changedTouches[i3];
            if (typeof touch.button === "undefined")
              touch.button = 0;
            if (typeof touch.buttons === "undefined")
              touch.buttons = 1;
            if (typeof touch.isPrimary === "undefined") {
              touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
            }
            if (typeof touch.width === "undefined")
              touch.width = touch.radiusX || 1;
            if (typeof touch.height === "undefined")
              touch.height = touch.radiusY || 1;
            if (typeof touch.tiltX === "undefined")
              touch.tiltX = 0;
            if (typeof touch.tiltY === "undefined")
              touch.tiltY = 0;
            if (typeof touch.pointerType === "undefined")
              touch.pointerType = "touch";
            if (typeof touch.pointerId === "undefined")
              touch.pointerId = touch.identifier || 0;
            if (typeof touch.pressure === "undefined")
              touch.pressure = touch.force || 0.5;
            if (typeof touch.twist === "undefined")
              touch.twist = 0;
            if (typeof touch.tangentialPressure === "undefined")
              touch.tangentialPressure = 0;
            if (typeof touch.layerX === "undefined")
              touch.layerX = touch.offsetX = touch.clientX;
            if (typeof touch.layerY === "undefined")
              touch.layerY = touch.offsetY = touch.clientY;
            touch.isNormalized = true;
            touch.type = event.type;
            normalizedEvents.push(touch);
          }
        } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
          const tempEvent = event;
          if (typeof tempEvent.isPrimary === "undefined")
            tempEvent.isPrimary = true;
          if (typeof tempEvent.width === "undefined")
            tempEvent.width = 1;
          if (typeof tempEvent.height === "undefined")
            tempEvent.height = 1;
          if (typeof tempEvent.tiltX === "undefined")
            tempEvent.tiltX = 0;
          if (typeof tempEvent.tiltY === "undefined")
            tempEvent.tiltY = 0;
          if (typeof tempEvent.pointerType === "undefined")
            tempEvent.pointerType = "mouse";
          if (typeof tempEvent.pointerId === "undefined")
            tempEvent.pointerId = MOUSE_POINTER_ID2;
          if (typeof tempEvent.pressure === "undefined")
            tempEvent.pressure = 0.5;
          if (typeof tempEvent.twist === "undefined")
            tempEvent.twist = 0;
          if (typeof tempEvent.tangentialPressure === "undefined")
            tempEvent.tangentialPressure = 0;
          tempEvent.isNormalized = true;
          normalizedEvents.push(tempEvent);
        } else {
          normalizedEvents.push(event);
        }
        return normalizedEvents;
      }
      /**
       * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.
       *
       * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across
       * multiple native wheel events.
       * @param nativeEvent - The native wheel event that occurred on the canvas.
       * @returns A federated wheel event.
       */
      normalizeWheelEvent(nativeEvent) {
        const event = this._rootWheelEvent;
        this._transferMouseData(event, nativeEvent);
        event.deltaX = nativeEvent.deltaX;
        event.deltaY = nativeEvent.deltaY;
        event.deltaZ = nativeEvent.deltaZ;
        event.deltaMode = nativeEvent.deltaMode;
        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
        event.global.copyFrom(event.screen);
        event.offset.copyFrom(event.screen);
        event.nativeEvent = nativeEvent;
        event.type = nativeEvent.type;
        return event;
      }
      /**
       * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.
       * @param event
       * @param nativeEvent
       */
      _bootstrapEvent(event, nativeEvent) {
        event.originalEvent = null;
        event.nativeEvent = nativeEvent;
        event.pointerId = nativeEvent.pointerId;
        event.width = nativeEvent.width;
        event.height = nativeEvent.height;
        event.isPrimary = nativeEvent.isPrimary;
        event.pointerType = nativeEvent.pointerType;
        event.pressure = nativeEvent.pressure;
        event.tangentialPressure = nativeEvent.tangentialPressure;
        event.tiltX = nativeEvent.tiltX;
        event.tiltY = nativeEvent.tiltY;
        event.twist = nativeEvent.twist;
        this._transferMouseData(event, nativeEvent);
        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
        event.global.copyFrom(event.screen);
        event.offset.copyFrom(event.screen);
        event.isTrusted = nativeEvent.isTrusted;
        if (event.type === "pointerleave") {
          event.type = "pointerout";
        }
        if (event.type.startsWith("mouse")) {
          event.type = event.type.replace("mouse", "pointer");
        }
        if (event.type.startsWith("touch")) {
          event.type = TOUCH_TO_POINTER2[event.type] || event.type;
        }
        return event;
      }
      /**
       * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.
       * @param event
       * @param nativeEvent
       */
      _transferMouseData(event, nativeEvent) {
        event.isTrusted = nativeEvent.isTrusted;
        event.srcElement = nativeEvent.srcElement;
        event.timeStamp = performance.now();
        event.type = nativeEvent.type;
        event.altKey = nativeEvent.altKey;
        event.button = nativeEvent.button;
        event.buttons = nativeEvent.buttons;
        event.client.x = nativeEvent.clientX;
        event.client.y = nativeEvent.clientY;
        event.ctrlKey = nativeEvent.ctrlKey;
        event.metaKey = nativeEvent.metaKey;
        event.movement.x = nativeEvent.movementX;
        event.movement.y = nativeEvent.movementY;
        event.page.x = nativeEvent.pageX;
        event.page.y = nativeEvent.pageY;
        event.relatedTarget = null;
        event.shiftKey = nativeEvent.shiftKey;
      }
    };
    EventSystem2 = _EventSystem2;
    EventSystem2.extension = {
      name: "events",
      type: [
        ExtensionType3.WebGLSystem,
        ExtensionType3.CanvasSystem,
        ExtensionType3.WebGPUSystem
      ],
      priority: -1
    };
    EventSystem2.defaultEventFeatures = {
      move: true,
      globalMove: true,
      click: true,
      wheel: true
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/FederatedEventTarget.mjs
var FederatedContainer2;
var init_FederatedEventTarget2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/FederatedEventTarget.mjs"() {
    init_EventSystem2();
    init_FederatedEvent2();
    FederatedContainer2 = {
      /**
       * Property-based event handler for the `click` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onclick = (event) => {
       *  //some function here that happens on click
       * }
       */
      onclick: null,
      /**
       * Property-based event handler for the `mousedown` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmousedown = (event) => {
       *  //some function here that happens on mousedown
       * }
       */
      onmousedown: null,
      /**
       * Property-based event handler for the `mouseenter` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmouseenter = (event) => {
       *  //some function here that happens on mouseenter
       * }
       */
      onmouseenter: null,
      /**
       * Property-based event handler for the `mouseleave` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmouseleave = (event) => {
       *  //some function here that happens on mouseleave
       * }
       */
      onmouseleave: null,
      /**
       * Property-based event handler for the `mousemove` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmousemove = (event) => {
       *  //some function here that happens on mousemove
       * }
       */
      onmousemove: null,
      /**
       * Property-based event handler for the `globalmousemove` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onglobalmousemove = (event) => {
       *  //some function here that happens on globalmousemove
       * }
       */
      onglobalmousemove: null,
      /**
       * Property-based event handler for the `mouseout` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmouseout = (event) => {
       *  //some function here that happens on mouseout
       * }
       */
      onmouseout: null,
      /**
       * Property-based event handler for the `mouseover` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmouseover = (event) => {
       *  //some function here that happens on mouseover
       * }
       */
      onmouseover: null,
      /**
       * Property-based event handler for the `mouseup` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmouseup = (event) => {
       *  //some function here that happens on mouseup
       * }
       */
      onmouseup: null,
      /**
       * Property-based event handler for the `mouseupoutside` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmouseupoutside = (event) => {
       *  //some function here that happens on mouseupoutside
       * }
       */
      onmouseupoutside: null,
      /**
       * Property-based event handler for the `pointercancel` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointercancel = (event) => {
       *  //some function here that happens on pointercancel
       * }
       */
      onpointercancel: null,
      /**
       * Property-based event handler for the `pointerdown` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointerdown = (event) => {
       *  //some function here that happens on pointerdown
       * }
       */
      onpointerdown: null,
      /**
       * Property-based event handler for the `pointerenter` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointerenter = (event) => {
       *  //some function here that happens on pointerenter
       * }
       */
      onpointerenter: null,
      /**
       * Property-based event handler for the `pointerleave` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointerleave = (event) => {
       *  //some function here that happens on pointerleave
       * }
       */
      onpointerleave: null,
      /**
       * Property-based event handler for the `pointermove` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointermove = (event) => {
       *  //some function here that happens on pointermove
       * }
       */
      onpointermove: null,
      /**
       * Property-based event handler for the `globalpointermove` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onglobalpointermove = (event) => {
       *  //some function here that happens on globalpointermove
       * }
       */
      onglobalpointermove: null,
      /**
       * Property-based event handler for the `pointerout` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointerout = (event) => {
       *  //some function here that happens on pointerout
       * }
       */
      onpointerout: null,
      /**
       * Property-based event handler for the `pointerover` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointerover = (event) => {
       *  //some function here that happens on pointerover
       * }
       */
      onpointerover: null,
      /**
       * Property-based event handler for the `pointertap` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointertap = (event) => {
       *  //some function here that happens on pointertap
       * }
       */
      onpointertap: null,
      /**
       * Property-based event handler for the `pointerup` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointerup = (event) => {
       *  //some function here that happens on pointerup
       * }
       */
      onpointerup: null,
      /**
       * Property-based event handler for the `pointerupoutside` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointerupoutside = (event) => {
       *  //some function here that happens on pointerupoutside
       * }
       */
      onpointerupoutside: null,
      /**
       * Property-based event handler for the `rightclick` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onrightclick = (event) => {
       *  //some function here that happens on rightclick
       * }
       */
      onrightclick: null,
      /**
       * Property-based event handler for the `rightdown` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onrightdown = (event) => {
       *  //some function here that happens on rightdown
       * }
       */
      onrightdown: null,
      /**
       * Property-based event handler for the `rightup` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onrightup = (event) => {
       *  //some function here that happens on rightup
       * }
       */
      onrightup: null,
      /**
       * Property-based event handler for the `rightupoutside` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onrightupoutside = (event) => {
       *  //some function here that happens on rightupoutside
       * }
       */
      onrightupoutside: null,
      /**
       * Property-based event handler for the `tap` event.
       * @memberof Container#
       * @default null
       * @example
       * this.ontap = (event) => {
       *  //some function here that happens on tap
       * }
       */
      ontap: null,
      /**
       * Property-based event handler for the `touchcancel` event.
       * @memberof Container#
       * @default null
       * @example
       * this.ontouchcancel = (event) => {
       *  //some function here that happens on touchcancel
       * }
       */
      ontouchcancel: null,
      /**
       * Property-based event handler for the `touchend` event.
       * @memberof Container#
       * @default null
       * @example
       * this.ontouchend = (event) => {
       *  //some function here that happens on touchend
       * }
       */
      ontouchend: null,
      /**
       * Property-based event handler for the `touchendoutside` event.
       * @memberof Container#
       * @default null
       * @example
       * this.ontouchendoutside = (event) => {
       *  //some function here that happens on touchendoutside
       * }
       */
      ontouchendoutside: null,
      /**
       * Property-based event handler for the `touchmove` event.
       * @memberof Container#
       * @default null
       * @example
       * this.ontouchmove = (event) => {
       *  //some function here that happens on touchmove
       * }
       */
      ontouchmove: null,
      /**
       * Property-based event handler for the `globaltouchmove` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onglobaltouchmove = (event) => {
       *  //some function here that happens on globaltouchmove
       * }
       */
      onglobaltouchmove: null,
      /**
       * Property-based event handler for the `touchstart` event.
       * @memberof Container#
       * @default null
       * @example
       * this.ontouchstart = (event) => {
       *  //some function here that happens on touchstart
       * }
       */
      ontouchstart: null,
      /**
       * Property-based event handler for the `wheel` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onwheel = (event) => {
       *  //some function here that happens on wheel
       * }
       */
      onwheel: null,
      /**
       * Enable interaction events for the Container. Touch, pointer and mouse
       * @memberof Container#
       */
      get interactive() {
        return this.eventMode === "dynamic" || this.eventMode === "static";
      },
      set interactive(value) {
        this.eventMode = value ? "static" : "passive";
      },
      /**
       * @ignore
       */
      _internalEventMode: void 0,
      /**
       * Enable interaction events for the Container. Touch, pointer and mouse.
       * This now replaces the `interactive` property.
       * There are 5 types of interaction settings:
       * - `'none'`: Ignores all interaction events, even on its children.
       * - `'passive'`: Does not emit events and ignores all hit testing on itself and non-interactive children.
       * Interactive children will still emit events.
       * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7
       * - `'static'`: Emit events and is hit tested. Same as `interaction = true` in v7
       * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from a ticker to
       * allow for interaction when the mouse isn't moving
       * @example
       * import { Sprite } from 'pixi.js';
       *
       * const sprite = new Sprite(texture);
       * sprite.eventMode = 'static';
       * sprite.on('tap', (event) => {
       *     // Handle event
       * });
       * @memberof Container#
       * @since 7.2.0
       */
      get eventMode() {
        return this._internalEventMode ?? EventSystem2.defaultEventMode;
      },
      set eventMode(value) {
        this._internalEventMode = value;
      },
      /**
       * Determines if the container is interactive or not
       * @returns {boolean} Whether the container is interactive or not
       * @memberof Container#
       * @since 7.2.0
       * @example
       * import { Sprite } from 'pixi.js';
       * const sprite = new Sprite(texture);
       * sprite.eventMode = 'static';
       * sprite.isInteractive(); // true
       *
       * sprite.eventMode = 'dynamic';
       * sprite.isInteractive(); // true
       *
       * sprite.eventMode = 'none';
       * sprite.isInteractive(); // false
       *
       * sprite.eventMode = 'passive';
       * sprite.isInteractive(); // false
       *
       * sprite.eventMode = 'auto';
       * sprite.isInteractive(); // false
       */
      isInteractive() {
        return this.eventMode === "static" || this.eventMode === "dynamic";
      },
      /**
       * Determines if the children to the container can be clicked/touched
       * Setting this to false allows PixiJS to bypass a recursive `hitTest` function
       * @memberof Container#
       */
      interactiveChildren: true,
      /**
       * Interaction shape. Children will be hit first, then this shape will be checked.
       * Setting this will cause this shape to be checked in hit tests rather than the container's bounds.
       * @example
       * import { Rectangle, Sprite } from 'pixi.js';
       *
       * const sprite = new Sprite(texture);
       * sprite.interactive = true;
       * sprite.hitArea = new Rectangle(0, 0, 100, 100);
       * @member {IHitArea}
       * @memberof Container#
       */
      hitArea: null,
      /**
       * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`
       * seeks to be compatible with the DOM's `addEventListener` with support for options.
       * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.
       * @memberof Container
       * @param type - The type of event to listen to.
       * @param listener - The listener callback or object.
       * @param options - Listener options, used for capture phase.
       * @example
       * // Tell the user whether they did a single, double, triple, or nth click.
       * button.addEventListener('click', {
       *     handleEvent(e): {
       *         let prefix;
       *
       *         switch (e.detail) {
       *             case 1: prefix = 'single'; break;
       *             case 2: prefix = 'double'; break;
       *             case 3: prefix = 'triple'; break;
       *             default: prefix = e.detail + 'th'; break;
       *         }
       *
       *         console.log('That was a ' + prefix + 'click');
       *     }
       * });
       *
       * // But skip the first click!
       * button.parent.addEventListener('click', function blockClickOnce(e) {
       *     e.stopImmediatePropagation();
       *     button.parent.removeEventListener('click', blockClickOnce, true);
       * }, {
       *     capture: true,
       * });
       */
      addEventListener(type2, listener, options) {
        const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
        const context4 = typeof listener === "function" ? void 0 : listener;
        type2 = capture ? `${type2}capture` : type2;
        listener = typeof listener === "function" ? listener : listener.handleEvent;
        this.on(type2, listener, context4);
      },
      /**
       * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`
       * seeks to be compatible with the DOM's `removeEventListener` with support for options.
       * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.
       * @memberof Container
       * @param type - The type of event the listener is bound to.
       * @param listener - The listener callback or object.
       * @param options - The original listener options. This is required to deregister a capture phase listener.
       */
      removeEventListener(type2, listener, options) {
        const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
        const context4 = typeof listener === "function" ? void 0 : listener;
        type2 = capture ? `${type2}capture` : type2;
        listener = typeof listener === "function" ? listener : listener.handleEvent;
        this.off(type2, listener, context4);
      },
      /**
       * Dispatch the event on this {@link Container} using the event's {@link EventBoundary}.
       *
       * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.
       *
       * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.
       * @memberof Container
       * @param e - The event to dispatch.
       * @returns Whether the {@link FederatedEvent.preventDefault preventDefault}() method was not invoked.
       * @example
       * // Reuse a click event!
       * button.dispatchEvent(clickEvent);
       */
      dispatchEvent(e3) {
        if (!(e3 instanceof FederatedEvent2)) {
          throw new Error("Container cannot propagate events outside of the Federated Events API");
        }
        e3.defaultPrevented = false;
        e3.path = null;
        e3.target = this;
        e3.manager.dispatchEvent(e3);
        return !e3.defaultPrevented;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/init.mjs
var init_init10 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/init.mjs"() {
    init_Extensions2();
    init_Container2();
    init_EventSystem2();
    init_FederatedEventTarget2();
    extensions3.add(EventSystem2);
    Container4.mixin(FederatedContainer2);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs
var _Spritesheet2, Spritesheet3;
var init_Spritesheet2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs"() {
    init_Rectangle2();
    init_Texture2();
    _Spritesheet2 = class {
      /**
       * @param texture - Reference to the source BaseTexture object.
       * @param {object} data - Spritesheet image data.
       */
      constructor(texture, data) {
        this.linkedSheets = [];
        this._texture = texture instanceof Texture4 ? texture : null;
        this.textureSource = texture.source;
        this.textures = {};
        this.animations = {};
        this.data = data;
        const metaResolution = parseFloat(data.meta.scale);
        if (metaResolution) {
          this.resolution = metaResolution;
          texture.source.resolution = this.resolution;
        } else {
          this.resolution = texture.source._resolution;
        }
        this._frames = this.data.frames;
        this._frameKeys = Object.keys(this._frames);
        this._batchIndex = 0;
        this._callback = null;
      }
      /**
       * Parser spritesheet from loaded data. This is done asynchronously
       * to prevent creating too many Texture within a single process.
       * @method Spritesheet#parse
       */
      parse() {
        return new Promise((resolve2) => {
          this._callback = resolve2;
          this._batchIndex = 0;
          if (this._frameKeys.length <= _Spritesheet2.BATCH_SIZE) {
            this._processFrames(0);
            this._processAnimations();
            this._parseComplete();
          } else {
            this._nextBatch();
          }
        });
      }
      /**
       * Process a batch of frames
       * @param initialFrameIndex - The index of frame to start.
       */
      _processFrames(initialFrameIndex) {
        let frameIndex = initialFrameIndex;
        const maxFrames = _Spritesheet2.BATCH_SIZE;
        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
          const i3 = this._frameKeys[frameIndex];
          const data = this._frames[i3];
          const rect = data.frame;
          if (rect) {
            let frame = null;
            let trim = null;
            const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
            const orig = new Rectangle3(
              0,
              0,
              Math.floor(sourceSize.w) / this.resolution,
              Math.floor(sourceSize.h) / this.resolution
            );
            if (data.rotated) {
              frame = new Rectangle3(
                Math.floor(rect.x) / this.resolution,
                Math.floor(rect.y) / this.resolution,
                Math.floor(rect.h) / this.resolution,
                Math.floor(rect.w) / this.resolution
              );
            } else {
              frame = new Rectangle3(
                Math.floor(rect.x) / this.resolution,
                Math.floor(rect.y) / this.resolution,
                Math.floor(rect.w) / this.resolution,
                Math.floor(rect.h) / this.resolution
              );
            }
            if (data.trimmed !== false && data.spriteSourceSize) {
              trim = new Rectangle3(
                Math.floor(data.spriteSourceSize.x) / this.resolution,
                Math.floor(data.spriteSourceSize.y) / this.resolution,
                Math.floor(rect.w) / this.resolution,
                Math.floor(rect.h) / this.resolution
              );
              trim.x /= this.textureSource.width;
              trim.y /= this.textureSource.height;
              trim.width /= this.textureSource.width;
              trim.height /= this.textureSource.height;
            }
            frame.x /= this.textureSource.width;
            frame.y /= this.textureSource.height;
            frame.width /= this.textureSource.width;
            frame.height /= this.textureSource.height;
            orig.x /= this.textureSource.width;
            orig.y /= this.textureSource.height;
            orig.width /= this.textureSource.width;
            orig.height /= this.textureSource.height;
            this.textures[i3] = new Texture4({
              source: this.textureSource,
              layout: {
                frame,
                orig,
                trim,
                rotate: data.rotated ? 2 : 0,
                defaultAnchor: data.anchor,
                defaultBorders: data.borders
              },
              label: i3.toString()
            });
          }
          frameIndex++;
        }
      }
      /** Parse animations config. */
      _processAnimations() {
        const animations = this.data.animations || {};
        for (const animName in animations) {
          this.animations[animName] = [];
          for (let i3 = 0; i3 < animations[animName].length; i3++) {
            const frameName = animations[animName][i3];
            this.animations[animName].push(this.textures[frameName]);
          }
        }
      }
      /** The parse has completed. */
      _parseComplete() {
        const callback = this._callback;
        this._callback = null;
        this._batchIndex = 0;
        callback.call(this, this.textures);
      }
      /** Begin the next batch of textures. */
      _nextBatch() {
        this._processFrames(this._batchIndex * _Spritesheet2.BATCH_SIZE);
        this._batchIndex++;
        setTimeout(() => {
          if (this._batchIndex * _Spritesheet2.BATCH_SIZE < this._frameKeys.length) {
            this._nextBatch();
          } else {
            this._processAnimations();
            this._parseComplete();
          }
        }, 0);
      }
      /**
       * Destroy Spritesheet and don't use after this.
       * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
       */
      destroy(destroyBase = false) {
        for (const i3 in this.textures) {
          this.textures[i3].destroy();
        }
        this._frames = null;
        this._frameKeys = null;
        this.data = null;
        this.textures = null;
        if (destroyBase) {
          this._texture?.destroy();
          this.textureSource.destroy();
        }
        this._texture = null;
        this.textureSource = null;
        this.linkedSheets = [];
      }
    };
    Spritesheet3 = _Spritesheet2;
    Spritesheet3.BATCH_SIZE = 1e3;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs
function getCacheableAssets2(keys, asset, ignoreMultiPack) {
  const out3 = {};
  keys.forEach((key2) => {
    out3[key2] = asset;
  });
  Object.keys(asset.textures).forEach((key2) => {
    out3[key2] = asset.textures[key2];
  });
  if (!ignoreMultiPack) {
    const basePath = path3.dirname(keys[0]);
    asset.linkedSheets.forEach((item, i3) => {
      const out22 = getCacheableAssets2([`${basePath}/${asset.data.meta.related_multi_packs[i3]}`], item, true);
      Object.assign(out3, out22);
    });
  }
  return out3;
}
var validImages2, spritesheetAsset2;
var init_spritesheetAsset2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs"() {
    init_LoaderParser2();
    init_Resolver();
    init_copySearchParams2();
    init_Extensions2();
    init_path2();
    init_Spritesheet2();
    validImages2 = ["jpg", "png", "jpeg", "avif", "webp"];
    spritesheetAsset2 = {
      extension: ExtensionType3.Asset,
      /** Handle the caching of the related Spritesheet Textures */
      cache: {
        test: (asset) => asset instanceof Spritesheet3,
        getCacheableAssets: (keys, asset) => getCacheableAssets2(keys, asset, false)
      },
      /** Resolve the the resolution of the asset. */
      resolver: {
        test: (value) => {
          const tempURL = value.split("?")[0];
          const split = tempURL.split(".");
          const extension = split.pop();
          const format3 = split.pop();
          return extension === "json" && validImages2.includes(format3);
        },
        parse: (value) => {
          const split = value.split(".");
          return {
            resolution: parseFloat(Resolver2.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
            format: split[split.length - 2],
            src: value
          };
        }
      },
      /**
       * Loader plugin that parses sprite sheets!
       * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
       * If it is, we load the spritesheets image and parse the data into Spritesheet
       * All textures in the sprite sheet are then added to the cache
       * @ignore
       */
      loader: {
        name: "spritesheetLoader",
        extension: {
          type: ExtensionType3.LoadParser,
          priority: LoaderParserPriority2.Normal
        },
        async testParse(asset, options) {
          return path3.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
        },
        async parse(asset, options, loader) {
          let basePath = path3.dirname(options.src);
          if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
            basePath += "/";
          }
          let imagePath = basePath + asset.meta.image;
          imagePath = copySearchParams2(imagePath, options.src);
          const assets = await loader.load([imagePath]);
          const texture = assets[imagePath];
          const spritesheet = new Spritesheet3(
            texture.source,
            asset
          );
          await spritesheet.parse();
          const multiPacks = asset?.meta?.related_multi_packs;
          if (Array.isArray(multiPacks)) {
            const promises = [];
            for (const item of multiPacks) {
              if (typeof item !== "string") {
                continue;
              }
              let itemUrl = basePath + item;
              if (options.data?.ignoreMultiPack) {
                continue;
              }
              itemUrl = copySearchParams2(itemUrl, options.src);
              promises.push(loader.load({
                src: itemUrl,
                data: {
                  ignoreMultiPack: true
                }
              }));
            }
            const res = await Promise.all(promises);
            spritesheet.linkedSheets = res;
            res.forEach((item) => {
              item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
            });
          }
          return spritesheet;
        },
        unload(spritesheet) {
          spritesheet.destroy(true);
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/spritesheet/init.mjs
var init_init11 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/spritesheet/init.mjs"() {
    init_Extensions2();
    init_spritesheetAsset2();
    extensions3.add(spritesheetAsset2);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/view/View.mjs
var emptyViewObserver2;
var init_View2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/view/View.mjs"() {
    emptyViewObserver2 = {
      onViewUpdate: () => {
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/updateQuadBounds.mjs
function updateQuadBounds2(bounds, anchor, texture, padding) {
  const textureSource = texture._source;
  const layout = texture.layout;
  const orig = layout.orig;
  const trim = layout.trim;
  const textureSourceWidth = textureSource.width;
  const textureSourceHeight = textureSource.height;
  const width = textureSourceWidth * orig.width;
  const height = textureSourceHeight * orig.height;
  if (trim) {
    const sourceWidth = textureSourceWidth * trim.width;
    const sourceHeight = textureSourceHeight * trim.height;
    bounds[0] = trim.x * textureSourceWidth - anchor._x * width - padding;
    bounds[1] = bounds[0] + sourceWidth;
    bounds[2] = trim.y * textureSourceHeight - anchor._y * height - padding;
    bounds[3] = bounds[2] + sourceHeight;
  } else {
    bounds[0] = -anchor._x * width - padding;
    bounds[1] = bounds[0] + width;
    bounds[2] = -anchor._y * height - padding;
    bounds[3] = bounds[2] + height;
  }
  return;
}
var init_updateQuadBounds2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/updateQuadBounds.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite/SpriteView.mjs
var SpriteView2;
var init_SpriteView2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite/SpriteView.mjs"() {
    init_ObservablePoint2();
    init_Texture2();
    init_View2();
    init_uid2();
    init_updateQuadBounds2();
    SpriteView2 = class {
      constructor(texture) {
        this.renderPipeId = "sprite";
        this.owner = emptyViewObserver2;
        this.uid = uid3("spriteView");
        this.batched = true;
        this._didUpdate = false;
        this._bounds = [0, 1, 0, 0];
        this._sourceBounds = [0, 1, 0, 0];
        this._boundsDirty = true;
        this._sourceBoundsDirty = true;
        this.roundPixels = 0;
        this.anchor = new ObservablePoint3(
          this,
          texture.layout.defaultAnchor?.x || 0,
          texture.layout.defaultAnchor?.y || 0
        );
        this.texture = texture;
      }
      set texture(value) {
        value || (value = Texture4.EMPTY);
        if (this._texture === value)
          return;
        if (this._texture) {
          this._texture.off("update", this.onUpdate, this);
        }
        value.on("update", this.onUpdate, this);
        this._texture = value;
        this.onUpdate();
      }
      get texture() {
        return this._texture;
      }
      get bounds() {
        if (this._boundsDirty) {
          this._updateBounds();
          this._boundsDirty = false;
        }
        return this._bounds;
      }
      get sourceBounds() {
        if (this._sourceBoundsDirty) {
          this._updateSourceBounds();
          this._sourceBoundsDirty = false;
        }
        return this._sourceBounds;
      }
      // passed local space..
      containsPoint(point) {
        const width = this._texture.frameWidth;
        const height = this._texture.frameHeight;
        const x1 = -width * this.anchor.x;
        let y1 = 0;
        if (point.x >= x1 && point.x < x1 + width) {
          y1 = -height * this.anchor.y;
          if (point.y >= y1 && point.y < y1 + height) {
            return true;
          }
        }
        return false;
      }
      addBounds(bounds) {
        const trim = this._texture._layout.trim;
        if (trim) {
          const sourceBounds = this.sourceBounds;
          bounds.addFrame(sourceBounds[0], sourceBounds[2], sourceBounds[1], sourceBounds[3]);
        } else {
          const _bounds = this.bounds;
          bounds.addFrame(_bounds[0], _bounds[2], _bounds[1], _bounds[3]);
        }
      }
      /**
       * @internal
       */
      onUpdate() {
        this._didUpdate = true;
        this._sourceBoundsDirty = this._boundsDirty = true;
        this.owner.onViewUpdate();
      }
      _updateBounds() {
        updateQuadBounds2(this._bounds, this.anchor, this._texture, 0);
      }
      _updateSourceBounds() {
        const anchor = this.anchor;
        const texture = this._texture;
        const textureSource = texture._source;
        const layout = texture.layout;
        const orig = layout.orig;
        const sourceBounds = this._sourceBounds;
        const width = textureSource.width * orig.width;
        const height = textureSource.height * orig.height;
        sourceBounds[1] = -anchor._x * width;
        sourceBounds[0] = sourceBounds[1] + width;
        sourceBounds[3] = -anchor._y * height;
        sourceBounds[2] = sourceBounds[3] + height;
      }
      /**
       * Destroys this sprite renderable and optionally its texture.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
       * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
       */
      destroy(options = false) {
        this.anchor = null;
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          this._texture.destroy(destroyTextureSource);
        }
        this._texture = null;
        this._bounds = null;
        this._sourceBounds = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite/Sprite.mjs
var Sprite3;
var init_Sprite2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite/Sprite.mjs"() {
    init_Cache2();
    init_Texture2();
    init_Container2();
    init_SpriteView2();
    Sprite3 = class _Sprite extends Container4 {
      static from(id) {
        if (typeof id === "string") {
          return new _Sprite(Cache2.get(id));
        }
        return new _Sprite(id);
      }
      constructor(options = Texture4.EMPTY) {
        if (options instanceof Texture4) {
          options = { texture: options };
        }
        const { texture, ...rest } = options;
        super({
          view: new SpriteView2(texture ?? Texture4.EMPTY),
          label: "Sprite",
          ...rest
        });
        this.allowChildren = false;
      }
      get anchor() {
        return this.view.anchor;
      }
      set anchor(value) {
        this.view.anchor.x = value.x;
        this.view.anchor.y = value.y;
      }
      get texture() {
        return this.view.texture;
      }
      set texture(value) {
        this.view.texture = value;
      }
      get roundPixels() {
        return !!this.view.roundPixels;
      }
      set roundPixels(value) {
        this.view.roundPixels = value ? 1 : 0;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs
function addMaskBounds2(mask2, bounds, skipUpdateTransform) {
  const boundsToMask = tempBounds7;
  mask2.measurable = true;
  getGlobalBounds2(mask2, skipUpdateTransform, boundsToMask);
  bounds.addBoundsMask(boundsToMask);
  mask2.measurable = false;
}
var tempBounds7;
var init_addMaskBounds2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs"() {
    init_Bounds2();
    init_getGlobalBounds2();
    tempBounds7 = new Bounds2();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs
function addMaskLocalBounds2(mask2, bounds, localRoot) {
  const boundsToMask = new Bounds2();
  mask2.measurable = true;
  const relativeMask = getMatrixRelativeToParent2(mask2, localRoot, new Matrix3());
  getLocalBounds2(mask2, boundsToMask, relativeMask);
  mask2.measurable = false;
  bounds.addBoundsMask(boundsToMask);
}
function getMatrixRelativeToParent2(target, root, matrix) {
  if (!target) {
    warn2("Item is not inside the root container");
    return matrix;
  }
  if (target !== root) {
    getMatrixRelativeToParent2(target.parent, root, matrix);
    if (target.didChange) {
      updateLocalTransform2(target.localTransform, target);
    }
    matrix.append(target.localTransform);
  }
  return matrix;
}
var init_addMaskLocalBounds2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs"() {
    init_Matrix2();
    init_Bounds2();
    init_getLocalBounds2();
    init_updateLocalTransform2();
    init_warn2();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs
var AlphaMask2;
var init_AlphaMask2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs"() {
    init_Extensions2();
    init_Sprite2();
    init_addMaskBounds2();
    init_addMaskLocalBounds2();
    AlphaMask2 = class {
      constructor(options) {
        this.priority = 0;
        this.pipe = "alphaMask";
        if (options?.mask) {
          this.init(options.mask);
        }
      }
      init(mask2) {
        this.mask = mask2;
        this.renderMaskToTexture = !(mask2 instanceof Sprite3);
        this.mask.renderable = this.renderMaskToTexture;
        this.mask.includeInBuild = !this.renderMaskToTexture;
        this.mask.measurable = false;
      }
      reset() {
        this.mask.measurable = true;
        this.mask = null;
      }
      addBounds(bounds, skipUpdateTransform) {
        addMaskBounds2(this.mask, bounds, skipUpdateTransform);
      }
      addLocalBounds(bounds, localRoot) {
        addMaskLocalBounds2(this.mask, bounds, localRoot);
      }
      containsPoint(point, hitTestFn) {
        const mask2 = this.mask;
        return hitTestFn(mask2, point);
      }
      destroy() {
        this.reset();
      }
      static test(mask2) {
        return mask2 instanceof Sprite3;
      }
    };
    AlphaMask2.extension = ExtensionType3.MaskEffect;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs
var ColorMask2;
var init_ColorMask2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs"() {
    init_Extensions2();
    ColorMask2 = class {
      constructor(options) {
        this.priority = 0;
        this.pipe = "colorMask";
        if (options?.mask) {
          this.init(options.mask);
        }
      }
      init(mask2) {
        this.mask = mask2;
      }
      destroy() {
      }
      static test(mask2) {
        return typeof mask2 === "number";
      }
    };
    ColorMask2.extension = ExtensionType3.MaskEffect;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs
var StencilMask2;
var init_StencilMask2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs"() {
    init_Extensions2();
    init_Container2();
    init_addMaskBounds2();
    init_addMaskLocalBounds2();
    StencilMask2 = class {
      constructor(options) {
        this.priority = 0;
        this.pipe = "stencilMask";
        if (options?.mask) {
          this.init(options.mask);
        }
      }
      init(mask2) {
        this.mask = mask2;
        this.mask.includeInBuild = false;
        this.mask.measurable = false;
      }
      reset() {
        this.mask.measurable = true;
        this.mask.includeInBuild = true;
        this.mask = null;
      }
      addBounds(bounds, skipUpdateTransform) {
        addMaskBounds2(this.mask, bounds, skipUpdateTransform);
      }
      addLocalBounds(bounds, localRoot) {
        addMaskLocalBounds2(this.mask, bounds, localRoot);
      }
      containsPoint(point, hitTestFn) {
        const mask2 = this.mask;
        return hitTestFn(mask2, point);
      }
      destroy() {
        this.reset();
      }
      static test(mask2) {
        return mask2 instanceof Container4;
      }
    };
    StencilMask2.extension = ExtensionType3.MaskEffect;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs
var BufferImageSource2;
var init_BufferImageSource2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs"() {
    init_Extensions2();
    init_TextureSource2();
    BufferImageSource2 = class extends TextureSource2 {
      constructor(options) {
        const buffer2 = options.resource || new Float32Array(options.width * options.height * 4);
        let format3 = options.format;
        if (!format3) {
          if (buffer2 instanceof Float32Array) {
            format3 = "rgba32float";
          } else if (buffer2 instanceof Int32Array) {
            format3 = "rgba32uint";
          } else if (buffer2 instanceof Uint32Array) {
            format3 = "rgba32uint";
          } else if (buffer2 instanceof Int16Array) {
            format3 = "rgba16uint";
          } else if (buffer2 instanceof Uint16Array) {
            format3 = "rgba16uint";
          } else if (buffer2 instanceof Int8Array) {
            format3 = "bgra8unorm";
          } else {
            format3 = "bgra8unorm";
          }
        }
        super({
          ...options,
          format: format3
        });
        this.uploadMethodId = "buffer";
      }
      static test(resource) {
        return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;
      }
    };
    BufferImageSource2.extension = ExtensionType3.TextureSource;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs
var CanvasSource2;
var init_CanvasSource2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs"() {
    init_Extensions2();
    init_adapter2();
    init_TextureSource2();
    CanvasSource2 = class extends TextureSource2 {
      constructor(options) {
        if (!options.resource) {
          options.resource = DOMAdapter.get().createCanvas();
        }
        if (!options.width) {
          options.width = options.resource.width;
          if (!options.autoDensity) {
            options.width /= options.resolution;
          }
        }
        if (!options.height) {
          options.height = options.resource.height;
          if (!options.autoDensity) {
            options.height /= options.resolution;
          }
        }
        options.alphaMode ?? (options.alphaMode = "premultiply-alpha-on-upload");
        super(options);
        this.uploadMethodId = "image";
        this.autoDensity = options.autoDensity;
        const canvas3 = options.resource;
        if (this.pixelWidth !== canvas3.width || this.pixelWidth !== canvas3.height) {
          this.resizeCanvas();
        }
      }
      resizeCanvas() {
        if (this.autoDensity) {
          this.resource.style.width = `${this.width}px`;
          this.resource.style.height = `${this.height}px`;
        }
        this.resource.width = this.pixelWidth;
        this.resource.height = this.pixelHeight;
      }
      resize(width = this.width, height = this.height, resolution = this._resolution) {
        super.resize(width, height, resolution);
        this.resizeCanvas();
      }
      static test(resource) {
        return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;
      }
    };
    CanvasSource2.extension = ExtensionType3.TextureSource;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/init.mjs
var init_init12 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/init.mjs"() {
    init_Extensions2();
    init_AlphaMask2();
    init_ColorMask2();
    init_StencilMask2();
    init_BufferImageSource2();
    init_CanvasSource2();
    init_ImageSource2();
    init_VideoSource2();
    extensions3.add(AlphaMask2, ColorMask2, StencilMask2, VideoSource2, ImageSource2, CanvasSource2, BufferImageSource2);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/all.mjs
var init_all2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/all.mjs"() {
    init_init8();
    init_init9();
    init_init10();
    init_init11();
    init_init12();
    init_init7();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensurePrecision.mjs
function ensurePrecision2(src, options, isFragment) {
  const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;
  if (src.substring(0, 9) !== "precision") {
    let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;
    if (precision === "highp" && maxSupportedPrecision !== "highp") {
      precision = "mediump";
    }
    if (src.substring(0, 8) !== "#version") {
      return `precision ${precision} float;
${src}`;
    }
    const firstLineBreak = src.indexOf("\n");
    return `${src.substring(0, firstLineBreak + 1)}precision ${precision} float;
${src.substring(firstLineBreak + 1)}`;
  } else if (maxSupportedPrecision !== "highp" && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}
var init_ensurePrecision2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensurePrecision.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs
function getTestContext3() {
  if (context3 === unknownContext3 || context3?.isContextLost()) {
    const canvas3 = DOMAdapter.get().createCanvas();
    context3 = canvas3.getContext("webgl2", {});
  }
  return context3;
}
var unknownContext3, context3;
var init_getTestContext2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs"() {
    init_adapter2();
    unknownContext3 = {};
    context3 = unknownContext3;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs
function getMaxFragmentPrecision3() {
  if (!maxFragmentPrecision3) {
    maxFragmentPrecision3 = "mediump";
    const gl = getTestContext3();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision3 = shaderFragment.precision ? "highp" : "mediump";
      }
    }
  }
  return maxFragmentPrecision3;
}
var maxFragmentPrecision3;
var init_getMaxFragmentPrecision2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs"() {
    init_getTestContext2();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/setProgramName.mjs
function setProgramName2(src, { name = `pixi-program` }, isFragment = true) {
  name = name.replace(/\s+/g, "-");
  name += isFragment ? "-fragment" : "-vertex";
  const nameCache2 = isFragment ? fragmentNameCache2 : VertexNameCache2;
  if (nameCache2[name]) {
    nameCache2[name]++;
    name += `-${nameCache2[name]}`;
  } else {
    nameCache2[name] = 1;
  }
  if (src.indexOf("#define SHADER_NAME") !== -1)
    return src;
  const shaderName = `#define SHADER_NAME ${name}`;
  if (src.substring(0, 8) !== "#version") {
    return `${shaderName}
${src}`;
  }
  const firstLineBreak = src.indexOf("\n");
  return `${src.substring(0, firstLineBreak + 1)}${shaderName}
${src.substring(firstLineBreak + 1)}`;
}
var fragmentNameCache2, VertexNameCache2;
var init_setProgramName2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/setProgramName.mjs"() {
    fragmentNameCache2 = {};
    VertexNameCache2 = {};
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/setProgramVersion.mjs
function setProgramVersion2(src, { version = "300 es" }) {
  if (src.substring(0, 8) === "#version")
    return src;
  return `#version ${version}
${src}`;
}
var init_setProgramVersion2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/setProgramVersion.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs
var processes2, _GlProgram2, GlProgram2;
var init_GlProgram2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs"() {
    init_ensurePrecision2();
    init_getMaxFragmentPrecision2();
    init_setProgramName2();
    init_setProgramVersion2();
    processes2 = {
      ensurePrecision: ensurePrecision2,
      setProgramName: setProgramName2,
      setProgramVersion: setProgramVersion2
    };
    _GlProgram2 = class {
      constructor(options) {
        options = { ..._GlProgram2.defaultOptions, ...options };
        const preprocessorOptions = {
          ensurePrecision: {
            requestedFragmentPrecision: options.preferredFragmentPrecision,
            requestedVertexPrecision: options.preferredVertexPrecision,
            maxSupportedVertexPrecision: "highp",
            maxSupportedFragmentPrecision: getMaxFragmentPrecision3()
          },
          setProgramName: {
            name: options.name
          },
          setProgramVersion: {
            version: "300 es"
          }
        };
        let fragment3 = options.fragment;
        let vertex3 = options.vertex;
        Object.keys(processes2).forEach((processKey) => {
          const processOptions = preprocessorOptions[processKey] ?? {};
          fragment3 = processes2[processKey](fragment3, processOptions, true);
          vertex3 = processes2[processKey](vertex3, processOptions, false);
        });
        this.fragment = fragment3;
        this.vertex = vertex3;
        this.key = `${this.vertex}:${this.fragment}`;
      }
      destroy() {
        this.fragment = null;
        this.vertex = null;
        this.attributeData = null;
        this.uniformData = null;
        this.uniformBlockData = null;
        this.transformFeedbackVaryings = null;
      }
      static from(options) {
        const key2 = `${options.vertex}:${options.fragment}`;
        if (!_GlProgram2.programCached[key2]) {
          _GlProgram2.programCached[key2] = new _GlProgram2(options);
        }
        return _GlProgram2.programCached[key2];
      }
    };
    GlProgram2 = _GlProgram2;
    GlProgram2.defaultOptions = {
      preferredVertexPrecision: "highp",
      preferredFragmentPrecision: "mediump"
    };
    GlProgram2.programCached = /* @__PURE__ */ Object.create(null);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/extractStructAndGroups.mjs
function extractStructAndGroups2(wgsl) {
  const linePattern = /(?<!\/\/.*)@(group|binding)\(\d+\)[^;]+;/g;
  const groupPattern = /@group\((\d+)\)/;
  const bindingPattern = /@binding\((\d+)\)/;
  const namePattern = /var(<[^>]+>)? (\w+)/;
  const typePattern = /:\s*(\w+)/;
  const structPattern = /struct\s+(\w+)\s*{([^}]+)}/g;
  const structMemberPattern = /(\w+)\s*:\s*([\w\<\>]+)/g;
  const structName = /struct\s+(\w+)/;
  const groups = wgsl.match(linePattern)?.map((item) => ({
    group: parseInt(item.match(groupPattern)[1], 10),
    binding: parseInt(item.match(bindingPattern)[1], 10),
    name: item.match(namePattern)[2],
    isUniform: item.match(namePattern)[1] === "<uniform>",
    type: item.match(typePattern)[1]
  }));
  if (!groups) {
    return {
      groups: [],
      structs: []
    };
  }
  const structs = wgsl.match(structPattern)?.map((struct) => {
    const name = struct.match(structName)[1];
    const members = struct.match(structMemberPattern).reduce((acc, member) => {
      const [name2, type2] = member.split(":");
      acc[name2.trim()] = type2.trim();
      return acc;
    }, {});
    if (!members) {
      return null;
    }
    return { name, members };
  }).filter(({ name }) => groups.some((group) => group.type === name)) ?? [];
  return {
    groups,
    structs
  };
}
var init_extractStructAndGroups2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/extractStructAndGroups.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs
var ShaderStage2;
var init_const13 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs"() {
    ShaderStage2 = /* @__PURE__ */ ((ShaderStage22) => {
      ShaderStage22[ShaderStage22["VERTEX"] = 1] = "VERTEX";
      ShaderStage22[ShaderStage22["FRAGMENT"] = 2] = "FRAGMENT";
      ShaderStage22[ShaderStage22["COMPUTE"] = 4] = "COMPUTE";
      return ShaderStage22;
    })(ShaderStage2 || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/generateGpuLayoutGroups.mjs
function generateGpuLayoutGroups2({ groups }) {
  const layout = [];
  for (let i3 = 0; i3 < groups.length; i3++) {
    const group = groups[i3];
    if (!layout[group.group]) {
      layout[group.group] = [];
    }
    if (group.isUniform) {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage2.VERTEX | ShaderStage2.FRAGMENT,
        buffer: {
          type: "uniform"
        }
      });
    } else if (group.type === "sampler") {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage2.FRAGMENT,
        sampler: {
          type: "filtering"
        }
      });
    } else if (group.type === "texture_2d") {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage2.FRAGMENT,
        texture: {
          sampleType: "float",
          viewDimension: "2d",
          multisampled: false
        }
      });
    }
  }
  return layout;
}
var init_generateGpuLayoutGroups2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/generateGpuLayoutGroups.mjs"() {
    init_const13();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/generateLayoutHash.mjs
function generateLayoutHash2({ groups }) {
  const layout = [];
  for (let i3 = 0; i3 < groups.length; i3++) {
    const group = groups[i3];
    if (!layout[group.group]) {
      layout[group.group] = {};
    }
    layout[group.group][group.name] = group.binding;
  }
  return layout;
}
var init_generateLayoutHash2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/generateLayoutHash.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/removeStructAndGroupDuplicates.mjs
function removeStructAndGroupDuplicates2(vertexStructsAndGroups, fragmentStructsAndGroups) {
  const structNameSet = /* @__PURE__ */ new Set();
  const dupeGroupKeySet = /* @__PURE__ */ new Set();
  const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {
    if (structNameSet.has(struct.name)) {
      return false;
    }
    structNameSet.add(struct.name);
    return true;
  });
  const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {
    const key2 = `${group.name}-${group.binding}`;
    if (dupeGroupKeySet.has(key2)) {
      return false;
    }
    dupeGroupKeySet.add(key2);
    return true;
  });
  return { structs, groups };
}
var init_removeStructAndGroupDuplicates2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/removeStructAndGroupDuplicates.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs
var _GpuProgram2, GpuProgram2;
var init_GpuProgram2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs"() {
    init_extractStructAndGroups2();
    init_generateGpuLayoutGroups2();
    init_generateLayoutHash2();
    init_removeStructAndGroupDuplicates2();
    _GpuProgram2 = class {
      constructor({ fragment: fragment3, vertex: vertex3, layout, gpuLayout, name }) {
        this._layoutKey = 0;
        this.name = name;
        this.fragment = fragment3;
        this.vertex = vertex3;
        if (fragment3.source === vertex3.source) {
          const structsAndGroups = extractStructAndGroups2(fragment3.source);
          this.structsAndGroups = structsAndGroups;
        } else {
          const vertexStructsAndGroups = extractStructAndGroups2(vertex3.source);
          const fragmentStructsAndGroups = extractStructAndGroups2(fragment3.source);
          this.structsAndGroups = removeStructAndGroupDuplicates2(vertexStructsAndGroups, fragmentStructsAndGroups);
        }
        this.layout = layout ?? generateLayoutHash2(this.structsAndGroups);
        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups2(this.structsAndGroups);
      }
      destroy() {
        this._gpuLayout = null;
        this.gpuLayout = null;
        this.layout = null;
        this.structsAndGroups = null;
        this.fragment = null;
        this.vertex = null;
      }
      static from(options) {
        const key2 = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;
        if (!_GpuProgram2.programCached[key2]) {
          _GpuProgram2.programCached[key2] = new _GpuProgram2(options);
        }
        return _GpuProgram2.programCached[key2];
      }
    };
    GpuProgram2 = _GpuProgram2;
    GpuProgram2.programCached = /* @__PURE__ */ Object.create(null);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/defaultUniformValue.mjs
function defaultUniformValue2(type2, size3) {
  switch (type2) {
    case "f32":
      return 0;
    case "vec2<f32>":
      return new Float32Array(2 * size3);
    case "vec3<f32>":
      return new Float32Array(3 * size3);
    case "vec4<f32>":
      return new Float32Array(4 * size3);
    case "mat2x2<f32>":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3x3<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4x4<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var init_defaultUniformValue2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/defaultUniformValue.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs
var _UniformGroup2, UniformGroup3;
var init_UniformGroup2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"() {
    init_uid2();
    init_defaultUniformValue2();
    _UniformGroup2 = class {
      constructor(uniformStructures, options) {
        this.touched = 0;
        this.uid = uid3("uniform");
        this.resourceType = "uniformGroup";
        this.resourceId = this.uid;
        this.isUniformGroup = true;
        this.dirtyId = 0;
        options = { ..._UniformGroup2.DEFAULT, ...options };
        this.uniformStructures = uniformStructures;
        const uniforms = {};
        for (const i3 in uniformStructures) {
          const uniformData = uniformStructures[i3];
          uniformData.name = i3;
          uniformData.size = uniformData.size ?? 1;
          uniformData.value ?? (uniformData.value = defaultUniformValue2(uniformData.type, uniformData.size));
          uniforms[i3] = uniformData.value;
        }
        this.uniforms = uniforms;
        this.dirtyId = 1;
        this.ubo = options.ubo;
        this.isStatic = options.isStatic;
        this.signature = Object.keys(uniforms).map(
          (i3) => `${i3}-${uniformStructures[i3].type}`
        ).join("-");
      }
      update() {
        this.dirtyId++;
      }
    };
    UniformGroup3 = _UniformGroup2;
    UniformGroup3.DEFAULT = {
      ubo: false,
      isStatic: false
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs
var BindGroup2;
var init_BindGroup2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs"() {
    BindGroup2 = class {
      constructor(resources) {
        this.resources = /* @__PURE__ */ Object.create(null);
        this._dirty = true;
        let index = 0;
        for (const i3 in resources) {
          const resource = resources[i3];
          this.setResource(resource, index++);
        }
        this.updateKey();
      }
      update() {
        this.updateKey();
      }
      updateKey() {
        if (!this._dirty)
          return;
        this._dirty = false;
        const keyParts = [];
        let index = 0;
        for (const i3 in this.resources) {
          keyParts[index++] = this.resources[i3].resourceId;
        }
        this.key = keyParts.join("|");
      }
      setResource(resource, index) {
        const currentResource = this.resources[index];
        if (resource === currentResource)
          return;
        if (currentResource) {
          resource.off?.("change", this.onResourceChange, this);
        }
        resource.on?.("change", this.onResourceChange, this);
        this.resources[index] = resource;
        this._dirty = true;
      }
      getResource(index) {
        return this.resources[index];
      }
      touch(tick) {
        const resources = this.resources;
        for (const i3 in resources) {
          resources[i3].touched = tick;
        }
      }
      destroy() {
        const resources = this.resources;
        for (const i3 in resources) {
          const resource = resources[i3];
          resource.off?.("change", this.onResourceChange, this);
        }
        this.resources = null;
      }
      onResourceChange() {
        this._dirty = true;
        this.update();
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/types.mjs
var RendererType2;
var init_types2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/types.mjs"() {
    RendererType2 = /* @__PURE__ */ ((RendererType22) => {
      RendererType22[RendererType22["WEBGL"] = 1] = "WEBGL";
      RendererType22[RendererType22["WEBGPU"] = 2] = "WEBGPU";
      return RendererType22;
    })(RendererType2 || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs
var Shader3;
var init_Shader2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs"() {
    init_eventemitter3();
    init_BindGroup2();
    init_types2();
    init_UniformGroup2();
    Shader3 = class extends eventemitter3_default {
      constructor({ gpuProgram, glProgram, groups, resources, groupMap, compatibleRenderers }) {
        super();
        this.uniformBindMap = /* @__PURE__ */ Object.create(null);
        this.gpuProgram = gpuProgram;
        this.glProgram = glProgram;
        if (compatibleRenderers === void 0) {
          compatibleRenderers = 0;
          if (gpuProgram)
            compatibleRenderers |= RendererType2.WEBGPU;
          if (glProgram)
            compatibleRenderers |= RendererType2.WEBGL;
        }
        this.compatibleRenderers = compatibleRenderers;
        const nameHash = {};
        if (resources && groups) {
          throw new Error("[Shader] Cannot have both resources and groups");
        } else if (!resources && !groups) {
          throw new Error("[Shader] Must provide either resources or groups descriptor");
        } else if (!gpuProgram && groups && !groupMap) {
          throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
        } else if (!gpuProgram && groups && groupMap) {
          for (const i3 in groupMap) {
            for (const j3 in groupMap[i3]) {
              const uniformName = groupMap[i3][j3];
              nameHash[uniformName] = {
                group: i3,
                binding: j3,
                name: uniformName
              };
            }
          }
        } else if (gpuProgram && groups && !groupMap) {
          const groupData = gpuProgram.structsAndGroups.groups;
          groupMap = {};
          groupData.forEach((data) => {
            groupMap[data.group] = groupMap[data.group] || {};
            groupMap[data.group][data.binding] = data.name;
            nameHash[data.name] = data;
          });
        } else if (resources) {
          if (!gpuProgram) {
            groupMap = {};
            groups = {
              99: new BindGroup2()
            };
            let bindTick = 0;
            for (const i3 in resources) {
              nameHash[i3] = { group: 99, binding: bindTick, name: i3 };
              groupMap[99] = groupMap[99] || {};
              groupMap[99][bindTick] = i3;
              bindTick++;
            }
          } else {
            const groupData = gpuProgram.structsAndGroups.groups;
            groupMap = {};
            groupData.forEach((data) => {
              groupMap[data.group] = groupMap[data.group] || {};
              groupMap[data.group][data.binding] = data.name;
              nameHash[data.name] = data;
            });
          }
          groups = {};
          for (const i3 in resources) {
            const name = i3;
            let value = resources[i3];
            if (!value.source && !value.resourceType) {
              value = new UniformGroup3(value);
            }
            const data = nameHash[name];
            if (data) {
              groups[data.group] = groups[data.group] || new BindGroup2();
              groups[data.group].setResource(value, data.binding);
            }
          }
        }
        this.groups = groups;
        this.uniformBindMap = groupMap;
        this.resources = this._buildResourceAccessor(groups, nameHash);
      }
      addResource(name, groupIndex, bindIndex) {
        var _a2, _b;
        (_a2 = this.uniformBindMap)[groupIndex] || (_a2[groupIndex] = {});
        (_b = this.uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);
      }
      _buildResourceAccessor(groups, nameHash) {
        const uniformsOut = {};
        for (const i3 in nameHash) {
          const data = nameHash[i3];
          Object.defineProperty(uniformsOut, data.name, {
            get() {
              return groups[data.group].getResource(data.binding);
            },
            set(value) {
              groups[data.group].setResource(value, data.binding);
            }
          });
        }
        return uniformsOut;
      }
      destroy(destroyProgram = false) {
        this.emit("destroy", this);
        if (destroyProgram) {
          this.gpuProgram?.destroy();
          this.glProgram?.destroy();
        }
        this.gpuProgram = null;
        this.glProgram = null;
        this.groups = null;
        this.removeAllListeners();
        this.uniformBindMap = null;
        this.resources = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs
var blendModeIds2, BLEND5, OFFSET5, CULLING5, DEPTH_TEST5, WINDING5, DEPTH_MASK5, State3;
var init_State2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs"() {
    blendModeIds2 = {
      normal: 0,
      additive: 1,
      multiply: 2,
      screen: 3,
      overlay: 4,
      erase: 5
    };
    BLEND5 = 0;
    OFFSET5 = 1;
    CULLING5 = 2;
    DEPTH_TEST5 = 3;
    WINDING5 = 4;
    DEPTH_MASK5 = 5;
    State3 = class _State {
      constructor() {
        this.data = 0;
        this.blendMode = "normal";
        this.polygonOffset = 0;
        this.blend = true;
        this.depthMask = true;
      }
      /**
       * Activates blending of the computed fragment color values.
       * @default true
       */
      get blend() {
        return !!(this.data & 1 << BLEND5);
      }
      set blend(value) {
        if (!!(this.data & 1 << BLEND5) !== value) {
          this.data ^= 1 << BLEND5;
        }
      }
      /**
       * Activates adding an offset to depth values of polygon's fragments
       * @default false
       */
      get offsets() {
        return !!(this.data & 1 << OFFSET5);
      }
      set offsets(value) {
        if (!!(this.data & 1 << OFFSET5) !== value) {
          this.data ^= 1 << OFFSET5;
        }
      }
      set cullMode(value) {
        if (value === "none") {
          this.culling = false;
          return;
        }
        this.culling = true;
        this.clockwiseFrontFace = value === "front";
      }
      get cullMode() {
        if (!this.culling) {
          return "none";
        }
        return this.clockwiseFrontFace ? "front" : "back";
      }
      /**
       * Activates culling of polygons.
       * @default false
       */
      get culling() {
        return !!(this.data & 1 << CULLING5);
      }
      set culling(value) {
        if (!!(this.data & 1 << CULLING5) !== value) {
          this.data ^= 1 << CULLING5;
        }
      }
      /**
       * Activates depth comparisons and updates to the depth buffer.
       * @default false
       */
      get depthTest() {
        return !!(this.data & 1 << DEPTH_TEST5);
      }
      set depthTest(value) {
        if (!!(this.data & 1 << DEPTH_TEST5) !== value) {
          this.data ^= 1 << DEPTH_TEST5;
        }
      }
      /**
       * Enables or disables writing to the depth buffer.
       * @default true
       */
      get depthMask() {
        return !!(this.data & 1 << DEPTH_MASK5);
      }
      set depthMask(value) {
        if (!!(this.data & 1 << DEPTH_MASK5) !== value) {
          this.data ^= 1 << DEPTH_MASK5;
        }
      }
      /**
       * Specifies whether or not front or back-facing polygons can be culled.
       * @default false
       */
      get clockwiseFrontFace() {
        return !!(this.data & 1 << WINDING5);
      }
      set clockwiseFrontFace(value) {
        if (!!(this.data & 1 << WINDING5) !== value) {
          this.data ^= 1 << WINDING5;
        }
      }
      /**
       * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.
       * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
       * @default 'normal'
       */
      get blendMode() {
        return this._blendMode;
      }
      set blendMode(value) {
        this.blend = value !== "none";
        this._blendMode = value;
        this._blendModeId = blendModeIds2[value] || 0;
      }
      /**
       * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
       * @default 0
       */
      get polygonOffset() {
        return this._polygonOffset;
      }
      set polygonOffset(value) {
        this.offsets = !!value;
        this._polygonOffset = value;
      }
      toString() {
        return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
      }
      static for2d() {
        const state = new _State();
        state.depthTest = false;
        state.blend = true;
        return state;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/Filter.mjs
var _Filter3, Filter3;
var init_Filter2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/Filter.mjs"() {
    init_Shader2();
    init_State2();
    _Filter3 = class extends Shader3 {
      constructor(options) {
        options = { ..._Filter3.defaultOptions, ...options };
        super(options);
        this.enabled = true;
        this._state = State3.for2d();
        this.padding = options.padding;
        if (typeof options.antialias === "boolean") {
          this.antialias = options.antialias ? "on" : "off";
        } else {
          this.antialias = options.antialias ?? "inherit";
        }
        this.resolution = options.resolution;
        this.blendRequired = options.blendRequired;
        this.addResource("filterUniforms", 0, 0);
        this.addResource("uSampler", 0, 1);
      }
      /**
       * Applies the filter
       * @param filterManager - The renderer to retrieve the filter from
       * @param input - The input render target.
       * @param output - The target to output to.
       * @param clearMode - Should the output be cleared before rendering to it
       */
      apply(filterManager, input, output, clearMode) {
        filterManager.applyFilter(this, input, output, clearMode);
      }
      /**
       * Sets the blend mode of the filter.
       * @default "normal"
       */
      get blendMode() {
        return this._state.blendMode;
      }
      set blendMode(value) {
        this._state.blendMode = value;
      }
    };
    Filter3 = _Filter3;
    Filter3.defaultOptions = {
      blendMode: "normal",
      resolution: 1,
      padding: 0,
      antialias: "inherit",
      blendRequired: false
    };
  }
});

// ../../node_modules/.pnpm/@aeolun+yoga-layout-prebuilt@1.10.0/node_modules/@aeolun/yoga-layout-prebuilt/yoga-layout/dist/YGEnums.js
var require_YGEnums = __commonJS({
  "../../node_modules/.pnpm/@aeolun+yoga-layout-prebuilt@1.10.0/node_modules/@aeolun/yoga-layout-prebuilt/yoga-layout/dist/YGEnums.js"(exports2, module2) {
    "use strict";
    var CONSTANTS = {
      ALIGN_COUNT: 8,
      ALIGN_AUTO: 0,
      ALIGN_FLEX_START: 1,
      ALIGN_CENTER: 2,
      ALIGN_FLEX_END: 3,
      ALIGN_STRETCH: 4,
      ALIGN_BASELINE: 5,
      ALIGN_SPACE_BETWEEN: 6,
      ALIGN_SPACE_AROUND: 7,
      DIMENSION_COUNT: 2,
      DIMENSION_WIDTH: 0,
      DIMENSION_HEIGHT: 1,
      DIRECTION_COUNT: 3,
      DIRECTION_INHERIT: 0,
      DIRECTION_LTR: 1,
      DIRECTION_RTL: 2,
      DISPLAY_COUNT: 2,
      DISPLAY_FLEX: 0,
      DISPLAY_NONE: 1,
      EDGE_COUNT: 9,
      EDGE_LEFT: 0,
      EDGE_TOP: 1,
      EDGE_RIGHT: 2,
      EDGE_BOTTOM: 3,
      EDGE_START: 4,
      EDGE_END: 5,
      EDGE_HORIZONTAL: 6,
      EDGE_VERTICAL: 7,
      EDGE_ALL: 8,
      EXPERIMENTAL_FEATURE_COUNT: 1,
      EXPERIMENTAL_FEATURE_WEB_FLEX_BASIS: 0,
      FLEX_DIRECTION_COUNT: 4,
      FLEX_DIRECTION_COLUMN: 0,
      FLEX_DIRECTION_COLUMN_REVERSE: 1,
      FLEX_DIRECTION_ROW: 2,
      FLEX_DIRECTION_ROW_REVERSE: 3,
      JUSTIFY_COUNT: 6,
      JUSTIFY_FLEX_START: 0,
      JUSTIFY_CENTER: 1,
      JUSTIFY_FLEX_END: 2,
      JUSTIFY_SPACE_BETWEEN: 3,
      JUSTIFY_SPACE_AROUND: 4,
      JUSTIFY_SPACE_EVENLY: 5,
      LOG_LEVEL_COUNT: 6,
      LOG_LEVEL_ERROR: 0,
      LOG_LEVEL_WARN: 1,
      LOG_LEVEL_INFO: 2,
      LOG_LEVEL_DEBUG: 3,
      LOG_LEVEL_VERBOSE: 4,
      LOG_LEVEL_FATAL: 5,
      MEASURE_MODE_COUNT: 3,
      MEASURE_MODE_UNDEFINED: 0,
      MEASURE_MODE_EXACTLY: 1,
      MEASURE_MODE_AT_MOST: 2,
      NODE_TYPE_COUNT: 2,
      NODE_TYPE_DEFAULT: 0,
      NODE_TYPE_TEXT: 1,
      OVERFLOW_COUNT: 3,
      OVERFLOW_VISIBLE: 0,
      OVERFLOW_HIDDEN: 1,
      OVERFLOW_SCROLL: 2,
      POSITION_TYPE_COUNT: 2,
      POSITION_TYPE_RELATIVE: 0,
      POSITION_TYPE_ABSOLUTE: 1,
      PRINT_OPTIONS_COUNT: 3,
      PRINT_OPTIONS_LAYOUT: 1,
      PRINT_OPTIONS_STYLE: 2,
      PRINT_OPTIONS_CHILDREN: 4,
      UNIT_COUNT: 4,
      UNIT_UNDEFINED: 0,
      UNIT_POINT: 1,
      UNIT_PERCENT: 2,
      UNIT_AUTO: 3,
      WRAP_COUNT: 3,
      WRAP_NO_WRAP: 0,
      WRAP_WRAP: 1,
      WRAP_WRAP_REVERSE: 2
    };
    module2.exports = CONSTANTS;
  }
});

// ../../node_modules/.pnpm/@aeolun+yoga-layout-prebuilt@1.10.0/node_modules/@aeolun/yoga-layout-prebuilt/yoga-layout/dist/entry-common.js
var require_entry_common = __commonJS({
  "../../node_modules/.pnpm/@aeolun+yoga-layout-prebuilt@1.10.0/node_modules/@aeolun/yoga-layout-prebuilt/yoga-layout/dist/entry-common.js"(exports2, module2) {
    "use strict";
    var _extends = Object.assign || function(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source3 = arguments[i3];
        for (var key2 in source3) {
          if (Object.prototype.hasOwnProperty.call(source3, key2)) {
            target[key2] = source3[key2];
          }
        }
      }
      return target;
    };
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _defineProperty(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var CONSTANTS = require_YGEnums();
    var Layout = function() {
      function Layout2(left, right, top, bottom, width, height) {
        _classCallCheck(this, Layout2);
        this.left = left;
        this.right = right;
        this.top = top;
        this.bottom = bottom;
        this.width = width;
        this.height = height;
      }
      _createClass(Layout2, [{
        key: "fromJS",
        value: function fromJS(expose) {
          expose(this.left, this.right, this.top, this.bottom, this.width, this.height);
        }
      }, {
        key: "toString",
        value: function toString() {
          return "<Layout#" + this.left + ":" + this.right + ";" + this.top + ":" + this.bottom + ";" + this.width + ":" + this.height + ">";
        }
      }]);
      return Layout2;
    }();
    var Size = function() {
      _createClass(Size2, null, [{
        key: "fromJS",
        value: function fromJS(_ref) {
          var width = _ref.width, height = _ref.height;
          return new Size2(width, height);
        }
      }]);
      function Size2(width, height) {
        _classCallCheck(this, Size2);
        this.width = width;
        this.height = height;
      }
      _createClass(Size2, [{
        key: "fromJS",
        value: function fromJS(expose) {
          expose(this.width, this.height);
        }
      }, {
        key: "toString",
        value: function toString() {
          return "<Size#" + this.width + "x" + this.height + ">";
        }
      }]);
      return Size2;
    }();
    var Value = function() {
      function Value2(unit, value) {
        _classCallCheck(this, Value2);
        this.unit = unit;
        this.value = value;
      }
      _createClass(Value2, [{
        key: "fromJS",
        value: function fromJS(expose) {
          expose(this.unit, this.value);
        }
      }, {
        key: "toString",
        value: function toString() {
          switch (this.unit) {
            case CONSTANTS.UNIT_POINT:
              return String(this.value);
            case CONSTANTS.UNIT_PERCENT:
              return this.value + "%";
            case CONSTANTS.UNIT_AUTO:
              return "auto";
            default: {
              return this.value + "?";
            }
          }
        }
      }, {
        key: "valueOf",
        value: function valueOf() {
          return this.value;
        }
      }]);
      return Value2;
    }();
    module2.exports = function(bind, lib) {
      function patch(prototype, name, fn) {
        var original = prototype[name];
        prototype[name] = function() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return fn.call.apply(fn, [this, original].concat(args));
        };
      }
      var _arr = ["setPosition", "setMargin", "setFlexBasis", "setWidth", "setHeight", "setMinWidth", "setMinHeight", "setMaxWidth", "setMaxHeight", "setPadding"];
      var _loop = function _loop2() {
        var _methods;
        var fnName = _arr[_i];
        var methods = (_methods = {}, _defineProperty(_methods, CONSTANTS.UNIT_POINT, lib.Node.prototype[fnName]), _defineProperty(_methods, CONSTANTS.UNIT_PERCENT, lib.Node.prototype[fnName + "Percent"]), _defineProperty(_methods, CONSTANTS.UNIT_AUTO, lib.Node.prototype[fnName + "Auto"]), _methods);
        patch(lib.Node.prototype, fnName, function(original) {
          for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          var value = args.pop();
          var unit = void 0, asNumber = void 0;
          if (value === "auto") {
            unit = CONSTANTS.UNIT_AUTO;
            asNumber = void 0;
          } else if (value instanceof Value) {
            unit = value.unit;
            asNumber = value.valueOf();
          } else {
            unit = typeof value === "string" && value.endsWith("%") ? CONSTANTS.UNIT_PERCENT : CONSTANTS.UNIT_POINT;
            asNumber = parseFloat(value);
            if (!Number.isNaN(value) && Number.isNaN(asNumber)) {
              throw new Error("Invalid value " + value + " for " + fnName);
            }
          }
          if (!methods[unit])
            throw new Error('Failed to execute "' + fnName + `": Unsupported unit '` + value + "'");
          if (asNumber !== void 0) {
            var _methods$unit;
            return (_methods$unit = methods[unit]).call.apply(_methods$unit, [this].concat(args, [asNumber]));
          } else {
            var _methods$unit2;
            return (_methods$unit2 = methods[unit]).call.apply(_methods$unit2, [this].concat(args));
          }
        });
      };
      for (var _i = 0; _i < _arr.length; _i++) {
        _loop();
      }
      patch(lib.Config.prototype, "free", function() {
        lib.Config.destroy(this);
      });
      patch(lib.Node, "create", function(_2, config) {
        return config ? lib.Node.createWithConfig(config) : lib.Node.createDefault();
      });
      patch(lib.Node.prototype, "free", function() {
        lib.Node.destroy(this);
      });
      patch(lib.Node.prototype, "freeRecursive", function() {
        for (var t2 = 0, T2 = this.getChildCount(); t2 < T2; ++t2) {
          this.getChild(0).freeRecursive();
        }
        this.free();
      });
      patch(lib.Node.prototype, "setMeasureFunc", function(original, measureFunc) {
        if (measureFunc) {
          return original.call(this, function() {
            return Size.fromJS(measureFunc.apply(void 0, arguments));
          });
        } else {
          return this.unsetMeasureFunc();
        }
      });
      patch(lib.Node.prototype, "calculateLayout", function(original) {
        var width = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : NaN;
        var height = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
        var direction = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : CONSTANTS.DIRECTION_LTR;
        return original.call(this, width, height, direction);
      });
      return _extends({
        Config: lib.Config,
        Node: lib.Node,
        Layout: bind("Layout", Layout),
        Size: bind("Size", Size),
        Value: bind("Value", Value),
        getInstanceCount: function getInstanceCount() {
          return lib.getInstanceCount.apply(lib, arguments);
        }
      }, CONSTANTS);
    };
  }
});

// ../../node_modules/.pnpm/@aeolun+yoga-layout-prebuilt@1.10.0/node_modules/@aeolun/yoga-layout-prebuilt/yoga-layout/build/Release/nbind.js
var require_nbind = __commonJS({
  "../../node_modules/.pnpm/@aeolun+yoga-layout-prebuilt@1.10.0/node_modules/@aeolun/yoga-layout-prebuilt/yoga-layout/build/Release/nbind.js"(exports, module) {
    (function(root, wrapper) {
      if (typeof define == "function" && define.amd)
        define([], function() {
          return wrapper;
        });
      else if (typeof module == "object" && module.exports)
        module.exports = wrapper;
      else
        (root.nbind = root.nbind || {}).init = wrapper;
    })(exports, function(Module, cb) {
      if (typeof Module == "function") {
        cb = Module;
        Module = {};
      }
      Module.onRuntimeInitialized = function(init4, cb2) {
        return function() {
          if (init4)
            init4.apply(this, arguments);
          try {
            Module.ccall("nbind_init");
          } catch (err2) {
            cb2(err2);
            return;
          }
          cb2(null, { bind: Module._nbind_value, reflect: Module.NBind.reflect, queryType: Module.NBind.queryType, toggleLightGC: Module.toggleLightGC, lib: Module });
        };
      }(Module.onRuntimeInitialized, cb);
      var Module;
      if (!Module)
        Module = (typeof Module !== "undefined" ? Module : null) || {};
      var moduleOverrides = {};
      for (var key in Module) {
        if (Module.hasOwnProperty(key)) {
          moduleOverrides[key] = Module[key];
        }
      }
      var ENVIRONMENT_IS_WEB = false;
      var ENVIRONMENT_IS_WORKER = false;
      var ENVIRONMENT_IS_NODE = false;
      var ENVIRONMENT_IS_SHELL = false;
      if (Module["ENVIRONMENT"]) {
        if (Module["ENVIRONMENT"] === "WEB") {
          ENVIRONMENT_IS_WEB = true;
        } else if (Module["ENVIRONMENT"] === "WORKER") {
          ENVIRONMENT_IS_WORKER = true;
        } else if (Module["ENVIRONMENT"] === "NODE") {
          ENVIRONMENT_IS_NODE = true;
        } else if (Module["ENVIRONMENT"] === "SHELL") {
          ENVIRONMENT_IS_SHELL = true;
        } else {
          throw new Error("The provided Module['ENVIRONMENT'] value is not valid. It must be one of: WEB|WORKER|NODE|SHELL.");
        }
      } else {
        ENVIRONMENT_IS_WEB = typeof window === "object";
        ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
        ENVIRONMENT_IS_NODE = typeof process === "object" && typeof __require === "function" && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;
        ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
      }
      if (ENVIRONMENT_IS_NODE) {
        if (!Module["print"])
          Module["print"] = console.log;
        if (!Module["printErr"])
          Module["printErr"] = console.warn;
        var nodeFS;
        var nodePath;
        Module["read"] = function shell_read(filename, binary) {
          if (!nodeFS)
            nodeFS = {}("");
          if (!nodePath)
            nodePath = {}("");
          filename = nodePath["normalize"](filename);
          var ret = nodeFS["readFileSync"](filename);
          return binary ? ret : ret.toString();
        };
        Module["readBinary"] = function readBinary(filename) {
          var ret = Module["read"](filename, true);
          if (!ret.buffer) {
            ret = new Uint8Array(ret);
          }
          assert(ret.buffer);
          return ret;
        };
        Module["load"] = function load(f3) {
          globalEval(read(f3));
        };
        if (!Module["thisProgram"]) {
          if (process["argv"].length > 1) {
            Module["thisProgram"] = process["argv"][1].replace(/\\/g, "/");
          } else {
            Module["thisProgram"] = "unknown-program";
          }
        }
        Module["arguments"] = process["argv"].slice(2);
        if (typeof module !== "undefined") {
          module["exports"] = Module;
        }
        process["on"]("uncaughtException", function(ex) {
          if (!(ex instanceof ExitStatus)) {
            throw ex;
          }
        });
        Module["inspect"] = function() {
          return "[Emscripten Module object]";
        };
      } else if (ENVIRONMENT_IS_SHELL) {
        if (!Module["print"])
          Module["print"] = print;
        if (typeof printErr != "undefined")
          Module["printErr"] = printErr;
        if (typeof read != "undefined") {
          Module["read"] = read;
        } else {
          Module["read"] = function shell_read() {
            throw "no read() available";
          };
        }
        Module["readBinary"] = function readBinary(f3) {
          if (typeof readbuffer === "function") {
            return new Uint8Array(readbuffer(f3));
          }
          var data = read(f3, "binary");
          assert(typeof data === "object");
          return data;
        };
        if (typeof scriptArgs != "undefined") {
          Module["arguments"] = scriptArgs;
        } else if (typeof arguments != "undefined") {
          Module["arguments"] = arguments;
        }
        if (typeof quit === "function") {
          Module["quit"] = function(status, toThrow) {
            quit(status);
          };
        }
      } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
        Module["read"] = function shell_read(url2) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url2, false);
          xhr.send(null);
          return xhr.responseText;
        };
        if (ENVIRONMENT_IS_WORKER) {
          Module["readBinary"] = function readBinary(url2) {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url2, false);
            xhr.responseType = "arraybuffer";
            xhr.send(null);
            return new Uint8Array(xhr.response);
          };
        }
        Module["readAsync"] = function readAsync(url2, onload, onerror) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url2, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = function xhr_onload() {
            if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
              onload(xhr.response);
            } else {
              onerror();
            }
          };
          xhr.onerror = onerror;
          xhr.send(null);
        };
        if (typeof arguments != "undefined") {
          Module["arguments"] = arguments;
        }
        if (typeof console !== "undefined") {
          if (!Module["print"])
            Module["print"] = function shell_print(x3) {
              console.log(x3);
            };
          if (!Module["printErr"])
            Module["printErr"] = function shell_printErr(x3) {
              console.warn(x3);
            };
        } else {
          var TRY_USE_DUMP = false;
          if (!Module["print"])
            Module["print"] = TRY_USE_DUMP && typeof dump !== "undefined" ? function(x3) {
              dump(x3);
            } : function(x3) {
            };
        }
        if (ENVIRONMENT_IS_WORKER) {
          Module["load"] = importScripts;
        }
        if (typeof Module["setWindowTitle"] === "undefined") {
          Module["setWindowTitle"] = function(title) {
            document.title = title;
          };
        }
      } else {
        throw "Unknown runtime environment. Where are we?";
      }
      function globalEval(x3) {
        eval.call(null, x3);
      }
      if (!Module["load"] && Module["read"]) {
        Module["load"] = function load(f3) {
          globalEval(Module["read"](f3));
        };
      }
      if (!Module["print"]) {
        Module["print"] = function() {
        };
      }
      if (!Module["printErr"]) {
        Module["printErr"] = Module["print"];
      }
      if (!Module["arguments"]) {
        Module["arguments"] = [];
      }
      if (!Module["thisProgram"]) {
        Module["thisProgram"] = "./this.program";
      }
      if (!Module["quit"]) {
        Module["quit"] = function(status, toThrow) {
          throw toThrow;
        };
      }
      Module.print = Module["print"];
      Module.printErr = Module["printErr"];
      Module["preRun"] = [];
      Module["postRun"] = [];
      for (var key in moduleOverrides) {
        if (moduleOverrides.hasOwnProperty(key)) {
          Module[key] = moduleOverrides[key];
        }
      }
      moduleOverrides = void 0;
      var Runtime = { setTempRet0: function(value) {
        tempRet0 = value;
        return value;
      }, getTempRet0: function() {
        return tempRet0;
      }, stackSave: function() {
        return STACKTOP;
      }, stackRestore: function(stackTop) {
        STACKTOP = stackTop;
      }, getNativeTypeSize: function(type2) {
        switch (type2) {
          case "i1":
          case "i8":
            return 1;
          case "i16":
            return 2;
          case "i32":
            return 4;
          case "i64":
            return 8;
          case "float":
            return 4;
          case "double":
            return 8;
          default: {
            if (type2[type2.length - 1] === "*") {
              return Runtime.QUANTUM_SIZE;
            } else if (type2[0] === "i") {
              var bits = parseInt(type2.substr(1));
              assert(bits % 8 === 0);
              return bits / 8;
            } else {
              return 0;
            }
          }
        }
      }, getNativeFieldSize: function(type2) {
        return Math.max(Runtime.getNativeTypeSize(type2), Runtime.QUANTUM_SIZE);
      }, STACK_ALIGN: 16, prepVararg: function(ptr2, type2) {
        if (type2 === "double" || type2 === "i64") {
          if (ptr2 & 7) {
            assert((ptr2 & 7) === 4);
            ptr2 += 4;
          }
        } else {
          assert((ptr2 & 3) === 0);
        }
        return ptr2;
      }, getAlignSize: function(type2, size3, vararg) {
        if (!vararg && (type2 == "i64" || type2 == "double"))
          return 8;
        if (!type2)
          return Math.min(size3, 8);
        return Math.min(size3 || (type2 ? Runtime.getNativeFieldSize(type2) : 0), Runtime.QUANTUM_SIZE);
      }, dynCall: function(sig, ptr2, args) {
        if (args && args.length) {
          return Module["dynCall_" + sig].apply(null, [ptr2].concat(args));
        } else {
          return Module["dynCall_" + sig].call(null, ptr2);
        }
      }, functionPointers: [], addFunction: function(func2) {
        for (var i3 = 0; i3 < Runtime.functionPointers.length; i3++) {
          if (!Runtime.functionPointers[i3]) {
            Runtime.functionPointers[i3] = func2;
            return 2 * (1 + i3);
          }
        }
        throw "Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.";
      }, removeFunction: function(index) {
        Runtime.functionPointers[(index - 2) / 2] = null;
      }, warnOnce: function(text) {
        if (!Runtime.warnOnce.shown)
          Runtime.warnOnce.shown = {};
        if (!Runtime.warnOnce.shown[text]) {
          Runtime.warnOnce.shown[text] = 1;
          Module.printErr(text);
        }
      }, funcWrappers: {}, getFuncWrapper: function(func2, sig) {
        if (!func2)
          return;
        assert(sig);
        if (!Runtime.funcWrappers[sig]) {
          Runtime.funcWrappers[sig] = {};
        }
        var sigCache = Runtime.funcWrappers[sig];
        if (!sigCache[func2]) {
          if (sig.length === 1) {
            sigCache[func2] = function dynCall_wrapper() {
              return Runtime.dynCall(sig, func2);
            };
          } else if (sig.length === 2) {
            sigCache[func2] = function dynCall_wrapper(arg2) {
              return Runtime.dynCall(sig, func2, [arg2]);
            };
          } else {
            sigCache[func2] = function dynCall_wrapper() {
              return Runtime.dynCall(sig, func2, Array.prototype.slice.call(arguments));
            };
          }
        }
        return sigCache[func2];
      }, getCompilerSetting: function(name) {
        throw "You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work";
      }, stackAlloc: function(size3) {
        var ret = STACKTOP;
        STACKTOP = STACKTOP + size3 | 0;
        STACKTOP = STACKTOP + 15 & -16;
        return ret;
      }, staticAlloc: function(size3) {
        var ret = STATICTOP;
        STATICTOP = STATICTOP + size3 | 0;
        STATICTOP = STATICTOP + 15 & -16;
        return ret;
      }, dynamicAlloc: function(size3) {
        var ret = HEAP32[DYNAMICTOP_PTR >> 2];
        var end = (ret + size3 + 15 | 0) & -16;
        HEAP32[DYNAMICTOP_PTR >> 2] = end;
        if (end >= TOTAL_MEMORY) {
          var success = enlargeMemory();
          if (!success) {
            HEAP32[DYNAMICTOP_PTR >> 2] = ret;
            return 0;
          }
        }
        return ret;
      }, alignMemory: function(size3, quantum) {
        var ret = size3 = Math.ceil(size3 / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
        return ret;
      }, makeBigInt: function(low, high, unsigned) {
        var ret = unsigned ? +(low >>> 0) + +(high >>> 0) * 4294967296 : +(low >>> 0) + +(high | 0) * 4294967296;
        return ret;
      }, GLOBAL_BASE: 8, QUANTUM_SIZE: 4, __dummy__: 0 };
      Module["Runtime"] = Runtime;
      var ABORT = 0;
      var EXITSTATUS = 0;
      function assert(condition, text) {
        if (!condition) {
          abort("Assertion failed: " + text);
        }
      }
      function getCFunc(ident) {
        var func = Module["_" + ident];
        if (!func) {
          try {
            func = eval("_" + ident);
          } catch (e3) {
          }
        }
        assert(func, "Cannot call unknown function " + ident + " (perhaps LLVM optimizations or closure removed it?)");
        return func;
      }
      var cwrap, ccall;
      (function() {
        var JSfuncs = { "stackSave": function() {
          Runtime.stackSave();
        }, "stackRestore": function() {
          Runtime.stackRestore();
        }, "arrayToC": function(arr) {
          var ret = Runtime.stackAlloc(arr.length);
          writeArrayToMemory(arr, ret);
          return ret;
        }, "stringToC": function(str) {
          var ret = 0;
          if (str !== null && str !== void 0 && str !== 0) {
            var len = (str.length << 2) + 1;
            ret = Runtime.stackAlloc(len);
            stringToUTF8(str, ret, len);
          }
          return ret;
        } };
        var toC = { "string": JSfuncs["stringToC"], "array": JSfuncs["arrayToC"] };
        ccall = function ccallFunc(ident2, returnType2, argTypes2, args, opts) {
          var func2 = getCFunc(ident2);
          var cArgs = [];
          var stack = 0;
          if (args) {
            for (var i3 = 0; i3 < args.length; i3++) {
              var converter = toC[argTypes2[i3]];
              if (converter) {
                if (stack === 0)
                  stack = Runtime.stackSave();
                cArgs[i3] = converter(args[i3]);
              } else {
                cArgs[i3] = args[i3];
              }
            }
          }
          var ret = func2.apply(null, cArgs);
          if (returnType2 === "string")
            ret = Pointer_stringify(ret);
          if (stack !== 0) {
            if (opts && opts.async) {
              EmterpreterAsync.asyncFinalizers.push(function() {
                Runtime.stackRestore(stack);
              });
              return;
            }
            Runtime.stackRestore(stack);
          }
          return ret;
        };
        var sourceRegex = /^function\s*[a-zA-Z$_0-9]*\s*\(([^)]*)\)\s*{\s*([^*]*?)[\s;]*(?:return\s*(.*?)[;\s]*)?}$/;
        function parseJSFunc(jsfunc) {
          var parsed = jsfunc.toString().match(sourceRegex).slice(1);
          return { arguments: parsed[0], body: parsed[1], returnValue: parsed[2] };
        }
        var JSsource = null;
        function ensureJSsource() {
          if (!JSsource) {
            JSsource = {};
            for (var fun in JSfuncs) {
              if (JSfuncs.hasOwnProperty(fun)) {
                JSsource[fun] = parseJSFunc(JSfuncs[fun]);
              }
            }
          }
        }
        cwrap = function cwrap(ident, returnType, argTypes) {
          argTypes = argTypes || [];
          var cfunc = getCFunc(ident);
          var numericArgs = argTypes.every(function(type2) {
            return type2 === "number";
          });
          var numericRet = returnType !== "string";
          if (numericRet && numericArgs) {
            return cfunc;
          }
          var argNames = argTypes.map(function(x3, i3) {
            return "$" + i3;
          });
          var funcstr = "(function(" + argNames.join(",") + ") {";
          var nargs = argTypes.length;
          if (!numericArgs) {
            ensureJSsource();
            funcstr += "var stack = " + JSsource["stackSave"].body + ";";
            for (var i = 0; i < nargs; i++) {
              var arg = argNames[i], type = argTypes[i];
              if (type === "number")
                continue;
              var convertCode = JSsource[type + "ToC"];
              funcstr += "var " + convertCode.arguments + " = " + arg + ";";
              funcstr += convertCode.body + ";";
              funcstr += arg + "=(" + convertCode.returnValue + ");";
            }
          }
          var cfuncname = parseJSFunc(function() {
            return cfunc;
          }).returnValue;
          funcstr += "var ret = " + cfuncname + "(" + argNames.join(",") + ");";
          if (!numericRet) {
            var strgfy = parseJSFunc(function() {
              return Pointer_stringify;
            }).returnValue;
            funcstr += "ret = " + strgfy + "(ret);";
          }
          if (!numericArgs) {
            ensureJSsource();
            funcstr += JSsource["stackRestore"].body.replace("()", "(stack)") + ";";
          }
          funcstr += "return ret})";
          return eval(funcstr);
        };
      })();
      Module["ccall"] = ccall;
      Module["cwrap"] = cwrap;
      function setValue(ptr2, value, type2, noSafe) {
        type2 = type2 || "i8";
        if (type2.charAt(type2.length - 1) === "*")
          type2 = "i32";
        switch (type2) {
          case "i1":
            HEAP8[ptr2 >> 0] = value;
            break;
          case "i8":
            HEAP8[ptr2 >> 0] = value;
            break;
          case "i16":
            HEAP16[ptr2 >> 1] = value;
            break;
          case "i32":
            HEAP32[ptr2 >> 2] = value;
            break;
          case "i64":
            tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr2 >> 2] = tempI64[0], HEAP32[ptr2 + 4 >> 2] = tempI64[1];
            break;
          case "float":
            HEAPF32[ptr2 >> 2] = value;
            break;
          case "double":
            HEAPF64[ptr2 >> 3] = value;
            break;
          default:
            abort("invalid type for setValue: " + type2);
        }
      }
      Module["setValue"] = setValue;
      function getValue(ptr2, type2, noSafe) {
        type2 = type2 || "i8";
        if (type2.charAt(type2.length - 1) === "*")
          type2 = "i32";
        switch (type2) {
          case "i1":
            return HEAP8[ptr2 >> 0];
          case "i8":
            return HEAP8[ptr2 >> 0];
          case "i16":
            return HEAP16[ptr2 >> 1];
          case "i32":
            return HEAP32[ptr2 >> 2];
          case "i64":
            return HEAP32[ptr2 >> 2];
          case "float":
            return HEAPF32[ptr2 >> 2];
          case "double":
            return HEAPF64[ptr2 >> 3];
          default:
            abort("invalid type for setValue: " + type2);
        }
        return null;
      }
      Module["getValue"] = getValue;
      var ALLOC_NORMAL = 0;
      var ALLOC_STACK = 1;
      var ALLOC_STATIC = 2;
      var ALLOC_DYNAMIC = 3;
      var ALLOC_NONE = 4;
      Module["ALLOC_NORMAL"] = ALLOC_NORMAL;
      Module["ALLOC_STACK"] = ALLOC_STACK;
      Module["ALLOC_STATIC"] = ALLOC_STATIC;
      Module["ALLOC_DYNAMIC"] = ALLOC_DYNAMIC;
      Module["ALLOC_NONE"] = ALLOC_NONE;
      function allocate(slab, types, allocator, ptr2) {
        var zeroinit, size3;
        if (typeof slab === "number") {
          zeroinit = true;
          size3 = slab;
        } else {
          zeroinit = false;
          size3 = slab.length;
        }
        var singleType = typeof types === "string" ? types : null;
        var ret;
        if (allocator == ALLOC_NONE) {
          ret = ptr2;
        } else {
          ret = [typeof _malloc === "function" ? _malloc : Runtime.staticAlloc, Runtime.stackAlloc, Runtime.staticAlloc, Runtime.dynamicAlloc][allocator === void 0 ? ALLOC_STATIC : allocator](Math.max(size3, singleType ? 1 : types.length));
        }
        if (zeroinit) {
          var ptr2 = ret, stop;
          assert((ret & 3) == 0);
          stop = ret + (size3 & ~3);
          for (; ptr2 < stop; ptr2 += 4) {
            HEAP32[ptr2 >> 2] = 0;
          }
          stop = ret + size3;
          while (ptr2 < stop) {
            HEAP8[ptr2++ >> 0] = 0;
          }
          return ret;
        }
        if (singleType === "i8") {
          if (slab.subarray || slab.slice) {
            HEAPU8.set(slab, ret);
          } else {
            HEAPU8.set(new Uint8Array(slab), ret);
          }
          return ret;
        }
        var i3 = 0, type2, typeSize, previousType;
        while (i3 < size3) {
          var curr = slab[i3];
          if (typeof curr === "function") {
            curr = Runtime.getFunctionIndex(curr);
          }
          type2 = singleType || types[i3];
          if (type2 === 0) {
            i3++;
            continue;
          }
          if (type2 == "i64")
            type2 = "i32";
          setValue(ret + i3, curr, type2);
          if (previousType !== type2) {
            typeSize = Runtime.getNativeTypeSize(type2);
            previousType = type2;
          }
          i3 += typeSize;
        }
        return ret;
      }
      Module["allocate"] = allocate;
      function getMemory(size3) {
        if (!staticSealed)
          return Runtime.staticAlloc(size3);
        if (!runtimeInitialized)
          return Runtime.dynamicAlloc(size3);
        return _malloc(size3);
      }
      Module["getMemory"] = getMemory;
      function Pointer_stringify(ptr2, length) {
        if (length === 0 || !ptr2)
          return "";
        var hasUtf = 0;
        var t2;
        var i3 = 0;
        while (1) {
          t2 = HEAPU8[ptr2 + i3 >> 0];
          hasUtf |= t2;
          if (t2 == 0 && !length)
            break;
          i3++;
          if (length && i3 == length)
            break;
        }
        if (!length)
          length = i3;
        var ret = "";
        if (hasUtf < 128) {
          var MAX_CHUNK = 1024;
          var curr;
          while (length > 0) {
            curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr2, ptr2 + Math.min(length, MAX_CHUNK)));
            ret = ret ? ret + curr : curr;
            ptr2 += MAX_CHUNK;
            length -= MAX_CHUNK;
          }
          return ret;
        }
        return Module["UTF8ToString"](ptr2);
      }
      Module["Pointer_stringify"] = Pointer_stringify;
      function AsciiToString(ptr2) {
        var str = "";
        while (1) {
          var ch = HEAP8[ptr2++ >> 0];
          if (!ch)
            return str;
          str += String.fromCharCode(ch);
        }
      }
      Module["AsciiToString"] = AsciiToString;
      function stringToAscii(str, outPtr) {
        return writeAsciiToMemory(str, outPtr, false);
      }
      Module["stringToAscii"] = stringToAscii;
      var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
      function UTF8ArrayToString(u8Array, idx) {
        var endPtr = idx;
        while (u8Array[endPtr])
          ++endPtr;
        if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
          return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));
        } else {
          var u0, u1, u22, u3, u4, u5;
          var str = "";
          while (1) {
            u0 = u8Array[idx++];
            if (!u0)
              return str;
            if (!(u0 & 128)) {
              str += String.fromCharCode(u0);
              continue;
            }
            u1 = u8Array[idx++] & 63;
            if ((u0 & 224) == 192) {
              str += String.fromCharCode((u0 & 31) << 6 | u1);
              continue;
            }
            u22 = u8Array[idx++] & 63;
            if ((u0 & 240) == 224) {
              u0 = (u0 & 15) << 12 | u1 << 6 | u22;
            } else {
              u3 = u8Array[idx++] & 63;
              if ((u0 & 248) == 240) {
                u0 = (u0 & 7) << 18 | u1 << 12 | u22 << 6 | u3;
              } else {
                u4 = u8Array[idx++] & 63;
                if ((u0 & 252) == 248) {
                  u0 = (u0 & 3) << 24 | u1 << 18 | u22 << 12 | u3 << 6 | u4;
                } else {
                  u5 = u8Array[idx++] & 63;
                  u0 = (u0 & 1) << 30 | u1 << 24 | u22 << 18 | u3 << 12 | u4 << 6 | u5;
                }
              }
            }
            if (u0 < 65536) {
              str += String.fromCharCode(u0);
            } else {
              var ch = u0 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            }
          }
        }
      }
      Module["UTF8ArrayToString"] = UTF8ArrayToString;
      function UTF8ToString(ptr2) {
        return UTF8ArrayToString(HEAPU8, ptr2);
      }
      Module["UTF8ToString"] = UTF8ToString;
      function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
        if (!(maxBytesToWrite > 0))
          return 0;
        var startIdx = outIdx;
        var endIdx = outIdx + maxBytesToWrite - 1;
        for (var i3 = 0; i3 < str.length; ++i3) {
          var u3 = str.charCodeAt(i3);
          if (u3 >= 55296 && u3 <= 57343)
            u3 = 65536 + ((u3 & 1023) << 10) | str.charCodeAt(++i3) & 1023;
          if (u3 <= 127) {
            if (outIdx >= endIdx)
              break;
            outU8Array[outIdx++] = u3;
          } else if (u3 <= 2047) {
            if (outIdx + 1 >= endIdx)
              break;
            outU8Array[outIdx++] = 192 | u3 >> 6;
            outU8Array[outIdx++] = 128 | u3 & 63;
          } else if (u3 <= 65535) {
            if (outIdx + 2 >= endIdx)
              break;
            outU8Array[outIdx++] = 224 | u3 >> 12;
            outU8Array[outIdx++] = 128 | u3 >> 6 & 63;
            outU8Array[outIdx++] = 128 | u3 & 63;
          } else if (u3 <= 2097151) {
            if (outIdx + 3 >= endIdx)
              break;
            outU8Array[outIdx++] = 240 | u3 >> 18;
            outU8Array[outIdx++] = 128 | u3 >> 12 & 63;
            outU8Array[outIdx++] = 128 | u3 >> 6 & 63;
            outU8Array[outIdx++] = 128 | u3 & 63;
          } else if (u3 <= 67108863) {
            if (outIdx + 4 >= endIdx)
              break;
            outU8Array[outIdx++] = 248 | u3 >> 24;
            outU8Array[outIdx++] = 128 | u3 >> 18 & 63;
            outU8Array[outIdx++] = 128 | u3 >> 12 & 63;
            outU8Array[outIdx++] = 128 | u3 >> 6 & 63;
            outU8Array[outIdx++] = 128 | u3 & 63;
          } else {
            if (outIdx + 5 >= endIdx)
              break;
            outU8Array[outIdx++] = 252 | u3 >> 30;
            outU8Array[outIdx++] = 128 | u3 >> 24 & 63;
            outU8Array[outIdx++] = 128 | u3 >> 18 & 63;
            outU8Array[outIdx++] = 128 | u3 >> 12 & 63;
            outU8Array[outIdx++] = 128 | u3 >> 6 & 63;
            outU8Array[outIdx++] = 128 | u3 & 63;
          }
        }
        outU8Array[outIdx] = 0;
        return outIdx - startIdx;
      }
      Module["stringToUTF8Array"] = stringToUTF8Array;
      function stringToUTF8(str, outPtr, maxBytesToWrite) {
        return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
      }
      Module["stringToUTF8"] = stringToUTF8;
      function lengthBytesUTF8(str) {
        var len = 0;
        for (var i3 = 0; i3 < str.length; ++i3) {
          var u3 = str.charCodeAt(i3);
          if (u3 >= 55296 && u3 <= 57343)
            u3 = 65536 + ((u3 & 1023) << 10) | str.charCodeAt(++i3) & 1023;
          if (u3 <= 127) {
            ++len;
          } else if (u3 <= 2047) {
            len += 2;
          } else if (u3 <= 65535) {
            len += 3;
          } else if (u3 <= 2097151) {
            len += 4;
          } else if (u3 <= 67108863) {
            len += 5;
          } else {
            len += 6;
          }
        }
        return len;
      }
      Module["lengthBytesUTF8"] = lengthBytesUTF8;
      var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : void 0;
      function demangle(func2) {
        var __cxa_demangle_func = Module["___cxa_demangle"] || Module["__cxa_demangle"];
        if (__cxa_demangle_func) {
          try {
            var s2 = func2.substr(1);
            var len = lengthBytesUTF8(s2) + 1;
            var buf = _malloc(len);
            stringToUTF8(s2, buf, len);
            var status = _malloc(4);
            var ret = __cxa_demangle_func(buf, 0, 0, status);
            if (getValue(status, "i32") === 0 && ret) {
              return Pointer_stringify(ret);
            }
          } catch (e3) {
          } finally {
            if (buf)
              _free(buf);
            if (status)
              _free(status);
            if (ret)
              _free(ret);
          }
          return func2;
        }
        Runtime.warnOnce("warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling");
        return func2;
      }
      function demangleAll(text) {
        var regex = /__Z[\w\d_]+/g;
        return text.replace(regex, function(x3) {
          var y2 = demangle(x3);
          return x3 === y2 ? x3 : x3 + " [" + y2 + "]";
        });
      }
      function jsStackTrace() {
        var err2 = new Error();
        if (!err2.stack) {
          try {
            throw new Error(0);
          } catch (e3) {
            err2 = e3;
          }
          if (!err2.stack) {
            return "(no stack trace available)";
          }
        }
        return err2.stack.toString();
      }
      function stackTrace() {
        var js = jsStackTrace();
        if (Module["extraStackTrace"])
          js += "\n" + Module["extraStackTrace"]();
        return demangleAll(js);
      }
      Module["stackTrace"] = stackTrace;
      var HEAP, buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
      function updateGlobalBufferViews() {
        Module["HEAP8"] = HEAP8 = new Int8Array(buffer);
        Module["HEAP16"] = HEAP16 = new Int16Array(buffer);
        Module["HEAP32"] = HEAP32 = new Int32Array(buffer);
        Module["HEAPU8"] = HEAPU8 = new Uint8Array(buffer);
        Module["HEAPU16"] = HEAPU16 = new Uint16Array(buffer);
        Module["HEAPU32"] = HEAPU32 = new Uint32Array(buffer);
        Module["HEAPF32"] = HEAPF32 = new Float32Array(buffer);
        Module["HEAPF64"] = HEAPF64 = new Float64Array(buffer);
      }
      var STATIC_BASE, STATICTOP, staticSealed;
      var STACK_BASE, STACKTOP, STACK_MAX;
      var DYNAMIC_BASE, DYNAMICTOP_PTR;
      STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0;
      staticSealed = false;
      function abortOnCannotGrowMemory() {
        abort("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value " + TOTAL_MEMORY + ", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or (4) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ");
      }
      function enlargeMemory() {
        abortOnCannotGrowMemory();
      }
      var TOTAL_STACK = Module["TOTAL_STACK"] || 5242880;
      var TOTAL_MEMORY = Module["TOTAL_MEMORY"] || 134217728;
      if (TOTAL_MEMORY < TOTAL_STACK)
        Module.printErr("TOTAL_MEMORY should be larger than TOTAL_STACK, was " + TOTAL_MEMORY + "! (TOTAL_STACK=" + TOTAL_STACK + ")");
      if (Module["buffer"]) {
        buffer = Module["buffer"];
      } else {
        {
          buffer = new ArrayBuffer(TOTAL_MEMORY);
        }
      }
      updateGlobalBufferViews();
      function getTotalMemory() {
        return TOTAL_MEMORY;
      }
      HEAP32[0] = 1668509029;
      HEAP16[1] = 25459;
      if (HEAPU8[2] !== 115 || HEAPU8[3] !== 99)
        throw "Runtime error: expected the system to be little-endian!";
      Module["HEAP"] = HEAP;
      Module["buffer"] = buffer;
      Module["HEAP8"] = HEAP8;
      Module["HEAP16"] = HEAP16;
      Module["HEAP32"] = HEAP32;
      Module["HEAPU8"] = HEAPU8;
      Module["HEAPU16"] = HEAPU16;
      Module["HEAPU32"] = HEAPU32;
      Module["HEAPF32"] = HEAPF32;
      Module["HEAPF64"] = HEAPF64;
      function callRuntimeCallbacks(callbacks) {
        while (callbacks.length > 0) {
          var callback = callbacks.shift();
          if (typeof callback == "function") {
            callback();
            continue;
          }
          var func2 = callback.func;
          if (typeof func2 === "number") {
            if (callback.arg === void 0) {
              Module["dynCall_v"](func2);
            } else {
              Module["dynCall_vi"](func2, callback.arg);
            }
          } else {
            func2(callback.arg === void 0 ? null : callback.arg);
          }
        }
      }
      var __ATPRERUN__ = [];
      var __ATINIT__ = [];
      var __ATMAIN__ = [];
      var __ATEXIT__ = [];
      var __ATPOSTRUN__ = [];
      var runtimeInitialized = false;
      var runtimeExited = false;
      function preRun() {
        if (Module["preRun"]) {
          if (typeof Module["preRun"] == "function")
            Module["preRun"] = [Module["preRun"]];
          while (Module["preRun"].length) {
            addOnPreRun(Module["preRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPRERUN__);
      }
      function ensureInitRuntime() {
        if (runtimeInitialized)
          return;
        runtimeInitialized = true;
        callRuntimeCallbacks(__ATINIT__);
      }
      function preMain() {
        callRuntimeCallbacks(__ATMAIN__);
      }
      function exitRuntime() {
        callRuntimeCallbacks(__ATEXIT__);
        runtimeExited = true;
      }
      function postRun() {
        if (Module["postRun"]) {
          if (typeof Module["postRun"] == "function")
            Module["postRun"] = [Module["postRun"]];
          while (Module["postRun"].length) {
            addOnPostRun(Module["postRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPOSTRUN__);
      }
      function addOnPreRun(cb2) {
        __ATPRERUN__.unshift(cb2);
      }
      Module["addOnPreRun"] = addOnPreRun;
      function addOnInit(cb2) {
        __ATINIT__.unshift(cb2);
      }
      Module["addOnInit"] = addOnInit;
      function addOnPreMain(cb2) {
        __ATMAIN__.unshift(cb2);
      }
      Module["addOnPreMain"] = addOnPreMain;
      function addOnExit(cb2) {
        __ATEXIT__.unshift(cb2);
      }
      Module["addOnExit"] = addOnExit;
      function addOnPostRun(cb2) {
        __ATPOSTRUN__.unshift(cb2);
      }
      Module["addOnPostRun"] = addOnPostRun;
      function intArrayFromString(stringy, dontAddNull, length) {
        var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
        var u8array = new Array(len);
        var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
        if (dontAddNull)
          u8array.length = numBytesWritten;
        return u8array;
      }
      Module["intArrayFromString"] = intArrayFromString;
      function intArrayToString(array) {
        var ret = [];
        for (var i3 = 0; i3 < array.length; i3++) {
          var chr = array[i3];
          if (chr > 255) {
            chr &= 255;
          }
          ret.push(String.fromCharCode(chr));
        }
        return ret.join("");
      }
      Module["intArrayToString"] = intArrayToString;
      function writeStringToMemory(string, buffer2, dontAddNull) {
        Runtime.warnOnce("writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!");
        var lastChar, end;
        if (dontAddNull) {
          end = buffer2 + lengthBytesUTF8(string);
          lastChar = HEAP8[end];
        }
        stringToUTF8(string, buffer2, Infinity);
        if (dontAddNull)
          HEAP8[end] = lastChar;
      }
      Module["writeStringToMemory"] = writeStringToMemory;
      function writeArrayToMemory(array, buffer2) {
        HEAP8.set(array, buffer2);
      }
      Module["writeArrayToMemory"] = writeArrayToMemory;
      function writeAsciiToMemory(str, buffer2, dontAddNull) {
        for (var i3 = 0; i3 < str.length; ++i3) {
          HEAP8[buffer2++ >> 0] = str.charCodeAt(i3);
        }
        if (!dontAddNull)
          HEAP8[buffer2 >> 0] = 0;
      }
      Module["writeAsciiToMemory"] = writeAsciiToMemory;
      if (!Math["imul"] || Math["imul"](4294967295, 5) !== -5)
        Math["imul"] = function imul(a2, b2) {
          var ah = a2 >>> 16;
          var al = a2 & 65535;
          var bh = b2 >>> 16;
          var bl = b2 & 65535;
          return al * bl + (ah * bl + al * bh << 16) | 0;
        };
      Math.imul = Math["imul"];
      if (!Math["fround"]) {
        var froundBuffer = new Float32Array(1);
        Math["fround"] = function(x3) {
          froundBuffer[0] = x3;
          return froundBuffer[0];
        };
      }
      Math.fround = Math["fround"];
      if (!Math["clz32"])
        Math["clz32"] = function(x3) {
          x3 = x3 >>> 0;
          for (var i3 = 0; i3 < 32; i3++) {
            if (x3 & 1 << 31 - i3)
              return i3;
          }
          return 32;
        };
      Math.clz32 = Math["clz32"];
      if (!Math["trunc"])
        Math["trunc"] = function(x3) {
          return x3 < 0 ? Math.ceil(x3) : Math.floor(x3);
        };
      Math.trunc = Math["trunc"];
      var Math_abs = Math.abs;
      var Math_cos = Math.cos;
      var Math_sin = Math.sin;
      var Math_tan = Math.tan;
      var Math_acos = Math.acos;
      var Math_asin = Math.asin;
      var Math_atan = Math.atan;
      var Math_atan2 = Math.atan2;
      var Math_exp = Math.exp;
      var Math_log = Math.log;
      var Math_sqrt = Math.sqrt;
      var Math_ceil = Math.ceil;
      var Math_floor = Math.floor;
      var Math_pow = Math.pow;
      var Math_imul = Math.imul;
      var Math_fround = Math.fround;
      var Math_round = Math.round;
      var Math_min = Math.min;
      var Math_clz32 = Math.clz32;
      var Math_trunc = Math.trunc;
      var runDependencies = 0;
      var runDependencyWatcher = null;
      var dependenciesFulfilled = null;
      function getUniqueRunDependency(id) {
        return id;
      }
      function addRunDependency(id) {
        runDependencies++;
        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
      }
      Module["addRunDependency"] = addRunDependency;
      function removeRunDependency(id) {
        runDependencies--;
        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
        if (runDependencies == 0) {
          if (runDependencyWatcher !== null) {
            clearInterval(runDependencyWatcher);
            runDependencyWatcher = null;
          }
          if (dependenciesFulfilled) {
            var callback = dependenciesFulfilled;
            dependenciesFulfilled = null;
            callback();
          }
        }
      }
      Module["removeRunDependency"] = removeRunDependency;
      Module["preloadedImages"] = {};
      Module["preloadedAudios"] = {};
      var ASM_CONSTS = [function($0, $1, $22, $3, $4, $5, $6, $7) {
        return _nbind.callbackSignatureList[$0].apply(this, arguments);
      }];
      function _emscripten_asm_const_iiiiiiii(code, a0, a1, a2, a3, a4, a5, a6) {
        return ASM_CONSTS[code](a0, a1, a2, a3, a4, a5, a6);
      }
      function _emscripten_asm_const_iiiii(code, a0, a1, a2, a3) {
        return ASM_CONSTS[code](a0, a1, a2, a3);
      }
      function _emscripten_asm_const_iiidddddd(code, a0, a1, a2, a3, a4, a5, a6, a7) {
        return ASM_CONSTS[code](a0, a1, a2, a3, a4, a5, a6, a7);
      }
      function _emscripten_asm_const_iiididi(code, a0, a1, a2, a3, a4, a5) {
        return ASM_CONSTS[code](a0, a1, a2, a3, a4, a5);
      }
      function _emscripten_asm_const_iiii(code, a0, a1, a2) {
        return ASM_CONSTS[code](a0, a1, a2);
      }
      function _emscripten_asm_const_iiiid(code, a0, a1, a2, a3) {
        return ASM_CONSTS[code](a0, a1, a2, a3);
      }
      function _emscripten_asm_const_iiiiii(code, a0, a1, a2, a3, a4) {
        return ASM_CONSTS[code](a0, a1, a2, a3, a4);
      }
      STATIC_BASE = Runtime.GLOBAL_BASE;
      STATICTOP = STATIC_BASE + 12800;
      __ATINIT__.push({ func: function() {
        __GLOBAL__sub_I_Yoga_cpp();
      } }, { func: function() {
        __GLOBAL__sub_I_nbind_cc();
      } }, { func: function() {
        __GLOBAL__sub_I_common_cc();
      } }, { func: function() {
        __GLOBAL__sub_I_Binding_cc();
      } });
      allocate([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 192, 127, 0, 0, 192, 127, 0, 0, 192, 127, 3, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 3, 0, 0, 0, 0, 0, 192, 127, 3, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 192, 127, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 128, 191, 0, 0, 128, 191, 0, 0, 192, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 63, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 190, 12, 0, 0, 200, 12, 0, 0, 208, 12, 0, 0, 216, 12, 0, 0, 230, 12, 0, 0, 242, 12, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 192, 127, 3, 0, 0, 0, 180, 45, 0, 0, 181, 45, 0, 0, 182, 45, 0, 0, 181, 45, 0, 0, 182, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 183, 45, 0, 0, 181, 45, 0, 0, 181, 45, 0, 0, 181, 45, 0, 0, 181, 45, 0, 0, 181, 45, 0, 0, 181, 45, 0, 0, 184, 45, 0, 0, 185, 45, 0, 0, 181, 45, 0, 0, 181, 45, 0, 0, 182, 45, 0, 0, 186, 45, 0, 0, 185, 45, 0, 0, 148, 4, 0, 0, 3, 0, 0, 0, 187, 45, 0, 0, 164, 4, 0, 0, 188, 45, 0, 0, 2, 0, 0, 0, 189, 45, 0, 0, 164, 4, 0, 0, 188, 45, 0, 0, 185, 45, 0, 0, 164, 4, 0, 0, 185, 45, 0, 0, 164, 4, 0, 0, 188, 45, 0, 0, 181, 45, 0, 0, 182, 45, 0, 0, 181, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 5, 0, 0, 0, 6, 0, 0, 0, 1, 0, 0, 0, 7, 0, 0, 0, 183, 45, 0, 0, 182, 45, 0, 0, 181, 45, 0, 0, 190, 45, 0, 0, 190, 45, 0, 0, 182, 45, 0, 0, 182, 45, 0, 0, 185, 45, 0, 0, 181, 45, 0, 0, 185, 45, 0, 0, 182, 45, 0, 0, 181, 45, 0, 0, 185, 45, 0, 0, 182, 45, 0, 0, 185, 45, 0, 0, 48, 5, 0, 0, 3, 0, 0, 0, 56, 5, 0, 0, 1, 0, 0, 0, 189, 45, 0, 0, 185, 45, 0, 0, 164, 4, 0, 0, 76, 5, 0, 0, 2, 0, 0, 0, 191, 45, 0, 0, 186, 45, 0, 0, 182, 45, 0, 0, 185, 45, 0, 0, 192, 45, 0, 0, 185, 45, 0, 0, 182, 45, 0, 0, 186, 45, 0, 0, 185, 45, 0, 0, 76, 5, 0, 0, 76, 5, 0, 0, 136, 5, 0, 0, 182, 45, 0, 0, 181, 45, 0, 0, 2, 0, 0, 0, 190, 45, 0, 0, 136, 5, 0, 0, 56, 19, 0, 0, 156, 5, 0, 0, 2, 0, 0, 0, 184, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 8, 0, 0, 0, 9, 0, 0, 0, 1, 0, 0, 0, 10, 0, 0, 0, 204, 5, 0, 0, 181, 45, 0, 0, 181, 45, 0, 0, 2, 0, 0, 0, 180, 45, 0, 0, 204, 5, 0, 0, 2, 0, 0, 0, 195, 45, 0, 0, 236, 5, 0, 0, 97, 19, 0, 0, 198, 45, 0, 0, 211, 45, 0, 0, 212, 45, 0, 0, 213, 45, 0, 0, 214, 45, 0, 0, 215, 45, 0, 0, 188, 45, 0, 0, 182, 45, 0, 0, 216, 45, 0, 0, 217, 45, 0, 0, 218, 45, 0, 0, 219, 45, 0, 0, 192, 45, 0, 0, 181, 45, 0, 0, 0, 0, 0, 0, 185, 45, 0, 0, 110, 19, 0, 0, 186, 45, 0, 0, 115, 19, 0, 0, 221, 45, 0, 0, 120, 19, 0, 0, 148, 4, 0, 0, 132, 19, 0, 0, 96, 6, 0, 0, 145, 19, 0, 0, 222, 45, 0, 0, 164, 19, 0, 0, 223, 45, 0, 0, 173, 19, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 104, 6, 0, 0, 1, 0, 0, 0, 187, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 11, 0, 0, 0, 12, 0, 0, 0, 1, 0, 0, 0, 13, 0, 0, 0, 185, 45, 0, 0, 224, 45, 0, 0, 164, 6, 0, 0, 188, 45, 0, 0, 172, 6, 0, 0, 180, 6, 0, 0, 2, 0, 0, 0, 188, 6, 0, 0, 7, 0, 0, 0, 224, 45, 0, 0, 7, 0, 0, 0, 164, 6, 0, 0, 1, 0, 0, 0, 213, 45, 0, 0, 185, 45, 0, 0, 224, 45, 0, 0, 172, 6, 0, 0, 185, 45, 0, 0, 224, 45, 0, 0, 164, 6, 0, 0, 185, 45, 0, 0, 224, 45, 0, 0, 211, 45, 0, 0, 211, 45, 0, 0, 222, 45, 0, 0, 211, 45, 0, 0, 224, 45, 0, 0, 222, 45, 0, 0, 211, 45, 0, 0, 224, 45, 0, 0, 172, 6, 0, 0, 222, 45, 0, 0, 211, 45, 0, 0, 224, 45, 0, 0, 188, 45, 0, 0, 222, 45, 0, 0, 211, 45, 0, 0, 40, 7, 0, 0, 188, 45, 0, 0, 2, 0, 0, 0, 224, 45, 0, 0, 185, 45, 0, 0, 188, 45, 0, 0, 188, 45, 0, 0, 188, 45, 0, 0, 188, 45, 0, 0, 222, 45, 0, 0, 224, 45, 0, 0, 148, 4, 0, 0, 185, 45, 0, 0, 148, 4, 0, 0, 148, 4, 0, 0, 148, 4, 0, 0, 148, 4, 0, 0, 148, 4, 0, 0, 185, 45, 0, 0, 164, 6, 0, 0, 148, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 14, 0, 0, 0, 15, 0, 0, 0, 1, 0, 0, 0, 16, 0, 0, 0, 148, 7, 0, 0, 2, 0, 0, 0, 225, 45, 0, 0, 183, 45, 0, 0, 188, 45, 0, 0, 168, 7, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 234, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 148, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 9, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 2, 0, 0, 0, 242, 45, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 111, 117, 108, 100, 32, 110, 111, 116, 32, 97, 108, 108, 111, 99, 97, 116, 101, 32, 109, 101, 109, 111, 114, 121, 32, 102, 111, 114, 32, 110, 111, 100, 101, 0, 67, 97, 110, 110, 111, 116, 32, 114, 101, 115, 101, 116, 32, 97, 32, 110, 111, 100, 101, 32, 119, 104, 105, 99, 104, 32, 115, 116, 105, 108, 108, 32, 104, 97, 115, 32, 99, 104, 105, 108, 100, 114, 101, 110, 32, 97, 116, 116, 97, 99, 104, 101, 100, 0, 67, 97, 110, 110, 111, 116, 32, 114, 101, 115, 101, 116, 32, 97, 32, 110, 111, 100, 101, 32, 115, 116, 105, 108, 108, 32, 97, 116, 116, 97, 99, 104, 101, 100, 32, 116, 111, 32, 97, 32, 112, 97, 114, 101, 110, 116, 0, 67, 111, 117, 108, 100, 32, 110, 111, 116, 32, 97, 108, 108, 111, 99, 97, 116, 101, 32, 109, 101, 109, 111, 114, 121, 32, 102, 111, 114, 32, 99, 111, 110, 102, 105, 103, 0, 67, 97, 110, 110, 111, 116, 32, 115, 101, 116, 32, 109, 101, 97, 115, 117, 114, 101, 32, 102, 117, 110, 99, 116, 105, 111, 110, 58, 32, 78, 111, 100, 101, 115, 32, 119, 105, 116, 104, 32, 109, 101, 97, 115, 117, 114, 101, 32, 102, 117, 110, 99, 116, 105, 111, 110, 115, 32, 99, 97, 110, 110, 111, 116, 32, 104, 97, 118, 101, 32, 99, 104, 105, 108, 100, 114, 101, 110, 46, 0, 67, 104, 105, 108, 100, 32, 97, 108, 114, 101, 97, 100, 121, 32, 104, 97, 115, 32, 97, 32, 112, 97, 114, 101, 110, 116, 44, 32, 105, 116, 32, 109, 117, 115, 116, 32, 98, 101, 32, 114, 101, 109, 111, 118, 101, 100, 32, 102, 105, 114, 115, 116, 46, 0, 67, 97, 110, 110, 111, 116, 32, 97, 100, 100, 32, 99, 104, 105, 108, 100, 58, 32, 78, 111, 100, 101, 115, 32, 119, 105, 116, 104, 32, 109, 101, 97, 115, 117, 114, 101, 32, 102, 117, 110, 99, 116, 105, 111, 110, 115, 32, 99, 97, 110, 110, 111, 116, 32, 104, 97, 118, 101, 32, 99, 104, 105, 108, 100, 114, 101, 110, 46, 0, 79, 110, 108, 121, 32, 108, 101, 97, 102, 32, 110, 111, 100, 101, 115, 32, 119, 105, 116, 104, 32, 99, 117, 115, 116, 111, 109, 32, 109, 101, 97, 115, 117, 114, 101, 32, 102, 117, 110, 99, 116, 105, 111, 110, 115, 115, 104, 111, 117, 108, 100, 32, 109, 97, 110, 117, 97, 108, 108, 121, 32, 109, 97, 114, 107, 32, 116, 104, 101, 109, 115, 101, 108, 118, 101, 115, 32, 97, 115, 32, 100, 105, 114, 116, 121, 0, 67, 97, 110, 110, 111, 116, 32, 103, 101, 116, 32, 108, 97, 121, 111, 117, 116, 32, 112, 114, 111, 112, 101, 114, 116, 105, 101, 115, 32, 111, 102, 32, 109, 117, 108, 116, 105, 45, 101, 100, 103, 101, 32, 115, 104, 111, 114, 116, 104, 97, 110, 100, 115, 0, 37, 115, 37, 100, 46, 123, 91, 115, 107, 105, 112, 112, 101, 100, 93, 32, 0, 119, 109, 58, 32, 37, 115, 44, 32, 104, 109, 58, 32, 37, 115, 44, 32, 97, 119, 58, 32, 37, 102, 32, 97, 104, 58, 32, 37, 102, 32, 61, 62, 32, 100, 58, 32, 40, 37, 102, 44, 32, 37, 102, 41, 32, 37, 115, 10, 0, 37, 115, 37, 100, 46, 123, 37, 115, 0, 42, 0, 119, 109, 58, 32, 37, 115, 44, 32, 104, 109, 58, 32, 37, 115, 44, 32, 97, 119, 58, 32, 37, 102, 32, 97, 104, 58, 32, 37, 102, 32, 37, 115, 10, 0, 37, 115, 37, 100, 46, 125, 37, 115, 0, 119, 109, 58, 32, 37, 115, 44, 32, 104, 109, 58, 32, 37, 115, 44, 32, 100, 58, 32, 40, 37, 102, 44, 32, 37, 102, 41, 32, 37, 115, 10, 0, 79, 117, 116, 32, 111, 102, 32, 99, 97, 99, 104, 101, 32, 101, 110, 116, 114, 105, 101, 115, 33, 10, 0, 83, 99, 97, 108, 101, 32, 102, 97, 99, 116, 111, 114, 32, 115, 104, 111, 117, 108, 100, 32, 110, 111, 116, 32, 98, 101, 32, 108, 101, 115, 115, 32, 116, 104, 97, 110, 32, 122, 101, 114, 111, 0, 105, 110, 105, 116, 105, 97, 108, 0, 37, 115, 10, 0, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 0, 85, 78, 68, 69, 70, 73, 78, 69, 68, 0, 69, 88, 65, 67, 84, 76, 89, 0, 65, 84, 95, 77, 79, 83, 84, 0, 76, 65, 89, 95, 85, 78, 68, 69, 70, 73, 78, 69, 68, 0, 76, 65, 89, 95, 69, 88, 65, 67, 84, 76, 89, 0, 76, 65, 89, 95, 65, 84, 95, 77, 79, 83, 84, 0, 97, 118, 97, 105, 108, 97, 98, 108, 101, 87, 105, 100, 116, 104, 32, 105, 115, 32, 105, 110, 100, 101, 102, 105, 110, 105, 116, 101, 32, 115, 111, 32, 119, 105, 100, 116, 104, 77, 101, 97, 115, 117, 114, 101, 77, 111, 100, 101, 32, 109, 117, 115, 116, 32, 98, 101, 32, 89, 71, 77, 101, 97, 115, 117, 114, 101, 77, 111, 100, 101, 85, 110, 100, 101, 102, 105, 110, 101, 100, 0, 97, 118, 97, 105, 108, 97, 98, 108, 101, 72, 101, 105, 103, 104, 116, 32, 105, 115, 32, 105, 110, 100, 101, 102, 105, 110, 105, 116, 101, 32, 115, 111, 32, 104, 101, 105, 103, 104, 116, 77, 101, 97, 115, 117, 114, 101, 77, 111, 100, 101, 32, 109, 117, 115, 116, 32, 98, 101, 32, 89, 71, 77, 101, 97, 115, 117, 114, 101, 77, 111, 100, 101, 85, 110, 100, 101, 102, 105, 110, 101, 100, 0, 102, 108, 101, 120, 0, 115, 116, 114, 101, 116, 99, 104, 0, 109, 117, 108, 116, 105, 108, 105, 110, 101, 45, 115, 116, 114, 101, 116, 99, 104, 0, 69, 120, 112, 101, 99, 116, 101, 100, 32, 110, 111, 100, 101, 32, 116, 111, 32, 104, 97, 118, 101, 32, 99, 117, 115, 116, 111, 109, 32, 109, 101, 97, 115, 117, 114, 101, 32, 102, 117, 110, 99, 116, 105, 111, 110, 0, 109, 101, 97, 115, 117, 114, 101, 0, 69, 120, 112, 101, 99, 116, 32, 99, 117, 115, 116, 111, 109, 32, 98, 97, 115, 101, 108, 105, 110, 101, 32, 102, 117, 110, 99, 116, 105, 111, 110, 32, 116, 111, 32, 110, 111, 116, 32, 114, 101, 116, 117, 114, 110, 32, 78, 97, 78, 0, 97, 98, 115, 45, 109, 101, 97, 115, 117, 114, 101, 0, 97, 98, 115, 45, 108, 97, 121, 111, 117, 116, 0, 78, 111, 100, 101, 0, 99, 114, 101, 97, 116, 101, 68, 101, 102, 97, 117, 108, 116, 0, 99, 114, 101, 97, 116, 101, 87, 105, 116, 104, 67, 111, 110, 102, 105, 103, 0, 100, 101, 115, 116, 114, 111, 121, 0, 114, 101, 115, 101, 116, 0, 99, 111, 112, 121, 83, 116, 121, 108, 101, 0, 115, 101, 116, 80, 111, 115, 105, 116, 105, 111, 110, 84, 121, 112, 101, 0, 115, 101, 116, 80, 111, 115, 105, 116, 105, 111, 110, 0, 115, 101, 116, 80, 111, 115, 105, 116, 105, 111, 110, 80, 101, 114, 99, 101, 110, 116, 0, 115, 101, 116, 65, 108, 105, 103, 110, 67, 111, 110, 116, 101, 110, 116, 0, 115, 101, 116, 65, 108, 105, 103, 110, 73, 116, 101, 109, 115, 0, 115, 101, 116, 65, 108, 105, 103, 110, 83, 101, 108, 102, 0, 115, 101, 116, 70, 108, 101, 120, 68, 105, 114, 101, 99, 116, 105, 111, 110, 0, 115, 101, 116, 70, 108, 101, 120, 87, 114, 97, 112, 0, 115, 101, 116, 74, 117, 115, 116, 105, 102, 121, 67, 111, 110, 116, 101, 110, 116, 0, 115, 101, 116, 77, 97, 114, 103, 105, 110, 0, 115, 101, 116, 77, 97, 114, 103, 105, 110, 80, 101, 114, 99, 101, 110, 116, 0, 115, 101, 116, 77, 97, 114, 103, 105, 110, 65, 117, 116, 111, 0, 115, 101, 116, 79, 118, 101, 114, 102, 108, 111, 119, 0, 115, 101, 116, 68, 105, 115, 112, 108, 97, 121, 0, 115, 101, 116, 70, 108, 101, 120, 0, 115, 101, 116, 70, 108, 101, 120, 66, 97, 115, 105, 115, 0, 115, 101, 116, 70, 108, 101, 120, 66, 97, 115, 105, 115, 80, 101, 114, 99, 101, 110, 116, 0, 115, 101, 116, 70, 108, 101, 120, 71, 114, 111, 119, 0, 115, 101, 116, 70, 108, 101, 120, 83, 104, 114, 105, 110, 107, 0, 115, 101, 116, 87, 105, 100, 116, 104, 0, 115, 101, 116, 87, 105, 100, 116, 104, 80, 101, 114, 99, 101, 110, 116, 0, 115, 101, 116, 87, 105, 100, 116, 104, 65, 117, 116, 111, 0, 115, 101, 116, 72, 101, 105, 103, 104, 116, 0, 115, 101, 116, 72, 101, 105, 103, 104, 116, 80, 101, 114, 99, 101, 110, 116, 0, 115, 101, 116, 72, 101, 105, 103, 104, 116, 65, 117, 116, 111, 0, 115, 101, 116, 77, 105, 110, 87, 105, 100, 116, 104, 0, 115, 101, 116, 77, 105, 110, 87, 105, 100, 116, 104, 80, 101, 114, 99, 101, 110, 116, 0, 115, 101, 116, 77, 105, 110, 72, 101, 105, 103, 104, 116, 0, 115, 101, 116, 77, 105, 110, 72, 101, 105, 103, 104, 116, 80, 101, 114, 99, 101, 110, 116, 0, 115, 101, 116, 77, 97, 120, 87, 105, 100, 116, 104, 0, 115, 101, 116, 77, 97, 120, 87, 105, 100, 116, 104, 80, 101, 114, 99, 101, 110, 116, 0, 115, 101, 116, 77, 97, 120, 72, 101, 105, 103, 104, 116, 0, 115, 101, 116, 77, 97, 120, 72, 101, 105, 103, 104, 116, 80, 101, 114, 99, 101, 110, 116, 0, 115, 101, 116, 65, 115, 112, 101, 99, 116, 82, 97, 116, 105, 111, 0, 115, 101, 116, 66, 111, 114, 100, 101, 114, 0, 115, 101, 116, 80, 97, 100, 100, 105, 110, 103, 0, 115, 101, 116, 80, 97, 100, 100, 105, 110, 103, 80, 101, 114, 99, 101, 110, 116, 0, 103, 101, 116, 80, 111, 115, 105, 116, 105, 111, 110, 84, 121, 112, 101, 0, 103, 101, 116, 80, 111, 115, 105, 116, 105, 111, 110, 0, 103, 101, 116, 65, 108, 105, 103, 110, 67, 111, 110, 116, 101, 110, 116, 0, 103, 101, 116, 65, 108, 105, 103, 110, 73, 116, 101, 109, 115, 0, 103, 101, 116, 65, 108, 105, 103, 110, 83, 101, 108, 102, 0, 103, 101, 116, 70, 108, 101, 120, 68, 105, 114, 101, 99, 116, 105, 111, 110, 0, 103, 101, 116, 70, 108, 101, 120, 87, 114, 97, 112, 0, 103, 101, 116, 74, 117, 115, 116, 105, 102, 121, 67, 111, 110, 116, 101, 110, 116, 0, 103, 101, 116, 77, 97, 114, 103, 105, 110, 0, 103, 101, 116, 70, 108, 101, 120, 66, 97, 115, 105, 115, 0, 103, 101, 116, 70, 108, 101, 120, 71, 114, 111, 119, 0, 103, 101, 116, 70, 108, 101, 120, 83, 104, 114, 105, 110, 107, 0, 103, 101, 116, 87, 105, 100, 116, 104, 0, 103, 101, 116, 72, 101, 105, 103, 104, 116, 0, 103, 101, 116, 77, 105, 110, 87, 105, 100, 116, 104, 0, 103, 101, 116, 77, 105, 110, 72, 101, 105, 103, 104, 116, 0, 103, 101, 116, 77, 97, 120, 87, 105, 100, 116, 104, 0, 103, 101, 116, 77, 97, 120, 72, 101, 105, 103, 104, 116, 0, 103, 101, 116, 65, 115, 112, 101, 99, 116, 82, 97, 116, 105, 111, 0, 103, 101, 116, 66, 111, 114, 100, 101, 114, 0, 103, 101, 116, 79, 118, 101, 114, 102, 108, 111, 119, 0, 103, 101, 116, 68, 105, 115, 112, 108, 97, 121, 0, 103, 101, 116, 80, 97, 100, 100, 105, 110, 103, 0, 105, 110, 115, 101, 114, 116, 67, 104, 105, 108, 100, 0, 114, 101, 109, 111, 118, 101, 67, 104, 105, 108, 100, 0, 103, 101, 116, 67, 104, 105, 108, 100, 67, 111, 117, 110, 116, 0, 103, 101, 116, 80, 97, 114, 101, 110, 116, 0, 103, 101, 116, 67, 104, 105, 108, 100, 0, 115, 101, 116, 77, 101, 97, 115, 117, 114, 101, 70, 117, 110, 99, 0, 117, 110, 115, 101, 116, 77, 101, 97, 115, 117, 114, 101, 70, 117, 110, 99, 0, 109, 97, 114, 107, 68, 105, 114, 116, 121, 0, 105, 115, 68, 105, 114, 116, 121, 0, 99, 97, 108, 99, 117, 108, 97, 116, 101, 76, 97, 121, 111, 117, 116, 0, 103, 101, 116, 67, 111, 109, 112, 117, 116, 101, 100, 76, 101, 102, 116, 0, 103, 101, 116, 67, 111, 109, 112, 117, 116, 101, 100, 82, 105, 103, 104, 116, 0, 103, 101, 116, 67, 111, 109, 112, 117, 116, 101, 100, 84, 111, 112, 0, 103, 101, 116, 67, 111, 109, 112, 117, 116, 101, 100, 66, 111, 116, 116, 111, 109, 0, 103, 101, 116, 67, 111, 109, 112, 117, 116, 101, 100, 87, 105, 100, 116, 104, 0, 103, 101, 116, 67, 111, 109, 112, 117, 116, 101, 100, 72, 101, 105, 103, 104, 116, 0, 103, 101, 116, 67, 111, 109, 112, 117, 116, 101, 100, 76, 97, 121, 111, 117, 116, 0, 103, 101, 116, 67, 111, 109, 112, 117, 116, 101, 100, 77, 97, 114, 103, 105, 110, 0, 103, 101, 116, 67, 111, 109, 112, 117, 116, 101, 100, 66, 111, 114, 100, 101, 114, 0, 103, 101, 116, 67, 111, 109, 112, 117, 116, 101, 100, 80, 97, 100, 100, 105, 110, 103, 0, 67, 111, 110, 102, 105, 103, 0, 99, 114, 101, 97, 116, 101, 0, 115, 101, 116, 69, 120, 112, 101, 114, 105, 109, 101, 110, 116, 97, 108, 70, 101, 97, 116, 117, 114, 101, 69, 110, 97, 98, 108, 101, 100, 0, 115, 101, 116, 80, 111, 105, 110, 116, 83, 99, 97, 108, 101, 70, 97, 99, 116, 111, 114, 0, 105, 115, 69, 120, 112, 101, 114, 105, 109, 101, 110, 116, 97, 108, 70, 101, 97, 116, 117, 114, 101, 69, 110, 97, 98, 108, 101, 100, 0, 86, 97, 108, 117, 101, 0, 76, 97, 121, 111, 117, 116, 0, 83, 105, 122, 101, 0, 103, 101, 116, 73, 110, 115, 116, 97, 110, 99, 101, 67, 111, 117, 110, 116, 0, 73, 110, 116, 54, 52, 0, 1, 1, 1, 2, 2, 4, 4, 4, 4, 8, 8, 4, 8, 118, 111, 105, 100, 0, 98, 111, 111, 108, 0, 115, 116, 100, 58, 58, 115, 116, 114, 105, 110, 103, 0, 99, 98, 70, 117, 110, 99, 116, 105, 111, 110, 32, 38, 0, 99, 111, 110, 115, 116, 32, 99, 98, 70, 117, 110, 99, 116, 105, 111, 110, 32, 38, 0, 69, 120, 116, 101, 114, 110, 97, 108, 0, 66, 117, 102, 102, 101, 114, 0, 78, 66, 105, 110, 100, 73, 68, 0, 78, 66, 105, 110, 100, 0, 98, 105, 110, 100, 95, 118, 97, 108, 117, 101, 0, 114, 101, 102, 108, 101, 99, 116, 0, 113, 117, 101, 114, 121, 84, 121, 112, 101, 0, 108, 97, 108, 108, 111, 99, 0, 108, 114, 101, 115, 101, 116, 0, 123, 114, 101, 116, 117, 114, 110, 40, 95, 110, 98, 105, 110, 100, 46, 99, 97, 108, 108, 98, 97, 99, 107, 83, 105, 103, 110, 97, 116, 117, 114, 101, 76, 105, 115, 116, 91, 36, 48, 93, 46, 97, 112, 112, 108, 121, 40, 116, 104, 105, 115, 44, 97, 114, 103, 117, 109, 101, 110, 116, 115, 41, 41, 59, 125, 0, 95, 110, 98, 105, 110, 100, 95, 110, 101, 119, 0, 17, 0, 10, 0, 17, 17, 17, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 15, 10, 17, 17, 17, 3, 10, 7, 0, 1, 19, 9, 11, 11, 0, 0, 9, 6, 11, 0, 0, 11, 0, 6, 17, 0, 0, 0, 17, 17, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 10, 10, 17, 17, 17, 0, 10, 0, 0, 2, 0, 9, 11, 0, 0, 0, 9, 0, 11, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 12, 0, 0, 0, 0, 9, 12, 0, 0, 0, 0, 0, 12, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 4, 13, 0, 0, 0, 0, 9, 14, 0, 0, 0, 0, 0, 14, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 15, 0, 0, 0, 0, 9, 16, 0, 0, 0, 0, 0, 16, 0, 0, 16, 0, 0, 18, 0, 0, 0, 18, 18, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 18, 18, 18, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 10, 0, 0, 0, 0, 9, 11, 0, 0, 0, 0, 0, 11, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 12, 0, 0, 0, 0, 9, 12, 0, 0, 0, 0, 0, 12, 0, 0, 12, 0, 0, 45, 43, 32, 32, 32, 48, 88, 48, 120, 0, 40, 110, 117, 108, 108, 41, 0, 45, 48, 88, 43, 48, 88, 32, 48, 88, 45, 48, 120, 43, 48, 120, 32, 48, 120, 0, 105, 110, 102, 0, 73, 78, 70, 0, 110, 97, 110, 0, 78, 65, 78, 0, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 46, 0, 84, 33, 34, 25, 13, 1, 2, 3, 17, 75, 28, 12, 16, 4, 11, 29, 18, 30, 39, 104, 110, 111, 112, 113, 98, 32, 5, 6, 15, 19, 20, 21, 26, 8, 22, 7, 40, 36, 23, 24, 9, 10, 14, 27, 31, 37, 35, 131, 130, 125, 38, 42, 43, 60, 61, 62, 63, 67, 71, 74, 77, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 99, 100, 101, 102, 103, 105, 106, 107, 108, 114, 115, 116, 121, 122, 123, 124, 0, 73, 108, 108, 101, 103, 97, 108, 32, 98, 121, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101, 0, 68, 111, 109, 97, 105, 110, 32, 101, 114, 114, 111, 114, 0, 82, 101, 115, 117, 108, 116, 32, 110, 111, 116, 32, 114, 101, 112, 114, 101, 115, 101, 110, 116, 97, 98, 108, 101, 0, 78, 111, 116, 32, 97, 32, 116, 116, 121, 0, 80, 101, 114, 109, 105, 115, 115, 105, 111, 110, 32, 100, 101, 110, 105, 101, 100, 0, 79, 112, 101, 114, 97, 116, 105, 111, 110, 32, 110, 111, 116, 32, 112, 101, 114, 109, 105, 116, 116, 101, 100, 0, 78, 111, 32, 115, 117, 99, 104, 32, 102, 105, 108, 101, 32, 111, 114, 32, 100, 105, 114, 101, 99, 116, 111, 114, 121, 0, 78, 111, 32, 115, 117, 99, 104, 32, 112, 114, 111, 99, 101, 115, 115, 0, 70, 105, 108, 101, 32, 101, 120, 105, 115, 116, 115, 0, 86, 97, 108, 117, 101, 32, 116, 111, 111, 32, 108, 97, 114, 103, 101, 32, 102, 111, 114, 32, 100, 97, 116, 97, 32, 116, 121, 112, 101, 0, 78, 111, 32, 115, 112, 97, 99, 101, 32, 108, 101, 102, 116, 32, 111, 110, 32, 100, 101, 118, 105, 99, 101, 0, 79, 117, 116, 32, 111, 102, 32, 109, 101, 109, 111, 114, 121, 0, 82, 101, 115, 111, 117, 114, 99, 101, 32, 98, 117, 115, 121, 0, 73, 110, 116, 101, 114, 114, 117, 112, 116, 101, 100, 32, 115, 121, 115, 116, 101, 109, 32, 99, 97, 108, 108, 0, 82, 101, 115, 111, 117, 114, 99, 101, 32, 116, 101, 109, 112, 111, 114, 97, 114, 105, 108, 121, 32, 117, 110, 97, 118, 97, 105, 108, 97, 98, 108, 101, 0, 73, 110, 118, 97, 108, 105, 100, 32, 115, 101, 101, 107, 0, 67, 114, 111, 115, 115, 45, 100, 101, 118, 105, 99, 101, 32, 108, 105, 110, 107, 0, 82, 101, 97, 100, 45, 111, 110, 108, 121, 32, 102, 105, 108, 101, 32, 115, 121, 115, 116, 101, 109, 0, 68, 105, 114, 101, 99, 116, 111, 114, 121, 32, 110, 111, 116, 32, 101, 109, 112, 116, 121, 0, 67, 111, 110, 110, 101, 99, 116, 105, 111, 110, 32, 114, 101, 115, 101, 116, 32, 98, 121, 32, 112, 101, 101, 114, 0, 79, 112, 101, 114, 97, 116, 105, 111, 110, 32, 116, 105, 109, 101, 100, 32, 111, 117, 116, 0, 67, 111, 110, 110, 101, 99, 116, 105, 111, 110, 32, 114, 101, 102, 117, 115, 101, 100, 0, 72, 111, 115, 116, 32, 105, 115, 32, 100, 111, 119, 110, 0, 72, 111, 115, 116, 32, 105, 115, 32, 117, 110, 114, 101, 97, 99, 104, 97, 98, 108, 101, 0, 65, 100, 100, 114, 101, 115, 115, 32, 105, 110, 32, 117, 115, 101, 0, 66, 114, 111, 107, 101, 110, 32, 112, 105, 112, 101, 0, 73, 47, 79, 32, 101, 114, 114, 111, 114, 0, 78, 111, 32, 115, 117, 99, 104, 32, 100, 101, 118, 105, 99, 101, 32, 111, 114, 32, 97, 100, 100, 114, 101, 115, 115, 0, 66, 108, 111, 99, 107, 32, 100, 101, 118, 105, 99, 101, 32, 114, 101, 113, 117, 105, 114, 101, 100, 0, 78, 111, 32, 115, 117, 99, 104, 32, 100, 101, 118, 105, 99, 101, 0, 78, 111, 116, 32, 97, 32, 100, 105, 114, 101, 99, 116, 111, 114, 121, 0, 73, 115, 32, 97, 32, 100, 105, 114, 101, 99, 116, 111, 114, 121, 0, 84, 101, 120, 116, 32, 102, 105, 108, 101, 32, 98, 117, 115, 121, 0, 69, 120, 101, 99, 32, 102, 111, 114, 109, 97, 116, 32, 101, 114, 114, 111, 114, 0, 73, 110, 118, 97, 108, 105, 100, 32, 97, 114, 103, 117, 109, 101, 110, 116, 0, 65, 114, 103, 117, 109, 101, 110, 116, 32, 108, 105, 115, 116, 32, 116, 111, 111, 32, 108, 111, 110, 103, 0, 83, 121, 109, 98, 111, 108, 105, 99, 32, 108, 105, 110, 107, 32, 108, 111, 111, 112, 0, 70, 105, 108, 101, 110, 97, 109, 101, 32, 116, 111, 111, 32, 108, 111, 110, 103, 0, 84, 111, 111, 32, 109, 97, 110, 121, 32, 111, 112, 101, 110, 32, 102, 105, 108, 101, 115, 32, 105, 110, 32, 115, 121, 115, 116, 101, 109, 0, 78, 111, 32, 102, 105, 108, 101, 32, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 115, 32, 97, 118, 97, 105, 108, 97, 98, 108, 101, 0, 66, 97, 100, 32, 102, 105, 108, 101, 32, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 0, 78, 111, 32, 99, 104, 105, 108, 100, 32, 112, 114, 111, 99, 101, 115, 115, 0, 66, 97, 100, 32, 97, 100, 100, 114, 101, 115, 115, 0, 70, 105, 108, 101, 32, 116, 111, 111, 32, 108, 97, 114, 103, 101, 0, 84, 111, 111, 32, 109, 97, 110, 121, 32, 108, 105, 110, 107, 115, 0, 78, 111, 32, 108, 111, 99, 107, 115, 32, 97, 118, 97, 105, 108, 97, 98, 108, 101, 0, 82, 101, 115, 111, 117, 114, 99, 101, 32, 100, 101, 97, 100, 108, 111, 99, 107, 32, 119, 111, 117, 108, 100, 32, 111, 99, 99, 117, 114, 0, 83, 116, 97, 116, 101, 32, 110, 111, 116, 32, 114, 101, 99, 111, 118, 101, 114, 97, 98, 108, 101, 0, 80, 114, 101, 118, 105, 111, 117, 115, 32, 111, 119, 110, 101, 114, 32, 100, 105, 101, 100, 0, 79, 112, 101, 114, 97, 116, 105, 111, 110, 32, 99, 97, 110, 99, 101, 108, 101, 100, 0, 70, 117, 110, 99, 116, 105, 111, 110, 32, 110, 111, 116, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 101, 100, 0, 78, 111, 32, 109, 101, 115, 115, 97, 103, 101, 32, 111, 102, 32, 100, 101, 115, 105, 114, 101, 100, 32, 116, 121, 112, 101, 0, 73, 100, 101, 110, 116, 105, 102, 105, 101, 114, 32, 114, 101, 109, 111, 118, 101, 100, 0, 68, 101, 118, 105, 99, 101, 32, 110, 111, 116, 32, 97, 32, 115, 116, 114, 101, 97, 109, 0, 78, 111, 32, 100, 97, 116, 97, 32, 97, 118, 97, 105, 108, 97, 98, 108, 101, 0, 68, 101, 118, 105, 99, 101, 32, 116, 105, 109, 101, 111, 117, 116, 0, 79, 117, 116, 32, 111, 102, 32, 115, 116, 114, 101, 97, 109, 115, 32, 114, 101, 115, 111, 117, 114, 99, 101, 115, 0, 76, 105, 110, 107, 32, 104, 97, 115, 32, 98, 101, 101, 110, 32, 115, 101, 118, 101, 114, 101, 100, 0, 80, 114, 111, 116, 111, 99, 111, 108, 32, 101, 114, 114, 111, 114, 0, 66, 97, 100, 32, 109, 101, 115, 115, 97, 103, 101, 0, 70, 105, 108, 101, 32, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 32, 105, 110, 32, 98, 97, 100, 32, 115, 116, 97, 116, 101, 0, 78, 111, 116, 32, 97, 32, 115, 111, 99, 107, 101, 116, 0, 68, 101, 115, 116, 105, 110, 97, 116, 105, 111, 110, 32, 97, 100, 100, 114, 101, 115, 115, 32, 114, 101, 113, 117, 105, 114, 101, 100, 0, 77, 101, 115, 115, 97, 103, 101, 32, 116, 111, 111, 32, 108, 97, 114, 103, 101, 0, 80, 114, 111, 116, 111, 99, 111, 108, 32, 119, 114, 111, 110, 103, 32, 116, 121, 112, 101, 32, 102, 111, 114, 32, 115, 111, 99, 107, 101, 116, 0, 80, 114, 111, 116, 111, 99, 111, 108, 32, 110, 111, 116, 32, 97, 118, 97, 105, 108, 97, 98, 108, 101, 0, 80, 114, 111, 116, 111, 99, 111, 108, 32, 110, 111, 116, 32, 115, 117, 112, 112, 111, 114, 116, 101, 100, 0, 83, 111, 99, 107, 101, 116, 32, 116, 121, 112, 101, 32, 110, 111, 116, 32, 115, 117, 112, 112, 111, 114, 116, 101, 100, 0, 78, 111, 116, 32, 115, 117, 112, 112, 111, 114, 116, 101, 100, 0, 80, 114, 111, 116, 111, 99, 111, 108, 32, 102, 97, 109, 105, 108, 121, 32, 110, 111, 116, 32, 115, 117, 112, 112, 111, 114, 116, 101, 100, 0, 65, 100, 100, 114, 101, 115, 115, 32, 102, 97, 109, 105, 108, 121, 32, 110, 111, 116, 32, 115, 117, 112, 112, 111, 114, 116, 101, 100, 32, 98, 121, 32, 112, 114, 111, 116, 111, 99, 111, 108, 0, 65, 100, 100, 114, 101, 115, 115, 32, 110, 111, 116, 32, 97, 118, 97, 105, 108, 97, 98, 108, 101, 0, 78, 101, 116, 119, 111, 114, 107, 32, 105, 115, 32, 100, 111, 119, 110, 0, 78, 101, 116, 119, 111, 114, 107, 32, 117, 110, 114, 101, 97, 99, 104, 97, 98, 108, 101, 0, 67, 111, 110, 110, 101, 99, 116, 105, 111, 110, 32, 114, 101, 115, 101, 116, 32, 98, 121, 32, 110, 101, 116, 119, 111, 114, 107, 0, 67, 111, 110, 110, 101, 99, 116, 105, 111, 110, 32, 97, 98, 111, 114, 116, 101, 100, 0, 78, 111, 32, 98, 117, 102, 102, 101, 114, 32, 115, 112, 97, 99, 101, 32, 97, 118, 97, 105, 108, 97, 98, 108, 101, 0, 83, 111, 99, 107, 101, 116, 32, 105, 115, 32, 99, 111, 110, 110, 101, 99, 116, 101, 100, 0, 83, 111, 99, 107, 101, 116, 32, 110, 111, 116, 32, 99, 111, 110, 110, 101, 99, 116, 101, 100, 0, 67, 97, 110, 110, 111, 116, 32, 115, 101, 110, 100, 32, 97, 102, 116, 101, 114, 32, 115, 111, 99, 107, 101, 116, 32, 115, 104, 117, 116, 100, 111, 119, 110, 0, 79, 112, 101, 114, 97, 116, 105, 111, 110, 32, 97, 108, 114, 101, 97, 100, 121, 32, 105, 110, 32, 112, 114, 111, 103, 114, 101, 115, 115, 0, 79, 112, 101, 114, 97, 116, 105, 111, 110, 32, 105, 110, 32, 112, 114, 111, 103, 114, 101, 115, 115, 0, 83, 116, 97, 108, 101, 32, 102, 105, 108, 101, 32, 104, 97, 110, 100, 108, 101, 0, 82, 101, 109, 111, 116, 101, 32, 73, 47, 79, 32, 101, 114, 114, 111, 114, 0, 81, 117, 111, 116, 97, 32, 101, 120, 99, 101, 101, 100, 101, 100, 0, 78, 111, 32, 109, 101, 100, 105, 117, 109, 32, 102, 111, 117, 110, 100, 0, 87, 114, 111, 110, 103, 32, 109, 101, 100, 105, 117, 109, 32, 116, 121, 112, 101, 0, 78, 111, 32, 101, 114, 114, 111, 114, 32, 105, 110, 102, 111, 114, 109, 97, 116, 105, 111, 110, 0, 0], "i8", ALLOC_NONE, Runtime.GLOBAL_BASE);
      var tempDoublePtr = STATICTOP;
      STATICTOP += 16;
      function _atexit(func2, arg2) {
        __ATEXIT__.unshift({ func: func2, arg: arg2 });
      }
      function ___cxa_atexit() {
        return _atexit.apply(null, arguments);
      }
      function _abort() {
        Module["abort"]();
      }
      function __ZN8facebook4yoga14YGNodeToStringEPNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEP6YGNode14YGPrintOptionsj() {
        Module["printErr"]("missing function: _ZN8facebook4yoga14YGNodeToStringEPNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEP6YGNode14YGPrintOptionsj");
        abort(-1);
      }
      function __decorate(decorators, target, key2, desc) {
        var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key2, desc);
        else
          for (var i3 = decorators.length - 1; i3 >= 0; i3--)
            if (d3 = decorators[i3])
              r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
        return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
      }
      function _defineHidden(value) {
        return function(target, key2) {
          Object.defineProperty(target, key2, { configurable: false, enumerable: false, value, writable: true });
        };
      }
      var _nbind = {};
      function __nbind_free_external(num2) {
        _nbind.externalList[num2].dereference(num2);
      }
      function __nbind_reference_external(num2) {
        _nbind.externalList[num2].reference();
      }
      function _llvm_stackrestore(p3) {
        var self2 = _llvm_stacksave;
        var ret = self2.LLVM_SAVEDSTACKS[p3];
        self2.LLVM_SAVEDSTACKS.splice(p3, 1);
        Runtime.stackRestore(ret);
      }
      function __nbind_register_pool(pageSize, usedPtr, rootPtr, pagePtr) {
        _nbind.Pool.pageSize = pageSize;
        _nbind.Pool.usedPtr = usedPtr / 4;
        _nbind.Pool.rootPtr = rootPtr;
        _nbind.Pool.pagePtr = pagePtr / 4;
        HEAP32[usedPtr / 4] = 16909060;
        if (HEAP8[usedPtr] == 1)
          _nbind.bigEndian = true;
        HEAP32[usedPtr / 4] = 0;
        _nbind.makeTypeKindTbl = (_a2 = {}, _a2[1024] = _nbind.PrimitiveType, _a2[64] = _nbind.Int64Type, _a2[2048] = _nbind.BindClass, _a2[3072] = _nbind.BindClassPtr, _a2[4096] = _nbind.SharedClassPtr, _a2[5120] = _nbind.ArrayType, _a2[6144] = _nbind.ArrayType, _a2[7168] = _nbind.CStringType, _a2[9216] = _nbind.CallbackType, _a2[10240] = _nbind.BindType, _a2);
        _nbind.makeTypeNameTbl = { "Buffer": _nbind.BufferType, "External": _nbind.ExternalType, "Int64": _nbind.Int64Type, "_nbind_new": _nbind.CreateValueType, "bool": _nbind.BooleanType, "cbFunction &": _nbind.CallbackType, "const cbFunction &": _nbind.CallbackType, "const std::string &": _nbind.StringType, "std::string": _nbind.StringType };
        Module["toggleLightGC"] = _nbind.toggleLightGC;
        _nbind.callUpcast = Module["dynCall_ii"];
        var globalScope = _nbind.makeType(_nbind.constructType, { flags: 2048, id: 0, name: "" });
        globalScope.proto = Module;
        _nbind.BindClass.list.push(globalScope);
        var _a2;
      }
      function _emscripten_set_main_loop_timing(mode, value) {
        Browser.mainLoop.timingMode = mode;
        Browser.mainLoop.timingValue = value;
        if (!Browser.mainLoop.func) {
          return 1;
        }
        if (mode == 0) {
          Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setTimeout() {
            var timeUntilNextTick = Math.max(0, Browser.mainLoop.tickStartTime + value - _emscripten_get_now()) | 0;
            setTimeout(Browser.mainLoop.runner, timeUntilNextTick);
          };
          Browser.mainLoop.method = "timeout";
        } else if (mode == 1) {
          Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_rAF() {
            Browser.requestAnimationFrame(Browser.mainLoop.runner);
          };
          Browser.mainLoop.method = "rAF";
        } else if (mode == 2) {
          if (!window["setImmediate"]) {
            let Browser_setImmediate_messageHandler2 = function(event) {
              if (event.source === window && event.data === emscriptenMainLoopMessageId) {
                event.stopPropagation();
                setImmediates.shift()();
              }
            };
            var Browser_setImmediate_messageHandler = Browser_setImmediate_messageHandler2;
            var setImmediates = [];
            var emscriptenMainLoopMessageId = "setimmediate";
            window.addEventListener("message", Browser_setImmediate_messageHandler2, true);
            window["setImmediate"] = function Browser_emulated_setImmediate(func2) {
              setImmediates.push(func2);
              if (ENVIRONMENT_IS_WORKER) {
                if (Module["setImmediates"] === void 0)
                  Module["setImmediates"] = [];
                Module["setImmediates"].push(func2);
                window.postMessage({ target: emscriptenMainLoopMessageId });
              } else
                window.postMessage(emscriptenMainLoopMessageId, "*");
            };
          }
          Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setImmediate() {
            window["setImmediate"](Browser.mainLoop.runner);
          };
          Browser.mainLoop.method = "immediate";
        }
        return 0;
      }
      function _emscripten_get_now() {
        abort();
      }
      function _emscripten_set_main_loop(func2, fps2, simulateInfiniteLoop, arg2, noSetTiming) {
        Module["noExitRuntime"] = true;
        assert(!Browser.mainLoop.func, "emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.");
        Browser.mainLoop.func = func2;
        Browser.mainLoop.arg = arg2;
        var browserIterationFunc;
        if (typeof arg2 !== "undefined") {
          browserIterationFunc = function() {
            Module["dynCall_vi"](func2, arg2);
          };
        } else {
          browserIterationFunc = function() {
            Module["dynCall_v"](func2);
          };
        }
        var thisMainLoopId = Browser.mainLoop.currentlyRunningMainloop;
        Browser.mainLoop.runner = function Browser_mainLoop_runner() {
          if (ABORT)
            return;
          if (Browser.mainLoop.queue.length > 0) {
            var start = Date.now();
            var blocker = Browser.mainLoop.queue.shift();
            blocker.func(blocker.arg);
            if (Browser.mainLoop.remainingBlockers) {
              var remaining = Browser.mainLoop.remainingBlockers;
              var next = remaining % 1 == 0 ? remaining - 1 : Math.floor(remaining);
              if (blocker.counted) {
                Browser.mainLoop.remainingBlockers = next;
              } else {
                next = next + 0.5;
                Browser.mainLoop.remainingBlockers = (8 * remaining + next) / 9;
              }
            }
            console.log('main loop blocker "' + blocker.name + '" took ' + (Date.now() - start) + " ms");
            Browser.mainLoop.updateStatus();
            if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop)
              return;
            setTimeout(Browser.mainLoop.runner, 0);
            return;
          }
          if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop)
            return;
          Browser.mainLoop.currentFrameNumber = Browser.mainLoop.currentFrameNumber + 1 | 0;
          if (Browser.mainLoop.timingMode == 1 && Browser.mainLoop.timingValue > 1 && Browser.mainLoop.currentFrameNumber % Browser.mainLoop.timingValue != 0) {
            Browser.mainLoop.scheduler();
            return;
          } else if (Browser.mainLoop.timingMode == 0) {
            Browser.mainLoop.tickStartTime = _emscripten_get_now();
          }
          if (Browser.mainLoop.method === "timeout" && Module.ctx) {
            Module.printErr("Looks like you are rendering without using requestAnimationFrame for the main loop. You should use 0 for the frame rate in emscripten_set_main_loop in order to use requestAnimationFrame, as that can greatly improve your frame rates!");
            Browser.mainLoop.method = "";
          }
          Browser.mainLoop.runIter(browserIterationFunc);
          if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop)
            return;
          if (typeof SDL === "object" && SDL.audio && SDL.audio.queueNewAudioData)
            SDL.audio.queueNewAudioData();
          Browser.mainLoop.scheduler();
        };
        if (!noSetTiming) {
          if (fps2 && fps2 > 0)
            _emscripten_set_main_loop_timing(0, 1e3 / fps2);
          else
            _emscripten_set_main_loop_timing(1, 1);
          Browser.mainLoop.scheduler();
        }
        if (simulateInfiniteLoop) {
          throw "SimulateInfiniteLoop";
        }
      }
      var Browser = { mainLoop: { scheduler: null, method: "", currentlyRunningMainloop: 0, func: null, arg: 0, timingMode: 0, timingValue: 0, currentFrameNumber: 0, queue: [], pause: function() {
        Browser.mainLoop.scheduler = null;
        Browser.mainLoop.currentlyRunningMainloop++;
      }, resume: function() {
        Browser.mainLoop.currentlyRunningMainloop++;
        var timingMode = Browser.mainLoop.timingMode;
        var timingValue = Browser.mainLoop.timingValue;
        var func2 = Browser.mainLoop.func;
        Browser.mainLoop.func = null;
        _emscripten_set_main_loop(func2, 0, false, Browser.mainLoop.arg, true);
        _emscripten_set_main_loop_timing(timingMode, timingValue);
        Browser.mainLoop.scheduler();
      }, updateStatus: function() {
        if (Module["setStatus"]) {
          var message = Module["statusMessage"] || "Please wait...";
          var remaining = Browser.mainLoop.remainingBlockers;
          var expected = Browser.mainLoop.expectedBlockers;
          if (remaining) {
            if (remaining < expected) {
              Module["setStatus"](message + " (" + (expected - remaining) + "/" + expected + ")");
            } else {
              Module["setStatus"](message);
            }
          } else {
            Module["setStatus"]("");
          }
        }
      }, runIter: function(func2) {
        if (ABORT)
          return;
        if (Module["preMainLoop"]) {
          var preRet = Module["preMainLoop"]();
          if (preRet === false) {
            return;
          }
        }
        try {
          func2();
        } catch (e3) {
          if (e3 instanceof ExitStatus) {
            return;
          } else {
            if (e3 && typeof e3 === "object" && e3.stack)
              Module.printErr("exception thrown: " + [e3, e3.stack]);
            throw e3;
          }
        }
        if (Module["postMainLoop"])
          Module["postMainLoop"]();
      } }, isFullscreen: false, pointerLock: false, moduleContextCreatedCallbacks: [], workers: [], init: function() {
        if (!Module["preloadPlugins"])
          Module["preloadPlugins"] = [];
        if (Browser.initted)
          return;
        Browser.initted = true;
        try {
          new Blob();
          Browser.hasBlobConstructor = true;
        } catch (e3) {
          Browser.hasBlobConstructor = false;
          console.log("warning: no blob constructor, cannot create blobs with mimetypes");
        }
        Browser.BlobBuilder = typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : typeof WebKitBlobBuilder != "undefined" ? WebKitBlobBuilder : !Browser.hasBlobConstructor ? console.log("warning: no BlobBuilder") : null;
        Browser.URLObject = typeof window != "undefined" ? window.URL ? window.URL : window.webkitURL : void 0;
        if (!Module.noImageDecoding && typeof Browser.URLObject === "undefined") {
          console.log("warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available.");
          Module.noImageDecoding = true;
        }
        var imagePlugin = {};
        imagePlugin["canHandle"] = function imagePlugin_canHandle(name) {
          return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/i.test(name);
        };
        imagePlugin["handle"] = function imagePlugin_handle(byteArray, name, onload, onerror) {
          var b2 = null;
          if (Browser.hasBlobConstructor) {
            try {
              b2 = new Blob([byteArray], { type: Browser.getMimetype(name) });
              if (b2.size !== byteArray.length) {
                b2 = new Blob([new Uint8Array(byteArray).buffer], { type: Browser.getMimetype(name) });
              }
            } catch (e3) {
              Runtime.warnOnce("Blob constructor present but fails: " + e3 + "; falling back to blob builder");
            }
          }
          if (!b2) {
            var bb = new Browser.BlobBuilder();
            bb.append(new Uint8Array(byteArray).buffer);
            b2 = bb.getBlob();
          }
          var url2 = Browser.URLObject.createObjectURL(b2);
          var img = new Image();
          img.onload = function img_onload() {
            assert(img.complete, "Image " + name + " could not be decoded");
            var canvas4 = document.createElement("canvas");
            canvas4.width = img.width;
            canvas4.height = img.height;
            var ctx3 = canvas4.getContext("2d");
            ctx3.drawImage(img, 0, 0);
            Module["preloadedImages"][name] = canvas4;
            Browser.URLObject.revokeObjectURL(url2);
            if (onload)
              onload(byteArray);
          };
          img.onerror = function img_onerror(event) {
            console.log("Image " + url2 + " could not be decoded");
            if (onerror)
              onerror();
          };
          img.src = url2;
        };
        Module["preloadPlugins"].push(imagePlugin);
        var audioPlugin = {};
        audioPlugin["canHandle"] = function audioPlugin_canHandle(name) {
          return !Module.noAudioDecoding && name.substr(-4) in { ".ogg": 1, ".wav": 1, ".mp3": 1 };
        };
        audioPlugin["handle"] = function audioPlugin_handle(byteArray, name, onload, onerror) {
          var done = false;
          function finish(audio2) {
            if (done)
              return;
            done = true;
            Module["preloadedAudios"][name] = audio2;
            if (onload)
              onload(byteArray);
          }
          function fail() {
            if (done)
              return;
            done = true;
            Module["preloadedAudios"][name] = new Audio();
            if (onerror)
              onerror();
          }
          if (Browser.hasBlobConstructor) {
            try {
              var b2 = new Blob([byteArray], { type: Browser.getMimetype(name) });
            } catch (e3) {
              return fail();
            }
            var url2 = Browser.URLObject.createObjectURL(b2);
            var audio = new Audio();
            audio.addEventListener("canplaythrough", function() {
              finish(audio);
            }, false);
            audio.onerror = function audio_onerror(event) {
              if (done)
                return;
              console.log("warning: browser could not fully decode audio " + name + ", trying slower base64 approach");
              function encode64(data) {
                var BASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                var PAD = "=";
                var ret = "";
                var leftchar = 0;
                var leftbits = 0;
                for (var i3 = 0; i3 < data.length; i3++) {
                  leftchar = leftchar << 8 | data[i3];
                  leftbits += 8;
                  while (leftbits >= 6) {
                    var curr = leftchar >> leftbits - 6 & 63;
                    leftbits -= 6;
                    ret += BASE[curr];
                  }
                }
                if (leftbits == 2) {
                  ret += BASE[(leftchar & 3) << 4];
                  ret += PAD + PAD;
                } else if (leftbits == 4) {
                  ret += BASE[(leftchar & 15) << 2];
                  ret += PAD;
                }
                return ret;
              }
              audio.src = "data:audio/x-" + name.substr(-3) + ";base64," + encode64(byteArray);
              finish(audio);
            };
            audio.src = url2;
            Browser.safeSetTimeout(function() {
              finish(audio);
            }, 1e4);
          } else {
            return fail();
          }
        };
        Module["preloadPlugins"].push(audioPlugin);
        function pointerLockChange() {
          Browser.pointerLock = document["pointerLockElement"] === Module["canvas"] || document["mozPointerLockElement"] === Module["canvas"] || document["webkitPointerLockElement"] === Module["canvas"] || document["msPointerLockElement"] === Module["canvas"];
        }
        var canvas3 = Module["canvas"];
        if (canvas3) {
          canvas3.requestPointerLock = canvas3["requestPointerLock"] || canvas3["mozRequestPointerLock"] || canvas3["webkitRequestPointerLock"] || canvas3["msRequestPointerLock"] || function() {
          };
          canvas3.exitPointerLock = document["exitPointerLock"] || document["mozExitPointerLock"] || document["webkitExitPointerLock"] || document["msExitPointerLock"] || function() {
          };
          canvas3.exitPointerLock = canvas3.exitPointerLock.bind(document);
          document.addEventListener("pointerlockchange", pointerLockChange, false);
          document.addEventListener("mozpointerlockchange", pointerLockChange, false);
          document.addEventListener("webkitpointerlockchange", pointerLockChange, false);
          document.addEventListener("mspointerlockchange", pointerLockChange, false);
          if (Module["elementPointerLock"]) {
            canvas3.addEventListener("click", function(ev) {
              if (!Browser.pointerLock && Module["canvas"].requestPointerLock) {
                Module["canvas"].requestPointerLock();
                ev.preventDefault();
              }
            }, false);
          }
        }
      }, createContext: function(canvas3, useWebGL, setInModule, webGLContextAttributes) {
        if (useWebGL && Module.ctx && canvas3 == Module.canvas)
          return Module.ctx;
        var ctx3;
        var contextHandle;
        if (useWebGL) {
          var contextAttributes = { antialias: false, alpha: false };
          if (webGLContextAttributes) {
            for (var attribute in webGLContextAttributes) {
              contextAttributes[attribute] = webGLContextAttributes[attribute];
            }
          }
          contextHandle = GL.createContext(canvas3, contextAttributes);
          if (contextHandle) {
            ctx3 = GL.getContext(contextHandle).GLctx;
          }
        } else {
          ctx3 = canvas3.getContext("2d");
        }
        if (!ctx3)
          return null;
        if (setInModule) {
          if (!useWebGL)
            assert(typeof GLctx === "undefined", "cannot set in module if GLctx is used, but we are a non-GL context that would replace it");
          Module.ctx = ctx3;
          if (useWebGL)
            GL.makeContextCurrent(contextHandle);
          Module.useWebGL = useWebGL;
          Browser.moduleContextCreatedCallbacks.forEach(function(callback) {
            callback();
          });
          Browser.init();
        }
        return ctx3;
      }, destroyContext: function(canvas3, useWebGL, setInModule) {
      }, fullscreenHandlersInstalled: false, lockPointer: void 0, resizeCanvas: void 0, requestFullscreen: function(lockPointer, resizeCanvas, vrDevice) {
        Browser.lockPointer = lockPointer;
        Browser.resizeCanvas = resizeCanvas;
        Browser.vrDevice = vrDevice;
        if (typeof Browser.lockPointer === "undefined")
          Browser.lockPointer = true;
        if (typeof Browser.resizeCanvas === "undefined")
          Browser.resizeCanvas = false;
        if (typeof Browser.vrDevice === "undefined")
          Browser.vrDevice = null;
        var canvas3 = Module["canvas"];
        function fullscreenChange() {
          Browser.isFullscreen = false;
          var canvasContainer2 = canvas3.parentNode;
          if ((document["fullscreenElement"] || document["mozFullScreenElement"] || document["msFullscreenElement"] || document["webkitFullscreenElement"] || document["webkitCurrentFullScreenElement"]) === canvasContainer2) {
            canvas3.exitFullscreen = document["exitFullscreen"] || document["cancelFullScreen"] || document["mozCancelFullScreen"] || document["msExitFullscreen"] || document["webkitCancelFullScreen"] || function() {
            };
            canvas3.exitFullscreen = canvas3.exitFullscreen.bind(document);
            if (Browser.lockPointer)
              canvas3.requestPointerLock();
            Browser.isFullscreen = true;
            if (Browser.resizeCanvas)
              Browser.setFullscreenCanvasSize();
          } else {
            canvasContainer2.parentNode.insertBefore(canvas3, canvasContainer2);
            canvasContainer2.parentNode.removeChild(canvasContainer2);
            if (Browser.resizeCanvas)
              Browser.setWindowedCanvasSize();
          }
          if (Module["onFullScreen"])
            Module["onFullScreen"](Browser.isFullscreen);
          if (Module["onFullscreen"])
            Module["onFullscreen"](Browser.isFullscreen);
          Browser.updateCanvasDimensions(canvas3);
        }
        if (!Browser.fullscreenHandlersInstalled) {
          Browser.fullscreenHandlersInstalled = true;
          document.addEventListener("fullscreenchange", fullscreenChange, false);
          document.addEventListener("mozfullscreenchange", fullscreenChange, false);
          document.addEventListener("webkitfullscreenchange", fullscreenChange, false);
          document.addEventListener("MSFullscreenChange", fullscreenChange, false);
        }
        var canvasContainer = document.createElement("div");
        canvas3.parentNode.insertBefore(canvasContainer, canvas3);
        canvasContainer.appendChild(canvas3);
        canvasContainer.requestFullscreen = canvasContainer["requestFullscreen"] || canvasContainer["mozRequestFullScreen"] || canvasContainer["msRequestFullscreen"] || (canvasContainer["webkitRequestFullscreen"] ? function() {
          canvasContainer["webkitRequestFullscreen"](Element["ALLOW_KEYBOARD_INPUT"]);
        } : null) || (canvasContainer["webkitRequestFullScreen"] ? function() {
          canvasContainer["webkitRequestFullScreen"](Element["ALLOW_KEYBOARD_INPUT"]);
        } : null);
        if (vrDevice) {
          canvasContainer.requestFullscreen({ vrDisplay: vrDevice });
        } else {
          canvasContainer.requestFullscreen();
        }
      }, requestFullScreen: function(lockPointer, resizeCanvas, vrDevice) {
        Module.printErr("Browser.requestFullScreen() is deprecated. Please call Browser.requestFullscreen instead.");
        Browser.requestFullScreen = function(lockPointer2, resizeCanvas2, vrDevice2) {
          return Browser.requestFullscreen(lockPointer2, resizeCanvas2, vrDevice2);
        };
        return Browser.requestFullscreen(lockPointer, resizeCanvas, vrDevice);
      }, nextRAF: 0, fakeRequestAnimationFrame: function(func2) {
        var now = Date.now();
        if (Browser.nextRAF === 0) {
          Browser.nextRAF = now + 1e3 / 60;
        } else {
          while (now + 2 >= Browser.nextRAF) {
            Browser.nextRAF += 1e3 / 60;
          }
        }
        var delay = Math.max(Browser.nextRAF - now, 0);
        setTimeout(func2, delay);
      }, requestAnimationFrame: function requestAnimationFrame2(func2) {
        if (typeof window === "undefined") {
          Browser.fakeRequestAnimationFrame(func2);
        } else {
          if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = window["requestAnimationFrame"] || window["mozRequestAnimationFrame"] || window["webkitRequestAnimationFrame"] || window["msRequestAnimationFrame"] || window["oRequestAnimationFrame"] || Browser.fakeRequestAnimationFrame;
          }
          window.requestAnimationFrame(func2);
        }
      }, safeCallback: function(func2) {
        return function() {
          if (!ABORT)
            return func2.apply(null, arguments);
        };
      }, allowAsyncCallbacks: true, queuedAsyncCallbacks: [], pauseAsyncCallbacks: function() {
        Browser.allowAsyncCallbacks = false;
      }, resumeAsyncCallbacks: function() {
        Browser.allowAsyncCallbacks = true;
        if (Browser.queuedAsyncCallbacks.length > 0) {
          var callbacks = Browser.queuedAsyncCallbacks;
          Browser.queuedAsyncCallbacks = [];
          callbacks.forEach(function(func2) {
            func2();
          });
        }
      }, safeRequestAnimationFrame: function(func2) {
        return Browser.requestAnimationFrame(function() {
          if (ABORT)
            return;
          if (Browser.allowAsyncCallbacks) {
            func2();
          } else {
            Browser.queuedAsyncCallbacks.push(func2);
          }
        });
      }, safeSetTimeout: function(func2, timeout) {
        Module["noExitRuntime"] = true;
        return setTimeout(function() {
          if (ABORT)
            return;
          if (Browser.allowAsyncCallbacks) {
            func2();
          } else {
            Browser.queuedAsyncCallbacks.push(func2);
          }
        }, timeout);
      }, safeSetInterval: function(func2, timeout) {
        Module["noExitRuntime"] = true;
        return setInterval(function() {
          if (ABORT)
            return;
          if (Browser.allowAsyncCallbacks) {
            func2();
          }
        }, timeout);
      }, getMimetype: function(name) {
        return { "jpg": "image/jpeg", "jpeg": "image/jpeg", "png": "image/png", "bmp": "image/bmp", "ogg": "audio/ogg", "wav": "audio/wav", "mp3": "audio/mpeg" }[name.substr(name.lastIndexOf(".") + 1)];
      }, getUserMedia: function(func2) {
        if (!window.getUserMedia) {
          window.getUserMedia = navigator["getUserMedia"] || navigator["mozGetUserMedia"];
        }
        window.getUserMedia(func2);
      }, getMovementX: function(event) {
        return event["movementX"] || event["mozMovementX"] || event["webkitMovementX"] || 0;
      }, getMovementY: function(event) {
        return event["movementY"] || event["mozMovementY"] || event["webkitMovementY"] || 0;
      }, getMouseWheelDelta: function(event) {
        var delta = 0;
        switch (event.type) {
          case "DOMMouseScroll":
            delta = event.detail;
            break;
          case "mousewheel":
            delta = event.wheelDelta;
            break;
          case "wheel":
            delta = event["deltaY"];
            break;
          default:
            throw "unrecognized mouse wheel event: " + event.type;
        }
        return delta;
      }, mouseX: 0, mouseY: 0, mouseMovementX: 0, mouseMovementY: 0, touches: {}, lastTouches: {}, calculateMouseEvent: function(event) {
        if (Browser.pointerLock) {
          if (event.type != "mousemove" && "mozMovementX" in event) {
            Browser.mouseMovementX = Browser.mouseMovementY = 0;
          } else {
            Browser.mouseMovementX = Browser.getMovementX(event);
            Browser.mouseMovementY = Browser.getMovementY(event);
          }
          if (typeof SDL != "undefined") {
            Browser.mouseX = SDL.mouseX + Browser.mouseMovementX;
            Browser.mouseY = SDL.mouseY + Browser.mouseMovementY;
          } else {
            Browser.mouseX += Browser.mouseMovementX;
            Browser.mouseY += Browser.mouseMovementY;
          }
        } else {
          var rect = Module["canvas"].getBoundingClientRect();
          var cw = Module["canvas"].width;
          var ch = Module["canvas"].height;
          var scrollX = typeof window.scrollX !== "undefined" ? window.scrollX : window.pageXOffset;
          var scrollY = typeof window.scrollY !== "undefined" ? window.scrollY : window.pageYOffset;
          if (event.type === "touchstart" || event.type === "touchend" || event.type === "touchmove") {
            var touch = event.touch;
            if (touch === void 0) {
              return;
            }
            var adjustedX = touch.pageX - (scrollX + rect.left);
            var adjustedY = touch.pageY - (scrollY + rect.top);
            adjustedX = adjustedX * (cw / rect.width);
            adjustedY = adjustedY * (ch / rect.height);
            var coords = { x: adjustedX, y: adjustedY };
            if (event.type === "touchstart") {
              Browser.lastTouches[touch.identifier] = coords;
              Browser.touches[touch.identifier] = coords;
            } else if (event.type === "touchend" || event.type === "touchmove") {
              var last = Browser.touches[touch.identifier];
              if (!last)
                last = coords;
              Browser.lastTouches[touch.identifier] = last;
              Browser.touches[touch.identifier] = coords;
            }
            return;
          }
          var x3 = event.pageX - (scrollX + rect.left);
          var y2 = event.pageY - (scrollY + rect.top);
          x3 = x3 * (cw / rect.width);
          y2 = y2 * (ch / rect.height);
          Browser.mouseMovementX = x3 - Browser.mouseX;
          Browser.mouseMovementY = y2 - Browser.mouseY;
          Browser.mouseX = x3;
          Browser.mouseY = y2;
        }
      }, asyncLoad: function(url2, onload, onerror, noRunDep) {
        var dep = !noRunDep ? getUniqueRunDependency("al " + url2) : "";
        Module["readAsync"](url2, function(arrayBuffer) {
          assert(arrayBuffer, 'Loading data file "' + url2 + '" failed (no arrayBuffer).');
          onload(new Uint8Array(arrayBuffer));
          if (dep)
            removeRunDependency(dep);
        }, function(event) {
          if (onerror) {
            onerror();
          } else {
            throw 'Loading data file "' + url2 + '" failed.';
          }
        });
        if (dep)
          addRunDependency(dep);
      }, resizeListeners: [], updateResizeListeners: function() {
        var canvas3 = Module["canvas"];
        Browser.resizeListeners.forEach(function(listener) {
          listener(canvas3.width, canvas3.height);
        });
      }, setCanvasSize: function(width, height, noUpdates) {
        var canvas3 = Module["canvas"];
        Browser.updateCanvasDimensions(canvas3, width, height);
        if (!noUpdates)
          Browser.updateResizeListeners();
      }, windowedWidth: 0, windowedHeight: 0, setFullscreenCanvasSize: function() {
        if (typeof SDL != "undefined") {
          var flags = HEAPU32[SDL.screen + Runtime.QUANTUM_SIZE * 0 >> 2];
          flags = flags | 8388608;
          HEAP32[SDL.screen + Runtime.QUANTUM_SIZE * 0 >> 2] = flags;
        }
        Browser.updateResizeListeners();
      }, setWindowedCanvasSize: function() {
        if (typeof SDL != "undefined") {
          var flags = HEAPU32[SDL.screen + Runtime.QUANTUM_SIZE * 0 >> 2];
          flags = flags & ~8388608;
          HEAP32[SDL.screen + Runtime.QUANTUM_SIZE * 0 >> 2] = flags;
        }
        Browser.updateResizeListeners();
      }, updateCanvasDimensions: function(canvas3, wNative, hNative) {
        if (wNative && hNative) {
          canvas3.widthNative = wNative;
          canvas3.heightNative = hNative;
        } else {
          wNative = canvas3.widthNative;
          hNative = canvas3.heightNative;
        }
        var w2 = wNative;
        var h2 = hNative;
        if (Module["forcedAspectRatio"] && Module["forcedAspectRatio"] > 0) {
          if (w2 / h2 < Module["forcedAspectRatio"]) {
            w2 = Math.round(h2 * Module["forcedAspectRatio"]);
          } else {
            h2 = Math.round(w2 / Module["forcedAspectRatio"]);
          }
        }
        if ((document["fullscreenElement"] || document["mozFullScreenElement"] || document["msFullscreenElement"] || document["webkitFullscreenElement"] || document["webkitCurrentFullScreenElement"]) === canvas3.parentNode && typeof screen != "undefined") {
          var factor = Math.min(screen.width / w2, screen.height / h2);
          w2 = Math.round(w2 * factor);
          h2 = Math.round(h2 * factor);
        }
        if (Browser.resizeCanvas) {
          if (canvas3.width != w2)
            canvas3.width = w2;
          if (canvas3.height != h2)
            canvas3.height = h2;
          if (typeof canvas3.style != "undefined") {
            canvas3.style.removeProperty("width");
            canvas3.style.removeProperty("height");
          }
        } else {
          if (canvas3.width != wNative)
            canvas3.width = wNative;
          if (canvas3.height != hNative)
            canvas3.height = hNative;
          if (typeof canvas3.style != "undefined") {
            if (w2 != wNative || h2 != hNative) {
              canvas3.style.setProperty("width", w2 + "px", "important");
              canvas3.style.setProperty("height", h2 + "px", "important");
            } else {
              canvas3.style.removeProperty("width");
              canvas3.style.removeProperty("height");
            }
          }
        }
      }, wgetRequests: {}, nextWgetRequestHandle: 0, getNextWgetRequestHandle: function() {
        var handle = Browser.nextWgetRequestHandle;
        Browser.nextWgetRequestHandle++;
        return handle;
      } };
      var SYSCALLS = { varargs: 0, get: function(varargs) {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
        return ret;
      }, getStr: function() {
        var ret = Pointer_stringify(SYSCALLS.get());
        return ret;
      }, get64: function() {
        var low = SYSCALLS.get(), high = SYSCALLS.get();
        if (low >= 0)
          assert(high === 0);
        else
          assert(high === -1);
        return low;
      }, getZero: function() {
        assert(SYSCALLS.get() === 0);
      } };
      function ___syscall6(which, varargs) {
        SYSCALLS.varargs = varargs;
        try {
          var stream = SYSCALLS.getStreamFromFD();
          FS.close(stream);
          return 0;
        } catch (e3) {
          if (typeof FS === "undefined" || !(e3 instanceof FS.ErrnoError))
            abort(e3);
          return -e3.errno;
        }
      }
      function ___syscall54(which, varargs) {
        SYSCALLS.varargs = varargs;
        try {
          return 0;
        } catch (e3) {
          if (typeof FS === "undefined" || !(e3 instanceof FS.ErrnoError))
            abort(e3);
          return -e3.errno;
        }
      }
      function _typeModule(self2) {
        var structureList = [[0, 1, "X"], [1, 1, "const X"], [128, 1, "X *"], [256, 1, "X &"], [384, 1, "X &&"], [512, 1, "std::shared_ptr<X>"], [640, 1, "std::unique_ptr<X>"], [5120, 1, "std::vector<X>"], [6144, 2, "std::array<X, Y>"], [9216, -1, "std::function<X (Y)>"]];
        function applyStructure(outerName, outerFlags, innerName, innerFlags, param, flip) {
          if (outerFlags == 1) {
            var ref = innerFlags & 896;
            if (ref == 128 || ref == 256 || ref == 384)
              outerName = "X const";
          }
          var name;
          if (flip) {
            name = innerName.replace("X", outerName).replace("Y", param);
          } else {
            name = outerName.replace("X", innerName).replace("Y", param);
          }
          return name.replace(/([*&]) (?=[*&])/g, "$1");
        }
        function reportProblem(problem, id, kind, structureType, place) {
          throw new Error(problem + " type " + kind.replace("X", id + "?") + (structureType ? " with flag " + structureType : "") + " in " + place);
        }
        function getComplexType(id, constructType2, getType2, queryType2, place, kind, prevStructure, depth) {
          if (kind === void 0) {
            kind = "X";
          }
          if (depth === void 0) {
            depth = 1;
          }
          var result = getType2(id);
          if (result)
            return result;
          var query = queryType2(id);
          var structureType = query.placeholderFlag;
          var structure = structureList[structureType];
          if (prevStructure && structure) {
            kind = applyStructure(prevStructure[2], prevStructure[0], kind, structure[0], "?", true);
          }
          var problem;
          if (structureType == 0)
            problem = "Unbound";
          if (structureType >= 10)
            problem = "Corrupt";
          if (depth > 20)
            problem = "Deeply nested";
          if (problem)
            reportProblem(problem, id, kind, structureType, place || "?");
          var subId = query.paramList[0];
          var subType = getComplexType(subId, constructType2, getType2, queryType2, place, kind, structure, depth + 1);
          var srcSpec;
          var spec = { flags: structure[0], id, name: "", paramList: [subType] };
          var argList2 = [];
          var structureParam = "?";
          switch (query.placeholderFlag) {
            case 1:
              srcSpec = subType.spec;
              break;
            case 2:
              if ((subType.flags & 15360) == 1024 && subType.spec.ptrSize == 1) {
                spec.flags = 7168;
                break;
              }
              ;
            case 3:
            case 6:
            case 5:
              srcSpec = subType.spec;
              if ((subType.flags & 15360) != 2048) {
              }
              break;
            case 8:
              structureParam = "" + query.paramList[1];
              spec.paramList.push(query.paramList[1]);
              break;
            case 9:
              for (var _i = 0, _a2 = query.paramList[1]; _i < _a2.length; _i++) {
                var paramId = _a2[_i];
                var paramType = getComplexType(paramId, constructType2, getType2, queryType2, place, kind, structure, depth + 1);
                argList2.push(paramType.name);
                spec.paramList.push(paramType);
              }
              structureParam = argList2.join(", ");
              break;
            default:
              break;
          }
          spec.name = applyStructure(structure[2], structure[0], subType.name, subType.flags, structureParam);
          if (srcSpec) {
            for (var _b = 0, _c = Object.keys(srcSpec); _b < _c.length; _b++) {
              var key2 = _c[_b];
              spec[key2] = spec[key2] || srcSpec[key2];
            }
            spec.flags |= srcSpec.flags;
          }
          return makeType(constructType2, spec);
        }
        function makeType(constructType2, spec) {
          var flags = spec.flags;
          var refKind = flags & 896;
          var kind = flags & 15360;
          if (!spec.name && kind == 1024) {
            if (spec.ptrSize == 1) {
              spec.name = (flags & 16 ? "" : (flags & 8 ? "un" : "") + "signed ") + "char";
            } else {
              spec.name = (flags & 8 ? "u" : "") + (flags & 32 ? "float" : "int") + (spec.ptrSize * 8 + "_t");
            }
          }
          if (spec.ptrSize == 8 && !(flags & 32))
            kind = 64;
          if (kind == 2048) {
            if (refKind == 512 || refKind == 640) {
              kind = 4096;
            } else if (refKind)
              kind = 3072;
          }
          return constructType2(kind, spec);
        }
        var Type = function() {
          function Type2(spec) {
            this.id = spec.id;
            this.name = spec.name;
            this.flags = spec.flags;
            this.spec = spec;
          }
          Type2.prototype.toString = function() {
            return this.name;
          };
          return Type2;
        }();
        var output = { Type, getComplexType, makeType, structureList };
        self2.output = output;
        return self2.output || output;
      }
      function __nbind_register_type(id, namePtr) {
        var name = _nbind.readAsciiString(namePtr);
        var spec = { flags: 10240, id, name };
        _nbind.makeType(_nbind.constructType, spec);
      }
      function __nbind_register_callback_signature(typeListPtr, typeCount) {
        var typeList = _nbind.readTypeIdList(typeListPtr, typeCount);
        var num2 = _nbind.callbackSignatureList.length;
        _nbind.callbackSignatureList[num2] = _nbind.makeJSCaller(typeList);
        return num2;
      }
      function __extends(Class, Parent) {
        for (var key2 in Parent)
          if (Parent.hasOwnProperty(key2))
            Class[key2] = Parent[key2];
        function Base() {
          this.constructor = Class;
        }
        Base.prototype = Parent.prototype;
        Class.prototype = new Base();
      }
      function __nbind_register_class(idListPtr, policyListPtr, superListPtr, upcastListPtr, superCount, destructorPtr, namePtr) {
        var name = _nbind.readAsciiString(namePtr);
        var policyTbl2 = _nbind.readPolicyList(policyListPtr);
        var idList = HEAPU32.subarray(idListPtr / 4, idListPtr / 4 + 2);
        var spec = { flags: 2048 | (policyTbl2["Value"] ? 2 : 0), id: idList[0], name };
        var bindClass = _nbind.makeType(_nbind.constructType, spec);
        bindClass.ptrType = _nbind.getComplexType(idList[1], _nbind.constructType, _nbind.getType, _nbind.queryType);
        bindClass.destroy = _nbind.makeMethodCaller(bindClass.ptrType, { boundID: spec.id, flags: 0, name: "destroy", num: 0, ptr: destructorPtr, title: bindClass.name + ".free", typeList: ["void", "uint32_t", "uint32_t"] });
        if (superCount) {
          bindClass.superIdList = Array.prototype.slice.call(HEAPU32.subarray(superListPtr / 4, superListPtr / 4 + superCount));
          bindClass.upcastList = Array.prototype.slice.call(HEAPU32.subarray(upcastListPtr / 4, upcastListPtr / 4 + superCount));
        }
        Module[bindClass.name] = bindClass.makeBound(policyTbl2);
        _nbind.BindClass.list.push(bindClass);
      }
      function _removeAccessorPrefix(name) {
        var prefixMatcher = /^[Gg]et_?([A-Z]?([A-Z]?))/;
        return name.replace(prefixMatcher, function(match, initial, second) {
          return second ? initial : initial.toLowerCase();
        });
      }
      function __nbind_register_function(boundID, policyListPtr, typeListPtr, typeCount, ptr2, direct, signatureType, namePtr, num2, flags) {
        var bindClass = _nbind.getType(boundID);
        var policyTbl2 = _nbind.readPolicyList(policyListPtr);
        var typeList = _nbind.readTypeIdList(typeListPtr, typeCount);
        var specList;
        if (signatureType == 5) {
          specList = [{ direct: ptr2, name: "__nbindConstructor", ptr: 0, title: bindClass.name + " constructor", typeList: ["uint32_t"].concat(typeList.slice(1)) }, { direct, name: "__nbindValueConstructor", ptr: 0, title: bindClass.name + " value constructor", typeList: ["void", "uint32_t"].concat(typeList.slice(1)) }];
        } else {
          var name_1 = _nbind.readAsciiString(namePtr);
          var title = (bindClass.name && bindClass.name + ".") + name_1;
          if (signatureType == 3 || signatureType == 4) {
            name_1 = _removeAccessorPrefix(name_1);
          }
          specList = [{ boundID, direct, name: name_1, ptr: ptr2, title, typeList }];
        }
        for (var _i = 0, specList_1 = specList; _i < specList_1.length; _i++) {
          var spec = specList_1[_i];
          spec.signatureType = signatureType;
          spec.policyTbl = policyTbl2;
          spec.num = num2;
          spec.flags = flags;
          bindClass.addMethod(spec);
        }
      }
      function _nbind_value(name, proto) {
        if (!_nbind.typeNameTbl[name])
          _nbind.throwError("Unknown value type " + name);
        Module["NBind"].bind_value(name, proto);
        _defineHidden(_nbind.typeNameTbl[name].proto.prototype.__nbindValueConstructor)(proto.prototype, "__nbindValueConstructor");
      }
      Module["_nbind_value"] = _nbind_value;
      function __nbind_get_value_object(num2, ptr2) {
        var obj = _nbind.popValue(num2);
        if (!obj.fromJS) {
          throw new Error("Object " + obj + " has no fromJS function");
        }
        obj.fromJS(function() {
          obj.__nbindValueConstructor.apply(this, Array.prototype.concat.apply([ptr2], arguments));
        });
      }
      function _emscripten_memcpy_big(dest, src, num2) {
        HEAPU8.set(HEAPU8.subarray(src, src + num2), dest);
        return dest;
      }
      function __nbind_register_primitive(id, size3, flags) {
        var spec = { flags: 1024 | flags, id, ptrSize: size3 };
        _nbind.makeType(_nbind.constructType, spec);
      }
      var cttz_i8 = allocate([8, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0], "i8", ALLOC_STATIC);
      function ___setErrNo(value) {
        if (Module["___errno_location"])
          HEAP32[Module["___errno_location"]() >> 2] = value;
        return value;
      }
      function _llvm_stacksave() {
        var self2 = _llvm_stacksave;
        if (!self2.LLVM_SAVEDSTACKS) {
          self2.LLVM_SAVEDSTACKS = [];
        }
        self2.LLVM_SAVEDSTACKS.push(Runtime.stackSave());
        return self2.LLVM_SAVEDSTACKS.length - 1;
      }
      function ___syscall140(which, varargs) {
        SYSCALLS.varargs = varargs;
        try {
          var stream = SYSCALLS.getStreamFromFD(), offset_high = SYSCALLS.get(), offset_low = SYSCALLS.get(), result = SYSCALLS.get(), whence = SYSCALLS.get();
          var offset = offset_low;
          FS.llseek(stream, offset, whence);
          HEAP32[result >> 2] = stream.position;
          if (stream.getdents && offset === 0 && whence === 0)
            stream.getdents = null;
          return 0;
        } catch (e3) {
          if (typeof FS === "undefined" || !(e3 instanceof FS.ErrnoError))
            abort(e3);
          return -e3.errno;
        }
      }
      function ___syscall146(which, varargs) {
        SYSCALLS.varargs = varargs;
        try {
          var stream = SYSCALLS.get(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();
          var ret = 0;
          if (!___syscall146.buffer) {
            ___syscall146.buffers = [null, [], []];
            ___syscall146.printChar = function(stream2, curr) {
              var buffer2 = ___syscall146.buffers[stream2];
              assert(buffer2);
              if (curr === 0 || curr === 10) {
                (stream2 === 1 ? Module["print"] : Module["printErr"])(UTF8ArrayToString(buffer2, 0));
                buffer2.length = 0;
              } else {
                buffer2.push(curr);
              }
            };
          }
          for (var i3 = 0; i3 < iovcnt; i3++) {
            var ptr2 = HEAP32[iov + i3 * 8 >> 2];
            var len = HEAP32[iov + (i3 * 8 + 4) >> 2];
            for (var j3 = 0; j3 < len; j3++) {
              ___syscall146.printChar(stream, HEAPU8[ptr2 + j3]);
            }
            ret += len;
          }
          return ret;
        } catch (e3) {
          if (typeof FS === "undefined" || !(e3 instanceof FS.ErrnoError))
            abort(e3);
          return -e3.errno;
        }
      }
      function __nbind_finish() {
        for (var _i = 0, _a2 = _nbind.BindClass.list; _i < _a2.length; _i++) {
          var bindClass = _a2[_i];
          bindClass.finish();
        }
      }
      var ___dso_handle = STATICTOP;
      STATICTOP += 16;
      (function(_nbind) {
        var typeIdTbl = {};
        _nbind.typeNameTbl = {};
        var Pool = function() {
          function Pool4() {
          }
          Pool4.lalloc = function(size3) {
            size3 = size3 + 7 & ~7;
            var used = HEAPU32[Pool4.usedPtr];
            if (size3 > Pool4.pageSize / 2 || size3 > Pool4.pageSize - used) {
              var NBind = _nbind.typeNameTbl["NBind"].proto;
              return NBind.lalloc(size3);
            } else {
              HEAPU32[Pool4.usedPtr] = used + size3;
              return Pool4.rootPtr + used;
            }
          };
          Pool4.lreset = function(used, page) {
            var topPage = HEAPU32[Pool4.pagePtr];
            if (topPage) {
              var NBind = _nbind.typeNameTbl["NBind"].proto;
              NBind.lreset(used, page);
            } else {
              HEAPU32[Pool4.usedPtr] = used;
            }
          };
          return Pool4;
        }();
        _nbind.Pool = Pool;
        function constructType(kind, spec) {
          var construct = kind == 10240 ? _nbind.makeTypeNameTbl[spec.name] || _nbind.BindType : _nbind.makeTypeKindTbl[kind];
          var bindType = new construct(spec);
          typeIdTbl[spec.id] = bindType;
          _nbind.typeNameTbl[spec.name] = bindType;
          return bindType;
        }
        _nbind.constructType = constructType;
        function getType(id) {
          return typeIdTbl[id];
        }
        _nbind.getType = getType;
        function queryType(id) {
          var placeholderFlag = HEAPU8[id];
          var paramCount = _nbind.structureList[placeholderFlag][1];
          id /= 4;
          if (paramCount < 0) {
            ++id;
            paramCount = HEAPU32[id] + 1;
          }
          var paramList = Array.prototype.slice.call(HEAPU32.subarray(id + 1, id + 1 + paramCount));
          if (placeholderFlag == 9) {
            paramList = [paramList[0], paramList.slice(1)];
          }
          return { paramList, placeholderFlag };
        }
        _nbind.queryType = queryType;
        function getTypes(idList, place) {
          return idList.map(function(id) {
            return typeof id == "number" ? _nbind.getComplexType(id, constructType, getType, queryType, place) : _nbind.typeNameTbl[id];
          });
        }
        _nbind.getTypes = getTypes;
        function readTypeIdList(typeListPtr, typeCount) {
          return Array.prototype.slice.call(HEAPU32, typeListPtr / 4, typeListPtr / 4 + typeCount);
        }
        _nbind.readTypeIdList = readTypeIdList;
        function readAsciiString(ptr2) {
          var endPtr = ptr2;
          while (HEAPU8[endPtr++])
            ;
          return String.fromCharCode.apply("", HEAPU8.subarray(ptr2, endPtr - 1));
        }
        _nbind.readAsciiString = readAsciiString;
        function readPolicyList(policyListPtr) {
          var policyTbl2 = {};
          if (policyListPtr) {
            while (1) {
              var namePtr = HEAPU32[policyListPtr / 4];
              if (!namePtr)
                break;
              policyTbl2[readAsciiString(namePtr)] = true;
              policyListPtr += 4;
            }
          }
          return policyTbl2;
        }
        _nbind.readPolicyList = readPolicyList;
        function getDynCall(typeList, name) {
          var mangleMap = { float32_t: "d", float64_t: "d", int64_t: "d", uint64_t: "d", "void": "v" };
          var signature = typeList.map(function(type2) {
            return mangleMap[type2.name] || "i";
          }).join("");
          var dynCall2 = Module["dynCall_" + signature];
          if (!dynCall2) {
            throw new Error("dynCall_" + signature + " not found for " + name + "(" + typeList.map(function(type2) {
              return type2.name;
            }).join(", ") + ")");
          }
          return dynCall2;
        }
        _nbind.getDynCall = getDynCall;
        function addMethod(obj, name, func2, arity) {
          var overload = obj[name];
          if (obj.hasOwnProperty(name) && overload) {
            if (overload.arity || overload.arity === 0) {
              overload = _nbind.makeOverloader(overload, overload.arity);
              obj[name] = overload;
            }
            overload.addMethod(func2, arity);
          } else {
            func2.arity = arity;
            obj[name] = func2;
          }
        }
        _nbind.addMethod = addMethod;
        function throwError(message) {
          throw new Error(message);
        }
        _nbind.throwError = throwError;
        _nbind.bigEndian = false;
        var _a;
        _a = _typeModule(_typeModule), _nbind.Type = _a.Type, _nbind.makeType = _a.makeType, _nbind.getComplexType = _a.getComplexType, _nbind.structureList = _a.structureList;
        var BindType = function(_super) {
          __extends(BindType2, _super);
          function BindType2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.heap = HEAPU32;
            _this.ptrSize = 4;
            return _this;
          }
          BindType2.prototype.needsWireRead = function(policyTbl2) {
            return !!this.wireRead || !!this.makeWireRead;
          };
          BindType2.prototype.needsWireWrite = function(policyTbl2) {
            return !!this.wireWrite || !!this.makeWireWrite;
          };
          return BindType2;
        }(_nbind.Type);
        _nbind.BindType = BindType;
        var PrimitiveType = function(_super) {
          __extends(PrimitiveType2, _super);
          function PrimitiveType2(spec) {
            var _this = _super.call(this, spec) || this;
            var heapTbl = spec.flags & 32 ? { 32: HEAPF32, 64: HEAPF64 } : spec.flags & 8 ? { 8: HEAPU8, 16: HEAPU16, 32: HEAPU32 } : { 8: HEAP8, 16: HEAP16, 32: HEAP32 };
            _this.heap = heapTbl[spec.ptrSize * 8];
            _this.ptrSize = spec.ptrSize;
            return _this;
          }
          PrimitiveType2.prototype.needsWireWrite = function(policyTbl2) {
            return !!policyTbl2 && !!policyTbl2["Strict"];
          };
          PrimitiveType2.prototype.makeWireWrite = function(expr, policyTbl2) {
            return policyTbl2 && policyTbl2["Strict"] && function(arg2) {
              if (typeof arg2 == "number")
                return arg2;
              throw new Error("Type mismatch");
            };
          };
          return PrimitiveType2;
        }(BindType);
        _nbind.PrimitiveType = PrimitiveType;
        function pushCString(str, policyTbl2) {
          if (str === null || str === void 0) {
            if (policyTbl2 && policyTbl2["Nullable"]) {
              return 0;
            } else
              throw new Error("Type mismatch");
          }
          if (policyTbl2 && policyTbl2["Strict"]) {
            if (typeof str != "string")
              throw new Error("Type mismatch");
          } else
            str = str.toString();
          var length = Module.lengthBytesUTF8(str) + 1;
          var result = _nbind.Pool.lalloc(length);
          Module.stringToUTF8Array(str, HEAPU8, result, length);
          return result;
        }
        _nbind.pushCString = pushCString;
        function popCString(ptr2) {
          if (ptr2 === 0)
            return null;
          return Module.Pointer_stringify(ptr2);
        }
        _nbind.popCString = popCString;
        var CStringType = function(_super) {
          __extends(CStringType2, _super);
          function CStringType2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.wireRead = popCString;
            _this.wireWrite = pushCString;
            _this.readResources = [_nbind.resources.pool];
            _this.writeResources = [_nbind.resources.pool];
            return _this;
          }
          CStringType2.prototype.makeWireWrite = function(expr, policyTbl2) {
            return function(arg2) {
              return pushCString(arg2, policyTbl2);
            };
          };
          return CStringType2;
        }(BindType);
        _nbind.CStringType = CStringType;
        var BooleanType = function(_super) {
          __extends(BooleanType2, _super);
          function BooleanType2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.wireRead = function(arg2) {
              return !!arg2;
            };
            return _this;
          }
          BooleanType2.prototype.needsWireWrite = function(policyTbl2) {
            return !!policyTbl2 && !!policyTbl2["Strict"];
          };
          BooleanType2.prototype.makeWireRead = function(expr) {
            return "!!(" + expr + ")";
          };
          BooleanType2.prototype.makeWireWrite = function(expr, policyTbl2) {
            return policyTbl2 && policyTbl2["Strict"] && function(arg2) {
              if (typeof arg2 == "boolean")
                return arg2;
              throw new Error("Type mismatch");
            } || expr;
          };
          return BooleanType2;
        }(BindType);
        _nbind.BooleanType = BooleanType;
        var Wrapper = function() {
          function Wrapper2() {
          }
          Wrapper2.prototype.persist = function() {
            this.__nbindState |= 1;
          };
          return Wrapper2;
        }();
        _nbind.Wrapper = Wrapper;
        function makeBound(policyTbl2, bindClass) {
          var Bound = function(_super) {
            __extends(Bound2, _super);
            function Bound2(marker, flags, ptr2, shared) {
              var _this = _super.call(this) || this;
              if (!(_this instanceof Bound2)) {
                return new (Function.prototype.bind.apply(Bound2, Array.prototype.concat.apply([null], arguments)))();
              }
              var nbindFlags = flags;
              var nbindPtr = ptr2;
              var nbindShared = shared;
              if (marker !== _nbind.ptrMarker) {
                var wirePtr = _this.__nbindConstructor.apply(_this, arguments);
                nbindFlags = 4096 | 512;
                nbindShared = HEAPU32[wirePtr / 4];
                nbindPtr = HEAPU32[wirePtr / 4 + 1];
              }
              var spec = { configurable: true, enumerable: false, value: null, writable: false };
              var propTbl = { "__nbindFlags": nbindFlags, "__nbindPtr": nbindPtr };
              if (nbindShared) {
                propTbl["__nbindShared"] = nbindShared;
                _nbind.mark(_this);
              }
              for (var _i = 0, _a2 = Object.keys(propTbl); _i < _a2.length; _i++) {
                var key2 = _a2[_i];
                spec.value = propTbl[key2];
                Object.defineProperty(_this, key2, spec);
              }
              _defineHidden(0)(_this, "__nbindState");
              return _this;
            }
            Bound2.prototype.free = function() {
              bindClass.destroy.call(this, this.__nbindShared, this.__nbindFlags);
              this.__nbindState |= 2;
              disableMember(this, "__nbindShared");
              disableMember(this, "__nbindPtr");
            };
            return Bound2;
          }(Wrapper);
          __decorate([_defineHidden()], Bound.prototype, "__nbindConstructor", void 0);
          __decorate([_defineHidden()], Bound.prototype, "__nbindValueConstructor", void 0);
          __decorate([_defineHidden(policyTbl2)], Bound.prototype, "__nbindPolicies", void 0);
          return Bound;
        }
        _nbind.makeBound = makeBound;
        function disableMember(obj, name) {
          function die() {
            throw new Error("Accessing deleted object");
          }
          Object.defineProperty(obj, name, { configurable: false, enumerable: false, get: die, set: die });
        }
        _nbind.ptrMarker = {};
        var BindClass = function(_super) {
          __extends(BindClass2, _super);
          function BindClass2(spec) {
            var _this = _super.call(this, spec) || this;
            _this.wireRead = function(arg2) {
              return _nbind.popValue(arg2, _this.ptrType);
            };
            _this.wireWrite = function(arg2) {
              return pushPointer(arg2, _this.ptrType, true);
            };
            _this.pendingSuperCount = 0;
            _this.ready = false;
            _this.methodTbl = {};
            if (spec.paramList) {
              _this.classType = spec.paramList[0].classType;
              _this.proto = _this.classType.proto;
            } else
              _this.classType = _this;
            return _this;
          }
          BindClass2.prototype.makeBound = function(policyTbl2) {
            var Bound = _nbind.makeBound(policyTbl2, this);
            this.proto = Bound;
            this.ptrType.proto = Bound;
            return Bound;
          };
          BindClass2.prototype.addMethod = function(spec) {
            var overloadList = this.methodTbl[spec.name] || [];
            overloadList.push(spec);
            this.methodTbl[spec.name] = overloadList;
          };
          BindClass2.prototype.registerMethods = function(src, staticOnly) {
            var setter;
            for (var _i = 0, _a2 = Object.keys(src.methodTbl); _i < _a2.length; _i++) {
              var name_1 = _a2[_i];
              var overloadList = src.methodTbl[name_1];
              for (var _b = 0, overloadList_1 = overloadList; _b < overloadList_1.length; _b++) {
                var spec = overloadList_1[_b];
                var target = void 0;
                var caller = void 0;
                target = this.proto.prototype;
                if (staticOnly && spec.signatureType != 1)
                  continue;
                switch (spec.signatureType) {
                  case 1:
                    target = this.proto;
                  case 5:
                    caller = _nbind.makeCaller(spec);
                    _nbind.addMethod(target, spec.name, caller, spec.typeList.length - 1);
                    break;
                  case 4:
                    setter = _nbind.makeMethodCaller(src.ptrType, spec);
                    break;
                  case 3:
                    Object.defineProperty(target, spec.name, { configurable: true, enumerable: false, get: _nbind.makeMethodCaller(src.ptrType, spec), set: setter });
                    break;
                  case 2:
                    caller = _nbind.makeMethodCaller(src.ptrType, spec);
                    _nbind.addMethod(target, spec.name, caller, spec.typeList.length - 1);
                    break;
                  default:
                    break;
                }
              }
            }
          };
          BindClass2.prototype.registerSuperMethods = function(src, firstSuper, visitTbl) {
            if (visitTbl[src.name])
              return;
            visitTbl[src.name] = true;
            var superNum = 0;
            var nextFirst;
            for (var _i = 0, _a2 = src.superIdList || []; _i < _a2.length; _i++) {
              var superId = _a2[_i];
              var superClass = _nbind.getType(superId);
              if (superNum++ < firstSuper || firstSuper < 0) {
                nextFirst = -1;
              } else {
                nextFirst = 0;
              }
              this.registerSuperMethods(superClass, nextFirst, visitTbl);
            }
            this.registerMethods(src, firstSuper < 0);
          };
          BindClass2.prototype.finish = function() {
            if (this.ready)
              return this;
            this.ready = true;
            this.superList = (this.superIdList || []).map(function(superId) {
              return _nbind.getType(superId).finish();
            });
            var Bound = this.proto;
            if (this.superList.length) {
              var Proto = function() {
                this.constructor = Bound;
              };
              Proto.prototype = this.superList[0].proto.prototype;
              Bound.prototype = new Proto();
            }
            if (Bound != Module)
              Bound.prototype.__nbindType = this;
            this.registerSuperMethods(this, 1, {});
            return this;
          };
          BindClass2.prototype.upcastStep = function(dst, ptr2) {
            if (dst == this)
              return ptr2;
            for (var i3 = 0; i3 < this.superList.length; ++i3) {
              var superPtr = this.superList[i3].upcastStep(dst, _nbind.callUpcast(this.upcastList[i3], ptr2));
              if (superPtr)
                return superPtr;
            }
            return 0;
          };
          return BindClass2;
        }(_nbind.BindType);
        BindClass.list = [];
        _nbind.BindClass = BindClass;
        function popPointer(ptr2, type2) {
          return ptr2 ? new type2.proto(_nbind.ptrMarker, type2.flags, ptr2) : null;
        }
        _nbind.popPointer = popPointer;
        function pushPointer(obj, type2, tryValue) {
          if (!(obj instanceof _nbind.Wrapper)) {
            if (tryValue) {
              return _nbind.pushValue(obj);
            } else
              throw new Error("Type mismatch");
          }
          var ptr2 = obj.__nbindPtr;
          var objType = obj.__nbindType.classType;
          var classType = type2.classType;
          if (obj instanceof type2.proto) {
            while (objType != classType) {
              ptr2 = _nbind.callUpcast(objType.upcastList[0], ptr2);
              objType = objType.superList[0];
            }
          } else {
            ptr2 = objType.upcastStep(classType, ptr2);
            if (!ptr2)
              throw new Error("Type mismatch");
          }
          return ptr2;
        }
        _nbind.pushPointer = pushPointer;
        function pushMutablePointer(obj, type2) {
          var ptr2 = pushPointer(obj, type2);
          if (obj.__nbindFlags & 1) {
            throw new Error("Passing a const value as a non-const argument");
          }
          return ptr2;
        }
        var BindClassPtr = function(_super) {
          __extends(BindClassPtr2, _super);
          function BindClassPtr2(spec) {
            var _this = _super.call(this, spec) || this;
            _this.classType = spec.paramList[0].classType;
            _this.proto = _this.classType.proto;
            var isConst = spec.flags & 1;
            var isValue = (_this.flags & 896) == 256 && spec.flags & 2;
            var push = isConst ? pushPointer : pushMutablePointer;
            var pop = isValue ? _nbind.popValue : popPointer;
            _this.makeWireWrite = function(expr, policyTbl2) {
              return policyTbl2["Nullable"] ? function(arg2) {
                return arg2 ? push(arg2, _this) : 0;
              } : function(arg2) {
                return push(arg2, _this);
              };
            };
            _this.wireRead = function(arg2) {
              return pop(arg2, _this);
            };
            _this.wireWrite = function(arg2) {
              return push(arg2, _this);
            };
            return _this;
          }
          return BindClassPtr2;
        }(_nbind.BindType);
        _nbind.BindClassPtr = BindClassPtr;
        function popShared(ptr2, type2) {
          var shared = HEAPU32[ptr2 / 4];
          var unsafe = HEAPU32[ptr2 / 4 + 1];
          return unsafe ? new type2.proto(_nbind.ptrMarker, type2.flags, unsafe, shared) : null;
        }
        _nbind.popShared = popShared;
        function pushShared(obj, type2) {
          if (!(obj instanceof type2.proto))
            throw new Error("Type mismatch");
          return obj.__nbindShared;
        }
        function pushMutableShared(obj, type2) {
          if (!(obj instanceof type2.proto))
            throw new Error("Type mismatch");
          if (obj.__nbindFlags & 1) {
            throw new Error("Passing a const value as a non-const argument");
          }
          return obj.__nbindShared;
        }
        var SharedClassPtr = function(_super) {
          __extends(SharedClassPtr2, _super);
          function SharedClassPtr2(spec) {
            var _this = _super.call(this, spec) || this;
            _this.readResources = [_nbind.resources.pool];
            _this.classType = spec.paramList[0].classType;
            _this.proto = _this.classType.proto;
            var isConst = spec.flags & 1;
            var push = isConst ? pushShared : pushMutableShared;
            _this.wireRead = function(arg2) {
              return popShared(arg2, _this);
            };
            _this.wireWrite = function(arg2) {
              return push(arg2, _this);
            };
            return _this;
          }
          return SharedClassPtr2;
        }(_nbind.BindType);
        _nbind.SharedClassPtr = SharedClassPtr;
        _nbind.externalList = [0];
        var firstFreeExternal = 0;
        var External = function() {
          function External2(data) {
            this.refCount = 1;
            this.data = data;
          }
          External2.prototype.register = function() {
            var num2 = firstFreeExternal;
            if (num2) {
              firstFreeExternal = _nbind.externalList[num2];
            } else
              num2 = _nbind.externalList.length;
            _nbind.externalList[num2] = this;
            return num2;
          };
          External2.prototype.reference = function() {
            ++this.refCount;
          };
          External2.prototype.dereference = function(num2) {
            if (--this.refCount == 0) {
              if (this.free)
                this.free();
              _nbind.externalList[num2] = firstFreeExternal;
              firstFreeExternal = num2;
            }
          };
          return External2;
        }();
        _nbind.External = External;
        function popExternal(num2) {
          var obj = _nbind.externalList[num2];
          obj.dereference(num2);
          return obj.data;
        }
        function pushExternal(obj) {
          var external = new External(obj);
          external.reference();
          return external.register();
        }
        var ExternalType = function(_super) {
          __extends(ExternalType2, _super);
          function ExternalType2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.wireRead = popExternal;
            _this.wireWrite = pushExternal;
            return _this;
          }
          return ExternalType2;
        }(_nbind.BindType);
        _nbind.ExternalType = ExternalType;
        _nbind.callbackSignatureList = [];
        var CallbackType = function(_super) {
          __extends(CallbackType2, _super);
          function CallbackType2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.wireWrite = function(func2) {
              if (typeof func2 != "function")
                _nbind.throwError("Type mismatch");
              return new _nbind.External(func2).register();
            };
            return _this;
          }
          return CallbackType2;
        }(_nbind.BindType);
        _nbind.CallbackType = CallbackType;
        _nbind.valueList = [0];
        var firstFreeValue = 0;
        function pushValue(value) {
          var num2 = firstFreeValue;
          if (num2) {
            firstFreeValue = _nbind.valueList[num2];
          } else
            num2 = _nbind.valueList.length;
          _nbind.valueList[num2] = value;
          return num2 * 2 + 1;
        }
        _nbind.pushValue = pushValue;
        function popValue(num2, type2) {
          if (!num2)
            _nbind.throwError("Value type JavaScript class is missing or not registered");
          if (num2 & 1) {
            num2 >>= 1;
            var obj = _nbind.valueList[num2];
            _nbind.valueList[num2] = firstFreeValue;
            firstFreeValue = num2;
            return obj;
          } else if (type2) {
            return _nbind.popShared(num2, type2);
          } else
            throw new Error("Invalid value slot " + num2);
        }
        _nbind.popValue = popValue;
        var valueBase = 18446744073709552e3;
        function push64(num2) {
          if (typeof num2 == "number")
            return num2;
          return pushValue(num2) * 4096 + valueBase;
        }
        function pop64(num2) {
          if (num2 < valueBase)
            return num2;
          return popValue((num2 - valueBase) / 4096);
        }
        var CreateValueType = function(_super) {
          __extends(CreateValueType2, _super);
          function CreateValueType2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          CreateValueType2.prototype.makeWireWrite = function(expr) {
            return "(_nbind.pushValue(new " + expr + "))";
          };
          return CreateValueType2;
        }(_nbind.BindType);
        _nbind.CreateValueType = CreateValueType;
        var Int64Type = function(_super) {
          __extends(Int64Type2, _super);
          function Int64Type2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.wireWrite = push64;
            _this.wireRead = pop64;
            return _this;
          }
          return Int64Type2;
        }(_nbind.BindType);
        _nbind.Int64Type = Int64Type;
        function pushArray(arr, type2) {
          if (!arr)
            return 0;
          var length = arr.length;
          if ((type2.size || type2.size === 0) && length < type2.size) {
            throw new Error("Type mismatch");
          }
          var ptrSize = type2.memberType.ptrSize;
          var result = _nbind.Pool.lalloc(4 + length * ptrSize);
          HEAPU32[result / 4] = length;
          var heap = type2.memberType.heap;
          var ptr2 = (result + 4) / ptrSize;
          var wireWrite = type2.memberType.wireWrite;
          var num2 = 0;
          if (wireWrite) {
            while (num2 < length) {
              heap[ptr2++] = wireWrite(arr[num2++]);
            }
          } else {
            while (num2 < length) {
              heap[ptr2++] = arr[num2++];
            }
          }
          return result;
        }
        _nbind.pushArray = pushArray;
        function popArray(ptr2, type2) {
          if (ptr2 === 0)
            return null;
          var length = HEAPU32[ptr2 / 4];
          var arr = new Array(length);
          var heap = type2.memberType.heap;
          ptr2 = (ptr2 + 4) / type2.memberType.ptrSize;
          var wireRead = type2.memberType.wireRead;
          var num2 = 0;
          if (wireRead) {
            while (num2 < length) {
              arr[num2++] = wireRead(heap[ptr2++]);
            }
          } else {
            while (num2 < length) {
              arr[num2++] = heap[ptr2++];
            }
          }
          return arr;
        }
        _nbind.popArray = popArray;
        var ArrayType = function(_super) {
          __extends(ArrayType2, _super);
          function ArrayType2(spec) {
            var _this = _super.call(this, spec) || this;
            _this.wireRead = function(arg2) {
              return popArray(arg2, _this);
            };
            _this.wireWrite = function(arg2) {
              return pushArray(arg2, _this);
            };
            _this.readResources = [_nbind.resources.pool];
            _this.writeResources = [_nbind.resources.pool];
            _this.memberType = spec.paramList[0];
            if (spec.paramList[1])
              _this.size = spec.paramList[1];
            return _this;
          }
          return ArrayType2;
        }(_nbind.BindType);
        _nbind.ArrayType = ArrayType;
        function pushString(str, policyTbl2) {
          if (str === null || str === void 0) {
            if (policyTbl2 && policyTbl2["Nullable"]) {
              str = "";
            } else
              throw new Error("Type mismatch");
          }
          if (policyTbl2 && policyTbl2["Strict"]) {
            if (typeof str != "string")
              throw new Error("Type mismatch");
          } else
            str = str.toString();
          var length = Module.lengthBytesUTF8(str);
          var result = _nbind.Pool.lalloc(4 + length + 1);
          HEAPU32[result / 4] = length;
          Module.stringToUTF8Array(str, HEAPU8, result + 4, length + 1);
          return result;
        }
        _nbind.pushString = pushString;
        function popString(ptr2) {
          if (ptr2 === 0)
            return null;
          var length = HEAPU32[ptr2 / 4];
          return Module.Pointer_stringify(ptr2 + 4, length);
        }
        _nbind.popString = popString;
        var StringType = function(_super) {
          __extends(StringType2, _super);
          function StringType2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.wireRead = popString;
            _this.wireWrite = pushString;
            _this.readResources = [_nbind.resources.pool];
            _this.writeResources = [_nbind.resources.pool];
            return _this;
          }
          StringType2.prototype.makeWireWrite = function(expr, policyTbl2) {
            return function(arg2) {
              return pushString(arg2, policyTbl2);
            };
          };
          return StringType2;
        }(_nbind.BindType);
        _nbind.StringType = StringType;
        function makeArgList(argCount) {
          return Array.apply(null, Array(argCount)).map(function(dummy, num2) {
            return "a" + (num2 + 1);
          });
        }
        function anyNeedsWireWrite(typeList, policyTbl2) {
          return typeList.reduce(function(result, type2) {
            return result || type2.needsWireWrite(policyTbl2);
          }, false);
        }
        function anyNeedsWireRead(typeList, policyTbl2) {
          return typeList.reduce(function(result, type2) {
            return result || !!type2.needsWireRead(policyTbl2);
          }, false);
        }
        function makeWireRead(convertParamList2, policyTbl2, type2, expr) {
          var paramNum = convertParamList2.length;
          if (type2.makeWireRead) {
            return type2.makeWireRead(expr, convertParamList2, paramNum);
          } else if (type2.wireRead) {
            convertParamList2[paramNum] = type2.wireRead;
            return "(convertParamList[" + paramNum + "](" + expr + "))";
          } else
            return expr;
        }
        function makeWireWrite(convertParamList2, policyTbl2, type2, expr) {
          var wireWrite;
          var paramNum = convertParamList2.length;
          if (type2.makeWireWrite) {
            wireWrite = type2.makeWireWrite(expr, policyTbl2, convertParamList2, paramNum);
          } else
            wireWrite = type2.wireWrite;
          if (wireWrite) {
            if (typeof wireWrite == "string") {
              return wireWrite;
            } else {
              convertParamList2[paramNum] = wireWrite;
              return "(convertParamList[" + paramNum + "](" + expr + "))";
            }
          } else
            return expr;
        }
        function buildCallerFunction(dynCall, ptrType, ptr, num, policyTbl, needsWireWrite, prefix, returnType, argTypeList, mask, err) {
          var argList = makeArgList(argTypeList.length);
          var convertParamList = [];
          var callExpression = makeWireRead(convertParamList, policyTbl, returnType, "dynCall(" + [prefix].concat(argList.map(function(name, index) {
            return makeWireWrite(convertParamList, policyTbl, argTypeList[index], name);
          })).join(",") + ")");
          var resourceSet = _nbind.listResources([returnType], argTypeList);
          var sourceCode = "function(" + argList.join(",") + "){" + (mask ? "this.__nbindFlags&mask&&err();" : "") + resourceSet.makeOpen() + "var r=" + callExpression + ";" + resourceSet.makeClose() + "return r;}";
          return eval("(" + sourceCode + ")");
        }
        function buildJSCallerFunction(returnType, argTypeList) {
          var argList = makeArgList(argTypeList.length);
          var convertParamList = [];
          var callExpression = makeWireWrite(convertParamList, null, returnType, "_nbind.externalList[num].data(" + argList.map(function(name, index) {
            return makeWireRead(convertParamList, null, argTypeList[index], name);
          }).join(",") + ")");
          var resourceSet = _nbind.listResources(argTypeList, [returnType]);
          resourceSet.remove(_nbind.resources.pool);
          var sourceCode = "function(" + ["dummy", "num"].concat(argList).join(",") + "){" + resourceSet.makeOpen() + "var r=" + callExpression + ";" + resourceSet.makeClose() + "return r;}";
          return eval("(" + sourceCode + ")");
        }
        _nbind.buildJSCallerFunction = buildJSCallerFunction;
        function makeJSCaller(idList) {
          var argCount = idList.length - 1;
          var typeList = _nbind.getTypes(idList, "callback");
          var returnType2 = typeList[0];
          var argTypeList2 = typeList.slice(1);
          var needsWireRead = anyNeedsWireRead(argTypeList2, null);
          var needsWireWrite2 = returnType2.needsWireWrite(null);
          if (!needsWireWrite2 && !needsWireRead) {
            switch (argCount) {
              case 0:
                return function(dummy, num2) {
                  return _nbind.externalList[num2].data();
                };
              case 1:
                return function(dummy, num2, a1) {
                  return _nbind.externalList[num2].data(a1);
                };
              case 2:
                return function(dummy, num2, a1, a2) {
                  return _nbind.externalList[num2].data(a1, a2);
                };
              case 3:
                return function(dummy, num2, a1, a2, a3) {
                  return _nbind.externalList[num2].data(a1, a2, a3);
                };
              default:
                break;
            }
          }
          return buildJSCallerFunction(returnType2, argTypeList2);
        }
        _nbind.makeJSCaller = makeJSCaller;
        function makeMethodCaller(ptrType2, spec) {
          var argCount = spec.typeList.length - 1;
          var typeIdList = spec.typeList.slice(0);
          typeIdList.splice(1, 0, "uint32_t", spec.boundID);
          var typeList = _nbind.getTypes(typeIdList, spec.title);
          var returnType2 = typeList[0];
          var argTypeList2 = typeList.slice(3);
          var needsWireRead = returnType2.needsWireRead(spec.policyTbl);
          var needsWireWrite2 = anyNeedsWireWrite(argTypeList2, spec.policyTbl);
          var ptr2 = spec.ptr;
          var num2 = spec.num;
          var dynCall2 = _nbind.getDynCall(typeList, spec.title);
          var mask2 = ~spec.flags & 1;
          function err2() {
            throw new Error("Calling a non-const method on a const object");
          }
          if (!needsWireRead && !needsWireWrite2) {
            switch (argCount) {
              case 0:
                return function() {
                  return this.__nbindFlags & mask2 ? err2() : dynCall2(ptr2, num2, _nbind.pushPointer(this, ptrType2));
                };
              case 1:
                return function(a1) {
                  return this.__nbindFlags & mask2 ? err2() : dynCall2(ptr2, num2, _nbind.pushPointer(this, ptrType2), a1);
                };
              case 2:
                return function(a1, a2) {
                  return this.__nbindFlags & mask2 ? err2() : dynCall2(ptr2, num2, _nbind.pushPointer(this, ptrType2), a1, a2);
                };
              case 3:
                return function(a1, a2, a3) {
                  return this.__nbindFlags & mask2 ? err2() : dynCall2(ptr2, num2, _nbind.pushPointer(this, ptrType2), a1, a2, a3);
                };
              default:
                break;
            }
          }
          return buildCallerFunction(dynCall2, ptrType2, ptr2, num2, spec.policyTbl, needsWireWrite2, "ptr,num,pushPointer(this,ptrType)", returnType2, argTypeList2, mask2, err2);
        }
        _nbind.makeMethodCaller = makeMethodCaller;
        function makeCaller(spec) {
          var argCount = spec.typeList.length - 1;
          var typeList = _nbind.getTypes(spec.typeList, spec.title);
          var returnType2 = typeList[0];
          var argTypeList2 = typeList.slice(1);
          var needsWireRead = returnType2.needsWireRead(spec.policyTbl);
          var needsWireWrite2 = anyNeedsWireWrite(argTypeList2, spec.policyTbl);
          var direct = spec.direct;
          var ptr2 = spec.ptr;
          if (spec.direct && !needsWireRead && !needsWireWrite2) {
            var dynCall_1 = _nbind.getDynCall(typeList, spec.title);
            switch (argCount) {
              case 0:
                return function() {
                  return dynCall_1(direct);
                };
              case 1:
                return function(a1) {
                  return dynCall_1(direct, a1);
                };
              case 2:
                return function(a1, a2) {
                  return dynCall_1(direct, a1, a2);
                };
              case 3:
                return function(a1, a2, a3) {
                  return dynCall_1(direct, a1, a2, a3);
                };
              default:
                break;
            }
            ptr2 = 0;
          }
          var prefix2;
          if (ptr2) {
            var typeIdList = spec.typeList.slice(0);
            typeIdList.splice(1, 0, "uint32_t");
            typeList = _nbind.getTypes(typeIdList, spec.title);
            prefix2 = "ptr,num";
          } else {
            ptr2 = direct;
            prefix2 = "ptr";
          }
          var dynCall2 = _nbind.getDynCall(typeList, spec.title);
          return buildCallerFunction(dynCall2, null, ptr2, spec.num, spec.policyTbl, needsWireWrite2, prefix2, returnType2, argTypeList2);
        }
        _nbind.makeCaller = makeCaller;
        function makeOverloader(func2, arity) {
          var callerList = [];
          function call() {
            return callerList[arguments.length].apply(this, arguments);
          }
          call.addMethod = function(_func, _arity) {
            callerList[_arity] = _func;
          };
          call.addMethod(func2, arity);
          return call;
        }
        _nbind.makeOverloader = makeOverloader;
        var Resource = function() {
          function Resource3(open, close) {
            var _this = this;
            this.makeOpen = function() {
              return Object.keys(_this.openTbl).join("");
            };
            this.makeClose = function() {
              return Object.keys(_this.closeTbl).join("");
            };
            this.openTbl = {};
            this.closeTbl = {};
            if (open)
              this.openTbl[open] = true;
            if (close)
              this.closeTbl[close] = true;
          }
          Resource3.prototype.add = function(other) {
            for (var _i = 0, _a2 = Object.keys(other.openTbl); _i < _a2.length; _i++) {
              var key2 = _a2[_i];
              this.openTbl[key2] = true;
            }
            for (var _b = 0, _c = Object.keys(other.closeTbl); _b < _c.length; _b++) {
              var key2 = _c[_b];
              this.closeTbl[key2] = true;
            }
          };
          Resource3.prototype.remove = function(other) {
            for (var _i = 0, _a2 = Object.keys(other.openTbl); _i < _a2.length; _i++) {
              var key2 = _a2[_i];
              delete this.openTbl[key2];
            }
            for (var _b = 0, _c = Object.keys(other.closeTbl); _b < _c.length; _b++) {
              var key2 = _c[_b];
              delete this.closeTbl[key2];
            }
          };
          return Resource3;
        }();
        _nbind.Resource = Resource;
        function listResources(readList, writeList) {
          var result = new Resource();
          for (var _i = 0, readList_1 = readList; _i < readList_1.length; _i++) {
            var bindType = readList_1[_i];
            for (var _a2 = 0, _b = bindType.readResources || []; _a2 < _b.length; _a2++) {
              var resource = _b[_a2];
              result.add(resource);
            }
          }
          for (var _c = 0, writeList_1 = writeList; _c < writeList_1.length; _c++) {
            var bindType = writeList_1[_c];
            for (var _d = 0, _e = bindType.writeResources || []; _d < _e.length; _d++) {
              var resource = _e[_d];
              result.add(resource);
            }
          }
          return result;
        }
        _nbind.listResources = listResources;
        _nbind.resources = { pool: new Resource("var used=HEAPU32[_nbind.Pool.usedPtr],page=HEAPU32[_nbind.Pool.pagePtr];", "_nbind.Pool.lreset(used,page);") };
        var ExternalBuffer = function(_super) {
          __extends(ExternalBuffer2, _super);
          function ExternalBuffer2(buf, ptr2) {
            var _this = _super.call(this, buf) || this;
            _this.ptr = ptr2;
            return _this;
          }
          ExternalBuffer2.prototype.free = function() {
            _free(this.ptr);
          };
          return ExternalBuffer2;
        }(_nbind.External);
        function getBuffer(buf) {
          if (buf instanceof ArrayBuffer) {
            return new Uint8Array(buf);
          } else if (buf instanceof DataView) {
            return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
          } else
            return buf;
        }
        function pushBuffer(buf, policyTbl2) {
          if (buf === null || buf === void 0) {
            if (policyTbl2 && policyTbl2["Nullable"])
              buf = [];
          }
          if (typeof buf != "object")
            throw new Error("Type mismatch");
          var b2 = buf;
          var length = b2.byteLength || b2.length;
          if (!length && length !== 0 && b2.byteLength !== 0)
            throw new Error("Type mismatch");
          var result = _nbind.Pool.lalloc(8);
          var data = _malloc(length);
          var ptr2 = result / 4;
          HEAPU32[ptr2++] = length;
          HEAPU32[ptr2++] = data;
          HEAPU32[ptr2++] = new ExternalBuffer(buf, data).register();
          HEAPU8.set(getBuffer(buf), data);
          return result;
        }
        var BufferType = function(_super) {
          __extends(BufferType2, _super);
          function BufferType2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.wireWrite = pushBuffer;
            _this.readResources = [_nbind.resources.pool];
            _this.writeResources = [_nbind.resources.pool];
            return _this;
          }
          BufferType2.prototype.makeWireWrite = function(expr, policyTbl2) {
            return function(arg2) {
              return pushBuffer(arg2, policyTbl2);
            };
          };
          return BufferType2;
        }(_nbind.BindType);
        _nbind.BufferType = BufferType;
        function commitBuffer(num2, data, length) {
          var buf = _nbind.externalList[num2].data;
          var NodeBuffer = Buffer;
          if (typeof Buffer != "function")
            NodeBuffer = function() {
            };
          if (buf instanceof Array) {
          } else {
            var src = HEAPU8.subarray(data, data + length);
            if (buf instanceof NodeBuffer) {
              var srcBuf = void 0;
              if (typeof Buffer.from == "function" && Buffer.from.length >= 3) {
                srcBuf = Buffer.from(src);
              } else
                srcBuf = new Buffer(src);
              srcBuf.copy(buf);
            } else
              getBuffer(buf).set(src);
          }
        }
        _nbind.commitBuffer = commitBuffer;
        var dirtyList = [];
        var gcTimer = 0;
        function sweep() {
          for (var _i = 0, dirtyList_1 = dirtyList; _i < dirtyList_1.length; _i++) {
            var obj = dirtyList_1[_i];
            if (!(obj.__nbindState & (1 | 2))) {
              obj.free();
            }
          }
          dirtyList = [];
          gcTimer = 0;
        }
        _nbind.mark = function(obj) {
        };
        function toggleLightGC(enable) {
          if (enable) {
            _nbind.mark = function(obj) {
              dirtyList.push(obj);
              if (!gcTimer)
                gcTimer = setTimeout(sweep, 0);
            };
          } else {
            _nbind.mark = function(obj) {
            };
          }
        }
        _nbind.toggleLightGC = toggleLightGC;
      })(_nbind);
      Module["requestFullScreen"] = function Module_requestFullScreen(lockPointer, resizeCanvas, vrDevice) {
        Module.printErr("Module.requestFullScreen is deprecated. Please call Module.requestFullscreen instead.");
        Module["requestFullScreen"] = Module["requestFullscreen"];
        Browser.requestFullScreen(lockPointer, resizeCanvas, vrDevice);
      };
      Module["requestFullscreen"] = function Module_requestFullscreen(lockPointer, resizeCanvas, vrDevice) {
        Browser.requestFullscreen(lockPointer, resizeCanvas, vrDevice);
      };
      Module["requestAnimationFrame"] = function Module_requestAnimationFrame(func2) {
        Browser.requestAnimationFrame(func2);
      };
      Module["setCanvasSize"] = function Module_setCanvasSize(width, height, noUpdates) {
        Browser.setCanvasSize(width, height, noUpdates);
      };
      Module["pauseMainLoop"] = function Module_pauseMainLoop() {
        Browser.mainLoop.pause();
      };
      Module["resumeMainLoop"] = function Module_resumeMainLoop() {
        Browser.mainLoop.resume();
      };
      Module["getUserMedia"] = function Module_getUserMedia() {
        Browser.getUserMedia();
      };
      Module["createContext"] = function Module_createContext(canvas3, useWebGL, setInModule, webGLContextAttributes) {
        return Browser.createContext(canvas3, useWebGL, setInModule, webGLContextAttributes);
      };
      if (ENVIRONMENT_IS_NODE) {
        _emscripten_get_now = function _emscripten_get_now_actual() {
          var t2 = process["hrtime"]();
          return t2[0] * 1e3 + t2[1] / 1e6;
        };
      } else if (typeof dateNow !== "undefined") {
        _emscripten_get_now = dateNow;
      } else if (typeof self === "object" && self["performance"] && typeof self["performance"]["now"] === "function") {
        _emscripten_get_now = function() {
          return self["performance"]["now"]();
        };
      } else if (typeof performance === "object" && typeof performance["now"] === "function") {
        _emscripten_get_now = function() {
          return performance["now"]();
        };
      } else {
        _emscripten_get_now = Date.now;
      }
      __ATEXIT__.push(function() {
        var fflush = Module["_fflush"];
        if (fflush)
          fflush(0);
        var printChar = ___syscall146.printChar;
        if (!printChar)
          return;
        var buffers = ___syscall146.buffers;
        if (buffers[1].length)
          printChar(1, 10);
        if (buffers[2].length)
          printChar(2, 10);
      });
      DYNAMICTOP_PTR = allocate(1, "i32", ALLOC_STATIC);
      STACK_BASE = STACKTOP = Runtime.alignMemory(STATICTOP);
      STACK_MAX = STACK_BASE + TOTAL_STACK;
      DYNAMIC_BASE = Runtime.alignMemory(STACK_MAX);
      HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
      staticSealed = true;
      function invoke_viiiii(index, a1, a2, a3, a4, a5) {
        try {
          Module["dynCall_viiiii"](index, a1, a2, a3, a4, a5);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_vif(index, a1, a2) {
        try {
          Module["dynCall_vif"](index, a1, a2);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_vid(index, a1, a2) {
        try {
          Module["dynCall_vid"](index, a1, a2);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_fiff(index, a1, a2, a3) {
        try {
          return Module["dynCall_fiff"](index, a1, a2, a3);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_vi(index, a1) {
        try {
          Module["dynCall_vi"](index, a1);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_vii(index, a1, a2) {
        try {
          Module["dynCall_vii"](index, a1, a2);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_ii(index, a1) {
        try {
          return Module["dynCall_ii"](index, a1);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_viddi(index, a1, a2, a3, a4) {
        try {
          Module["dynCall_viddi"](index, a1, a2, a3, a4);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_vidd(index, a1, a2, a3) {
        try {
          Module["dynCall_vidd"](index, a1, a2, a3);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_iiii(index, a1, a2, a3) {
        try {
          return Module["dynCall_iiii"](index, a1, a2, a3);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_diii(index, a1, a2, a3) {
        try {
          return Module["dynCall_diii"](index, a1, a2, a3);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_di(index, a1) {
        try {
          return Module["dynCall_di"](index, a1);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_iid(index, a1, a2) {
        try {
          return Module["dynCall_iid"](index, a1, a2);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_iii(index, a1, a2) {
        try {
          return Module["dynCall_iii"](index, a1, a2);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_viiddi(index, a1, a2, a3, a4, a5) {
        try {
          Module["dynCall_viiddi"](index, a1, a2, a3, a4, a5);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
        try {
          Module["dynCall_viiiiii"](index, a1, a2, a3, a4, a5, a6);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_dii(index, a1, a2) {
        try {
          return Module["dynCall_dii"](index, a1, a2);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_i(index) {
        try {
          return Module["dynCall_i"](index);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
        try {
          return Module["dynCall_iiiiii"](index, a1, a2, a3, a4, a5);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_viiid(index, a1, a2, a3, a4) {
        try {
          Module["dynCall_viiid"](index, a1, a2, a3, a4);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_viififi(index, a1, a2, a3, a4, a5, a6) {
        try {
          Module["dynCall_viififi"](index, a1, a2, a3, a4, a5, a6);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_viii(index, a1, a2, a3) {
        try {
          Module["dynCall_viii"](index, a1, a2, a3);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_v(index) {
        try {
          Module["dynCall_v"](index);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_viid(index, a1, a2, a3) {
        try {
          Module["dynCall_viid"](index, a1, a2, a3);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_idd(index, a1, a2) {
        try {
          return Module["dynCall_idd"](index, a1, a2);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      function invoke_viiii(index, a1, a2, a3, a4) {
        try {
          Module["dynCall_viiii"](index, a1, a2, a3, a4);
        } catch (e3) {
          if (typeof e3 !== "number" && e3 !== "longjmp")
            throw e3;
          Module["setThrew"](1, 0);
        }
      }
      Module.asmGlobalArg = { "Math": Math, "Int8Array": Int8Array, "Int16Array": Int16Array, "Int32Array": Int32Array, "Uint8Array": Uint8Array, "Uint16Array": Uint16Array, "Uint32Array": Uint32Array, "Float32Array": Float32Array, "Float64Array": Float64Array, "NaN": NaN, "Infinity": Infinity };
      Module.asmLibraryArg = { "abort": abort, "assert": assert, "enlargeMemory": enlargeMemory, "getTotalMemory": getTotalMemory, "abortOnCannotGrowMemory": abortOnCannotGrowMemory, "invoke_viiiii": invoke_viiiii, "invoke_vif": invoke_vif, "invoke_vid": invoke_vid, "invoke_fiff": invoke_fiff, "invoke_vi": invoke_vi, "invoke_vii": invoke_vii, "invoke_ii": invoke_ii, "invoke_viddi": invoke_viddi, "invoke_vidd": invoke_vidd, "invoke_iiii": invoke_iiii, "invoke_diii": invoke_diii, "invoke_di": invoke_di, "invoke_iid": invoke_iid, "invoke_iii": invoke_iii, "invoke_viiddi": invoke_viiddi, "invoke_viiiiii": invoke_viiiiii, "invoke_dii": invoke_dii, "invoke_i": invoke_i, "invoke_iiiiii": invoke_iiiiii, "invoke_viiid": invoke_viiid, "invoke_viififi": invoke_viififi, "invoke_viii": invoke_viii, "invoke_v": invoke_v, "invoke_viid": invoke_viid, "invoke_idd": invoke_idd, "invoke_viiii": invoke_viiii, "_emscripten_asm_const_iiiii": _emscripten_asm_const_iiiii, "_emscripten_asm_const_iiidddddd": _emscripten_asm_const_iiidddddd, "_emscripten_asm_const_iiiid": _emscripten_asm_const_iiiid, "__nbind_reference_external": __nbind_reference_external, "_emscripten_asm_const_iiiiiiii": _emscripten_asm_const_iiiiiiii, "_removeAccessorPrefix": _removeAccessorPrefix, "_typeModule": _typeModule, "__nbind_register_pool": __nbind_register_pool, "__decorate": __decorate, "_llvm_stackrestore": _llvm_stackrestore, "___cxa_atexit": ___cxa_atexit, "__extends": __extends, "__nbind_get_value_object": __nbind_get_value_object, "__ZN8facebook4yoga14YGNodeToStringEPNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEP6YGNode14YGPrintOptionsj": __ZN8facebook4yoga14YGNodeToStringEPNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEP6YGNode14YGPrintOptionsj, "_emscripten_set_main_loop_timing": _emscripten_set_main_loop_timing, "__nbind_register_primitive": __nbind_register_primitive, "__nbind_register_type": __nbind_register_type, "_emscripten_memcpy_big": _emscripten_memcpy_big, "__nbind_register_function": __nbind_register_function, "___setErrNo": ___setErrNo, "__nbind_register_class": __nbind_register_class, "__nbind_finish": __nbind_finish, "_abort": _abort, "_nbind_value": _nbind_value, "_llvm_stacksave": _llvm_stacksave, "___syscall54": ___syscall54, "_defineHidden": _defineHidden, "_emscripten_set_main_loop": _emscripten_set_main_loop, "_emscripten_get_now": _emscripten_get_now, "__nbind_register_callback_signature": __nbind_register_callback_signature, "_emscripten_asm_const_iiiiii": _emscripten_asm_const_iiiiii, "__nbind_free_external": __nbind_free_external, "_emscripten_asm_const_iiii": _emscripten_asm_const_iiii, "_emscripten_asm_const_iiididi": _emscripten_asm_const_iiididi, "___syscall6": ___syscall6, "_atexit": _atexit, "___syscall140": ___syscall140, "___syscall146": ___syscall146, "DYNAMICTOP_PTR": DYNAMICTOP_PTR, "tempDoublePtr": tempDoublePtr, "ABORT": ABORT, "STACKTOP": STACKTOP, "STACK_MAX": STACK_MAX, "cttz_i8": cttz_i8, "___dso_handle": ___dso_handle };
      var asm = function(global2, env, buffer2) {
        ;
        var a2 = new global2.Int8Array(buffer2);
        var b2 = new global2.Int16Array(buffer2);
        var c2 = new global2.Int32Array(buffer2);
        var d3 = new global2.Uint8Array(buffer2);
        var e3 = new global2.Uint16Array(buffer2);
        var f3 = new global2.Uint32Array(buffer2);
        var g2 = new global2.Float32Array(buffer2);
        var h2 = new global2.Float64Array(buffer2);
        var i3 = env.DYNAMICTOP_PTR | 0;
        var j3 = env.tempDoublePtr | 0;
        var k3 = env.ABORT | 0;
        var l3 = env.STACKTOP | 0;
        var m3 = env.STACK_MAX | 0;
        var n2 = env.cttz_i8 | 0;
        var o2 = env.___dso_handle | 0;
        var p3 = 0;
        var q2 = 0;
        var r2 = 0;
        var s2 = 0;
        var t2 = global2.NaN, u3 = global2.Infinity;
        var v3 = 0, w2 = 0, x3 = 0, y2 = 0, z2 = 0;
        var A2 = 0;
        var B2 = global2.Math.floor;
        var C2 = global2.Math.abs;
        var D2 = global2.Math.sqrt;
        var E2 = global2.Math.pow;
        var F2 = global2.Math.cos;
        var G2 = global2.Math.sin;
        var H2 = global2.Math.tan;
        var I2 = global2.Math.acos;
        var J2 = global2.Math.asin;
        var K2 = global2.Math.atan;
        var L2 = global2.Math.atan2;
        var M3 = global2.Math.exp;
        var N3 = global2.Math.log;
        var O2 = global2.Math.ceil;
        var P2 = global2.Math.imul;
        var Q2 = global2.Math.min;
        var R2 = global2.Math.max;
        var S3 = global2.Math.clz32;
        var T2 = global2.Math.fround;
        var U2 = env.abort;
        var V2 = env.assert;
        var W2 = env.enlargeMemory;
        var X2 = env.getTotalMemory;
        var Y2 = env.abortOnCannotGrowMemory;
        var Z2 = env.invoke_viiiii;
        var _2 = env.invoke_vif;
        var $3 = env.invoke_vid;
        var aa = env.invoke_fiff;
        var ba = env.invoke_vi;
        var ca = env.invoke_vii;
        var da = env.invoke_ii;
        var ea = env.invoke_viddi;
        var fa = env.invoke_vidd;
        var ga = env.invoke_iiii;
        var ha = env.invoke_diii;
        var ia = env.invoke_di;
        var ja = env.invoke_iid;
        var ka = env.invoke_iii;
        var la = env.invoke_viiddi;
        var ma = env.invoke_viiiiii;
        var na = env.invoke_dii;
        var oa = env.invoke_i;
        var pa = env.invoke_iiiiii;
        var qa = env.invoke_viiid;
        var ra = env.invoke_viififi;
        var sa = env.invoke_viii;
        var ta = env.invoke_v;
        var ua = env.invoke_viid;
        var va = env.invoke_idd;
        var wa = env.invoke_viiii;
        var xa = env._emscripten_asm_const_iiiii;
        var ya = env._emscripten_asm_const_iiidddddd;
        var za = env._emscripten_asm_const_iiiid;
        var Aa = env.__nbind_reference_external;
        var Ba = env._emscripten_asm_const_iiiiiiii;
        var Ca = env._removeAccessorPrefix;
        var Da = env._typeModule;
        var Ea = env.__nbind_register_pool;
        var Fa = env.__decorate;
        var Ga = env._llvm_stackrestore;
        var Ha = env.___cxa_atexit;
        var Ia = env.__extends;
        var Ja = env.__nbind_get_value_object;
        var Ka = env.__ZN8facebook4yoga14YGNodeToStringEPNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEP6YGNode14YGPrintOptionsj;
        var La = env._emscripten_set_main_loop_timing;
        var Ma = env.__nbind_register_primitive;
        var Na = env.__nbind_register_type;
        var Oa = env._emscripten_memcpy_big;
        var Pa = env.__nbind_register_function;
        var Qa = env.___setErrNo;
        var Ra = env.__nbind_register_class;
        var Sa = env.__nbind_finish;
        var Ta = env._abort;
        var Ua = env._nbind_value;
        var Va = env._llvm_stacksave;
        var Wa = env.___syscall54;
        var Xa = env._defineHidden;
        var Ya = env._emscripten_set_main_loop;
        var Za = env._emscripten_get_now;
        var _a2 = env.__nbind_register_callback_signature;
        var $a = env._emscripten_asm_const_iiiiii;
        var ab = env.__nbind_free_external;
        var bb = env._emscripten_asm_const_iiii;
        var cb2 = env._emscripten_asm_const_iiididi;
        var db = env.___syscall6;
        var eb = env._atexit;
        var fb = env.___syscall140;
        var gb = env.___syscall146;
        var hb = T2(0);
        const ib = T2(0);
        function Jb(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = l3;
          l3 = l3 + a3 | 0;
          l3 = l3 + 15 & -16;
          return b3 | 0;
        }
        function Kb() {
          return l3 | 0;
        }
        function Lb(a3) {
          a3 = a3 | 0;
          l3 = a3;
        }
        function Mb(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          l3 = a3;
          m3 = b3;
        }
        function Nb(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          if (!p3) {
            p3 = a3;
            q2 = b3;
          }
        }
        function Ob(a3) {
          a3 = a3 | 0;
          A2 = a3;
        }
        function Pb() {
          return A2 | 0;
        }
        function Qb() {
          var b3 = 0, d4 = 0;
          BC(8104, 8, 400) | 0;
          BC(8504, 408, 540) | 0;
          b3 = 9044;
          d4 = b3 + 44 | 0;
          do {
            c2[b3 >> 2] = 0;
            b3 = b3 + 4 | 0;
          } while ((b3 | 0) < (d4 | 0));
          a2[9088] = 0;
          a2[9089] = 1;
          c2[2273] = 0;
          c2[2274] = 948;
          c2[2275] = 948;
          Ha(17, 8104, o2 | 0) | 0;
          return;
        }
        function Rb(a3) {
          a3 = a3 | 0;
          oc(a3 + 948 | 0);
          return;
        }
        function Sb(a3) {
          a3 = T2(a3);
          return ((af(a3) | 0) & 2147483647) >>> 0 > 2139095040 | 0;
        }
        function Tb(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          a:
            do
              if (!(c2[a3 + (b3 << 3) + 4 >> 2] | 0)) {
                if ((b3 | 2 | 0) == 3 ? c2[a3 + 60 >> 2] | 0 : 0) {
                  a3 = a3 + 56 | 0;
                  break;
                }
                switch (b3 | 0) {
                  case 0:
                  case 2:
                  case 4:
                  case 5: {
                    if (c2[a3 + 52 >> 2] | 0) {
                      a3 = a3 + 48 | 0;
                      break a;
                    }
                    break;
                  }
                  default: {
                  }
                }
                if (!(c2[a3 + 68 >> 2] | 0)) {
                  a3 = (b3 | 1 | 0) == 5 ? 948 : d4;
                  break;
                } else {
                  a3 = a3 + 64 | 0;
                  break;
                }
              } else
                a3 = a3 + (b3 << 3) | 0;
            while (0);
          return a3 | 0;
        }
        function Ub(b3) {
          b3 = b3 | 0;
          var d4 = 0;
          d4 = oB(1e3) | 0;
          Vb(b3, (d4 | 0) != 0, 2456);
          c2[2276] = (c2[2276] | 0) + 1;
          BC(d4 | 0, 8104, 1e3) | 0;
          if (a2[b3 + 2 >> 0] | 0) {
            c2[d4 + 4 >> 2] = 2;
            c2[d4 + 12 >> 2] = 4;
          }
          c2[d4 + 976 >> 2] = b3;
          return d4 | 0;
        }
        function Vb(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0;
          f4 = l3;
          l3 = l3 + 16 | 0;
          e4 = f4;
          if (!b3) {
            c2[e4 >> 2] = d4;
            fe(a3, 5, 3197, e4);
          }
          l3 = f4;
          return;
        }
        function Wb() {
          return Ub(956) | 0;
        }
        function Xb(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = qC(1e3) | 0;
          Yb(b3, a3);
          Vb(c2[a3 + 976 >> 2] | 0, 1, 2456);
          c2[2276] = (c2[2276] | 0) + 1;
          c2[b3 + 944 >> 2] = 0;
          return b3 | 0;
        }
        function Yb(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          BC(a3 | 0, b3 | 0, 948) | 0;
          ie(a3 + 948 | 0, b3 + 948 | 0);
          d4 = a3 + 960 | 0;
          a3 = b3 + 960 | 0;
          b3 = d4 + 40 | 0;
          do {
            c2[d4 >> 2] = c2[a3 >> 2];
            d4 = d4 + 4 | 0;
            a3 = a3 + 4 | 0;
          } while ((d4 | 0) < (b3 | 0));
          return;
        }
        function Zb(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0, f4 = 0;
          b3 = a3 + 944 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 | 0) {
            _b(d4 + 948 | 0, a3) | 0;
            c2[b3 >> 2] = 0;
          }
          d4 = $b(a3) | 0;
          if (d4 | 0) {
            b3 = 0;
            do {
              c2[(ac(a3, b3) | 0) + 944 >> 2] = 0;
              b3 = b3 + 1 | 0;
            } while ((b3 | 0) != (d4 | 0));
          }
          d4 = a3 + 948 | 0;
          e4 = c2[d4 >> 2] | 0;
          f4 = a3 + 952 | 0;
          b3 = c2[f4 >> 2] | 0;
          if ((b3 | 0) != (e4 | 0))
            c2[f4 >> 2] = b3 + (~((b3 + -4 - e4 | 0) >>> 2) << 2);
          bc(d4);
          pB(a3);
          c2[2276] = (c2[2276] | 0) + -1;
          return;
        }
        function _b(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = c2[a3 >> 2] | 0;
          i4 = a3 + 4 | 0;
          d4 = c2[i4 >> 2] | 0;
          g3 = d4;
          a:
            do
              if ((e4 | 0) == (d4 | 0)) {
                f4 = e4;
                h3 = 4;
              } else {
                a3 = e4;
                while (1) {
                  if ((c2[a3 >> 2] | 0) == (b3 | 0)) {
                    f4 = a3;
                    h3 = 4;
                    break a;
                  }
                  a3 = a3 + 4 | 0;
                  if ((a3 | 0) == (d4 | 0)) {
                    a3 = 0;
                    break;
                  }
                }
              }
            while (0);
          if ((h3 | 0) == 4)
            if ((f4 | 0) != (d4 | 0)) {
              e4 = f4 + 4 | 0;
              a3 = g3 - e4 | 0;
              b3 = a3 >> 2;
              if (b3) {
                GC(f4 | 0, e4 | 0, a3 | 0) | 0;
                d4 = c2[i4 >> 2] | 0;
              }
              a3 = f4 + (b3 << 2) | 0;
              if ((d4 | 0) == (a3 | 0))
                a3 = 1;
              else {
                c2[i4 >> 2] = d4 + (~((d4 + -4 - a3 | 0) >>> 2) << 2);
                a3 = 1;
              }
            } else
              a3 = 0;
          return a3 | 0;
        }
        function $b(a3) {
          a3 = a3 | 0;
          return (c2[a3 + 952 >> 2] | 0) - (c2[a3 + 948 >> 2] | 0) >> 2 | 0;
        }
        function ac(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = c2[a3 + 948 >> 2] | 0;
          if ((c2[a3 + 952 >> 2] | 0) - d4 >> 2 >>> 0 > b3 >>> 0)
            a3 = c2[d4 + (b3 << 2) >> 2] | 0;
          else
            a3 = 0;
          return a3 | 0;
        }
        function bc(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0, f4 = 0;
          e4 = l3;
          l3 = l3 + 32 | 0;
          b3 = e4;
          f4 = c2[a3 >> 2] | 0;
          d4 = (c2[a3 + 4 >> 2] | 0) - f4 | 0;
          if (((c2[a3 + 8 >> 2] | 0) - f4 | 0) >>> 0 > d4 >>> 0) {
            f4 = d4 >> 2;
            bf(b3, f4, f4, a3 + 8 | 0);
            cf(a3, b3);
            df(b3);
          }
          l3 = e4;
          return;
        }
        function cc(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0;
          k4 = $b(a3) | 0;
          do
            if (k4 | 0) {
              if ((c2[(ac(a3, 0) | 0) + 944 >> 2] | 0) == (a3 | 0)) {
                if (!(_b(a3 + 948 | 0, b3) | 0))
                  break;
                BC(b3 + 400 | 0, 8504, 540) | 0;
                c2[b3 + 944 >> 2] = 0;
                nc(a3);
                break;
              }
              h3 = c2[(c2[a3 + 976 >> 2] | 0) + 12 >> 2] | 0;
              i4 = a3 + 948 | 0;
              j4 = (h3 | 0) == 0;
              d4 = 0;
              g3 = 0;
              do {
                e4 = c2[(c2[i4 >> 2] | 0) + (g3 << 2) >> 2] | 0;
                if ((e4 | 0) == (b3 | 0))
                  nc(a3);
                else {
                  f4 = Xb(e4) | 0;
                  c2[(c2[i4 >> 2] | 0) + (d4 << 2) >> 2] = f4;
                  c2[f4 + 944 >> 2] = a3;
                  if (!j4)
                    Ib[h3 & 15](e4, f4, a3, d4);
                  d4 = d4 + 1 | 0;
                }
                g3 = g3 + 1 | 0;
              } while ((g3 | 0) != (k4 | 0));
              if (d4 >>> 0 < k4 >>> 0) {
                j4 = a3 + 948 | 0;
                i4 = a3 + 952 | 0;
                h3 = d4;
                d4 = c2[i4 >> 2] | 0;
                do {
                  g3 = (c2[j4 >> 2] | 0) + (h3 << 2) | 0;
                  e4 = g3 + 4 | 0;
                  f4 = d4 - e4 | 0;
                  b3 = f4 >> 2;
                  if (!b3)
                    f4 = d4;
                  else {
                    GC(g3 | 0, e4 | 0, f4 | 0) | 0;
                    d4 = c2[i4 >> 2] | 0;
                    f4 = d4;
                  }
                  e4 = g3 + (b3 << 2) | 0;
                  if ((f4 | 0) != (e4 | 0)) {
                    d4 = f4 + (~((f4 + -4 - e4 | 0) >>> 2) << 2) | 0;
                    c2[i4 >> 2] = d4;
                  }
                  h3 = h3 + 1 | 0;
                } while ((h3 | 0) != (k4 | 0));
              }
            }
          while (0);
          return;
        }
        function dc(b3) {
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0;
          ec(b3, ($b(b3) | 0) == 0, 2491);
          ec(b3, (c2[b3 + 944 >> 2] | 0) == 0, 2545);
          d4 = b3 + 948 | 0;
          e4 = c2[d4 >> 2] | 0;
          f4 = b3 + 952 | 0;
          g3 = c2[f4 >> 2] | 0;
          if ((g3 | 0) != (e4 | 0))
            c2[f4 >> 2] = g3 + (~((g3 + -4 - e4 | 0) >>> 2) << 2);
          bc(d4);
          d4 = b3 + 976 | 0;
          e4 = c2[d4 >> 2] | 0;
          BC(b3 | 0, 8104, 1e3) | 0;
          if (a2[e4 + 2 >> 0] | 0) {
            c2[b3 + 4 >> 2] = 2;
            c2[b3 + 12 >> 2] = 4;
          }
          c2[d4 >> 2] = e4;
          return;
        }
        function ec(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0;
          f4 = l3;
          l3 = l3 + 16 | 0;
          e4 = f4;
          if (!b3) {
            c2[e4 >> 2] = d4;
            Vd(a3, 5, 3197, e4);
          }
          l3 = f4;
          return;
        }
        function fc() {
          return c2[2276] | 0;
        }
        function gc() {
          var a3 = 0;
          a3 = oB(20) | 0;
          hc((a3 | 0) != 0, 2592);
          c2[2277] = (c2[2277] | 0) + 1;
          c2[a3 >> 2] = c2[239];
          c2[a3 + 4 >> 2] = c2[240];
          c2[a3 + 8 >> 2] = c2[241];
          c2[a3 + 12 >> 2] = c2[242];
          c2[a3 + 16 >> 2] = c2[243];
          return a3 | 0;
        }
        function hc(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          d4 = e4;
          if (!a3) {
            c2[d4 >> 2] = b3;
            Vd(0, 5, 3197, d4);
          }
          l3 = e4;
          return;
        }
        function ic(a3) {
          a3 = a3 | 0;
          pB(a3);
          c2[2277] = (c2[2277] | 0) + -1;
          return;
        }
        function jc(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          if (!b3) {
            d4 = 0;
            b3 = 0;
          } else {
            ec(a3, ($b(a3) | 0) == 0, 2629);
            d4 = 1;
          }
          c2[a3 + 964 >> 2] = b3;
          c2[a3 + 988 >> 2] = d4;
          return;
        }
        function kc(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          g3 = e4 + 8 | 0;
          f4 = e4 + 4 | 0;
          h3 = e4;
          c2[f4 >> 2] = b3;
          ec(a3, (c2[b3 + 944 >> 2] | 0) == 0, 2709);
          ec(a3, (c2[a3 + 964 >> 2] | 0) == 0, 2763);
          lc(a3);
          b3 = a3 + 948 | 0;
          c2[h3 >> 2] = (c2[b3 >> 2] | 0) + (d4 << 2);
          c2[g3 >> 2] = c2[h3 >> 2];
          mc(b3, g3, f4) | 0;
          c2[(c2[f4 >> 2] | 0) + 944 >> 2] = a3;
          nc(a3);
          l3 = e4;
          return;
        }
        function lc(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          d4 = $b(a3) | 0;
          if (d4 | 0 ? (c2[(ac(a3, 0) | 0) + 944 >> 2] | 0) != (a3 | 0) : 0) {
            e4 = c2[(c2[a3 + 976 >> 2] | 0) + 12 >> 2] | 0;
            f4 = a3 + 948 | 0;
            g3 = (e4 | 0) == 0;
            b3 = 0;
            do {
              h3 = c2[(c2[f4 >> 2] | 0) + (b3 << 2) >> 2] | 0;
              i4 = Xb(h3) | 0;
              c2[(c2[f4 >> 2] | 0) + (b3 << 2) >> 2] = i4;
              c2[i4 + 944 >> 2] = a3;
              if (!g3)
                Ib[e4 & 15](h3, i4, a3, b3);
              b3 = b3 + 1 | 0;
            } while ((b3 | 0) != (d4 | 0));
          }
          return;
        }
        function mc(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0, p4 = 0, q3 = 0, r3 = 0, s3 = 0, t3 = 0;
          s3 = l3;
          l3 = l3 + 64 | 0;
          n3 = s3 + 52 | 0;
          i4 = s3 + 48 | 0;
          o3 = s3 + 28 | 0;
          p4 = s3 + 24 | 0;
          q3 = s3 + 20 | 0;
          r3 = s3;
          e4 = c2[a3 >> 2] | 0;
          g3 = e4;
          b3 = e4 + ((c2[b3 >> 2] | 0) - g3 >> 2 << 2) | 0;
          e4 = a3 + 4 | 0;
          f4 = c2[e4 >> 2] | 0;
          h3 = a3 + 8 | 0;
          do
            if (f4 >>> 0 < (c2[h3 >> 2] | 0) >>> 0) {
              if ((b3 | 0) == (f4 | 0)) {
                c2[b3 >> 2] = c2[d4 >> 2];
                c2[e4 >> 2] = (c2[e4 >> 2] | 0) + 4;
                break;
              }
              ef(a3, b3, f4, b3 + 4 | 0);
              if (b3 >>> 0 <= d4 >>> 0)
                d4 = (c2[e4 >> 2] | 0) >>> 0 > d4 >>> 0 ? d4 + 4 | 0 : d4;
              c2[b3 >> 2] = c2[d4 >> 2];
            } else {
              e4 = (f4 - g3 >> 2) + 1 | 0;
              f4 = le(a3) | 0;
              if (f4 >>> 0 < e4 >>> 0)
                jC(a3);
              m4 = c2[a3 >> 2] | 0;
              k4 = (c2[h3 >> 2] | 0) - m4 | 0;
              g3 = k4 >> 1;
              bf(r3, k4 >> 2 >>> 0 < f4 >>> 1 >>> 0 ? g3 >>> 0 < e4 >>> 0 ? e4 : g3 : f4, b3 - m4 >> 2, a3 + 8 | 0);
              m4 = r3 + 8 | 0;
              e4 = c2[m4 >> 2] | 0;
              g3 = r3 + 12 | 0;
              k4 = c2[g3 >> 2] | 0;
              h3 = k4;
              j4 = e4;
              do
                if ((e4 | 0) == (k4 | 0)) {
                  k4 = r3 + 4 | 0;
                  e4 = c2[k4 >> 2] | 0;
                  t3 = c2[r3 >> 2] | 0;
                  f4 = t3;
                  if (e4 >>> 0 <= t3 >>> 0) {
                    e4 = h3 - f4 >> 1;
                    e4 = (e4 | 0) == 0 ? 1 : e4;
                    bf(o3, e4, e4 >>> 2, c2[r3 + 16 >> 2] | 0);
                    c2[p4 >> 2] = c2[k4 >> 2];
                    c2[q3 >> 2] = c2[m4 >> 2];
                    c2[i4 >> 2] = c2[p4 >> 2];
                    c2[n3 >> 2] = c2[q3 >> 2];
                    gf(o3, i4, n3);
                    e4 = c2[r3 >> 2] | 0;
                    c2[r3 >> 2] = c2[o3 >> 2];
                    c2[o3 >> 2] = e4;
                    e4 = o3 + 4 | 0;
                    t3 = c2[k4 >> 2] | 0;
                    c2[k4 >> 2] = c2[e4 >> 2];
                    c2[e4 >> 2] = t3;
                    e4 = o3 + 8 | 0;
                    t3 = c2[m4 >> 2] | 0;
                    c2[m4 >> 2] = c2[e4 >> 2];
                    c2[e4 >> 2] = t3;
                    e4 = o3 + 12 | 0;
                    t3 = c2[g3 >> 2] | 0;
                    c2[g3 >> 2] = c2[e4 >> 2];
                    c2[e4 >> 2] = t3;
                    df(o3);
                    e4 = c2[m4 >> 2] | 0;
                    break;
                  }
                  g3 = e4;
                  h3 = ((g3 - f4 >> 2) + 1 | 0) / -2 | 0;
                  i4 = e4 + (h3 << 2) | 0;
                  f4 = j4 - g3 | 0;
                  g3 = f4 >> 2;
                  if (g3) {
                    GC(i4 | 0, e4 | 0, f4 | 0) | 0;
                    e4 = c2[k4 >> 2] | 0;
                  }
                  t3 = i4 + (g3 << 2) | 0;
                  c2[m4 >> 2] = t3;
                  c2[k4 >> 2] = e4 + (h3 << 2);
                  e4 = t3;
                }
              while (0);
              c2[e4 >> 2] = c2[d4 >> 2];
              c2[m4 >> 2] = (c2[m4 >> 2] | 0) + 4;
              b3 = ff(a3, r3, b3) | 0;
              df(r3);
            }
          while (0);
          l3 = s3;
          return b3 | 0;
        }
        function nc(b3) {
          b3 = b3 | 0;
          var d4 = 0;
          do {
            d4 = b3 + 984 | 0;
            if (a2[d4 >> 0] | 0)
              break;
            a2[d4 >> 0] = 1;
            g2[b3 + 504 >> 2] = T2(t2);
            b3 = c2[b3 + 944 >> 2] | 0;
          } while ((b3 | 0) != 0);
          return;
        }
        function oc(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~((b3 + -4 - e4 | 0) >>> 2) << 2);
            sC(d4);
          }
          return;
        }
        function pc(a3) {
          a3 = a3 | 0;
          return c2[a3 + 944 >> 2] | 0;
        }
        function qc(a3) {
          a3 = a3 | 0;
          ec(a3, (c2[a3 + 964 >> 2] | 0) != 0, 2832);
          nc(a3);
          return;
        }
        function rc(b3) {
          b3 = b3 | 0;
          return (a2[b3 + 984 >> 0] | 0) != 0 | 0;
        }
        function sc(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          if (BB(a3, b3, 400) | 0) {
            BC(a3 | 0, b3 | 0, 400) | 0;
            nc(a3);
          }
          return;
        }
        function tc(a3) {
          a3 = a3 | 0;
          var b3 = ib;
          b3 = T2(g2[a3 + 44 >> 2]);
          a3 = Sb(b3) | 0;
          return T2(a3 ? T2(0) : b3);
        }
        function uc(b3) {
          b3 = b3 | 0;
          var d4 = ib;
          d4 = T2(g2[b3 + 48 >> 2]);
          if (Sb(d4) | 0)
            d4 = a2[(c2[b3 + 976 >> 2] | 0) + 2 >> 0] | 0 ? T2(1) : T2(0);
          return T2(d4);
        }
        function vc(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c2[a3 + 980 >> 2] = b3;
          return;
        }
        function wc(a3) {
          a3 = a3 | 0;
          return c2[a3 + 980 >> 2] | 0;
        }
        function xc(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = a3 + 4 | 0;
          if ((c2[d4 >> 2] | 0) != (b3 | 0)) {
            c2[d4 >> 2] = b3;
            nc(a3);
          }
          return;
        }
        function yc(a3) {
          a3 = a3 | 0;
          return c2[a3 + 4 >> 2] | 0;
        }
        function zc(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = a3 + 8 | 0;
          if ((c2[d4 >> 2] | 0) != (b3 | 0)) {
            c2[d4 >> 2] = b3;
            nc(a3);
          }
          return;
        }
        function Ac(a3) {
          a3 = a3 | 0;
          return c2[a3 + 8 >> 2] | 0;
        }
        function Bc(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = a3 + 12 | 0;
          if ((c2[d4 >> 2] | 0) != (b3 | 0)) {
            c2[d4 >> 2] = b3;
            nc(a3);
          }
          return;
        }
        function Cc(a3) {
          a3 = a3 | 0;
          return c2[a3 + 12 >> 2] | 0;
        }
        function Dc(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = a3 + 16 | 0;
          if ((c2[d4 >> 2] | 0) != (b3 | 0)) {
            c2[d4 >> 2] = b3;
            nc(a3);
          }
          return;
        }
        function Ec(a3) {
          a3 = a3 | 0;
          return c2[a3 + 16 >> 2] | 0;
        }
        function Fc(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = a3 + 20 | 0;
          if ((c2[d4 >> 2] | 0) != (b3 | 0)) {
            c2[d4 >> 2] = b3;
            nc(a3);
          }
          return;
        }
        function Gc(a3) {
          a3 = a3 | 0;
          return c2[a3 + 20 >> 2] | 0;
        }
        function Hc(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = a3 + 24 | 0;
          if ((c2[d4 >> 2] | 0) != (b3 | 0)) {
            c2[d4 >> 2] = b3;
            nc(a3);
          }
          return;
        }
        function Ic(a3) {
          a3 = a3 | 0;
          return c2[a3 + 24 >> 2] | 0;
        }
        function Jc(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = a3 + 28 | 0;
          if ((c2[d4 >> 2] | 0) != (b3 | 0)) {
            c2[d4 >> 2] = b3;
            nc(a3);
          }
          return;
        }
        function Kc(a3) {
          a3 = a3 | 0;
          return c2[a3 + 28 >> 2] | 0;
        }
        function Lc(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = a3 + 32 | 0;
          if ((c2[d4 >> 2] | 0) != (b3 | 0)) {
            c2[d4 >> 2] = b3;
            nc(a3);
          }
          return;
        }
        function Mc(a3) {
          a3 = a3 | 0;
          return c2[a3 + 32 >> 2] | 0;
        }
        function Nc(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = a3 + 36 | 0;
          if ((c2[d4 >> 2] | 0) != (b3 | 0)) {
            c2[d4 >> 2] = b3;
            nc(a3);
          }
          return;
        }
        function Oc(a3) {
          a3 = a3 | 0;
          return c2[a3 + 36 >> 2] | 0;
        }
        function Pc(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          var c3 = 0;
          c3 = a3 + 40 | 0;
          if (T2(g2[c3 >> 2]) != b3) {
            g2[c3 >> 2] = b3;
            nc(a3);
          }
          return;
        }
        function Qc(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          var c3 = 0;
          c3 = a3 + 44 | 0;
          if (T2(g2[c3 >> 2]) != b3) {
            g2[c3 >> 2] = b3;
            nc(a3);
          }
          return;
        }
        function Rc(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          var c3 = 0;
          c3 = a3 + 48 | 0;
          if (T2(g2[c3 >> 2]) != b3) {
            g2[c3 >> 2] = b3;
            nc(a3);
          }
          return;
        }
        function Sc(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          var d4 = 0, e4 = 0, f4 = 0, h3 = 0;
          h3 = Sb(b3) | 0;
          d4 = (h3 ^ 1) & 1;
          e4 = a3 + 52 | 0;
          f4 = a3 + 56 | 0;
          if (!(h3 | T2(g2[e4 >> 2]) == b3 ? (c2[f4 >> 2] | 0) == (d4 | 0) : 0)) {
            g2[e4 >> 2] = b3;
            c2[f4 >> 2] = d4;
            nc(a3);
          }
          return;
        }
        function Tc(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          var d4 = 0, e4 = 0;
          e4 = a3 + 52 | 0;
          d4 = a3 + 56 | 0;
          if (!(!(T2(g2[e4 >> 2]) != b3) ? (c2[d4 >> 2] | 0) == 2 : 0)) {
            g2[e4 >> 2] = b3;
            e4 = Sb(b3) | 0;
            c2[d4 >> 2] = e4 ? 3 : 2;
            nc(a3);
          }
          return;
        }
        function Uc(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          e4 = b3 + 52 | 0;
          d4 = c2[e4 + 4 >> 2] | 0;
          b3 = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          c2[b3 + 4 >> 2] = d4;
          return;
        }
        function Vc(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = T2(d4);
          var e4 = 0, f4 = 0, h3 = 0;
          h3 = Sb(d4) | 0;
          e4 = (h3 ^ 1) & 1;
          f4 = a3 + 132 + (b3 << 3) | 0;
          b3 = a3 + 132 + (b3 << 3) + 4 | 0;
          if (!(h3 | T2(g2[f4 >> 2]) == d4 ? (c2[b3 >> 2] | 0) == (e4 | 0) : 0)) {
            g2[f4 >> 2] = d4;
            c2[b3 >> 2] = e4;
            nc(a3);
          }
          return;
        }
        function Wc(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = T2(d4);
          var e4 = 0, f4 = 0, h3 = 0;
          h3 = Sb(d4) | 0;
          e4 = h3 ? 0 : 2;
          f4 = a3 + 132 + (b3 << 3) | 0;
          b3 = a3 + 132 + (b3 << 3) + 4 | 0;
          if (!(h3 | T2(g2[f4 >> 2]) == d4 ? (c2[b3 >> 2] | 0) == (e4 | 0) : 0)) {
            g2[f4 >> 2] = d4;
            c2[b3 >> 2] = e4;
            nc(a3);
          }
          return;
        }
        function Xc(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = b3 + 132 + (d4 << 3) | 0;
          b3 = c2[e4 + 4 >> 2] | 0;
          d4 = a3;
          c2[d4 >> 2] = c2[e4 >> 2];
          c2[d4 + 4 >> 2] = b3;
          return;
        }
        function Yc(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = T2(d4);
          var e4 = 0, f4 = 0, h3 = 0;
          h3 = Sb(d4) | 0;
          e4 = (h3 ^ 1) & 1;
          f4 = a3 + 60 + (b3 << 3) | 0;
          b3 = a3 + 60 + (b3 << 3) + 4 | 0;
          if (!(h3 | T2(g2[f4 >> 2]) == d4 ? (c2[b3 >> 2] | 0) == (e4 | 0) : 0)) {
            g2[f4 >> 2] = d4;
            c2[b3 >> 2] = e4;
            nc(a3);
          }
          return;
        }
        function Zc(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = T2(d4);
          var e4 = 0, f4 = 0, h3 = 0;
          h3 = Sb(d4) | 0;
          e4 = h3 ? 0 : 2;
          f4 = a3 + 60 + (b3 << 3) | 0;
          b3 = a3 + 60 + (b3 << 3) + 4 | 0;
          if (!(h3 | T2(g2[f4 >> 2]) == d4 ? (c2[b3 >> 2] | 0) == (e4 | 0) : 0)) {
            g2[f4 >> 2] = d4;
            c2[b3 >> 2] = e4;
            nc(a3);
          }
          return;
        }
        function _c(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = b3 + 60 + (d4 << 3) | 0;
          b3 = c2[e4 + 4 >> 2] | 0;
          d4 = a3;
          c2[d4 >> 2] = c2[e4 >> 2];
          c2[d4 + 4 >> 2] = b3;
          return;
        }
        function $c(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = a3 + 60 + (b3 << 3) + 4 | 0;
          if ((c2[d4 >> 2] | 0) != 3) {
            g2[a3 + 60 + (b3 << 3) >> 2] = T2(t2);
            c2[d4 >> 2] = 3;
            nc(a3);
          }
          return;
        }
        function ad(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = T2(d4);
          var e4 = 0, f4 = 0, h3 = 0;
          h3 = Sb(d4) | 0;
          e4 = (h3 ^ 1) & 1;
          f4 = a3 + 204 + (b3 << 3) | 0;
          b3 = a3 + 204 + (b3 << 3) + 4 | 0;
          if (!(h3 | T2(g2[f4 >> 2]) == d4 ? (c2[b3 >> 2] | 0) == (e4 | 0) : 0)) {
            g2[f4 >> 2] = d4;
            c2[b3 >> 2] = e4;
            nc(a3);
          }
          return;
        }
        function bd(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = T2(d4);
          var e4 = 0, f4 = 0, h3 = 0;
          h3 = Sb(d4) | 0;
          e4 = h3 ? 0 : 2;
          f4 = a3 + 204 + (b3 << 3) | 0;
          b3 = a3 + 204 + (b3 << 3) + 4 | 0;
          if (!(h3 | T2(g2[f4 >> 2]) == d4 ? (c2[b3 >> 2] | 0) == (e4 | 0) : 0)) {
            g2[f4 >> 2] = d4;
            c2[b3 >> 2] = e4;
            nc(a3);
          }
          return;
        }
        function cd(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = b3 + 204 + (d4 << 3) | 0;
          b3 = c2[e4 + 4 >> 2] | 0;
          d4 = a3;
          c2[d4 >> 2] = c2[e4 >> 2];
          c2[d4 + 4 >> 2] = b3;
          return;
        }
        function dd(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = T2(d4);
          var e4 = 0, f4 = 0, h3 = 0;
          h3 = Sb(d4) | 0;
          e4 = (h3 ^ 1) & 1;
          f4 = a3 + 276 + (b3 << 3) | 0;
          b3 = a3 + 276 + (b3 << 3) + 4 | 0;
          if (!(h3 | T2(g2[f4 >> 2]) == d4 ? (c2[b3 >> 2] | 0) == (e4 | 0) : 0)) {
            g2[f4 >> 2] = d4;
            c2[b3 >> 2] = e4;
            nc(a3);
          }
          return;
        }
        function ed(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return T2(g2[a3 + 276 + (b3 << 3) >> 2]);
        }
        function fd(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          var d4 = 0, e4 = 0, f4 = 0, h3 = 0;
          h3 = Sb(b3) | 0;
          d4 = (h3 ^ 1) & 1;
          e4 = a3 + 348 | 0;
          f4 = a3 + 352 | 0;
          if (!(h3 | T2(g2[e4 >> 2]) == b3 ? (c2[f4 >> 2] | 0) == (d4 | 0) : 0)) {
            g2[e4 >> 2] = b3;
            c2[f4 >> 2] = d4;
            nc(a3);
          }
          return;
        }
        function gd(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          var d4 = 0, e4 = 0;
          e4 = a3 + 348 | 0;
          d4 = a3 + 352 | 0;
          if (!(!(T2(g2[e4 >> 2]) != b3) ? (c2[d4 >> 2] | 0) == 2 : 0)) {
            g2[e4 >> 2] = b3;
            e4 = Sb(b3) | 0;
            c2[d4 >> 2] = e4 ? 3 : 2;
            nc(a3);
          }
          return;
        }
        function hd(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = a3 + 352 | 0;
          if ((c2[b3 >> 2] | 0) != 3) {
            g2[a3 + 348 >> 2] = T2(t2);
            c2[b3 >> 2] = 3;
            nc(a3);
          }
          return;
        }
        function id(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          e4 = b3 + 348 | 0;
          d4 = c2[e4 + 4 >> 2] | 0;
          b3 = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          c2[b3 + 4 >> 2] = d4;
          return;
        }
        function jd(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          var d4 = 0, e4 = 0, f4 = 0, h3 = 0;
          h3 = Sb(b3) | 0;
          d4 = (h3 ^ 1) & 1;
          e4 = a3 + 356 | 0;
          f4 = a3 + 360 | 0;
          if (!(h3 | T2(g2[e4 >> 2]) == b3 ? (c2[f4 >> 2] | 0) == (d4 | 0) : 0)) {
            g2[e4 >> 2] = b3;
            c2[f4 >> 2] = d4;
            nc(a3);
          }
          return;
        }
        function kd(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          var d4 = 0, e4 = 0;
          e4 = a3 + 356 | 0;
          d4 = a3 + 360 | 0;
          if (!(!(T2(g2[e4 >> 2]) != b3) ? (c2[d4 >> 2] | 0) == 2 : 0)) {
            g2[e4 >> 2] = b3;
            e4 = Sb(b3) | 0;
            c2[d4 >> 2] = e4 ? 3 : 2;
            nc(a3);
          }
          return;
        }
        function ld(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = a3 + 360 | 0;
          if ((c2[b3 >> 2] | 0) != 3) {
            g2[a3 + 356 >> 2] = T2(t2);
            c2[b3 >> 2] = 3;
            nc(a3);
          }
          return;
        }
        function md(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          e4 = b3 + 356 | 0;
          d4 = c2[e4 + 4 >> 2] | 0;
          b3 = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          c2[b3 + 4 >> 2] = d4;
          return;
        }
        function nd(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          var d4 = 0, e4 = 0, f4 = 0, h3 = 0;
          h3 = Sb(b3) | 0;
          d4 = (h3 ^ 1) & 1;
          e4 = a3 + 364 | 0;
          f4 = a3 + 368 | 0;
          if (!(h3 | T2(g2[e4 >> 2]) == b3 ? (c2[f4 >> 2] | 0) == (d4 | 0) : 0)) {
            g2[e4 >> 2] = b3;
            c2[f4 >> 2] = d4;
            nc(a3);
          }
          return;
        }
        function od(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          var d4 = 0, e4 = 0, f4 = 0, h3 = 0;
          h3 = Sb(b3) | 0;
          d4 = h3 ? 0 : 2;
          e4 = a3 + 364 | 0;
          f4 = a3 + 368 | 0;
          if (!(h3 | T2(g2[e4 >> 2]) == b3 ? (c2[f4 >> 2] | 0) == (d4 | 0) : 0)) {
            g2[e4 >> 2] = b3;
            c2[f4 >> 2] = d4;
            nc(a3);
          }
          return;
        }
        function pd(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          e4 = b3 + 364 | 0;
          d4 = c2[e4 + 4 >> 2] | 0;
          b3 = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          c2[b3 + 4 >> 2] = d4;
          return;
        }
        function qd(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          var d4 = 0, e4 = 0, f4 = 0, h3 = 0;
          h3 = Sb(b3) | 0;
          d4 = (h3 ^ 1) & 1;
          e4 = a3 + 372 | 0;
          f4 = a3 + 376 | 0;
          if (!(h3 | T2(g2[e4 >> 2]) == b3 ? (c2[f4 >> 2] | 0) == (d4 | 0) : 0)) {
            g2[e4 >> 2] = b3;
            c2[f4 >> 2] = d4;
            nc(a3);
          }
          return;
        }
        function rd(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          var d4 = 0, e4 = 0, f4 = 0, h3 = 0;
          h3 = Sb(b3) | 0;
          d4 = h3 ? 0 : 2;
          e4 = a3 + 372 | 0;
          f4 = a3 + 376 | 0;
          if (!(h3 | T2(g2[e4 >> 2]) == b3 ? (c2[f4 >> 2] | 0) == (d4 | 0) : 0)) {
            g2[e4 >> 2] = b3;
            c2[f4 >> 2] = d4;
            nc(a3);
          }
          return;
        }
        function sd(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          e4 = b3 + 372 | 0;
          d4 = c2[e4 + 4 >> 2] | 0;
          b3 = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          c2[b3 + 4 >> 2] = d4;
          return;
        }
        function td(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          var d4 = 0, e4 = 0, f4 = 0, h3 = 0;
          h3 = Sb(b3) | 0;
          d4 = (h3 ^ 1) & 1;
          e4 = a3 + 380 | 0;
          f4 = a3 + 384 | 0;
          if (!(h3 | T2(g2[e4 >> 2]) == b3 ? (c2[f4 >> 2] | 0) == (d4 | 0) : 0)) {
            g2[e4 >> 2] = b3;
            c2[f4 >> 2] = d4;
            nc(a3);
          }
          return;
        }
        function ud(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          var d4 = 0, e4 = 0, f4 = 0, h3 = 0;
          h3 = Sb(b3) | 0;
          d4 = h3 ? 0 : 2;
          e4 = a3 + 380 | 0;
          f4 = a3 + 384 | 0;
          if (!(h3 | T2(g2[e4 >> 2]) == b3 ? (c2[f4 >> 2] | 0) == (d4 | 0) : 0)) {
            g2[e4 >> 2] = b3;
            c2[f4 >> 2] = d4;
            nc(a3);
          }
          return;
        }
        function vd(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          e4 = b3 + 380 | 0;
          d4 = c2[e4 + 4 >> 2] | 0;
          b3 = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          c2[b3 + 4 >> 2] = d4;
          return;
        }
        function wd(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          var d4 = 0, e4 = 0, f4 = 0, h3 = 0;
          h3 = Sb(b3) | 0;
          d4 = (h3 ^ 1) & 1;
          e4 = a3 + 388 | 0;
          f4 = a3 + 392 | 0;
          if (!(h3 | T2(g2[e4 >> 2]) == b3 ? (c2[f4 >> 2] | 0) == (d4 | 0) : 0)) {
            g2[e4 >> 2] = b3;
            c2[f4 >> 2] = d4;
            nc(a3);
          }
          return;
        }
        function xd(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          var d4 = 0, e4 = 0, f4 = 0, h3 = 0;
          h3 = Sb(b3) | 0;
          d4 = h3 ? 0 : 2;
          e4 = a3 + 388 | 0;
          f4 = a3 + 392 | 0;
          if (!(h3 | T2(g2[e4 >> 2]) == b3 ? (c2[f4 >> 2] | 0) == (d4 | 0) : 0)) {
            g2[e4 >> 2] = b3;
            c2[f4 >> 2] = d4;
            nc(a3);
          }
          return;
        }
        function yd(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          e4 = b3 + 388 | 0;
          d4 = c2[e4 + 4 >> 2] | 0;
          b3 = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          c2[b3 + 4 >> 2] = d4;
          return;
        }
        function zd(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          var c3 = 0;
          c3 = a3 + 396 | 0;
          if (T2(g2[c3 >> 2]) != b3) {
            g2[c3 >> 2] = b3;
            nc(a3);
          }
          return;
        }
        function Ad(a3) {
          a3 = a3 | 0;
          return T2(g2[a3 + 396 >> 2]);
        }
        function Bd(a3) {
          a3 = a3 | 0;
          return T2(g2[a3 + 400 >> 2]);
        }
        function Cd(a3) {
          a3 = a3 | 0;
          return T2(g2[a3 + 404 >> 2]);
        }
        function Dd(a3) {
          a3 = a3 | 0;
          return T2(g2[a3 + 408 >> 2]);
        }
        function Ed(a3) {
          a3 = a3 | 0;
          return T2(g2[a3 + 412 >> 2]);
        }
        function Fd(a3) {
          a3 = a3 | 0;
          return T2(g2[a3 + 416 >> 2]);
        }
        function Gd(a3) {
          a3 = a3 | 0;
          return T2(g2[a3 + 420 >> 2]);
        }
        function Hd(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          ec(a3, (b3 | 0) < 6, 2918);
          switch (b3 | 0) {
            case 0: {
              b3 = (c2[a3 + 496 >> 2] | 0) == 2 ? 5 : 4;
              break;
            }
            case 2: {
              b3 = (c2[a3 + 496 >> 2] | 0) == 2 ? 4 : 5;
              break;
            }
            default: {
            }
          }
          return T2(g2[a3 + 424 + (b3 << 2) >> 2]);
        }
        function Id(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          ec(a3, (b3 | 0) < 6, 2918);
          switch (b3 | 0) {
            case 0: {
              b3 = (c2[a3 + 496 >> 2] | 0) == 2 ? 5 : 4;
              break;
            }
            case 2: {
              b3 = (c2[a3 + 496 >> 2] | 0) == 2 ? 4 : 5;
              break;
            }
            default: {
            }
          }
          return T2(g2[a3 + 448 + (b3 << 2) >> 2]);
        }
        function Jd(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          ec(a3, (b3 | 0) < 6, 2918);
          switch (b3 | 0) {
            case 0: {
              b3 = (c2[a3 + 496 >> 2] | 0) == 2 ? 5 : 4;
              break;
            }
            case 2: {
              b3 = (c2[a3 + 496 >> 2] | 0) == 2 ? 4 : 5;
              break;
            }
            default: {
            }
          }
          return T2(g2[a3 + 472 + (b3 << 2) >> 2]);
        }
        function Kd(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = ib;
          d4 = c2[a3 + 4 >> 2] | 0;
          if ((d4 | 0) == (c2[b3 + 4 >> 2] | 0)) {
            if (!d4)
              a3 = 1;
            else {
              e4 = T2(g2[a3 >> 2]);
              a3 = T2(C2(T2(e4 - T2(g2[b3 >> 2])))) < T2(999999974e-13);
            }
          } else
            a3 = 0;
          return a3 | 0;
        }
        function Ld(a3, b3) {
          a3 = T2(a3);
          b3 = T2(b3);
          var c3 = 0;
          if (Sb(a3) | 0)
            c3 = Sb(b3) | 0;
          else
            c3 = T2(C2(T2(a3 - b3))) < T2(999999974e-13);
          return c3 | 0;
        }
        function Md(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          Nd(a3, b3);
          return;
        }
        function Nd(b3, d4) {
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 4 | 0;
          c2[f4 >> 2] = 0;
          c2[f4 + 4 >> 2] = 0;
          c2[f4 + 8 >> 2] = 0;
          Ka(f4 | 0, b3 | 0, d4 | 0, 0);
          Vd(b3, 3, (a2[f4 + 11 >> 0] | 0) < 0 ? c2[f4 >> 2] | 0 : f4, e4);
          tC(f4);
          l3 = e4;
          return;
        }
        function Od(a3, b3, c3, d4) {
          a3 = T2(a3);
          b3 = T2(b3);
          c3 = c3 | 0;
          d4 = d4 | 0;
          var e4 = ib;
          a3 = T2(a3 * b3);
          e4 = T2(gC(a3, T2(1)));
          do
            if (!(Ld(e4, T2(0)) | 0)) {
              a3 = T2(a3 - e4);
              if (Ld(e4, T2(1)) | 0) {
                a3 = T2(a3 + T2(1));
                break;
              }
              if (c3) {
                a3 = T2(a3 + T2(1));
                break;
              }
              if (!d4) {
                if (e4 > T2(0.5))
                  e4 = T2(1);
                else {
                  d4 = Ld(e4, T2(0.5)) | 0;
                  e4 = d4 ? T2(1) : T2(0);
                }
                a3 = T2(a3 + e4);
              }
            } else
              a3 = T2(a3 - e4);
          while (0);
          return T2(a3 / b3);
        }
        function Pd(a3, b3, c3, d4, e4, f4, h3, i4, j4, k4, l4, m4, n3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          c3 = c3 | 0;
          d4 = T2(d4);
          e4 = e4 | 0;
          f4 = T2(f4);
          h3 = h3 | 0;
          i4 = T2(i4);
          j4 = T2(j4);
          k4 = T2(k4);
          l4 = T2(l4);
          m4 = T2(m4);
          n3 = n3 | 0;
          var o3 = 0, p4 = ib, q3 = ib, r3 = ib, s3 = ib, t3 = ib, u4 = ib;
          if (j4 < T2(0) | k4 < T2(0))
            n3 = 0;
          else {
            if ((n3 | 0) != 0 ? (p4 = T2(g2[n3 + 4 >> 2]), p4 != T2(0)) : 0) {
              r3 = T2(Od(b3, p4, 0, 0));
              s3 = T2(Od(d4, p4, 0, 0));
              q3 = T2(Od(f4, p4, 0, 0));
              p4 = T2(Od(i4, p4, 0, 0));
            } else {
              q3 = f4;
              r3 = b3;
              p4 = i4;
              s3 = d4;
            }
            if ((e4 | 0) == (a3 | 0))
              o3 = Ld(q3, r3) | 0;
            else
              o3 = 0;
            if ((h3 | 0) == (c3 | 0))
              n3 = Ld(p4, s3) | 0;
            else
              n3 = 0;
            if ((!o3 ? (t3 = T2(b3 - l4), !(Qd(a3, t3, j4) | 0)) : 0) ? !(Rd(a3, t3, e4, j4) | 0) : 0)
              o3 = Sd(a3, t3, e4, f4, j4) | 0;
            else
              o3 = 1;
            if ((!n3 ? (u4 = T2(d4 - m4), !(Qd(c3, u4, k4) | 0)) : 0) ? !(Rd(c3, u4, h3, k4) | 0) : 0)
              n3 = Sd(c3, u4, h3, i4, k4) | 0;
            else
              n3 = 1;
            n3 = o3 & n3;
          }
          return n3 | 0;
        }
        function Qd(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          c3 = T2(c3);
          if ((a3 | 0) == 1)
            a3 = Ld(b3, c3) | 0;
          else
            a3 = 0;
          return a3 | 0;
        }
        function Rd(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = T2(b3);
          c3 = c3 | 0;
          d4 = T2(d4);
          if ((a3 | 0) == 2 & (c3 | 0) == 0) {
            if (!(b3 >= d4))
              a3 = Ld(b3, d4) | 0;
            else
              a3 = 1;
          } else
            a3 = 0;
          return a3 | 0;
        }
        function Sd(a3, b3, c3, d4, e4) {
          a3 = a3 | 0;
          b3 = T2(b3);
          c3 = c3 | 0;
          d4 = T2(d4);
          e4 = T2(e4);
          if ((a3 | 0) == 2 & (c3 | 0) == 2 & d4 > b3) {
            if (!(e4 <= b3))
              a3 = Ld(b3, e4) | 0;
            else
              a3 = 1;
          } else
            a3 = 0;
          return a3 | 0;
        }
        function Td(b3, d4, e4, f4, i4, j4, k4, m4, n3, o3, p4) {
          b3 = b3 | 0;
          d4 = T2(d4);
          e4 = T2(e4);
          f4 = f4 | 0;
          i4 = i4 | 0;
          j4 = j4 | 0;
          k4 = T2(k4);
          m4 = T2(m4);
          n3 = n3 | 0;
          o3 = o3 | 0;
          p4 = p4 | 0;
          var q3 = 0, r3 = 0, s3 = 0, t3 = 0, u4 = ib, v4 = ib, w3 = 0, x4 = 0, y3 = 0, z3 = 0, A3 = 0, B3 = 0, C3 = 0, D3 = 0, E3 = 0, F3 = 0, G3 = 0, H3 = ib, I3 = ib, J3 = ib, K3 = 0, L3 = 0;
          G3 = l3;
          l3 = l3 + 160 | 0;
          D3 = G3 + 152 | 0;
          C3 = G3 + 120 | 0;
          B3 = G3 + 104 | 0;
          y3 = G3 + 72 | 0;
          t3 = G3 + 56 | 0;
          A3 = G3 + 8 | 0;
          x4 = G3;
          z3 = (c2[2279] | 0) + 1 | 0;
          c2[2279] = z3;
          E3 = b3 + 984 | 0;
          if ((a2[E3 >> 0] | 0) != 0 ? (c2[b3 + 512 >> 2] | 0) != (c2[2278] | 0) : 0)
            w3 = 4;
          else if ((c2[b3 + 516 >> 2] | 0) == (f4 | 0))
            F3 = 0;
          else
            w3 = 4;
          if ((w3 | 0) == 4) {
            c2[b3 + 520 >> 2] = 0;
            c2[b3 + 924 >> 2] = -1;
            c2[b3 + 928 >> 2] = -1;
            g2[b3 + 932 >> 2] = T2(-1);
            g2[b3 + 936 >> 2] = T2(-1);
            F3 = 1;
          }
          a:
            do
              if (!(c2[b3 + 964 >> 2] | 0)) {
                if (n3) {
                  q3 = b3 + 916 | 0;
                  if (!(Ld(T2(g2[q3 >> 2]), d4) | 0)) {
                    w3 = 21;
                    break;
                  }
                  if (!(Ld(T2(g2[b3 + 920 >> 2]), e4) | 0)) {
                    w3 = 21;
                    break;
                  }
                  if ((c2[b3 + 924 >> 2] | 0) != (i4 | 0)) {
                    w3 = 21;
                    break;
                  }
                  q3 = (c2[b3 + 928 >> 2] | 0) == (j4 | 0) ? q3 : 0;
                  w3 = 22;
                  break;
                }
                s3 = c2[b3 + 520 >> 2] | 0;
                if (!s3)
                  w3 = 21;
                else {
                  r3 = 0;
                  while (1) {
                    q3 = b3 + 524 + (r3 * 24 | 0) | 0;
                    if (((Ld(T2(g2[q3 >> 2]), d4) | 0 ? Ld(T2(g2[b3 + 524 + (r3 * 24 | 0) + 4 >> 2]), e4) | 0 : 0) ? (c2[b3 + 524 + (r3 * 24 | 0) + 8 >> 2] | 0) == (i4 | 0) : 0) ? (c2[b3 + 524 + (r3 * 24 | 0) + 12 >> 2] | 0) == (j4 | 0) : 0) {
                      w3 = 22;
                      break a;
                    }
                    r3 = r3 + 1 | 0;
                    if (r3 >>> 0 >= s3 >>> 0) {
                      w3 = 21;
                      break;
                    }
                  }
                }
              } else {
                u4 = T2(Ud(b3, 2, k4));
                v4 = T2(Ud(b3, 0, k4));
                q3 = b3 + 916 | 0;
                J3 = T2(g2[q3 >> 2]);
                I3 = T2(g2[b3 + 920 >> 2]);
                H3 = T2(g2[b3 + 932 >> 2]);
                if (!(Pd(i4, d4, j4, e4, c2[b3 + 924 >> 2] | 0, J3, c2[b3 + 928 >> 2] | 0, I3, H3, T2(g2[b3 + 936 >> 2]), u4, v4, p4) | 0)) {
                  s3 = c2[b3 + 520 >> 2] | 0;
                  if (!s3)
                    w3 = 21;
                  else {
                    r3 = 0;
                    while (1) {
                      q3 = b3 + 524 + (r3 * 24 | 0) | 0;
                      H3 = T2(g2[q3 >> 2]);
                      I3 = T2(g2[b3 + 524 + (r3 * 24 | 0) + 4 >> 2]);
                      J3 = T2(g2[b3 + 524 + (r3 * 24 | 0) + 16 >> 2]);
                      if (Pd(i4, d4, j4, e4, c2[b3 + 524 + (r3 * 24 | 0) + 8 >> 2] | 0, H3, c2[b3 + 524 + (r3 * 24 | 0) + 12 >> 2] | 0, I3, J3, T2(g2[b3 + 524 + (r3 * 24 | 0) + 20 >> 2]), u4, v4, p4) | 0) {
                        w3 = 22;
                        break a;
                      }
                      r3 = r3 + 1 | 0;
                      if (r3 >>> 0 >= s3 >>> 0) {
                        w3 = 21;
                        break;
                      }
                    }
                  }
                } else
                  w3 = 22;
              }
            while (0);
          do
            if ((w3 | 0) == 21) {
              if (!(a2[11697] | 0)) {
                q3 = 0;
                w3 = 31;
              } else {
                q3 = 0;
                w3 = 28;
              }
            } else if ((w3 | 0) == 22) {
              r3 = (a2[11697] | 0) != 0;
              if (!((q3 | 0) != 0 & (F3 ^ 1)))
                if (r3) {
                  w3 = 28;
                  break;
                } else {
                  w3 = 31;
                  break;
                }
              t3 = q3 + 16 | 0;
              c2[b3 + 908 >> 2] = c2[t3 >> 2];
              s3 = q3 + 20 | 0;
              c2[b3 + 912 >> 2] = c2[s3 >> 2];
              if (!((a2[11698] | 0) == 0 | r3 ^ 1)) {
                c2[x4 >> 2] = Wd(z3) | 0;
                c2[x4 + 4 >> 2] = z3;
                Vd(b3, 4, 2972, x4);
                r3 = c2[b3 + 972 >> 2] | 0;
                if (r3 | 0)
                  nb[r3 & 127](b3);
                i4 = Xd(i4, n3) | 0;
                j4 = Xd(j4, n3) | 0;
                L3 = +T2(g2[t3 >> 2]);
                K3 = +T2(g2[s3 >> 2]);
                c2[A3 >> 2] = i4;
                c2[A3 + 4 >> 2] = j4;
                h2[A3 + 8 >> 3] = +d4;
                h2[A3 + 16 >> 3] = +e4;
                h2[A3 + 24 >> 3] = L3;
                h2[A3 + 32 >> 3] = K3;
                c2[A3 + 40 >> 2] = o3;
                Vd(b3, 4, 2989, A3);
              }
            }
          while (0);
          if ((w3 | 0) == 28) {
            r3 = Wd(z3) | 0;
            c2[t3 >> 2] = r3;
            c2[t3 + 4 >> 2] = z3;
            c2[t3 + 8 >> 2] = F3 ? 3047 : 11699;
            Vd(b3, 4, 3038, t3);
            r3 = c2[b3 + 972 >> 2] | 0;
            if (r3 | 0)
              nb[r3 & 127](b3);
            A3 = Xd(i4, n3) | 0;
            w3 = Xd(j4, n3) | 0;
            c2[y3 >> 2] = A3;
            c2[y3 + 4 >> 2] = w3;
            h2[y3 + 8 >> 3] = +d4;
            h2[y3 + 16 >> 3] = +e4;
            c2[y3 + 24 >> 2] = o3;
            Vd(b3, 4, 3049, y3);
            w3 = 31;
          }
          if ((w3 | 0) == 31) {
            Yd(b3, d4, e4, f4, i4, j4, k4, m4, n3, p4);
            if (a2[11697] | 0) {
              r3 = c2[2279] | 0;
              A3 = Wd(r3) | 0;
              c2[B3 >> 2] = A3;
              c2[B3 + 4 >> 2] = r3;
              c2[B3 + 8 >> 2] = F3 ? 3047 : 11699;
              Vd(b3, 4, 3083, B3);
              r3 = c2[b3 + 972 >> 2] | 0;
              if (r3 | 0)
                nb[r3 & 127](b3);
              A3 = Xd(i4, n3) | 0;
              B3 = Xd(j4, n3) | 0;
              K3 = +T2(g2[b3 + 908 >> 2]);
              L3 = +T2(g2[b3 + 912 >> 2]);
              c2[C3 >> 2] = A3;
              c2[C3 + 4 >> 2] = B3;
              h2[C3 + 8 >> 3] = K3;
              h2[C3 + 16 >> 3] = L3;
              c2[C3 + 24 >> 2] = o3;
              Vd(b3, 4, 3092, C3);
            }
            c2[b3 + 516 >> 2] = f4;
            if (!q3) {
              r3 = b3 + 520 | 0;
              q3 = c2[r3 >> 2] | 0;
              if ((q3 | 0) == 16) {
                if (a2[11697] | 0)
                  Vd(b3, 4, 3124, D3);
                c2[r3 >> 2] = 0;
                q3 = 0;
              }
              if (n3)
                q3 = b3 + 916 | 0;
              else {
                c2[r3 >> 2] = q3 + 1;
                q3 = b3 + 524 + (q3 * 24 | 0) | 0;
              }
              g2[q3 >> 2] = d4;
              g2[q3 + 4 >> 2] = e4;
              c2[q3 + 8 >> 2] = i4;
              c2[q3 + 12 >> 2] = j4;
              c2[q3 + 16 >> 2] = c2[b3 + 908 >> 2];
              c2[q3 + 20 >> 2] = c2[b3 + 912 >> 2];
              q3 = 0;
            }
          }
          if (n3) {
            c2[b3 + 416 >> 2] = c2[b3 + 908 >> 2];
            c2[b3 + 420 >> 2] = c2[b3 + 912 >> 2];
            a2[b3 + 985 >> 0] = 1;
            a2[E3 >> 0] = 0;
          }
          c2[2279] = (c2[2279] | 0) + -1;
          c2[b3 + 512 >> 2] = c2[2278];
          l3 = G3;
          return F3 | (q3 | 0) == 0 | 0;
        }
        function Ud(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = T2(c3);
          var d4 = ib;
          d4 = T2(me(a3, b3, c3));
          return T2(d4 + T2(ne(a3, b3, c3)));
        }
        function Vd(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0;
          g3 = l3;
          l3 = l3 + 16 | 0;
          f4 = g3;
          c2[f4 >> 2] = e4;
          if (!a3)
            e4 = 0;
          else
            e4 = c2[a3 + 976 >> 2] | 0;
          ge(e4, a3, b3, d4, f4);
          l3 = g3;
          return;
        }
        function Wd(a3) {
          a3 = a3 | 0;
          return (a3 >>> 0 > 60 ? 3201 : 3201 + (60 - a3) | 0) | 0;
        }
        function Xd(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          d4 = f4 + 12 | 0;
          e4 = f4;
          c2[d4 >> 2] = c2[254];
          c2[d4 + 4 >> 2] = c2[255];
          c2[d4 + 8 >> 2] = c2[256];
          c2[e4 >> 2] = c2[257];
          c2[e4 + 4 >> 2] = c2[258];
          c2[e4 + 8 >> 2] = c2[259];
          if ((a3 | 0) > 2)
            a3 = 11699;
          else
            a3 = c2[(b3 ? e4 : d4) + (a3 << 2) >> 2] | 0;
          l3 = f4;
          return a3 | 0;
        }
        function Yd(b3, e4, f4, h3, i4, k4, m4, n3, o3, p4) {
          b3 = b3 | 0;
          e4 = T2(e4);
          f4 = T2(f4);
          h3 = h3 | 0;
          i4 = i4 | 0;
          k4 = k4 | 0;
          m4 = T2(m4);
          n3 = T2(n3);
          o3 = o3 | 0;
          p4 = p4 | 0;
          var q3 = 0, r3 = 0, s3 = 0, t3 = 0, u4 = ib, v4 = ib, w3 = ib, x4 = ib, y3 = ib, z3 = ib, A3 = ib, B3 = 0, C3 = 0, D3 = 0, E3 = ib, F3 = ib, G3 = 0, H3 = ib, I3 = 0, J3 = 0, K3 = 0, L3 = 0, M4 = 0, N4 = 0, O3 = 0, P3 = 0, Q3 = 0, R3 = 0, S4 = 0, U3 = 0, V3 = 0, W3 = 0, X3 = 0, Y3 = 0, Z3 = 0, _3 = 0, $4 = ib, aa2 = ib, ba2 = ib, ca2 = ib, da2 = ib, ea2 = 0, fa2 = 0, ga2 = 0, ha2 = 0, ia2 = 0, ja2 = ib, ka2 = ib, la2 = ib, ma2 = ib, na2 = ib, oa2 = ib, pa2 = 0, qa2 = ib, ra2 = ib, sa2 = ib, ta2 = ib, ua2 = ib, va2 = ib, wa2 = 0, xa2 = 0, ya2 = ib, za2 = ib, Aa2 = 0, Ba2 = 0, Ca2 = 0, Da2 = 0, Ea2 = ib, Fa2 = 0, Ga2 = 0, Ha2 = 0, Ia2 = 0, Ja2 = 0, Ka2 = 0, La2 = 0, Ma2 = ib, Na2 = 0, Oa2 = 0;
          La2 = l3;
          l3 = l3 + 16 | 0;
          ea2 = La2 + 12 | 0;
          fa2 = La2 + 8 | 0;
          ga2 = La2 + 4 | 0;
          ha2 = La2;
          ec(b3, (i4 | 0) == 0 | (Sb(e4) | 0) ^ 1, 3326);
          ec(b3, (k4 | 0) == 0 | (Sb(f4) | 0) ^ 1, 3406);
          Ga2 = qe(b3, h3) | 0;
          c2[b3 + 496 >> 2] = Ga2;
          Ja2 = re(2, Ga2) | 0;
          Ka2 = re(0, Ga2) | 0;
          g2[b3 + 440 >> 2] = T2(me(b3, Ja2, m4));
          g2[b3 + 444 >> 2] = T2(ne(b3, Ja2, m4));
          g2[b3 + 428 >> 2] = T2(me(b3, Ka2, m4));
          g2[b3 + 436 >> 2] = T2(ne(b3, Ka2, m4));
          g2[b3 + 464 >> 2] = T2(se(b3, Ja2));
          g2[b3 + 468 >> 2] = T2(te(b3, Ja2));
          g2[b3 + 452 >> 2] = T2(se(b3, Ka2));
          g2[b3 + 460 >> 2] = T2(te(b3, Ka2));
          g2[b3 + 488 >> 2] = T2(ue(b3, Ja2, m4));
          g2[b3 + 492 >> 2] = T2(ve(b3, Ja2, m4));
          g2[b3 + 476 >> 2] = T2(ue(b3, Ka2, m4));
          g2[b3 + 484 >> 2] = T2(ve(b3, Ka2, m4));
          do
            if (!(c2[b3 + 964 >> 2] | 0)) {
              Ha2 = b3 + 948 | 0;
              Ia2 = (c2[b3 + 952 >> 2] | 0) - (c2[Ha2 >> 2] | 0) >> 2;
              if (!Ia2) {
                xe(b3, e4, f4, i4, k4, m4, n3);
                break;
              }
              if (!o3 ? ye(b3, e4, f4, i4, k4, m4, n3) | 0 : 0)
                break;
              lc(b3);
              Y3 = b3 + 508 | 0;
              a2[Y3 >> 0] = 0;
              Ja2 = re(c2[b3 + 4 >> 2] | 0, Ga2) | 0;
              Ka2 = ze(Ja2, Ga2) | 0;
              Fa2 = oe(Ja2) | 0;
              Z3 = c2[b3 + 8 >> 2] | 0;
              Ba2 = b3 + 28 | 0;
              _3 = (c2[Ba2 >> 2] | 0) != 0;
              ua2 = Fa2 ? m4 : n3;
              ya2 = Fa2 ? n3 : m4;
              $4 = T2(Ae(b3, Ja2, m4));
              aa2 = T2(Be(b3, Ja2, m4));
              u4 = T2(Ae(b3, Ka2, m4));
              va2 = T2(Ce(b3, Ja2, m4));
              za2 = T2(Ce(b3, Ka2, m4));
              D3 = Fa2 ? i4 : k4;
              Aa2 = Fa2 ? k4 : i4;
              Ea2 = Fa2 ? va2 : za2;
              y3 = Fa2 ? za2 : va2;
              ta2 = T2(Ud(b3, 2, m4));
              x4 = T2(Ud(b3, 0, m4));
              v4 = T2(T2(be(b3 + 364 | 0, m4)) - Ea2);
              w3 = T2(T2(be(b3 + 380 | 0, m4)) - Ea2);
              z3 = T2(T2(be(b3 + 372 | 0, n3)) - y3);
              A3 = T2(T2(be(b3 + 388 | 0, n3)) - y3);
              ba2 = Fa2 ? v4 : z3;
              ca2 = Fa2 ? w3 : A3;
              ta2 = T2(e4 - ta2);
              e4 = T2(ta2 - Ea2);
              if (Sb(e4) | 0)
                Ea2 = e4;
              else
                Ea2 = T2(cC(T2(eC(e4, w3)), v4));
              ra2 = T2(f4 - x4);
              e4 = T2(ra2 - y3);
              if (Sb(e4) | 0)
                sa2 = e4;
              else
                sa2 = T2(cC(T2(eC(e4, A3)), z3));
              v4 = Fa2 ? Ea2 : sa2;
              qa2 = Fa2 ? sa2 : Ea2;
              a:
                do
                  if ((D3 | 0) == 1) {
                    h3 = 0;
                    r3 = 0;
                    while (1) {
                      q3 = ac(b3, r3) | 0;
                      if (!h3) {
                        if (T2(Ee(q3)) > T2(0) ? T2(Fe(q3)) > T2(0) : 0)
                          h3 = q3;
                        else
                          h3 = 0;
                      } else if (De(q3) | 0) {
                        t3 = 0;
                        break a;
                      }
                      r3 = r3 + 1 | 0;
                      if (r3 >>> 0 >= Ia2 >>> 0) {
                        t3 = h3;
                        break;
                      }
                    }
                  } else
                    t3 = 0;
                while (0);
              B3 = t3 + 500 | 0;
              C3 = t3 + 504 | 0;
              h3 = 0;
              q3 = 0;
              e4 = T2(0);
              s3 = 0;
              do {
                r3 = c2[(c2[Ha2 >> 2] | 0) + (s3 << 2) >> 2] | 0;
                if ((c2[r3 + 36 >> 2] | 0) == 1) {
                  Ge(r3);
                  a2[r3 + 985 >> 0] = 1;
                  a2[r3 + 984 >> 0] = 0;
                } else {
                  $d(r3);
                  if (o3)
                    ce(r3, qe(r3, Ga2) | 0, v4, qa2, Ea2);
                  do
                    if ((c2[r3 + 24 >> 2] | 0) != 1) {
                      if ((r3 | 0) == (t3 | 0)) {
                        c2[B3 >> 2] = c2[2278];
                        g2[C3 >> 2] = T2(0);
                        break;
                      } else {
                        He(b3, r3, Ea2, i4, sa2, Ea2, sa2, k4, Ga2, p4);
                        break;
                      }
                    } else {
                      if (q3 | 0)
                        c2[q3 + 960 >> 2] = r3;
                      c2[r3 + 960 >> 2] = 0;
                      q3 = r3;
                      h3 = (h3 | 0) == 0 ? r3 : h3;
                    }
                  while (0);
                  oa2 = T2(g2[r3 + 504 >> 2]);
                  e4 = T2(e4 + T2(oa2 + T2(Ud(r3, Ja2, Ea2))));
                }
                s3 = s3 + 1 | 0;
              } while ((s3 | 0) != (Ia2 | 0));
              K3 = e4 > v4;
              pa2 = _3 & ((D3 | 0) == 2 & K3) ? 1 : D3;
              I3 = (Aa2 | 0) == 1;
              M4 = I3 & (o3 ^ 1);
              N4 = (pa2 | 0) == 1;
              O3 = (pa2 | 0) == 2;
              P3 = 976 + (Ja2 << 2) | 0;
              Q3 = (Aa2 | 2 | 0) == 2;
              W3 = I3 & (_3 ^ 1);
              R3 = 1040 + (Ka2 << 2) | 0;
              S4 = 1040 + (Ja2 << 2) | 0;
              U3 = 976 + (Ka2 << 2) | 0;
              V3 = (Aa2 | 0) != 1;
              K3 = _3 & ((D3 | 0) != 0 & K3);
              J3 = b3 + 976 | 0;
              I3 = I3 ^ 1;
              e4 = v4;
              G3 = 0;
              L3 = 0;
              oa2 = T2(0);
              da2 = T2(0);
              while (1) {
                b:
                  do
                    if (G3 >>> 0 < Ia2 >>> 0) {
                      C3 = c2[Ha2 >> 2] | 0;
                      s3 = 0;
                      A3 = T2(0);
                      z3 = T2(0);
                      w3 = T2(0);
                      v4 = T2(0);
                      r3 = 0;
                      q3 = 0;
                      t3 = G3;
                      while (1) {
                        B3 = c2[C3 + (t3 << 2) >> 2] | 0;
                        if ((c2[B3 + 36 >> 2] | 0) != 1 ? (c2[B3 + 940 >> 2] = L3, (c2[B3 + 24 >> 2] | 0) != 1) : 0) {
                          x4 = T2(Ud(B3, Ja2, Ea2));
                          X3 = c2[P3 >> 2] | 0;
                          f4 = T2(be(B3 + 380 + (X3 << 3) | 0, ua2));
                          y3 = T2(g2[B3 + 504 >> 2]);
                          f4 = T2(eC(f4, y3));
                          f4 = T2(cC(T2(be(B3 + 364 + (X3 << 3) | 0, ua2)), f4));
                          if (_3 & (s3 | 0) != 0 & T2(x4 + T2(z3 + f4)) > e4) {
                            k4 = s3;
                            x4 = A3;
                            D3 = t3;
                            break b;
                          }
                          x4 = T2(x4 + f4);
                          f4 = T2(z3 + x4);
                          x4 = T2(A3 + x4);
                          if (De(B3) | 0) {
                            w3 = T2(w3 + T2(Ee(B3)));
                            v4 = T2(v4 - T2(y3 * T2(Fe(B3))));
                          }
                          if (q3 | 0)
                            c2[q3 + 960 >> 2] = B3;
                          c2[B3 + 960 >> 2] = 0;
                          s3 = s3 + 1 | 0;
                          q3 = B3;
                          r3 = (r3 | 0) == 0 ? B3 : r3;
                        } else {
                          x4 = A3;
                          f4 = z3;
                        }
                        t3 = t3 + 1 | 0;
                        if (t3 >>> 0 < Ia2 >>> 0) {
                          A3 = x4;
                          z3 = f4;
                        } else {
                          k4 = s3;
                          D3 = t3;
                          break;
                        }
                      }
                    } else {
                      k4 = 0;
                      x4 = T2(0);
                      w3 = T2(0);
                      v4 = T2(0);
                      r3 = 0;
                      D3 = G3;
                    }
                  while (0);
                X3 = w3 > T2(0) & w3 < T2(1);
                E3 = X3 ? T2(1) : w3;
                X3 = v4 > T2(0) & v4 < T2(1);
                A3 = X3 ? T2(1) : v4;
                do
                  if (!N4) {
                    if (!(x4 < ba2 & ((Sb(ba2) | 0) ^ 1))) {
                      if (!(x4 > ca2 & ((Sb(ca2) | 0) ^ 1))) {
                        if (!(a2[(c2[J3 >> 2] | 0) + 3 >> 0] | 0)) {
                          if (!(E3 == T2(0)) ? !(T2(Ee(b3)) == T2(0)) : 0) {
                            X3 = 53;
                            break;
                          }
                          e4 = x4;
                          X3 = 53;
                        } else
                          X3 = 51;
                      } else {
                        e4 = ca2;
                        X3 = 51;
                      }
                    } else {
                      e4 = ba2;
                      X3 = 51;
                    }
                  } else
                    X3 = 51;
                while (0);
                if ((X3 | 0) == 51) {
                  X3 = 0;
                  if (Sb(e4) | 0)
                    X3 = 53;
                  else {
                    F3 = T2(e4 - x4);
                    H3 = e4;
                  }
                }
                if ((X3 | 0) == 53) {
                  X3 = 0;
                  if (x4 < T2(0)) {
                    F3 = T2(-x4);
                    H3 = e4;
                  } else {
                    F3 = T2(0);
                    H3 = e4;
                  }
                }
                if (!M4 ? (ia2 = (r3 | 0) == 0, !ia2) : 0) {
                  s3 = c2[P3 >> 2] | 0;
                  t3 = F3 < T2(0);
                  y3 = T2(F3 / A3);
                  B3 = F3 > T2(0);
                  z3 = T2(F3 / E3);
                  w3 = T2(0);
                  x4 = T2(0);
                  e4 = T2(0);
                  q3 = r3;
                  do {
                    f4 = T2(be(q3 + 380 + (s3 << 3) | 0, ua2));
                    v4 = T2(be(q3 + 364 + (s3 << 3) | 0, ua2));
                    v4 = T2(eC(f4, T2(cC(v4, T2(g2[q3 + 504 >> 2])))));
                    if (t3) {
                      f4 = T2(v4 * T2(Fe(q3)));
                      if (f4 != T2(-0) ? (Ma2 = T2(v4 - T2(y3 * f4)), ja2 = T2(Ie(q3, Ja2, Ma2, H3, Ea2)), Ma2 != ja2) : 0) {
                        w3 = T2(w3 - T2(ja2 - v4));
                        e4 = T2(e4 + f4);
                      }
                    } else if ((B3 ? (ka2 = T2(Ee(q3)), ka2 != T2(0)) : 0) ? (Ma2 = T2(v4 + T2(z3 * ka2)), la2 = T2(Ie(q3, Ja2, Ma2, H3, Ea2)), Ma2 != la2) : 0) {
                      w3 = T2(w3 - T2(la2 - v4));
                      x4 = T2(x4 - ka2);
                    }
                    q3 = c2[q3 + 960 >> 2] | 0;
                  } while ((q3 | 0) != 0);
                  e4 = T2(A3 + e4);
                  v4 = T2(F3 + w3);
                  if (!ia2) {
                    y3 = T2(E3 + x4);
                    t3 = c2[P3 >> 2] | 0;
                    B3 = v4 < T2(0);
                    C3 = e4 == T2(0);
                    z3 = T2(v4 / e4);
                    s3 = v4 > T2(0);
                    y3 = T2(v4 / y3);
                    e4 = T2(0);
                    do {
                      Ma2 = T2(be(r3 + 380 + (t3 << 3) | 0, ua2));
                      w3 = T2(be(r3 + 364 + (t3 << 3) | 0, ua2));
                      w3 = T2(eC(Ma2, T2(cC(w3, T2(g2[r3 + 504 >> 2])))));
                      if (B3) {
                        Ma2 = T2(w3 * T2(Fe(r3)));
                        v4 = T2(-Ma2);
                        if (Ma2 != T2(-0)) {
                          Ma2 = T2(z3 * v4);
                          v4 = T2(Ie(r3, Ja2, T2(w3 + (C3 ? v4 : Ma2)), H3, Ea2));
                        } else
                          v4 = w3;
                      } else if (s3 ? (ma2 = T2(Ee(r3)), ma2 != T2(0)) : 0)
                        v4 = T2(Ie(r3, Ja2, T2(w3 + T2(y3 * ma2)), H3, Ea2));
                      else
                        v4 = w3;
                      e4 = T2(e4 - T2(v4 - w3));
                      x4 = T2(Ud(r3, Ja2, Ea2));
                      f4 = T2(Ud(r3, Ka2, Ea2));
                      v4 = T2(v4 + x4);
                      g2[fa2 >> 2] = v4;
                      c2[ha2 >> 2] = 1;
                      w3 = T2(g2[r3 + 396 >> 2]);
                      c:
                        do
                          if (Sb(w3) | 0) {
                            q3 = Sb(qa2) | 0;
                            do
                              if (!q3) {
                                if (K3 | (ae(r3, Ka2, qa2) | 0 | I3))
                                  break;
                                if ((Je(b3, r3) | 0) != 4)
                                  break;
                                if ((c2[(Ke(r3, Ka2) | 0) + 4 >> 2] | 0) == 3)
                                  break;
                                if ((c2[(Le(r3, Ka2) | 0) + 4 >> 2] | 0) == 3)
                                  break;
                                g2[ea2 >> 2] = qa2;
                                c2[ga2 >> 2] = 1;
                                break c;
                              }
                            while (0);
                            if (ae(r3, Ka2, qa2) | 0) {
                              q3 = c2[r3 + 992 + (c2[U3 >> 2] << 2) >> 2] | 0;
                              Ma2 = T2(f4 + T2(be(q3, qa2)));
                              g2[ea2 >> 2] = Ma2;
                              q3 = V3 & (c2[q3 + 4 >> 2] | 0) == 2;
                              c2[ga2 >> 2] = ((Sb(Ma2) | 0 | q3) ^ 1) & 1;
                              break;
                            } else {
                              g2[ea2 >> 2] = qa2;
                              c2[ga2 >> 2] = q3 ? 0 : 2;
                              break;
                            }
                          } else {
                            Ma2 = T2(v4 - x4);
                            E3 = T2(Ma2 / w3);
                            Ma2 = T2(w3 * Ma2);
                            c2[ga2 >> 2] = 1;
                            g2[ea2 >> 2] = T2(f4 + (Fa2 ? E3 : Ma2));
                          }
                        while (0);
                      Me(r3, Ja2, H3, Ea2, ha2, fa2);
                      Me(r3, Ka2, qa2, Ea2, ga2, ea2);
                      do
                        if (!(ae(r3, Ka2, qa2) | 0) ? (Je(b3, r3) | 0) == 4 : 0) {
                          if ((c2[(Ke(r3, Ka2) | 0) + 4 >> 2] | 0) == 3) {
                            q3 = 0;
                            break;
                          }
                          q3 = (c2[(Le(r3, Ka2) | 0) + 4 >> 2] | 0) != 3;
                        } else
                          q3 = 0;
                      while (0);
                      Ma2 = T2(g2[fa2 >> 2]);
                      E3 = T2(g2[ea2 >> 2]);
                      Na2 = c2[ha2 >> 2] | 0;
                      Oa2 = c2[ga2 >> 2] | 0;
                      Td(r3, Fa2 ? Ma2 : E3, Fa2 ? E3 : Ma2, Ga2, Fa2 ? Na2 : Oa2, Fa2 ? Oa2 : Na2, Ea2, sa2, o3 & (q3 ^ 1), 3488, p4) | 0;
                      a2[Y3 >> 0] = a2[Y3 >> 0] | a2[r3 + 508 >> 0];
                      r3 = c2[r3 + 960 >> 2] | 0;
                    } while ((r3 | 0) != 0);
                  } else
                    e4 = T2(0);
                } else
                  e4 = T2(0);
                e4 = T2(F3 + e4);
                Oa2 = e4 < T2(0) & 1;
                a2[Y3 >> 0] = Oa2 | d3[Y3 >> 0];
                if (O3 & e4 > T2(0)) {
                  q3 = c2[P3 >> 2] | 0;
                  if ((c2[b3 + 364 + (q3 << 3) + 4 >> 2] | 0) != 0 ? (na2 = T2(be(b3 + 364 + (q3 << 3) | 0, ua2)), na2 >= T2(0)) : 0)
                    v4 = T2(cC(T2(0), T2(na2 - T2(H3 - e4))));
                  else
                    v4 = T2(0);
                } else
                  v4 = e4;
                B3 = G3 >>> 0 < D3 >>> 0;
                if (B3) {
                  t3 = c2[Ha2 >> 2] | 0;
                  s3 = G3;
                  q3 = 0;
                  do {
                    r3 = c2[t3 + (s3 << 2) >> 2] | 0;
                    if (!(c2[r3 + 24 >> 2] | 0)) {
                      q3 = ((c2[(Ke(r3, Ja2) | 0) + 4 >> 2] | 0) == 3 & 1) + q3 | 0;
                      q3 = q3 + ((c2[(Le(r3, Ja2) | 0) + 4 >> 2] | 0) == 3 & 1) | 0;
                    }
                    s3 = s3 + 1 | 0;
                  } while ((s3 | 0) != (D3 | 0));
                  if (q3) {
                    x4 = T2(0);
                    f4 = T2(0);
                  } else
                    X3 = 101;
                } else
                  X3 = 101;
                d:
                  do
                    if ((X3 | 0) == 101) {
                      X3 = 0;
                      switch (Z3 | 0) {
                        case 1: {
                          q3 = 0;
                          x4 = T2(v4 * T2(0.5));
                          f4 = T2(0);
                          break d;
                        }
                        case 2: {
                          q3 = 0;
                          x4 = v4;
                          f4 = T2(0);
                          break d;
                        }
                        case 3: {
                          if (k4 >>> 0 <= 1) {
                            q3 = 0;
                            x4 = T2(0);
                            f4 = T2(0);
                            break d;
                          }
                          f4 = T2((k4 + -1 | 0) >>> 0);
                          q3 = 0;
                          x4 = T2(0);
                          f4 = T2(T2(cC(v4, T2(0))) / f4);
                          break d;
                        }
                        case 5: {
                          f4 = T2(v4 / T2((k4 + 1 | 0) >>> 0));
                          q3 = 0;
                          x4 = f4;
                          break d;
                        }
                        case 4: {
                          f4 = T2(v4 / T2(k4 >>> 0));
                          q3 = 0;
                          x4 = T2(f4 * T2(0.5));
                          break d;
                        }
                        default: {
                          q3 = 0;
                          x4 = T2(0);
                          f4 = T2(0);
                          break d;
                        }
                      }
                    }
                  while (0);
                e4 = T2($4 + x4);
                if (B3) {
                  w3 = T2(v4 / T2(q3 | 0));
                  s3 = c2[Ha2 >> 2] | 0;
                  r3 = G3;
                  v4 = T2(0);
                  do {
                    q3 = c2[s3 + (r3 << 2) >> 2] | 0;
                    e:
                      do
                        if ((c2[q3 + 36 >> 2] | 0) != 1) {
                          switch (c2[q3 + 24 >> 2] | 0) {
                            case 1: {
                              if (Ne(q3, Ja2) | 0) {
                                if (!o3)
                                  break e;
                                Ma2 = T2(Oe(q3, Ja2, H3));
                                Ma2 = T2(Ma2 + T2(se(b3, Ja2)));
                                Ma2 = T2(Ma2 + T2(me(q3, Ja2, Ea2)));
                                g2[q3 + 400 + (c2[S4 >> 2] << 2) >> 2] = Ma2;
                                break e;
                              }
                              break;
                            }
                            case 0: {
                              Oa2 = (c2[(Ke(q3, Ja2) | 0) + 4 >> 2] | 0) == 3;
                              Ma2 = T2(w3 + e4);
                              e4 = Oa2 ? Ma2 : e4;
                              if (o3) {
                                Oa2 = q3 + 400 + (c2[S4 >> 2] << 2) | 0;
                                g2[Oa2 >> 2] = T2(e4 + T2(g2[Oa2 >> 2]));
                              }
                              Oa2 = (c2[(Le(q3, Ja2) | 0) + 4 >> 2] | 0) == 3;
                              Ma2 = T2(w3 + e4);
                              e4 = Oa2 ? Ma2 : e4;
                              if (M4) {
                                Ma2 = T2(f4 + T2(Ud(q3, Ja2, Ea2)));
                                v4 = qa2;
                                e4 = T2(e4 + T2(Ma2 + T2(g2[q3 + 504 >> 2])));
                                break e;
                              } else {
                                e4 = T2(e4 + T2(f4 + T2(Pe(q3, Ja2, Ea2))));
                                v4 = T2(cC(v4, T2(Pe(q3, Ka2, Ea2))));
                                break e;
                              }
                            }
                            default: {
                            }
                          }
                          if (o3) {
                            Ma2 = T2(x4 + T2(se(b3, Ja2)));
                            Oa2 = q3 + 400 + (c2[S4 >> 2] << 2) | 0;
                            g2[Oa2 >> 2] = T2(Ma2 + T2(g2[Oa2 >> 2]));
                          }
                        }
                      while (0);
                    r3 = r3 + 1 | 0;
                  } while ((r3 | 0) != (D3 | 0));
                } else
                  v4 = T2(0);
                f4 = T2(aa2 + e4);
                if (Q3)
                  x4 = T2(T2(Ie(b3, Ka2, T2(za2 + v4), ya2, m4)) - za2);
                else
                  x4 = qa2;
                w3 = T2(T2(Ie(b3, Ka2, T2(za2 + (W3 ? qa2 : v4)), ya2, m4)) - za2);
                if (B3 & o3) {
                  r3 = G3;
                  do {
                    s3 = c2[(c2[Ha2 >> 2] | 0) + (r3 << 2) >> 2] | 0;
                    do
                      if ((c2[s3 + 36 >> 2] | 0) != 1) {
                        if ((c2[s3 + 24 >> 2] | 0) == 1) {
                          if (Ne(s3, Ka2) | 0) {
                            Ma2 = T2(Oe(s3, Ka2, qa2));
                            Ma2 = T2(Ma2 + T2(se(b3, Ka2)));
                            Ma2 = T2(Ma2 + T2(me(s3, Ka2, Ea2)));
                            q3 = c2[R3 >> 2] | 0;
                            g2[s3 + 400 + (q3 << 2) >> 2] = Ma2;
                            if (!(Sb(Ma2) | 0))
                              break;
                          } else
                            q3 = c2[R3 >> 2] | 0;
                          Ma2 = T2(se(b3, Ka2));
                          g2[s3 + 400 + (q3 << 2) >> 2] = T2(Ma2 + T2(me(s3, Ka2, Ea2)));
                          break;
                        }
                        q3 = Je(b3, s3) | 0;
                        do
                          if ((q3 | 0) == 4) {
                            if ((c2[(Ke(s3, Ka2) | 0) + 4 >> 2] | 0) == 3) {
                              X3 = 139;
                              break;
                            }
                            if ((c2[(Le(s3, Ka2) | 0) + 4 >> 2] | 0) == 3) {
                              X3 = 139;
                              break;
                            }
                            if (ae(s3, Ka2, qa2) | 0) {
                              e4 = u4;
                              break;
                            }
                            Na2 = c2[s3 + 908 + (c2[P3 >> 2] << 2) >> 2] | 0;
                            c2[ea2 >> 2] = Na2;
                            e4 = T2(g2[s3 + 396 >> 2]);
                            Oa2 = Sb(e4) | 0;
                            v4 = (c2[j3 >> 2] = Na2, T2(g2[j3 >> 2]));
                            if (Oa2)
                              e4 = w3;
                            else {
                              F3 = T2(Ud(s3, Ka2, Ea2));
                              Ma2 = T2(v4 / e4);
                              e4 = T2(e4 * v4);
                              e4 = T2(F3 + (Fa2 ? Ma2 : e4));
                            }
                            g2[fa2 >> 2] = e4;
                            g2[ea2 >> 2] = T2(T2(Ud(s3, Ja2, Ea2)) + v4);
                            c2[ga2 >> 2] = 1;
                            c2[ha2 >> 2] = 1;
                            Me(s3, Ja2, H3, Ea2, ga2, ea2);
                            Me(s3, Ka2, qa2, Ea2, ha2, fa2);
                            e4 = T2(g2[ea2 >> 2]);
                            F3 = T2(g2[fa2 >> 2]);
                            Ma2 = Fa2 ? e4 : F3;
                            e4 = Fa2 ? F3 : e4;
                            Oa2 = ((Sb(Ma2) | 0) ^ 1) & 1;
                            Td(s3, Ma2, e4, Ga2, Oa2, ((Sb(e4) | 0) ^ 1) & 1, Ea2, sa2, 1, 3493, p4) | 0;
                            e4 = u4;
                          } else
                            X3 = 139;
                        while (0);
                        f:
                          do
                            if ((X3 | 0) == 139) {
                              X3 = 0;
                              e4 = T2(x4 - T2(Pe(s3, Ka2, Ea2)));
                              do
                                if ((c2[(Ke(s3, Ka2) | 0) + 4 >> 2] | 0) == 3) {
                                  if ((c2[(Le(s3, Ka2) | 0) + 4 >> 2] | 0) != 3)
                                    break;
                                  e4 = T2(u4 + T2(cC(T2(0), T2(e4 * T2(0.5)))));
                                  break f;
                                }
                              while (0);
                              if ((c2[(Le(s3, Ka2) | 0) + 4 >> 2] | 0) == 3) {
                                e4 = u4;
                                break;
                              }
                              if ((c2[(Ke(s3, Ka2) | 0) + 4 >> 2] | 0) == 3) {
                                e4 = T2(u4 + T2(cC(T2(0), e4)));
                                break;
                              }
                              switch (q3 | 0) {
                                case 1: {
                                  e4 = u4;
                                  break f;
                                }
                                case 2: {
                                  e4 = T2(u4 + T2(e4 * T2(0.5)));
                                  break f;
                                }
                                default: {
                                  e4 = T2(u4 + e4);
                                  break f;
                                }
                              }
                            }
                          while (0);
                        Ma2 = T2(oa2 + e4);
                        Oa2 = s3 + 400 + (c2[R3 >> 2] << 2) | 0;
                        g2[Oa2 >> 2] = T2(Ma2 + T2(g2[Oa2 >> 2]));
                      }
                    while (0);
                    r3 = r3 + 1 | 0;
                  } while ((r3 | 0) != (D3 | 0));
                }
                oa2 = T2(oa2 + w3);
                da2 = T2(cC(da2, f4));
                k4 = L3 + 1 | 0;
                if (D3 >>> 0 >= Ia2 >>> 0)
                  break;
                else {
                  e4 = H3;
                  G3 = D3;
                  L3 = k4;
                }
              }
              do
                if (o3) {
                  q3 = k4 >>> 0 > 1;
                  if (!q3 ? !(Qe(b3) | 0) : 0)
                    break;
                  if (!(Sb(qa2) | 0)) {
                    e4 = T2(qa2 - oa2);
                    g:
                      do
                        switch (c2[b3 + 12 >> 2] | 0) {
                          case 3: {
                            u4 = T2(u4 + e4);
                            z3 = T2(0);
                            break;
                          }
                          case 2: {
                            u4 = T2(u4 + T2(e4 * T2(0.5)));
                            z3 = T2(0);
                            break;
                          }
                          case 4: {
                            if (qa2 > oa2)
                              z3 = T2(e4 / T2(k4 >>> 0));
                            else
                              z3 = T2(0);
                            break;
                          }
                          case 7:
                            if (qa2 > oa2) {
                              u4 = T2(u4 + T2(e4 / T2(k4 << 1 >>> 0)));
                              z3 = T2(e4 / T2(k4 >>> 0));
                              z3 = q3 ? z3 : T2(0);
                              break g;
                            } else {
                              u4 = T2(u4 + T2(e4 * T2(0.5)));
                              z3 = T2(0);
                              break g;
                            }
                          case 6: {
                            z3 = T2(e4 / T2(L3 >>> 0));
                            z3 = qa2 > oa2 & q3 ? z3 : T2(0);
                            break;
                          }
                          default:
                            z3 = T2(0);
                        }
                      while (0);
                    if (k4 | 0) {
                      B3 = 1040 + (Ka2 << 2) | 0;
                      C3 = 976 + (Ka2 << 2) | 0;
                      t3 = 0;
                      r3 = 0;
                      while (1) {
                        h:
                          do
                            if (r3 >>> 0 < Ia2 >>> 0) {
                              v4 = T2(0);
                              w3 = T2(0);
                              e4 = T2(0);
                              s3 = r3;
                              while (1) {
                                q3 = c2[(c2[Ha2 >> 2] | 0) + (s3 << 2) >> 2] | 0;
                                do
                                  if ((c2[q3 + 36 >> 2] | 0) != 1 ? (c2[q3 + 24 >> 2] | 0) == 0 : 0) {
                                    if ((c2[q3 + 940 >> 2] | 0) != (t3 | 0))
                                      break h;
                                    if (Re(q3, Ka2) | 0) {
                                      Ma2 = T2(g2[q3 + 908 + (c2[C3 >> 2] << 2) >> 2]);
                                      e4 = T2(cC(e4, T2(Ma2 + T2(Ud(q3, Ka2, Ea2)))));
                                    }
                                    if ((Je(b3, q3) | 0) != 5)
                                      break;
                                    na2 = T2(Se(q3));
                                    na2 = T2(na2 + T2(me(q3, 0, Ea2)));
                                    Ma2 = T2(g2[q3 + 912 >> 2]);
                                    Ma2 = T2(T2(Ma2 + T2(Ud(q3, 0, Ea2))) - na2);
                                    na2 = T2(cC(w3, na2));
                                    Ma2 = T2(cC(v4, Ma2));
                                    v4 = Ma2;
                                    w3 = na2;
                                    e4 = T2(cC(e4, T2(na2 + Ma2)));
                                  }
                                while (0);
                                q3 = s3 + 1 | 0;
                                if (q3 >>> 0 < Ia2 >>> 0)
                                  s3 = q3;
                                else {
                                  s3 = q3;
                                  break;
                                }
                              }
                            } else {
                              w3 = T2(0);
                              e4 = T2(0);
                              s3 = r3;
                            }
                          while (0);
                        y3 = T2(z3 + e4);
                        f4 = u4;
                        u4 = T2(u4 + y3);
                        if (r3 >>> 0 < s3 >>> 0) {
                          x4 = T2(f4 + w3);
                          q3 = r3;
                          do {
                            r3 = c2[(c2[Ha2 >> 2] | 0) + (q3 << 2) >> 2] | 0;
                            i:
                              do
                                if ((c2[r3 + 36 >> 2] | 0) != 1 ? (c2[r3 + 24 >> 2] | 0) == 0 : 0)
                                  switch (Je(b3, r3) | 0) {
                                    case 1: {
                                      Ma2 = T2(f4 + T2(me(r3, Ka2, Ea2)));
                                      g2[r3 + 400 + (c2[B3 >> 2] << 2) >> 2] = Ma2;
                                      break i;
                                    }
                                    case 3: {
                                      Ma2 = T2(T2(u4 - T2(ne(r3, Ka2, Ea2))) - T2(g2[r3 + 908 + (c2[C3 >> 2] << 2) >> 2]));
                                      g2[r3 + 400 + (c2[B3 >> 2] << 2) >> 2] = Ma2;
                                      break i;
                                    }
                                    case 2: {
                                      Ma2 = T2(f4 + T2(T2(y3 - T2(g2[r3 + 908 + (c2[C3 >> 2] << 2) >> 2])) * T2(0.5)));
                                      g2[r3 + 400 + (c2[B3 >> 2] << 2) >> 2] = Ma2;
                                      break i;
                                    }
                                    case 4: {
                                      Ma2 = T2(f4 + T2(me(r3, Ka2, Ea2)));
                                      g2[r3 + 400 + (c2[B3 >> 2] << 2) >> 2] = Ma2;
                                      if (ae(r3, Ka2, qa2) | 0)
                                        break i;
                                      if (Fa2) {
                                        v4 = T2(g2[r3 + 908 >> 2]);
                                        e4 = T2(v4 + T2(Ud(r3, Ja2, Ea2)));
                                        w3 = y3;
                                      } else {
                                        w3 = T2(g2[r3 + 912 >> 2]);
                                        w3 = T2(w3 + T2(Ud(r3, Ka2, Ea2)));
                                        e4 = y3;
                                        v4 = T2(g2[r3 + 908 >> 2]);
                                      }
                                      if (Ld(e4, v4) | 0 ? Ld(w3, T2(g2[r3 + 912 >> 2])) | 0 : 0)
                                        break i;
                                      Td(r3, e4, w3, Ga2, 1, 1, Ea2, sa2, 1, 3501, p4) | 0;
                                      break i;
                                    }
                                    case 5: {
                                      g2[r3 + 404 >> 2] = T2(T2(x4 - T2(Se(r3))) + T2(Oe(r3, 0, qa2)));
                                      break i;
                                    }
                                    default:
                                      break i;
                                  }
                              while (0);
                            q3 = q3 + 1 | 0;
                          } while ((q3 | 0) != (s3 | 0));
                        }
                        t3 = t3 + 1 | 0;
                        if ((t3 | 0) == (k4 | 0))
                          break;
                        else
                          r3 = s3;
                      }
                    }
                  }
                }
              while (0);
              g2[b3 + 908 >> 2] = T2(Ie(b3, 2, ta2, m4, m4));
              g2[b3 + 912 >> 2] = T2(Ie(b3, 0, ra2, n3, m4));
              if ((pa2 | 0) != 0 ? (wa2 = c2[b3 + 32 >> 2] | 0, xa2 = (pa2 | 0) == 2, !(xa2 & (wa2 | 0) != 2)) : 0) {
                if (xa2 & (wa2 | 0) == 2) {
                  e4 = T2(va2 + H3);
                  e4 = T2(cC(T2(eC(e4, T2(Te(b3, Ja2, da2, ua2)))), va2));
                  X3 = 198;
                }
              } else {
                e4 = T2(Ie(b3, Ja2, da2, ua2, m4));
                X3 = 198;
              }
              if ((X3 | 0) == 198)
                g2[b3 + 908 + (c2[976 + (Ja2 << 2) >> 2] << 2) >> 2] = e4;
              if ((Aa2 | 0) != 0 ? (Ca2 = c2[b3 + 32 >> 2] | 0, Da2 = (Aa2 | 0) == 2, !(Da2 & (Ca2 | 0) != 2)) : 0) {
                if (Da2 & (Ca2 | 0) == 2) {
                  e4 = T2(za2 + qa2);
                  e4 = T2(cC(T2(eC(e4, T2(Te(b3, Ka2, T2(za2 + oa2), ya2)))), za2));
                  X3 = 204;
                }
              } else {
                e4 = T2(Ie(b3, Ka2, T2(za2 + oa2), ya2, m4));
                X3 = 204;
              }
              if ((X3 | 0) == 204)
                g2[b3 + 908 + (c2[976 + (Ka2 << 2) >> 2] << 2) >> 2] = e4;
              if (o3) {
                if ((c2[Ba2 >> 2] | 0) == 2) {
                  r3 = 976 + (Ka2 << 2) | 0;
                  s3 = 1040 + (Ka2 << 2) | 0;
                  q3 = 0;
                  do {
                    t3 = ac(b3, q3) | 0;
                    if (!(c2[t3 + 24 >> 2] | 0)) {
                      Na2 = c2[r3 >> 2] | 0;
                      Ma2 = T2(g2[b3 + 908 + (Na2 << 2) >> 2]);
                      Oa2 = t3 + 400 + (c2[s3 >> 2] << 2) | 0;
                      Ma2 = T2(Ma2 - T2(g2[Oa2 >> 2]));
                      g2[Oa2 >> 2] = T2(Ma2 - T2(g2[t3 + 908 + (Na2 << 2) >> 2]));
                    }
                    q3 = q3 + 1 | 0;
                  } while ((q3 | 0) != (Ia2 | 0));
                }
                if (h3 | 0) {
                  q3 = Fa2 ? pa2 : i4;
                  do {
                    Ue(b3, h3, Ea2, q3, sa2, Ga2, p4);
                    h3 = c2[h3 + 960 >> 2] | 0;
                  } while ((h3 | 0) != 0);
                }
                q3 = (Ja2 | 2 | 0) == 3;
                r3 = (Ka2 | 2 | 0) == 3;
                if (q3 | r3) {
                  h3 = 0;
                  do {
                    s3 = c2[(c2[Ha2 >> 2] | 0) + (h3 << 2) >> 2] | 0;
                    if ((c2[s3 + 36 >> 2] | 0) != 1) {
                      if (q3)
                        Ve(b3, s3, Ja2);
                      if (r3)
                        Ve(b3, s3, Ka2);
                    }
                    h3 = h3 + 1 | 0;
                  } while ((h3 | 0) != (Ia2 | 0));
                }
              }
            } else
              we(b3, e4, f4, i4, k4, m4, n3);
          while (0);
          l3 = La2;
          return;
        }
        function Zd(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          var c3 = 0;
          Vb(a3, b3 >= T2(0), 3147);
          c3 = b3 == T2(0);
          g2[a3 + 4 >> 2] = c3 ? T2(0) : b3;
          return;
        }
        function _d(b3, d4, e4, f4) {
          b3 = b3 | 0;
          d4 = T2(d4);
          e4 = T2(e4);
          f4 = f4 | 0;
          var h3 = ib, i4 = ib, j4 = 0, k4 = 0, l4 = 0;
          c2[2278] = (c2[2278] | 0) + 1;
          $d(b3);
          if (!(ae(b3, 2, d4) | 0)) {
            h3 = T2(be(b3 + 380 | 0, d4));
            if (!(h3 >= T2(0))) {
              l4 = ((Sb(d4) | 0) ^ 1) & 1;
              h3 = d4;
            } else
              l4 = 2;
          } else {
            h3 = T2(be(c2[b3 + 992 >> 2] | 0, d4));
            l4 = 1;
            h3 = T2(h3 + T2(Ud(b3, 2, d4)));
          }
          if (!(ae(b3, 0, e4) | 0)) {
            i4 = T2(be(b3 + 388 | 0, e4));
            if (!(i4 >= T2(0))) {
              k4 = ((Sb(e4) | 0) ^ 1) & 1;
              i4 = e4;
            } else
              k4 = 2;
          } else {
            i4 = T2(be(c2[b3 + 996 >> 2] | 0, e4));
            k4 = 1;
            i4 = T2(i4 + T2(Ud(b3, 0, d4)));
          }
          j4 = b3 + 976 | 0;
          if (Td(b3, h3, i4, f4, l4, k4, d4, e4, 1, 3189, c2[j4 >> 2] | 0) | 0 ? (ce(b3, c2[b3 + 496 >> 2] | 0, d4, e4, d4), de(b3, T2(g2[(c2[j4 >> 2] | 0) + 4 >> 2]), T2(0), T2(0)), a2[11696] | 0) : 0)
            Md(b3, 7);
          return;
        }
        function $d(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          i4 = l3;
          l3 = l3 + 32 | 0;
          h3 = i4 + 24 | 0;
          g3 = i4 + 16 | 0;
          e4 = i4 + 8 | 0;
          f4 = i4;
          d4 = 0;
          do {
            b3 = a3 + 380 + (d4 << 3) | 0;
            if (!((c2[a3 + 380 + (d4 << 3) + 4 >> 2] | 0) != 0 ? (j4 = b3, k4 = c2[j4 + 4 >> 2] | 0, m4 = e4, c2[m4 >> 2] = c2[j4 >> 2], c2[m4 + 4 >> 2] = k4, m4 = a3 + 364 + (d4 << 3) | 0, k4 = c2[m4 + 4 >> 2] | 0, j4 = f4, c2[j4 >> 2] = c2[m4 >> 2], c2[j4 + 4 >> 2] = k4, c2[g3 >> 2] = c2[e4 >> 2], c2[g3 + 4 >> 2] = c2[e4 + 4 >> 2], c2[h3 >> 2] = c2[f4 >> 2], c2[h3 + 4 >> 2] = c2[f4 + 4 >> 2], Kd(g3, h3) | 0) : 0))
              b3 = a3 + 348 + (d4 << 3) | 0;
            c2[a3 + 992 + (d4 << 2) >> 2] = b3;
            d4 = d4 + 1 | 0;
          } while ((d4 | 0) != 2);
          l3 = i4;
          return;
        }
        function ae(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = T2(d4);
          var e4 = 0;
          a3 = c2[a3 + 992 + (c2[976 + (b3 << 2) >> 2] << 2) >> 2] | 0;
          switch (c2[a3 + 4 >> 2] | 0) {
            case 0:
            case 3: {
              a3 = 0;
              break;
            }
            case 1: {
              if (T2(g2[a3 >> 2]) < T2(0))
                a3 = 0;
              else
                e4 = 5;
              break;
            }
            case 2: {
              if (T2(g2[a3 >> 2]) < T2(0))
                a3 = 0;
              else
                a3 = (Sb(d4) | 0) ^ 1;
              break;
            }
            default:
              e4 = 5;
          }
          if ((e4 | 0) == 5)
            a3 = 1;
          return a3 | 0;
        }
        function be(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          switch (c2[a3 + 4 >> 2] | 0) {
            case 2: {
              b3 = T2(T2(T2(g2[a3 >> 2]) * b3) / T2(100));
              break;
            }
            case 1: {
              b3 = T2(g2[a3 >> 2]);
              break;
            }
            default:
              b3 = T2(t2);
          }
          return T2(b3);
        }
        function ce(a3, b3, d4, e4, f4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = T2(d4);
          e4 = T2(e4);
          f4 = T2(f4);
          var h3 = 0, i4 = ib;
          b3 = c2[a3 + 944 >> 2] | 0 ? b3 : 1;
          h3 = re(c2[a3 + 4 >> 2] | 0, b3) | 0;
          b3 = ze(h3, b3) | 0;
          d4 = T2($e(a3, h3, d4));
          e4 = T2($e(a3, b3, e4));
          i4 = T2(d4 + T2(me(a3, h3, f4)));
          g2[a3 + 400 + (c2[1040 + (h3 << 2) >> 2] << 2) >> 2] = i4;
          d4 = T2(d4 + T2(ne(a3, h3, f4)));
          g2[a3 + 400 + (c2[1e3 + (h3 << 2) >> 2] << 2) >> 2] = d4;
          d4 = T2(e4 + T2(me(a3, b3, f4)));
          g2[a3 + 400 + (c2[1040 + (b3 << 2) >> 2] << 2) >> 2] = d4;
          f4 = T2(e4 + T2(ne(a3, b3, f4)));
          g2[a3 + 400 + (c2[1e3 + (b3 << 2) >> 2] << 2) >> 2] = f4;
          return;
        }
        function de(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = T2(b3);
          d4 = T2(d4);
          e4 = T2(e4);
          var f4 = 0, h3 = 0, i4 = ib, j4 = ib, k4 = 0, l4 = 0, m4 = ib, n3 = 0, o3 = ib, p4 = ib, q3 = ib, r3 = ib;
          if (!(b3 == T2(0))) {
            f4 = a3 + 400 | 0;
            r3 = T2(g2[f4 >> 2]);
            h3 = a3 + 404 | 0;
            q3 = T2(g2[h3 >> 2]);
            n3 = a3 + 416 | 0;
            p4 = T2(g2[n3 >> 2]);
            l4 = a3 + 420 | 0;
            i4 = T2(g2[l4 >> 2]);
            o3 = T2(r3 + d4);
            m4 = T2(q3 + e4);
            e4 = T2(o3 + p4);
            j4 = T2(m4 + i4);
            k4 = (c2[a3 + 988 >> 2] | 0) == 1;
            g2[f4 >> 2] = T2(Od(r3, b3, 0, k4));
            g2[h3 >> 2] = T2(Od(q3, b3, 0, k4));
            d4 = T2(gC(T2(p4 * b3), T2(1)));
            if (Ld(d4, T2(0)) | 0)
              h3 = 0;
            else
              h3 = (Ld(d4, T2(1)) | 0) ^ 1;
            d4 = T2(gC(T2(i4 * b3), T2(1)));
            if (Ld(d4, T2(0)) | 0)
              f4 = 0;
            else
              f4 = (Ld(d4, T2(1)) | 0) ^ 1;
            r3 = T2(Od(e4, b3, k4 & h3, k4 & (h3 ^ 1)));
            g2[n3 >> 2] = T2(r3 - T2(Od(o3, b3, 0, k4)));
            r3 = T2(Od(j4, b3, k4 & f4, k4 & (f4 ^ 1)));
            g2[l4 >> 2] = T2(r3 - T2(Od(m4, b3, 0, k4)));
            h3 = (c2[a3 + 952 >> 2] | 0) - (c2[a3 + 948 >> 2] | 0) >> 2;
            if (h3 | 0) {
              f4 = 0;
              do {
                de(ac(a3, f4) | 0, b3, o3, m4);
                f4 = f4 + 1 | 0;
              } while ((f4 | 0) != (h3 | 0));
            }
          }
          return;
        }
        function ee(a3, b3, d4, e4, f4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          switch (d4 | 0) {
            case 5:
            case 0: {
              a3 = CB(c2[489] | 0, e4, f4) | 0;
              break;
            }
            default:
              a3 = iC(e4, f4) | 0;
          }
          return a3 | 0;
        }
        function fe(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0;
          f4 = l3;
          l3 = l3 + 16 | 0;
          g3 = f4;
          c2[g3 >> 2] = e4;
          ge(a3, 0, b3, d4, g3);
          l3 = f4;
          return;
        }
        function ge(a3, b3, d4, e4, f4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          a3 = a3 | 0 ? a3 : 956;
          Bb[c2[a3 + 8 >> 2] & 1](a3, b3, d4, e4, f4) | 0;
          if ((d4 | 0) == 5)
            Ta();
          else
            return;
        }
        function he(b3, c3, d4) {
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          a2[b3 + c3 >> 0] = d4 & 1;
          return;
        }
        function ie(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          c2[a3 >> 2] = 0;
          c2[a3 + 4 >> 2] = 0;
          c2[a3 + 8 >> 2] = 0;
          d4 = b3 + 4 | 0;
          e4 = (c2[d4 >> 2] | 0) - (c2[b3 >> 2] | 0) >> 2;
          if (e4 | 0) {
            je(a3, e4);
            ke(a3, c2[b3 >> 2] | 0, c2[d4 >> 2] | 0, e4);
          }
          return;
        }
        function je(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          if ((le(a3) | 0) >>> 0 < b3 >>> 0)
            jC(a3);
          if (b3 >>> 0 > 1073741823)
            Ta();
          else {
            d4 = qC(b3 << 2) | 0;
            c2[a3 + 4 >> 2] = d4;
            c2[a3 >> 2] = d4;
            c2[a3 + 8 >> 2] = d4 + (b3 << 2);
            return;
          }
        }
        function ke(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          e4 = a3 + 4 | 0;
          a3 = d4 - b3 | 0;
          if ((a3 | 0) > 0) {
            BC(c2[e4 >> 2] | 0, b3 | 0, a3 | 0) | 0;
            c2[e4 >> 2] = (c2[e4 >> 2] | 0) + (a3 >>> 2 << 2);
          }
          return;
        }
        function le(a3) {
          a3 = a3 | 0;
          return 1073741823;
        }
        function me(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = T2(d4);
          if (oe(b3) | 0 ? (c2[a3 + 96 >> 2] | 0) != 0 : 0)
            a3 = a3 + 92 | 0;
          else
            a3 = Tb(a3 + 60 | 0, c2[1040 + (b3 << 2) >> 2] | 0, 992) | 0;
          return T2(pe(a3, d4));
        }
        function ne(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = T2(d4);
          if (oe(b3) | 0 ? (c2[a3 + 104 >> 2] | 0) != 0 : 0)
            a3 = a3 + 100 | 0;
          else
            a3 = Tb(a3 + 60 | 0, c2[1e3 + (b3 << 2) >> 2] | 0, 992) | 0;
          return T2(pe(a3, d4));
        }
        function oe(a3) {
          a3 = a3 | 0;
          return (a3 | 1 | 0) == 3 | 0;
        }
        function pe(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          if ((c2[a3 + 4 >> 2] | 0) == 3)
            b3 = T2(0);
          else
            b3 = T2(be(a3, b3));
          return T2(b3);
        }
        function qe(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          a3 = c2[a3 >> 2] | 0;
          return ((a3 | 0) == 0 ? (b3 | 0) > 1 ? b3 : 1 : a3) | 0;
        }
        function re(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var c3 = 0;
          a:
            do
              if ((b3 | 0) == 2) {
                switch (a3 | 0) {
                  case 2: {
                    a3 = 3;
                    break a;
                  }
                  case 3:
                    break;
                  default: {
                    c3 = 4;
                    break a;
                  }
                }
                a3 = 2;
              } else
                c3 = 4;
            while (0);
          return a3 | 0;
        }
        function se(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = ib;
          if (!((oe(b3) | 0 ? (c2[a3 + 312 >> 2] | 0) != 0 : 0) ? (d4 = T2(g2[a3 + 308 >> 2]), d4 >= T2(0)) : 0))
            d4 = T2(cC(T2(g2[(Tb(a3 + 276 | 0, c2[1040 + (b3 << 2) >> 2] | 0, 992) | 0) >> 2]), T2(0)));
          return T2(d4);
        }
        function te(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = ib;
          if (!((oe(b3) | 0 ? (c2[a3 + 320 >> 2] | 0) != 0 : 0) ? (d4 = T2(g2[a3 + 316 >> 2]), d4 >= T2(0)) : 0))
            d4 = T2(cC(T2(g2[(Tb(a3 + 276 | 0, c2[1e3 + (b3 << 2) >> 2] | 0, 992) | 0) >> 2]), T2(0)));
          return T2(d4);
        }
        function ue(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = T2(d4);
          var e4 = ib;
          if (!((oe(b3) | 0 ? (c2[a3 + 240 >> 2] | 0) != 0 : 0) ? (e4 = T2(be(a3 + 236 | 0, d4)), e4 >= T2(0)) : 0))
            e4 = T2(cC(T2(be(Tb(a3 + 204 | 0, c2[1040 + (b3 << 2) >> 2] | 0, 992) | 0, d4)), T2(0)));
          return T2(e4);
        }
        function ve(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = T2(d4);
          var e4 = ib;
          if (!((oe(b3) | 0 ? (c2[a3 + 248 >> 2] | 0) != 0 : 0) ? (e4 = T2(be(a3 + 244 | 0, d4)), e4 >= T2(0)) : 0))
            e4 = T2(cC(T2(be(Tb(a3 + 204 | 0, c2[1e3 + (b3 << 2) >> 2] | 0, 992) | 0, d4)), T2(0)));
          return T2(e4);
        }
        function we(a3, b3, d4, e4, f4, h3, i4) {
          a3 = a3 | 0;
          b3 = T2(b3);
          d4 = T2(d4);
          e4 = e4 | 0;
          f4 = f4 | 0;
          h3 = T2(h3);
          i4 = T2(i4);
          var j4 = ib, k4 = ib, m4 = ib, n3 = ib, o3 = ib, p4 = ib, q3 = 0, r3 = 0, s3 = 0;
          s3 = l3;
          l3 = l3 + 16 | 0;
          q3 = s3;
          r3 = a3 + 964 | 0;
          ec(a3, (c2[r3 >> 2] | 0) != 0, 3519);
          j4 = T2(Ce(a3, 2, b3));
          k4 = T2(Ce(a3, 0, b3));
          m4 = T2(Ud(a3, 2, b3));
          n3 = T2(Ud(a3, 0, b3));
          if (Sb(b3) | 0)
            o3 = b3;
          else
            o3 = T2(cC(T2(0), T2(T2(b3 - m4) - j4)));
          if (Sb(d4) | 0)
            p4 = d4;
          else
            p4 = T2(cC(T2(0), T2(T2(d4 - n3) - k4)));
          if ((e4 | 0) == 1 & (f4 | 0) == 1) {
            g2[a3 + 908 >> 2] = T2(Ie(a3, 2, T2(b3 - m4), h3, h3));
            b3 = T2(Ie(a3, 0, T2(d4 - n3), i4, h3));
          } else {
            Db[c2[r3 >> 2] & 1](q3, a3, o3, e4, p4, f4);
            o3 = T2(j4 + T2(g2[q3 >> 2]));
            p4 = T2(b3 - m4);
            g2[a3 + 908 >> 2] = T2(Ie(a3, 2, (e4 | 2 | 0) == 2 ? o3 : p4, h3, h3));
            p4 = T2(k4 + T2(g2[q3 + 4 >> 2]));
            b3 = T2(d4 - n3);
            b3 = T2(Ie(a3, 0, (f4 | 2 | 0) == 2 ? p4 : b3, i4, h3));
          }
          g2[a3 + 912 >> 2] = b3;
          l3 = s3;
          return;
        }
        function xe(a3, b3, c3, d4, e4, f4, h3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          c3 = T2(c3);
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = T2(f4);
          h3 = T2(h3);
          var i4 = ib, j4 = ib, k4 = ib, l4 = ib;
          k4 = T2(Ce(a3, 2, f4));
          i4 = T2(Ce(a3, 0, f4));
          l4 = T2(Ud(a3, 2, f4));
          j4 = T2(Ud(a3, 0, f4));
          b3 = T2(b3 - l4);
          g2[a3 + 908 >> 2] = T2(Ie(a3, 2, (d4 | 2 | 0) == 2 ? k4 : b3, f4, f4));
          c3 = T2(c3 - j4);
          g2[a3 + 912 >> 2] = T2(Ie(a3, 0, (e4 | 2 | 0) == 2 ? i4 : c3, h3, f4));
          return;
        }
        function ye(a3, b3, c3, d4, e4, f4, h3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          c3 = T2(c3);
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = T2(f4);
          h3 = T2(h3);
          var i4 = 0, j4 = ib, k4 = ib;
          i4 = (d4 | 0) == 2;
          if ((!(b3 <= T2(0) & i4) ? !(c3 <= T2(0) & (e4 | 0) == 2) : 0) ? !((d4 | 0) == 1 & (e4 | 0) == 1) : 0)
            a3 = 0;
          else {
            j4 = T2(Ud(a3, 0, f4));
            k4 = T2(Ud(a3, 2, f4));
            i4 = b3 < T2(0) & i4 | (Sb(b3) | 0);
            b3 = T2(b3 - k4);
            g2[a3 + 908 >> 2] = T2(Ie(a3, 2, i4 ? T2(0) : b3, f4, f4));
            b3 = T2(c3 - j4);
            i4 = c3 < T2(0) & (e4 | 0) == 2 | (Sb(c3) | 0);
            g2[a3 + 912 >> 2] = T2(Ie(a3, 0, i4 ? T2(0) : b3, h3, f4));
            a3 = 1;
          }
          return a3 | 0;
        }
        function ze(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          if (We(a3) | 0)
            a3 = re(2, b3) | 0;
          else
            a3 = 0;
          return a3 | 0;
        }
        function Ae(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = T2(c3);
          c3 = T2(ue(a3, b3, c3));
          return T2(c3 + T2(se(a3, b3)));
        }
        function Be(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = T2(c3);
          c3 = T2(ve(a3, b3, c3));
          return T2(c3 + T2(te(a3, b3)));
        }
        function Ce(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = T2(c3);
          var d4 = ib;
          d4 = T2(Ae(a3, b3, c3));
          return T2(d4 + T2(Be(a3, b3, c3)));
        }
        function De(a3) {
          a3 = a3 | 0;
          if (!(c2[a3 + 24 >> 2] | 0)) {
            if (T2(Ee(a3)) != T2(0))
              a3 = 1;
            else
              a3 = T2(Fe(a3)) != T2(0);
          } else
            a3 = 0;
          return a3 | 0;
        }
        function Ee(a3) {
          a3 = a3 | 0;
          var b3 = ib;
          if (c2[a3 + 944 >> 2] | 0) {
            b3 = T2(g2[a3 + 44 >> 2]);
            if (Sb(b3) | 0) {
              b3 = T2(g2[a3 + 40 >> 2]);
              a3 = b3 > T2(0) & ((Sb(b3) | 0) ^ 1);
              return T2(a3 ? b3 : T2(0));
            }
          } else
            b3 = T2(0);
          return T2(b3);
        }
        function Fe(b3) {
          b3 = b3 | 0;
          var d4 = ib, e4 = 0, f4 = ib;
          do
            if (c2[b3 + 944 >> 2] | 0) {
              d4 = T2(g2[b3 + 48 >> 2]);
              if (Sb(d4) | 0) {
                e4 = a2[(c2[b3 + 976 >> 2] | 0) + 2 >> 0] | 0;
                if (e4 << 24 >> 24 == 0 ? (f4 = T2(g2[b3 + 40 >> 2]), f4 < T2(0) & ((Sb(f4) | 0) ^ 1)) : 0) {
                  d4 = T2(-f4);
                  break;
                }
                d4 = e4 << 24 >> 24 ? T2(1) : T2(0);
              }
            } else
              d4 = T2(0);
          while (0);
          return T2(d4);
        }
        function Ge(b3) {
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          yC(b3 + 400 | 0, 0, 540) | 0;
          a2[b3 + 985 >> 0] = 1;
          lc(b3);
          e4 = $b(b3) | 0;
          if (e4 | 0) {
            d4 = b3 + 948 | 0;
            b3 = 0;
            do {
              Ge(c2[(c2[d4 >> 2] | 0) + (b3 << 2) >> 2] | 0);
              b3 = b3 + 1 | 0;
            } while ((b3 | 0) != (e4 | 0));
          }
          return;
        }
        function He(a3, b3, d4, e4, f4, h3, i4, j4, k4, m4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = T2(d4);
          e4 = e4 | 0;
          f4 = T2(f4);
          h3 = T2(h3);
          i4 = T2(i4);
          j4 = j4 | 0;
          k4 = k4 | 0;
          m4 = m4 | 0;
          var n3 = 0, o3 = ib, p4 = 0, q3 = 0, r3 = ib, s3 = ib, u4 = 0, v4 = ib, w3 = 0, x4 = ib, y3 = 0, z3 = 0, A3 = 0, B3 = 0, C3 = 0, D3 = 0, E3 = 0, F3 = 0, G3 = 0, H3 = 0;
          G3 = l3;
          l3 = l3 + 16 | 0;
          A3 = G3 + 12 | 0;
          B3 = G3 + 8 | 0;
          C3 = G3 + 4 | 0;
          D3 = G3;
          F3 = re(c2[a3 + 4 >> 2] | 0, k4) | 0;
          y3 = oe(F3) | 0;
          o3 = T2(be(Xe(b3) | 0, y3 ? h3 : i4));
          z3 = ae(b3, 2, h3) | 0;
          E3 = ae(b3, 0, i4) | 0;
          do
            if (!(Sb(o3) | 0) ? !(Sb(y3 ? d4 : f4) | 0) : 0) {
              n3 = b3 + 504 | 0;
              if (!(Sb(T2(g2[n3 >> 2])) | 0)) {
                if (!(Ye(c2[b3 + 976 >> 2] | 0, 0) | 0))
                  break;
                if ((c2[b3 + 500 >> 2] | 0) == (c2[2278] | 0))
                  break;
              }
              g2[n3 >> 2] = T2(cC(o3, T2(Ce(b3, F3, h3))));
            } else
              p4 = 7;
          while (0);
          do
            if ((p4 | 0) == 7) {
              w3 = y3 ^ 1;
              if (!(w3 | z3 ^ 1)) {
                i4 = T2(be(c2[b3 + 992 >> 2] | 0, h3));
                g2[b3 + 504 >> 2] = T2(cC(i4, T2(Ce(b3, 2, h3))));
                break;
              }
              if (!(y3 | E3 ^ 1)) {
                i4 = T2(be(c2[b3 + 996 >> 2] | 0, i4));
                g2[b3 + 504 >> 2] = T2(cC(i4, T2(Ce(b3, 0, h3))));
                break;
              }
              g2[A3 >> 2] = T2(t2);
              g2[B3 >> 2] = T2(t2);
              c2[C3 >> 2] = 0;
              c2[D3 >> 2] = 0;
              v4 = T2(Ud(b3, 2, h3));
              x4 = T2(Ud(b3, 0, h3));
              if (z3) {
                r3 = T2(v4 + T2(be(c2[b3 + 992 >> 2] | 0, h3)));
                g2[A3 >> 2] = r3;
                c2[C3 >> 2] = 1;
                q3 = 1;
              } else {
                q3 = 0;
                r3 = T2(t2);
              }
              if (E3) {
                o3 = T2(x4 + T2(be(c2[b3 + 996 >> 2] | 0, i4)));
                g2[B3 >> 2] = o3;
                c2[D3 >> 2] = 1;
                n3 = 1;
              } else {
                n3 = 0;
                o3 = T2(t2);
              }
              p4 = c2[a3 + 32 >> 2] | 0;
              if (!(y3 & (p4 | 0) == 2)) {
                if (Sb(r3) | 0 ? !(Sb(d4) | 0) : 0) {
                  g2[A3 >> 2] = d4;
                  c2[C3 >> 2] = 2;
                  q3 = 2;
                  r3 = d4;
                }
              } else
                p4 = 2;
              if ((!((p4 | 0) == 2 & w3) ? Sb(o3) | 0 : 0) ? !(Sb(f4) | 0) : 0) {
                g2[B3 >> 2] = f4;
                c2[D3 >> 2] = 2;
                n3 = 2;
                o3 = f4;
              }
              s3 = T2(g2[b3 + 396 >> 2]);
              u4 = Sb(s3) | 0;
              do
                if (!u4) {
                  if ((q3 | 0) == 1 & w3) {
                    g2[B3 >> 2] = T2(T2(r3 - v4) / s3);
                    c2[D3 >> 2] = 1;
                    n3 = 1;
                    p4 = 1;
                    break;
                  }
                  if (y3 & (n3 | 0) == 1) {
                    g2[A3 >> 2] = T2(s3 * T2(o3 - x4));
                    c2[C3 >> 2] = 1;
                    n3 = 1;
                    p4 = 1;
                  } else
                    p4 = q3;
                } else
                  p4 = q3;
              while (0);
              H3 = Sb(d4) | 0;
              q3 = (Je(a3, b3) | 0) != 4;
              if (!(y3 | z3 | ((e4 | 0) != 1 | H3) | (q3 | (p4 | 0) == 1)) ? (g2[A3 >> 2] = d4, c2[C3 >> 2] = 1, !u4) : 0) {
                g2[B3 >> 2] = T2(T2(d4 - v4) / s3);
                c2[D3 >> 2] = 1;
                n3 = 1;
              }
              if (!(E3 | w3 | ((j4 | 0) != 1 | (Sb(f4) | 0)) | (q3 | (n3 | 0) == 1)) ? (g2[B3 >> 2] = f4, c2[D3 >> 2] = 1, !u4) : 0) {
                g2[A3 >> 2] = T2(s3 * T2(f4 - x4));
                c2[C3 >> 2] = 1;
              }
              Me(b3, 2, h3, h3, C3, A3);
              Me(b3, 0, i4, h3, D3, B3);
              d4 = T2(g2[A3 >> 2]);
              f4 = T2(g2[B3 >> 2]);
              Td(b3, d4, f4, k4, c2[C3 >> 2] | 0, c2[D3 >> 2] | 0, h3, i4, 0, 3565, m4) | 0;
              i4 = T2(g2[b3 + 908 + (c2[976 + (F3 << 2) >> 2] << 2) >> 2]);
              g2[b3 + 504 >> 2] = T2(cC(i4, T2(Ce(b3, F3, h3))));
            }
          while (0);
          c2[b3 + 500 >> 2] = c2[2278];
          l3 = G3;
          return;
        }
        function Ie(a3, b3, c3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = T2(c3);
          d4 = T2(d4);
          e4 = T2(e4);
          d4 = T2(Te(a3, b3, c3, d4));
          return T2(cC(d4, T2(Ce(a3, b3, e4))));
        }
        function Je(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          b3 = b3 + 20 | 0;
          b3 = c2[((c2[b3 >> 2] | 0) == 0 ? a3 + 16 | 0 : b3) >> 2] | 0;
          if ((b3 | 0) == 5 ? We(c2[a3 + 4 >> 2] | 0) | 0 : 0)
            b3 = 1;
          return b3 | 0;
        }
        function Ke(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          if (oe(b3) | 0 ? (c2[a3 + 96 >> 2] | 0) != 0 : 0)
            b3 = 4;
          else
            b3 = c2[1040 + (b3 << 2) >> 2] | 0;
          return a3 + 60 + (b3 << 3) | 0;
        }
        function Le(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          if (oe(b3) | 0 ? (c2[a3 + 104 >> 2] | 0) != 0 : 0)
            b3 = 5;
          else
            b3 = c2[1e3 + (b3 << 2) >> 2] | 0;
          return a3 + 60 + (b3 << 3) | 0;
        }
        function Me(a3, b3, d4, e4, f4, h3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = T2(d4);
          e4 = T2(e4);
          f4 = f4 | 0;
          h3 = h3 | 0;
          d4 = T2(be(a3 + 380 + (c2[976 + (b3 << 2) >> 2] << 3) | 0, d4));
          d4 = T2(d4 + T2(Ud(a3, b3, e4)));
          switch (c2[f4 >> 2] | 0) {
            case 2:
            case 1: {
              f4 = Sb(d4) | 0;
              e4 = T2(g2[h3 >> 2]);
              g2[h3 >> 2] = f4 | e4 < d4 ? e4 : d4;
              break;
            }
            case 0: {
              if (!(Sb(d4) | 0)) {
                c2[f4 >> 2] = 2;
                g2[h3 >> 2] = d4;
              }
              break;
            }
            default: {
            }
          }
          return;
        }
        function Ne(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          a3 = a3 + 132 | 0;
          if (oe(b3) | 0 ? (c2[(Tb(a3, 4, 948) | 0) + 4 >> 2] | 0) != 0 : 0)
            a3 = 1;
          else
            a3 = (c2[(Tb(a3, c2[1040 + (b3 << 2) >> 2] | 0, 948) | 0) + 4 >> 2] | 0) != 0;
          return a3 | 0;
        }
        function Oe(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = T2(d4);
          var e4 = 0, f4 = 0;
          a3 = a3 + 132 | 0;
          if (oe(b3) | 0 ? (e4 = Tb(a3, 4, 948) | 0, (c2[e4 + 4 >> 2] | 0) != 0) : 0)
            f4 = 4;
          else {
            e4 = Tb(a3, c2[1040 + (b3 << 2) >> 2] | 0, 948) | 0;
            if (!(c2[e4 + 4 >> 2] | 0))
              d4 = T2(0);
            else
              f4 = 4;
          }
          if ((f4 | 0) == 4)
            d4 = T2(be(e4, d4));
          return T2(d4);
        }
        function Pe(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = T2(d4);
          var e4 = ib;
          e4 = T2(g2[a3 + 908 + (c2[976 + (b3 << 2) >> 2] << 2) >> 2]);
          e4 = T2(e4 + T2(me(a3, b3, d4)));
          return T2(e4 + T2(ne(a3, b3, d4)));
        }
        function Qe(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          a:
            do
              if (!(We(c2[a3 + 4 >> 2] | 0) | 0)) {
                if ((c2[a3 + 16 >> 2] | 0) != 5) {
                  d4 = $b(a3) | 0;
                  if (!d4)
                    b3 = 0;
                  else {
                    b3 = 0;
                    while (1) {
                      e4 = ac(a3, b3) | 0;
                      if ((c2[e4 + 24 >> 2] | 0) == 0 ? (c2[e4 + 20 >> 2] | 0) == 5 : 0) {
                        b3 = 1;
                        break a;
                      }
                      b3 = b3 + 1 | 0;
                      if (b3 >>> 0 >= d4 >>> 0) {
                        b3 = 0;
                        break;
                      }
                    }
                  }
                } else
                  b3 = 1;
              } else
                b3 = 0;
            while (0);
          return b3 | 0;
        }
        function Re(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = ib;
          d4 = T2(g2[a3 + 908 + (c2[976 + (b3 << 2) >> 2] << 2) >> 2]);
          return d4 >= T2(0) & ((Sb(d4) | 0) ^ 1) | 0;
        }
        function Se(a3) {
          a3 = a3 | 0;
          var b3 = ib, d4 = 0, e4 = 0, f4 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = ib;
          d4 = c2[a3 + 968 >> 2] | 0;
          if (!d4) {
            h3 = $b(a3) | 0;
            do
              if (h3 | 0) {
                d4 = 0;
                f4 = 0;
                while (1) {
                  e4 = ac(a3, f4) | 0;
                  if (c2[e4 + 940 >> 2] | 0) {
                    i4 = 8;
                    break;
                  }
                  if ((c2[e4 + 24 >> 2] | 0) != 1) {
                    j4 = (Je(a3, e4) | 0) == 5;
                    if (j4) {
                      d4 = e4;
                      break;
                    } else
                      d4 = (d4 | 0) == 0 ? e4 : d4;
                  }
                  f4 = f4 + 1 | 0;
                  if (f4 >>> 0 >= h3 >>> 0) {
                    i4 = 8;
                    break;
                  }
                }
                if ((i4 | 0) == 8) {
                  if (!d4)
                    break;
                }
                b3 = T2(Se(d4));
                return T2(b3 + T2(g2[d4 + 404 >> 2]));
              }
            while (0);
            b3 = T2(g2[a3 + 912 >> 2]);
          } else {
            k4 = T2(g2[a3 + 908 >> 2]);
            b3 = T2(g2[a3 + 912 >> 2]);
            b3 = T2(mb[d4 & 0](a3, k4, b3));
            ec(a3, (Sb(b3) | 0) ^ 1, 3573);
          }
          return T2(b3);
        }
        function Te(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = T2(c3);
          d4 = T2(d4);
          var e4 = ib, f4 = 0;
          if (!(We(b3) | 0)) {
            if (oe(b3) | 0) {
              b3 = 0;
              f4 = 3;
            } else {
              d4 = T2(t2);
              e4 = T2(t2);
            }
          } else {
            b3 = 1;
            f4 = 3;
          }
          if ((f4 | 0) == 3) {
            e4 = T2(be(a3 + 364 + (b3 << 3) | 0, d4));
            d4 = T2(be(a3 + 380 + (b3 << 3) | 0, d4));
          }
          f4 = d4 < c3 & (d4 >= T2(0) & ((Sb(d4) | 0) ^ 1));
          c3 = f4 ? d4 : c3;
          f4 = e4 >= T2(0) & ((Sb(e4) | 0) ^ 1) & c3 < e4;
          return T2(f4 ? e4 : c3);
        }
        function Ue(a3, b3, d4, e4, f4, h3, i4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = T2(d4);
          e4 = e4 | 0;
          f4 = T2(f4);
          h3 = h3 | 0;
          i4 = i4 | 0;
          var j4 = ib, k4 = ib, l4 = 0, m4 = 0, n3 = ib, o3 = ib, p4 = ib, q3 = 0, r3 = 0, s3 = 0, u4 = 0, v4 = ib, w3 = 0;
          s3 = re(c2[a3 + 4 >> 2] | 0, h3) | 0;
          q3 = ze(s3, h3) | 0;
          r3 = oe(s3) | 0;
          n3 = T2(Ud(b3, 2, d4));
          o3 = T2(Ud(b3, 0, d4));
          if (!(ae(b3, 2, d4) | 0)) {
            if (Ne(b3, 2) | 0 ? Ze(b3, 2) | 0 : 0) {
              j4 = T2(g2[a3 + 908 >> 2]);
              k4 = T2(se(a3, 2));
              k4 = T2(j4 - T2(k4 + T2(te(a3, 2))));
              j4 = T2(Oe(b3, 2, d4));
              j4 = T2(Ie(b3, 2, T2(k4 - T2(j4 + T2(_e(b3, 2, d4)))), d4, d4));
            } else
              j4 = T2(t2);
          } else
            j4 = T2(n3 + T2(be(c2[b3 + 992 >> 2] | 0, d4)));
          if (!(ae(b3, 0, f4) | 0)) {
            if (Ne(b3, 0) | 0 ? Ze(b3, 0) | 0 : 0) {
              k4 = T2(g2[a3 + 912 >> 2]);
              v4 = T2(se(a3, 0));
              v4 = T2(k4 - T2(v4 + T2(te(a3, 0))));
              k4 = T2(Oe(b3, 0, f4));
              k4 = T2(Ie(b3, 0, T2(v4 - T2(k4 + T2(_e(b3, 0, f4)))), f4, d4));
            } else
              k4 = T2(t2);
          } else
            k4 = T2(o3 + T2(be(c2[b3 + 996 >> 2] | 0, f4)));
          l4 = Sb(j4) | 0;
          m4 = Sb(k4) | 0;
          do
            if (l4 ^ m4 ? (p4 = T2(g2[b3 + 396 >> 2]), !(Sb(p4) | 0)) : 0)
              if (l4) {
                j4 = T2(n3 + T2(T2(k4 - o3) * p4));
                break;
              } else {
                v4 = T2(o3 + T2(T2(j4 - n3) / p4));
                k4 = m4 ? v4 : k4;
                break;
              }
          while (0);
          m4 = Sb(j4) | 0;
          l4 = Sb(k4) | 0;
          if (m4 | l4) {
            w3 = (m4 ^ 1) & 1;
            e4 = d4 > T2(0) & ((e4 | 0) != 0 & m4);
            j4 = r3 ? j4 : e4 ? d4 : j4;
            Td(b3, j4, k4, h3, r3 ? w3 : e4 ? 2 : w3, m4 & (l4 ^ 1) & 1, j4, k4, 0, 3623, i4) | 0;
            j4 = T2(g2[b3 + 908 >> 2]);
            j4 = T2(j4 + T2(Ud(b3, 2, d4)));
            k4 = T2(g2[b3 + 912 >> 2]);
            k4 = T2(k4 + T2(Ud(b3, 0, d4)));
          }
          Td(b3, j4, k4, h3, 1, 1, j4, k4, 1, 3635, i4) | 0;
          if (Ze(b3, s3) | 0 ? !(Ne(b3, s3) | 0) : 0) {
            w3 = c2[976 + (s3 << 2) >> 2] | 0;
            v4 = T2(g2[a3 + 908 + (w3 << 2) >> 2]);
            v4 = T2(v4 - T2(g2[b3 + 908 + (w3 << 2) >> 2]));
            v4 = T2(v4 - T2(te(a3, s3)));
            v4 = T2(v4 - T2(ne(b3, s3, d4)));
            v4 = T2(v4 - T2(_e(b3, s3, r3 ? d4 : f4)));
            g2[b3 + 400 + (c2[1040 + (s3 << 2) >> 2] << 2) >> 2] = v4;
          } else
            u4 = 21;
          do
            if ((u4 | 0) == 21) {
              if (!(Ne(b3, s3) | 0) ? (c2[a3 + 8 >> 2] | 0) == 1 : 0) {
                w3 = c2[976 + (s3 << 2) >> 2] | 0;
                v4 = T2(g2[a3 + 908 + (w3 << 2) >> 2]);
                v4 = T2(T2(v4 - T2(g2[b3 + 908 + (w3 << 2) >> 2])) * T2(0.5));
                g2[b3 + 400 + (c2[1040 + (s3 << 2) >> 2] << 2) >> 2] = v4;
                break;
              }
              if (!(Ne(b3, s3) | 0) ? (c2[a3 + 8 >> 2] | 0) == 2 : 0) {
                w3 = c2[976 + (s3 << 2) >> 2] | 0;
                v4 = T2(g2[a3 + 908 + (w3 << 2) >> 2]);
                v4 = T2(v4 - T2(g2[b3 + 908 + (w3 << 2) >> 2]));
                g2[b3 + 400 + (c2[1040 + (s3 << 2) >> 2] << 2) >> 2] = v4;
              }
            }
          while (0);
          if (Ze(b3, q3) | 0 ? !(Ne(b3, q3) | 0) : 0) {
            w3 = c2[976 + (q3 << 2) >> 2] | 0;
            v4 = T2(g2[a3 + 908 + (w3 << 2) >> 2]);
            v4 = T2(v4 - T2(g2[b3 + 908 + (w3 << 2) >> 2]));
            v4 = T2(v4 - T2(te(a3, q3)));
            v4 = T2(v4 - T2(ne(b3, q3, d4)));
            v4 = T2(v4 - T2(_e(b3, q3, r3 ? f4 : d4)));
            g2[b3 + 400 + (c2[1040 + (q3 << 2) >> 2] << 2) >> 2] = v4;
          } else
            u4 = 30;
          do
            if ((u4 | 0) == 30 ? !(Ne(b3, q3) | 0) : 0) {
              if ((Je(a3, b3) | 0) == 2) {
                w3 = c2[976 + (q3 << 2) >> 2] | 0;
                v4 = T2(g2[a3 + 908 + (w3 << 2) >> 2]);
                v4 = T2(T2(v4 - T2(g2[b3 + 908 + (w3 << 2) >> 2])) * T2(0.5));
                g2[b3 + 400 + (c2[1040 + (q3 << 2) >> 2] << 2) >> 2] = v4;
                break;
              }
              w3 = (Je(a3, b3) | 0) == 3;
              if (w3 ^ (c2[a3 + 28 >> 2] | 0) == 2) {
                w3 = c2[976 + (q3 << 2) >> 2] | 0;
                v4 = T2(g2[a3 + 908 + (w3 << 2) >> 2]);
                v4 = T2(v4 - T2(g2[b3 + 908 + (w3 << 2) >> 2]));
                g2[b3 + 400 + (c2[1040 + (q3 << 2) >> 2] << 2) >> 2] = v4;
              }
            }
          while (0);
          return;
        }
        function Ve(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = ib, f4 = 0;
          f4 = c2[976 + (d4 << 2) >> 2] | 0;
          e4 = T2(g2[b3 + 908 + (f4 << 2) >> 2]);
          e4 = T2(T2(g2[a3 + 908 + (f4 << 2) >> 2]) - e4);
          e4 = T2(e4 - T2(g2[b3 + 400 + (c2[1040 + (d4 << 2) >> 2] << 2) >> 2]));
          g2[b3 + 400 + (c2[1e3 + (d4 << 2) >> 2] << 2) >> 2] = e4;
          return;
        }
        function We(a3) {
          a3 = a3 | 0;
          return (a3 | 1 | 0) == 1 | 0;
        }
        function Xe(b3) {
          b3 = b3 | 0;
          var d4 = ib;
          switch (c2[b3 + 56 >> 2] | 0) {
            case 0:
            case 3: {
              d4 = T2(g2[b3 + 40 >> 2]);
              if (d4 > T2(0) & ((Sb(d4) | 0) ^ 1))
                b3 = a2[(c2[b3 + 976 >> 2] | 0) + 2 >> 0] | 0 ? 1056 : 992;
              else
                b3 = 1056;
              break;
            }
            default:
              b3 = b3 + 52 | 0;
          }
          return b3 | 0;
        }
        function Ye(b3, c3) {
          b3 = b3 | 0;
          c3 = c3 | 0;
          return (a2[b3 + c3 >> 0] | 0) != 0 | 0;
        }
        function Ze(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          a3 = a3 + 132 | 0;
          if (oe(b3) | 0 ? (c2[(Tb(a3, 5, 948) | 0) + 4 >> 2] | 0) != 0 : 0)
            a3 = 1;
          else
            a3 = (c2[(Tb(a3, c2[1e3 + (b3 << 2) >> 2] | 0, 948) | 0) + 4 >> 2] | 0) != 0;
          return a3 | 0;
        }
        function _e(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = T2(d4);
          var e4 = 0, f4 = 0;
          a3 = a3 + 132 | 0;
          if (oe(b3) | 0 ? (e4 = Tb(a3, 5, 948) | 0, (c2[e4 + 4 >> 2] | 0) != 0) : 0)
            f4 = 4;
          else {
            e4 = Tb(a3, c2[1e3 + (b3 << 2) >> 2] | 0, 948) | 0;
            if (!(c2[e4 + 4 >> 2] | 0))
              d4 = T2(0);
            else
              f4 = 4;
          }
          if ((f4 | 0) == 4)
            d4 = T2(be(e4, d4));
          return T2(d4);
        }
        function $e(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = T2(c3);
          if (Ne(a3, b3) | 0)
            c3 = T2(Oe(a3, b3, c3));
          else
            c3 = T2(-T2(_e(a3, b3, c3)));
          return T2(c3);
        }
        function af(a3) {
          a3 = T2(a3);
          return (g2[j3 >> 2] = a3, c2[j3 >> 2] | 0) | 0;
        }
        function bf(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 1073741823)
                Ta();
              else {
                f4 = qC(b3 << 2) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 << 2) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 << 2);
          return;
        }
        function cf(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (0 - (f4 >> 2) << 2) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function df(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~((e4 + -4 - b3 | 0) >>> 2) << 2);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function ef(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          h3 = a3 + 4 | 0;
          i4 = c2[h3 >> 2] | 0;
          f4 = i4 - e4 | 0;
          g3 = f4 >> 2;
          a3 = b3 + (g3 << 2) | 0;
          if (a3 >>> 0 < d4 >>> 0) {
            e4 = i4;
            do {
              c2[e4 >> 2] = c2[a3 >> 2];
              a3 = a3 + 4 | 0;
              e4 = (c2[h3 >> 2] | 0) + 4 | 0;
              c2[h3 >> 2] = e4;
            } while (a3 >>> 0 < d4 >>> 0);
          }
          if (g3 | 0)
            GC(i4 + (0 - g3 << 2) | 0, b3 | 0, f4 | 0) | 0;
          return;
        }
        function ff(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          i4 = b3 + 4 | 0;
          j4 = c2[i4 >> 2] | 0;
          f4 = c2[a3 >> 2] | 0;
          h3 = d4;
          g3 = h3 - f4 | 0;
          e4 = j4 + (0 - (g3 >> 2) << 2) | 0;
          c2[i4 >> 2] = e4;
          if ((g3 | 0) > 0)
            BC(e4 | 0, f4 | 0, g3 | 0) | 0;
          f4 = a3 + 4 | 0;
          g3 = b3 + 8 | 0;
          e4 = (c2[f4 >> 2] | 0) - h3 | 0;
          if ((e4 | 0) > 0) {
            BC(c2[g3 >> 2] | 0, d4 | 0, e4 | 0) | 0;
            c2[g3 >> 2] = (c2[g3 >> 2] | 0) + (e4 >>> 2 << 2);
          }
          h3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = c2[i4 >> 2];
          c2[i4 >> 2] = h3;
          h3 = c2[f4 >> 2] | 0;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = h3;
          h3 = a3 + 8 | 0;
          d4 = b3 + 12 | 0;
          a3 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[d4 >> 2];
          c2[d4 >> 2] = a3;
          c2[b3 >> 2] = c2[i4 >> 2];
          return j4 | 0;
        }
        function gf(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          h3 = c2[b3 >> 2] | 0;
          g3 = c2[d4 >> 2] | 0;
          if ((h3 | 0) != (g3 | 0)) {
            f4 = a3 + 8 | 0;
            d4 = ((g3 + -4 - h3 | 0) >>> 2) + 1 | 0;
            a3 = h3;
            e4 = c2[f4 >> 2] | 0;
            do {
              c2[e4 >> 2] = c2[a3 >> 2];
              e4 = (c2[f4 >> 2] | 0) + 4 | 0;
              c2[f4 >> 2] = e4;
              a3 = a3 + 4 | 0;
            } while ((a3 | 0) != (g3 | 0));
            c2[b3 >> 2] = h3 + (d4 << 2);
          }
          return;
        }
        function hf() {
          Qb();
          return;
        }
        function jf() {
          var a3 = 0;
          a3 = qC(4) | 0;
          kf(a3);
          return a3 | 0;
        }
        function kf(a3) {
          a3 = a3 | 0;
          c2[a3 >> 2] = gc() | 0;
          return;
        }
        function lf(a3) {
          a3 = a3 | 0;
          if (a3 | 0) {
            mf(a3);
            sC(a3);
          }
          return;
        }
        function mf(a3) {
          a3 = a3 | 0;
          ic(c2[a3 >> 2] | 0);
          return;
        }
        function nf(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          he(c2[a3 >> 2] | 0, b3, d4);
          return;
        }
        function of(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          Zd(c2[a3 >> 2] | 0, b3);
          return;
        }
        function pf(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return Ye(c2[a3 >> 2] | 0, b3) | 0;
        }
        function qf() {
          var a3 = 0;
          a3 = qC(8) | 0;
          rf(a3, 0);
          return a3 | 0;
        }
        function rf(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          if (!b3)
            b3 = Wb() | 0;
          else
            b3 = Ub(c2[b3 >> 2] | 0) | 0;
          c2[a3 >> 2] = b3;
          c2[a3 + 4 >> 2] = 0;
          vc(b3, a3);
          return;
        }
        function sf(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = qC(8) | 0;
          rf(b3, a3);
          return b3 | 0;
        }
        function tf(a3) {
          a3 = a3 | 0;
          if (a3 | 0) {
            uf(a3);
            sC(a3);
          }
          return;
        }
        function uf(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          Zb(c2[a3 >> 2] | 0);
          b3 = a3 + 4 | 0;
          a3 = c2[b3 >> 2] | 0;
          c2[b3 >> 2] = 0;
          if (a3 | 0) {
            vf(a3);
            sC(a3);
          }
          return;
        }
        function vf(a3) {
          a3 = a3 | 0;
          wf(a3);
          return;
        }
        function wf(a3) {
          a3 = a3 | 0;
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            ab(a3 | 0);
          return;
        }
        function xf(a3) {
          a3 = a3 | 0;
          return wc(a3) | 0;
        }
        function yf(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0;
          d4 = a3 + 4 | 0;
          b3 = c2[d4 >> 2] | 0;
          c2[d4 >> 2] = 0;
          if (b3 | 0) {
            vf(b3);
            sC(b3);
          }
          dc(c2[a3 >> 2] | 0);
          return;
        }
        function zf(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          sc(c2[a3 >> 2] | 0, c2[b3 >> 2] | 0);
          return;
        }
        function Af(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          Hc(c2[a3 >> 2] | 0, b3);
          return;
        }
        function Bf(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = +d4;
          Vc(c2[a3 >> 2] | 0, b3, T2(d4));
          return;
        }
        function Cf(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = +d4;
          Wc(c2[a3 >> 2] | 0, b3, T2(d4));
          return;
        }
        function Df(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          Bc(c2[a3 >> 2] | 0, b3);
          return;
        }
        function Ef(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          Dc(c2[a3 >> 2] | 0, b3);
          return;
        }
        function Ff(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          Fc(c2[a3 >> 2] | 0, b3);
          return;
        }
        function Gf(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          xc(c2[a3 >> 2] | 0, b3);
          return;
        }
        function Hf(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          Jc(c2[a3 >> 2] | 0, b3);
          return;
        }
        function If(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          zc(c2[a3 >> 2] | 0, b3);
          return;
        }
        function Jf(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = +d4;
          Yc(c2[a3 >> 2] | 0, b3, T2(d4));
          return;
        }
        function Kf(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = +d4;
          Zc(c2[a3 >> 2] | 0, b3, T2(d4));
          return;
        }
        function Lf(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          $c(c2[a3 >> 2] | 0, b3);
          return;
        }
        function Mf(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          Lc(c2[a3 >> 2] | 0, b3);
          return;
        }
        function Nf(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          Nc(c2[a3 >> 2] | 0, b3);
          return;
        }
        function Of(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          Pc(c2[a3 >> 2] | 0, T2(b3));
          return;
        }
        function Pf(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          Sc(c2[a3 >> 2] | 0, T2(b3));
          return;
        }
        function Qf(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          Tc(c2[a3 >> 2] | 0, T2(b3));
          return;
        }
        function Rf(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          Qc(c2[a3 >> 2] | 0, T2(b3));
          return;
        }
        function Sf(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          Rc(c2[a3 >> 2] | 0, T2(b3));
          return;
        }
        function Tf(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          fd(c2[a3 >> 2] | 0, T2(b3));
          return;
        }
        function Uf(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          gd(c2[a3 >> 2] | 0, T2(b3));
          return;
        }
        function Vf(a3) {
          a3 = a3 | 0;
          hd(c2[a3 >> 2] | 0);
          return;
        }
        function Wf(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          jd(c2[a3 >> 2] | 0, T2(b3));
          return;
        }
        function Xf(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          kd(c2[a3 >> 2] | 0, T2(b3));
          return;
        }
        function Yf(a3) {
          a3 = a3 | 0;
          ld(c2[a3 >> 2] | 0);
          return;
        }
        function Zf(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          nd(c2[a3 >> 2] | 0, T2(b3));
          return;
        }
        function _f(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          od(c2[a3 >> 2] | 0, T2(b3));
          return;
        }
        function $f(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          qd(c2[a3 >> 2] | 0, T2(b3));
          return;
        }
        function ag(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          rd(c2[a3 >> 2] | 0, T2(b3));
          return;
        }
        function bg(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          td(c2[a3 >> 2] | 0, T2(b3));
          return;
        }
        function cg(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          ud(c2[a3 >> 2] | 0, T2(b3));
          return;
        }
        function dg(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          wd(c2[a3 >> 2] | 0, T2(b3));
          return;
        }
        function eg(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          xd(c2[a3 >> 2] | 0, T2(b3));
          return;
        }
        function fg(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          zd(c2[a3 >> 2] | 0, T2(b3));
          return;
        }
        function gg(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = +d4;
          dd(c2[a3 >> 2] | 0, b3, T2(d4));
          return;
        }
        function hg(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = +d4;
          ad(c2[a3 >> 2] | 0, b3, T2(d4));
          return;
        }
        function ig(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = +d4;
          bd(c2[a3 >> 2] | 0, b3, T2(d4));
          return;
        }
        function jg(a3) {
          a3 = a3 | 0;
          return Ic(c2[a3 >> 2] | 0) | 0;
        }
        function kg(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4;
          Xc(f4, c2[b3 >> 2] | 0, d4);
          lg(a3, f4);
          l3 = e4;
          return;
        }
        function lg(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          mg(a3, c2[b3 + 4 >> 2] | 0, +T2(g2[b3 >> 2]));
          return;
        }
        function mg(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = +d4;
          c2[a3 >> 2] = b3;
          h2[a3 + 8 >> 3] = d4;
          return;
        }
        function ng(a3) {
          a3 = a3 | 0;
          return Cc(c2[a3 >> 2] | 0) | 0;
        }
        function og(a3) {
          a3 = a3 | 0;
          return Ec(c2[a3 >> 2] | 0) | 0;
        }
        function pg(a3) {
          a3 = a3 | 0;
          return Gc(c2[a3 >> 2] | 0) | 0;
        }
        function qg(a3) {
          a3 = a3 | 0;
          return yc(c2[a3 >> 2] | 0) | 0;
        }
        function rg(a3) {
          a3 = a3 | 0;
          return Kc(c2[a3 >> 2] | 0) | 0;
        }
        function sg(a3) {
          a3 = a3 | 0;
          return Ac(c2[a3 >> 2] | 0) | 0;
        }
        function tg(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4;
          _c(f4, c2[b3 >> 2] | 0, d4);
          lg(a3, f4);
          l3 = e4;
          return;
        }
        function ug(a3) {
          a3 = a3 | 0;
          return Mc(c2[a3 >> 2] | 0) | 0;
        }
        function vg(a3) {
          a3 = a3 | 0;
          return Oc(c2[a3 >> 2] | 0) | 0;
        }
        function wg(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          d4 = l3;
          l3 = l3 + 16 | 0;
          e4 = d4;
          Uc(e4, c2[b3 >> 2] | 0);
          lg(a3, e4);
          l3 = d4;
          return;
        }
        function xg(a3) {
          a3 = a3 | 0;
          return + +T2(tc(c2[a3 >> 2] | 0));
        }
        function yg(a3) {
          a3 = a3 | 0;
          return + +T2(uc(c2[a3 >> 2] | 0));
        }
        function zg(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          d4 = l3;
          l3 = l3 + 16 | 0;
          e4 = d4;
          id(e4, c2[b3 >> 2] | 0);
          lg(a3, e4);
          l3 = d4;
          return;
        }
        function Ag(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          d4 = l3;
          l3 = l3 + 16 | 0;
          e4 = d4;
          md(e4, c2[b3 >> 2] | 0);
          lg(a3, e4);
          l3 = d4;
          return;
        }
        function Bg(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          d4 = l3;
          l3 = l3 + 16 | 0;
          e4 = d4;
          pd(e4, c2[b3 >> 2] | 0);
          lg(a3, e4);
          l3 = d4;
          return;
        }
        function Cg(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          d4 = l3;
          l3 = l3 + 16 | 0;
          e4 = d4;
          sd(e4, c2[b3 >> 2] | 0);
          lg(a3, e4);
          l3 = d4;
          return;
        }
        function Dg(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          d4 = l3;
          l3 = l3 + 16 | 0;
          e4 = d4;
          vd(e4, c2[b3 >> 2] | 0);
          lg(a3, e4);
          l3 = d4;
          return;
        }
        function Eg(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          d4 = l3;
          l3 = l3 + 16 | 0;
          e4 = d4;
          yd(e4, c2[b3 >> 2] | 0);
          lg(a3, e4);
          l3 = d4;
          return;
        }
        function Fg(a3) {
          a3 = a3 | 0;
          return + +T2(Ad(c2[a3 >> 2] | 0));
        }
        function Gg(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return + +T2(ed(c2[a3 >> 2] | 0, b3));
        }
        function Hg(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4;
          cd(f4, c2[b3 >> 2] | 0, d4);
          lg(a3, f4);
          l3 = e4;
          return;
        }
        function Ig(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          kc(c2[a3 >> 2] | 0, c2[b3 >> 2] | 0, d4);
          return;
        }
        function Jg(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          cc(c2[a3 >> 2] | 0, c2[b3 >> 2] | 0);
          return;
        }
        function Kg(a3) {
          a3 = a3 | 0;
          return $b(c2[a3 >> 2] | 0) | 0;
        }
        function Lg(a3) {
          a3 = a3 | 0;
          a3 = pc(c2[a3 >> 2] | 0) | 0;
          if (!a3)
            a3 = 0;
          else
            a3 = xf(a3) | 0;
          return a3 | 0;
        }
        function Mg(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          a3 = ac(c2[a3 >> 2] | 0, b3) | 0;
          if (!a3)
            a3 = 0;
          else
            a3 = xf(a3) | 0;
          return a3 | 0;
        }
        function Ng(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          e4 = qC(4) | 0;
          Og(e4, b3);
          d4 = a3 + 4 | 0;
          b3 = c2[d4 >> 2] | 0;
          c2[d4 >> 2] = e4;
          if (b3 | 0) {
            vf(b3);
            sC(b3);
          }
          jc(c2[a3 >> 2] | 0, 1);
          return;
        }
        function Og(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          gh(a3, b3);
          return;
        }
        function Pg(a3, b3, c3, d4, e4, f4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = T2(c3);
          d4 = d4 | 0;
          e4 = T2(e4);
          f4 = f4 | 0;
          var i4 = 0, j4 = 0;
          i4 = l3;
          l3 = l3 + 16 | 0;
          j4 = i4;
          Qg(j4, wc(b3) | 0, +c3, d4, +e4, f4);
          g2[a3 >> 2] = T2(+h2[j4 >> 3]);
          g2[a3 + 4 >> 2] = T2(+h2[j4 + 8 >> 3]);
          l3 = i4;
          return;
        }
        function Qg(a3, b3, d4, e4, f4, g3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = +d4;
          e4 = e4 | 0;
          f4 = +f4;
          g3 = g3 | 0;
          var i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          i4 = l3;
          l3 = l3 + 32 | 0;
          n3 = i4 + 8 | 0;
          m4 = i4 + 20 | 0;
          k4 = i4;
          j4 = i4 + 16 | 0;
          h2[n3 >> 3] = d4;
          c2[m4 >> 2] = e4;
          h2[k4 >> 3] = f4;
          c2[j4 >> 2] = g3;
          Rg(a3, c2[b3 + 4 >> 2] | 0, n3, m4, k4, j4);
          l3 = i4;
          return;
        }
        function Rg(a3, b3, d4, e4, f4, g3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          g3 = g3 | 0;
          var i4 = 0, j4 = 0;
          i4 = l3;
          l3 = l3 + 16 | 0;
          j4 = i4;
          UA(j4);
          b3 = Sg(b3) | 0;
          Tg(a3, b3, +h2[d4 >> 3], c2[e4 >> 2] | 0, +h2[f4 >> 3], c2[g3 >> 2] | 0);
          WA(j4);
          l3 = i4;
          return;
        }
        function Sg(a3) {
          a3 = a3 | 0;
          return c2[a3 >> 2] | 0;
        }
        function Tg(a3, b3, c3, d4, e4, f4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = +c3;
          d4 = d4 | 0;
          e4 = +e4;
          f4 = f4 | 0;
          var g3 = 0;
          g3 = Vg(Ug() | 0) | 0;
          c3 = +Wg(c3);
          d4 = Xg(d4) | 0;
          e4 = +Wg(e4);
          Yg(a3, cb2(0, g3 | 0, b3 | 0, +c3, d4 | 0, +e4, Xg(f4) | 0) | 0);
          return;
        }
        function Ug() {
          var b3 = 0;
          if (!(a2[7608] | 0)) {
            dh(9120);
            b3 = 7608;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          return 9120;
        }
        function Vg(a3) {
          a3 = a3 | 0;
          return c2[a3 + 8 >> 2] | 0;
        }
        function Wg(a3) {
          a3 = +a3;
          return + +ch(a3);
        }
        function Xg(a3) {
          a3 = a3 | 0;
          return bh(a3) | 0;
        }
        function Yg(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          d4 = f4;
          e4 = b3;
          if (!(e4 & 1)) {
            c2[a3 >> 2] = c2[b3 >> 2];
            c2[a3 + 4 >> 2] = c2[b3 + 4 >> 2];
            c2[a3 + 8 >> 2] = c2[b3 + 8 >> 2];
            c2[a3 + 12 >> 2] = c2[b3 + 12 >> 2];
          } else {
            Zg(d4, 0);
            Ja(e4 | 0, d4 | 0) | 0;
            _g(a3, d4);
            $g(d4);
          }
          l3 = f4;
          return;
        }
        function Zg(b3, d4) {
          b3 = b3 | 0;
          d4 = d4 | 0;
          ah(b3, d4);
          c2[b3 + 8 >> 2] = 0;
          a2[b3 + 24 >> 0] = 0;
          return;
        }
        function _g(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          b3 = b3 + 8 | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = c2[b3 + 4 >> 2];
          c2[a3 + 8 >> 2] = c2[b3 + 8 >> 2];
          c2[a3 + 12 >> 2] = c2[b3 + 12 >> 2];
          return;
        }
        function $g(b3) {
          b3 = b3 | 0;
          a2[b3 + 24 >> 0] = 0;
          return;
        }
        function ah(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c2[a3 >> 2] = b3;
          return;
        }
        function bh(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function ch(a3) {
          a3 = +a3;
          return +a3;
        }
        function dh(a3) {
          a3 = a3 | 0;
          fh(a3, eh() | 0, 4);
          return;
        }
        function eh() {
          return 1064;
        }
        function fh(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          c2[a3 >> 2] = b3;
          c2[a3 + 4 >> 2] = d4;
          c2[a3 + 8 >> 2] = _a2(b3 | 0, d4 + 1 | 0) | 0;
          return;
        }
        function gh(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          b3 = c2[b3 >> 2] | 0;
          c2[a3 >> 2] = b3;
          Aa(b3 | 0);
          return;
        }
        function hh(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0;
          d4 = a3 + 4 | 0;
          b3 = c2[d4 >> 2] | 0;
          c2[d4 >> 2] = 0;
          if (b3 | 0) {
            vf(b3);
            sC(b3);
          }
          jc(c2[a3 >> 2] | 0, 0);
          return;
        }
        function ih(a3) {
          a3 = a3 | 0;
          qc(c2[a3 >> 2] | 0);
          return;
        }
        function jh(a3) {
          a3 = a3 | 0;
          return rc(c2[a3 >> 2] | 0) | 0;
        }
        function kh(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = +b3;
          d4 = +d4;
          e4 = e4 | 0;
          _d(c2[a3 >> 2] | 0, T2(b3), T2(d4), e4);
          return;
        }
        function lh(a3) {
          a3 = a3 | 0;
          return + +T2(Bd(c2[a3 >> 2] | 0));
        }
        function mh(a3) {
          a3 = a3 | 0;
          return + +T2(Dd(c2[a3 >> 2] | 0));
        }
        function nh(a3) {
          a3 = a3 | 0;
          return + +T2(Cd(c2[a3 >> 2] | 0));
        }
        function oh(a3) {
          a3 = a3 | 0;
          return + +T2(Ed(c2[a3 >> 2] | 0));
        }
        function ph(a3) {
          a3 = a3 | 0;
          return + +T2(Fd(c2[a3 >> 2] | 0));
        }
        function qh(a3) {
          a3 = a3 | 0;
          return + +T2(Gd(c2[a3 >> 2] | 0));
        }
        function rh(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          h2[a3 >> 3] = +T2(Bd(c2[b3 >> 2] | 0));
          h2[a3 + 8 >> 3] = +T2(Dd(c2[b3 >> 2] | 0));
          h2[a3 + 16 >> 3] = +T2(Cd(c2[b3 >> 2] | 0));
          h2[a3 + 24 >> 3] = +T2(Ed(c2[b3 >> 2] | 0));
          h2[a3 + 32 >> 3] = +T2(Fd(c2[b3 >> 2] | 0));
          h2[a3 + 40 >> 3] = +T2(Gd(c2[b3 >> 2] | 0));
          return;
        }
        function sh(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return + +T2(Hd(c2[a3 >> 2] | 0, b3));
        }
        function th(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return + +T2(Id(c2[a3 >> 2] | 0, b3));
        }
        function uh(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return + +T2(Jd(c2[a3 >> 2] | 0, b3));
        }
        function vh() {
          return fc() | 0;
        }
        function wh() {
          xh();
          yh();
          zh();
          Ah();
          Bh();
          Ch();
          return;
        }
        function xh() {
          kv(11713, 4938, 1);
          return;
        }
        function yh() {
          yu(10448);
          return;
        }
        function zh() {
          eu(10408);
          return;
        }
        function Ah() {
          vt(10324);
          return;
        }
        function Bh() {
          or(10096);
          return;
        }
        function Ch() {
          Dh(9132);
          return;
        }
        function Dh(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0, p4 = 0, q3 = 0, r3 = 0, s3 = 0, t3 = 0, u4 = 0, v4 = 0, w3 = 0, x4 = 0, y3 = 0, z3 = 0, A3 = 0, B3 = 0, C3 = 0, D3 = 0, E3 = 0, F3 = 0, G3 = 0, H3 = 0, I3 = 0, J3 = 0, K3 = 0, L3 = 0, M4 = 0, N4 = 0, O3 = 0, P3 = 0, Q3 = 0, R3 = 0, S4 = 0, T3 = 0, U3 = 0, V3 = 0, W3 = 0, X3 = 0, Y3 = 0, Z3 = 0, _3 = 0, $4 = 0, aa2 = 0, ba2 = 0, ca2 = 0, da2 = 0, ea2 = 0, fa2 = 0, ga2 = 0, ha2 = 0, ia2 = 0, ja2 = 0, ka2 = 0, la2 = 0, ma2 = 0, na2 = 0, oa2 = 0, pa2 = 0, qa2 = 0, ra2 = 0, sa2 = 0, ta2 = 0, ua2 = 0, va2 = 0, wa2 = 0, xa2 = 0, ya2 = 0, za2 = 0, Aa2 = 0, Ba2 = 0, Ca2 = 0, Da2 = 0, Ea2 = 0, Fa2 = 0, Ga2 = 0;
          b3 = l3;
          l3 = l3 + 672 | 0;
          d4 = b3 + 656 | 0;
          Ga2 = b3 + 648 | 0;
          Fa2 = b3 + 640 | 0;
          Ea2 = b3 + 632 | 0;
          Da2 = b3 + 624 | 0;
          Ca2 = b3 + 616 | 0;
          Ba2 = b3 + 608 | 0;
          Aa2 = b3 + 600 | 0;
          za2 = b3 + 592 | 0;
          ya2 = b3 + 584 | 0;
          xa2 = b3 + 576 | 0;
          wa2 = b3 + 568 | 0;
          va2 = b3 + 560 | 0;
          ua2 = b3 + 552 | 0;
          ta2 = b3 + 544 | 0;
          sa2 = b3 + 536 | 0;
          ra2 = b3 + 528 | 0;
          qa2 = b3 + 520 | 0;
          pa2 = b3 + 512 | 0;
          oa2 = b3 + 504 | 0;
          na2 = b3 + 496 | 0;
          ma2 = b3 + 488 | 0;
          la2 = b3 + 480 | 0;
          ka2 = b3 + 472 | 0;
          ja2 = b3 + 464 | 0;
          ia2 = b3 + 456 | 0;
          ha2 = b3 + 448 | 0;
          ga2 = b3 + 440 | 0;
          fa2 = b3 + 432 | 0;
          ea2 = b3 + 424 | 0;
          da2 = b3 + 416 | 0;
          ca2 = b3 + 408 | 0;
          ba2 = b3 + 400 | 0;
          aa2 = b3 + 392 | 0;
          $4 = b3 + 384 | 0;
          _3 = b3 + 376 | 0;
          Z3 = b3 + 368 | 0;
          Y3 = b3 + 360 | 0;
          X3 = b3 + 352 | 0;
          W3 = b3 + 344 | 0;
          V3 = b3 + 336 | 0;
          U3 = b3 + 328 | 0;
          T3 = b3 + 320 | 0;
          S4 = b3 + 312 | 0;
          R3 = b3 + 304 | 0;
          Q3 = b3 + 296 | 0;
          P3 = b3 + 288 | 0;
          O3 = b3 + 280 | 0;
          N4 = b3 + 272 | 0;
          M4 = b3 + 264 | 0;
          L3 = b3 + 256 | 0;
          K3 = b3 + 248 | 0;
          J3 = b3 + 240 | 0;
          I3 = b3 + 232 | 0;
          H3 = b3 + 224 | 0;
          G3 = b3 + 216 | 0;
          F3 = b3 + 208 | 0;
          E3 = b3 + 200 | 0;
          D3 = b3 + 192 | 0;
          C3 = b3 + 184 | 0;
          B3 = b3 + 176 | 0;
          A3 = b3 + 168 | 0;
          z3 = b3 + 160 | 0;
          y3 = b3 + 152 | 0;
          x4 = b3 + 144 | 0;
          w3 = b3 + 136 | 0;
          v4 = b3 + 128 | 0;
          u4 = b3 + 120 | 0;
          t3 = b3 + 112 | 0;
          s3 = b3 + 104 | 0;
          r3 = b3 + 96 | 0;
          q3 = b3 + 88 | 0;
          p4 = b3 + 80 | 0;
          o3 = b3 + 72 | 0;
          n3 = b3 + 64 | 0;
          m4 = b3 + 56 | 0;
          k4 = b3 + 48 | 0;
          j4 = b3 + 40 | 0;
          i4 = b3 + 32 | 0;
          h3 = b3 + 24 | 0;
          g3 = b3 + 16 | 0;
          f4 = b3 + 8 | 0;
          e4 = b3;
          Eh(a3, 3646);
          Fh(a3, 3651, 2) | 0;
          Gh(a3, 3665, 2) | 0;
          Hh(a3, 3682, 18) | 0;
          c2[Ga2 >> 2] = 19;
          c2[Ga2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[Ga2 >> 2];
          c2[d4 + 4 >> 2] = c2[Ga2 + 4 >> 2];
          Ih(a3, 3690, d4) | 0;
          c2[Fa2 >> 2] = 1;
          c2[Fa2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[Fa2 >> 2];
          c2[d4 + 4 >> 2] = c2[Fa2 + 4 >> 2];
          Jh(a3, 3696, d4) | 0;
          c2[Ea2 >> 2] = 2;
          c2[Ea2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[Ea2 >> 2];
          c2[d4 + 4 >> 2] = c2[Ea2 + 4 >> 2];
          Kh(a3, 3706, d4) | 0;
          c2[Da2 >> 2] = 1;
          c2[Da2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[Da2 >> 2];
          c2[d4 + 4 >> 2] = c2[Da2 + 4 >> 2];
          Lh(a3, 3722, d4) | 0;
          c2[Ca2 >> 2] = 2;
          c2[Ca2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[Ca2 >> 2];
          c2[d4 + 4 >> 2] = c2[Ca2 + 4 >> 2];
          Lh(a3, 3734, d4) | 0;
          c2[Ba2 >> 2] = 3;
          c2[Ba2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[Ba2 >> 2];
          c2[d4 + 4 >> 2] = c2[Ba2 + 4 >> 2];
          Kh(a3, 3753, d4) | 0;
          c2[Aa2 >> 2] = 4;
          c2[Aa2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[Aa2 >> 2];
          c2[d4 + 4 >> 2] = c2[Aa2 + 4 >> 2];
          Kh(a3, 3769, d4) | 0;
          c2[za2 >> 2] = 5;
          c2[za2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[za2 >> 2];
          c2[d4 + 4 >> 2] = c2[za2 + 4 >> 2];
          Kh(a3, 3783, d4) | 0;
          c2[ya2 >> 2] = 6;
          c2[ya2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[ya2 >> 2];
          c2[d4 + 4 >> 2] = c2[ya2 + 4 >> 2];
          Kh(a3, 3796, d4) | 0;
          c2[xa2 >> 2] = 7;
          c2[xa2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[xa2 >> 2];
          c2[d4 + 4 >> 2] = c2[xa2 + 4 >> 2];
          Kh(a3, 3813, d4) | 0;
          c2[wa2 >> 2] = 8;
          c2[wa2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[wa2 >> 2];
          c2[d4 + 4 >> 2] = c2[wa2 + 4 >> 2];
          Kh(a3, 3825, d4) | 0;
          c2[va2 >> 2] = 3;
          c2[va2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[va2 >> 2];
          c2[d4 + 4 >> 2] = c2[va2 + 4 >> 2];
          Lh(a3, 3843, d4) | 0;
          c2[ua2 >> 2] = 4;
          c2[ua2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[ua2 >> 2];
          c2[d4 + 4 >> 2] = c2[ua2 + 4 >> 2];
          Lh(a3, 3853, d4) | 0;
          c2[ta2 >> 2] = 9;
          c2[ta2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[ta2 >> 2];
          c2[d4 + 4 >> 2] = c2[ta2 + 4 >> 2];
          Kh(a3, 3870, d4) | 0;
          c2[sa2 >> 2] = 10;
          c2[sa2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[sa2 >> 2];
          c2[d4 + 4 >> 2] = c2[sa2 + 4 >> 2];
          Kh(a3, 3884, d4) | 0;
          c2[ra2 >> 2] = 11;
          c2[ra2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[ra2 >> 2];
          c2[d4 + 4 >> 2] = c2[ra2 + 4 >> 2];
          Kh(a3, 3896, d4) | 0;
          c2[qa2 >> 2] = 1;
          c2[qa2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[qa2 >> 2];
          c2[d4 + 4 >> 2] = c2[qa2 + 4 >> 2];
          Mh(a3, 3907, d4) | 0;
          c2[pa2 >> 2] = 2;
          c2[pa2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[pa2 >> 2];
          c2[d4 + 4 >> 2] = c2[pa2 + 4 >> 2];
          Mh(a3, 3915, d4) | 0;
          c2[oa2 >> 2] = 3;
          c2[oa2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[oa2 >> 2];
          c2[d4 + 4 >> 2] = c2[oa2 + 4 >> 2];
          Mh(a3, 3928, d4) | 0;
          c2[na2 >> 2] = 4;
          c2[na2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[na2 >> 2];
          c2[d4 + 4 >> 2] = c2[na2 + 4 >> 2];
          Mh(a3, 3948, d4) | 0;
          c2[ma2 >> 2] = 5;
          c2[ma2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[ma2 >> 2];
          c2[d4 + 4 >> 2] = c2[ma2 + 4 >> 2];
          Mh(a3, 3960, d4) | 0;
          c2[la2 >> 2] = 6;
          c2[la2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[la2 >> 2];
          c2[d4 + 4 >> 2] = c2[la2 + 4 >> 2];
          Mh(a3, 3974, d4) | 0;
          c2[ka2 >> 2] = 7;
          c2[ka2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[ka2 >> 2];
          c2[d4 + 4 >> 2] = c2[ka2 + 4 >> 2];
          Mh(a3, 3983, d4) | 0;
          c2[ja2 >> 2] = 20;
          c2[ja2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[ja2 >> 2];
          c2[d4 + 4 >> 2] = c2[ja2 + 4 >> 2];
          Ih(a3, 3999, d4) | 0;
          c2[ia2 >> 2] = 8;
          c2[ia2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[ia2 >> 2];
          c2[d4 + 4 >> 2] = c2[ia2 + 4 >> 2];
          Mh(a3, 4012, d4) | 0;
          c2[ha2 >> 2] = 9;
          c2[ha2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[ha2 >> 2];
          c2[d4 + 4 >> 2] = c2[ha2 + 4 >> 2];
          Mh(a3, 4022, d4) | 0;
          c2[ga2 >> 2] = 21;
          c2[ga2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[ga2 >> 2];
          c2[d4 + 4 >> 2] = c2[ga2 + 4 >> 2];
          Ih(a3, 4039, d4) | 0;
          c2[fa2 >> 2] = 10;
          c2[fa2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[fa2 >> 2];
          c2[d4 + 4 >> 2] = c2[fa2 + 4 >> 2];
          Mh(a3, 4053, d4) | 0;
          c2[ea2 >> 2] = 11;
          c2[ea2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[ea2 >> 2];
          c2[d4 + 4 >> 2] = c2[ea2 + 4 >> 2];
          Mh(a3, 4065, d4) | 0;
          c2[da2 >> 2] = 12;
          c2[da2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[da2 >> 2];
          c2[d4 + 4 >> 2] = c2[da2 + 4 >> 2];
          Mh(a3, 4084, d4) | 0;
          c2[ca2 >> 2] = 13;
          c2[ca2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[ca2 >> 2];
          c2[d4 + 4 >> 2] = c2[ca2 + 4 >> 2];
          Mh(a3, 4097, d4) | 0;
          c2[ba2 >> 2] = 14;
          c2[ba2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[ba2 >> 2];
          c2[d4 + 4 >> 2] = c2[ba2 + 4 >> 2];
          Mh(a3, 4117, d4) | 0;
          c2[aa2 >> 2] = 15;
          c2[aa2 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[aa2 >> 2];
          c2[d4 + 4 >> 2] = c2[aa2 + 4 >> 2];
          Mh(a3, 4129, d4) | 0;
          c2[$4 >> 2] = 16;
          c2[$4 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[$4 >> 2];
          c2[d4 + 4 >> 2] = c2[$4 + 4 >> 2];
          Mh(a3, 4148, d4) | 0;
          c2[_3 >> 2] = 17;
          c2[_3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[_3 >> 2];
          c2[d4 + 4 >> 2] = c2[_3 + 4 >> 2];
          Mh(a3, 4161, d4) | 0;
          c2[Z3 >> 2] = 18;
          c2[Z3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[Z3 >> 2];
          c2[d4 + 4 >> 2] = c2[Z3 + 4 >> 2];
          Mh(a3, 4181, d4) | 0;
          c2[Y3 >> 2] = 5;
          c2[Y3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[Y3 >> 2];
          c2[d4 + 4 >> 2] = c2[Y3 + 4 >> 2];
          Lh(a3, 4196, d4) | 0;
          c2[X3 >> 2] = 6;
          c2[X3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[X3 >> 2];
          c2[d4 + 4 >> 2] = c2[X3 + 4 >> 2];
          Lh(a3, 4206, d4) | 0;
          c2[W3 >> 2] = 7;
          c2[W3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[W3 >> 2];
          c2[d4 + 4 >> 2] = c2[W3 + 4 >> 2];
          Lh(a3, 4217, d4) | 0;
          c2[V3 >> 2] = 3;
          c2[V3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[V3 >> 2];
          c2[d4 + 4 >> 2] = c2[V3 + 4 >> 2];
          Nh(a3, 4235, d4) | 0;
          c2[U3 >> 2] = 1;
          c2[U3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[U3 >> 2];
          c2[d4 + 4 >> 2] = c2[U3 + 4 >> 2];
          Oh(a3, 4251, d4) | 0;
          c2[T3 >> 2] = 4;
          c2[T3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[T3 >> 2];
          c2[d4 + 4 >> 2] = c2[T3 + 4 >> 2];
          Nh(a3, 4263, d4) | 0;
          c2[S4 >> 2] = 5;
          c2[S4 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[S4 >> 2];
          c2[d4 + 4 >> 2] = c2[S4 + 4 >> 2];
          Nh(a3, 4279, d4) | 0;
          c2[R3 >> 2] = 6;
          c2[R3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[R3 >> 2];
          c2[d4 + 4 >> 2] = c2[R3 + 4 >> 2];
          Nh(a3, 4293, d4) | 0;
          c2[Q3 >> 2] = 7;
          c2[Q3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[Q3 >> 2];
          c2[d4 + 4 >> 2] = c2[Q3 + 4 >> 2];
          Nh(a3, 4306, d4) | 0;
          c2[P3 >> 2] = 8;
          c2[P3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[P3 >> 2];
          c2[d4 + 4 >> 2] = c2[P3 + 4 >> 2];
          Nh(a3, 4323, d4) | 0;
          c2[O3 >> 2] = 9;
          c2[O3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[O3 >> 2];
          c2[d4 + 4 >> 2] = c2[O3 + 4 >> 2];
          Nh(a3, 4335, d4) | 0;
          c2[N4 >> 2] = 2;
          c2[N4 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[N4 >> 2];
          c2[d4 + 4 >> 2] = c2[N4 + 4 >> 2];
          Oh(a3, 4353, d4) | 0;
          c2[M4 >> 2] = 12;
          c2[M4 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[M4 >> 2];
          c2[d4 + 4 >> 2] = c2[M4 + 4 >> 2];
          Ph(a3, 4363, d4) | 0;
          c2[L3 >> 2] = 1;
          c2[L3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[L3 >> 2];
          c2[d4 + 4 >> 2] = c2[L3 + 4 >> 2];
          Qh(a3, 4376, d4) | 0;
          c2[K3 >> 2] = 2;
          c2[K3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[K3 >> 2];
          c2[d4 + 4 >> 2] = c2[K3 + 4 >> 2];
          Qh(a3, 4388, d4) | 0;
          c2[J3 >> 2] = 13;
          c2[J3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[J3 >> 2];
          c2[d4 + 4 >> 2] = c2[J3 + 4 >> 2];
          Ph(a3, 4402, d4) | 0;
          c2[I3 >> 2] = 14;
          c2[I3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[I3 >> 2];
          c2[d4 + 4 >> 2] = c2[I3 + 4 >> 2];
          Ph(a3, 4411, d4) | 0;
          c2[H3 >> 2] = 15;
          c2[H3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[H3 >> 2];
          c2[d4 + 4 >> 2] = c2[H3 + 4 >> 2];
          Ph(a3, 4421, d4) | 0;
          c2[G3 >> 2] = 16;
          c2[G3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[G3 >> 2];
          c2[d4 + 4 >> 2] = c2[G3 + 4 >> 2];
          Ph(a3, 4433, d4) | 0;
          c2[F3 >> 2] = 17;
          c2[F3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[F3 >> 2];
          c2[d4 + 4 >> 2] = c2[F3 + 4 >> 2];
          Ph(a3, 4446, d4) | 0;
          c2[E3 >> 2] = 18;
          c2[E3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[E3 >> 2];
          c2[d4 + 4 >> 2] = c2[E3 + 4 >> 2];
          Ph(a3, 4458, d4) | 0;
          c2[D3 >> 2] = 3;
          c2[D3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[D3 >> 2];
          c2[d4 + 4 >> 2] = c2[D3 + 4 >> 2];
          Qh(a3, 4471, d4) | 0;
          c2[C3 >> 2] = 1;
          c2[C3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[C3 >> 2];
          c2[d4 + 4 >> 2] = c2[C3 + 4 >> 2];
          Rh(a3, 4486, d4) | 0;
          c2[B3 >> 2] = 10;
          c2[B3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[B3 >> 2];
          c2[d4 + 4 >> 2] = c2[B3 + 4 >> 2];
          Nh(a3, 4496, d4) | 0;
          c2[A3 >> 2] = 11;
          c2[A3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[A3 >> 2];
          c2[d4 + 4 >> 2] = c2[A3 + 4 >> 2];
          Nh(a3, 4508, d4) | 0;
          c2[z3 >> 2] = 3;
          c2[z3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[z3 >> 2];
          c2[d4 + 4 >> 2] = c2[z3 + 4 >> 2];
          Oh(a3, 4519, d4) | 0;
          c2[y3 >> 2] = 4;
          c2[y3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[y3 >> 2];
          c2[d4 + 4 >> 2] = c2[y3 + 4 >> 2];
          Sh(a3, 4530, d4) | 0;
          c2[x4 >> 2] = 19;
          c2[x4 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[x4 >> 2];
          c2[d4 + 4 >> 2] = c2[x4 + 4 >> 2];
          Th(a3, 4542, d4) | 0;
          c2[w3 >> 2] = 12;
          c2[w3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[w3 >> 2];
          c2[d4 + 4 >> 2] = c2[w3 + 4 >> 2];
          Uh(a3, 4554, d4) | 0;
          c2[v4 >> 2] = 13;
          c2[v4 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[v4 >> 2];
          c2[d4 + 4 >> 2] = c2[v4 + 4 >> 2];
          Vh(a3, 4568, d4) | 0;
          c2[u4 >> 2] = 2;
          c2[u4 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[u4 >> 2];
          c2[d4 + 4 >> 2] = c2[u4 + 4 >> 2];
          Wh(a3, 4578, d4) | 0;
          c2[t3 >> 2] = 20;
          c2[t3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[t3 >> 2];
          c2[d4 + 4 >> 2] = c2[t3 + 4 >> 2];
          Xh(a3, 4587, d4) | 0;
          c2[s3 >> 2] = 22;
          c2[s3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[s3 >> 2];
          c2[d4 + 4 >> 2] = c2[s3 + 4 >> 2];
          Ih(a3, 4602, d4) | 0;
          c2[r3 >> 2] = 23;
          c2[r3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[r3 >> 2];
          c2[d4 + 4 >> 2] = c2[r3 + 4 >> 2];
          Ih(a3, 4619, d4) | 0;
          c2[q3 >> 2] = 14;
          c2[q3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[q3 >> 2];
          c2[d4 + 4 >> 2] = c2[q3 + 4 >> 2];
          Yh(a3, 4629, d4) | 0;
          c2[p4 >> 2] = 1;
          c2[p4 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[p4 >> 2];
          c2[d4 + 4 >> 2] = c2[p4 + 4 >> 2];
          Zh(a3, 4637, d4) | 0;
          c2[o3 >> 2] = 4;
          c2[o3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[o3 >> 2];
          c2[d4 + 4 >> 2] = c2[o3 + 4 >> 2];
          Qh(a3, 4653, d4) | 0;
          c2[n3 >> 2] = 5;
          c2[n3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[n3 >> 2];
          c2[d4 + 4 >> 2] = c2[n3 + 4 >> 2];
          Qh(a3, 4669, d4) | 0;
          c2[m4 >> 2] = 6;
          c2[m4 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[m4 >> 2];
          c2[d4 + 4 >> 2] = c2[m4 + 4 >> 2];
          Qh(a3, 4686, d4) | 0;
          c2[k4 >> 2] = 7;
          c2[k4 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[k4 >> 2];
          c2[d4 + 4 >> 2] = c2[k4 + 4 >> 2];
          Qh(a3, 4701, d4) | 0;
          c2[j4 >> 2] = 8;
          c2[j4 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[j4 >> 2];
          c2[d4 + 4 >> 2] = c2[j4 + 4 >> 2];
          Qh(a3, 4719, d4) | 0;
          c2[i4 >> 2] = 9;
          c2[i4 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[i4 >> 2];
          c2[d4 + 4 >> 2] = c2[i4 + 4 >> 2];
          Qh(a3, 4736, d4) | 0;
          c2[h3 >> 2] = 21;
          c2[h3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[h3 >> 2];
          c2[d4 + 4 >> 2] = c2[h3 + 4 >> 2];
          _h(a3, 4754, d4) | 0;
          c2[g3 >> 2] = 2;
          c2[g3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[g3 >> 2];
          c2[d4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Rh(a3, 4772, d4) | 0;
          c2[f4 >> 2] = 3;
          c2[f4 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[f4 >> 2];
          c2[d4 + 4 >> 2] = c2[f4 + 4 >> 2];
          Rh(a3, 4790, d4) | 0;
          c2[e4 >> 2] = 4;
          c2[e4 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[e4 >> 2];
          c2[d4 + 4 >> 2] = c2[e4 + 4 >> 2];
          Rh(a3, 4808, d4) | 0;
          l3 = b3;
          return;
        }
        function Eh(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = dr() | 0;
          c2[a3 >> 2] = d4;
          er(d4, b3);
          Hv(c2[a3 >> 2] | 0);
          return;
        }
        function Fh(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          Oq(a3, ai(b3) | 0, c3, 0);
          return a3 | 0;
        }
        function Gh(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          tq(a3, ai(b3) | 0, c3, 0);
          return a3 | 0;
        }
        function Hh(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          cq(a3, ai(b3) | 0, c3, 0);
          return a3 | 0;
        }
        function Ih(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = c2[d4 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[d4 >> 2];
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Lp(a3, b3, f4);
          l3 = e4;
          return a3 | 0;
        }
        function Jh(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = c2[d4 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[d4 >> 2];
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          pp(a3, b3, f4);
          l3 = e4;
          return a3 | 0;
        }
        function Kh(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = c2[d4 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[d4 >> 2];
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Yo(a3, b3, f4);
          l3 = e4;
          return a3 | 0;
        }
        function Lh(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = c2[d4 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[d4 >> 2];
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Fo(a3, b3, f4);
          l3 = e4;
          return a3 | 0;
        }
        function Mh(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = c2[d4 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[d4 >> 2];
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          mo(a3, b3, f4);
          l3 = e4;
          return a3 | 0;
        }
        function Nh(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = c2[d4 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[d4 >> 2];
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Un(a3, b3, f4);
          l3 = e4;
          return a3 | 0;
        }
        function Oh(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = c2[d4 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[d4 >> 2];
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Bn(a3, b3, f4);
          l3 = e4;
          return a3 | 0;
        }
        function Ph(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = c2[d4 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[d4 >> 2];
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Um(a3, b3, f4);
          l3 = e4;
          return a3 | 0;
        }
        function Qh(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = c2[d4 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[d4 >> 2];
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Bm(a3, b3, f4);
          l3 = e4;
          return a3 | 0;
        }
        function Rh(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = c2[d4 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[d4 >> 2];
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          im(a3, b3, f4);
          l3 = e4;
          return a3 | 0;
        }
        function Sh(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = c2[d4 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[d4 >> 2];
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Rl(a3, b3, f4);
          l3 = e4;
          return a3 | 0;
        }
        function Th(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = c2[d4 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[d4 >> 2];
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          vl(a3, b3, f4);
          l3 = e4;
          return a3 | 0;
        }
        function Uh(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = c2[d4 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[d4 >> 2];
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          bl(a3, b3, f4);
          l3 = e4;
          return a3 | 0;
        }
        function Vh(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = c2[d4 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[d4 >> 2];
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Kk(a3, b3, f4);
          l3 = e4;
          return a3 | 0;
        }
        function Wh(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = c2[d4 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[d4 >> 2];
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          nk(a3, b3, f4);
          l3 = e4;
          return a3 | 0;
        }
        function Xh(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = c2[d4 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[d4 >> 2];
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Rj(a3, b3, f4);
          l3 = e4;
          return a3 | 0;
        }
        function Yh(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = c2[d4 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[d4 >> 2];
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          xj(a3, b3, f4);
          l3 = e4;
          return a3 | 0;
        }
        function Zh(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = c2[d4 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[d4 >> 2];
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          _i(a3, b3, f4);
          l3 = e4;
          return a3 | 0;
        }
        function _h(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = c2[d4 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[d4 >> 2];
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          $h(a3, b3, f4);
          l3 = e4;
          return a3 | 0;
        }
        function $h(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          i4 = c2[d4 >> 2] | 0;
          h3 = c2[d4 + 4 >> 2] | 0;
          d4 = ai(b3) | 0;
          c2[g3 >> 2] = i4;
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          bi(a3, d4, f4, 1);
          l3 = e4;
          return;
        }
        function ai(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function bi(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4 + 16 | 0;
          m4 = f4 + 8 | 0;
          i4 = f4;
          k4 = c2[d4 >> 2] | 0;
          j4 = c2[d4 + 4 >> 2] | 0;
          h3 = c2[a3 >> 2] | 0;
          a3 = ci() | 0;
          c2[m4 >> 2] = k4;
          c2[m4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[m4 >> 2];
          c2[g3 + 4 >> 2] = c2[m4 + 4 >> 2];
          d4 = di(g3) | 0;
          c2[i4 >> 2] = k4;
          c2[i4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[i4 >> 2];
          c2[g3 + 4 >> 2] = c2[i4 + 4 >> 2];
          fi(h3, b3, a3, d4, ei(g3, e4) | 0, e4);
          l3 = f4;
          return;
        }
        function ci() {
          var b3 = 0, d4 = 0;
          if (!(a2[7616] | 0)) {
            qi(9136);
            Ha(24, 9136, o2 | 0) | 0;
            d4 = 7616;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(9136) | 0)) {
            b3 = 9136;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            qi(9136);
          }
          return 9136;
        }
        function di(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function ei(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          m4 = l3;
          l3 = l3 + 32 | 0;
          f4 = m4 + 24 | 0;
          h3 = m4 + 16 | 0;
          i4 = m4;
          j4 = m4 + 8 | 0;
          g3 = c2[a3 >> 2] | 0;
          e4 = c2[a3 + 4 >> 2] | 0;
          c2[i4 >> 2] = g3;
          c2[i4 + 4 >> 2] = e4;
          n3 = ci() | 0;
          k4 = n3 + 24 | 0;
          a3 = ji(b3, 4) | 0;
          c2[j4 >> 2] = a3;
          b3 = n3 + 28 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 >>> 0 < (c2[n3 + 32 >> 2] | 0) >>> 0) {
            c2[h3 >> 2] = g3;
            c2[h3 + 4 >> 2] = e4;
            c2[f4 >> 2] = c2[h3 >> 2];
            c2[f4 + 4 >> 2] = c2[h3 + 4 >> 2];
            ki(d4, f4, a3);
            a3 = (c2[b3 >> 2] | 0) + 12 | 0;
            c2[b3 >> 2] = a3;
          } else {
            li(k4, i4, j4);
            a3 = c2[b3 >> 2] | 0;
          }
          l3 = m4;
          return ((a3 - (c2[k4 >> 2] | 0) | 0) / 12 | 0) + -1 | 0;
        }
        function fi(a3, b3, d4, e4, f4, g3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          g3 = g3 | 0;
          var h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0, p4 = 0;
          h3 = l3;
          l3 = l3 + 32 | 0;
          o3 = h3 + 24 | 0;
          n3 = h3 + 20 | 0;
          j4 = h3 + 16 | 0;
          m4 = h3 + 12 | 0;
          k4 = h3 + 8 | 0;
          i4 = h3 + 4 | 0;
          p4 = h3;
          c2[n3 >> 2] = b3;
          c2[j4 >> 2] = d4;
          c2[m4 >> 2] = e4;
          c2[k4 >> 2] = f4;
          c2[i4 >> 2] = g3;
          g3 = a3 + 28 | 0;
          c2[p4 >> 2] = c2[g3 >> 2];
          c2[o3 >> 2] = c2[p4 >> 2];
          gi(a3 + 24 | 0, o3, n3, m4, k4, j4, i4) | 0;
          c2[g3 >> 2] = c2[c2[g3 >> 2] >> 2];
          l3 = h3;
          return;
        }
        function gi(a3, b3, d4, e4, f4, g3, h3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          g3 = g3 | 0;
          h3 = h3 | 0;
          a3 = hi(b3) | 0;
          b3 = qC(24) | 0;
          ii(b3 + 4 | 0, c2[d4 >> 2] | 0, c2[e4 >> 2] | 0, c2[f4 >> 2] | 0, c2[g3 >> 2] | 0, c2[h3 >> 2] | 0);
          c2[b3 >> 2] = c2[a3 >> 2];
          c2[a3 >> 2] = b3;
          return b3 | 0;
        }
        function hi(a3) {
          a3 = a3 | 0;
          return c2[a3 >> 2] | 0;
        }
        function ii(a3, b3, d4, e4, f4, g3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          g3 = g3 | 0;
          c2[a3 >> 2] = b3;
          c2[a3 + 4 >> 2] = d4;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4;
          c2[a3 + 16 >> 2] = g3;
          return;
        }
        function ji(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return b3 | a3 | 0;
        }
        function ki(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = c2[b3 + 4 >> 2] | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 8 >> 2] = d4;
          return;
        }
        function li(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0;
          k4 = l3;
          l3 = l3 + 48 | 0;
          e4 = k4 + 32 | 0;
          h3 = k4 + 24 | 0;
          i4 = k4;
          j4 = a3 + 4 | 0;
          f4 = (((c2[j4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
          g3 = mi(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            m4 = c2[a3 >> 2] | 0;
            o3 = ((c2[a3 + 8 >> 2] | 0) - m4 | 0) / 12 | 0;
            n3 = o3 << 1;
            ni(i4, o3 >>> 0 < g3 >>> 1 >>> 0 ? n3 >>> 0 < f4 >>> 0 ? f4 : n3 : g3, ((c2[j4 >> 2] | 0) - m4 | 0) / 12 | 0, a3 + 8 | 0);
            j4 = i4 + 8 | 0;
            g3 = c2[j4 >> 2] | 0;
            f4 = c2[b3 + 4 >> 2] | 0;
            d4 = c2[d4 >> 2] | 0;
            c2[h3 >> 2] = c2[b3 >> 2];
            c2[h3 + 4 >> 2] = f4;
            c2[e4 >> 2] = c2[h3 >> 2];
            c2[e4 + 4 >> 2] = c2[h3 + 4 >> 2];
            ki(g3, e4, d4);
            c2[j4 >> 2] = (c2[j4 >> 2] | 0) + 12;
            oi(a3, i4);
            pi(i4);
            l3 = k4;
            return;
          }
        }
        function mi(a3) {
          a3 = a3 | 0;
          return 357913941;
        }
        function ni(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 357913941)
                Ta();
              else {
                f4 = qC(b3 * 12 | 0) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 * 12 | 0) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 * 12 | 0);
          return;
        }
        function oi(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (((f4 | 0) / -12 | 0) * 12 | 0) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function pi(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~(((e4 + -12 - b3 | 0) >>> 0) / 12 | 0) * 12 | 0);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function qi(a3) {
          a3 = a3 | 0;
          ui(a3);
          return;
        }
        function ri(a3) {
          a3 = a3 | 0;
          ti(a3 + 24 | 0);
          return;
        }
        function si(a3) {
          a3 = a3 | 0;
          return c2[a3 >> 2] | 0;
        }
        function ti(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~(((b3 + -12 - e4 | 0) >>> 0) / 12 | 0) * 12 | 0);
            sC(d4);
          }
          return;
        }
        function ui(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 2, 3, b3, wi() | 0, 0);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function vi() {
          return 9228;
        }
        function wi() {
          return 1140;
        }
        function xi(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0;
          d4 = l3;
          l3 = l3 + 16 | 0;
          e4 = d4 + 8 | 0;
          f4 = d4;
          g3 = zi(a3) | 0;
          a3 = c2[g3 + 4 >> 2] | 0;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = a3;
          c2[e4 >> 2] = c2[f4 >> 2];
          c2[e4 + 4 >> 2] = c2[f4 + 4 >> 2];
          b3 = Ai(b3, e4) | 0;
          l3 = d4;
          return b3 | 0;
        }
        function yi(a3, b3, d4, e4, f4, g3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          g3 = g3 | 0;
          c2[a3 >> 2] = b3;
          c2[a3 + 4 >> 2] = d4;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4;
          c2[a3 + 16 >> 2] = g3;
          return;
        }
        function zi(a3) {
          a3 = a3 | 0;
          return (c2[(ci() | 0) + 24 >> 2] | 0) + (a3 * 12 | 0) | 0;
        }
        function Ai(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0;
          f4 = l3;
          l3 = l3 + 48 | 0;
          e4 = f4;
          d4 = c2[b3 >> 2] | 0;
          b3 = c2[b3 + 4 >> 2] | 0;
          a3 = a3 + (b3 >> 1) | 0;
          if (b3 & 1)
            d4 = c2[(c2[a3 >> 2] | 0) + d4 >> 2] | 0;
          ob[d4 & 31](e4, a3);
          e4 = Bi(e4) | 0;
          l3 = f4;
          return e4 | 0;
        }
        function Bi(a3) {
          a3 = a3 | 0;
          var b3 = 0, c3 = 0, d4 = 0, e4 = 0;
          e4 = l3;
          l3 = l3 + 32 | 0;
          b3 = e4 + 12 | 0;
          c3 = e4;
          d4 = Di(Ci() | 0) | 0;
          if (!d4)
            a3 = Ii(a3) | 0;
          else {
            Ei(b3, d4);
            Fi(c3, b3);
            Gi(a3, c3);
            a3 = Hi(b3) | 0;
          }
          l3 = e4;
          return a3 | 0;
        }
        function Ci() {
          var b3 = 0;
          if (!(a2[7632] | 0)) {
            Ti(9184);
            Ha(25, 9184, o2 | 0) | 0;
            b3 = 7632;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          return 9184;
        }
        function Di(a3) {
          a3 = a3 | 0;
          return c2[a3 + 36 >> 2] | 0;
        }
        function Ei(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c2[a3 >> 2] = b3;
          c2[a3 + 4 >> 2] = a3;
          c2[a3 + 8 >> 2] = 0;
          return;
        }
        function Fi(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = c2[b3 + 4 >> 2];
          c2[a3 + 8 >> 2] = 0;
          return;
        }
        function Gi(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          Ni(b3, a3, a3 + 8 | 0, a3 + 16 | 0, a3 + 24 | 0, a3 + 32 | 0, a3 + 40 | 0) | 0;
          return;
        }
        function Hi(a3) {
          a3 = a3 | 0;
          return c2[(c2[a3 + 4 >> 2] | 0) + 8 >> 2] | 0;
        }
        function Ii(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          j4 = l3;
          l3 = l3 + 16 | 0;
          d4 = j4 + 4 | 0;
          e4 = j4;
          f4 = jy(8) | 0;
          g3 = f4;
          h3 = qC(48) | 0;
          i4 = h3;
          b3 = i4 + 48 | 0;
          do {
            c2[i4 >> 2] = c2[a3 >> 2];
            i4 = i4 + 4 | 0;
            a3 = a3 + 4 | 0;
          } while ((i4 | 0) < (b3 | 0));
          b3 = g3 + 4 | 0;
          c2[b3 >> 2] = h3;
          i4 = qC(8) | 0;
          h3 = c2[b3 >> 2] | 0;
          c2[e4 >> 2] = 0;
          c2[d4 >> 2] = c2[e4 >> 2];
          Ji(i4, h3, d4);
          c2[f4 >> 2] = i4;
          l3 = j4;
          return g3 | 0;
        }
        function Ji(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          c2[a3 >> 2] = b3;
          d4 = qC(16) | 0;
          c2[d4 + 4 >> 2] = 0;
          c2[d4 + 8 >> 2] = 0;
          c2[d4 >> 2] = 1092;
          c2[d4 + 12 >> 2] = b3;
          c2[a3 + 4 >> 2] = d4;
          return;
        }
        function Ki(a3) {
          a3 = a3 | 0;
          kC(a3);
          sC(a3);
          return;
        }
        function Li(a3) {
          a3 = a3 | 0;
          a3 = c2[a3 + 12 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function Mi(a3) {
          a3 = a3 | 0;
          sC(a3);
          return;
        }
        function Ni(a3, b3, d4, e4, f4, g3, h3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          g3 = g3 | 0;
          h3 = h3 | 0;
          g3 = Oi(c2[a3 >> 2] | 0, b3, d4, e4, f4, g3, h3) | 0;
          h3 = a3 + 4 | 0;
          c2[(c2[h3 >> 2] | 0) + 8 >> 2] = g3;
          return c2[(c2[h3 >> 2] | 0) + 8 >> 2] | 0;
        }
        function Oi(a3, b3, c3, d4, e4, f4, g3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          g3 = g3 | 0;
          var i4 = 0, j4 = 0;
          i4 = l3;
          l3 = l3 + 16 | 0;
          j4 = i4;
          UA(j4);
          a3 = Sg(a3) | 0;
          g3 = Pi(a3, +h2[b3 >> 3], +h2[c3 >> 3], +h2[d4 >> 3], +h2[e4 >> 3], +h2[f4 >> 3], +h2[g3 >> 3]) | 0;
          WA(j4);
          l3 = i4;
          return g3 | 0;
        }
        function Pi(a3, b3, c3, d4, e4, f4, g3) {
          a3 = a3 | 0;
          b3 = +b3;
          c3 = +c3;
          d4 = +d4;
          e4 = +e4;
          f4 = +f4;
          g3 = +g3;
          var h3 = 0;
          h3 = Vg(Qi() | 0) | 0;
          b3 = +Wg(b3);
          c3 = +Wg(c3);
          d4 = +Wg(d4);
          e4 = +Wg(e4);
          f4 = +Wg(f4);
          return ya(0, h3 | 0, a3 | 0, +b3, +c3, +d4, +e4, +f4, + +Wg(g3)) | 0;
        }
        function Qi() {
          var b3 = 0;
          if (!(a2[7624] | 0)) {
            Ri(9172);
            b3 = 7624;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          return 9172;
        }
        function Ri(a3) {
          a3 = a3 | 0;
          fh(a3, Si() | 0, 6);
          return;
        }
        function Si() {
          return 1112;
        }
        function Ti(a3) {
          a3 = a3 | 0;
          Zi(a3);
          return;
        }
        function Ui(a3) {
          a3 = a3 | 0;
          Vi(a3 + 24 | 0);
          Wi(a3 + 16 | 0);
          return;
        }
        function Vi(a3) {
          a3 = a3 | 0;
          Yi(a3);
          return;
        }
        function Wi(a3) {
          a3 = a3 | 0;
          Xi(a3);
          return;
        }
        function Xi(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0;
          b3 = c2[a3 >> 2] | 0;
          if (b3 | 0)
            do {
              d4 = b3;
              b3 = c2[b3 >> 2] | 0;
              sC(d4);
            } while ((b3 | 0) != 0);
          c2[a3 >> 2] = 0;
          return;
        }
        function Yi(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0;
          b3 = c2[a3 >> 2] | 0;
          if (b3 | 0)
            do {
              d4 = b3;
              b3 = c2[b3 >> 2] | 0;
              sC(d4);
            } while ((b3 | 0) != 0);
          c2[a3 >> 2] = 0;
          return;
        }
        function Zi(b3) {
          b3 = b3 | 0;
          var d4 = 0;
          c2[b3 + 16 >> 2] = 0;
          c2[b3 + 20 >> 2] = 0;
          d4 = b3 + 24 | 0;
          c2[d4 >> 2] = 0;
          c2[b3 + 28 >> 2] = d4;
          c2[b3 + 36 >> 2] = 0;
          a2[b3 + 40 >> 0] = 0;
          a2[b3 + 41 >> 0] = 0;
          return;
        }
        function _i(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          i4 = c2[d4 >> 2] | 0;
          h3 = c2[d4 + 4 >> 2] | 0;
          d4 = ai(b3) | 0;
          c2[g3 >> 2] = i4;
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          $i(a3, d4, f4, 0);
          l3 = e4;
          return;
        }
        function $i(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4 + 16 | 0;
          m4 = f4 + 8 | 0;
          i4 = f4;
          k4 = c2[d4 >> 2] | 0;
          j4 = c2[d4 + 4 >> 2] | 0;
          h3 = c2[a3 >> 2] | 0;
          a3 = aj() | 0;
          c2[m4 >> 2] = k4;
          c2[m4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[m4 >> 2];
          c2[g3 + 4 >> 2] = c2[m4 + 4 >> 2];
          d4 = bj(g3) | 0;
          c2[i4 >> 2] = k4;
          c2[i4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[i4 >> 2];
          c2[g3 + 4 >> 2] = c2[i4 + 4 >> 2];
          fi(h3, b3, a3, d4, cj(g3, e4) | 0, e4);
          l3 = f4;
          return;
        }
        function aj() {
          var b3 = 0, d4 = 0;
          if (!(a2[7640] | 0)) {
            jj(9232);
            Ha(26, 9232, o2 | 0) | 0;
            d4 = 7640;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(9232) | 0)) {
            b3 = 9232;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            jj(9232);
          }
          return 9232;
        }
        function bj(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function cj(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          m4 = l3;
          l3 = l3 + 32 | 0;
          f4 = m4 + 24 | 0;
          h3 = m4 + 16 | 0;
          i4 = m4;
          j4 = m4 + 8 | 0;
          g3 = c2[a3 >> 2] | 0;
          e4 = c2[a3 + 4 >> 2] | 0;
          c2[i4 >> 2] = g3;
          c2[i4 + 4 >> 2] = e4;
          n3 = aj() | 0;
          k4 = n3 + 24 | 0;
          a3 = ji(b3, 4) | 0;
          c2[j4 >> 2] = a3;
          b3 = n3 + 28 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 >>> 0 < (c2[n3 + 32 >> 2] | 0) >>> 0) {
            c2[h3 >> 2] = g3;
            c2[h3 + 4 >> 2] = e4;
            c2[f4 >> 2] = c2[h3 >> 2];
            c2[f4 + 4 >> 2] = c2[h3 + 4 >> 2];
            dj(d4, f4, a3);
            a3 = (c2[b3 >> 2] | 0) + 12 | 0;
            c2[b3 >> 2] = a3;
          } else {
            ej(k4, i4, j4);
            a3 = c2[b3 >> 2] | 0;
          }
          l3 = m4;
          return ((a3 - (c2[k4 >> 2] | 0) | 0) / 12 | 0) + -1 | 0;
        }
        function dj(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = c2[b3 + 4 >> 2] | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 8 >> 2] = d4;
          return;
        }
        function ej(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0;
          k4 = l3;
          l3 = l3 + 48 | 0;
          e4 = k4 + 32 | 0;
          h3 = k4 + 24 | 0;
          i4 = k4;
          j4 = a3 + 4 | 0;
          f4 = (((c2[j4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
          g3 = fj(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            m4 = c2[a3 >> 2] | 0;
            o3 = ((c2[a3 + 8 >> 2] | 0) - m4 | 0) / 12 | 0;
            n3 = o3 << 1;
            gj(i4, o3 >>> 0 < g3 >>> 1 >>> 0 ? n3 >>> 0 < f4 >>> 0 ? f4 : n3 : g3, ((c2[j4 >> 2] | 0) - m4 | 0) / 12 | 0, a3 + 8 | 0);
            j4 = i4 + 8 | 0;
            g3 = c2[j4 >> 2] | 0;
            f4 = c2[b3 + 4 >> 2] | 0;
            d4 = c2[d4 >> 2] | 0;
            c2[h3 >> 2] = c2[b3 >> 2];
            c2[h3 + 4 >> 2] = f4;
            c2[e4 >> 2] = c2[h3 >> 2];
            c2[e4 + 4 >> 2] = c2[h3 + 4 >> 2];
            dj(g3, e4, d4);
            c2[j4 >> 2] = (c2[j4 >> 2] | 0) + 12;
            hj(a3, i4);
            ij(i4);
            l3 = k4;
            return;
          }
        }
        function fj(a3) {
          a3 = a3 | 0;
          return 357913941;
        }
        function gj(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 357913941)
                Ta();
              else {
                f4 = qC(b3 * 12 | 0) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 * 12 | 0) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 * 12 | 0);
          return;
        }
        function hj(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (((f4 | 0) / -12 | 0) * 12 | 0) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function ij(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~(((e4 + -12 - b3 | 0) >>> 0) / 12 | 0) * 12 | 0);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function jj(a3) {
          a3 = a3 | 0;
          mj(a3);
          return;
        }
        function kj(a3) {
          a3 = a3 | 0;
          lj(a3 + 24 | 0);
          return;
        }
        function lj(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~(((b3 + -12 - e4 | 0) >>> 0) / 12 | 0) * 12 | 0);
            sC(d4);
          }
          return;
        }
        function mj(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 2, 1, b3, nj() | 0, 3);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function nj() {
          return 1144;
        }
        function oj(a3, b3, d4, e4, f4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = +d4;
          e4 = +e4;
          f4 = f4 | 0;
          var g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          g3 = l3;
          l3 = l3 + 16 | 0;
          h3 = g3 + 8 | 0;
          i4 = g3;
          j4 = pj(a3) | 0;
          a3 = c2[j4 + 4 >> 2] | 0;
          c2[i4 >> 2] = c2[j4 >> 2];
          c2[i4 + 4 >> 2] = a3;
          c2[h3 >> 2] = c2[i4 >> 2];
          c2[h3 + 4 >> 2] = c2[i4 + 4 >> 2];
          qj(b3, h3, d4, e4, f4);
          l3 = g3;
          return;
        }
        function pj(a3) {
          a3 = a3 | 0;
          return (c2[(aj() | 0) + 24 >> 2] | 0) + (a3 * 12 | 0) | 0;
        }
        function qj(a3, b3, d4, e4, f4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = +d4;
          e4 = +e4;
          f4 = f4 | 0;
          var g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0;
          k4 = l3;
          l3 = l3 + 16 | 0;
          h3 = k4 + 2 | 0;
          i4 = k4 + 1 | 0;
          j4 = k4;
          g3 = c2[b3 >> 2] | 0;
          b3 = c2[b3 + 4 >> 2] | 0;
          a3 = a3 + (b3 >> 1) | 0;
          if (b3 & 1)
            g3 = c2[(c2[a3 >> 2] | 0) + g3 >> 2] | 0;
          rj(h3, d4);
          d4 = +sj(h3, d4);
          rj(i4, e4);
          e4 = +sj(i4, e4);
          tj(j4, f4);
          j4 = uj(j4, f4) | 0;
          qb[g3 & 1](a3, d4, e4, j4);
          l3 = k4;
          return;
        }
        function rj(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          return;
        }
        function sj(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          return + +wj(b3);
        }
        function tj(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return;
        }
        function uj(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return vj(b3) | 0;
        }
        function vj(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function wj(a3) {
          a3 = +a3;
          return +a3;
        }
        function xj(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          i4 = c2[d4 >> 2] | 0;
          h3 = c2[d4 + 4 >> 2] | 0;
          d4 = ai(b3) | 0;
          c2[g3 >> 2] = i4;
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          yj(a3, d4, f4, 1);
          l3 = e4;
          return;
        }
        function yj(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4 + 16 | 0;
          m4 = f4 + 8 | 0;
          i4 = f4;
          k4 = c2[d4 >> 2] | 0;
          j4 = c2[d4 + 4 >> 2] | 0;
          h3 = c2[a3 >> 2] | 0;
          a3 = zj() | 0;
          c2[m4 >> 2] = k4;
          c2[m4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[m4 >> 2];
          c2[g3 + 4 >> 2] = c2[m4 + 4 >> 2];
          d4 = Aj(g3) | 0;
          c2[i4 >> 2] = k4;
          c2[i4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[i4 >> 2];
          c2[g3 + 4 >> 2] = c2[i4 + 4 >> 2];
          fi(h3, b3, a3, d4, Bj(g3, e4) | 0, e4);
          l3 = f4;
          return;
        }
        function zj() {
          var b3 = 0, d4 = 0;
          if (!(a2[7648] | 0)) {
            Ij(9268);
            Ha(27, 9268, o2 | 0) | 0;
            d4 = 7648;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(9268) | 0)) {
            b3 = 9268;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            Ij(9268);
          }
          return 9268;
        }
        function Aj(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function Bj(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          m4 = l3;
          l3 = l3 + 32 | 0;
          f4 = m4 + 24 | 0;
          h3 = m4 + 16 | 0;
          i4 = m4;
          j4 = m4 + 8 | 0;
          g3 = c2[a3 >> 2] | 0;
          e4 = c2[a3 + 4 >> 2] | 0;
          c2[i4 >> 2] = g3;
          c2[i4 + 4 >> 2] = e4;
          n3 = zj() | 0;
          k4 = n3 + 24 | 0;
          a3 = ji(b3, 4) | 0;
          c2[j4 >> 2] = a3;
          b3 = n3 + 28 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 >>> 0 < (c2[n3 + 32 >> 2] | 0) >>> 0) {
            c2[h3 >> 2] = g3;
            c2[h3 + 4 >> 2] = e4;
            c2[f4 >> 2] = c2[h3 >> 2];
            c2[f4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Cj(d4, f4, a3);
            a3 = (c2[b3 >> 2] | 0) + 12 | 0;
            c2[b3 >> 2] = a3;
          } else {
            Dj(k4, i4, j4);
            a3 = c2[b3 >> 2] | 0;
          }
          l3 = m4;
          return ((a3 - (c2[k4 >> 2] | 0) | 0) / 12 | 0) + -1 | 0;
        }
        function Cj(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = c2[b3 + 4 >> 2] | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 8 >> 2] = d4;
          return;
        }
        function Dj(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0;
          k4 = l3;
          l3 = l3 + 48 | 0;
          e4 = k4 + 32 | 0;
          h3 = k4 + 24 | 0;
          i4 = k4;
          j4 = a3 + 4 | 0;
          f4 = (((c2[j4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
          g3 = Ej(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            m4 = c2[a3 >> 2] | 0;
            o3 = ((c2[a3 + 8 >> 2] | 0) - m4 | 0) / 12 | 0;
            n3 = o3 << 1;
            Fj(i4, o3 >>> 0 < g3 >>> 1 >>> 0 ? n3 >>> 0 < f4 >>> 0 ? f4 : n3 : g3, ((c2[j4 >> 2] | 0) - m4 | 0) / 12 | 0, a3 + 8 | 0);
            j4 = i4 + 8 | 0;
            g3 = c2[j4 >> 2] | 0;
            f4 = c2[b3 + 4 >> 2] | 0;
            d4 = c2[d4 >> 2] | 0;
            c2[h3 >> 2] = c2[b3 >> 2];
            c2[h3 + 4 >> 2] = f4;
            c2[e4 >> 2] = c2[h3 >> 2];
            c2[e4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Cj(g3, e4, d4);
            c2[j4 >> 2] = (c2[j4 >> 2] | 0) + 12;
            Gj(a3, i4);
            Hj(i4);
            l3 = k4;
            return;
          }
        }
        function Ej(a3) {
          a3 = a3 | 0;
          return 357913941;
        }
        function Fj(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 357913941)
                Ta();
              else {
                f4 = qC(b3 * 12 | 0) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 * 12 | 0) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 * 12 | 0);
          return;
        }
        function Gj(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (((f4 | 0) / -12 | 0) * 12 | 0) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function Hj(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~(((e4 + -12 - b3 | 0) >>> 0) / 12 | 0) * 12 | 0);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function Ij(a3) {
          a3 = a3 | 0;
          Lj(a3);
          return;
        }
        function Jj(a3) {
          a3 = a3 | 0;
          Kj(a3 + 24 | 0);
          return;
        }
        function Kj(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~(((b3 + -12 - e4 | 0) >>> 0) / 12 | 0) * 12 | 0);
            sC(d4);
          }
          return;
        }
        function Lj(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 2, 4, b3, Mj() | 0, 0);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function Mj() {
          return 1160;
        }
        function Nj(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0;
          d4 = l3;
          l3 = l3 + 16 | 0;
          e4 = d4 + 8 | 0;
          f4 = d4;
          g3 = Oj(a3) | 0;
          a3 = c2[g3 + 4 >> 2] | 0;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = a3;
          c2[e4 >> 2] = c2[f4 >> 2];
          c2[e4 + 4 >> 2] = c2[f4 + 4 >> 2];
          b3 = Pj(b3, e4) | 0;
          l3 = d4;
          return b3 | 0;
        }
        function Oj(a3) {
          a3 = a3 | 0;
          return (c2[(zj() | 0) + 24 >> 2] | 0) + (a3 * 12 | 0) | 0;
        }
        function Pj(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = c2[b3 >> 2] | 0;
          b3 = c2[b3 + 4 >> 2] | 0;
          a3 = a3 + (b3 >> 1) | 0;
          if (b3 & 1)
            d4 = c2[(c2[a3 >> 2] | 0) + d4 >> 2] | 0;
          return Qj(pb[d4 & 31](a3) | 0) | 0;
        }
        function Qj(a3) {
          a3 = a3 | 0;
          return a3 & 1 | 0;
        }
        function Rj(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          i4 = c2[d4 >> 2] | 0;
          h3 = c2[d4 + 4 >> 2] | 0;
          d4 = ai(b3) | 0;
          c2[g3 >> 2] = i4;
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Sj(a3, d4, f4, 0);
          l3 = e4;
          return;
        }
        function Sj(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4 + 16 | 0;
          m4 = f4 + 8 | 0;
          i4 = f4;
          k4 = c2[d4 >> 2] | 0;
          j4 = c2[d4 + 4 >> 2] | 0;
          h3 = c2[a3 >> 2] | 0;
          a3 = Tj() | 0;
          c2[m4 >> 2] = k4;
          c2[m4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[m4 >> 2];
          c2[g3 + 4 >> 2] = c2[m4 + 4 >> 2];
          d4 = Uj(g3) | 0;
          c2[i4 >> 2] = k4;
          c2[i4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[i4 >> 2];
          c2[g3 + 4 >> 2] = c2[i4 + 4 >> 2];
          fi(h3, b3, a3, d4, Vj(g3, e4) | 0, e4);
          l3 = f4;
          return;
        }
        function Tj() {
          var b3 = 0, d4 = 0;
          if (!(a2[7656] | 0)) {
            ak(9304);
            Ha(28, 9304, o2 | 0) | 0;
            d4 = 7656;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(9304) | 0)) {
            b3 = 9304;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            ak(9304);
          }
          return 9304;
        }
        function Uj(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function Vj(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          m4 = l3;
          l3 = l3 + 32 | 0;
          f4 = m4 + 24 | 0;
          h3 = m4 + 16 | 0;
          i4 = m4;
          j4 = m4 + 8 | 0;
          g3 = c2[a3 >> 2] | 0;
          e4 = c2[a3 + 4 >> 2] | 0;
          c2[i4 >> 2] = g3;
          c2[i4 + 4 >> 2] = e4;
          n3 = Tj() | 0;
          k4 = n3 + 24 | 0;
          a3 = ji(b3, 4) | 0;
          c2[j4 >> 2] = a3;
          b3 = n3 + 28 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 >>> 0 < (c2[n3 + 32 >> 2] | 0) >>> 0) {
            c2[h3 >> 2] = g3;
            c2[h3 + 4 >> 2] = e4;
            c2[f4 >> 2] = c2[h3 >> 2];
            c2[f4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Wj(d4, f4, a3);
            a3 = (c2[b3 >> 2] | 0) + 12 | 0;
            c2[b3 >> 2] = a3;
          } else {
            Xj(k4, i4, j4);
            a3 = c2[b3 >> 2] | 0;
          }
          l3 = m4;
          return ((a3 - (c2[k4 >> 2] | 0) | 0) / 12 | 0) + -1 | 0;
        }
        function Wj(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = c2[b3 + 4 >> 2] | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 8 >> 2] = d4;
          return;
        }
        function Xj(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0;
          k4 = l3;
          l3 = l3 + 48 | 0;
          e4 = k4 + 32 | 0;
          h3 = k4 + 24 | 0;
          i4 = k4;
          j4 = a3 + 4 | 0;
          f4 = (((c2[j4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
          g3 = Yj(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            m4 = c2[a3 >> 2] | 0;
            o3 = ((c2[a3 + 8 >> 2] | 0) - m4 | 0) / 12 | 0;
            n3 = o3 << 1;
            Zj(i4, o3 >>> 0 < g3 >>> 1 >>> 0 ? n3 >>> 0 < f4 >>> 0 ? f4 : n3 : g3, ((c2[j4 >> 2] | 0) - m4 | 0) / 12 | 0, a3 + 8 | 0);
            j4 = i4 + 8 | 0;
            g3 = c2[j4 >> 2] | 0;
            f4 = c2[b3 + 4 >> 2] | 0;
            d4 = c2[d4 >> 2] | 0;
            c2[h3 >> 2] = c2[b3 >> 2];
            c2[h3 + 4 >> 2] = f4;
            c2[e4 >> 2] = c2[h3 >> 2];
            c2[e4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Wj(g3, e4, d4);
            c2[j4 >> 2] = (c2[j4 >> 2] | 0) + 12;
            _j(a3, i4);
            $j(i4);
            l3 = k4;
            return;
          }
        }
        function Yj(a3) {
          a3 = a3 | 0;
          return 357913941;
        }
        function Zj(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 357913941)
                Ta();
              else {
                f4 = qC(b3 * 12 | 0) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 * 12 | 0) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 * 12 | 0);
          return;
        }
        function _j(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (((f4 | 0) / -12 | 0) * 12 | 0) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function $j(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~(((e4 + -12 - b3 | 0) >>> 0) / 12 | 0) * 12 | 0);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function ak(a3) {
          a3 = a3 | 0;
          dk(a3);
          return;
        }
        function bk(a3) {
          a3 = a3 | 0;
          ck(a3 + 24 | 0);
          return;
        }
        function ck(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~(((b3 + -12 - e4 | 0) >>> 0) / 12 | 0) * 12 | 0);
            sC(d4);
          }
          return;
        }
        function dk(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 2, 5, b3, ek() | 0, 1);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function ek() {
          return 1164;
        }
        function fk(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = gk(a3) | 0;
          a3 = c2[h3 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[g3 + 4 >> 2] = a3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          hk(b3, f4, d4);
          l3 = e4;
          return;
        }
        function gk(a3) {
          a3 = a3 | 0;
          return (c2[(Tj() | 0) + 24 >> 2] | 0) + (a3 * 12 | 0) | 0;
        }
        function hk(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0;
          g3 = l3;
          l3 = l3 + 16 | 0;
          f4 = g3;
          e4 = c2[b3 >> 2] | 0;
          b3 = c2[b3 + 4 >> 2] | 0;
          a3 = a3 + (b3 >> 1) | 0;
          if (b3 & 1)
            e4 = c2[(c2[a3 >> 2] | 0) + e4 >> 2] | 0;
          ik(f4, d4);
          d4 = jk(f4, d4) | 0;
          ob[e4 & 31](a3, d4);
          kk(f4);
          l3 = g3;
          return;
        }
        function ik(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          lk(a3, b3);
          return;
        }
        function jk(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return a3 | 0;
        }
        function kk(a3) {
          a3 = a3 | 0;
          vf(a3);
          return;
        }
        function lk(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          mk(a3, b3);
          return;
        }
        function mk(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c2[a3 >> 2] = b3;
          return;
        }
        function nk(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          i4 = c2[d4 >> 2] | 0;
          h3 = c2[d4 + 4 >> 2] | 0;
          d4 = ai(b3) | 0;
          c2[g3 >> 2] = i4;
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          ok(a3, d4, f4, 0);
          l3 = e4;
          return;
        }
        function ok(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4 + 16 | 0;
          m4 = f4 + 8 | 0;
          i4 = f4;
          k4 = c2[d4 >> 2] | 0;
          j4 = c2[d4 + 4 >> 2] | 0;
          h3 = c2[a3 >> 2] | 0;
          a3 = pk() | 0;
          c2[m4 >> 2] = k4;
          c2[m4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[m4 >> 2];
          c2[g3 + 4 >> 2] = c2[m4 + 4 >> 2];
          d4 = qk(g3) | 0;
          c2[i4 >> 2] = k4;
          c2[i4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[i4 >> 2];
          c2[g3 + 4 >> 2] = c2[i4 + 4 >> 2];
          fi(h3, b3, a3, d4, rk(g3, e4) | 0, e4);
          l3 = f4;
          return;
        }
        function pk() {
          var b3 = 0, d4 = 0;
          if (!(a2[7664] | 0)) {
            yk(9340);
            Ha(29, 9340, o2 | 0) | 0;
            d4 = 7664;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(9340) | 0)) {
            b3 = 9340;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            yk(9340);
          }
          return 9340;
        }
        function qk(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function rk(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          m4 = l3;
          l3 = l3 + 32 | 0;
          f4 = m4 + 24 | 0;
          h3 = m4 + 16 | 0;
          i4 = m4;
          j4 = m4 + 8 | 0;
          g3 = c2[a3 >> 2] | 0;
          e4 = c2[a3 + 4 >> 2] | 0;
          c2[i4 >> 2] = g3;
          c2[i4 + 4 >> 2] = e4;
          n3 = pk() | 0;
          k4 = n3 + 24 | 0;
          a3 = ji(b3, 4) | 0;
          c2[j4 >> 2] = a3;
          b3 = n3 + 28 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 >>> 0 < (c2[n3 + 32 >> 2] | 0) >>> 0) {
            c2[h3 >> 2] = g3;
            c2[h3 + 4 >> 2] = e4;
            c2[f4 >> 2] = c2[h3 >> 2];
            c2[f4 + 4 >> 2] = c2[h3 + 4 >> 2];
            sk(d4, f4, a3);
            a3 = (c2[b3 >> 2] | 0) + 12 | 0;
            c2[b3 >> 2] = a3;
          } else {
            tk(k4, i4, j4);
            a3 = c2[b3 >> 2] | 0;
          }
          l3 = m4;
          return ((a3 - (c2[k4 >> 2] | 0) | 0) / 12 | 0) + -1 | 0;
        }
        function sk(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = c2[b3 + 4 >> 2] | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 8 >> 2] = d4;
          return;
        }
        function tk(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0;
          k4 = l3;
          l3 = l3 + 48 | 0;
          e4 = k4 + 32 | 0;
          h3 = k4 + 24 | 0;
          i4 = k4;
          j4 = a3 + 4 | 0;
          f4 = (((c2[j4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
          g3 = uk(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            m4 = c2[a3 >> 2] | 0;
            o3 = ((c2[a3 + 8 >> 2] | 0) - m4 | 0) / 12 | 0;
            n3 = o3 << 1;
            vk(i4, o3 >>> 0 < g3 >>> 1 >>> 0 ? n3 >>> 0 < f4 >>> 0 ? f4 : n3 : g3, ((c2[j4 >> 2] | 0) - m4 | 0) / 12 | 0, a3 + 8 | 0);
            j4 = i4 + 8 | 0;
            g3 = c2[j4 >> 2] | 0;
            f4 = c2[b3 + 4 >> 2] | 0;
            d4 = c2[d4 >> 2] | 0;
            c2[h3 >> 2] = c2[b3 >> 2];
            c2[h3 + 4 >> 2] = f4;
            c2[e4 >> 2] = c2[h3 >> 2];
            c2[e4 + 4 >> 2] = c2[h3 + 4 >> 2];
            sk(g3, e4, d4);
            c2[j4 >> 2] = (c2[j4 >> 2] | 0) + 12;
            wk(a3, i4);
            xk(i4);
            l3 = k4;
            return;
          }
        }
        function uk(a3) {
          a3 = a3 | 0;
          return 357913941;
        }
        function vk(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 357913941)
                Ta();
              else {
                f4 = qC(b3 * 12 | 0) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 * 12 | 0) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 * 12 | 0);
          return;
        }
        function wk(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (((f4 | 0) / -12 | 0) * 12 | 0) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function xk(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~(((e4 + -12 - b3 | 0) >>> 0) / 12 | 0) * 12 | 0);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function yk(a3) {
          a3 = a3 | 0;
          Bk(a3);
          return;
        }
        function zk(a3) {
          a3 = a3 | 0;
          Ak(a3 + 24 | 0);
          return;
        }
        function Ak(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~(((b3 + -12 - e4 | 0) >>> 0) / 12 | 0) * 12 | 0);
            sC(d4);
          }
          return;
        }
        function Bk(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 2, 4, b3, Ck() | 0, 1);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function Ck() {
          return 1180;
        }
        function Dk(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = Ek(a3) | 0;
          a3 = c2[h3 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[g3 + 4 >> 2] = a3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          d4 = Fk(b3, f4, d4) | 0;
          l3 = e4;
          return d4 | 0;
        }
        function Ek(a3) {
          a3 = a3 | 0;
          return (c2[(pk() | 0) + 24 >> 2] | 0) + (a3 * 12 | 0) | 0;
        }
        function Fk(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0;
          g3 = l3;
          l3 = l3 + 16 | 0;
          f4 = g3;
          e4 = c2[b3 >> 2] | 0;
          b3 = c2[b3 + 4 >> 2] | 0;
          a3 = a3 + (b3 >> 1) | 0;
          if (b3 & 1)
            e4 = c2[(c2[a3 >> 2] | 0) + e4 >> 2] | 0;
          Gk(f4, d4);
          f4 = Hk(f4, d4) | 0;
          f4 = Ik(wb[e4 & 15](a3, f4) | 0) | 0;
          l3 = g3;
          return f4 | 0;
        }
        function Gk(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return;
        }
        function Hk(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return Jk(b3) | 0;
        }
        function Ik(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function Jk(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function Kk(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          i4 = c2[d4 >> 2] | 0;
          h3 = c2[d4 + 4 >> 2] | 0;
          d4 = ai(b3) | 0;
          c2[g3 >> 2] = i4;
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Lk(a3, d4, f4, 0);
          l3 = e4;
          return;
        }
        function Lk(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4 + 16 | 0;
          m4 = f4 + 8 | 0;
          i4 = f4;
          k4 = c2[d4 >> 2] | 0;
          j4 = c2[d4 + 4 >> 2] | 0;
          h3 = c2[a3 >> 2] | 0;
          a3 = Mk() | 0;
          c2[m4 >> 2] = k4;
          c2[m4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[m4 >> 2];
          c2[g3 + 4 >> 2] = c2[m4 + 4 >> 2];
          d4 = Nk(g3) | 0;
          c2[i4 >> 2] = k4;
          c2[i4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[i4 >> 2];
          c2[g3 + 4 >> 2] = c2[i4 + 4 >> 2];
          fi(h3, b3, a3, d4, Ok(g3, e4) | 0, e4);
          l3 = f4;
          return;
        }
        function Mk() {
          var b3 = 0, d4 = 0;
          if (!(a2[7672] | 0)) {
            Vk(9376);
            Ha(30, 9376, o2 | 0) | 0;
            d4 = 7672;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(9376) | 0)) {
            b3 = 9376;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            Vk(9376);
          }
          return 9376;
        }
        function Nk(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function Ok(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          m4 = l3;
          l3 = l3 + 32 | 0;
          f4 = m4 + 24 | 0;
          h3 = m4 + 16 | 0;
          i4 = m4;
          j4 = m4 + 8 | 0;
          g3 = c2[a3 >> 2] | 0;
          e4 = c2[a3 + 4 >> 2] | 0;
          c2[i4 >> 2] = g3;
          c2[i4 + 4 >> 2] = e4;
          n3 = Mk() | 0;
          k4 = n3 + 24 | 0;
          a3 = ji(b3, 4) | 0;
          c2[j4 >> 2] = a3;
          b3 = n3 + 28 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 >>> 0 < (c2[n3 + 32 >> 2] | 0) >>> 0) {
            c2[h3 >> 2] = g3;
            c2[h3 + 4 >> 2] = e4;
            c2[f4 >> 2] = c2[h3 >> 2];
            c2[f4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Pk(d4, f4, a3);
            a3 = (c2[b3 >> 2] | 0) + 12 | 0;
            c2[b3 >> 2] = a3;
          } else {
            Qk(k4, i4, j4);
            a3 = c2[b3 >> 2] | 0;
          }
          l3 = m4;
          return ((a3 - (c2[k4 >> 2] | 0) | 0) / 12 | 0) + -1 | 0;
        }
        function Pk(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = c2[b3 + 4 >> 2] | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 8 >> 2] = d4;
          return;
        }
        function Qk(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0;
          k4 = l3;
          l3 = l3 + 48 | 0;
          e4 = k4 + 32 | 0;
          h3 = k4 + 24 | 0;
          i4 = k4;
          j4 = a3 + 4 | 0;
          f4 = (((c2[j4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
          g3 = Rk(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            m4 = c2[a3 >> 2] | 0;
            o3 = ((c2[a3 + 8 >> 2] | 0) - m4 | 0) / 12 | 0;
            n3 = o3 << 1;
            Sk(i4, o3 >>> 0 < g3 >>> 1 >>> 0 ? n3 >>> 0 < f4 >>> 0 ? f4 : n3 : g3, ((c2[j4 >> 2] | 0) - m4 | 0) / 12 | 0, a3 + 8 | 0);
            j4 = i4 + 8 | 0;
            g3 = c2[j4 >> 2] | 0;
            f4 = c2[b3 + 4 >> 2] | 0;
            d4 = c2[d4 >> 2] | 0;
            c2[h3 >> 2] = c2[b3 >> 2];
            c2[h3 + 4 >> 2] = f4;
            c2[e4 >> 2] = c2[h3 >> 2];
            c2[e4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Pk(g3, e4, d4);
            c2[j4 >> 2] = (c2[j4 >> 2] | 0) + 12;
            Tk(a3, i4);
            Uk(i4);
            l3 = k4;
            return;
          }
        }
        function Rk(a3) {
          a3 = a3 | 0;
          return 357913941;
        }
        function Sk(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 357913941)
                Ta();
              else {
                f4 = qC(b3 * 12 | 0) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 * 12 | 0) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 * 12 | 0);
          return;
        }
        function Tk(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (((f4 | 0) / -12 | 0) * 12 | 0) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function Uk(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~(((e4 + -12 - b3 | 0) >>> 0) / 12 | 0) * 12 | 0);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function Vk(a3) {
          a3 = a3 | 0;
          Yk(a3);
          return;
        }
        function Wk(a3) {
          a3 = a3 | 0;
          Xk(a3 + 24 | 0);
          return;
        }
        function Xk(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~(((b3 + -12 - e4 | 0) >>> 0) / 12 | 0) * 12 | 0);
            sC(d4);
          }
          return;
        }
        function Yk(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 2, 5, b3, Zk() | 0, 0);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function Zk() {
          return 1196;
        }
        function _k(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0;
          d4 = l3;
          l3 = l3 + 16 | 0;
          e4 = d4 + 8 | 0;
          f4 = d4;
          g3 = $k(a3) | 0;
          a3 = c2[g3 + 4 >> 2] | 0;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = a3;
          c2[e4 >> 2] = c2[f4 >> 2];
          c2[e4 + 4 >> 2] = c2[f4 + 4 >> 2];
          b3 = al(b3, e4) | 0;
          l3 = d4;
          return b3 | 0;
        }
        function $k(a3) {
          a3 = a3 | 0;
          return (c2[(Mk() | 0) + 24 >> 2] | 0) + (a3 * 12 | 0) | 0;
        }
        function al(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = c2[b3 >> 2] | 0;
          b3 = c2[b3 + 4 >> 2] | 0;
          a3 = a3 + (b3 >> 1) | 0;
          if (b3 & 1)
            d4 = c2[(c2[a3 >> 2] | 0) + d4 >> 2] | 0;
          return Ik(pb[d4 & 31](a3) | 0) | 0;
        }
        function bl(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          i4 = c2[d4 >> 2] | 0;
          h3 = c2[d4 + 4 >> 2] | 0;
          d4 = ai(b3) | 0;
          c2[g3 >> 2] = i4;
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          cl(a3, d4, f4, 1);
          l3 = e4;
          return;
        }
        function cl(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4 + 16 | 0;
          m4 = f4 + 8 | 0;
          i4 = f4;
          k4 = c2[d4 >> 2] | 0;
          j4 = c2[d4 + 4 >> 2] | 0;
          h3 = c2[a3 >> 2] | 0;
          a3 = dl() | 0;
          c2[m4 >> 2] = k4;
          c2[m4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[m4 >> 2];
          c2[g3 + 4 >> 2] = c2[m4 + 4 >> 2];
          d4 = el(g3) | 0;
          c2[i4 >> 2] = k4;
          c2[i4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[i4 >> 2];
          c2[g3 + 4 >> 2] = c2[i4 + 4 >> 2];
          fi(h3, b3, a3, d4, fl(g3, e4) | 0, e4);
          l3 = f4;
          return;
        }
        function dl() {
          var b3 = 0, d4 = 0;
          if (!(a2[7680] | 0)) {
            ml(9412);
            Ha(31, 9412, o2 | 0) | 0;
            d4 = 7680;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(9412) | 0)) {
            b3 = 9412;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            ml(9412);
          }
          return 9412;
        }
        function el(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function fl(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          m4 = l3;
          l3 = l3 + 32 | 0;
          f4 = m4 + 24 | 0;
          h3 = m4 + 16 | 0;
          i4 = m4;
          j4 = m4 + 8 | 0;
          g3 = c2[a3 >> 2] | 0;
          e4 = c2[a3 + 4 >> 2] | 0;
          c2[i4 >> 2] = g3;
          c2[i4 + 4 >> 2] = e4;
          n3 = dl() | 0;
          k4 = n3 + 24 | 0;
          a3 = ji(b3, 4) | 0;
          c2[j4 >> 2] = a3;
          b3 = n3 + 28 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 >>> 0 < (c2[n3 + 32 >> 2] | 0) >>> 0) {
            c2[h3 >> 2] = g3;
            c2[h3 + 4 >> 2] = e4;
            c2[f4 >> 2] = c2[h3 >> 2];
            c2[f4 + 4 >> 2] = c2[h3 + 4 >> 2];
            gl(d4, f4, a3);
            a3 = (c2[b3 >> 2] | 0) + 12 | 0;
            c2[b3 >> 2] = a3;
          } else {
            hl(k4, i4, j4);
            a3 = c2[b3 >> 2] | 0;
          }
          l3 = m4;
          return ((a3 - (c2[k4 >> 2] | 0) | 0) / 12 | 0) + -1 | 0;
        }
        function gl(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = c2[b3 + 4 >> 2] | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 8 >> 2] = d4;
          return;
        }
        function hl(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0;
          k4 = l3;
          l3 = l3 + 48 | 0;
          e4 = k4 + 32 | 0;
          h3 = k4 + 24 | 0;
          i4 = k4;
          j4 = a3 + 4 | 0;
          f4 = (((c2[j4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
          g3 = il(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            m4 = c2[a3 >> 2] | 0;
            o3 = ((c2[a3 + 8 >> 2] | 0) - m4 | 0) / 12 | 0;
            n3 = o3 << 1;
            jl(i4, o3 >>> 0 < g3 >>> 1 >>> 0 ? n3 >>> 0 < f4 >>> 0 ? f4 : n3 : g3, ((c2[j4 >> 2] | 0) - m4 | 0) / 12 | 0, a3 + 8 | 0);
            j4 = i4 + 8 | 0;
            g3 = c2[j4 >> 2] | 0;
            f4 = c2[b3 + 4 >> 2] | 0;
            d4 = c2[d4 >> 2] | 0;
            c2[h3 >> 2] = c2[b3 >> 2];
            c2[h3 + 4 >> 2] = f4;
            c2[e4 >> 2] = c2[h3 >> 2];
            c2[e4 + 4 >> 2] = c2[h3 + 4 >> 2];
            gl(g3, e4, d4);
            c2[j4 >> 2] = (c2[j4 >> 2] | 0) + 12;
            kl(a3, i4);
            ll(i4);
            l3 = k4;
            return;
          }
        }
        function il(a3) {
          a3 = a3 | 0;
          return 357913941;
        }
        function jl(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 357913941)
                Ta();
              else {
                f4 = qC(b3 * 12 | 0) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 * 12 | 0) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 * 12 | 0);
          return;
        }
        function kl(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (((f4 | 0) / -12 | 0) * 12 | 0) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function ll(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~(((e4 + -12 - b3 | 0) >>> 0) / 12 | 0) * 12 | 0);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function ml(a3) {
          a3 = a3 | 0;
          pl(a3);
          return;
        }
        function nl(a3) {
          a3 = a3 | 0;
          ol(a3 + 24 | 0);
          return;
        }
        function ol(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~(((b3 + -12 - e4 | 0) >>> 0) / 12 | 0) * 12 | 0);
            sC(d4);
          }
          return;
        }
        function pl(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 2, 6, b3, ql() | 0, 0);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function ql() {
          return 1200;
        }
        function rl(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0;
          d4 = l3;
          l3 = l3 + 16 | 0;
          e4 = d4 + 8 | 0;
          f4 = d4;
          g3 = sl(a3) | 0;
          a3 = c2[g3 + 4 >> 2] | 0;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = a3;
          c2[e4 >> 2] = c2[f4 >> 2];
          c2[e4 + 4 >> 2] = c2[f4 + 4 >> 2];
          b3 = tl(b3, e4) | 0;
          l3 = d4;
          return b3 | 0;
        }
        function sl(a3) {
          a3 = a3 | 0;
          return (c2[(dl() | 0) + 24 >> 2] | 0) + (a3 * 12 | 0) | 0;
        }
        function tl(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = c2[b3 >> 2] | 0;
          b3 = c2[b3 + 4 >> 2] | 0;
          a3 = a3 + (b3 >> 1) | 0;
          if (b3 & 1)
            d4 = c2[(c2[a3 >> 2] | 0) + d4 >> 2] | 0;
          return ul(pb[d4 & 31](a3) | 0) | 0;
        }
        function ul(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function vl(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          i4 = c2[d4 >> 2] | 0;
          h3 = c2[d4 + 4 >> 2] | 0;
          d4 = ai(b3) | 0;
          c2[g3 >> 2] = i4;
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          wl(a3, d4, f4, 0);
          l3 = e4;
          return;
        }
        function wl(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4 + 16 | 0;
          m4 = f4 + 8 | 0;
          i4 = f4;
          k4 = c2[d4 >> 2] | 0;
          j4 = c2[d4 + 4 >> 2] | 0;
          h3 = c2[a3 >> 2] | 0;
          a3 = xl() | 0;
          c2[m4 >> 2] = k4;
          c2[m4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[m4 >> 2];
          c2[g3 + 4 >> 2] = c2[m4 + 4 >> 2];
          d4 = yl(g3) | 0;
          c2[i4 >> 2] = k4;
          c2[i4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[i4 >> 2];
          c2[g3 + 4 >> 2] = c2[i4 + 4 >> 2];
          fi(h3, b3, a3, d4, zl(g3, e4) | 0, e4);
          l3 = f4;
          return;
        }
        function xl() {
          var b3 = 0, d4 = 0;
          if (!(a2[7688] | 0)) {
            Gl(9448);
            Ha(32, 9448, o2 | 0) | 0;
            d4 = 7688;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(9448) | 0)) {
            b3 = 9448;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            Gl(9448);
          }
          return 9448;
        }
        function yl(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function zl(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          m4 = l3;
          l3 = l3 + 32 | 0;
          f4 = m4 + 24 | 0;
          h3 = m4 + 16 | 0;
          i4 = m4;
          j4 = m4 + 8 | 0;
          g3 = c2[a3 >> 2] | 0;
          e4 = c2[a3 + 4 >> 2] | 0;
          c2[i4 >> 2] = g3;
          c2[i4 + 4 >> 2] = e4;
          n3 = xl() | 0;
          k4 = n3 + 24 | 0;
          a3 = ji(b3, 4) | 0;
          c2[j4 >> 2] = a3;
          b3 = n3 + 28 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 >>> 0 < (c2[n3 + 32 >> 2] | 0) >>> 0) {
            c2[h3 >> 2] = g3;
            c2[h3 + 4 >> 2] = e4;
            c2[f4 >> 2] = c2[h3 >> 2];
            c2[f4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Al(d4, f4, a3);
            a3 = (c2[b3 >> 2] | 0) + 12 | 0;
            c2[b3 >> 2] = a3;
          } else {
            Bl(k4, i4, j4);
            a3 = c2[b3 >> 2] | 0;
          }
          l3 = m4;
          return ((a3 - (c2[k4 >> 2] | 0) | 0) / 12 | 0) + -1 | 0;
        }
        function Al(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = c2[b3 + 4 >> 2] | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 8 >> 2] = d4;
          return;
        }
        function Bl(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0;
          k4 = l3;
          l3 = l3 + 48 | 0;
          e4 = k4 + 32 | 0;
          h3 = k4 + 24 | 0;
          i4 = k4;
          j4 = a3 + 4 | 0;
          f4 = (((c2[j4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
          g3 = Cl(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            m4 = c2[a3 >> 2] | 0;
            o3 = ((c2[a3 + 8 >> 2] | 0) - m4 | 0) / 12 | 0;
            n3 = o3 << 1;
            Dl(i4, o3 >>> 0 < g3 >>> 1 >>> 0 ? n3 >>> 0 < f4 >>> 0 ? f4 : n3 : g3, ((c2[j4 >> 2] | 0) - m4 | 0) / 12 | 0, a3 + 8 | 0);
            j4 = i4 + 8 | 0;
            g3 = c2[j4 >> 2] | 0;
            f4 = c2[b3 + 4 >> 2] | 0;
            d4 = c2[d4 >> 2] | 0;
            c2[h3 >> 2] = c2[b3 >> 2];
            c2[h3 + 4 >> 2] = f4;
            c2[e4 >> 2] = c2[h3 >> 2];
            c2[e4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Al(g3, e4, d4);
            c2[j4 >> 2] = (c2[j4 >> 2] | 0) + 12;
            El(a3, i4);
            Fl(i4);
            l3 = k4;
            return;
          }
        }
        function Cl(a3) {
          a3 = a3 | 0;
          return 357913941;
        }
        function Dl(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 357913941)
                Ta();
              else {
                f4 = qC(b3 * 12 | 0) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 * 12 | 0) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 * 12 | 0);
          return;
        }
        function El(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (((f4 | 0) / -12 | 0) * 12 | 0) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function Fl(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~(((e4 + -12 - b3 | 0) >>> 0) / 12 | 0) * 12 | 0);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function Gl(a3) {
          a3 = a3 | 0;
          Jl(a3);
          return;
        }
        function Hl(a3) {
          a3 = a3 | 0;
          Il(a3 + 24 | 0);
          return;
        }
        function Il(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~(((b3 + -12 - e4 | 0) >>> 0) / 12 | 0) * 12 | 0);
            sC(d4);
          }
          return;
        }
        function Jl(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 2, 6, b3, Kl() | 0, 1);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function Kl() {
          return 1204;
        }
        function Ll(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = Ml(a3) | 0;
          a3 = c2[h3 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[g3 + 4 >> 2] = a3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Nl(b3, f4, d4);
          l3 = e4;
          return;
        }
        function Ml(a3) {
          a3 = a3 | 0;
          return (c2[(xl() | 0) + 24 >> 2] | 0) + (a3 * 12 | 0) | 0;
        }
        function Nl(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0;
          g3 = l3;
          l3 = l3 + 16 | 0;
          f4 = g3;
          e4 = c2[b3 >> 2] | 0;
          b3 = c2[b3 + 4 >> 2] | 0;
          a3 = a3 + (b3 >> 1) | 0;
          if (b3 & 1)
            e4 = c2[(c2[a3 >> 2] | 0) + e4 >> 2] | 0;
          Ol(f4, d4);
          f4 = Pl(f4, d4) | 0;
          ob[e4 & 31](a3, f4);
          l3 = g3;
          return;
        }
        function Ol(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return;
        }
        function Pl(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return Ql(b3) | 0;
        }
        function Ql(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function Rl(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          i4 = c2[d4 >> 2] | 0;
          h3 = c2[d4 + 4 >> 2] | 0;
          d4 = ai(b3) | 0;
          c2[g3 >> 2] = i4;
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Sl(a3, d4, f4, 0);
          l3 = e4;
          return;
        }
        function Sl(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4 + 16 | 0;
          m4 = f4 + 8 | 0;
          i4 = f4;
          k4 = c2[d4 >> 2] | 0;
          j4 = c2[d4 + 4 >> 2] | 0;
          h3 = c2[a3 >> 2] | 0;
          a3 = Tl() | 0;
          c2[m4 >> 2] = k4;
          c2[m4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[m4 >> 2];
          c2[g3 + 4 >> 2] = c2[m4 + 4 >> 2];
          d4 = Ul(g3) | 0;
          c2[i4 >> 2] = k4;
          c2[i4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[i4 >> 2];
          c2[g3 + 4 >> 2] = c2[i4 + 4 >> 2];
          fi(h3, b3, a3, d4, Vl(g3, e4) | 0, e4);
          l3 = f4;
          return;
        }
        function Tl() {
          var b3 = 0, d4 = 0;
          if (!(a2[7696] | 0)) {
            am(9484);
            Ha(33, 9484, o2 | 0) | 0;
            d4 = 7696;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(9484) | 0)) {
            b3 = 9484;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            am(9484);
          }
          return 9484;
        }
        function Ul(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function Vl(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          m4 = l3;
          l3 = l3 + 32 | 0;
          f4 = m4 + 24 | 0;
          h3 = m4 + 16 | 0;
          i4 = m4;
          j4 = m4 + 8 | 0;
          g3 = c2[a3 >> 2] | 0;
          e4 = c2[a3 + 4 >> 2] | 0;
          c2[i4 >> 2] = g3;
          c2[i4 + 4 >> 2] = e4;
          n3 = Tl() | 0;
          k4 = n3 + 24 | 0;
          a3 = ji(b3, 4) | 0;
          c2[j4 >> 2] = a3;
          b3 = n3 + 28 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 >>> 0 < (c2[n3 + 32 >> 2] | 0) >>> 0) {
            c2[h3 >> 2] = g3;
            c2[h3 + 4 >> 2] = e4;
            c2[f4 >> 2] = c2[h3 >> 2];
            c2[f4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Wl(d4, f4, a3);
            a3 = (c2[b3 >> 2] | 0) + 12 | 0;
            c2[b3 >> 2] = a3;
          } else {
            Xl(k4, i4, j4);
            a3 = c2[b3 >> 2] | 0;
          }
          l3 = m4;
          return ((a3 - (c2[k4 >> 2] | 0) | 0) / 12 | 0) + -1 | 0;
        }
        function Wl(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = c2[b3 + 4 >> 2] | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 8 >> 2] = d4;
          return;
        }
        function Xl(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0;
          k4 = l3;
          l3 = l3 + 48 | 0;
          e4 = k4 + 32 | 0;
          h3 = k4 + 24 | 0;
          i4 = k4;
          j4 = a3 + 4 | 0;
          f4 = (((c2[j4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
          g3 = Yl(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            m4 = c2[a3 >> 2] | 0;
            o3 = ((c2[a3 + 8 >> 2] | 0) - m4 | 0) / 12 | 0;
            n3 = o3 << 1;
            Zl(i4, o3 >>> 0 < g3 >>> 1 >>> 0 ? n3 >>> 0 < f4 >>> 0 ? f4 : n3 : g3, ((c2[j4 >> 2] | 0) - m4 | 0) / 12 | 0, a3 + 8 | 0);
            j4 = i4 + 8 | 0;
            g3 = c2[j4 >> 2] | 0;
            f4 = c2[b3 + 4 >> 2] | 0;
            d4 = c2[d4 >> 2] | 0;
            c2[h3 >> 2] = c2[b3 >> 2];
            c2[h3 + 4 >> 2] = f4;
            c2[e4 >> 2] = c2[h3 >> 2];
            c2[e4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Wl(g3, e4, d4);
            c2[j4 >> 2] = (c2[j4 >> 2] | 0) + 12;
            _l(a3, i4);
            $l(i4);
            l3 = k4;
            return;
          }
        }
        function Yl(a3) {
          a3 = a3 | 0;
          return 357913941;
        }
        function Zl(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 357913941)
                Ta();
              else {
                f4 = qC(b3 * 12 | 0) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 * 12 | 0) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 * 12 | 0);
          return;
        }
        function _l(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (((f4 | 0) / -12 | 0) * 12 | 0) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function $l(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~(((e4 + -12 - b3 | 0) >>> 0) / 12 | 0) * 12 | 0);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function am(a3) {
          a3 = a3 | 0;
          dm(a3);
          return;
        }
        function bm(a3) {
          a3 = a3 | 0;
          cm(a3 + 24 | 0);
          return;
        }
        function cm(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~(((b3 + -12 - e4 | 0) >>> 0) / 12 | 0) * 12 | 0);
            sC(d4);
          }
          return;
        }
        function dm(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 2, 1, b3, em() | 0, 2);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function em() {
          return 1212;
        }
        function fm(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          f4 = l3;
          l3 = l3 + 16 | 0;
          g3 = f4 + 8 | 0;
          h3 = f4;
          i4 = gm(a3) | 0;
          a3 = c2[i4 + 4 >> 2] | 0;
          c2[h3 >> 2] = c2[i4 >> 2];
          c2[h3 + 4 >> 2] = a3;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[g3 + 4 >> 2] = c2[h3 + 4 >> 2];
          hm(b3, g3, d4, e4);
          l3 = f4;
          return;
        }
        function gm(a3) {
          a3 = a3 | 0;
          return (c2[(Tl() | 0) + 24 >> 2] | 0) + (a3 * 12 | 0) | 0;
        }
        function hm(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          i4 = l3;
          l3 = l3 + 16 | 0;
          g3 = i4 + 1 | 0;
          h3 = i4;
          f4 = c2[b3 >> 2] | 0;
          b3 = c2[b3 + 4 >> 2] | 0;
          a3 = a3 + (b3 >> 1) | 0;
          if (b3 & 1)
            f4 = c2[(c2[a3 >> 2] | 0) + f4 >> 2] | 0;
          Ol(g3, d4);
          g3 = Pl(g3, d4) | 0;
          Gk(h3, e4);
          h3 = Hk(h3, e4) | 0;
          Eb[f4 & 15](a3, g3, h3);
          l3 = i4;
          return;
        }
        function im(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          i4 = c2[d4 >> 2] | 0;
          h3 = c2[d4 + 4 >> 2] | 0;
          d4 = ai(b3) | 0;
          c2[g3 >> 2] = i4;
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          jm(a3, d4, f4, 1);
          l3 = e4;
          return;
        }
        function jm(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4 + 16 | 0;
          m4 = f4 + 8 | 0;
          i4 = f4;
          k4 = c2[d4 >> 2] | 0;
          j4 = c2[d4 + 4 >> 2] | 0;
          h3 = c2[a3 >> 2] | 0;
          a3 = km() | 0;
          c2[m4 >> 2] = k4;
          c2[m4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[m4 >> 2];
          c2[g3 + 4 >> 2] = c2[m4 + 4 >> 2];
          d4 = lm(g3) | 0;
          c2[i4 >> 2] = k4;
          c2[i4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[i4 >> 2];
          c2[g3 + 4 >> 2] = c2[i4 + 4 >> 2];
          fi(h3, b3, a3, d4, mm(g3, e4) | 0, e4);
          l3 = f4;
          return;
        }
        function km() {
          var b3 = 0, d4 = 0;
          if (!(a2[7704] | 0)) {
            tm(9520);
            Ha(34, 9520, o2 | 0) | 0;
            d4 = 7704;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(9520) | 0)) {
            b3 = 9520;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            tm(9520);
          }
          return 9520;
        }
        function lm(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function mm(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          m4 = l3;
          l3 = l3 + 32 | 0;
          f4 = m4 + 24 | 0;
          h3 = m4 + 16 | 0;
          i4 = m4;
          j4 = m4 + 8 | 0;
          g3 = c2[a3 >> 2] | 0;
          e4 = c2[a3 + 4 >> 2] | 0;
          c2[i4 >> 2] = g3;
          c2[i4 + 4 >> 2] = e4;
          n3 = km() | 0;
          k4 = n3 + 24 | 0;
          a3 = ji(b3, 4) | 0;
          c2[j4 >> 2] = a3;
          b3 = n3 + 28 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 >>> 0 < (c2[n3 + 32 >> 2] | 0) >>> 0) {
            c2[h3 >> 2] = g3;
            c2[h3 + 4 >> 2] = e4;
            c2[f4 >> 2] = c2[h3 >> 2];
            c2[f4 + 4 >> 2] = c2[h3 + 4 >> 2];
            nm(d4, f4, a3);
            a3 = (c2[b3 >> 2] | 0) + 12 | 0;
            c2[b3 >> 2] = a3;
          } else {
            om(k4, i4, j4);
            a3 = c2[b3 >> 2] | 0;
          }
          l3 = m4;
          return ((a3 - (c2[k4 >> 2] | 0) | 0) / 12 | 0) + -1 | 0;
        }
        function nm(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = c2[b3 + 4 >> 2] | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 8 >> 2] = d4;
          return;
        }
        function om(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0;
          k4 = l3;
          l3 = l3 + 48 | 0;
          e4 = k4 + 32 | 0;
          h3 = k4 + 24 | 0;
          i4 = k4;
          j4 = a3 + 4 | 0;
          f4 = (((c2[j4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
          g3 = pm(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            m4 = c2[a3 >> 2] | 0;
            o3 = ((c2[a3 + 8 >> 2] | 0) - m4 | 0) / 12 | 0;
            n3 = o3 << 1;
            qm(i4, o3 >>> 0 < g3 >>> 1 >>> 0 ? n3 >>> 0 < f4 >>> 0 ? f4 : n3 : g3, ((c2[j4 >> 2] | 0) - m4 | 0) / 12 | 0, a3 + 8 | 0);
            j4 = i4 + 8 | 0;
            g3 = c2[j4 >> 2] | 0;
            f4 = c2[b3 + 4 >> 2] | 0;
            d4 = c2[d4 >> 2] | 0;
            c2[h3 >> 2] = c2[b3 >> 2];
            c2[h3 + 4 >> 2] = f4;
            c2[e4 >> 2] = c2[h3 >> 2];
            c2[e4 + 4 >> 2] = c2[h3 + 4 >> 2];
            nm(g3, e4, d4);
            c2[j4 >> 2] = (c2[j4 >> 2] | 0) + 12;
            rm(a3, i4);
            sm(i4);
            l3 = k4;
            return;
          }
        }
        function pm(a3) {
          a3 = a3 | 0;
          return 357913941;
        }
        function qm(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 357913941)
                Ta();
              else {
                f4 = qC(b3 * 12 | 0) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 * 12 | 0) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 * 12 | 0);
          return;
        }
        function rm(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (((f4 | 0) / -12 | 0) * 12 | 0) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function sm(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~(((e4 + -12 - b3 | 0) >>> 0) / 12 | 0) * 12 | 0);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function tm(a3) {
          a3 = a3 | 0;
          wm(a3);
          return;
        }
        function um(a3) {
          a3 = a3 | 0;
          vm(a3 + 24 | 0);
          return;
        }
        function vm(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~(((b3 + -12 - e4 | 0) >>> 0) / 12 | 0) * 12 | 0);
            sC(d4);
          }
          return;
        }
        function wm(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 2, 1, b3, xm() | 0, 1);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function xm() {
          return 1224;
        }
        function ym(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          f4 = l3;
          l3 = l3 + 16 | 0;
          g3 = f4 + 8 | 0;
          h3 = f4;
          i4 = zm(a3) | 0;
          a3 = c2[i4 + 4 >> 2] | 0;
          c2[h3 >> 2] = c2[i4 >> 2];
          c2[h3 + 4 >> 2] = a3;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[g3 + 4 >> 2] = c2[h3 + 4 >> 2];
          e4 = +Am(b3, g3, d4);
          l3 = f4;
          return +e4;
        }
        function zm(a3) {
          a3 = a3 | 0;
          return (c2[(km() | 0) + 24 >> 2] | 0) + (a3 * 12 | 0) | 0;
        }
        function Am(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          g3 = l3;
          l3 = l3 + 16 | 0;
          f4 = g3;
          e4 = c2[b3 >> 2] | 0;
          b3 = c2[b3 + 4 >> 2] | 0;
          a3 = a3 + (b3 >> 1) | 0;
          if (b3 & 1)
            e4 = c2[(c2[a3 >> 2] | 0) + e4 >> 2] | 0;
          tj(f4, d4);
          f4 = uj(f4, d4) | 0;
          h3 = +ch(+zb[e4 & 7](a3, f4));
          l3 = g3;
          return +h3;
        }
        function Bm(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          i4 = c2[d4 >> 2] | 0;
          h3 = c2[d4 + 4 >> 2] | 0;
          d4 = ai(b3) | 0;
          c2[g3 >> 2] = i4;
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Cm(a3, d4, f4, 1);
          l3 = e4;
          return;
        }
        function Cm(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4 + 16 | 0;
          m4 = f4 + 8 | 0;
          i4 = f4;
          k4 = c2[d4 >> 2] | 0;
          j4 = c2[d4 + 4 >> 2] | 0;
          h3 = c2[a3 >> 2] | 0;
          a3 = Dm() | 0;
          c2[m4 >> 2] = k4;
          c2[m4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[m4 >> 2];
          c2[g3 + 4 >> 2] = c2[m4 + 4 >> 2];
          d4 = Em(g3) | 0;
          c2[i4 >> 2] = k4;
          c2[i4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[i4 >> 2];
          c2[g3 + 4 >> 2] = c2[i4 + 4 >> 2];
          fi(h3, b3, a3, d4, Fm(g3, e4) | 0, e4);
          l3 = f4;
          return;
        }
        function Dm() {
          var b3 = 0, d4 = 0;
          if (!(a2[7712] | 0)) {
            Mm(9556);
            Ha(35, 9556, o2 | 0) | 0;
            d4 = 7712;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(9556) | 0)) {
            b3 = 9556;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            Mm(9556);
          }
          return 9556;
        }
        function Em(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function Fm(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          m4 = l3;
          l3 = l3 + 32 | 0;
          f4 = m4 + 24 | 0;
          h3 = m4 + 16 | 0;
          i4 = m4;
          j4 = m4 + 8 | 0;
          g3 = c2[a3 >> 2] | 0;
          e4 = c2[a3 + 4 >> 2] | 0;
          c2[i4 >> 2] = g3;
          c2[i4 + 4 >> 2] = e4;
          n3 = Dm() | 0;
          k4 = n3 + 24 | 0;
          a3 = ji(b3, 4) | 0;
          c2[j4 >> 2] = a3;
          b3 = n3 + 28 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 >>> 0 < (c2[n3 + 32 >> 2] | 0) >>> 0) {
            c2[h3 >> 2] = g3;
            c2[h3 + 4 >> 2] = e4;
            c2[f4 >> 2] = c2[h3 >> 2];
            c2[f4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Gm(d4, f4, a3);
            a3 = (c2[b3 >> 2] | 0) + 12 | 0;
            c2[b3 >> 2] = a3;
          } else {
            Hm(k4, i4, j4);
            a3 = c2[b3 >> 2] | 0;
          }
          l3 = m4;
          return ((a3 - (c2[k4 >> 2] | 0) | 0) / 12 | 0) + -1 | 0;
        }
        function Gm(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = c2[b3 + 4 >> 2] | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 8 >> 2] = d4;
          return;
        }
        function Hm(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0;
          k4 = l3;
          l3 = l3 + 48 | 0;
          e4 = k4 + 32 | 0;
          h3 = k4 + 24 | 0;
          i4 = k4;
          j4 = a3 + 4 | 0;
          f4 = (((c2[j4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
          g3 = Im(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            m4 = c2[a3 >> 2] | 0;
            o3 = ((c2[a3 + 8 >> 2] | 0) - m4 | 0) / 12 | 0;
            n3 = o3 << 1;
            Jm(i4, o3 >>> 0 < g3 >>> 1 >>> 0 ? n3 >>> 0 < f4 >>> 0 ? f4 : n3 : g3, ((c2[j4 >> 2] | 0) - m4 | 0) / 12 | 0, a3 + 8 | 0);
            j4 = i4 + 8 | 0;
            g3 = c2[j4 >> 2] | 0;
            f4 = c2[b3 + 4 >> 2] | 0;
            d4 = c2[d4 >> 2] | 0;
            c2[h3 >> 2] = c2[b3 >> 2];
            c2[h3 + 4 >> 2] = f4;
            c2[e4 >> 2] = c2[h3 >> 2];
            c2[e4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Gm(g3, e4, d4);
            c2[j4 >> 2] = (c2[j4 >> 2] | 0) + 12;
            Km(a3, i4);
            Lm(i4);
            l3 = k4;
            return;
          }
        }
        function Im(a3) {
          a3 = a3 | 0;
          return 357913941;
        }
        function Jm(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 357913941)
                Ta();
              else {
                f4 = qC(b3 * 12 | 0) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 * 12 | 0) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 * 12 | 0);
          return;
        }
        function Km(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (((f4 | 0) / -12 | 0) * 12 | 0) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function Lm(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~(((e4 + -12 - b3 | 0) >>> 0) / 12 | 0) * 12 | 0);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function Mm(a3) {
          a3 = a3 | 0;
          Pm(a3);
          return;
        }
        function Nm(a3) {
          a3 = a3 | 0;
          Om(a3 + 24 | 0);
          return;
        }
        function Om(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~(((b3 + -12 - e4 | 0) >>> 0) / 12 | 0) * 12 | 0);
            sC(d4);
          }
          return;
        }
        function Pm(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 2, 5, b3, Qm() | 0, 0);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function Qm() {
          return 1232;
        }
        function Rm(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = Sm(a3) | 0;
          a3 = c2[h3 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[g3 + 4 >> 2] = a3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          d4 = +Tm(b3, f4);
          l3 = e4;
          return +d4;
        }
        function Sm(a3) {
          a3 = a3 | 0;
          return (c2[(Dm() | 0) + 24 >> 2] | 0) + (a3 * 12 | 0) | 0;
        }
        function Tm(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = c2[b3 >> 2] | 0;
          b3 = c2[b3 + 4 >> 2] | 0;
          a3 = a3 + (b3 >> 1) | 0;
          if (b3 & 1)
            d4 = c2[(c2[a3 >> 2] | 0) + d4 >> 2] | 0;
          return + +ch(+ub[d4 & 15](a3));
        }
        function Um(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          i4 = c2[d4 >> 2] | 0;
          h3 = c2[d4 + 4 >> 2] | 0;
          d4 = ai(b3) | 0;
          c2[g3 >> 2] = i4;
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Vm(a3, d4, f4, 1);
          l3 = e4;
          return;
        }
        function Vm(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4 + 16 | 0;
          m4 = f4 + 8 | 0;
          i4 = f4;
          k4 = c2[d4 >> 2] | 0;
          j4 = c2[d4 + 4 >> 2] | 0;
          h3 = c2[a3 >> 2] | 0;
          a3 = Wm() | 0;
          c2[m4 >> 2] = k4;
          c2[m4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[m4 >> 2];
          c2[g3 + 4 >> 2] = c2[m4 + 4 >> 2];
          d4 = Xm(g3) | 0;
          c2[i4 >> 2] = k4;
          c2[i4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[i4 >> 2];
          c2[g3 + 4 >> 2] = c2[i4 + 4 >> 2];
          fi(h3, b3, a3, d4, Ym(g3, e4) | 0, e4);
          l3 = f4;
          return;
        }
        function Wm() {
          var b3 = 0, d4 = 0;
          if (!(a2[7720] | 0)) {
            dn(9592);
            Ha(36, 9592, o2 | 0) | 0;
            d4 = 7720;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(9592) | 0)) {
            b3 = 9592;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            dn(9592);
          }
          return 9592;
        }
        function Xm(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function Ym(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          m4 = l3;
          l3 = l3 + 32 | 0;
          f4 = m4 + 24 | 0;
          h3 = m4 + 16 | 0;
          i4 = m4;
          j4 = m4 + 8 | 0;
          g3 = c2[a3 >> 2] | 0;
          e4 = c2[a3 + 4 >> 2] | 0;
          c2[i4 >> 2] = g3;
          c2[i4 + 4 >> 2] = e4;
          n3 = Wm() | 0;
          k4 = n3 + 24 | 0;
          a3 = ji(b3, 4) | 0;
          c2[j4 >> 2] = a3;
          b3 = n3 + 28 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 >>> 0 < (c2[n3 + 32 >> 2] | 0) >>> 0) {
            c2[h3 >> 2] = g3;
            c2[h3 + 4 >> 2] = e4;
            c2[f4 >> 2] = c2[h3 >> 2];
            c2[f4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Zm(d4, f4, a3);
            a3 = (c2[b3 >> 2] | 0) + 12 | 0;
            c2[b3 >> 2] = a3;
          } else {
            _m(k4, i4, j4);
            a3 = c2[b3 >> 2] | 0;
          }
          l3 = m4;
          return ((a3 - (c2[k4 >> 2] | 0) | 0) / 12 | 0) + -1 | 0;
        }
        function Zm(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = c2[b3 + 4 >> 2] | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 8 >> 2] = d4;
          return;
        }
        function _m(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0;
          k4 = l3;
          l3 = l3 + 48 | 0;
          e4 = k4 + 32 | 0;
          h3 = k4 + 24 | 0;
          i4 = k4;
          j4 = a3 + 4 | 0;
          f4 = (((c2[j4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
          g3 = $m(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            m4 = c2[a3 >> 2] | 0;
            o3 = ((c2[a3 + 8 >> 2] | 0) - m4 | 0) / 12 | 0;
            n3 = o3 << 1;
            an(i4, o3 >>> 0 < g3 >>> 1 >>> 0 ? n3 >>> 0 < f4 >>> 0 ? f4 : n3 : g3, ((c2[j4 >> 2] | 0) - m4 | 0) / 12 | 0, a3 + 8 | 0);
            j4 = i4 + 8 | 0;
            g3 = c2[j4 >> 2] | 0;
            f4 = c2[b3 + 4 >> 2] | 0;
            d4 = c2[d4 >> 2] | 0;
            c2[h3 >> 2] = c2[b3 >> 2];
            c2[h3 + 4 >> 2] = f4;
            c2[e4 >> 2] = c2[h3 >> 2];
            c2[e4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Zm(g3, e4, d4);
            c2[j4 >> 2] = (c2[j4 >> 2] | 0) + 12;
            bn(a3, i4);
            cn(i4);
            l3 = k4;
            return;
          }
        }
        function $m(a3) {
          a3 = a3 | 0;
          return 357913941;
        }
        function an(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 357913941)
                Ta();
              else {
                f4 = qC(b3 * 12 | 0) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 * 12 | 0) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 * 12 | 0);
          return;
        }
        function bn(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (((f4 | 0) / -12 | 0) * 12 | 0) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function cn(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~(((e4 + -12 - b3 | 0) >>> 0) / 12 | 0) * 12 | 0);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function dn(a3) {
          a3 = a3 | 0;
          gn(a3);
          return;
        }
        function en(a3) {
          a3 = a3 | 0;
          fn(a3 + 24 | 0);
          return;
        }
        function fn(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~(((b3 + -12 - e4 | 0) >>> 0) / 12 | 0) * 12 | 0);
            sC(d4);
          }
          return;
        }
        function gn(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 2, 7, b3, hn() | 0, 0);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function hn() {
          return 1276;
        }
        function jn(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0;
          d4 = l3;
          l3 = l3 + 16 | 0;
          e4 = d4 + 8 | 0;
          f4 = d4;
          g3 = kn(a3) | 0;
          a3 = c2[g3 + 4 >> 2] | 0;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = a3;
          c2[e4 >> 2] = c2[f4 >> 2];
          c2[e4 + 4 >> 2] = c2[f4 + 4 >> 2];
          b3 = ln(b3, e4) | 0;
          l3 = d4;
          return b3 | 0;
        }
        function kn(a3) {
          a3 = a3 | 0;
          return (c2[(Wm() | 0) + 24 >> 2] | 0) + (a3 * 12 | 0) | 0;
        }
        function ln(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0;
          f4 = l3;
          l3 = l3 + 16 | 0;
          e4 = f4;
          d4 = c2[b3 >> 2] | 0;
          b3 = c2[b3 + 4 >> 2] | 0;
          a3 = a3 + (b3 >> 1) | 0;
          if (b3 & 1)
            d4 = c2[(c2[a3 >> 2] | 0) + d4 >> 2] | 0;
          ob[d4 & 31](e4, a3);
          e4 = mn(e4) | 0;
          l3 = f4;
          return e4 | 0;
        }
        function mn(a3) {
          a3 = a3 | 0;
          var b3 = 0, c3 = 0, d4 = 0, e4 = 0;
          e4 = l3;
          l3 = l3 + 32 | 0;
          b3 = e4 + 12 | 0;
          c3 = e4;
          d4 = Di(nn() | 0) | 0;
          if (!d4)
            a3 = pn(a3) | 0;
          else {
            Ei(b3, d4);
            Fi(c3, b3);
            on(a3, c3);
            a3 = Hi(b3) | 0;
          }
          l3 = e4;
          return a3 | 0;
        }
        function nn() {
          var b3 = 0;
          if (!(a2[7736] | 0)) {
            An(9640);
            Ha(25, 9640, o2 | 0) | 0;
            b3 = 7736;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          return 9640;
        }
        function on(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          un(b3, a3, a3 + 8 | 0) | 0;
          return;
        }
        function pn(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          d4 = l3;
          l3 = l3 + 16 | 0;
          f4 = d4 + 4 | 0;
          h3 = d4;
          e4 = jy(8) | 0;
          b3 = e4;
          i4 = qC(16) | 0;
          c2[i4 >> 2] = c2[a3 >> 2];
          c2[i4 + 4 >> 2] = c2[a3 + 4 >> 2];
          c2[i4 + 8 >> 2] = c2[a3 + 8 >> 2];
          c2[i4 + 12 >> 2] = c2[a3 + 12 >> 2];
          g3 = b3 + 4 | 0;
          c2[g3 >> 2] = i4;
          a3 = qC(8) | 0;
          g3 = c2[g3 >> 2] | 0;
          c2[h3 >> 2] = 0;
          c2[f4 >> 2] = c2[h3 >> 2];
          qn(a3, g3, f4);
          c2[e4 >> 2] = a3;
          l3 = d4;
          return b3 | 0;
        }
        function qn(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          c2[a3 >> 2] = b3;
          d4 = qC(16) | 0;
          c2[d4 + 4 >> 2] = 0;
          c2[d4 + 8 >> 2] = 0;
          c2[d4 >> 2] = 1244;
          c2[d4 + 12 >> 2] = b3;
          c2[a3 + 4 >> 2] = d4;
          return;
        }
        function rn(a3) {
          a3 = a3 | 0;
          kC(a3);
          sC(a3);
          return;
        }
        function sn(a3) {
          a3 = a3 | 0;
          a3 = c2[a3 + 12 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function tn(a3) {
          a3 = a3 | 0;
          sC(a3);
          return;
        }
        function un(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          b3 = vn(c2[a3 >> 2] | 0, b3, d4) | 0;
          d4 = a3 + 4 | 0;
          c2[(c2[d4 >> 2] | 0) + 8 >> 2] = b3;
          return c2[(c2[d4 >> 2] | 0) + 8 >> 2] | 0;
        }
        function vn(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4;
          UA(f4);
          a3 = Sg(a3) | 0;
          d4 = wn(a3, c2[b3 >> 2] | 0, +h2[d4 >> 3]) | 0;
          WA(f4);
          l3 = e4;
          return d4 | 0;
        }
        function wn(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = +c3;
          var d4 = 0;
          d4 = Vg(xn() | 0) | 0;
          b3 = Xg(b3) | 0;
          return za(0, d4 | 0, a3 | 0, b3 | 0, + +Wg(c3)) | 0;
        }
        function xn() {
          var b3 = 0;
          if (!(a2[7728] | 0)) {
            yn(9628);
            b3 = 7728;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          return 9628;
        }
        function yn(a3) {
          a3 = a3 | 0;
          fh(a3, zn() | 0, 2);
          return;
        }
        function zn() {
          return 1264;
        }
        function An(a3) {
          a3 = a3 | 0;
          Zi(a3);
          return;
        }
        function Bn(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          i4 = c2[d4 >> 2] | 0;
          h3 = c2[d4 + 4 >> 2] | 0;
          d4 = ai(b3) | 0;
          c2[g3 >> 2] = i4;
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Cn(a3, d4, f4, 1);
          l3 = e4;
          return;
        }
        function Cn(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4 + 16 | 0;
          m4 = f4 + 8 | 0;
          i4 = f4;
          k4 = c2[d4 >> 2] | 0;
          j4 = c2[d4 + 4 >> 2] | 0;
          h3 = c2[a3 >> 2] | 0;
          a3 = Dn() | 0;
          c2[m4 >> 2] = k4;
          c2[m4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[m4 >> 2];
          c2[g3 + 4 >> 2] = c2[m4 + 4 >> 2];
          d4 = En(g3) | 0;
          c2[i4 >> 2] = k4;
          c2[i4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[i4 >> 2];
          c2[g3 + 4 >> 2] = c2[i4 + 4 >> 2];
          fi(h3, b3, a3, d4, Fn(g3, e4) | 0, e4);
          l3 = f4;
          return;
        }
        function Dn() {
          var b3 = 0, d4 = 0;
          if (!(a2[7744] | 0)) {
            Mn(9684);
            Ha(37, 9684, o2 | 0) | 0;
            d4 = 7744;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(9684) | 0)) {
            b3 = 9684;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            Mn(9684);
          }
          return 9684;
        }
        function En(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function Fn(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          m4 = l3;
          l3 = l3 + 32 | 0;
          f4 = m4 + 24 | 0;
          h3 = m4 + 16 | 0;
          i4 = m4;
          j4 = m4 + 8 | 0;
          g3 = c2[a3 >> 2] | 0;
          e4 = c2[a3 + 4 >> 2] | 0;
          c2[i4 >> 2] = g3;
          c2[i4 + 4 >> 2] = e4;
          n3 = Dn() | 0;
          k4 = n3 + 24 | 0;
          a3 = ji(b3, 4) | 0;
          c2[j4 >> 2] = a3;
          b3 = n3 + 28 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 >>> 0 < (c2[n3 + 32 >> 2] | 0) >>> 0) {
            c2[h3 >> 2] = g3;
            c2[h3 + 4 >> 2] = e4;
            c2[f4 >> 2] = c2[h3 >> 2];
            c2[f4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Gn(d4, f4, a3);
            a3 = (c2[b3 >> 2] | 0) + 12 | 0;
            c2[b3 >> 2] = a3;
          } else {
            Hn(k4, i4, j4);
            a3 = c2[b3 >> 2] | 0;
          }
          l3 = m4;
          return ((a3 - (c2[k4 >> 2] | 0) | 0) / 12 | 0) + -1 | 0;
        }
        function Gn(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = c2[b3 + 4 >> 2] | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 8 >> 2] = d4;
          return;
        }
        function Hn(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0;
          k4 = l3;
          l3 = l3 + 48 | 0;
          e4 = k4 + 32 | 0;
          h3 = k4 + 24 | 0;
          i4 = k4;
          j4 = a3 + 4 | 0;
          f4 = (((c2[j4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
          g3 = In(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            m4 = c2[a3 >> 2] | 0;
            o3 = ((c2[a3 + 8 >> 2] | 0) - m4 | 0) / 12 | 0;
            n3 = o3 << 1;
            Jn(i4, o3 >>> 0 < g3 >>> 1 >>> 0 ? n3 >>> 0 < f4 >>> 0 ? f4 : n3 : g3, ((c2[j4 >> 2] | 0) - m4 | 0) / 12 | 0, a3 + 8 | 0);
            j4 = i4 + 8 | 0;
            g3 = c2[j4 >> 2] | 0;
            f4 = c2[b3 + 4 >> 2] | 0;
            d4 = c2[d4 >> 2] | 0;
            c2[h3 >> 2] = c2[b3 >> 2];
            c2[h3 + 4 >> 2] = f4;
            c2[e4 >> 2] = c2[h3 >> 2];
            c2[e4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Gn(g3, e4, d4);
            c2[j4 >> 2] = (c2[j4 >> 2] | 0) + 12;
            Kn(a3, i4);
            Ln(i4);
            l3 = k4;
            return;
          }
        }
        function In(a3) {
          a3 = a3 | 0;
          return 357913941;
        }
        function Jn(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 357913941)
                Ta();
              else {
                f4 = qC(b3 * 12 | 0) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 * 12 | 0) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 * 12 | 0);
          return;
        }
        function Kn(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (((f4 | 0) / -12 | 0) * 12 | 0) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function Ln(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~(((e4 + -12 - b3 | 0) >>> 0) / 12 | 0) * 12 | 0);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function Mn(a3) {
          a3 = a3 | 0;
          Pn(a3);
          return;
        }
        function Nn(a3) {
          a3 = a3 | 0;
          On(a3 + 24 | 0);
          return;
        }
        function On(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~(((b3 + -12 - e4 | 0) >>> 0) / 12 | 0) * 12 | 0);
            sC(d4);
          }
          return;
        }
        function Pn(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 2, 5, b3, Qn() | 0, 1);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function Qn() {
          return 1280;
        }
        function Rn(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = Sn(a3) | 0;
          a3 = c2[h3 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[g3 + 4 >> 2] = a3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          d4 = Tn(b3, f4, d4) | 0;
          l3 = e4;
          return d4 | 0;
        }
        function Sn(a3) {
          a3 = a3 | 0;
          return (c2[(Dn() | 0) + 24 >> 2] | 0) + (a3 * 12 | 0) | 0;
        }
        function Tn(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          h3 = l3;
          l3 = l3 + 32 | 0;
          f4 = h3;
          g3 = h3 + 16 | 0;
          e4 = c2[b3 >> 2] | 0;
          b3 = c2[b3 + 4 >> 2] | 0;
          a3 = a3 + (b3 >> 1) | 0;
          if (b3 & 1)
            e4 = c2[(c2[a3 >> 2] | 0) + e4 >> 2] | 0;
          tj(g3, d4);
          g3 = uj(g3, d4) | 0;
          Eb[e4 & 15](f4, a3, g3);
          g3 = mn(f4) | 0;
          l3 = h3;
          return g3 | 0;
        }
        function Un(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          i4 = c2[d4 >> 2] | 0;
          h3 = c2[d4 + 4 >> 2] | 0;
          d4 = ai(b3) | 0;
          c2[g3 >> 2] = i4;
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Vn(a3, d4, f4, 1);
          l3 = e4;
          return;
        }
        function Vn(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4 + 16 | 0;
          m4 = f4 + 8 | 0;
          i4 = f4;
          k4 = c2[d4 >> 2] | 0;
          j4 = c2[d4 + 4 >> 2] | 0;
          h3 = c2[a3 >> 2] | 0;
          a3 = Wn() | 0;
          c2[m4 >> 2] = k4;
          c2[m4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[m4 >> 2];
          c2[g3 + 4 >> 2] = c2[m4 + 4 >> 2];
          d4 = Xn(g3) | 0;
          c2[i4 >> 2] = k4;
          c2[i4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[i4 >> 2];
          c2[g3 + 4 >> 2] = c2[i4 + 4 >> 2];
          fi(h3, b3, a3, d4, Yn(g3, e4) | 0, e4);
          l3 = f4;
          return;
        }
        function Wn() {
          var b3 = 0, d4 = 0;
          if (!(a2[7752] | 0)) {
            eo(9720);
            Ha(38, 9720, o2 | 0) | 0;
            d4 = 7752;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(9720) | 0)) {
            b3 = 9720;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            eo(9720);
          }
          return 9720;
        }
        function Xn(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function Yn(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          m4 = l3;
          l3 = l3 + 32 | 0;
          f4 = m4 + 24 | 0;
          h3 = m4 + 16 | 0;
          i4 = m4;
          j4 = m4 + 8 | 0;
          g3 = c2[a3 >> 2] | 0;
          e4 = c2[a3 + 4 >> 2] | 0;
          c2[i4 >> 2] = g3;
          c2[i4 + 4 >> 2] = e4;
          n3 = Wn() | 0;
          k4 = n3 + 24 | 0;
          a3 = ji(b3, 4) | 0;
          c2[j4 >> 2] = a3;
          b3 = n3 + 28 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 >>> 0 < (c2[n3 + 32 >> 2] | 0) >>> 0) {
            c2[h3 >> 2] = g3;
            c2[h3 + 4 >> 2] = e4;
            c2[f4 >> 2] = c2[h3 >> 2];
            c2[f4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Zn(d4, f4, a3);
            a3 = (c2[b3 >> 2] | 0) + 12 | 0;
            c2[b3 >> 2] = a3;
          } else {
            _n(k4, i4, j4);
            a3 = c2[b3 >> 2] | 0;
          }
          l3 = m4;
          return ((a3 - (c2[k4 >> 2] | 0) | 0) / 12 | 0) + -1 | 0;
        }
        function Zn(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = c2[b3 + 4 >> 2] | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 8 >> 2] = d4;
          return;
        }
        function _n(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0;
          k4 = l3;
          l3 = l3 + 48 | 0;
          e4 = k4 + 32 | 0;
          h3 = k4 + 24 | 0;
          i4 = k4;
          j4 = a3 + 4 | 0;
          f4 = (((c2[j4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
          g3 = $n(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            m4 = c2[a3 >> 2] | 0;
            o3 = ((c2[a3 + 8 >> 2] | 0) - m4 | 0) / 12 | 0;
            n3 = o3 << 1;
            ao(i4, o3 >>> 0 < g3 >>> 1 >>> 0 ? n3 >>> 0 < f4 >>> 0 ? f4 : n3 : g3, ((c2[j4 >> 2] | 0) - m4 | 0) / 12 | 0, a3 + 8 | 0);
            j4 = i4 + 8 | 0;
            g3 = c2[j4 >> 2] | 0;
            f4 = c2[b3 + 4 >> 2] | 0;
            d4 = c2[d4 >> 2] | 0;
            c2[h3 >> 2] = c2[b3 >> 2];
            c2[h3 + 4 >> 2] = f4;
            c2[e4 >> 2] = c2[h3 >> 2];
            c2[e4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Zn(g3, e4, d4);
            c2[j4 >> 2] = (c2[j4 >> 2] | 0) + 12;
            bo(a3, i4);
            co(i4);
            l3 = k4;
            return;
          }
        }
        function $n(a3) {
          a3 = a3 | 0;
          return 357913941;
        }
        function ao(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 357913941)
                Ta();
              else {
                f4 = qC(b3 * 12 | 0) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 * 12 | 0) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 * 12 | 0);
          return;
        }
        function bo(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (((f4 | 0) / -12 | 0) * 12 | 0) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function co(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~(((e4 + -12 - b3 | 0) >>> 0) / 12 | 0) * 12 | 0);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function eo(a3) {
          a3 = a3 | 0;
          ho(a3);
          return;
        }
        function fo(a3) {
          a3 = a3 | 0;
          go(a3 + 24 | 0);
          return;
        }
        function go(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~(((b3 + -12 - e4 | 0) >>> 0) / 12 | 0) * 12 | 0);
            sC(d4);
          }
          return;
        }
        function ho(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 2, 8, b3, io() | 0, 0);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function io() {
          return 1288;
        }
        function jo(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0;
          d4 = l3;
          l3 = l3 + 16 | 0;
          e4 = d4 + 8 | 0;
          f4 = d4;
          g3 = ko(a3) | 0;
          a3 = c2[g3 + 4 >> 2] | 0;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = a3;
          c2[e4 >> 2] = c2[f4 >> 2];
          c2[e4 + 4 >> 2] = c2[f4 + 4 >> 2];
          b3 = lo(b3, e4) | 0;
          l3 = d4;
          return b3 | 0;
        }
        function ko(a3) {
          a3 = a3 | 0;
          return (c2[(Wn() | 0) + 24 >> 2] | 0) + (a3 * 12 | 0) | 0;
        }
        function lo(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = c2[b3 >> 2] | 0;
          b3 = c2[b3 + 4 >> 2] | 0;
          a3 = a3 + (b3 >> 1) | 0;
          if (b3 & 1)
            d4 = c2[(c2[a3 >> 2] | 0) + d4 >> 2] | 0;
          return bh(pb[d4 & 31](a3) | 0) | 0;
        }
        function mo(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          i4 = c2[d4 >> 2] | 0;
          h3 = c2[d4 + 4 >> 2] | 0;
          d4 = ai(b3) | 0;
          c2[g3 >> 2] = i4;
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          no(a3, d4, f4, 0);
          l3 = e4;
          return;
        }
        function no(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4 + 16 | 0;
          m4 = f4 + 8 | 0;
          i4 = f4;
          k4 = c2[d4 >> 2] | 0;
          j4 = c2[d4 + 4 >> 2] | 0;
          h3 = c2[a3 >> 2] | 0;
          a3 = oo() | 0;
          c2[m4 >> 2] = k4;
          c2[m4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[m4 >> 2];
          c2[g3 + 4 >> 2] = c2[m4 + 4 >> 2];
          d4 = po(g3) | 0;
          c2[i4 >> 2] = k4;
          c2[i4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[i4 >> 2];
          c2[g3 + 4 >> 2] = c2[i4 + 4 >> 2];
          fi(h3, b3, a3, d4, qo(g3, e4) | 0, e4);
          l3 = f4;
          return;
        }
        function oo() {
          var b3 = 0, d4 = 0;
          if (!(a2[7760] | 0)) {
            xo(9756);
            Ha(39, 9756, o2 | 0) | 0;
            d4 = 7760;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(9756) | 0)) {
            b3 = 9756;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            xo(9756);
          }
          return 9756;
        }
        function po(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function qo(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          m4 = l3;
          l3 = l3 + 32 | 0;
          f4 = m4 + 24 | 0;
          h3 = m4 + 16 | 0;
          i4 = m4;
          j4 = m4 + 8 | 0;
          g3 = c2[a3 >> 2] | 0;
          e4 = c2[a3 + 4 >> 2] | 0;
          c2[i4 >> 2] = g3;
          c2[i4 + 4 >> 2] = e4;
          n3 = oo() | 0;
          k4 = n3 + 24 | 0;
          a3 = ji(b3, 4) | 0;
          c2[j4 >> 2] = a3;
          b3 = n3 + 28 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 >>> 0 < (c2[n3 + 32 >> 2] | 0) >>> 0) {
            c2[h3 >> 2] = g3;
            c2[h3 + 4 >> 2] = e4;
            c2[f4 >> 2] = c2[h3 >> 2];
            c2[f4 + 4 >> 2] = c2[h3 + 4 >> 2];
            ro(d4, f4, a3);
            a3 = (c2[b3 >> 2] | 0) + 12 | 0;
            c2[b3 >> 2] = a3;
          } else {
            so(k4, i4, j4);
            a3 = c2[b3 >> 2] | 0;
          }
          l3 = m4;
          return ((a3 - (c2[k4 >> 2] | 0) | 0) / 12 | 0) + -1 | 0;
        }
        function ro(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = c2[b3 + 4 >> 2] | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 8 >> 2] = d4;
          return;
        }
        function so(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0;
          k4 = l3;
          l3 = l3 + 48 | 0;
          e4 = k4 + 32 | 0;
          h3 = k4 + 24 | 0;
          i4 = k4;
          j4 = a3 + 4 | 0;
          f4 = (((c2[j4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
          g3 = to(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            m4 = c2[a3 >> 2] | 0;
            o3 = ((c2[a3 + 8 >> 2] | 0) - m4 | 0) / 12 | 0;
            n3 = o3 << 1;
            uo(i4, o3 >>> 0 < g3 >>> 1 >>> 0 ? n3 >>> 0 < f4 >>> 0 ? f4 : n3 : g3, ((c2[j4 >> 2] | 0) - m4 | 0) / 12 | 0, a3 + 8 | 0);
            j4 = i4 + 8 | 0;
            g3 = c2[j4 >> 2] | 0;
            f4 = c2[b3 + 4 >> 2] | 0;
            d4 = c2[d4 >> 2] | 0;
            c2[h3 >> 2] = c2[b3 >> 2];
            c2[h3 + 4 >> 2] = f4;
            c2[e4 >> 2] = c2[h3 >> 2];
            c2[e4 + 4 >> 2] = c2[h3 + 4 >> 2];
            ro(g3, e4, d4);
            c2[j4 >> 2] = (c2[j4 >> 2] | 0) + 12;
            vo(a3, i4);
            wo(i4);
            l3 = k4;
            return;
          }
        }
        function to(a3) {
          a3 = a3 | 0;
          return 357913941;
        }
        function uo(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 357913941)
                Ta();
              else {
                f4 = qC(b3 * 12 | 0) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 * 12 | 0) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 * 12 | 0);
          return;
        }
        function vo(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (((f4 | 0) / -12 | 0) * 12 | 0) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function wo(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~(((e4 + -12 - b3 | 0) >>> 0) / 12 | 0) * 12 | 0);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function xo(a3) {
          a3 = a3 | 0;
          Ao(a3);
          return;
        }
        function yo(a3) {
          a3 = a3 | 0;
          zo(a3 + 24 | 0);
          return;
        }
        function zo(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~(((b3 + -12 - e4 | 0) >>> 0) / 12 | 0) * 12 | 0);
            sC(d4);
          }
          return;
        }
        function Ao(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 2, 8, b3, Bo() | 0, 1);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function Bo() {
          return 1292;
        }
        function Co(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = +d4;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = Do(a3) | 0;
          a3 = c2[h3 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[g3 + 4 >> 2] = a3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Eo(b3, f4, d4);
          l3 = e4;
          return;
        }
        function Do(a3) {
          a3 = a3 | 0;
          return (c2[(oo() | 0) + 24 >> 2] | 0) + (a3 * 12 | 0) | 0;
        }
        function Eo(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = +d4;
          var e4 = 0, f4 = 0, g3 = 0;
          g3 = l3;
          l3 = l3 + 16 | 0;
          f4 = g3;
          e4 = c2[b3 >> 2] | 0;
          b3 = c2[b3 + 4 >> 2] | 0;
          a3 = a3 + (b3 >> 1) | 0;
          if (b3 & 1)
            e4 = c2[(c2[a3 >> 2] | 0) + e4 >> 2] | 0;
          rj(f4, d4);
          d4 = +sj(f4, d4);
          lb[e4 & 31](a3, d4);
          l3 = g3;
          return;
        }
        function Fo(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          i4 = c2[d4 >> 2] | 0;
          h3 = c2[d4 + 4 >> 2] | 0;
          d4 = ai(b3) | 0;
          c2[g3 >> 2] = i4;
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Go(a3, d4, f4, 0);
          l3 = e4;
          return;
        }
        function Go(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4 + 16 | 0;
          m4 = f4 + 8 | 0;
          i4 = f4;
          k4 = c2[d4 >> 2] | 0;
          j4 = c2[d4 + 4 >> 2] | 0;
          h3 = c2[a3 >> 2] | 0;
          a3 = Ho() | 0;
          c2[m4 >> 2] = k4;
          c2[m4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[m4 >> 2];
          c2[g3 + 4 >> 2] = c2[m4 + 4 >> 2];
          d4 = Io(g3) | 0;
          c2[i4 >> 2] = k4;
          c2[i4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[i4 >> 2];
          c2[g3 + 4 >> 2] = c2[i4 + 4 >> 2];
          fi(h3, b3, a3, d4, Jo(g3, e4) | 0, e4);
          l3 = f4;
          return;
        }
        function Ho() {
          var b3 = 0, d4 = 0;
          if (!(a2[7768] | 0)) {
            Qo(9792);
            Ha(40, 9792, o2 | 0) | 0;
            d4 = 7768;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(9792) | 0)) {
            b3 = 9792;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            Qo(9792);
          }
          return 9792;
        }
        function Io(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function Jo(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          m4 = l3;
          l3 = l3 + 32 | 0;
          f4 = m4 + 24 | 0;
          h3 = m4 + 16 | 0;
          i4 = m4;
          j4 = m4 + 8 | 0;
          g3 = c2[a3 >> 2] | 0;
          e4 = c2[a3 + 4 >> 2] | 0;
          c2[i4 >> 2] = g3;
          c2[i4 + 4 >> 2] = e4;
          n3 = Ho() | 0;
          k4 = n3 + 24 | 0;
          a3 = ji(b3, 4) | 0;
          c2[j4 >> 2] = a3;
          b3 = n3 + 28 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 >>> 0 < (c2[n3 + 32 >> 2] | 0) >>> 0) {
            c2[h3 >> 2] = g3;
            c2[h3 + 4 >> 2] = e4;
            c2[f4 >> 2] = c2[h3 >> 2];
            c2[f4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Ko(d4, f4, a3);
            a3 = (c2[b3 >> 2] | 0) + 12 | 0;
            c2[b3 >> 2] = a3;
          } else {
            Lo(k4, i4, j4);
            a3 = c2[b3 >> 2] | 0;
          }
          l3 = m4;
          return ((a3 - (c2[k4 >> 2] | 0) | 0) / 12 | 0) + -1 | 0;
        }
        function Ko(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = c2[b3 + 4 >> 2] | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 8 >> 2] = d4;
          return;
        }
        function Lo(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0;
          k4 = l3;
          l3 = l3 + 48 | 0;
          e4 = k4 + 32 | 0;
          h3 = k4 + 24 | 0;
          i4 = k4;
          j4 = a3 + 4 | 0;
          f4 = (((c2[j4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
          g3 = Mo(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            m4 = c2[a3 >> 2] | 0;
            o3 = ((c2[a3 + 8 >> 2] | 0) - m4 | 0) / 12 | 0;
            n3 = o3 << 1;
            No(i4, o3 >>> 0 < g3 >>> 1 >>> 0 ? n3 >>> 0 < f4 >>> 0 ? f4 : n3 : g3, ((c2[j4 >> 2] | 0) - m4 | 0) / 12 | 0, a3 + 8 | 0);
            j4 = i4 + 8 | 0;
            g3 = c2[j4 >> 2] | 0;
            f4 = c2[b3 + 4 >> 2] | 0;
            d4 = c2[d4 >> 2] | 0;
            c2[h3 >> 2] = c2[b3 >> 2];
            c2[h3 + 4 >> 2] = f4;
            c2[e4 >> 2] = c2[h3 >> 2];
            c2[e4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Ko(g3, e4, d4);
            c2[j4 >> 2] = (c2[j4 >> 2] | 0) + 12;
            Oo(a3, i4);
            Po(i4);
            l3 = k4;
            return;
          }
        }
        function Mo(a3) {
          a3 = a3 | 0;
          return 357913941;
        }
        function No(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 357913941)
                Ta();
              else {
                f4 = qC(b3 * 12 | 0) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 * 12 | 0) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 * 12 | 0);
          return;
        }
        function Oo(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (((f4 | 0) / -12 | 0) * 12 | 0) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function Po(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~(((e4 + -12 - b3 | 0) >>> 0) / 12 | 0) * 12 | 0);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function Qo(a3) {
          a3 = a3 | 0;
          To(a3);
          return;
        }
        function Ro(a3) {
          a3 = a3 | 0;
          So(a3 + 24 | 0);
          return;
        }
        function So(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~(((b3 + -12 - e4 | 0) >>> 0) / 12 | 0) * 12 | 0);
            sC(d4);
          }
          return;
        }
        function To(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 2, 1, b3, Uo() | 0, 2);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function Uo() {
          return 1300;
        }
        function Vo(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = +e4;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          f4 = l3;
          l3 = l3 + 16 | 0;
          g3 = f4 + 8 | 0;
          h3 = f4;
          i4 = Wo(a3) | 0;
          a3 = c2[i4 + 4 >> 2] | 0;
          c2[h3 >> 2] = c2[i4 >> 2];
          c2[h3 + 4 >> 2] = a3;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[g3 + 4 >> 2] = c2[h3 + 4 >> 2];
          Xo(b3, g3, d4, e4);
          l3 = f4;
          return;
        }
        function Wo(a3) {
          a3 = a3 | 0;
          return (c2[(Ho() | 0) + 24 >> 2] | 0) + (a3 * 12 | 0) | 0;
        }
        function Xo(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = +e4;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          i4 = l3;
          l3 = l3 + 16 | 0;
          g3 = i4 + 1 | 0;
          h3 = i4;
          f4 = c2[b3 >> 2] | 0;
          b3 = c2[b3 + 4 >> 2] | 0;
          a3 = a3 + (b3 >> 1) | 0;
          if (b3 & 1)
            f4 = c2[(c2[a3 >> 2] | 0) + f4 >> 2] | 0;
          tj(g3, d4);
          g3 = uj(g3, d4) | 0;
          rj(h3, e4);
          e4 = +sj(h3, e4);
          Gb[f4 & 15](a3, g3, e4);
          l3 = i4;
          return;
        }
        function Yo(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          i4 = c2[d4 >> 2] | 0;
          h3 = c2[d4 + 4 >> 2] | 0;
          d4 = ai(b3) | 0;
          c2[g3 >> 2] = i4;
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Zo(a3, d4, f4, 0);
          l3 = e4;
          return;
        }
        function Zo(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4 + 16 | 0;
          m4 = f4 + 8 | 0;
          i4 = f4;
          k4 = c2[d4 >> 2] | 0;
          j4 = c2[d4 + 4 >> 2] | 0;
          h3 = c2[a3 >> 2] | 0;
          a3 = _o() | 0;
          c2[m4 >> 2] = k4;
          c2[m4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[m4 >> 2];
          c2[g3 + 4 >> 2] = c2[m4 + 4 >> 2];
          d4 = $o(g3) | 0;
          c2[i4 >> 2] = k4;
          c2[i4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[i4 >> 2];
          c2[g3 + 4 >> 2] = c2[i4 + 4 >> 2];
          fi(h3, b3, a3, d4, ap(g3, e4) | 0, e4);
          l3 = f4;
          return;
        }
        function _o() {
          var b3 = 0, d4 = 0;
          if (!(a2[7776] | 0)) {
            hp(9828);
            Ha(41, 9828, o2 | 0) | 0;
            d4 = 7776;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(9828) | 0)) {
            b3 = 9828;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            hp(9828);
          }
          return 9828;
        }
        function $o(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function ap(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          m4 = l3;
          l3 = l3 + 32 | 0;
          f4 = m4 + 24 | 0;
          h3 = m4 + 16 | 0;
          i4 = m4;
          j4 = m4 + 8 | 0;
          g3 = c2[a3 >> 2] | 0;
          e4 = c2[a3 + 4 >> 2] | 0;
          c2[i4 >> 2] = g3;
          c2[i4 + 4 >> 2] = e4;
          n3 = _o() | 0;
          k4 = n3 + 24 | 0;
          a3 = ji(b3, 4) | 0;
          c2[j4 >> 2] = a3;
          b3 = n3 + 28 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 >>> 0 < (c2[n3 + 32 >> 2] | 0) >>> 0) {
            c2[h3 >> 2] = g3;
            c2[h3 + 4 >> 2] = e4;
            c2[f4 >> 2] = c2[h3 >> 2];
            c2[f4 + 4 >> 2] = c2[h3 + 4 >> 2];
            bp(d4, f4, a3);
            a3 = (c2[b3 >> 2] | 0) + 12 | 0;
            c2[b3 >> 2] = a3;
          } else {
            cp(k4, i4, j4);
            a3 = c2[b3 >> 2] | 0;
          }
          l3 = m4;
          return ((a3 - (c2[k4 >> 2] | 0) | 0) / 12 | 0) + -1 | 0;
        }
        function bp(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = c2[b3 + 4 >> 2] | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 8 >> 2] = d4;
          return;
        }
        function cp(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0;
          k4 = l3;
          l3 = l3 + 48 | 0;
          e4 = k4 + 32 | 0;
          h3 = k4 + 24 | 0;
          i4 = k4;
          j4 = a3 + 4 | 0;
          f4 = (((c2[j4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
          g3 = dp(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            m4 = c2[a3 >> 2] | 0;
            o3 = ((c2[a3 + 8 >> 2] | 0) - m4 | 0) / 12 | 0;
            n3 = o3 << 1;
            ep(i4, o3 >>> 0 < g3 >>> 1 >>> 0 ? n3 >>> 0 < f4 >>> 0 ? f4 : n3 : g3, ((c2[j4 >> 2] | 0) - m4 | 0) / 12 | 0, a3 + 8 | 0);
            j4 = i4 + 8 | 0;
            g3 = c2[j4 >> 2] | 0;
            f4 = c2[b3 + 4 >> 2] | 0;
            d4 = c2[d4 >> 2] | 0;
            c2[h3 >> 2] = c2[b3 >> 2];
            c2[h3 + 4 >> 2] = f4;
            c2[e4 >> 2] = c2[h3 >> 2];
            c2[e4 + 4 >> 2] = c2[h3 + 4 >> 2];
            bp(g3, e4, d4);
            c2[j4 >> 2] = (c2[j4 >> 2] | 0) + 12;
            fp(a3, i4);
            gp(i4);
            l3 = k4;
            return;
          }
        }
        function dp(a3) {
          a3 = a3 | 0;
          return 357913941;
        }
        function ep(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 357913941)
                Ta();
              else {
                f4 = qC(b3 * 12 | 0) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 * 12 | 0) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 * 12 | 0);
          return;
        }
        function fp(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (((f4 | 0) / -12 | 0) * 12 | 0) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function gp(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~(((e4 + -12 - b3 | 0) >>> 0) / 12 | 0) * 12 | 0);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function hp(a3) {
          a3 = a3 | 0;
          kp(a3);
          return;
        }
        function ip(a3) {
          a3 = a3 | 0;
          jp(a3 + 24 | 0);
          return;
        }
        function jp(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~(((b3 + -12 - e4 | 0) >>> 0) / 12 | 0) * 12 | 0);
            sC(d4);
          }
          return;
        }
        function kp(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 2, 7, b3, lp() | 0, 1);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function lp() {
          return 1312;
        }
        function mp(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = np(a3) | 0;
          a3 = c2[h3 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[g3 + 4 >> 2] = a3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          op(b3, f4, d4);
          l3 = e4;
          return;
        }
        function np(a3) {
          a3 = a3 | 0;
          return (c2[(_o() | 0) + 24 >> 2] | 0) + (a3 * 12 | 0) | 0;
        }
        function op(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0;
          g3 = l3;
          l3 = l3 + 16 | 0;
          f4 = g3;
          e4 = c2[b3 >> 2] | 0;
          b3 = c2[b3 + 4 >> 2] | 0;
          a3 = a3 + (b3 >> 1) | 0;
          if (b3 & 1)
            e4 = c2[(c2[a3 >> 2] | 0) + e4 >> 2] | 0;
          tj(f4, d4);
          f4 = uj(f4, d4) | 0;
          ob[e4 & 31](a3, f4);
          l3 = g3;
          return;
        }
        function pp(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          i4 = c2[d4 >> 2] | 0;
          h3 = c2[d4 + 4 >> 2] | 0;
          d4 = ai(b3) | 0;
          c2[g3 >> 2] = i4;
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          qp(a3, d4, f4, 0);
          l3 = e4;
          return;
        }
        function qp(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4 + 16 | 0;
          m4 = f4 + 8 | 0;
          i4 = f4;
          k4 = c2[d4 >> 2] | 0;
          j4 = c2[d4 + 4 >> 2] | 0;
          h3 = c2[a3 >> 2] | 0;
          a3 = rp() | 0;
          c2[m4 >> 2] = k4;
          c2[m4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[m4 >> 2];
          c2[g3 + 4 >> 2] = c2[m4 + 4 >> 2];
          d4 = sp(g3) | 0;
          c2[i4 >> 2] = k4;
          c2[i4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[i4 >> 2];
          c2[g3 + 4 >> 2] = c2[i4 + 4 >> 2];
          fi(h3, b3, a3, d4, tp(g3, e4) | 0, e4);
          l3 = f4;
          return;
        }
        function rp() {
          var b3 = 0, d4 = 0;
          if (!(a2[7784] | 0)) {
            Ap(9864);
            Ha(42, 9864, o2 | 0) | 0;
            d4 = 7784;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(9864) | 0)) {
            b3 = 9864;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            Ap(9864);
          }
          return 9864;
        }
        function sp(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function tp(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          m4 = l3;
          l3 = l3 + 32 | 0;
          f4 = m4 + 24 | 0;
          h3 = m4 + 16 | 0;
          i4 = m4;
          j4 = m4 + 8 | 0;
          g3 = c2[a3 >> 2] | 0;
          e4 = c2[a3 + 4 >> 2] | 0;
          c2[i4 >> 2] = g3;
          c2[i4 + 4 >> 2] = e4;
          n3 = rp() | 0;
          k4 = n3 + 24 | 0;
          a3 = ji(b3, 4) | 0;
          c2[j4 >> 2] = a3;
          b3 = n3 + 28 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 >>> 0 < (c2[n3 + 32 >> 2] | 0) >>> 0) {
            c2[h3 >> 2] = g3;
            c2[h3 + 4 >> 2] = e4;
            c2[f4 >> 2] = c2[h3 >> 2];
            c2[f4 + 4 >> 2] = c2[h3 + 4 >> 2];
            up(d4, f4, a3);
            a3 = (c2[b3 >> 2] | 0) + 12 | 0;
            c2[b3 >> 2] = a3;
          } else {
            vp(k4, i4, j4);
            a3 = c2[b3 >> 2] | 0;
          }
          l3 = m4;
          return ((a3 - (c2[k4 >> 2] | 0) | 0) / 12 | 0) + -1 | 0;
        }
        function up(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = c2[b3 + 4 >> 2] | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 8 >> 2] = d4;
          return;
        }
        function vp(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0;
          k4 = l3;
          l3 = l3 + 48 | 0;
          e4 = k4 + 32 | 0;
          h3 = k4 + 24 | 0;
          i4 = k4;
          j4 = a3 + 4 | 0;
          f4 = (((c2[j4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
          g3 = wp(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            m4 = c2[a3 >> 2] | 0;
            o3 = ((c2[a3 + 8 >> 2] | 0) - m4 | 0) / 12 | 0;
            n3 = o3 << 1;
            xp(i4, o3 >>> 0 < g3 >>> 1 >>> 0 ? n3 >>> 0 < f4 >>> 0 ? f4 : n3 : g3, ((c2[j4 >> 2] | 0) - m4 | 0) / 12 | 0, a3 + 8 | 0);
            j4 = i4 + 8 | 0;
            g3 = c2[j4 >> 2] | 0;
            f4 = c2[b3 + 4 >> 2] | 0;
            d4 = c2[d4 >> 2] | 0;
            c2[h3 >> 2] = c2[b3 >> 2];
            c2[h3 + 4 >> 2] = f4;
            c2[e4 >> 2] = c2[h3 >> 2];
            c2[e4 + 4 >> 2] = c2[h3 + 4 >> 2];
            up(g3, e4, d4);
            c2[j4 >> 2] = (c2[j4 >> 2] | 0) + 12;
            yp(a3, i4);
            zp(i4);
            l3 = k4;
            return;
          }
        }
        function wp(a3) {
          a3 = a3 | 0;
          return 357913941;
        }
        function xp(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 357913941)
                Ta();
              else {
                f4 = qC(b3 * 12 | 0) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 * 12 | 0) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 * 12 | 0);
          return;
        }
        function yp(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (((f4 | 0) / -12 | 0) * 12 | 0) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function zp(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~(((e4 + -12 - b3 | 0) >>> 0) / 12 | 0) * 12 | 0);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function Ap(a3) {
          a3 = a3 | 0;
          Dp(a3);
          return;
        }
        function Bp(a3) {
          a3 = a3 | 0;
          Cp(a3 + 24 | 0);
          return;
        }
        function Cp(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~(((b3 + -12 - e4 | 0) >>> 0) / 12 | 0) * 12 | 0);
            sC(d4);
          }
          return;
        }
        function Dp(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 2, 8, b3, Ep() | 0, 1);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function Ep() {
          return 1320;
        }
        function Fp(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = Gp(a3) | 0;
          a3 = c2[h3 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[g3 + 4 >> 2] = a3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Hp(b3, f4, d4);
          l3 = e4;
          return;
        }
        function Gp(a3) {
          a3 = a3 | 0;
          return (c2[(rp() | 0) + 24 >> 2] | 0) + (a3 * 12 | 0) | 0;
        }
        function Hp(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0;
          g3 = l3;
          l3 = l3 + 16 | 0;
          f4 = g3;
          e4 = c2[b3 >> 2] | 0;
          b3 = c2[b3 + 4 >> 2] | 0;
          a3 = a3 + (b3 >> 1) | 0;
          if (b3 & 1)
            e4 = c2[(c2[a3 >> 2] | 0) + e4 >> 2] | 0;
          Ip(f4, d4);
          f4 = Jp(f4, d4) | 0;
          ob[e4 & 31](a3, f4);
          l3 = g3;
          return;
        }
        function Ip(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return;
        }
        function Jp(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return Kp(b3) | 0;
        }
        function Kp(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function Lp(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          i4 = c2[d4 >> 2] | 0;
          h3 = c2[d4 + 4 >> 2] | 0;
          d4 = ai(b3) | 0;
          c2[g3 >> 2] = i4;
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Mp(a3, d4, f4, 0);
          l3 = e4;
          return;
        }
        function Mp(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4 + 16 | 0;
          m4 = f4 + 8 | 0;
          i4 = f4;
          k4 = c2[d4 >> 2] | 0;
          j4 = c2[d4 + 4 >> 2] | 0;
          h3 = c2[a3 >> 2] | 0;
          a3 = Np() | 0;
          c2[m4 >> 2] = k4;
          c2[m4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[m4 >> 2];
          c2[g3 + 4 >> 2] = c2[m4 + 4 >> 2];
          d4 = Op(g3) | 0;
          c2[i4 >> 2] = k4;
          c2[i4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[i4 >> 2];
          c2[g3 + 4 >> 2] = c2[i4 + 4 >> 2];
          fi(h3, b3, a3, d4, Pp(g3, e4) | 0, e4);
          l3 = f4;
          return;
        }
        function Np() {
          var b3 = 0, d4 = 0;
          if (!(a2[7792] | 0)) {
            Wp(9900);
            Ha(43, 9900, o2 | 0) | 0;
            d4 = 7792;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(9900) | 0)) {
            b3 = 9900;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            Wp(9900);
          }
          return 9900;
        }
        function Op(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function Pp(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          m4 = l3;
          l3 = l3 + 32 | 0;
          f4 = m4 + 24 | 0;
          h3 = m4 + 16 | 0;
          i4 = m4;
          j4 = m4 + 8 | 0;
          g3 = c2[a3 >> 2] | 0;
          e4 = c2[a3 + 4 >> 2] | 0;
          c2[i4 >> 2] = g3;
          c2[i4 + 4 >> 2] = e4;
          n3 = Np() | 0;
          k4 = n3 + 24 | 0;
          a3 = ji(b3, 4) | 0;
          c2[j4 >> 2] = a3;
          b3 = n3 + 28 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 >>> 0 < (c2[n3 + 32 >> 2] | 0) >>> 0) {
            c2[h3 >> 2] = g3;
            c2[h3 + 4 >> 2] = e4;
            c2[f4 >> 2] = c2[h3 >> 2];
            c2[f4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Qp(d4, f4, a3);
            a3 = (c2[b3 >> 2] | 0) + 12 | 0;
            c2[b3 >> 2] = a3;
          } else {
            Rp(k4, i4, j4);
            a3 = c2[b3 >> 2] | 0;
          }
          l3 = m4;
          return ((a3 - (c2[k4 >> 2] | 0) | 0) / 12 | 0) + -1 | 0;
        }
        function Qp(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = c2[b3 + 4 >> 2] | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 8 >> 2] = d4;
          return;
        }
        function Rp(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0;
          k4 = l3;
          l3 = l3 + 48 | 0;
          e4 = k4 + 32 | 0;
          h3 = k4 + 24 | 0;
          i4 = k4;
          j4 = a3 + 4 | 0;
          f4 = (((c2[j4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
          g3 = Sp(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            m4 = c2[a3 >> 2] | 0;
            o3 = ((c2[a3 + 8 >> 2] | 0) - m4 | 0) / 12 | 0;
            n3 = o3 << 1;
            Tp(i4, o3 >>> 0 < g3 >>> 1 >>> 0 ? n3 >>> 0 < f4 >>> 0 ? f4 : n3 : g3, ((c2[j4 >> 2] | 0) - m4 | 0) / 12 | 0, a3 + 8 | 0);
            j4 = i4 + 8 | 0;
            g3 = c2[j4 >> 2] | 0;
            f4 = c2[b3 + 4 >> 2] | 0;
            d4 = c2[d4 >> 2] | 0;
            c2[h3 >> 2] = c2[b3 >> 2];
            c2[h3 + 4 >> 2] = f4;
            c2[e4 >> 2] = c2[h3 >> 2];
            c2[e4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Qp(g3, e4, d4);
            c2[j4 >> 2] = (c2[j4 >> 2] | 0) + 12;
            Up(a3, i4);
            Vp(i4);
            l3 = k4;
            return;
          }
        }
        function Sp(a3) {
          a3 = a3 | 0;
          return 357913941;
        }
        function Tp(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 357913941)
                Ta();
              else {
                f4 = qC(b3 * 12 | 0) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 * 12 | 0) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 * 12 | 0);
          return;
        }
        function Up(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (((f4 | 0) / -12 | 0) * 12 | 0) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function Vp(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~(((e4 + -12 - b3 | 0) >>> 0) / 12 | 0) * 12 | 0);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function Wp(a3) {
          a3 = a3 | 0;
          Zp(a3);
          return;
        }
        function Xp(a3) {
          a3 = a3 | 0;
          Yp(a3 + 24 | 0);
          return;
        }
        function Yp(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~(((b3 + -12 - e4 | 0) >>> 0) / 12 | 0) * 12 | 0);
            sC(d4);
          }
          return;
        }
        function Zp(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 2, 22, b3, _p() | 0, 0);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function _p() {
          return 1344;
        }
        function $p(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0;
          d4 = l3;
          l3 = l3 + 16 | 0;
          e4 = d4 + 8 | 0;
          f4 = d4;
          g3 = aq(a3) | 0;
          a3 = c2[g3 + 4 >> 2] | 0;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = a3;
          c2[e4 >> 2] = c2[f4 >> 2];
          c2[e4 + 4 >> 2] = c2[f4 + 4 >> 2];
          bq(b3, e4);
          l3 = d4;
          return;
        }
        function aq(a3) {
          a3 = a3 | 0;
          return (c2[(Np() | 0) + 24 >> 2] | 0) + (a3 * 12 | 0) | 0;
        }
        function bq(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = c2[b3 >> 2] | 0;
          b3 = c2[b3 + 4 >> 2] | 0;
          a3 = a3 + (b3 >> 1) | 0;
          if (b3 & 1)
            d4 = c2[(c2[a3 >> 2] | 0) + d4 >> 2] | 0;
          nb[d4 & 127](a3);
          return;
        }
        function cq(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0;
          g3 = c2[a3 >> 2] | 0;
          f4 = dq() | 0;
          a3 = eq(d4) | 0;
          fi(g3, b3, f4, a3, fq(d4, e4) | 0, e4);
          return;
        }
        function dq() {
          var b3 = 0, d4 = 0;
          if (!(a2[7800] | 0)) {
            mq(9936);
            Ha(44, 9936, o2 | 0) | 0;
            d4 = 7800;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(9936) | 0)) {
            b3 = 9936;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            mq(9936);
          }
          return 9936;
        }
        function eq(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function fq(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          i4 = l3;
          l3 = l3 + 16 | 0;
          f4 = i4;
          g3 = i4 + 4 | 0;
          c2[f4 >> 2] = a3;
          j4 = dq() | 0;
          h3 = j4 + 24 | 0;
          b3 = ji(b3, 4) | 0;
          c2[g3 >> 2] = b3;
          d4 = j4 + 28 | 0;
          e4 = c2[d4 >> 2] | 0;
          if (e4 >>> 0 < (c2[j4 + 32 >> 2] | 0) >>> 0) {
            gq(e4, a3, b3);
            b3 = (c2[d4 >> 2] | 0) + 8 | 0;
            c2[d4 >> 2] = b3;
          } else {
            hq(h3, f4, g3);
            b3 = c2[d4 >> 2] | 0;
          }
          l3 = i4;
          return (b3 - (c2[h3 >> 2] | 0) >> 3) + -1 | 0;
        }
        function gq(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          c2[a3 >> 2] = b3;
          c2[a3 + 4 >> 2] = d4;
          return;
        }
        function hq(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          i4 = l3;
          l3 = l3 + 32 | 0;
          f4 = i4;
          g3 = a3 + 4 | 0;
          h3 = ((c2[g3 >> 2] | 0) - (c2[a3 >> 2] | 0) >> 3) + 1 | 0;
          e4 = iq(a3) | 0;
          if (e4 >>> 0 < h3 >>> 0)
            jC(a3);
          else {
            j4 = c2[a3 >> 2] | 0;
            m4 = (c2[a3 + 8 >> 2] | 0) - j4 | 0;
            k4 = m4 >> 2;
            jq(f4, m4 >> 3 >>> 0 < e4 >>> 1 >>> 0 ? k4 >>> 0 < h3 >>> 0 ? h3 : k4 : e4, (c2[g3 >> 2] | 0) - j4 >> 3, a3 + 8 | 0);
            h3 = f4 + 8 | 0;
            gq(c2[h3 >> 2] | 0, c2[b3 >> 2] | 0, c2[d4 >> 2] | 0);
            c2[h3 >> 2] = (c2[h3 >> 2] | 0) + 8;
            kq(a3, f4);
            lq(f4);
            l3 = i4;
            return;
          }
        }
        function iq(a3) {
          a3 = a3 | 0;
          return 536870911;
        }
        function jq(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 536870911)
                Ta();
              else {
                f4 = qC(b3 << 3) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 << 3) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 << 3);
          return;
        }
        function kq(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (0 - (f4 >> 3) << 3) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function lq(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~((e4 + -8 - b3 | 0) >>> 3) << 3);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function mq(a3) {
          a3 = a3 | 0;
          pq(a3);
          return;
        }
        function nq(a3) {
          a3 = a3 | 0;
          oq(a3 + 24 | 0);
          return;
        }
        function oq(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~((b3 + -8 - e4 | 0) >>> 3) << 3);
            sC(d4);
          }
          return;
        }
        function pq(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 1, 23, b3, Kl() | 0, 1);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function qq(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          sq(c2[(rq(a3) | 0) >> 2] | 0, b3);
          return;
        }
        function rq(a3) {
          a3 = a3 | 0;
          return (c2[(dq() | 0) + 24 >> 2] | 0) + (a3 << 3) | 0;
        }
        function sq(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var c3 = 0, d4 = 0;
          c3 = l3;
          l3 = l3 + 16 | 0;
          d4 = c3;
          Ol(d4, b3);
          b3 = Pl(d4, b3) | 0;
          nb[a3 & 127](b3);
          l3 = c3;
          return;
        }
        function tq(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0;
          g3 = c2[a3 >> 2] | 0;
          f4 = uq() | 0;
          a3 = vq(d4) | 0;
          fi(g3, b3, f4, a3, wq(d4, e4) | 0, e4);
          return;
        }
        function uq() {
          var b3 = 0, d4 = 0;
          if (!(a2[7808] | 0)) {
            Dq(9972);
            Ha(45, 9972, o2 | 0) | 0;
            d4 = 7808;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(9972) | 0)) {
            b3 = 9972;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            Dq(9972);
          }
          return 9972;
        }
        function vq(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function wq(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          i4 = l3;
          l3 = l3 + 16 | 0;
          f4 = i4;
          g3 = i4 + 4 | 0;
          c2[f4 >> 2] = a3;
          j4 = uq() | 0;
          h3 = j4 + 24 | 0;
          b3 = ji(b3, 4) | 0;
          c2[g3 >> 2] = b3;
          d4 = j4 + 28 | 0;
          e4 = c2[d4 >> 2] | 0;
          if (e4 >>> 0 < (c2[j4 + 32 >> 2] | 0) >>> 0) {
            xq(e4, a3, b3);
            b3 = (c2[d4 >> 2] | 0) + 8 | 0;
            c2[d4 >> 2] = b3;
          } else {
            yq(h3, f4, g3);
            b3 = c2[d4 >> 2] | 0;
          }
          l3 = i4;
          return (b3 - (c2[h3 >> 2] | 0) >> 3) + -1 | 0;
        }
        function xq(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          c2[a3 >> 2] = b3;
          c2[a3 + 4 >> 2] = d4;
          return;
        }
        function yq(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          i4 = l3;
          l3 = l3 + 32 | 0;
          f4 = i4;
          g3 = a3 + 4 | 0;
          h3 = ((c2[g3 >> 2] | 0) - (c2[a3 >> 2] | 0) >> 3) + 1 | 0;
          e4 = zq(a3) | 0;
          if (e4 >>> 0 < h3 >>> 0)
            jC(a3);
          else {
            j4 = c2[a3 >> 2] | 0;
            m4 = (c2[a3 + 8 >> 2] | 0) - j4 | 0;
            k4 = m4 >> 2;
            Aq(f4, m4 >> 3 >>> 0 < e4 >>> 1 >>> 0 ? k4 >>> 0 < h3 >>> 0 ? h3 : k4 : e4, (c2[g3 >> 2] | 0) - j4 >> 3, a3 + 8 | 0);
            h3 = f4 + 8 | 0;
            xq(c2[h3 >> 2] | 0, c2[b3 >> 2] | 0, c2[d4 >> 2] | 0);
            c2[h3 >> 2] = (c2[h3 >> 2] | 0) + 8;
            Bq(a3, f4);
            Cq(f4);
            l3 = i4;
            return;
          }
        }
        function zq(a3) {
          a3 = a3 | 0;
          return 536870911;
        }
        function Aq(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 536870911)
                Ta();
              else {
                f4 = qC(b3 << 3) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 << 3) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 << 3);
          return;
        }
        function Bq(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (0 - (f4 >> 3) << 3) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function Cq(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~((e4 + -8 - b3 | 0) >>> 3) << 3);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function Dq(a3) {
          a3 = a3 | 0;
          Gq(a3);
          return;
        }
        function Eq(a3) {
          a3 = a3 | 0;
          Fq(a3 + 24 | 0);
          return;
        }
        function Fq(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~((b3 + -8 - e4 | 0) >>> 3) << 3);
            sC(d4);
          }
          return;
        }
        function Gq(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 1, 9, b3, Hq() | 0, 1);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function Hq() {
          return 1348;
        }
        function Iq(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return Kq(c2[(Jq(a3) | 0) >> 2] | 0, b3) | 0;
        }
        function Jq(a3) {
          a3 = a3 | 0;
          return (c2[(uq() | 0) + 24 >> 2] | 0) + (a3 << 3) | 0;
        }
        function Kq(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var c3 = 0, d4 = 0;
          c3 = l3;
          l3 = l3 + 16 | 0;
          d4 = c3;
          Lq(d4, b3);
          b3 = Mq(d4, b3) | 0;
          b3 = Ik(pb[a3 & 31](b3) | 0) | 0;
          l3 = c3;
          return b3 | 0;
        }
        function Lq(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return;
        }
        function Mq(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return Nq(b3) | 0;
        }
        function Nq(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function Oq(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0;
          g3 = c2[a3 >> 2] | 0;
          f4 = Pq() | 0;
          a3 = Qq(d4) | 0;
          fi(g3, b3, f4, a3, Rq(d4, e4) | 0, e4);
          return;
        }
        function Pq() {
          var b3 = 0, d4 = 0;
          if (!(a2[7816] | 0)) {
            Yq(10008);
            Ha(46, 10008, o2 | 0) | 0;
            d4 = 7816;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(10008) | 0)) {
            b3 = 10008;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            Yq(10008);
          }
          return 10008;
        }
        function Qq(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function Rq(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          i4 = l3;
          l3 = l3 + 16 | 0;
          f4 = i4;
          g3 = i4 + 4 | 0;
          c2[f4 >> 2] = a3;
          j4 = Pq() | 0;
          h3 = j4 + 24 | 0;
          b3 = ji(b3, 4) | 0;
          c2[g3 >> 2] = b3;
          d4 = j4 + 28 | 0;
          e4 = c2[d4 >> 2] | 0;
          if (e4 >>> 0 < (c2[j4 + 32 >> 2] | 0) >>> 0) {
            Sq(e4, a3, b3);
            b3 = (c2[d4 >> 2] | 0) + 8 | 0;
            c2[d4 >> 2] = b3;
          } else {
            Tq(h3, f4, g3);
            b3 = c2[d4 >> 2] | 0;
          }
          l3 = i4;
          return (b3 - (c2[h3 >> 2] | 0) >> 3) + -1 | 0;
        }
        function Sq(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          c2[a3 >> 2] = b3;
          c2[a3 + 4 >> 2] = d4;
          return;
        }
        function Tq(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          i4 = l3;
          l3 = l3 + 32 | 0;
          f4 = i4;
          g3 = a3 + 4 | 0;
          h3 = ((c2[g3 >> 2] | 0) - (c2[a3 >> 2] | 0) >> 3) + 1 | 0;
          e4 = Uq(a3) | 0;
          if (e4 >>> 0 < h3 >>> 0)
            jC(a3);
          else {
            j4 = c2[a3 >> 2] | 0;
            m4 = (c2[a3 + 8 >> 2] | 0) - j4 | 0;
            k4 = m4 >> 2;
            Vq(f4, m4 >> 3 >>> 0 < e4 >>> 1 >>> 0 ? k4 >>> 0 < h3 >>> 0 ? h3 : k4 : e4, (c2[g3 >> 2] | 0) - j4 >> 3, a3 + 8 | 0);
            h3 = f4 + 8 | 0;
            Sq(c2[h3 >> 2] | 0, c2[b3 >> 2] | 0, c2[d4 >> 2] | 0);
            c2[h3 >> 2] = (c2[h3 >> 2] | 0) + 8;
            Wq(a3, f4);
            Xq(f4);
            l3 = i4;
            return;
          }
        }
        function Uq(a3) {
          a3 = a3 | 0;
          return 536870911;
        }
        function Vq(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 536870911)
                Ta();
              else {
                f4 = qC(b3 << 3) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 << 3) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 << 3);
          return;
        }
        function Wq(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (0 - (f4 >> 3) << 3) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function Xq(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~((e4 + -8 - b3 | 0) >>> 3) << 3);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function Yq(a3) {
          a3 = a3 | 0;
          $q(a3);
          return;
        }
        function Zq(a3) {
          a3 = a3 | 0;
          _q(a3 + 24 | 0);
          return;
        }
        function _q(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~((b3 + -8 - e4 | 0) >>> 3) << 3);
            sC(d4);
          }
          return;
        }
        function $q(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 1, 15, b3, Zk() | 0, 0);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function ar(a3) {
          a3 = a3 | 0;
          return cr(c2[(br(a3) | 0) >> 2] | 0) | 0;
        }
        function br(a3) {
          a3 = a3 | 0;
          return (c2[(Pq() | 0) + 24 >> 2] | 0) + (a3 << 3) | 0;
        }
        function cr(a3) {
          a3 = a3 | 0;
          return Ik(Ab[a3 & 7]() | 0) | 0;
        }
        function dr() {
          var b3 = 0;
          if (!(a2[7832] | 0)) {
            nr(10052);
            Ha(25, 10052, o2 | 0) | 0;
            b3 = 7832;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          return 10052;
        }
        function er(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c2[a3 >> 2] = fr() | 0;
          c2[a3 + 4 >> 2] = gr() | 0;
          c2[a3 + 12 >> 2] = b3;
          c2[a3 + 8 >> 2] = hr() | 0;
          c2[a3 + 32 >> 2] = 2;
          return;
        }
        function fr() {
          return 11709;
        }
        function gr() {
          return 1188;
        }
        function hr() {
          return lr() | 0;
        }
        function ir(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          if ((jr(d4, 896) | 0) == 512) {
            if (c3 | 0) {
              kr(c3);
              sC(c3);
            }
          } else if (b3 | 0) {
            uf(b3);
            sC(b3);
          }
          return;
        }
        function jr(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return b3 & a3 | 0;
        }
        function kr(a3) {
          a3 = a3 | 0;
          a3 = c2[a3 + 4 >> 2] | 0;
          if (a3 | 0)
            oC(a3);
          return;
        }
        function lr() {
          var b3 = 0;
          if (!(a2[7824] | 0)) {
            c2[2511] = mr() | 0;
            c2[2512] = 0;
            b3 = 7824;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          return 10044;
        }
        function mr() {
          return 0;
        }
        function nr(a3) {
          a3 = a3 | 0;
          Zi(a3);
          return;
        }
        function or(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0, f4 = 0, g3 = 0;
          b3 = l3;
          l3 = l3 + 32 | 0;
          d4 = b3 + 24 | 0;
          g3 = b3 + 16 | 0;
          f4 = b3 + 8 | 0;
          e4 = b3;
          pr(a3, 4827);
          qr(a3, 4834, 3) | 0;
          rr(a3, 3682, 47) | 0;
          c2[g3 >> 2] = 9;
          c2[g3 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[g3 >> 2];
          c2[d4 + 4 >> 2] = c2[g3 + 4 >> 2];
          sr(a3, 4841, d4) | 0;
          c2[f4 >> 2] = 1;
          c2[f4 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[f4 >> 2];
          c2[d4 + 4 >> 2] = c2[f4 + 4 >> 2];
          tr(a3, 4871, d4) | 0;
          c2[e4 >> 2] = 10;
          c2[e4 + 4 >> 2] = 0;
          c2[d4 >> 2] = c2[e4 >> 2];
          c2[d4 + 4 >> 2] = c2[e4 + 4 >> 2];
          ur(a3, 4891, d4) | 0;
          l3 = b3;
          return;
        }
        function pr(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = nt() | 0;
          c2[a3 >> 2] = d4;
          ot(d4, b3);
          Hv(c2[a3 >> 2] | 0);
          return;
        }
        function qr(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          Ws(a3, ai(b3) | 0, c3, 0);
          return a3 | 0;
        }
        function rr(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          Es(a3, ai(b3) | 0, c3, 0);
          return a3 | 0;
        }
        function sr(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = c2[d4 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[d4 >> 2];
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          is(a3, b3, f4);
          l3 = e4;
          return a3 | 0;
        }
        function tr(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = c2[d4 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[d4 >> 2];
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Or(a3, b3, f4);
          l3 = e4;
          return a3 | 0;
        }
        function ur(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = c2[d4 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[d4 >> 2];
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          vr(a3, b3, f4);
          l3 = e4;
          return a3 | 0;
        }
        function vr(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          i4 = c2[d4 >> 2] | 0;
          h3 = c2[d4 + 4 >> 2] | 0;
          d4 = ai(b3) | 0;
          c2[g3 >> 2] = i4;
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          wr(a3, d4, f4, 1);
          l3 = e4;
          return;
        }
        function wr(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4 + 16 | 0;
          m4 = f4 + 8 | 0;
          i4 = f4;
          k4 = c2[d4 >> 2] | 0;
          j4 = c2[d4 + 4 >> 2] | 0;
          h3 = c2[a3 >> 2] | 0;
          a3 = xr() | 0;
          c2[m4 >> 2] = k4;
          c2[m4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[m4 >> 2];
          c2[g3 + 4 >> 2] = c2[m4 + 4 >> 2];
          d4 = yr(g3) | 0;
          c2[i4 >> 2] = k4;
          c2[i4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[i4 >> 2];
          c2[g3 + 4 >> 2] = c2[i4 + 4 >> 2];
          fi(h3, b3, a3, d4, zr(g3, e4) | 0, e4);
          l3 = f4;
          return;
        }
        function xr() {
          var b3 = 0, d4 = 0;
          if (!(a2[7840] | 0)) {
            Gr(10100);
            Ha(48, 10100, o2 | 0) | 0;
            d4 = 7840;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(10100) | 0)) {
            b3 = 10100;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            Gr(10100);
          }
          return 10100;
        }
        function yr(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function zr(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          m4 = l3;
          l3 = l3 + 32 | 0;
          f4 = m4 + 24 | 0;
          h3 = m4 + 16 | 0;
          i4 = m4;
          j4 = m4 + 8 | 0;
          g3 = c2[a3 >> 2] | 0;
          e4 = c2[a3 + 4 >> 2] | 0;
          c2[i4 >> 2] = g3;
          c2[i4 + 4 >> 2] = e4;
          n3 = xr() | 0;
          k4 = n3 + 24 | 0;
          a3 = ji(b3, 4) | 0;
          c2[j4 >> 2] = a3;
          b3 = n3 + 28 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 >>> 0 < (c2[n3 + 32 >> 2] | 0) >>> 0) {
            c2[h3 >> 2] = g3;
            c2[h3 + 4 >> 2] = e4;
            c2[f4 >> 2] = c2[h3 >> 2];
            c2[f4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Ar(d4, f4, a3);
            a3 = (c2[b3 >> 2] | 0) + 12 | 0;
            c2[b3 >> 2] = a3;
          } else {
            Br(k4, i4, j4);
            a3 = c2[b3 >> 2] | 0;
          }
          l3 = m4;
          return ((a3 - (c2[k4 >> 2] | 0) | 0) / 12 | 0) + -1 | 0;
        }
        function Ar(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = c2[b3 + 4 >> 2] | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 8 >> 2] = d4;
          return;
        }
        function Br(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0;
          k4 = l3;
          l3 = l3 + 48 | 0;
          e4 = k4 + 32 | 0;
          h3 = k4 + 24 | 0;
          i4 = k4;
          j4 = a3 + 4 | 0;
          f4 = (((c2[j4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
          g3 = Cr(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            m4 = c2[a3 >> 2] | 0;
            o3 = ((c2[a3 + 8 >> 2] | 0) - m4 | 0) / 12 | 0;
            n3 = o3 << 1;
            Dr(i4, o3 >>> 0 < g3 >>> 1 >>> 0 ? n3 >>> 0 < f4 >>> 0 ? f4 : n3 : g3, ((c2[j4 >> 2] | 0) - m4 | 0) / 12 | 0, a3 + 8 | 0);
            j4 = i4 + 8 | 0;
            g3 = c2[j4 >> 2] | 0;
            f4 = c2[b3 + 4 >> 2] | 0;
            d4 = c2[d4 >> 2] | 0;
            c2[h3 >> 2] = c2[b3 >> 2];
            c2[h3 + 4 >> 2] = f4;
            c2[e4 >> 2] = c2[h3 >> 2];
            c2[e4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Ar(g3, e4, d4);
            c2[j4 >> 2] = (c2[j4 >> 2] | 0) + 12;
            Er(a3, i4);
            Fr(i4);
            l3 = k4;
            return;
          }
        }
        function Cr(a3) {
          a3 = a3 | 0;
          return 357913941;
        }
        function Dr(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 357913941)
                Ta();
              else {
                f4 = qC(b3 * 12 | 0) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 * 12 | 0) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 * 12 | 0);
          return;
        }
        function Er(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (((f4 | 0) / -12 | 0) * 12 | 0) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function Fr(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~(((e4 + -12 - b3 | 0) >>> 0) / 12 | 0) * 12 | 0);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function Gr(a3) {
          a3 = a3 | 0;
          Jr(a3);
          return;
        }
        function Hr(a3) {
          a3 = a3 | 0;
          Ir(a3 + 24 | 0);
          return;
        }
        function Ir(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~(((b3 + -12 - e4 | 0) >>> 0) / 12 | 0) * 12 | 0);
            sC(d4);
          }
          return;
        }
        function Jr(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 2, 6, b3, Kr() | 0, 1);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function Kr() {
          return 1364;
        }
        function Lr(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = Mr(a3) | 0;
          a3 = c2[h3 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[g3 + 4 >> 2] = a3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          d4 = Nr(b3, f4, d4) | 0;
          l3 = e4;
          return d4 | 0;
        }
        function Mr(a3) {
          a3 = a3 | 0;
          return (c2[(xr() | 0) + 24 >> 2] | 0) + (a3 * 12 | 0) | 0;
        }
        function Nr(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0;
          g3 = l3;
          l3 = l3 + 16 | 0;
          f4 = g3;
          e4 = c2[b3 >> 2] | 0;
          b3 = c2[b3 + 4 >> 2] | 0;
          a3 = a3 + (b3 >> 1) | 0;
          if (b3 & 1)
            e4 = c2[(c2[a3 >> 2] | 0) + e4 >> 2] | 0;
          tj(f4, d4);
          f4 = uj(f4, d4) | 0;
          f4 = Qj(wb[e4 & 15](a3, f4) | 0) | 0;
          l3 = g3;
          return f4 | 0;
        }
        function Or(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          i4 = c2[d4 >> 2] | 0;
          h3 = c2[d4 + 4 >> 2] | 0;
          d4 = ai(b3) | 0;
          c2[g3 >> 2] = i4;
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          Pr(a3, d4, f4, 0);
          l3 = e4;
          return;
        }
        function Pr(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4 + 16 | 0;
          m4 = f4 + 8 | 0;
          i4 = f4;
          k4 = c2[d4 >> 2] | 0;
          j4 = c2[d4 + 4 >> 2] | 0;
          h3 = c2[a3 >> 2] | 0;
          a3 = Qr() | 0;
          c2[m4 >> 2] = k4;
          c2[m4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[m4 >> 2];
          c2[g3 + 4 >> 2] = c2[m4 + 4 >> 2];
          d4 = Rr(g3) | 0;
          c2[i4 >> 2] = k4;
          c2[i4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[i4 >> 2];
          c2[g3 + 4 >> 2] = c2[i4 + 4 >> 2];
          fi(h3, b3, a3, d4, Sr(g3, e4) | 0, e4);
          l3 = f4;
          return;
        }
        function Qr() {
          var b3 = 0, d4 = 0;
          if (!(a2[7848] | 0)) {
            Zr(10136);
            Ha(49, 10136, o2 | 0) | 0;
            d4 = 7848;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(10136) | 0)) {
            b3 = 10136;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            Zr(10136);
          }
          return 10136;
        }
        function Rr(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function Sr(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          m4 = l3;
          l3 = l3 + 32 | 0;
          f4 = m4 + 24 | 0;
          h3 = m4 + 16 | 0;
          i4 = m4;
          j4 = m4 + 8 | 0;
          g3 = c2[a3 >> 2] | 0;
          e4 = c2[a3 + 4 >> 2] | 0;
          c2[i4 >> 2] = g3;
          c2[i4 + 4 >> 2] = e4;
          n3 = Qr() | 0;
          k4 = n3 + 24 | 0;
          a3 = ji(b3, 4) | 0;
          c2[j4 >> 2] = a3;
          b3 = n3 + 28 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 >>> 0 < (c2[n3 + 32 >> 2] | 0) >>> 0) {
            c2[h3 >> 2] = g3;
            c2[h3 + 4 >> 2] = e4;
            c2[f4 >> 2] = c2[h3 >> 2];
            c2[f4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Tr(d4, f4, a3);
            a3 = (c2[b3 >> 2] | 0) + 12 | 0;
            c2[b3 >> 2] = a3;
          } else {
            Ur(k4, i4, j4);
            a3 = c2[b3 >> 2] | 0;
          }
          l3 = m4;
          return ((a3 - (c2[k4 >> 2] | 0) | 0) / 12 | 0) + -1 | 0;
        }
        function Tr(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = c2[b3 + 4 >> 2] | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 8 >> 2] = d4;
          return;
        }
        function Ur(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0;
          k4 = l3;
          l3 = l3 + 48 | 0;
          e4 = k4 + 32 | 0;
          h3 = k4 + 24 | 0;
          i4 = k4;
          j4 = a3 + 4 | 0;
          f4 = (((c2[j4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
          g3 = Vr(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            m4 = c2[a3 >> 2] | 0;
            o3 = ((c2[a3 + 8 >> 2] | 0) - m4 | 0) / 12 | 0;
            n3 = o3 << 1;
            Wr(i4, o3 >>> 0 < g3 >>> 1 >>> 0 ? n3 >>> 0 < f4 >>> 0 ? f4 : n3 : g3, ((c2[j4 >> 2] | 0) - m4 | 0) / 12 | 0, a3 + 8 | 0);
            j4 = i4 + 8 | 0;
            g3 = c2[j4 >> 2] | 0;
            f4 = c2[b3 + 4 >> 2] | 0;
            d4 = c2[d4 >> 2] | 0;
            c2[h3 >> 2] = c2[b3 >> 2];
            c2[h3 + 4 >> 2] = f4;
            c2[e4 >> 2] = c2[h3 >> 2];
            c2[e4 + 4 >> 2] = c2[h3 + 4 >> 2];
            Tr(g3, e4, d4);
            c2[j4 >> 2] = (c2[j4 >> 2] | 0) + 12;
            Xr(a3, i4);
            Yr(i4);
            l3 = k4;
            return;
          }
        }
        function Vr(a3) {
          a3 = a3 | 0;
          return 357913941;
        }
        function Wr(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 357913941)
                Ta();
              else {
                f4 = qC(b3 * 12 | 0) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 * 12 | 0) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 * 12 | 0);
          return;
        }
        function Xr(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (((f4 | 0) / -12 | 0) * 12 | 0) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function Yr(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~(((e4 + -12 - b3 | 0) >>> 0) / 12 | 0) * 12 | 0);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function Zr(a3) {
          a3 = a3 | 0;
          as(a3);
          return;
        }
        function _r(a3) {
          a3 = a3 | 0;
          $r(a3 + 24 | 0);
          return;
        }
        function $r(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~(((b3 + -12 - e4 | 0) >>> 0) / 12 | 0) * 12 | 0);
            sC(d4);
          }
          return;
        }
        function as(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 2, 9, b3, bs() | 0, 1);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function bs() {
          return 1372;
        }
        function cs(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = +d4;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          h3 = ds(a3) | 0;
          a3 = c2[h3 + 4 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[g3 + 4 >> 2] = a3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          es(b3, f4, d4);
          l3 = e4;
          return;
        }
        function ds(a3) {
          a3 = a3 | 0;
          return (c2[(Qr() | 0) + 24 >> 2] | 0) + (a3 * 12 | 0) | 0;
        }
        function es(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = +d4;
          var e4 = 0, f4 = 0, g3 = 0, h3 = ib;
          g3 = l3;
          l3 = l3 + 16 | 0;
          f4 = g3;
          e4 = c2[b3 >> 2] | 0;
          b3 = c2[b3 + 4 >> 2] | 0;
          a3 = a3 + (b3 >> 1) | 0;
          if (b3 & 1)
            e4 = c2[(c2[a3 >> 2] | 0) + e4 >> 2] | 0;
          fs(f4, d4);
          h3 = T2(gs(f4, d4));
          kb[e4 & 1](a3, h3);
          l3 = g3;
          return;
        }
        function fs(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          return;
        }
        function gs(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          return T2(hs(b3));
        }
        function hs(a3) {
          a3 = +a3;
          return T2(a3);
        }
        function is(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4 + 8 | 0;
          g3 = e4;
          i4 = c2[d4 >> 2] | 0;
          h3 = c2[d4 + 4 >> 2] | 0;
          d4 = ai(b3) | 0;
          c2[g3 >> 2] = i4;
          c2[g3 + 4 >> 2] = h3;
          c2[f4 >> 2] = c2[g3 >> 2];
          c2[f4 + 4 >> 2] = c2[g3 + 4 >> 2];
          js(a3, d4, f4, 0);
          l3 = e4;
          return;
        }
        function js(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4 + 16 | 0;
          m4 = f4 + 8 | 0;
          i4 = f4;
          k4 = c2[d4 >> 2] | 0;
          j4 = c2[d4 + 4 >> 2] | 0;
          h3 = c2[a3 >> 2] | 0;
          a3 = ks() | 0;
          c2[m4 >> 2] = k4;
          c2[m4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[m4 >> 2];
          c2[g3 + 4 >> 2] = c2[m4 + 4 >> 2];
          d4 = ls(g3) | 0;
          c2[i4 >> 2] = k4;
          c2[i4 + 4 >> 2] = j4;
          c2[g3 >> 2] = c2[i4 >> 2];
          c2[g3 + 4 >> 2] = c2[i4 + 4 >> 2];
          fi(h3, b3, a3, d4, ms(g3, e4) | 0, e4);
          l3 = f4;
          return;
        }
        function ks() {
          var b3 = 0, d4 = 0;
          if (!(a2[7856] | 0)) {
            ts(10172);
            Ha(50, 10172, o2 | 0) | 0;
            d4 = 7856;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(10172) | 0)) {
            b3 = 10172;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            ts(10172);
          }
          return 10172;
        }
        function ls(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function ms(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          m4 = l3;
          l3 = l3 + 32 | 0;
          f4 = m4 + 24 | 0;
          h3 = m4 + 16 | 0;
          i4 = m4;
          j4 = m4 + 8 | 0;
          g3 = c2[a3 >> 2] | 0;
          e4 = c2[a3 + 4 >> 2] | 0;
          c2[i4 >> 2] = g3;
          c2[i4 + 4 >> 2] = e4;
          n3 = ks() | 0;
          k4 = n3 + 24 | 0;
          a3 = ji(b3, 4) | 0;
          c2[j4 >> 2] = a3;
          b3 = n3 + 28 | 0;
          d4 = c2[b3 >> 2] | 0;
          if (d4 >>> 0 < (c2[n3 + 32 >> 2] | 0) >>> 0) {
            c2[h3 >> 2] = g3;
            c2[h3 + 4 >> 2] = e4;
            c2[f4 >> 2] = c2[h3 >> 2];
            c2[f4 + 4 >> 2] = c2[h3 + 4 >> 2];
            ns(d4, f4, a3);
            a3 = (c2[b3 >> 2] | 0) + 12 | 0;
            c2[b3 >> 2] = a3;
          } else {
            os(k4, i4, j4);
            a3 = c2[b3 >> 2] | 0;
          }
          l3 = m4;
          return ((a3 - (c2[k4 >> 2] | 0) | 0) / 12 | 0) + -1 | 0;
        }
        function ns(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          e4 = c2[b3 + 4 >> 2] | 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 8 >> 2] = d4;
          return;
        }
        function os(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0;
          k4 = l3;
          l3 = l3 + 48 | 0;
          e4 = k4 + 32 | 0;
          h3 = k4 + 24 | 0;
          i4 = k4;
          j4 = a3 + 4 | 0;
          f4 = (((c2[j4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0) / 12 | 0) + 1 | 0;
          g3 = ps(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            m4 = c2[a3 >> 2] | 0;
            o3 = ((c2[a3 + 8 >> 2] | 0) - m4 | 0) / 12 | 0;
            n3 = o3 << 1;
            qs(i4, o3 >>> 0 < g3 >>> 1 >>> 0 ? n3 >>> 0 < f4 >>> 0 ? f4 : n3 : g3, ((c2[j4 >> 2] | 0) - m4 | 0) / 12 | 0, a3 + 8 | 0);
            j4 = i4 + 8 | 0;
            g3 = c2[j4 >> 2] | 0;
            f4 = c2[b3 + 4 >> 2] | 0;
            d4 = c2[d4 >> 2] | 0;
            c2[h3 >> 2] = c2[b3 >> 2];
            c2[h3 + 4 >> 2] = f4;
            c2[e4 >> 2] = c2[h3 >> 2];
            c2[e4 + 4 >> 2] = c2[h3 + 4 >> 2];
            ns(g3, e4, d4);
            c2[j4 >> 2] = (c2[j4 >> 2] | 0) + 12;
            rs(a3, i4);
            ss(i4);
            l3 = k4;
            return;
          }
        }
        function ps(a3) {
          a3 = a3 | 0;
          return 357913941;
        }
        function qs(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 357913941)
                Ta();
              else {
                f4 = qC(b3 * 12 | 0) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 * 12 | 0) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 * 12 | 0);
          return;
        }
        function rs(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (((f4 | 0) / -12 | 0) * 12 | 0) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function ss(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~(((e4 + -12 - b3 | 0) >>> 0) / 12 | 0) * 12 | 0);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function ts(a3) {
          a3 = a3 | 0;
          ws(a3);
          return;
        }
        function us(a3) {
          a3 = a3 | 0;
          vs(a3 + 24 | 0);
          return;
        }
        function vs(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~(((b3 + -12 - e4 | 0) >>> 0) / 12 | 0) * 12 | 0);
            sC(d4);
          }
          return;
        }
        function ws(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 2, 3, b3, xs() | 0, 2);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function xs() {
          return 1380;
        }
        function ys(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          f4 = l3;
          l3 = l3 + 16 | 0;
          g3 = f4 + 8 | 0;
          h3 = f4;
          i4 = zs(a3) | 0;
          a3 = c2[i4 + 4 >> 2] | 0;
          c2[h3 >> 2] = c2[i4 >> 2];
          c2[h3 + 4 >> 2] = a3;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[g3 + 4 >> 2] = c2[h3 + 4 >> 2];
          As(b3, g3, d4, e4);
          l3 = f4;
          return;
        }
        function zs(a3) {
          a3 = a3 | 0;
          return (c2[(ks() | 0) + 24 >> 2] | 0) + (a3 * 12 | 0) | 0;
        }
        function As(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          i4 = l3;
          l3 = l3 + 16 | 0;
          g3 = i4 + 1 | 0;
          h3 = i4;
          f4 = c2[b3 >> 2] | 0;
          b3 = c2[b3 + 4 >> 2] | 0;
          a3 = a3 + (b3 >> 1) | 0;
          if (b3 & 1)
            f4 = c2[(c2[a3 >> 2] | 0) + f4 >> 2] | 0;
          tj(g3, d4);
          g3 = uj(g3, d4) | 0;
          Bs(h3, e4);
          h3 = Cs(h3, e4) | 0;
          Eb[f4 & 15](a3, g3, h3);
          l3 = i4;
          return;
        }
        function Bs(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return;
        }
        function Cs(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return Ds(b3) | 0;
        }
        function Ds(a3) {
          a3 = a3 | 0;
          return (a3 | 0) != 0 | 0;
        }
        function Es(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0;
          g3 = c2[a3 >> 2] | 0;
          f4 = Fs() | 0;
          a3 = Gs(d4) | 0;
          fi(g3, b3, f4, a3, Hs(d4, e4) | 0, e4);
          return;
        }
        function Fs() {
          var b3 = 0, d4 = 0;
          if (!(a2[7864] | 0)) {
            Os(10208);
            Ha(51, 10208, o2 | 0) | 0;
            d4 = 7864;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(10208) | 0)) {
            b3 = 10208;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            Os(10208);
          }
          return 10208;
        }
        function Gs(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function Hs(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          i4 = l3;
          l3 = l3 + 16 | 0;
          f4 = i4;
          g3 = i4 + 4 | 0;
          c2[f4 >> 2] = a3;
          j4 = Fs() | 0;
          h3 = j4 + 24 | 0;
          b3 = ji(b3, 4) | 0;
          c2[g3 >> 2] = b3;
          d4 = j4 + 28 | 0;
          e4 = c2[d4 >> 2] | 0;
          if (e4 >>> 0 < (c2[j4 + 32 >> 2] | 0) >>> 0) {
            Is(e4, a3, b3);
            b3 = (c2[d4 >> 2] | 0) + 8 | 0;
            c2[d4 >> 2] = b3;
          } else {
            Js(h3, f4, g3);
            b3 = c2[d4 >> 2] | 0;
          }
          l3 = i4;
          return (b3 - (c2[h3 >> 2] | 0) >> 3) + -1 | 0;
        }
        function Is(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          c2[a3 >> 2] = b3;
          c2[a3 + 4 >> 2] = d4;
          return;
        }
        function Js(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          i4 = l3;
          l3 = l3 + 32 | 0;
          f4 = i4;
          g3 = a3 + 4 | 0;
          h3 = ((c2[g3 >> 2] | 0) - (c2[a3 >> 2] | 0) >> 3) + 1 | 0;
          e4 = Ks(a3) | 0;
          if (e4 >>> 0 < h3 >>> 0)
            jC(a3);
          else {
            j4 = c2[a3 >> 2] | 0;
            m4 = (c2[a3 + 8 >> 2] | 0) - j4 | 0;
            k4 = m4 >> 2;
            Ls(f4, m4 >> 3 >>> 0 < e4 >>> 1 >>> 0 ? k4 >>> 0 < h3 >>> 0 ? h3 : k4 : e4, (c2[g3 >> 2] | 0) - j4 >> 3, a3 + 8 | 0);
            h3 = f4 + 8 | 0;
            Is(c2[h3 >> 2] | 0, c2[b3 >> 2] | 0, c2[d4 >> 2] | 0);
            c2[h3 >> 2] = (c2[h3 >> 2] | 0) + 8;
            Ms(a3, f4);
            Ns(f4);
            l3 = i4;
            return;
          }
        }
        function Ks(a3) {
          a3 = a3 | 0;
          return 536870911;
        }
        function Ls(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 536870911)
                Ta();
              else {
                f4 = qC(b3 << 3) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 << 3) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 << 3);
          return;
        }
        function Ms(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (0 - (f4 >> 3) << 3) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function Ns(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~((e4 + -8 - b3 | 0) >>> 3) << 3);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function Os(a3) {
          a3 = a3 | 0;
          Rs(a3);
          return;
        }
        function Ps(a3) {
          a3 = a3 | 0;
          Qs(a3 + 24 | 0);
          return;
        }
        function Qs(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~((b3 + -8 - e4 | 0) >>> 3) << 3);
            sC(d4);
          }
          return;
        }
        function Rs(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 1, 24, b3, Ss() | 0, 1);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function Ss() {
          return 1392;
        }
        function Ts(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          Vs(c2[(Us(a3) | 0) >> 2] | 0, b3);
          return;
        }
        function Us(a3) {
          a3 = a3 | 0;
          return (c2[(Fs() | 0) + 24 >> 2] | 0) + (a3 << 3) | 0;
        }
        function Vs(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var c3 = 0, d4 = 0;
          c3 = l3;
          l3 = l3 + 16 | 0;
          d4 = c3;
          Lq(d4, b3);
          b3 = Mq(d4, b3) | 0;
          nb[a3 & 127](b3);
          l3 = c3;
          return;
        }
        function Ws(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0;
          g3 = c2[a3 >> 2] | 0;
          f4 = Xs() | 0;
          a3 = Ys(d4) | 0;
          fi(g3, b3, f4, a3, Zs(d4, e4) | 0, e4);
          return;
        }
        function Xs() {
          var b3 = 0, d4 = 0;
          if (!(a2[7872] | 0)) {
            et2(10244);
            Ha(52, 10244, o2 | 0) | 0;
            d4 = 7872;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(10244) | 0)) {
            b3 = 10244;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            et2(10244);
          }
          return 10244;
        }
        function Ys(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function Zs(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          i4 = l3;
          l3 = l3 + 16 | 0;
          f4 = i4;
          g3 = i4 + 4 | 0;
          c2[f4 >> 2] = a3;
          j4 = Xs() | 0;
          h3 = j4 + 24 | 0;
          b3 = ji(b3, 4) | 0;
          c2[g3 >> 2] = b3;
          d4 = j4 + 28 | 0;
          e4 = c2[d4 >> 2] | 0;
          if (e4 >>> 0 < (c2[j4 + 32 >> 2] | 0) >>> 0) {
            _s(e4, a3, b3);
            b3 = (c2[d4 >> 2] | 0) + 8 | 0;
            c2[d4 >> 2] = b3;
          } else {
            $s(h3, f4, g3);
            b3 = c2[d4 >> 2] | 0;
          }
          l3 = i4;
          return (b3 - (c2[h3 >> 2] | 0) >> 3) + -1 | 0;
        }
        function _s(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          c2[a3 >> 2] = b3;
          c2[a3 + 4 >> 2] = d4;
          return;
        }
        function $s(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          i4 = l3;
          l3 = l3 + 32 | 0;
          f4 = i4;
          g3 = a3 + 4 | 0;
          h3 = ((c2[g3 >> 2] | 0) - (c2[a3 >> 2] | 0) >> 3) + 1 | 0;
          e4 = at(a3) | 0;
          if (e4 >>> 0 < h3 >>> 0)
            jC(a3);
          else {
            j4 = c2[a3 >> 2] | 0;
            m4 = (c2[a3 + 8 >> 2] | 0) - j4 | 0;
            k4 = m4 >> 2;
            bt(f4, m4 >> 3 >>> 0 < e4 >>> 1 >>> 0 ? k4 >>> 0 < h3 >>> 0 ? h3 : k4 : e4, (c2[g3 >> 2] | 0) - j4 >> 3, a3 + 8 | 0);
            h3 = f4 + 8 | 0;
            _s(c2[h3 >> 2] | 0, c2[b3 >> 2] | 0, c2[d4 >> 2] | 0);
            c2[h3 >> 2] = (c2[h3 >> 2] | 0) + 8;
            ct(a3, f4);
            dt(f4);
            l3 = i4;
            return;
          }
        }
        function at(a3) {
          a3 = a3 | 0;
          return 536870911;
        }
        function bt(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 536870911)
                Ta();
              else {
                f4 = qC(b3 << 3) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 << 3) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 << 3);
          return;
        }
        function ct(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (0 - (f4 >> 3) << 3) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function dt(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~((e4 + -8 - b3 | 0) >>> 3) << 3);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function et2(a3) {
          a3 = a3 | 0;
          ht(a3);
          return;
        }
        function ft(a3) {
          a3 = a3 | 0;
          gt(a3 + 24 | 0);
          return;
        }
        function gt(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~((b3 + -8 - e4 | 0) >>> 3) << 3);
            sC(d4);
          }
          return;
        }
        function ht(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 1, 16, b3, it() | 0, 0);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function it() {
          return 1400;
        }
        function jt(a3) {
          a3 = a3 | 0;
          return lt(c2[(kt(a3) | 0) >> 2] | 0) | 0;
        }
        function kt(a3) {
          a3 = a3 | 0;
          return (c2[(Xs() | 0) + 24 >> 2] | 0) + (a3 << 3) | 0;
        }
        function lt(a3) {
          a3 = a3 | 0;
          return mt(Ab[a3 & 7]() | 0) | 0;
        }
        function mt(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function nt() {
          var b3 = 0;
          if (!(a2[7880] | 0)) {
            ut(10280);
            Ha(25, 10280, o2 | 0) | 0;
            b3 = 7880;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          return 10280;
        }
        function ot(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c2[a3 >> 2] = pt() | 0;
          c2[a3 + 4 >> 2] = qt() | 0;
          c2[a3 + 12 >> 2] = b3;
          c2[a3 + 8 >> 2] = rt() | 0;
          c2[a3 + 32 >> 2] = 4;
          return;
        }
        function pt() {
          return 11711;
        }
        function qt() {
          return 1356;
        }
        function rt() {
          return lr() | 0;
        }
        function st(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          if ((jr(d4, 896) | 0) == 512) {
            if (c3 | 0) {
              tt(c3);
              sC(c3);
            }
          } else if (b3 | 0) {
            mf(b3);
            sC(b3);
          }
          return;
        }
        function tt(a3) {
          a3 = a3 | 0;
          a3 = c2[a3 + 4 >> 2] | 0;
          if (a3 | 0)
            oC(a3);
          return;
        }
        function ut(a3) {
          a3 = a3 | 0;
          Zi(a3);
          return;
        }
        function vt(a3) {
          a3 = a3 | 0;
          wt(a3, 4920);
          xt(a3) | 0;
          yt(a3) | 0;
          return;
        }
        function wt(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = nn() | 0;
          c2[a3 >> 2] = d4;
          Yt(d4, b3);
          Hv(c2[a3 >> 2] | 0);
          return;
        }
        function xt(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = c2[a3 >> 2] | 0;
          At(b3, Mt() | 0);
          return a3 | 0;
        }
        function yt(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = c2[a3 >> 2] | 0;
          At(b3, zt() | 0);
          return a3 | 0;
        }
        function zt() {
          var b3 = 0;
          if (!(a2[7888] | 0)) {
            Bt(10328);
            Ha(53, 10328, o2 | 0) | 0;
            b3 = 7888;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          if (!(si(10328) | 0))
            Bt(10328);
          return 10328;
        }
        function At(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          fi(a3, 0, b3, 0, 0, 0);
          return;
        }
        function Bt(a3) {
          a3 = a3 | 0;
          Et(a3);
          Gt(a3, 10);
          return;
        }
        function Ct(a3) {
          a3 = a3 | 0;
          Dt(a3 + 24 | 0);
          return;
        }
        function Dt(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~((b3 + -8 - e4 | 0) >>> 3) << 3);
            sC(d4);
          }
          return;
        }
        function Et(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 5, 1, b3, Jt() | 0, 2);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function Ft(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = +c3;
          Ht(a3, b3, c3);
          return;
        }
        function Gt(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c2[a3 + 20 >> 2] = b3;
          return;
        }
        function Ht(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = +d4;
          var e4 = 0, f4 = 0, g3 = 0, i4 = 0, j4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          g3 = e4 + 8 | 0;
          j4 = e4 + 13 | 0;
          f4 = e4;
          i4 = e4 + 12 | 0;
          tj(j4, b3);
          c2[g3 >> 2] = uj(j4, b3) | 0;
          rj(i4, d4);
          h2[f4 >> 3] = +sj(i4, d4);
          It(a3, g3, f4);
          l3 = e4;
          return;
        }
        function It(b3, d4, e4) {
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          mg(b3 + 8 | 0, c2[d4 >> 2] | 0, +h2[e4 >> 3]);
          a2[b3 + 24 >> 0] = 1;
          return;
        }
        function Jt() {
          return 1404;
        }
        function Kt(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          return Lt(a3, b3) | 0;
        }
        function Lt(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          g3 = e4 + 4 | 0;
          h3 = e4 + 8 | 0;
          i4 = e4;
          f4 = jy(8) | 0;
          d4 = f4;
          j4 = qC(16) | 0;
          tj(g3, a3);
          a3 = uj(g3, a3) | 0;
          rj(h3, b3);
          mg(j4, a3, +sj(h3, b3));
          h3 = d4 + 4 | 0;
          c2[h3 >> 2] = j4;
          a3 = qC(8) | 0;
          h3 = c2[h3 >> 2] | 0;
          c2[i4 >> 2] = 0;
          c2[g3 >> 2] = c2[i4 >> 2];
          qn(a3, h3, g3);
          c2[f4 >> 2] = a3;
          l3 = e4;
          return d4 | 0;
        }
        function Mt() {
          var b3 = 0;
          if (!(a2[7896] | 0)) {
            Nt(10364);
            Ha(54, 10364, o2 | 0) | 0;
            b3 = 7896;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          if (!(si(10364) | 0))
            Nt(10364);
          return 10364;
        }
        function Nt(a3) {
          a3 = a3 | 0;
          Qt(a3);
          Gt(a3, 55);
          return;
        }
        function Ot(a3) {
          a3 = a3 | 0;
          Pt(a3 + 24 | 0);
          return;
        }
        function Pt(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~((b3 + -8 - e4 | 0) >>> 3) << 3);
            sC(d4);
          }
          return;
        }
        function Qt(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 5, 4, b3, Vt() | 0, 0);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function Rt(a3) {
          a3 = a3 | 0;
          St(a3);
          return;
        }
        function St(a3) {
          a3 = a3 | 0;
          Tt(a3);
          return;
        }
        function Tt(b3) {
          b3 = b3 | 0;
          Ut(b3 + 8 | 0);
          a2[b3 + 24 >> 0] = 1;
          return;
        }
        function Ut(a3) {
          a3 = a3 | 0;
          c2[a3 >> 2] = 0;
          h2[a3 + 8 >> 3] = 0;
          return;
        }
        function Vt() {
          return 1424;
        }
        function Wt() {
          return Xt() | 0;
        }
        function Xt() {
          var a3 = 0, b3 = 0, d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          b3 = l3;
          l3 = l3 + 16 | 0;
          f4 = b3 + 4 | 0;
          h3 = b3;
          d4 = jy(8) | 0;
          a3 = d4;
          e4 = qC(16) | 0;
          Ut(e4);
          g3 = a3 + 4 | 0;
          c2[g3 >> 2] = e4;
          e4 = qC(8) | 0;
          g3 = c2[g3 >> 2] | 0;
          c2[h3 >> 2] = 0;
          c2[f4 >> 2] = c2[h3 >> 2];
          qn(e4, g3, f4);
          c2[d4 >> 2] = e4;
          l3 = b3;
          return a3 | 0;
        }
        function Yt(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c2[a3 >> 2] = Zt() | 0;
          c2[a3 + 4 >> 2] = _t() | 0;
          c2[a3 + 12 >> 2] = b3;
          c2[a3 + 8 >> 2] = $t() | 0;
          c2[a3 + 32 >> 2] = 5;
          return;
        }
        function Zt() {
          return 11710;
        }
        function _t() {
          return 1416;
        }
        function $t() {
          return cu() | 0;
        }
        function au(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          if ((jr(d4, 896) | 0) == 512) {
            if (c3 | 0) {
              bu(c3);
              sC(c3);
            }
          } else if (b3 | 0)
            sC(b3);
          return;
        }
        function bu(a3) {
          a3 = a3 | 0;
          a3 = c2[a3 + 4 >> 2] | 0;
          if (a3 | 0)
            oC(a3);
          return;
        }
        function cu() {
          var b3 = 0;
          if (!(a2[7904] | 0)) {
            c2[2600] = du() | 0;
            c2[2601] = 0;
            b3 = 7904;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          return 10400;
        }
        function du() {
          return c2[357] | 0;
        }
        function eu(a3) {
          a3 = a3 | 0;
          fu(a3, 4926);
          gu(a3) | 0;
          return;
        }
        function fu(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = Ci() | 0;
          c2[a3 >> 2] = d4;
          su(d4, b3);
          Hv(c2[a3 >> 2] | 0);
          return;
        }
        function gu(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = c2[a3 >> 2] | 0;
          At(b3, hu() | 0);
          return a3 | 0;
        }
        function hu() {
          var b3 = 0;
          if (!(a2[7912] | 0)) {
            iu(10412);
            Ha(56, 10412, o2 | 0) | 0;
            b3 = 7912;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          if (!(si(10412) | 0))
            iu(10412);
          return 10412;
        }
        function iu(a3) {
          a3 = a3 | 0;
          lu(a3);
          Gt(a3, 57);
          return;
        }
        function ju(a3) {
          a3 = a3 | 0;
          ku(a3 + 24 | 0);
          return;
        }
        function ku(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~((b3 + -8 - e4 | 0) >>> 3) << 3);
            sC(d4);
          }
          return;
        }
        function lu(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 5, 5, b3, pu() | 0, 0);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function mu(a3) {
          a3 = a3 | 0;
          nu(a3);
          return;
        }
        function nu(a3) {
          a3 = a3 | 0;
          ou(a3);
          return;
        }
        function ou(b3) {
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          d4 = b3 + 8 | 0;
          e4 = d4 + 48 | 0;
          do {
            c2[d4 >> 2] = 0;
            d4 = d4 + 4 | 0;
          } while ((d4 | 0) < (e4 | 0));
          a2[b3 + 56 >> 0] = 1;
          return;
        }
        function pu() {
          return 1432;
        }
        function qu() {
          return ru() | 0;
        }
        function ru() {
          var a3 = 0, b3 = 0, d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          h3 = l3;
          l3 = l3 + 16 | 0;
          a3 = h3 + 4 | 0;
          b3 = h3;
          d4 = jy(8) | 0;
          e4 = d4;
          f4 = qC(48) | 0;
          g3 = f4;
          i4 = g3 + 48 | 0;
          do {
            c2[g3 >> 2] = 0;
            g3 = g3 + 4 | 0;
          } while ((g3 | 0) < (i4 | 0));
          g3 = e4 + 4 | 0;
          c2[g3 >> 2] = f4;
          i4 = qC(8) | 0;
          g3 = c2[g3 >> 2] | 0;
          c2[b3 >> 2] = 0;
          c2[a3 >> 2] = c2[b3 >> 2];
          Ji(i4, g3, a3);
          c2[d4 >> 2] = i4;
          l3 = h3;
          return e4 | 0;
        }
        function su(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c2[a3 >> 2] = tu() | 0;
          c2[a3 + 4 >> 2] = uu() | 0;
          c2[a3 + 12 >> 2] = b3;
          c2[a3 + 8 >> 2] = vu() | 0;
          c2[a3 + 32 >> 2] = 6;
          return;
        }
        function tu() {
          return 11704;
        }
        function uu() {
          return 1436;
        }
        function vu() {
          return cu() | 0;
        }
        function wu(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          if ((jr(d4, 896) | 0) == 512) {
            if (c3 | 0) {
              xu(c3);
              sC(c3);
            }
          } else if (b3 | 0)
            sC(b3);
          return;
        }
        function xu(a3) {
          a3 = a3 | 0;
          a3 = c2[a3 + 4 >> 2] | 0;
          if (a3 | 0)
            oC(a3);
          return;
        }
        function yu(a3) {
          a3 = a3 | 0;
          zu(a3, 4933);
          Au(a3) | 0;
          Bu(a3) | 0;
          return;
        }
        function zu(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = cv() | 0;
          c2[a3 >> 2] = d4;
          dv(d4, b3);
          Hv(c2[a3 >> 2] | 0);
          return;
        }
        function Au(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = c2[a3 >> 2] | 0;
          At(b3, Su() | 0);
          return a3 | 0;
        }
        function Bu(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = c2[a3 >> 2] | 0;
          At(b3, Cu() | 0);
          return a3 | 0;
        }
        function Cu() {
          var b3 = 0;
          if (!(a2[7920] | 0)) {
            Du(10452);
            Ha(58, 10452, o2 | 0) | 0;
            b3 = 7920;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          if (!(si(10452) | 0))
            Du(10452);
          return 10452;
        }
        function Du(a3) {
          a3 = a3 | 0;
          Gu(a3);
          Gt(a3, 1);
          return;
        }
        function Eu(a3) {
          a3 = a3 | 0;
          Fu(a3 + 24 | 0);
          return;
        }
        function Fu(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~((b3 + -8 - e4 | 0) >>> 3) << 3);
            sC(d4);
          }
          return;
        }
        function Gu(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 5, 1, b3, Lu() | 0, 2);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function Hu(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = +b3;
          c3 = +c3;
          Iu(a3, b3, c3);
          return;
        }
        function Iu(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = +b3;
          c3 = +c3;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, i4 = 0;
          d4 = l3;
          l3 = l3 + 32 | 0;
          f4 = d4 + 8 | 0;
          i4 = d4 + 17 | 0;
          e4 = d4;
          g3 = d4 + 16 | 0;
          rj(i4, b3);
          h2[f4 >> 3] = +sj(i4, b3);
          rj(g3, c3);
          h2[e4 >> 3] = +sj(g3, c3);
          Ju(a3, f4, e4);
          l3 = d4;
          return;
        }
        function Ju(b3, c3, d4) {
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          Ku(b3 + 8 | 0, +h2[c3 >> 3], +h2[d4 >> 3]);
          a2[b3 + 24 >> 0] = 1;
          return;
        }
        function Ku(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = +b3;
          c3 = +c3;
          h2[a3 >> 3] = b3;
          h2[a3 + 8 >> 3] = c3;
          return;
        }
        function Lu() {
          return 1472;
        }
        function Mu(a3, b3) {
          a3 = +a3;
          b3 = +b3;
          return Nu(a3, b3) | 0;
        }
        function Nu(a3, b3) {
          a3 = +a3;
          b3 = +b3;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          h3 = e4 + 4 | 0;
          i4 = e4 + 8 | 0;
          j4 = e4;
          f4 = jy(8) | 0;
          d4 = f4;
          g3 = qC(16) | 0;
          rj(h3, a3);
          a3 = +sj(h3, a3);
          rj(i4, b3);
          Ku(g3, a3, +sj(i4, b3));
          i4 = d4 + 4 | 0;
          c2[i4 >> 2] = g3;
          g3 = qC(8) | 0;
          i4 = c2[i4 >> 2] | 0;
          c2[j4 >> 2] = 0;
          c2[h3 >> 2] = c2[j4 >> 2];
          Ou(g3, i4, h3);
          c2[f4 >> 2] = g3;
          l3 = e4;
          return d4 | 0;
        }
        function Ou(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          c2[a3 >> 2] = b3;
          d4 = qC(16) | 0;
          c2[d4 + 4 >> 2] = 0;
          c2[d4 + 8 >> 2] = 0;
          c2[d4 >> 2] = 1452;
          c2[d4 + 12 >> 2] = b3;
          c2[a3 + 4 >> 2] = d4;
          return;
        }
        function Pu(a3) {
          a3 = a3 | 0;
          kC(a3);
          sC(a3);
          return;
        }
        function Qu(a3) {
          a3 = a3 | 0;
          a3 = c2[a3 + 12 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function Ru(a3) {
          a3 = a3 | 0;
          sC(a3);
          return;
        }
        function Su() {
          var b3 = 0;
          if (!(a2[7928] | 0)) {
            Tu(10488);
            Ha(59, 10488, o2 | 0) | 0;
            b3 = 7928;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          if (!(si(10488) | 0))
            Tu(10488);
          return 10488;
        }
        function Tu(a3) {
          a3 = a3 | 0;
          Wu(a3);
          Gt(a3, 60);
          return;
        }
        function Uu(a3) {
          a3 = a3 | 0;
          Vu(a3 + 24 | 0);
          return;
        }
        function Vu(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~((b3 + -8 - e4 | 0) >>> 3) << 3);
            sC(d4);
          }
          return;
        }
        function Wu(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 5, 6, b3, $u() | 0, 0);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function Xu(a3) {
          a3 = a3 | 0;
          Yu(a3);
          return;
        }
        function Yu(a3) {
          a3 = a3 | 0;
          Zu(a3);
          return;
        }
        function Zu(b3) {
          b3 = b3 | 0;
          _u(b3 + 8 | 0);
          a2[b3 + 24 >> 0] = 1;
          return;
        }
        function _u(a3) {
          a3 = a3 | 0;
          c2[a3 >> 2] = 0;
          c2[a3 + 4 >> 2] = 0;
          c2[a3 + 8 >> 2] = 0;
          c2[a3 + 12 >> 2] = 0;
          return;
        }
        function $u() {
          return 1492;
        }
        function av() {
          return bv() | 0;
        }
        function bv() {
          var a3 = 0, b3 = 0, d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          b3 = l3;
          l3 = l3 + 16 | 0;
          f4 = b3 + 4 | 0;
          h3 = b3;
          d4 = jy(8) | 0;
          a3 = d4;
          e4 = qC(16) | 0;
          _u(e4);
          g3 = a3 + 4 | 0;
          c2[g3 >> 2] = e4;
          e4 = qC(8) | 0;
          g3 = c2[g3 >> 2] | 0;
          c2[h3 >> 2] = 0;
          c2[f4 >> 2] = c2[h3 >> 2];
          Ou(e4, g3, f4);
          c2[d4 >> 2] = e4;
          l3 = b3;
          return a3 | 0;
        }
        function cv() {
          var b3 = 0;
          if (!(a2[7936] | 0)) {
            jv(10524);
            Ha(25, 10524, o2 | 0) | 0;
            b3 = 7936;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          return 10524;
        }
        function dv(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c2[a3 >> 2] = ev() | 0;
          c2[a3 + 4 >> 2] = fv() | 0;
          c2[a3 + 12 >> 2] = b3;
          c2[a3 + 8 >> 2] = gv() | 0;
          c2[a3 + 32 >> 2] = 7;
          return;
        }
        function ev() {
          return 11700;
        }
        function fv() {
          return 1484;
        }
        function gv() {
          return cu() | 0;
        }
        function hv(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          if ((jr(d4, 896) | 0) == 512) {
            if (c3 | 0) {
              iv(c3);
              sC(c3);
            }
          } else if (b3 | 0)
            sC(b3);
          return;
        }
        function iv(a3) {
          a3 = a3 | 0;
          a3 = c2[a3 + 4 >> 2] | 0;
          if (a3 | 0)
            oC(a3);
          return;
        }
        function jv(a3) {
          a3 = a3 | 0;
          Zi(a3);
          return;
        }
        function kv(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          a3 = ai(b3) | 0;
          b3 = lv(c3) | 0;
          c3 = mv(c3, 0) | 0;
          Zv(a3, b3, c3, nv() | 0, 0);
          return;
        }
        function lv(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function mv(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          i4 = l3;
          l3 = l3 + 16 | 0;
          f4 = i4;
          g3 = i4 + 4 | 0;
          c2[f4 >> 2] = a3;
          j4 = nv() | 0;
          h3 = j4 + 24 | 0;
          b3 = ji(b3, 4) | 0;
          c2[g3 >> 2] = b3;
          d4 = j4 + 28 | 0;
          e4 = c2[d4 >> 2] | 0;
          if (e4 >>> 0 < (c2[j4 + 32 >> 2] | 0) >>> 0) {
            vv(e4, a3, b3);
            b3 = (c2[d4 >> 2] | 0) + 8 | 0;
            c2[d4 >> 2] = b3;
          } else {
            wv(h3, f4, g3);
            b3 = c2[d4 >> 2] | 0;
          }
          l3 = i4;
          return (b3 - (c2[h3 >> 2] | 0) >> 3) + -1 | 0;
        }
        function nv() {
          var b3 = 0, d4 = 0;
          if (!(a2[7944] | 0)) {
            ov(10568);
            Ha(61, 10568, o2 | 0) | 0;
            d4 = 7944;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(10568) | 0)) {
            b3 = 10568;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            ov(10568);
          }
          return 10568;
        }
        function ov(a3) {
          a3 = a3 | 0;
          rv(a3);
          return;
        }
        function pv(a3) {
          a3 = a3 | 0;
          qv(a3 + 24 | 0);
          return;
        }
        function qv(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~((b3 + -8 - e4 | 0) >>> 3) << 3);
            sC(d4);
          }
          return;
        }
        function rv(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 1, 17, b3, ql() | 0, 0);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function sv(a3) {
          a3 = a3 | 0;
          return uv(c2[(tv(a3) | 0) >> 2] | 0) | 0;
        }
        function tv(a3) {
          a3 = a3 | 0;
          return (c2[(nv() | 0) + 24 >> 2] | 0) + (a3 << 3) | 0;
        }
        function uv(a3) {
          a3 = a3 | 0;
          return ul(Ab[a3 & 7]() | 0) | 0;
        }
        function vv(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          c2[a3 >> 2] = b3;
          c2[a3 + 4 >> 2] = d4;
          return;
        }
        function wv(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          i4 = l3;
          l3 = l3 + 32 | 0;
          f4 = i4;
          g3 = a3 + 4 | 0;
          h3 = ((c2[g3 >> 2] | 0) - (c2[a3 >> 2] | 0) >> 3) + 1 | 0;
          e4 = xv(a3) | 0;
          if (e4 >>> 0 < h3 >>> 0)
            jC(a3);
          else {
            j4 = c2[a3 >> 2] | 0;
            m4 = (c2[a3 + 8 >> 2] | 0) - j4 | 0;
            k4 = m4 >> 2;
            yv(f4, m4 >> 3 >>> 0 < e4 >>> 1 >>> 0 ? k4 >>> 0 < h3 >>> 0 ? h3 : k4 : e4, (c2[g3 >> 2] | 0) - j4 >> 3, a3 + 8 | 0);
            h3 = f4 + 8 | 0;
            vv(c2[h3 >> 2] | 0, c2[b3 >> 2] | 0, c2[d4 >> 2] | 0);
            c2[h3 >> 2] = (c2[h3 >> 2] | 0) + 8;
            zv(a3, f4);
            Av(f4);
            l3 = i4;
            return;
          }
        }
        function xv(a3) {
          a3 = a3 | 0;
          return 536870911;
        }
        function yv(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 536870911)
                Ta();
              else {
                f4 = qC(b3 << 3) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 << 3) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 << 3);
          return;
        }
        function zv(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (0 - (f4 >> 3) << 3) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function Av(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~((e4 + -8 - b3 | 0) >>> 3) << 3);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function Bv() {
          Cv();
          return;
        }
        function Cv() {
          Dv(10604);
          return;
        }
        function Dv(a3) {
          a3 = a3 | 0;
          Ev(a3, 4955);
          return;
        }
        function Ev(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = Fv() | 0;
          c2[a3 >> 2] = d4;
          Gv(d4, b3);
          Hv(c2[a3 >> 2] | 0);
          return;
        }
        function Fv() {
          var b3 = 0;
          if (!(a2[7952] | 0)) {
            Rv(10612);
            Ha(25, 10612, o2 | 0) | 0;
            b3 = 7952;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          return 10612;
        }
        function Gv(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c2[a3 >> 2] = Mv() | 0;
          c2[a3 + 4 >> 2] = Nv() | 0;
          c2[a3 + 12 >> 2] = b3;
          c2[a3 + 8 >> 2] = Ov() | 0;
          c2[a3 + 32 >> 2] = 8;
          return;
        }
        function Hv(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0;
          b3 = l3;
          l3 = l3 + 16 | 0;
          d4 = b3;
          Iv() | 0;
          c2[d4 >> 2] = a3;
          Jv(10608, d4);
          l3 = b3;
          return;
        }
        function Iv() {
          if (!(a2[11714] | 0)) {
            c2[2652] = 0;
            Ha(62, 10608, o2 | 0) | 0;
            a2[11714] = 1;
          }
          return 10608;
        }
        function Jv(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = qC(8) | 0;
          c2[d4 + 4 >> 2] = c2[b3 >> 2];
          c2[d4 >> 2] = c2[a3 >> 2];
          c2[a3 >> 2] = d4;
          return;
        }
        function Kv(a3) {
          a3 = a3 | 0;
          Lv(a3);
          return;
        }
        function Lv(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0;
          b3 = c2[a3 >> 2] | 0;
          if (b3 | 0)
            do {
              d4 = b3;
              b3 = c2[b3 >> 2] | 0;
              sC(d4);
            } while ((b3 | 0) != 0);
          c2[a3 >> 2] = 0;
          return;
        }
        function Mv() {
          return 11715;
        }
        function Nv() {
          return 1496;
        }
        function Ov() {
          return lr() | 0;
        }
        function Pv(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          if ((jr(d4, 896) | 0) == 512) {
            if (c3 | 0) {
              Qv(c3);
              sC(c3);
            }
          } else if (b3 | 0)
            sC(b3);
          return;
        }
        function Qv(a3) {
          a3 = a3 | 0;
          a3 = c2[a3 + 4 >> 2] | 0;
          if (a3 | 0)
            oC(a3);
          return;
        }
        function Rv(a3) {
          a3 = a3 | 0;
          Zi(a3);
          return;
        }
        function Sv(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          Iv() | 0;
          d4 = c2[2652] | 0;
          a:
            do
              if (d4 | 0) {
                while (1) {
                  e4 = c2[d4 + 4 >> 2] | 0;
                  if (e4 | 0 ? (AB(Tv(e4) | 0, a3) | 0) == 0 : 0)
                    break;
                  d4 = c2[d4 >> 2] | 0;
                  if (!d4)
                    break a;
                }
                Uv(e4, b3);
              }
            while (0);
          return;
        }
        function Tv(a3) {
          a3 = a3 | 0;
          return c2[a3 + 12 >> 2] | 0;
        }
        function Uv(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          a3 = a3 + 36 | 0;
          d4 = c2[a3 >> 2] | 0;
          if (d4 | 0) {
            vf(d4);
            sC(d4);
          }
          d4 = qC(4) | 0;
          Og(d4, b3);
          c2[a3 >> 2] = d4;
          return;
        }
        function Vv() {
          if (!(a2[11716] | 0)) {
            c2[2664] = 0;
            Ha(63, 10656, o2 | 0) | 0;
            a2[11716] = 1;
          }
          return 10656;
        }
        function Wv() {
          var b3 = 0;
          if (!(a2[11717] | 0)) {
            Xv();
            c2[2665] = 1504;
            a2[11717] = 1;
            b3 = 1504;
          } else
            b3 = c2[2665] | 0;
          return b3 | 0;
        }
        function Xv() {
          if (!(a2[11740] | 0)) {
            a2[11718] = ji(ji(8, 0) | 0, 0) | 0;
            a2[11719] = ji(ji(0, 0) | 0, 0) | 0;
            a2[11720] = ji(ji(0, 16) | 0, 0) | 0;
            a2[11721] = ji(ji(8, 0) | 0, 0) | 0;
            a2[11722] = ji(ji(0, 0) | 0, 0) | 0;
            a2[11723] = ji(ji(8, 0) | 0, 0) | 0;
            a2[11724] = ji(ji(0, 0) | 0, 0) | 0;
            a2[11725] = ji(ji(8, 0) | 0, 0) | 0;
            a2[11726] = ji(ji(0, 0) | 0, 0) | 0;
            a2[11727] = ji(ji(8, 0) | 0, 0) | 0;
            a2[11728] = ji(ji(0, 0) | 0, 0) | 0;
            a2[11729] = ji(ji(0, 0) | 0, 32) | 0;
            a2[11730] = ji(ji(0, 0) | 0, 32) | 0;
            a2[11740] = 1;
          }
          return;
        }
        function Yv() {
          return 1572;
        }
        function Zv(a3, b3, d4, e4, f4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          var g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          g3 = l3;
          l3 = l3 + 32 | 0;
          m4 = g3 + 16 | 0;
          k4 = g3 + 12 | 0;
          j4 = g3 + 8 | 0;
          i4 = g3 + 4 | 0;
          h3 = g3;
          c2[m4 >> 2] = a3;
          c2[k4 >> 2] = b3;
          c2[j4 >> 2] = d4;
          c2[i4 >> 2] = e4;
          c2[h3 >> 2] = f4;
          Vv() | 0;
          _v(10656, m4, k4, j4, i4, h3);
          l3 = g3;
          return;
        }
        function _v(a3, b3, d4, e4, f4, g3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          g3 = g3 | 0;
          var h3 = 0;
          h3 = qC(24) | 0;
          ii(h3 + 4 | 0, c2[b3 >> 2] | 0, c2[d4 >> 2] | 0, c2[e4 >> 2] | 0, c2[f4 >> 2] | 0, c2[g3 >> 2] | 0);
          c2[h3 >> 2] = c2[a3 >> 2];
          c2[a3 >> 2] = h3;
          return;
        }
        function $v(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0, p4 = 0, q3 = 0, r3 = 0, s3 = 0, t3 = 0, u4 = 0;
          u4 = l3;
          l3 = l3 + 32 | 0;
          q3 = u4 + 20 | 0;
          r3 = u4 + 8 | 0;
          s3 = u4 + 4 | 0;
          t3 = u4;
          b3 = c2[b3 >> 2] | 0;
          if (b3 | 0) {
            p4 = q3 + 4 | 0;
            j4 = q3 + 8 | 0;
            k4 = r3 + 4 | 0;
            m4 = r3 + 8 | 0;
            n3 = r3 + 8 | 0;
            o3 = q3 + 8 | 0;
            do {
              h3 = b3 + 4 | 0;
              i4 = aw(h3) | 0;
              if (i4 | 0) {
                f4 = bw(i4) | 0;
                c2[q3 >> 2] = 0;
                c2[p4 >> 2] = 0;
                c2[j4 >> 2] = 0;
                e4 = (cw(i4) | 0) + 1 | 0;
                dw(q3, e4);
                if (e4 | 0)
                  while (1) {
                    e4 = e4 + -1 | 0;
                    OA(r3, c2[f4 >> 2] | 0);
                    g3 = c2[p4 >> 2] | 0;
                    if (g3 >>> 0 < (c2[o3 >> 2] | 0) >>> 0) {
                      c2[g3 >> 2] = c2[r3 >> 2];
                      c2[p4 >> 2] = (c2[p4 >> 2] | 0) + 4;
                    } else
                      ew(q3, r3);
                    if (!e4)
                      break;
                    else
                      f4 = f4 + 4 | 0;
                  }
                e4 = fw(i4) | 0;
                c2[r3 >> 2] = 0;
                c2[k4 >> 2] = 0;
                c2[m4 >> 2] = 0;
                a:
                  do
                    if (c2[e4 >> 2] | 0) {
                      f4 = 0;
                      g3 = 0;
                      while (1) {
                        if ((f4 | 0) == (g3 | 0))
                          gw(r3, e4);
                        else {
                          c2[f4 >> 2] = c2[e4 >> 2];
                          c2[k4 >> 2] = (c2[k4 >> 2] | 0) + 4;
                        }
                        e4 = e4 + 4 | 0;
                        if (!(c2[e4 >> 2] | 0))
                          break a;
                        f4 = c2[k4 >> 2] | 0;
                        g3 = c2[n3 >> 2] | 0;
                      }
                    }
                  while (0);
                c2[s3 >> 2] = hw(h3) | 0;
                c2[t3 >> 2] = si(i4) | 0;
                iw(d4, a3, s3, t3, q3, r3);
                jw(r3);
                kw(q3);
              }
              b3 = c2[b3 >> 2] | 0;
            } while ((b3 | 0) != 0);
          }
          l3 = u4;
          return;
        }
        function aw(a3) {
          a3 = a3 | 0;
          return c2[a3 + 12 >> 2] | 0;
        }
        function bw(a3) {
          a3 = a3 | 0;
          return c2[a3 + 12 >> 2] | 0;
        }
        function cw(a3) {
          a3 = a3 | 0;
          return c2[a3 + 16 >> 2] | 0;
        }
        function dw(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          d4 = f4;
          e4 = c2[a3 >> 2] | 0;
          if ((c2[a3 + 8 >> 2] | 0) - e4 >> 2 >>> 0 < b3 >>> 0) {
            Rw(d4, b3, (c2[a3 + 4 >> 2] | 0) - e4 >> 2, a3 + 8 | 0);
            Sw(a3, d4);
            Tw(d4);
          }
          l3 = f4;
          return;
        }
        function ew(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0;
          h3 = l3;
          l3 = l3 + 32 | 0;
          d4 = h3;
          e4 = a3 + 4 | 0;
          f4 = ((c2[e4 >> 2] | 0) - (c2[a3 >> 2] | 0) >> 2) + 1 | 0;
          g3 = Nw(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            i4 = c2[a3 >> 2] | 0;
            k4 = (c2[a3 + 8 >> 2] | 0) - i4 | 0;
            j4 = k4 >> 1;
            Rw(d4, k4 >> 2 >>> 0 < g3 >>> 1 >>> 0 ? j4 >>> 0 < f4 >>> 0 ? f4 : j4 : g3, (c2[e4 >> 2] | 0) - i4 >> 2, a3 + 8 | 0);
            g3 = d4 + 8 | 0;
            c2[c2[g3 >> 2] >> 2] = c2[b3 >> 2];
            c2[g3 >> 2] = (c2[g3 >> 2] | 0) + 4;
            Sw(a3, d4);
            Tw(d4);
            l3 = h3;
            return;
          }
        }
        function fw(a3) {
          a3 = a3 | 0;
          return c2[a3 + 8 >> 2] | 0;
        }
        function gw(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0;
          h3 = l3;
          l3 = l3 + 32 | 0;
          d4 = h3;
          e4 = a3 + 4 | 0;
          f4 = ((c2[e4 >> 2] | 0) - (c2[a3 >> 2] | 0) >> 2) + 1 | 0;
          g3 = Kw(a3) | 0;
          if (g3 >>> 0 < f4 >>> 0)
            jC(a3);
          else {
            i4 = c2[a3 >> 2] | 0;
            k4 = (c2[a3 + 8 >> 2] | 0) - i4 | 0;
            j4 = k4 >> 1;
            Ow(d4, k4 >> 2 >>> 0 < g3 >>> 1 >>> 0 ? j4 >>> 0 < f4 >>> 0 ? f4 : j4 : g3, (c2[e4 >> 2] | 0) - i4 >> 2, a3 + 8 | 0);
            g3 = d4 + 8 | 0;
            c2[c2[g3 >> 2] >> 2] = c2[b3 >> 2];
            c2[g3 >> 2] = (c2[g3 >> 2] | 0) + 4;
            Pw(a3, d4);
            Qw(d4);
            l3 = h3;
            return;
          }
        }
        function hw(a3) {
          a3 = a3 | 0;
          return c2[a3 >> 2] | 0;
        }
        function iw(a3, b3, c3, d4, e4, f4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          lw(a3, b3, c3, d4, e4, f4);
          return;
        }
        function jw(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~((b3 + -4 - e4 | 0) >>> 2) << 2);
            sC(d4);
          }
          return;
        }
        function kw(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~((b3 + -4 - e4 | 0) >>> 2) << 2);
            sC(d4);
          }
          return;
        }
        function lw(a3, b3, d4, e4, f4, g3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          g3 = g3 | 0;
          var h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          h3 = l3;
          l3 = l3 + 48 | 0;
          m4 = h3 + 40 | 0;
          i4 = h3 + 32 | 0;
          n3 = h3 + 24 | 0;
          j4 = h3 + 12 | 0;
          k4 = h3;
          UA(i4);
          a3 = Sg(a3) | 0;
          c2[n3 >> 2] = c2[b3 >> 2];
          d4 = c2[d4 >> 2] | 0;
          e4 = c2[e4 >> 2] | 0;
          mw(j4, f4);
          nw(k4, g3);
          c2[m4 >> 2] = c2[n3 >> 2];
          ow(a3, m4, d4, e4, j4, k4);
          jw(k4);
          kw(j4);
          WA(i4);
          l3 = h3;
          return;
        }
        function mw(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          c2[a3 >> 2] = 0;
          c2[a3 + 4 >> 2] = 0;
          c2[a3 + 8 >> 2] = 0;
          d4 = b3 + 4 | 0;
          e4 = (c2[d4 >> 2] | 0) - (c2[b3 >> 2] | 0) >> 2;
          if (e4 | 0) {
            Lw(a3, e4);
            Mw(a3, c2[b3 >> 2] | 0, c2[d4 >> 2] | 0, e4);
          }
          return;
        }
        function nw(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          c2[a3 >> 2] = 0;
          c2[a3 + 4 >> 2] = 0;
          c2[a3 + 8 >> 2] = 0;
          d4 = b3 + 4 | 0;
          e4 = (c2[d4 >> 2] | 0) - (c2[b3 >> 2] | 0) >> 2;
          if (e4 | 0) {
            Iw(a3, e4);
            Jw(a3, c2[b3 >> 2] | 0, c2[d4 >> 2] | 0, e4);
          }
          return;
        }
        function ow(a3, b3, d4, e4, f4, g3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          g3 = g3 | 0;
          var h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0;
          h3 = l3;
          l3 = l3 + 32 | 0;
          m4 = h3 + 28 | 0;
          n3 = h3 + 24 | 0;
          i4 = h3 + 12 | 0;
          j4 = h3;
          k4 = Vg(pw() | 0) | 0;
          c2[n3 >> 2] = c2[b3 >> 2];
          c2[m4 >> 2] = c2[n3 >> 2];
          b3 = qw(m4) | 0;
          d4 = rw(d4) | 0;
          e4 = sw(e4) | 0;
          c2[i4 >> 2] = c2[f4 >> 2];
          m4 = f4 + 4 | 0;
          c2[i4 + 4 >> 2] = c2[m4 >> 2];
          n3 = f4 + 8 | 0;
          c2[i4 + 8 >> 2] = c2[n3 >> 2];
          c2[n3 >> 2] = 0;
          c2[m4 >> 2] = 0;
          c2[f4 >> 2] = 0;
          f4 = tw(i4) | 0;
          c2[j4 >> 2] = c2[g3 >> 2];
          m4 = g3 + 4 | 0;
          c2[j4 + 4 >> 2] = c2[m4 >> 2];
          n3 = g3 + 8 | 0;
          c2[j4 + 8 >> 2] = c2[n3 >> 2];
          c2[n3 >> 2] = 0;
          c2[m4 >> 2] = 0;
          c2[g3 >> 2] = 0;
          Ba(0, k4 | 0, a3 | 0, b3 | 0, d4 | 0, e4 | 0, f4 | 0, uw(j4) | 0) | 0;
          jw(j4);
          kw(i4);
          l3 = h3;
          return;
        }
        function pw() {
          var b3 = 0;
          if (!(a2[7968] | 0)) {
            Gw(10708);
            b3 = 7968;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          return 10708;
        }
        function qw(a3) {
          a3 = a3 | 0;
          return yw(a3) | 0;
        }
        function rw(a3) {
          a3 = a3 | 0;
          return ww(a3) | 0;
        }
        function sw(a3) {
          a3 = a3 | 0;
          return ul(a3) | 0;
        }
        function tw(a3) {
          a3 = a3 | 0;
          return xw(a3) | 0;
        }
        function uw(a3) {
          a3 = a3 | 0;
          return vw(a3) | 0;
        }
        function vw(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          e4 = (c2[a3 + 4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0;
          d4 = e4 >> 2;
          e4 = jy(e4 + 4 | 0) | 0;
          c2[e4 >> 2] = d4;
          if (d4 | 0) {
            b3 = 0;
            do {
              c2[e4 + 4 + (b3 << 2) >> 2] = ww(c2[(c2[a3 >> 2] | 0) + (b3 << 2) >> 2] | 0) | 0;
              b3 = b3 + 1 | 0;
            } while ((b3 | 0) != (d4 | 0));
          }
          return e4 | 0;
        }
        function ww(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function xw(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          e4 = (c2[a3 + 4 >> 2] | 0) - (c2[a3 >> 2] | 0) | 0;
          d4 = e4 >> 2;
          e4 = jy(e4 + 4 | 0) | 0;
          c2[e4 >> 2] = d4;
          if (d4 | 0) {
            b3 = 0;
            do {
              c2[e4 + 4 + (b3 << 2) >> 2] = yw((c2[a3 >> 2] | 0) + (b3 << 2) | 0) | 0;
              b3 = b3 + 1 | 0;
            } while ((b3 | 0) != (d4 | 0));
          }
          return e4 | 0;
        }
        function yw(a3) {
          a3 = a3 | 0;
          var b3 = 0, c3 = 0, d4 = 0, e4 = 0;
          e4 = l3;
          l3 = l3 + 32 | 0;
          b3 = e4 + 12 | 0;
          c3 = e4;
          d4 = Di(zw() | 0) | 0;
          if (!d4)
            a3 = Aw(a3) | 0;
          else {
            Ei(b3, d4);
            Fi(c3, b3);
            RA(a3, c3);
            a3 = Hi(b3) | 0;
          }
          l3 = e4;
          return a3 | 0;
        }
        function zw() {
          var b3 = 0;
          if (!(a2[7960] | 0)) {
            Fw(10664);
            Ha(25, 10664, o2 | 0) | 0;
            b3 = 7960;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          return 10664;
        }
        function Aw(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          d4 = l3;
          l3 = l3 + 16 | 0;
          f4 = d4 + 4 | 0;
          h3 = d4;
          e4 = jy(8) | 0;
          b3 = e4;
          i4 = qC(4) | 0;
          c2[i4 >> 2] = c2[a3 >> 2];
          g3 = b3 + 4 | 0;
          c2[g3 >> 2] = i4;
          a3 = qC(8) | 0;
          g3 = c2[g3 >> 2] | 0;
          c2[h3 >> 2] = 0;
          c2[f4 >> 2] = c2[h3 >> 2];
          Bw(a3, g3, f4);
          c2[e4 >> 2] = a3;
          l3 = d4;
          return b3 | 0;
        }
        function Bw(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          c2[a3 >> 2] = b3;
          d4 = qC(16) | 0;
          c2[d4 + 4 >> 2] = 0;
          c2[d4 + 8 >> 2] = 0;
          c2[d4 >> 2] = 1656;
          c2[d4 + 12 >> 2] = b3;
          c2[a3 + 4 >> 2] = d4;
          return;
        }
        function Cw(a3) {
          a3 = a3 | 0;
          kC(a3);
          sC(a3);
          return;
        }
        function Dw(a3) {
          a3 = a3 | 0;
          a3 = c2[a3 + 12 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function Ew(a3) {
          a3 = a3 | 0;
          sC(a3);
          return;
        }
        function Fw(a3) {
          a3 = a3 | 0;
          Zi(a3);
          return;
        }
        function Gw(a3) {
          a3 = a3 | 0;
          fh(a3, Hw() | 0, 5);
          return;
        }
        function Hw() {
          return 1676;
        }
        function Iw(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          if ((Kw(a3) | 0) >>> 0 < b3 >>> 0)
            jC(a3);
          if (b3 >>> 0 > 1073741823)
            Ta();
          else {
            d4 = qC(b3 << 2) | 0;
            c2[a3 + 4 >> 2] = d4;
            c2[a3 >> 2] = d4;
            c2[a3 + 8 >> 2] = d4 + (b3 << 2);
            return;
          }
        }
        function Jw(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          e4 = a3 + 4 | 0;
          a3 = d4 - b3 | 0;
          if ((a3 | 0) > 0) {
            BC(c2[e4 >> 2] | 0, b3 | 0, a3 | 0) | 0;
            c2[e4 >> 2] = (c2[e4 >> 2] | 0) + (a3 >>> 2 << 2);
          }
          return;
        }
        function Kw(a3) {
          a3 = a3 | 0;
          return 1073741823;
        }
        function Lw(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          if ((Nw(a3) | 0) >>> 0 < b3 >>> 0)
            jC(a3);
          if (b3 >>> 0 > 1073741823)
            Ta();
          else {
            d4 = qC(b3 << 2) | 0;
            c2[a3 + 4 >> 2] = d4;
            c2[a3 >> 2] = d4;
            c2[a3 + 8 >> 2] = d4 + (b3 << 2);
            return;
          }
        }
        function Mw(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          e4 = a3 + 4 | 0;
          a3 = d4 - b3 | 0;
          if ((a3 | 0) > 0) {
            BC(c2[e4 >> 2] | 0, b3 | 0, a3 | 0) | 0;
            c2[e4 >> 2] = (c2[e4 >> 2] | 0) + (a3 >>> 2 << 2);
          }
          return;
        }
        function Nw(a3) {
          a3 = a3 | 0;
          return 1073741823;
        }
        function Ow(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 1073741823)
                Ta();
              else {
                f4 = qC(b3 << 2) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 << 2) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 << 2);
          return;
        }
        function Pw(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (0 - (f4 >> 2) << 2) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function Qw(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~((e4 + -4 - b3 | 0) >>> 2) << 2);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function Rw(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 1073741823)
                Ta();
              else {
                f4 = qC(b3 << 2) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 << 2) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 << 2);
          return;
        }
        function Sw(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (0 - (f4 >> 2) << 2) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function Tw(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~((e4 + -4 - b3 | 0) >>> 2) << 2);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function Uw(a3, b3, d4, e4, f4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          var g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0, p4 = 0, q3 = 0, r3 = 0;
          r3 = l3;
          l3 = l3 + 32 | 0;
          m4 = r3 + 20 | 0;
          n3 = r3 + 12 | 0;
          k4 = r3 + 16 | 0;
          o3 = r3 + 4 | 0;
          p4 = r3;
          q3 = r3 + 8 | 0;
          i4 = Wv() | 0;
          g3 = c2[i4 >> 2] | 0;
          h3 = c2[g3 >> 2] | 0;
          if (h3 | 0) {
            j4 = c2[i4 + 8 >> 2] | 0;
            i4 = c2[i4 + 4 >> 2] | 0;
            while (1) {
              OA(m4, h3);
              Vw(a3, m4, i4, j4);
              g3 = g3 + 4 | 0;
              h3 = c2[g3 >> 2] | 0;
              if (!h3)
                break;
              else {
                j4 = j4 + 1 | 0;
                i4 = i4 + 1 | 0;
              }
            }
          }
          g3 = Yv() | 0;
          h3 = c2[g3 >> 2] | 0;
          if (h3 | 0)
            do {
              OA(m4, h3);
              c2[n3 >> 2] = c2[g3 + 4 >> 2];
              Ww(b3, m4, n3);
              g3 = g3 + 8 | 0;
              h3 = c2[g3 >> 2] | 0;
            } while ((h3 | 0) != 0);
          g3 = c2[(Iv() | 0) >> 2] | 0;
          if (g3 | 0)
            do {
              b3 = c2[g3 + 4 >> 2] | 0;
              OA(m4, c2[(Xw(b3) | 0) >> 2] | 0);
              c2[n3 >> 2] = Tv(b3) | 0;
              Yw(d4, m4, n3);
              g3 = c2[g3 >> 2] | 0;
            } while ((g3 | 0) != 0);
          OA(k4, 0);
          g3 = Vv() | 0;
          c2[m4 >> 2] = c2[k4 >> 2];
          $v(m4, g3, f4);
          g3 = c2[(Iv() | 0) >> 2] | 0;
          if (g3 | 0) {
            a3 = m4 + 4 | 0;
            b3 = m4 + 8 | 0;
            d4 = m4 + 8 | 0;
            do {
              j4 = c2[g3 + 4 >> 2] | 0;
              OA(n3, c2[(Xw(j4) | 0) >> 2] | 0);
              _w(o3, Zw(j4) | 0);
              h3 = c2[o3 >> 2] | 0;
              if (h3 | 0) {
                c2[m4 >> 2] = 0;
                c2[a3 >> 2] = 0;
                c2[b3 >> 2] = 0;
                do {
                  OA(p4, c2[(Xw(c2[h3 + 4 >> 2] | 0) | 0) >> 2] | 0);
                  i4 = c2[a3 >> 2] | 0;
                  if (i4 >>> 0 < (c2[d4 >> 2] | 0) >>> 0) {
                    c2[i4 >> 2] = c2[p4 >> 2];
                    c2[a3 >> 2] = (c2[a3 >> 2] | 0) + 4;
                  } else
                    ew(m4, p4);
                  h3 = c2[h3 >> 2] | 0;
                } while ((h3 | 0) != 0);
                $w(e4, n3, m4);
                kw(m4);
              }
              c2[q3 >> 2] = c2[n3 >> 2];
              k4 = ax(j4) | 0;
              c2[m4 >> 2] = c2[q3 >> 2];
              $v(m4, k4, f4);
              Wi(o3);
              g3 = c2[g3 >> 2] | 0;
            } while ((g3 | 0) != 0);
          }
          l3 = r3;
          return;
        }
        function Vw(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          ox(a3, b3, c3, d4);
          return;
        }
        function Ww(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          nx(a3, b3, c3);
          return;
        }
        function Xw(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function Yw(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          ix(a3, b3, c3);
          return;
        }
        function Zw(a3) {
          a3 = a3 | 0;
          return a3 + 16 | 0;
        }
        function _w(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          g3 = l3;
          l3 = l3 + 16 | 0;
          f4 = g3 + 8 | 0;
          d4 = g3;
          c2[a3 >> 2] = 0;
          e4 = c2[b3 >> 2] | 0;
          c2[f4 >> 2] = e4;
          c2[d4 >> 2] = a3;
          d4 = gx(d4) | 0;
          if (e4 | 0) {
            e4 = qC(12) | 0;
            h3 = (hx(f4) | 0) + 4 | 0;
            a3 = c2[h3 + 4 >> 2] | 0;
            b3 = e4 + 4 | 0;
            c2[b3 >> 2] = c2[h3 >> 2];
            c2[b3 + 4 >> 2] = a3;
            b3 = c2[c2[f4 >> 2] >> 2] | 0;
            c2[f4 >> 2] = b3;
            if (!b3)
              a3 = e4;
            else {
              b3 = e4;
              while (1) {
                a3 = qC(12) | 0;
                j4 = (hx(f4) | 0) + 4 | 0;
                i4 = c2[j4 + 4 >> 2] | 0;
                h3 = a3 + 4 | 0;
                c2[h3 >> 2] = c2[j4 >> 2];
                c2[h3 + 4 >> 2] = i4;
                c2[b3 >> 2] = a3;
                h3 = c2[c2[f4 >> 2] >> 2] | 0;
                c2[f4 >> 2] = h3;
                if (!h3)
                  break;
                else
                  b3 = a3;
              }
            }
            c2[a3 >> 2] = c2[d4 >> 2];
            c2[d4 >> 2] = e4;
          }
          l3 = g3;
          return;
        }
        function $w(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          bx(a3, b3, c3);
          return;
        }
        function ax(a3) {
          a3 = a3 | 0;
          return a3 + 24 | 0;
        }
        function bx(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 32 | 0;
          h3 = e4 + 24 | 0;
          f4 = e4 + 16 | 0;
          i4 = e4 + 12 | 0;
          g3 = e4;
          UA(f4);
          a3 = Sg(a3) | 0;
          c2[i4 >> 2] = c2[b3 >> 2];
          mw(g3, d4);
          c2[h3 >> 2] = c2[i4 >> 2];
          cx(a3, h3, g3);
          kw(g3);
          WA(f4);
          l3 = e4;
          return;
        }
        function cx(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          e4 = l3;
          l3 = l3 + 32 | 0;
          h3 = e4 + 16 | 0;
          i4 = e4 + 12 | 0;
          f4 = e4;
          g3 = Vg(dx() | 0) | 0;
          c2[i4 >> 2] = c2[b3 >> 2];
          c2[h3 >> 2] = c2[i4 >> 2];
          b3 = qw(h3) | 0;
          c2[f4 >> 2] = c2[d4 >> 2];
          h3 = d4 + 4 | 0;
          c2[f4 + 4 >> 2] = c2[h3 >> 2];
          i4 = d4 + 8 | 0;
          c2[f4 + 8 >> 2] = c2[i4 >> 2];
          c2[i4 >> 2] = 0;
          c2[h3 >> 2] = 0;
          c2[d4 >> 2] = 0;
          xa(0, g3 | 0, a3 | 0, b3 | 0, tw(f4) | 0) | 0;
          kw(f4);
          l3 = e4;
          return;
        }
        function dx() {
          var b3 = 0;
          if (!(a2[7976] | 0)) {
            ex(10720);
            b3 = 7976;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          return 10720;
        }
        function ex(a3) {
          a3 = a3 | 0;
          fh(a3, fx() | 0, 2);
          return;
        }
        function fx() {
          return 1732;
        }
        function gx(a3) {
          a3 = a3 | 0;
          return c2[a3 >> 2] | 0;
        }
        function hx(a3) {
          a3 = a3 | 0;
          return c2[a3 >> 2] | 0;
        }
        function ix(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 32 | 0;
          g3 = e4 + 16 | 0;
          f4 = e4 + 8 | 0;
          h3 = e4;
          UA(f4);
          a3 = Sg(a3) | 0;
          c2[h3 >> 2] = c2[b3 >> 2];
          d4 = c2[d4 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          jx(a3, g3, d4);
          WA(f4);
          l3 = e4;
          return;
        }
        function jx(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          g3 = e4 + 4 | 0;
          h3 = e4;
          f4 = Vg(kx() | 0) | 0;
          c2[h3 >> 2] = c2[b3 >> 2];
          c2[g3 >> 2] = c2[h3 >> 2];
          b3 = qw(g3) | 0;
          xa(0, f4 | 0, a3 | 0, b3 | 0, rw(d4) | 0) | 0;
          l3 = e4;
          return;
        }
        function kx() {
          var b3 = 0;
          if (!(a2[7984] | 0)) {
            lx(10732);
            b3 = 7984;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          return 10732;
        }
        function lx(a3) {
          a3 = a3 | 0;
          fh(a3, mx() | 0, 2);
          return;
        }
        function mx() {
          return 1744;
        }
        function nx(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = l3;
          l3 = l3 + 32 | 0;
          g3 = e4 + 16 | 0;
          f4 = e4 + 8 | 0;
          h3 = e4;
          UA(f4);
          a3 = Sg(a3) | 0;
          c2[h3 >> 2] = c2[b3 >> 2];
          d4 = c2[d4 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          jx(a3, g3, d4);
          WA(f4);
          l3 = e4;
          return;
        }
        function ox(b3, d4, e4, f4) {
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          var g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          g3 = l3;
          l3 = l3 + 32 | 0;
          i4 = g3 + 16 | 0;
          h3 = g3 + 8 | 0;
          j4 = g3;
          UA(h3);
          b3 = Sg(b3) | 0;
          c2[j4 >> 2] = c2[d4 >> 2];
          e4 = a2[e4 >> 0] | 0;
          f4 = a2[f4 >> 0] | 0;
          c2[i4 >> 2] = c2[j4 >> 2];
          px(b3, i4, e4, f4);
          WA(h3);
          l3 = g3;
          return;
        }
        function px(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          f4 = l3;
          l3 = l3 + 16 | 0;
          h3 = f4 + 4 | 0;
          i4 = f4;
          g3 = Vg(qx() | 0) | 0;
          c2[i4 >> 2] = c2[b3 >> 2];
          c2[h3 >> 2] = c2[i4 >> 2];
          b3 = qw(h3) | 0;
          d4 = rx(d4) | 0;
          $a(0, g3 | 0, a3 | 0, b3 | 0, d4 | 0, rx(e4) | 0) | 0;
          l3 = f4;
          return;
        }
        function qx() {
          var b3 = 0;
          if (!(a2[7992] | 0)) {
            tx(10744);
            b3 = 7992;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          return 10744;
        }
        function rx(a3) {
          a3 = a3 | 0;
          return sx(a3) | 0;
        }
        function sx(a3) {
          a3 = a3 | 0;
          return a3 & 255 | 0;
        }
        function tx(a3) {
          a3 = a3 | 0;
          fh(a3, ux4() | 0, 3);
          return;
        }
        function ux4() {
          return 1756;
        }
        function vx4(b3, d4, e4) {
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0, p4 = 0;
          p4 = l3;
          l3 = l3 + 32 | 0;
          j4 = p4 + 8 | 0;
          k4 = p4 + 4 | 0;
          m4 = p4 + 20 | 0;
          n3 = p4;
          mk(b3, 0);
          f4 = QA(d4) | 0;
          c2[j4 >> 2] = 0;
          o3 = j4 + 4 | 0;
          c2[o3 >> 2] = 0;
          c2[j4 + 8 >> 2] = 0;
          switch (f4 << 24 >> 24) {
            case 0: {
              a2[m4 >> 0] = 0;
              wx(k4, e4, m4);
              xx(b3, k4) | 0;
              wf(k4);
              break;
            }
            case 8: {
              o3 = PA(d4) | 0;
              a2[m4 >> 0] = 8;
              OA(n3, c2[o3 + 4 >> 2] | 0);
              yx(k4, e4, m4, n3, o3 + 8 | 0);
              xx(b3, k4) | 0;
              wf(k4);
              break;
            }
            case 9: {
              h3 = PA(d4) | 0;
              d4 = c2[h3 + 4 >> 2] | 0;
              if (d4 | 0) {
                i4 = j4 + 8 | 0;
                g3 = h3 + 12 | 0;
                while (1) {
                  d4 = d4 + -1 | 0;
                  OA(k4, c2[g3 >> 2] | 0);
                  f4 = c2[o3 >> 2] | 0;
                  if (f4 >>> 0 < (c2[i4 >> 2] | 0) >>> 0) {
                    c2[f4 >> 2] = c2[k4 >> 2];
                    c2[o3 >> 2] = (c2[o3 >> 2] | 0) + 4;
                  } else
                    ew(j4, k4);
                  if (!d4)
                    break;
                  else
                    g3 = g3 + 4 | 0;
                }
              }
              a2[m4 >> 0] = 9;
              OA(n3, c2[h3 + 8 >> 2] | 0);
              zx(k4, e4, m4, n3, j4);
              xx(b3, k4) | 0;
              wf(k4);
              break;
            }
            default: {
              o3 = PA(d4) | 0;
              a2[m4 >> 0] = f4;
              OA(n3, c2[o3 + 4 >> 2] | 0);
              Ax(k4, e4, m4, n3);
              xx(b3, k4) | 0;
              wf(k4);
            }
          }
          kw(j4);
          l3 = p4;
          return;
        }
        function wx(b3, c3, d4) {
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0;
          e4 = l3;
          l3 = l3 + 16 | 0;
          f4 = e4;
          UA(f4);
          c3 = Sg(c3) | 0;
          Ox(b3, c3, a2[d4 >> 0] | 0);
          WA(f4);
          l3 = e4;
          return;
        }
        function xx(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = c2[a3 >> 2] | 0;
          if (d4 | 0)
            ab(d4 | 0);
          c2[a3 >> 2] = c2[b3 >> 2];
          c2[b3 >> 2] = 0;
          return a3 | 0;
        }
        function yx(b3, d4, e4, f4, g3) {
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          g3 = g3 | 0;
          var h3 = 0, i4 = 0, j4 = 0, k4 = 0;
          h3 = l3;
          l3 = l3 + 32 | 0;
          j4 = h3 + 16 | 0;
          i4 = h3 + 8 | 0;
          k4 = h3;
          UA(i4);
          d4 = Sg(d4) | 0;
          e4 = a2[e4 >> 0] | 0;
          c2[k4 >> 2] = c2[f4 >> 2];
          g3 = c2[g3 >> 2] | 0;
          c2[j4 >> 2] = c2[k4 >> 2];
          Kx(b3, d4, e4, j4, g3);
          WA(i4);
          l3 = h3;
          return;
        }
        function zx(b3, d4, e4, f4, g3) {
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          g3 = g3 | 0;
          var h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          h3 = l3;
          l3 = l3 + 32 | 0;
          k4 = h3 + 24 | 0;
          i4 = h3 + 16 | 0;
          m4 = h3 + 12 | 0;
          j4 = h3;
          UA(i4);
          d4 = Sg(d4) | 0;
          e4 = a2[e4 >> 0] | 0;
          c2[m4 >> 2] = c2[f4 >> 2];
          mw(j4, g3);
          c2[k4 >> 2] = c2[m4 >> 2];
          Gx(b3, d4, e4, k4, j4);
          kw(j4);
          WA(i4);
          l3 = h3;
          return;
        }
        function Ax(b3, d4, e4, f4) {
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          var g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          g3 = l3;
          l3 = l3 + 32 | 0;
          i4 = g3 + 16 | 0;
          h3 = g3 + 8 | 0;
          j4 = g3;
          UA(h3);
          d4 = Sg(d4) | 0;
          e4 = a2[e4 >> 0] | 0;
          c2[j4 >> 2] = c2[f4 >> 2];
          c2[i4 >> 2] = c2[j4 >> 2];
          Bx(b3, d4, e4, i4);
          WA(h3);
          l3 = g3;
          return;
        }
        function Bx(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          f4 = l3;
          l3 = l3 + 16 | 0;
          g3 = f4 + 4 | 0;
          i4 = f4;
          h3 = Vg(Cx() | 0) | 0;
          d4 = rx(d4) | 0;
          c2[i4 >> 2] = c2[e4 >> 2];
          c2[g3 >> 2] = c2[i4 >> 2];
          Dx(a3, xa(0, h3 | 0, b3 | 0, d4 | 0, qw(g3) | 0) | 0);
          l3 = f4;
          return;
        }
        function Cx() {
          var b3 = 0;
          if (!(a2[8e3] | 0)) {
            Ex(10756);
            b3 = 8e3;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          return 10756;
        }
        function Dx(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          mk(a3, b3);
          return;
        }
        function Ex(a3) {
          a3 = a3 | 0;
          fh(a3, Fx() | 0, 2);
          return;
        }
        function Fx() {
          return 1772;
        }
        function Gx(a3, b3, d4, e4, f4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          var g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0;
          g3 = l3;
          l3 = l3 + 32 | 0;
          j4 = g3 + 16 | 0;
          k4 = g3 + 12 | 0;
          h3 = g3;
          i4 = Vg(Hx() | 0) | 0;
          d4 = rx(d4) | 0;
          c2[k4 >> 2] = c2[e4 >> 2];
          c2[j4 >> 2] = c2[k4 >> 2];
          e4 = qw(j4) | 0;
          c2[h3 >> 2] = c2[f4 >> 2];
          j4 = f4 + 4 | 0;
          c2[h3 + 4 >> 2] = c2[j4 >> 2];
          k4 = f4 + 8 | 0;
          c2[h3 + 8 >> 2] = c2[k4 >> 2];
          c2[k4 >> 2] = 0;
          c2[j4 >> 2] = 0;
          c2[f4 >> 2] = 0;
          Dx(a3, $a(0, i4 | 0, b3 | 0, d4 | 0, e4 | 0, tw(h3) | 0) | 0);
          kw(h3);
          l3 = g3;
          return;
        }
        function Hx() {
          var b3 = 0;
          if (!(a2[8008] | 0)) {
            Ix(10768);
            b3 = 8008;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          return 10768;
        }
        function Ix(a3) {
          a3 = a3 | 0;
          fh(a3, Jx() | 0, 3);
          return;
        }
        function Jx() {
          return 1784;
        }
        function Kx(a3, b3, d4, e4, f4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          var g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          g3 = l3;
          l3 = l3 + 16 | 0;
          i4 = g3 + 4 | 0;
          j4 = g3;
          h3 = Vg(Lx() | 0) | 0;
          d4 = rx(d4) | 0;
          c2[j4 >> 2] = c2[e4 >> 2];
          c2[i4 >> 2] = c2[j4 >> 2];
          e4 = qw(i4) | 0;
          Dx(a3, $a(0, h3 | 0, b3 | 0, d4 | 0, e4 | 0, sw(f4) | 0) | 0);
          l3 = g3;
          return;
        }
        function Lx() {
          var b3 = 0;
          if (!(a2[8016] | 0)) {
            Mx(10780);
            b3 = 8016;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          return 10780;
        }
        function Mx(a3) {
          a3 = a3 | 0;
          fh(a3, Nx() | 0, 3);
          return;
        }
        function Nx() {
          return 1800;
        }
        function Ox(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          var d4 = 0;
          d4 = Vg(Px() | 0) | 0;
          Dx(a3, bb(0, d4 | 0, b3 | 0, rx(c3) | 0) | 0);
          return;
        }
        function Px() {
          var b3 = 0;
          if (!(a2[8024] | 0)) {
            Qx(10792);
            b3 = 8024;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          return 10792;
        }
        function Qx(a3) {
          a3 = a3 | 0;
          fh(a3, Rx() | 0, 1);
          return;
        }
        function Rx() {
          return 1816;
        }
        function Sx() {
          Tx();
          Ux();
          Vx();
          return;
        }
        function Tx() {
          c2[2702] = rC(65536) | 0;
          return;
        }
        function Ux() {
          qy(10856);
          return;
        }
        function Vx() {
          Wx(10816);
          return;
        }
        function Wx(a3) {
          a3 = a3 | 0;
          Xx(a3, 5044);
          Yx(a3) | 0;
          return;
        }
        function Xx(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = zw() | 0;
          c2[a3 >> 2] = d4;
          ky(d4, b3);
          Hv(c2[a3 >> 2] | 0);
          return;
        }
        function Yx(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = c2[a3 >> 2] | 0;
          At(b3, Zx() | 0);
          return a3 | 0;
        }
        function Zx() {
          var b3 = 0;
          if (!(a2[8032] | 0)) {
            _x(10820);
            Ha(64, 10820, o2 | 0) | 0;
            b3 = 8032;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          if (!(si(10820) | 0))
            _x(10820);
          return 10820;
        }
        function _x(a3) {
          a3 = a3 | 0;
          by(a3);
          Gt(a3, 25);
          return;
        }
        function $x(a3) {
          a3 = a3 | 0;
          ay(a3 + 24 | 0);
          return;
        }
        function ay(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~((b3 + -8 - e4 | 0) >>> 3) << 3);
            sC(d4);
          }
          return;
        }
        function by(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 5, 18, b3, gy() | 0, 1);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function cy(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          dy(a3, b3);
          return;
        }
        function dy(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0;
          d4 = l3;
          l3 = l3 + 16 | 0;
          e4 = d4;
          f4 = d4 + 4 | 0;
          Gk(f4, b3);
          c2[e4 >> 2] = Hk(f4, b3) | 0;
          ey(a3, e4);
          l3 = d4;
          return;
        }
        function ey(b3, d4) {
          b3 = b3 | 0;
          d4 = d4 | 0;
          fy(b3 + 4 | 0, c2[d4 >> 2] | 0);
          a2[b3 + 8 >> 0] = 1;
          return;
        }
        function fy(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c2[a3 >> 2] = b3;
          return;
        }
        function gy() {
          return 1824;
        }
        function hy(a3) {
          a3 = a3 | 0;
          return iy(a3) | 0;
        }
        function iy(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          d4 = l3;
          l3 = l3 + 16 | 0;
          f4 = d4 + 4 | 0;
          h3 = d4;
          e4 = jy(8) | 0;
          b3 = e4;
          i4 = qC(4) | 0;
          Gk(f4, a3);
          fy(i4, Hk(f4, a3) | 0);
          g3 = b3 + 4 | 0;
          c2[g3 >> 2] = i4;
          a3 = qC(8) | 0;
          g3 = c2[g3 >> 2] | 0;
          c2[h3 >> 2] = 0;
          c2[f4 >> 2] = c2[h3 >> 2];
          Bw(a3, g3, f4);
          c2[e4 >> 2] = a3;
          l3 = d4;
          return b3 | 0;
        }
        function jy(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0;
          a3 = a3 + 7 & -8;
          if (a3 >>> 0 <= 32768 ? (b3 = c2[2701] | 0, a3 >>> 0 <= (65536 - b3 | 0) >>> 0) : 0) {
            d4 = (c2[2702] | 0) + b3 | 0;
            c2[2701] = b3 + a3;
            a3 = d4;
          } else {
            a3 = rC(a3 + 8 | 0) | 0;
            c2[a3 >> 2] = c2[2703];
            c2[2703] = a3;
            a3 = a3 + 8 | 0;
          }
          return a3 | 0;
        }
        function ky(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c2[a3 >> 2] = ly() | 0;
          c2[a3 + 4 >> 2] = my() | 0;
          c2[a3 + 12 >> 2] = b3;
          c2[a3 + 8 >> 2] = ny() | 0;
          c2[a3 + 32 >> 2] = 9;
          return;
        }
        function ly() {
          return 11744;
        }
        function my() {
          return 1832;
        }
        function ny() {
          return cu() | 0;
        }
        function oy(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          if ((jr(d4, 896) | 0) == 512) {
            if (c3 | 0) {
              py(c3);
              sC(c3);
            }
          } else if (b3 | 0)
            sC(b3);
          return;
        }
        function py(a3) {
          a3 = a3 | 0;
          a3 = c2[a3 + 4 >> 2] | 0;
          if (a3 | 0)
            oC(a3);
          return;
        }
        function qy(a3) {
          a3 = a3 | 0;
          ry(a3, 5052);
          sy(a3) | 0;
          ty(a3, 5058, 26) | 0;
          uy4(a3, 5069, 1) | 0;
          vy4(a3, 5077, 10) | 0;
          wy(a3, 5087, 19) | 0;
          yy(a3, 5094, 27) | 0;
          return;
        }
        function ry(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = GA() | 0;
          c2[a3 >> 2] = d4;
          HA(d4, b3);
          Hv(c2[a3 >> 2] | 0);
          return;
        }
        function sy(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = c2[a3 >> 2] | 0;
          At(b3, rA() | 0);
          return a3 | 0;
        }
        function ty(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          Yz(a3, ai(b3) | 0, c3, 0);
          return a3 | 0;
        }
        function uy4(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          Gz(a3, ai(b3) | 0, c3, 0);
          return a3 | 0;
        }
        function vy4(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          hz(a3, ai(b3) | 0, c3, 0);
          return a3 | 0;
        }
        function wy(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          Ry(a3, ai(b3) | 0, c3, 0);
          return a3 | 0;
        }
        function xy(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          a:
            while (1) {
              d4 = c2[2703] | 0;
              while (1) {
                if ((d4 | 0) == (b3 | 0))
                  break a;
                e4 = c2[d4 >> 2] | 0;
                c2[2703] = e4;
                if (!d4)
                  d4 = e4;
                else
                  break;
              }
              sC(d4);
            }
          c2[2701] = a3;
          return;
        }
        function yy(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          zy(a3, ai(b3) | 0, c3, 0);
          return a3 | 0;
        }
        function zy(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0;
          g3 = c2[a3 >> 2] | 0;
          f4 = Ay() | 0;
          a3 = By(d4) | 0;
          fi(g3, b3, f4, a3, Cy(d4, e4) | 0, e4);
          return;
        }
        function Ay() {
          var b3 = 0, d4 = 0;
          if (!(a2[8040] | 0)) {
            Jy(10860);
            Ha(65, 10860, o2 | 0) | 0;
            d4 = 8040;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(10860) | 0)) {
            b3 = 10860;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            Jy(10860);
          }
          return 10860;
        }
        function By(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function Cy(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          i4 = l3;
          l3 = l3 + 16 | 0;
          f4 = i4;
          g3 = i4 + 4 | 0;
          c2[f4 >> 2] = a3;
          j4 = Ay() | 0;
          h3 = j4 + 24 | 0;
          b3 = ji(b3, 4) | 0;
          c2[g3 >> 2] = b3;
          d4 = j4 + 28 | 0;
          e4 = c2[d4 >> 2] | 0;
          if (e4 >>> 0 < (c2[j4 + 32 >> 2] | 0) >>> 0) {
            Dy(e4, a3, b3);
            b3 = (c2[d4 >> 2] | 0) + 8 | 0;
            c2[d4 >> 2] = b3;
          } else {
            Ey(h3, f4, g3);
            b3 = c2[d4 >> 2] | 0;
          }
          l3 = i4;
          return (b3 - (c2[h3 >> 2] | 0) >> 3) + -1 | 0;
        }
        function Dy(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          c2[a3 >> 2] = b3;
          c2[a3 + 4 >> 2] = d4;
          return;
        }
        function Ey(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          i4 = l3;
          l3 = l3 + 32 | 0;
          f4 = i4;
          g3 = a3 + 4 | 0;
          h3 = ((c2[g3 >> 2] | 0) - (c2[a3 >> 2] | 0) >> 3) + 1 | 0;
          e4 = Fy(a3) | 0;
          if (e4 >>> 0 < h3 >>> 0)
            jC(a3);
          else {
            j4 = c2[a3 >> 2] | 0;
            m4 = (c2[a3 + 8 >> 2] | 0) - j4 | 0;
            k4 = m4 >> 2;
            Gy(f4, m4 >> 3 >>> 0 < e4 >>> 1 >>> 0 ? k4 >>> 0 < h3 >>> 0 ? h3 : k4 : e4, (c2[g3 >> 2] | 0) - j4 >> 3, a3 + 8 | 0);
            h3 = f4 + 8 | 0;
            Dy(c2[h3 >> 2] | 0, c2[b3 >> 2] | 0, c2[d4 >> 2] | 0);
            c2[h3 >> 2] = (c2[h3 >> 2] | 0) + 8;
            Hy(a3, f4);
            Iy(f4);
            l3 = i4;
            return;
          }
        }
        function Fy(a3) {
          a3 = a3 | 0;
          return 536870911;
        }
        function Gy(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 536870911)
                Ta();
              else {
                f4 = qC(b3 << 3) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 << 3) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 << 3);
          return;
        }
        function Hy(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (0 - (f4 >> 3) << 3) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function Iy(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~((e4 + -8 - b3 | 0) >>> 3) << 3);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function Jy(a3) {
          a3 = a3 | 0;
          My(a3);
          return;
        }
        function Ky(a3) {
          a3 = a3 | 0;
          Ly(a3 + 24 | 0);
          return;
        }
        function Ly(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~((b3 + -8 - e4 | 0) >>> 3) << 3);
            sC(d4);
          }
          return;
        }
        function My(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 1, 11, b3, Ny() | 0, 2);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function Ny() {
          return 1840;
        }
        function Oy(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          Qy(c2[(Py(a3) | 0) >> 2] | 0, b3, d4);
          return;
        }
        function Py(a3) {
          a3 = a3 | 0;
          return (c2[(Ay() | 0) + 24 >> 2] | 0) + (a3 << 3) | 0;
        }
        function Qy(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          var d4 = 0, e4 = 0, f4 = 0;
          d4 = l3;
          l3 = l3 + 16 | 0;
          f4 = d4 + 1 | 0;
          e4 = d4;
          Gk(f4, b3);
          b3 = Hk(f4, b3) | 0;
          Gk(e4, c3);
          c3 = Hk(e4, c3) | 0;
          ob[a3 & 31](b3, c3);
          l3 = d4;
          return;
        }
        function Ry(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0;
          g3 = c2[a3 >> 2] | 0;
          f4 = Sy() | 0;
          a3 = Ty(d4) | 0;
          fi(g3, b3, f4, a3, Uy(d4, e4) | 0, e4);
          return;
        }
        function Sy() {
          var b3 = 0, d4 = 0;
          if (!(a2[8048] | 0)) {
            $y(10896);
            Ha(66, 10896, o2 | 0) | 0;
            d4 = 8048;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(10896) | 0)) {
            b3 = 10896;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            $y(10896);
          }
          return 10896;
        }
        function Ty(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function Uy(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          i4 = l3;
          l3 = l3 + 16 | 0;
          f4 = i4;
          g3 = i4 + 4 | 0;
          c2[f4 >> 2] = a3;
          j4 = Sy() | 0;
          h3 = j4 + 24 | 0;
          b3 = ji(b3, 4) | 0;
          c2[g3 >> 2] = b3;
          d4 = j4 + 28 | 0;
          e4 = c2[d4 >> 2] | 0;
          if (e4 >>> 0 < (c2[j4 + 32 >> 2] | 0) >>> 0) {
            Vy(e4, a3, b3);
            b3 = (c2[d4 >> 2] | 0) + 8 | 0;
            c2[d4 >> 2] = b3;
          } else {
            Wy(h3, f4, g3);
            b3 = c2[d4 >> 2] | 0;
          }
          l3 = i4;
          return (b3 - (c2[h3 >> 2] | 0) >> 3) + -1 | 0;
        }
        function Vy(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          c2[a3 >> 2] = b3;
          c2[a3 + 4 >> 2] = d4;
          return;
        }
        function Wy(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          i4 = l3;
          l3 = l3 + 32 | 0;
          f4 = i4;
          g3 = a3 + 4 | 0;
          h3 = ((c2[g3 >> 2] | 0) - (c2[a3 >> 2] | 0) >> 3) + 1 | 0;
          e4 = Xy(a3) | 0;
          if (e4 >>> 0 < h3 >>> 0)
            jC(a3);
          else {
            j4 = c2[a3 >> 2] | 0;
            m4 = (c2[a3 + 8 >> 2] | 0) - j4 | 0;
            k4 = m4 >> 2;
            Yy(f4, m4 >> 3 >>> 0 < e4 >>> 1 >>> 0 ? k4 >>> 0 < h3 >>> 0 ? h3 : k4 : e4, (c2[g3 >> 2] | 0) - j4 >> 3, a3 + 8 | 0);
            h3 = f4 + 8 | 0;
            Vy(c2[h3 >> 2] | 0, c2[b3 >> 2] | 0, c2[d4 >> 2] | 0);
            c2[h3 >> 2] = (c2[h3 >> 2] | 0) + 8;
            Zy(a3, f4);
            _y(f4);
            l3 = i4;
            return;
          }
        }
        function Xy(a3) {
          a3 = a3 | 0;
          return 536870911;
        }
        function Yy(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 536870911)
                Ta();
              else {
                f4 = qC(b3 << 3) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 << 3) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 << 3);
          return;
        }
        function Zy(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (0 - (f4 >> 3) << 3) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function _y(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~((e4 + -8 - b3 | 0) >>> 3) << 3);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function $y(a3) {
          a3 = a3 | 0;
          cz(a3);
          return;
        }
        function az(a3) {
          a3 = a3 | 0;
          bz(a3 + 24 | 0);
          return;
        }
        function bz(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~((b3 + -8 - e4 | 0) >>> 3) << 3);
            sC(d4);
          }
          return;
        }
        function cz(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 1, 11, b3, dz() | 0, 1);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function dz() {
          return 1852;
        }
        function ez(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return gz(c2[(fz(a3) | 0) >> 2] | 0, b3) | 0;
        }
        function fz(a3) {
          a3 = a3 | 0;
          return (c2[(Sy() | 0) + 24 >> 2] | 0) + (a3 << 3) | 0;
        }
        function gz(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var c3 = 0, d4 = 0;
          c3 = l3;
          l3 = l3 + 16 | 0;
          d4 = c3;
          Gk(d4, b3);
          b3 = Hk(d4, b3) | 0;
          b3 = ul(pb[a3 & 31](b3) | 0) | 0;
          l3 = c3;
          return b3 | 0;
        }
        function hz(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0;
          g3 = c2[a3 >> 2] | 0;
          f4 = iz() | 0;
          a3 = jz(d4) | 0;
          fi(g3, b3, f4, a3, kz(d4, e4) | 0, e4);
          return;
        }
        function iz() {
          var b3 = 0, d4 = 0;
          if (!(a2[8056] | 0)) {
            rz(10932);
            Ha(67, 10932, o2 | 0) | 0;
            d4 = 8056;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(10932) | 0)) {
            b3 = 10932;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            rz(10932);
          }
          return 10932;
        }
        function jz(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function kz(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          i4 = l3;
          l3 = l3 + 16 | 0;
          f4 = i4;
          g3 = i4 + 4 | 0;
          c2[f4 >> 2] = a3;
          j4 = iz() | 0;
          h3 = j4 + 24 | 0;
          b3 = ji(b3, 4) | 0;
          c2[g3 >> 2] = b3;
          d4 = j4 + 28 | 0;
          e4 = c2[d4 >> 2] | 0;
          if (e4 >>> 0 < (c2[j4 + 32 >> 2] | 0) >>> 0) {
            lz(e4, a3, b3);
            b3 = (c2[d4 >> 2] | 0) + 8 | 0;
            c2[d4 >> 2] = b3;
          } else {
            mz(h3, f4, g3);
            b3 = c2[d4 >> 2] | 0;
          }
          l3 = i4;
          return (b3 - (c2[h3 >> 2] | 0) >> 3) + -1 | 0;
        }
        function lz(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          c2[a3 >> 2] = b3;
          c2[a3 + 4 >> 2] = d4;
          return;
        }
        function mz(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          i4 = l3;
          l3 = l3 + 32 | 0;
          f4 = i4;
          g3 = a3 + 4 | 0;
          h3 = ((c2[g3 >> 2] | 0) - (c2[a3 >> 2] | 0) >> 3) + 1 | 0;
          e4 = nz(a3) | 0;
          if (e4 >>> 0 < h3 >>> 0)
            jC(a3);
          else {
            j4 = c2[a3 >> 2] | 0;
            m4 = (c2[a3 + 8 >> 2] | 0) - j4 | 0;
            k4 = m4 >> 2;
            oz(f4, m4 >> 3 >>> 0 < e4 >>> 1 >>> 0 ? k4 >>> 0 < h3 >>> 0 ? h3 : k4 : e4, (c2[g3 >> 2] | 0) - j4 >> 3, a3 + 8 | 0);
            h3 = f4 + 8 | 0;
            lz(c2[h3 >> 2] | 0, c2[b3 >> 2] | 0, c2[d4 >> 2] | 0);
            c2[h3 >> 2] = (c2[h3 >> 2] | 0) + 8;
            pz(a3, f4);
            qz(f4);
            l3 = i4;
            return;
          }
        }
        function nz(a3) {
          a3 = a3 | 0;
          return 536870911;
        }
        function oz(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 536870911)
                Ta();
              else {
                f4 = qC(b3 << 3) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 << 3) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 << 3);
          return;
        }
        function pz(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (0 - (f4 >> 3) << 3) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function qz(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~((e4 + -8 - b3 | 0) >>> 3) << 3);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function rz(a3) {
          a3 = a3 | 0;
          uz(a3);
          return;
        }
        function sz(a3) {
          a3 = a3 | 0;
          tz(a3 + 24 | 0);
          return;
        }
        function tz(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~((b3 + -8 - e4 | 0) >>> 3) << 3);
            sC(d4);
          }
          return;
        }
        function uz(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 1, 7, b3, vz() | 0, 2);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function vz() {
          return 1860;
        }
        function wz(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          return yz(c2[(xz(a3) | 0) >> 2] | 0, b3, d4) | 0;
        }
        function xz(a3) {
          a3 = a3 | 0;
          return (c2[(iz() | 0) + 24 >> 2] | 0) + (a3 << 3) | 0;
        }
        function yz(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          e4 = l3;
          l3 = l3 + 32 | 0;
          h3 = e4 + 12 | 0;
          g3 = e4 + 8 | 0;
          i4 = e4;
          j4 = e4 + 16 | 0;
          f4 = e4 + 4 | 0;
          zz(j4, b3);
          Az(i4, j4, b3);
          ik(f4, d4);
          d4 = jk(f4, d4) | 0;
          c2[h3 >> 2] = c2[i4 >> 2];
          Eb[a3 & 15](g3, h3, d4);
          d4 = Bz(g3) | 0;
          wf(g3);
          kk(f4);
          l3 = e4;
          return d4 | 0;
        }
        function zz(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return;
        }
        function Az(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          Cz(a3, c3);
          return;
        }
        function Bz(a3) {
          a3 = a3 | 0;
          return Sg(a3) | 0;
        }
        function Cz(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0;
          f4 = l3;
          l3 = l3 + 16 | 0;
          d4 = f4;
          e4 = b3;
          if (!(e4 & 1))
            c2[a3 >> 2] = c2[b3 >> 2];
          else {
            Dz(d4, 0);
            Ja(e4 | 0, d4 | 0) | 0;
            Ez(a3, d4);
            Fz(d4);
          }
          l3 = f4;
          return;
        }
        function Dz(b3, d4) {
          b3 = b3 | 0;
          d4 = d4 | 0;
          ah(b3, d4);
          c2[b3 + 4 >> 2] = 0;
          a2[b3 + 8 >> 0] = 0;
          return;
        }
        function Ez(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c2[a3 >> 2] = c2[b3 + 4 >> 2];
          return;
        }
        function Fz(b3) {
          b3 = b3 | 0;
          a2[b3 + 8 >> 0] = 0;
          return;
        }
        function Gz(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0;
          g3 = c2[a3 >> 2] | 0;
          f4 = Hz() | 0;
          a3 = Iz(d4) | 0;
          fi(g3, b3, f4, a3, Jz(d4, e4) | 0, e4);
          return;
        }
        function Hz() {
          var b3 = 0, d4 = 0;
          if (!(a2[8064] | 0)) {
            Qz(10968);
            Ha(68, 10968, o2 | 0) | 0;
            d4 = 8064;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(10968) | 0)) {
            b3 = 10968;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            Qz(10968);
          }
          return 10968;
        }
        function Iz(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function Jz(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          i4 = l3;
          l3 = l3 + 16 | 0;
          f4 = i4;
          g3 = i4 + 4 | 0;
          c2[f4 >> 2] = a3;
          j4 = Hz() | 0;
          h3 = j4 + 24 | 0;
          b3 = ji(b3, 4) | 0;
          c2[g3 >> 2] = b3;
          d4 = j4 + 28 | 0;
          e4 = c2[d4 >> 2] | 0;
          if (e4 >>> 0 < (c2[j4 + 32 >> 2] | 0) >>> 0) {
            Kz(e4, a3, b3);
            b3 = (c2[d4 >> 2] | 0) + 8 | 0;
            c2[d4 >> 2] = b3;
          } else {
            Lz(h3, f4, g3);
            b3 = c2[d4 >> 2] | 0;
          }
          l3 = i4;
          return (b3 - (c2[h3 >> 2] | 0) >> 3) + -1 | 0;
        }
        function Kz(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          c2[a3 >> 2] = b3;
          c2[a3 + 4 >> 2] = d4;
          return;
        }
        function Lz(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          i4 = l3;
          l3 = l3 + 32 | 0;
          f4 = i4;
          g3 = a3 + 4 | 0;
          h3 = ((c2[g3 >> 2] | 0) - (c2[a3 >> 2] | 0) >> 3) + 1 | 0;
          e4 = Mz(a3) | 0;
          if (e4 >>> 0 < h3 >>> 0)
            jC(a3);
          else {
            j4 = c2[a3 >> 2] | 0;
            m4 = (c2[a3 + 8 >> 2] | 0) - j4 | 0;
            k4 = m4 >> 2;
            Nz(f4, m4 >> 3 >>> 0 < e4 >>> 1 >>> 0 ? k4 >>> 0 < h3 >>> 0 ? h3 : k4 : e4, (c2[g3 >> 2] | 0) - j4 >> 3, a3 + 8 | 0);
            h3 = f4 + 8 | 0;
            Kz(c2[h3 >> 2] | 0, c2[b3 >> 2] | 0, c2[d4 >> 2] | 0);
            c2[h3 >> 2] = (c2[h3 >> 2] | 0) + 8;
            Oz(a3, f4);
            Pz(f4);
            l3 = i4;
            return;
          }
        }
        function Mz(a3) {
          a3 = a3 | 0;
          return 536870911;
        }
        function Nz(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 536870911)
                Ta();
              else {
                f4 = qC(b3 << 3) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 << 3) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 << 3);
          return;
        }
        function Oz(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (0 - (f4 >> 3) << 3) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function Pz(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~((e4 + -8 - b3 | 0) >>> 3) << 3);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function Qz(a3) {
          a3 = a3 | 0;
          Tz(a3);
          return;
        }
        function Rz(a3) {
          a3 = a3 | 0;
          Sz(a3 + 24 | 0);
          return;
        }
        function Sz(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~((b3 + -8 - e4 | 0) >>> 3) << 3);
            sC(d4);
          }
          return;
        }
        function Tz(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 1, 1, b3, Uz() | 0, 5);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function Uz() {
          return 1872;
        }
        function Vz(a3, b3, d4, e4, f4, g3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          g3 = g3 | 0;
          Xz(c2[(Wz(a3) | 0) >> 2] | 0, b3, d4, e4, f4, g3);
          return;
        }
        function Wz(a3) {
          a3 = a3 | 0;
          return (c2[(Hz() | 0) + 24 >> 2] | 0) + (a3 << 3) | 0;
        }
        function Xz(a3, b3, c3, d4, e4, f4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          var g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          g3 = l3;
          l3 = l3 + 32 | 0;
          h3 = g3 + 16 | 0;
          i4 = g3 + 12 | 0;
          j4 = g3 + 8 | 0;
          k4 = g3 + 4 | 0;
          m4 = g3;
          ik(h3, b3);
          b3 = jk(h3, b3) | 0;
          ik(i4, c3);
          c3 = jk(i4, c3) | 0;
          ik(j4, d4);
          d4 = jk(j4, d4) | 0;
          ik(k4, e4);
          e4 = jk(k4, e4) | 0;
          ik(m4, f4);
          f4 = jk(m4, f4) | 0;
          jb[a3 & 1](b3, c3, d4, e4, f4);
          kk(m4);
          kk(k4);
          kk(j4);
          kk(i4);
          kk(h3);
          l3 = g3;
          return;
        }
        function Yz(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0;
          g3 = c2[a3 >> 2] | 0;
          f4 = Zz() | 0;
          a3 = _z(d4) | 0;
          fi(g3, b3, f4, a3, $z(d4, e4) | 0, e4);
          return;
        }
        function Zz() {
          var b3 = 0, d4 = 0;
          if (!(a2[8072] | 0)) {
            gA(11004);
            Ha(69, 11004, o2 | 0) | 0;
            d4 = 8072;
            c2[d4 >> 2] = 1;
            c2[d4 + 4 >> 2] = 0;
          }
          if (!(si(11004) | 0)) {
            b3 = 11004;
            d4 = b3 + 36 | 0;
            do {
              c2[b3 >> 2] = 0;
              b3 = b3 + 4 | 0;
            } while ((b3 | 0) < (d4 | 0));
            gA(11004);
          }
          return 11004;
        }
        function _z(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function $z(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          i4 = l3;
          l3 = l3 + 16 | 0;
          f4 = i4;
          g3 = i4 + 4 | 0;
          c2[f4 >> 2] = a3;
          j4 = Zz() | 0;
          h3 = j4 + 24 | 0;
          b3 = ji(b3, 4) | 0;
          c2[g3 >> 2] = b3;
          d4 = j4 + 28 | 0;
          e4 = c2[d4 >> 2] | 0;
          if (e4 >>> 0 < (c2[j4 + 32 >> 2] | 0) >>> 0) {
            aA(e4, a3, b3);
            b3 = (c2[d4 >> 2] | 0) + 8 | 0;
            c2[d4 >> 2] = b3;
          } else {
            bA(h3, f4, g3);
            b3 = c2[d4 >> 2] | 0;
          }
          l3 = i4;
          return (b3 - (c2[h3 >> 2] | 0) >> 3) + -1 | 0;
        }
        function aA(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          c2[a3 >> 2] = b3;
          c2[a3 + 4 >> 2] = d4;
          return;
        }
        function bA(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0;
          i4 = l3;
          l3 = l3 + 32 | 0;
          f4 = i4;
          g3 = a3 + 4 | 0;
          h3 = ((c2[g3 >> 2] | 0) - (c2[a3 >> 2] | 0) >> 3) + 1 | 0;
          e4 = cA(a3) | 0;
          if (e4 >>> 0 < h3 >>> 0)
            jC(a3);
          else {
            j4 = c2[a3 >> 2] | 0;
            m4 = (c2[a3 + 8 >> 2] | 0) - j4 | 0;
            k4 = m4 >> 2;
            dA(f4, m4 >> 3 >>> 0 < e4 >>> 1 >>> 0 ? k4 >>> 0 < h3 >>> 0 ? h3 : k4 : e4, (c2[g3 >> 2] | 0) - j4 >> 3, a3 + 8 | 0);
            h3 = f4 + 8 | 0;
            aA(c2[h3 >> 2] | 0, c2[b3 >> 2] | 0, c2[d4 >> 2] | 0);
            c2[h3 >> 2] = (c2[h3 >> 2] | 0) + 8;
            eA(a3, f4);
            fA(f4);
            l3 = i4;
            return;
          }
        }
        function cA(a3) {
          a3 = a3 | 0;
          return 536870911;
        }
        function dA(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0;
          c2[a3 + 12 >> 2] = 0;
          c2[a3 + 16 >> 2] = e4;
          do
            if (b3) {
              if (b3 >>> 0 > 536870911)
                Ta();
              else {
                f4 = qC(b3 << 3) | 0;
                break;
              }
            } else
              f4 = 0;
          while (0);
          c2[a3 >> 2] = f4;
          e4 = f4 + (d4 << 3) | 0;
          c2[a3 + 8 >> 2] = e4;
          c2[a3 + 4 >> 2] = e4;
          c2[a3 + 12 >> 2] = f4 + (b3 << 3);
          return;
        }
        function eA(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          e4 = c2[a3 >> 2] | 0;
          h3 = a3 + 4 | 0;
          g3 = b3 + 4 | 0;
          f4 = (c2[h3 >> 2] | 0) - e4 | 0;
          d4 = (c2[g3 >> 2] | 0) + (0 - (f4 >> 3) << 3) | 0;
          c2[g3 >> 2] = d4;
          if ((f4 | 0) > 0) {
            BC(d4 | 0, e4 | 0, f4 | 0) | 0;
            e4 = g3;
            d4 = c2[g3 >> 2] | 0;
          } else
            e4 = g3;
          g3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = d4;
          c2[e4 >> 2] = g3;
          g3 = b3 + 8 | 0;
          f4 = c2[h3 >> 2] | 0;
          c2[h3 >> 2] = c2[g3 >> 2];
          c2[g3 >> 2] = f4;
          g3 = a3 + 8 | 0;
          h3 = b3 + 12 | 0;
          a3 = c2[g3 >> 2] | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[h3 >> 2] = a3;
          c2[b3 >> 2] = c2[e4 >> 2];
          return;
        }
        function fA(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          b3 = c2[a3 + 4 >> 2] | 0;
          d4 = a3 + 8 | 0;
          e4 = c2[d4 >> 2] | 0;
          if ((e4 | 0) != (b3 | 0))
            c2[d4 >> 2] = e4 + (~((e4 + -8 - b3 | 0) >>> 3) << 3);
          a3 = c2[a3 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function gA(a3) {
          a3 = a3 | 0;
          jA(a3);
          return;
        }
        function hA(a3) {
          a3 = a3 | 0;
          iA(a3 + 24 | 0);
          return;
        }
        function iA(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~((b3 + -8 - e4 | 0) >>> 3) << 3);
            sC(d4);
          }
          return;
        }
        function jA(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 1, 12, b3, kA() | 0, 2);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function kA() {
          return 1896;
        }
        function lA(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          nA(c2[(mA(a3) | 0) >> 2] | 0, b3, d4);
          return;
        }
        function mA(a3) {
          a3 = a3 | 0;
          return (c2[(Zz() | 0) + 24 >> 2] | 0) + (a3 << 3) | 0;
        }
        function nA(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          var d4 = 0, e4 = 0, f4 = 0;
          d4 = l3;
          l3 = l3 + 16 | 0;
          f4 = d4 + 4 | 0;
          e4 = d4;
          oA(f4, b3);
          b3 = pA(f4, b3) | 0;
          ik(e4, c3);
          c3 = jk(e4, c3) | 0;
          ob[a3 & 31](b3, c3);
          kk(e4);
          l3 = d4;
          return;
        }
        function oA(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return;
        }
        function pA(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return qA(b3) | 0;
        }
        function qA(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function rA() {
          var b3 = 0;
          if (!(a2[8080] | 0)) {
            sA(11040);
            Ha(70, 11040, o2 | 0) | 0;
            b3 = 8080;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          if (!(si(11040) | 0))
            sA(11040);
          return 11040;
        }
        function sA(a3) {
          a3 = a3 | 0;
          vA(a3);
          Gt(a3, 71);
          return;
        }
        function tA(a3) {
          a3 = a3 | 0;
          uA(a3 + 24 | 0);
          return;
        }
        function uA(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0;
          d4 = c2[a3 >> 2] | 0;
          e4 = d4;
          if (d4 | 0) {
            a3 = a3 + 4 | 0;
            b3 = c2[a3 >> 2] | 0;
            if ((b3 | 0) != (d4 | 0))
              c2[a3 >> 2] = b3 + (~((b3 + -8 - e4 | 0) >>> 3) << 3);
            sC(d4);
          }
          return;
        }
        function vA(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = vi() | 0;
          yi(a3, 5, 7, b3, zA() | 0, 0);
          c2[a3 + 24 >> 2] = 0;
          c2[a3 + 28 >> 2] = 0;
          c2[a3 + 32 >> 2] = 0;
          return;
        }
        function wA(a3) {
          a3 = a3 | 0;
          xA(a3);
          return;
        }
        function xA(a3) {
          a3 = a3 | 0;
          yA(a3);
          return;
        }
        function yA(b3) {
          b3 = b3 | 0;
          a2[b3 + 8 >> 0] = 1;
          return;
        }
        function zA() {
          return 1936;
        }
        function AA() {
          return BA() | 0;
        }
        function BA() {
          var a3 = 0, b3 = 0, d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0;
          b3 = l3;
          l3 = l3 + 16 | 0;
          f4 = b3 + 4 | 0;
          h3 = b3;
          d4 = jy(8) | 0;
          a3 = d4;
          g3 = a3 + 4 | 0;
          c2[g3 >> 2] = qC(1) | 0;
          e4 = qC(8) | 0;
          g3 = c2[g3 >> 2] | 0;
          c2[h3 >> 2] = 0;
          c2[f4 >> 2] = c2[h3 >> 2];
          CA(e4, g3, f4);
          c2[d4 >> 2] = e4;
          l3 = b3;
          return a3 | 0;
        }
        function CA(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          c2[a3 >> 2] = b3;
          d4 = qC(16) | 0;
          c2[d4 + 4 >> 2] = 0;
          c2[d4 + 8 >> 2] = 0;
          c2[d4 >> 2] = 1916;
          c2[d4 + 12 >> 2] = b3;
          c2[a3 + 4 >> 2] = d4;
          return;
        }
        function DA(a3) {
          a3 = a3 | 0;
          kC(a3);
          sC(a3);
          return;
        }
        function EA(a3) {
          a3 = a3 | 0;
          a3 = c2[a3 + 12 >> 2] | 0;
          if (a3 | 0)
            sC(a3);
          return;
        }
        function FA(a3) {
          a3 = a3 | 0;
          sC(a3);
          return;
        }
        function GA() {
          var b3 = 0;
          if (!(a2[8088] | 0)) {
            NA(11076);
            Ha(25, 11076, o2 | 0) | 0;
            b3 = 8088;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          return 11076;
        }
        function HA(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c2[a3 >> 2] = IA() | 0;
          c2[a3 + 4 >> 2] = JA() | 0;
          c2[a3 + 12 >> 2] = b3;
          c2[a3 + 8 >> 2] = KA() | 0;
          c2[a3 + 32 >> 2] = 10;
          return;
        }
        function IA() {
          return 11745;
        }
        function JA() {
          return 1940;
        }
        function KA() {
          return lr() | 0;
        }
        function LA(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          if ((jr(d4, 896) | 0) == 512) {
            if (c3 | 0) {
              MA(c3);
              sC(c3);
            }
          } else if (b3 | 0)
            sC(b3);
          return;
        }
        function MA(a3) {
          a3 = a3 | 0;
          a3 = c2[a3 + 4 >> 2] | 0;
          if (a3 | 0)
            oC(a3);
          return;
        }
        function NA(a3) {
          a3 = a3 | 0;
          Zi(a3);
          return;
        }
        function OA(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c2[a3 >> 2] = b3;
          return;
        }
        function PA(a3) {
          a3 = a3 | 0;
          return c2[a3 >> 2] | 0;
        }
        function QA(b3) {
          b3 = b3 | 0;
          return a2[c2[b3 >> 2] >> 0] | 0;
        }
        function RA(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          d4 = l3;
          l3 = l3 + 16 | 0;
          e4 = d4;
          c2[e4 >> 2] = c2[a3 >> 2];
          SA(b3, e4) | 0;
          l3 = d4;
          return;
        }
        function SA(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0;
          d4 = TA(c2[a3 >> 2] | 0, b3) | 0;
          b3 = a3 + 4 | 0;
          c2[(c2[b3 >> 2] | 0) + 8 >> 2] = d4;
          return c2[(c2[b3 >> 2] | 0) + 8 >> 2] | 0;
        }
        function TA(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          d4 = l3;
          l3 = l3 + 16 | 0;
          e4 = d4;
          UA(e4);
          a3 = Sg(a3) | 0;
          b3 = VA(a3, c2[b3 >> 2] | 0) | 0;
          WA(e4);
          l3 = d4;
          return b3 | 0;
        }
        function UA(a3) {
          a3 = a3 | 0;
          c2[a3 >> 2] = c2[2701];
          c2[a3 + 4 >> 2] = c2[2703];
          return;
        }
        function VA(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var c3 = 0;
          c3 = Vg(XA() | 0) | 0;
          return bb(0, c3 | 0, a3 | 0, sw(b3) | 0) | 0;
        }
        function WA(a3) {
          a3 = a3 | 0;
          xy(c2[a3 >> 2] | 0, c2[a3 + 4 >> 2] | 0);
          return;
        }
        function XA() {
          var b3 = 0;
          if (!(a2[8096] | 0)) {
            YA(11120);
            b3 = 8096;
            c2[b3 >> 2] = 1;
            c2[b3 + 4 >> 2] = 0;
          }
          return 11120;
        }
        function YA(a3) {
          a3 = a3 | 0;
          fh(a3, ZA() | 0, 1);
          return;
        }
        function ZA() {
          return 1948;
        }
        function _A() {
          $A();
          return;
        }
        function $A() {
          var b3 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0, p4 = 0, q3 = 0, r3 = 0, s3 = 0, t3 = 0;
          s3 = l3;
          l3 = l3 + 16 | 0;
          o3 = s3 + 4 | 0;
          p4 = s3;
          Ea(65536, 10804, c2[2702] | 0, 10812);
          f4 = Wv() | 0;
          e4 = c2[f4 >> 2] | 0;
          b3 = c2[e4 >> 2] | 0;
          if (b3 | 0) {
            g3 = c2[f4 + 8 >> 2] | 0;
            f4 = c2[f4 + 4 >> 2] | 0;
            while (1) {
              Ma(b3 | 0, d3[f4 >> 0] | 0 | 0, a2[g3 >> 0] | 0);
              e4 = e4 + 4 | 0;
              b3 = c2[e4 >> 2] | 0;
              if (!b3)
                break;
              else {
                g3 = g3 + 1 | 0;
                f4 = f4 + 1 | 0;
              }
            }
          }
          b3 = Yv() | 0;
          e4 = c2[b3 >> 2] | 0;
          if (e4 | 0)
            do {
              Na(e4 | 0, c2[b3 + 4 >> 2] | 0);
              b3 = b3 + 8 | 0;
              e4 = c2[b3 >> 2] | 0;
            } while ((e4 | 0) != 0);
          Na(aB() | 0, 5167);
          n3 = Iv() | 0;
          b3 = c2[n3 >> 2] | 0;
          a:
            do
              if (b3 | 0) {
                do {
                  bB(c2[b3 + 4 >> 2] | 0);
                  b3 = c2[b3 >> 2] | 0;
                } while ((b3 | 0) != 0);
                b3 = c2[n3 >> 2] | 0;
                if (b3 | 0) {
                  m4 = n3;
                  do {
                    while (1) {
                      h3 = b3;
                      b3 = c2[b3 >> 2] | 0;
                      h3 = c2[h3 + 4 >> 2] | 0;
                      if (!(cB(h3) | 0))
                        break;
                      c2[p4 >> 2] = m4;
                      c2[o3 >> 2] = c2[p4 >> 2];
                      dB(n3, o3) | 0;
                      if (!b3)
                        break a;
                    }
                    eB(h3);
                    m4 = c2[m4 >> 2] | 0;
                    e4 = fB(h3) | 0;
                    i4 = Va() | 0;
                    j4 = l3;
                    l3 = l3 + ((1 * (e4 << 2) | 0) + 15 & -16) | 0;
                    k4 = l3;
                    l3 = l3 + ((1 * (e4 << 2) | 0) + 15 & -16) | 0;
                    e4 = c2[(Zw(h3) | 0) >> 2] | 0;
                    if (e4 | 0) {
                      f4 = j4;
                      g3 = k4;
                      while (1) {
                        c2[f4 >> 2] = c2[(Xw(c2[e4 + 4 >> 2] | 0) | 0) >> 2];
                        c2[g3 >> 2] = c2[e4 + 8 >> 2];
                        e4 = c2[e4 >> 2] | 0;
                        if (!e4)
                          break;
                        else {
                          f4 = f4 + 4 | 0;
                          g3 = g3 + 4 | 0;
                        }
                      }
                    }
                    t3 = Xw(h3) | 0;
                    e4 = gB(h3) | 0;
                    f4 = fB(h3) | 0;
                    g3 = hB(h3) | 0;
                    Ra(t3 | 0, e4 | 0, j4 | 0, k4 | 0, f4 | 0, g3 | 0, Tv(h3) | 0);
                    Ga(i4 | 0);
                  } while ((b3 | 0) != 0);
                }
              }
            while (0);
          b3 = c2[(Vv() | 0) >> 2] | 0;
          if (b3 | 0)
            do {
              t3 = b3 + 4 | 0;
              n3 = aw(t3) | 0;
              h3 = fw(n3) | 0;
              i4 = bw(n3) | 0;
              j4 = (cw(n3) | 0) + 1 | 0;
              k4 = iB(n3) | 0;
              m4 = jB(t3) | 0;
              n3 = si(n3) | 0;
              o3 = hw(t3) | 0;
              p4 = kB(t3) | 0;
              Pa(0, h3 | 0, i4 | 0, j4 | 0, k4 | 0, m4 | 0, n3 | 0, o3 | 0, p4 | 0, lB(t3) | 0);
              b3 = c2[b3 >> 2] | 0;
            } while ((b3 | 0) != 0);
          b3 = c2[(Iv() | 0) >> 2] | 0;
          b:
            do
              if (b3 | 0) {
                c:
                  while (1) {
                    e4 = c2[b3 + 4 >> 2] | 0;
                    if (e4 | 0 ? (q3 = c2[(Xw(e4) | 0) >> 2] | 0, r3 = c2[(ax(e4) | 0) >> 2] | 0, r3 | 0) : 0) {
                      f4 = r3;
                      do {
                        e4 = f4 + 4 | 0;
                        g3 = aw(e4) | 0;
                        d:
                          do
                            if (g3 | 0)
                              switch (si(g3) | 0) {
                                case 0:
                                  break c;
                                case 4:
                                case 3:
                                case 2: {
                                  k4 = fw(g3) | 0;
                                  m4 = bw(g3) | 0;
                                  n3 = (cw(g3) | 0) + 1 | 0;
                                  o3 = iB(g3) | 0;
                                  p4 = si(g3) | 0;
                                  t3 = hw(e4) | 0;
                                  Pa(q3 | 0, k4 | 0, m4 | 0, n3 | 0, o3 | 0, 0, p4 | 0, t3 | 0, kB(e4) | 0, lB(e4) | 0);
                                  break d;
                                }
                                case 1: {
                                  j4 = fw(g3) | 0;
                                  k4 = bw(g3) | 0;
                                  m4 = (cw(g3) | 0) + 1 | 0;
                                  n3 = iB(g3) | 0;
                                  o3 = jB(e4) | 0;
                                  p4 = si(g3) | 0;
                                  t3 = hw(e4) | 0;
                                  Pa(q3 | 0, j4 | 0, k4 | 0, m4 | 0, n3 | 0, o3 | 0, p4 | 0, t3 | 0, kB(e4) | 0, lB(e4) | 0);
                                  break d;
                                }
                                case 5: {
                                  n3 = fw(g3) | 0;
                                  o3 = bw(g3) | 0;
                                  p4 = (cw(g3) | 0) + 1 | 0;
                                  t3 = iB(g3) | 0;
                                  Pa(q3 | 0, n3 | 0, o3 | 0, p4 | 0, t3 | 0, mB(g3) | 0, si(g3) | 0, 0, 0, 0);
                                  break d;
                                }
                                default:
                                  break d;
                              }
                          while (0);
                        f4 = c2[f4 >> 2] | 0;
                      } while ((f4 | 0) != 0);
                    }
                    b3 = c2[b3 >> 2] | 0;
                    if (!b3)
                      break b;
                  }
                Ta();
              }
            while (0);
          Sa();
          l3 = s3;
          return;
        }
        function aB() {
          return 11703;
        }
        function bB(b3) {
          b3 = b3 | 0;
          a2[b3 + 40 >> 0] = 0;
          return;
        }
        function cB(b3) {
          b3 = b3 | 0;
          return (a2[b3 + 40 >> 0] | 0) != 0 | 0;
        }
        function dB(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          b3 = nB(b3) | 0;
          a3 = c2[b3 >> 2] | 0;
          c2[b3 >> 2] = c2[a3 >> 2];
          sC(a3);
          return c2[b3 >> 2] | 0;
        }
        function eB(b3) {
          b3 = b3 | 0;
          a2[b3 + 40 >> 0] = 1;
          return;
        }
        function fB(a3) {
          a3 = a3 | 0;
          return c2[a3 + 20 >> 2] | 0;
        }
        function gB(a3) {
          a3 = a3 | 0;
          return c2[a3 + 8 >> 2] | 0;
        }
        function hB(a3) {
          a3 = a3 | 0;
          return c2[a3 + 32 >> 2] | 0;
        }
        function iB(a3) {
          a3 = a3 | 0;
          return c2[a3 + 4 >> 2] | 0;
        }
        function jB(a3) {
          a3 = a3 | 0;
          return c2[a3 + 4 >> 2] | 0;
        }
        function kB(a3) {
          a3 = a3 | 0;
          return c2[a3 + 8 >> 2] | 0;
        }
        function lB(a3) {
          a3 = a3 | 0;
          return c2[a3 + 16 >> 2] | 0;
        }
        function mB(a3) {
          a3 = a3 | 0;
          return c2[a3 + 20 >> 2] | 0;
        }
        function nB(a3) {
          a3 = a3 | 0;
          return c2[a3 >> 2] | 0;
        }
        function oB(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0, p4 = 0, q3 = 0, r3 = 0, s3 = 0, t3 = 0, u4 = 0, v4 = 0, w3 = 0, x4 = 0;
          x4 = l3;
          l3 = l3 + 16 | 0;
          o3 = x4;
          do
            if (a3 >>> 0 < 245) {
              k4 = a3 >>> 0 < 11 ? 16 : a3 + 11 & -8;
              a3 = k4 >>> 3;
              n3 = c2[2783] | 0;
              d4 = n3 >>> a3;
              if (d4 & 3 | 0) {
                b3 = (d4 & 1 ^ 1) + a3 | 0;
                a3 = 11172 + (b3 << 1 << 2) | 0;
                d4 = a3 + 8 | 0;
                e4 = c2[d4 >> 2] | 0;
                f4 = e4 + 8 | 0;
                g3 = c2[f4 >> 2] | 0;
                if ((a3 | 0) == (g3 | 0))
                  c2[2783] = n3 & ~(1 << b3);
                else {
                  c2[g3 + 12 >> 2] = a3;
                  c2[d4 >> 2] = g3;
                }
                w3 = b3 << 3;
                c2[e4 + 4 >> 2] = w3 | 3;
                w3 = e4 + w3 + 4 | 0;
                c2[w3 >> 2] = c2[w3 >> 2] | 1;
                w3 = f4;
                l3 = x4;
                return w3 | 0;
              }
              m4 = c2[2785] | 0;
              if (k4 >>> 0 > m4 >>> 0) {
                if (d4 | 0) {
                  b3 = 2 << a3;
                  b3 = d4 << a3 & (b3 | 0 - b3);
                  b3 = (b3 & 0 - b3) + -1 | 0;
                  h3 = b3 >>> 12 & 16;
                  b3 = b3 >>> h3;
                  d4 = b3 >>> 5 & 8;
                  b3 = b3 >>> d4;
                  f4 = b3 >>> 2 & 4;
                  b3 = b3 >>> f4;
                  a3 = b3 >>> 1 & 2;
                  b3 = b3 >>> a3;
                  e4 = b3 >>> 1 & 1;
                  e4 = (d4 | h3 | f4 | a3 | e4) + (b3 >>> e4) | 0;
                  b3 = 11172 + (e4 << 1 << 2) | 0;
                  a3 = b3 + 8 | 0;
                  f4 = c2[a3 >> 2] | 0;
                  h3 = f4 + 8 | 0;
                  d4 = c2[h3 >> 2] | 0;
                  if ((b3 | 0) == (d4 | 0)) {
                    a3 = n3 & ~(1 << e4);
                    c2[2783] = a3;
                  } else {
                    c2[d4 + 12 >> 2] = b3;
                    c2[a3 >> 2] = d4;
                    a3 = n3;
                  }
                  g3 = (e4 << 3) - k4 | 0;
                  c2[f4 + 4 >> 2] = k4 | 3;
                  e4 = f4 + k4 | 0;
                  c2[e4 + 4 >> 2] = g3 | 1;
                  c2[e4 + g3 >> 2] = g3;
                  if (m4 | 0) {
                    f4 = c2[2788] | 0;
                    b3 = m4 >>> 3;
                    d4 = 11172 + (b3 << 1 << 2) | 0;
                    b3 = 1 << b3;
                    if (!(a3 & b3)) {
                      c2[2783] = a3 | b3;
                      b3 = d4;
                      a3 = d4 + 8 | 0;
                    } else {
                      a3 = d4 + 8 | 0;
                      b3 = c2[a3 >> 2] | 0;
                    }
                    c2[a3 >> 2] = f4;
                    c2[b3 + 12 >> 2] = f4;
                    c2[f4 + 8 >> 2] = b3;
                    c2[f4 + 12 >> 2] = d4;
                  }
                  c2[2785] = g3;
                  c2[2788] = e4;
                  w3 = h3;
                  l3 = x4;
                  return w3 | 0;
                }
                i4 = c2[2784] | 0;
                if (i4) {
                  d4 = (i4 & 0 - i4) + -1 | 0;
                  h3 = d4 >>> 12 & 16;
                  d4 = d4 >>> h3;
                  g3 = d4 >>> 5 & 8;
                  d4 = d4 >>> g3;
                  j4 = d4 >>> 2 & 4;
                  d4 = d4 >>> j4;
                  e4 = d4 >>> 1 & 2;
                  d4 = d4 >>> e4;
                  a3 = d4 >>> 1 & 1;
                  a3 = c2[11436 + ((g3 | h3 | j4 | e4 | a3) + (d4 >>> a3) << 2) >> 2] | 0;
                  d4 = (c2[a3 + 4 >> 2] & -8) - k4 | 0;
                  e4 = c2[a3 + 16 + (((c2[a3 + 16 >> 2] | 0) == 0 & 1) << 2) >> 2] | 0;
                  if (!e4) {
                    j4 = a3;
                    g3 = d4;
                  } else {
                    do {
                      h3 = (c2[e4 + 4 >> 2] & -8) - k4 | 0;
                      j4 = h3 >>> 0 < d4 >>> 0;
                      d4 = j4 ? h3 : d4;
                      a3 = j4 ? e4 : a3;
                      e4 = c2[e4 + 16 + (((c2[e4 + 16 >> 2] | 0) == 0 & 1) << 2) >> 2] | 0;
                    } while ((e4 | 0) != 0);
                    j4 = a3;
                    g3 = d4;
                  }
                  h3 = j4 + k4 | 0;
                  if (j4 >>> 0 < h3 >>> 0) {
                    f4 = c2[j4 + 24 >> 2] | 0;
                    b3 = c2[j4 + 12 >> 2] | 0;
                    do
                      if ((b3 | 0) == (j4 | 0)) {
                        a3 = j4 + 20 | 0;
                        b3 = c2[a3 >> 2] | 0;
                        if (!b3) {
                          a3 = j4 + 16 | 0;
                          b3 = c2[a3 >> 2] | 0;
                          if (!b3) {
                            d4 = 0;
                            break;
                          }
                        }
                        while (1) {
                          d4 = b3 + 20 | 0;
                          e4 = c2[d4 >> 2] | 0;
                          if (e4 | 0) {
                            b3 = e4;
                            a3 = d4;
                            continue;
                          }
                          d4 = b3 + 16 | 0;
                          e4 = c2[d4 >> 2] | 0;
                          if (!e4)
                            break;
                          else {
                            b3 = e4;
                            a3 = d4;
                          }
                        }
                        c2[a3 >> 2] = 0;
                        d4 = b3;
                      } else {
                        d4 = c2[j4 + 8 >> 2] | 0;
                        c2[d4 + 12 >> 2] = b3;
                        c2[b3 + 8 >> 2] = d4;
                        d4 = b3;
                      }
                    while (0);
                    do
                      if (f4 | 0) {
                        b3 = c2[j4 + 28 >> 2] | 0;
                        a3 = 11436 + (b3 << 2) | 0;
                        if ((j4 | 0) == (c2[a3 >> 2] | 0)) {
                          c2[a3 >> 2] = d4;
                          if (!d4) {
                            c2[2784] = i4 & ~(1 << b3);
                            break;
                          }
                        } else {
                          c2[f4 + 16 + (((c2[f4 + 16 >> 2] | 0) != (j4 | 0) & 1) << 2) >> 2] = d4;
                          if (!d4)
                            break;
                        }
                        c2[d4 + 24 >> 2] = f4;
                        b3 = c2[j4 + 16 >> 2] | 0;
                        if (b3 | 0) {
                          c2[d4 + 16 >> 2] = b3;
                          c2[b3 + 24 >> 2] = d4;
                        }
                        b3 = c2[j4 + 20 >> 2] | 0;
                        if (b3 | 0) {
                          c2[d4 + 20 >> 2] = b3;
                          c2[b3 + 24 >> 2] = d4;
                        }
                      }
                    while (0);
                    if (g3 >>> 0 < 16) {
                      w3 = g3 + k4 | 0;
                      c2[j4 + 4 >> 2] = w3 | 3;
                      w3 = j4 + w3 + 4 | 0;
                      c2[w3 >> 2] = c2[w3 >> 2] | 1;
                    } else {
                      c2[j4 + 4 >> 2] = k4 | 3;
                      c2[h3 + 4 >> 2] = g3 | 1;
                      c2[h3 + g3 >> 2] = g3;
                      if (m4 | 0) {
                        e4 = c2[2788] | 0;
                        b3 = m4 >>> 3;
                        d4 = 11172 + (b3 << 1 << 2) | 0;
                        b3 = 1 << b3;
                        if (!(n3 & b3)) {
                          c2[2783] = n3 | b3;
                          b3 = d4;
                          a3 = d4 + 8 | 0;
                        } else {
                          a3 = d4 + 8 | 0;
                          b3 = c2[a3 >> 2] | 0;
                        }
                        c2[a3 >> 2] = e4;
                        c2[b3 + 12 >> 2] = e4;
                        c2[e4 + 8 >> 2] = b3;
                        c2[e4 + 12 >> 2] = d4;
                      }
                      c2[2785] = g3;
                      c2[2788] = h3;
                    }
                    w3 = j4 + 8 | 0;
                    l3 = x4;
                    return w3 | 0;
                  } else
                    n3 = k4;
                } else
                  n3 = k4;
              } else
                n3 = k4;
            } else if (a3 >>> 0 <= 4294967231) {
              a3 = a3 + 11 | 0;
              k4 = a3 & -8;
              j4 = c2[2784] | 0;
              if (j4) {
                e4 = 0 - k4 | 0;
                a3 = a3 >>> 8;
                if (a3) {
                  if (k4 >>> 0 > 16777215)
                    i4 = 31;
                  else {
                    n3 = (a3 + 1048320 | 0) >>> 16 & 8;
                    v4 = a3 << n3;
                    m4 = (v4 + 520192 | 0) >>> 16 & 4;
                    v4 = v4 << m4;
                    i4 = (v4 + 245760 | 0) >>> 16 & 2;
                    i4 = 14 - (m4 | n3 | i4) + (v4 << i4 >>> 15) | 0;
                    i4 = k4 >>> (i4 + 7 | 0) & 1 | i4 << 1;
                  }
                } else
                  i4 = 0;
                d4 = c2[11436 + (i4 << 2) >> 2] | 0;
                a:
                  do
                    if (!d4) {
                      d4 = 0;
                      a3 = 0;
                      v4 = 57;
                    } else {
                      a3 = 0;
                      h3 = k4 << ((i4 | 0) == 31 ? 0 : 25 - (i4 >>> 1) | 0);
                      g3 = 0;
                      while (1) {
                        f4 = (c2[d4 + 4 >> 2] & -8) - k4 | 0;
                        if (f4 >>> 0 < e4 >>> 0)
                          if (!f4) {
                            a3 = d4;
                            e4 = 0;
                            f4 = d4;
                            v4 = 61;
                            break a;
                          } else {
                            a3 = d4;
                            e4 = f4;
                          }
                        f4 = c2[d4 + 20 >> 2] | 0;
                        d4 = c2[d4 + 16 + (h3 >>> 31 << 2) >> 2] | 0;
                        g3 = (f4 | 0) == 0 | (f4 | 0) == (d4 | 0) ? g3 : f4;
                        f4 = (d4 | 0) == 0;
                        if (f4) {
                          d4 = g3;
                          v4 = 57;
                          break;
                        } else
                          h3 = h3 << ((f4 ^ 1) & 1);
                      }
                    }
                  while (0);
                if ((v4 | 0) == 57) {
                  if ((d4 | 0) == 0 & (a3 | 0) == 0) {
                    a3 = 2 << i4;
                    a3 = j4 & (a3 | 0 - a3);
                    if (!a3) {
                      n3 = k4;
                      break;
                    }
                    n3 = (a3 & 0 - a3) + -1 | 0;
                    h3 = n3 >>> 12 & 16;
                    n3 = n3 >>> h3;
                    g3 = n3 >>> 5 & 8;
                    n3 = n3 >>> g3;
                    i4 = n3 >>> 2 & 4;
                    n3 = n3 >>> i4;
                    m4 = n3 >>> 1 & 2;
                    n3 = n3 >>> m4;
                    d4 = n3 >>> 1 & 1;
                    a3 = 0;
                    d4 = c2[11436 + ((g3 | h3 | i4 | m4 | d4) + (n3 >>> d4) << 2) >> 2] | 0;
                  }
                  if (!d4) {
                    i4 = a3;
                    h3 = e4;
                  } else {
                    f4 = d4;
                    v4 = 61;
                  }
                }
                if ((v4 | 0) == 61)
                  while (1) {
                    v4 = 0;
                    d4 = (c2[f4 + 4 >> 2] & -8) - k4 | 0;
                    n3 = d4 >>> 0 < e4 >>> 0;
                    d4 = n3 ? d4 : e4;
                    a3 = n3 ? f4 : a3;
                    f4 = c2[f4 + 16 + (((c2[f4 + 16 >> 2] | 0) == 0 & 1) << 2) >> 2] | 0;
                    if (!f4) {
                      i4 = a3;
                      h3 = d4;
                      break;
                    } else {
                      e4 = d4;
                      v4 = 61;
                    }
                  }
                if ((i4 | 0) != 0 ? h3 >>> 0 < ((c2[2785] | 0) - k4 | 0) >>> 0 : 0) {
                  g3 = i4 + k4 | 0;
                  if (i4 >>> 0 >= g3 >>> 0) {
                    w3 = 0;
                    l3 = x4;
                    return w3 | 0;
                  }
                  f4 = c2[i4 + 24 >> 2] | 0;
                  b3 = c2[i4 + 12 >> 2] | 0;
                  do
                    if ((b3 | 0) == (i4 | 0)) {
                      a3 = i4 + 20 | 0;
                      b3 = c2[a3 >> 2] | 0;
                      if (!b3) {
                        a3 = i4 + 16 | 0;
                        b3 = c2[a3 >> 2] | 0;
                        if (!b3) {
                          b3 = 0;
                          break;
                        }
                      }
                      while (1) {
                        d4 = b3 + 20 | 0;
                        e4 = c2[d4 >> 2] | 0;
                        if (e4 | 0) {
                          b3 = e4;
                          a3 = d4;
                          continue;
                        }
                        d4 = b3 + 16 | 0;
                        e4 = c2[d4 >> 2] | 0;
                        if (!e4)
                          break;
                        else {
                          b3 = e4;
                          a3 = d4;
                        }
                      }
                      c2[a3 >> 2] = 0;
                    } else {
                      w3 = c2[i4 + 8 >> 2] | 0;
                      c2[w3 + 12 >> 2] = b3;
                      c2[b3 + 8 >> 2] = w3;
                    }
                  while (0);
                  do
                    if (f4) {
                      a3 = c2[i4 + 28 >> 2] | 0;
                      d4 = 11436 + (a3 << 2) | 0;
                      if ((i4 | 0) == (c2[d4 >> 2] | 0)) {
                        c2[d4 >> 2] = b3;
                        if (!b3) {
                          e4 = j4 & ~(1 << a3);
                          c2[2784] = e4;
                          break;
                        }
                      } else {
                        c2[f4 + 16 + (((c2[f4 + 16 >> 2] | 0) != (i4 | 0) & 1) << 2) >> 2] = b3;
                        if (!b3) {
                          e4 = j4;
                          break;
                        }
                      }
                      c2[b3 + 24 >> 2] = f4;
                      a3 = c2[i4 + 16 >> 2] | 0;
                      if (a3 | 0) {
                        c2[b3 + 16 >> 2] = a3;
                        c2[a3 + 24 >> 2] = b3;
                      }
                      a3 = c2[i4 + 20 >> 2] | 0;
                      if (a3) {
                        c2[b3 + 20 >> 2] = a3;
                        c2[a3 + 24 >> 2] = b3;
                        e4 = j4;
                      } else
                        e4 = j4;
                    } else
                      e4 = j4;
                  while (0);
                  do
                    if (h3 >>> 0 >= 16) {
                      c2[i4 + 4 >> 2] = k4 | 3;
                      c2[g3 + 4 >> 2] = h3 | 1;
                      c2[g3 + h3 >> 2] = h3;
                      b3 = h3 >>> 3;
                      if (h3 >>> 0 < 256) {
                        d4 = 11172 + (b3 << 1 << 2) | 0;
                        a3 = c2[2783] | 0;
                        b3 = 1 << b3;
                        if (!(a3 & b3)) {
                          c2[2783] = a3 | b3;
                          b3 = d4;
                          a3 = d4 + 8 | 0;
                        } else {
                          a3 = d4 + 8 | 0;
                          b3 = c2[a3 >> 2] | 0;
                        }
                        c2[a3 >> 2] = g3;
                        c2[b3 + 12 >> 2] = g3;
                        c2[g3 + 8 >> 2] = b3;
                        c2[g3 + 12 >> 2] = d4;
                        break;
                      }
                      b3 = h3 >>> 8;
                      if (b3) {
                        if (h3 >>> 0 > 16777215)
                          b3 = 31;
                        else {
                          v4 = (b3 + 1048320 | 0) >>> 16 & 8;
                          w3 = b3 << v4;
                          u4 = (w3 + 520192 | 0) >>> 16 & 4;
                          w3 = w3 << u4;
                          b3 = (w3 + 245760 | 0) >>> 16 & 2;
                          b3 = 14 - (u4 | v4 | b3) + (w3 << b3 >>> 15) | 0;
                          b3 = h3 >>> (b3 + 7 | 0) & 1 | b3 << 1;
                        }
                      } else
                        b3 = 0;
                      d4 = 11436 + (b3 << 2) | 0;
                      c2[g3 + 28 >> 2] = b3;
                      a3 = g3 + 16 | 0;
                      c2[a3 + 4 >> 2] = 0;
                      c2[a3 >> 2] = 0;
                      a3 = 1 << b3;
                      if (!(e4 & a3)) {
                        c2[2784] = e4 | a3;
                        c2[d4 >> 2] = g3;
                        c2[g3 + 24 >> 2] = d4;
                        c2[g3 + 12 >> 2] = g3;
                        c2[g3 + 8 >> 2] = g3;
                        break;
                      }
                      a3 = h3 << ((b3 | 0) == 31 ? 0 : 25 - (b3 >>> 1) | 0);
                      d4 = c2[d4 >> 2] | 0;
                      while (1) {
                        if ((c2[d4 + 4 >> 2] & -8 | 0) == (h3 | 0)) {
                          v4 = 97;
                          break;
                        }
                        e4 = d4 + 16 + (a3 >>> 31 << 2) | 0;
                        b3 = c2[e4 >> 2] | 0;
                        if (!b3) {
                          v4 = 96;
                          break;
                        } else {
                          a3 = a3 << 1;
                          d4 = b3;
                        }
                      }
                      if ((v4 | 0) == 96) {
                        c2[e4 >> 2] = g3;
                        c2[g3 + 24 >> 2] = d4;
                        c2[g3 + 12 >> 2] = g3;
                        c2[g3 + 8 >> 2] = g3;
                        break;
                      } else if ((v4 | 0) == 97) {
                        v4 = d4 + 8 | 0;
                        w3 = c2[v4 >> 2] | 0;
                        c2[w3 + 12 >> 2] = g3;
                        c2[v4 >> 2] = g3;
                        c2[g3 + 8 >> 2] = w3;
                        c2[g3 + 12 >> 2] = d4;
                        c2[g3 + 24 >> 2] = 0;
                        break;
                      }
                    } else {
                      w3 = h3 + k4 | 0;
                      c2[i4 + 4 >> 2] = w3 | 3;
                      w3 = i4 + w3 + 4 | 0;
                      c2[w3 >> 2] = c2[w3 >> 2] | 1;
                    }
                  while (0);
                  w3 = i4 + 8 | 0;
                  l3 = x4;
                  return w3 | 0;
                } else
                  n3 = k4;
              } else
                n3 = k4;
            } else
              n3 = -1;
          while (0);
          d4 = c2[2785] | 0;
          if (d4 >>> 0 >= n3 >>> 0) {
            b3 = d4 - n3 | 0;
            a3 = c2[2788] | 0;
            if (b3 >>> 0 > 15) {
              w3 = a3 + n3 | 0;
              c2[2788] = w3;
              c2[2785] = b3;
              c2[w3 + 4 >> 2] = b3 | 1;
              c2[w3 + b3 >> 2] = b3;
              c2[a3 + 4 >> 2] = n3 | 3;
            } else {
              c2[2785] = 0;
              c2[2788] = 0;
              c2[a3 + 4 >> 2] = d4 | 3;
              w3 = a3 + d4 + 4 | 0;
              c2[w3 >> 2] = c2[w3 >> 2] | 1;
            }
            w3 = a3 + 8 | 0;
            l3 = x4;
            return w3 | 0;
          }
          h3 = c2[2786] | 0;
          if (h3 >>> 0 > n3 >>> 0) {
            u4 = h3 - n3 | 0;
            c2[2786] = u4;
            w3 = c2[2789] | 0;
            v4 = w3 + n3 | 0;
            c2[2789] = v4;
            c2[v4 + 4 >> 2] = u4 | 1;
            c2[w3 + 4 >> 2] = n3 | 3;
            w3 = w3 + 8 | 0;
            l3 = x4;
            return w3 | 0;
          }
          if (!(c2[2901] | 0)) {
            c2[2903] = 4096;
            c2[2902] = 4096;
            c2[2904] = -1;
            c2[2905] = -1;
            c2[2906] = 0;
            c2[2894] = 0;
            a3 = o3 & -16 ^ 1431655768;
            c2[o3 >> 2] = a3;
            c2[2901] = a3;
            a3 = 4096;
          } else
            a3 = c2[2903] | 0;
          i4 = n3 + 48 | 0;
          j4 = n3 + 47 | 0;
          g3 = a3 + j4 | 0;
          f4 = 0 - a3 | 0;
          k4 = g3 & f4;
          if (k4 >>> 0 <= n3 >>> 0) {
            w3 = 0;
            l3 = x4;
            return w3 | 0;
          }
          a3 = c2[2893] | 0;
          if (a3 | 0 ? (m4 = c2[2891] | 0, o3 = m4 + k4 | 0, o3 >>> 0 <= m4 >>> 0 | o3 >>> 0 > a3 >>> 0) : 0) {
            w3 = 0;
            l3 = x4;
            return w3 | 0;
          }
          b:
            do
              if (!(c2[2894] & 4)) {
                d4 = c2[2789] | 0;
                c:
                  do
                    if (d4) {
                      e4 = 11580;
                      while (1) {
                        a3 = c2[e4 >> 2] | 0;
                        if (a3 >>> 0 <= d4 >>> 0 ? (r3 = e4 + 4 | 0, (a3 + (c2[r3 >> 2] | 0) | 0) >>> 0 > d4 >>> 0) : 0)
                          break;
                        a3 = c2[e4 + 8 >> 2] | 0;
                        if (!a3) {
                          v4 = 118;
                          break c;
                        } else
                          e4 = a3;
                      }
                      b3 = g3 - h3 & f4;
                      if (b3 >>> 0 < 2147483647) {
                        a3 = FC(b3 | 0) | 0;
                        if ((a3 | 0) == ((c2[e4 >> 2] | 0) + (c2[r3 >> 2] | 0) | 0)) {
                          if ((a3 | 0) != (-1 | 0)) {
                            h3 = b3;
                            g3 = a3;
                            v4 = 135;
                            break b;
                          }
                        } else {
                          e4 = a3;
                          v4 = 126;
                        }
                      } else
                        b3 = 0;
                    } else
                      v4 = 118;
                  while (0);
                do
                  if ((v4 | 0) == 118) {
                    d4 = FC(0) | 0;
                    if ((d4 | 0) != (-1 | 0) ? (b3 = d4, p4 = c2[2902] | 0, q3 = p4 + -1 | 0, b3 = ((q3 & b3 | 0) == 0 ? 0 : (q3 + b3 & 0 - p4) - b3 | 0) + k4 | 0, p4 = c2[2891] | 0, q3 = b3 + p4 | 0, b3 >>> 0 > n3 >>> 0 & b3 >>> 0 < 2147483647) : 0) {
                      r3 = c2[2893] | 0;
                      if (r3 | 0 ? q3 >>> 0 <= p4 >>> 0 | q3 >>> 0 > r3 >>> 0 : 0) {
                        b3 = 0;
                        break;
                      }
                      a3 = FC(b3 | 0) | 0;
                      if ((a3 | 0) == (d4 | 0)) {
                        h3 = b3;
                        g3 = d4;
                        v4 = 135;
                        break b;
                      } else {
                        e4 = a3;
                        v4 = 126;
                      }
                    } else
                      b3 = 0;
                  }
                while (0);
                do
                  if ((v4 | 0) == 126) {
                    d4 = 0 - b3 | 0;
                    if (!(i4 >>> 0 > b3 >>> 0 & (b3 >>> 0 < 2147483647 & (e4 | 0) != (-1 | 0))))
                      if ((e4 | 0) == (-1 | 0)) {
                        b3 = 0;
                        break;
                      } else {
                        h3 = b3;
                        g3 = e4;
                        v4 = 135;
                        break b;
                      }
                    a3 = c2[2903] | 0;
                    a3 = j4 - b3 + a3 & 0 - a3;
                    if (a3 >>> 0 >= 2147483647) {
                      h3 = b3;
                      g3 = e4;
                      v4 = 135;
                      break b;
                    }
                    if ((FC(a3 | 0) | 0) == (-1 | 0)) {
                      FC(d4 | 0) | 0;
                      b3 = 0;
                      break;
                    } else {
                      h3 = a3 + b3 | 0;
                      g3 = e4;
                      v4 = 135;
                      break b;
                    }
                  }
                while (0);
                c2[2894] = c2[2894] | 4;
                v4 = 133;
              } else {
                b3 = 0;
                v4 = 133;
              }
            while (0);
          if (((v4 | 0) == 133 ? k4 >>> 0 < 2147483647 : 0) ? (u4 = FC(k4 | 0) | 0, r3 = FC(0) | 0, s3 = r3 - u4 | 0, t3 = s3 >>> 0 > (n3 + 40 | 0) >>> 0, !((u4 | 0) == (-1 | 0) | t3 ^ 1 | u4 >>> 0 < r3 >>> 0 & ((u4 | 0) != (-1 | 0) & (r3 | 0) != (-1 | 0)) ^ 1)) : 0) {
            h3 = t3 ? s3 : b3;
            g3 = u4;
            v4 = 135;
          }
          if ((v4 | 0) == 135) {
            b3 = (c2[2891] | 0) + h3 | 0;
            c2[2891] = b3;
            if (b3 >>> 0 > (c2[2892] | 0) >>> 0)
              c2[2892] = b3;
            j4 = c2[2789] | 0;
            do
              if (j4) {
                b3 = 11580;
                while (1) {
                  a3 = c2[b3 >> 2] | 0;
                  d4 = b3 + 4 | 0;
                  e4 = c2[d4 >> 2] | 0;
                  if ((g3 | 0) == (a3 + e4 | 0)) {
                    v4 = 145;
                    break;
                  }
                  f4 = c2[b3 + 8 >> 2] | 0;
                  if (!f4)
                    break;
                  else
                    b3 = f4;
                }
                if (((v4 | 0) == 145 ? (c2[b3 + 12 >> 2] & 8 | 0) == 0 : 0) ? j4 >>> 0 < g3 >>> 0 & j4 >>> 0 >= a3 >>> 0 : 0) {
                  c2[d4 >> 2] = e4 + h3;
                  w3 = j4 + 8 | 0;
                  w3 = (w3 & 7 | 0) == 0 ? 0 : 0 - w3 & 7;
                  v4 = j4 + w3 | 0;
                  w3 = (c2[2786] | 0) + (h3 - w3) | 0;
                  c2[2789] = v4;
                  c2[2786] = w3;
                  c2[v4 + 4 >> 2] = w3 | 1;
                  c2[v4 + w3 + 4 >> 2] = 40;
                  c2[2790] = c2[2905];
                  break;
                }
                if (g3 >>> 0 < (c2[2787] | 0) >>> 0)
                  c2[2787] = g3;
                d4 = g3 + h3 | 0;
                b3 = 11580;
                while (1) {
                  if ((c2[b3 >> 2] | 0) == (d4 | 0)) {
                    v4 = 153;
                    break;
                  }
                  a3 = c2[b3 + 8 >> 2] | 0;
                  if (!a3)
                    break;
                  else
                    b3 = a3;
                }
                if ((v4 | 0) == 153 ? (c2[b3 + 12 >> 2] & 8 | 0) == 0 : 0) {
                  c2[b3 >> 2] = g3;
                  m4 = b3 + 4 | 0;
                  c2[m4 >> 2] = (c2[m4 >> 2] | 0) + h3;
                  m4 = g3 + 8 | 0;
                  m4 = g3 + ((m4 & 7 | 0) == 0 ? 0 : 0 - m4 & 7) | 0;
                  b3 = d4 + 8 | 0;
                  b3 = d4 + ((b3 & 7 | 0) == 0 ? 0 : 0 - b3 & 7) | 0;
                  k4 = m4 + n3 | 0;
                  i4 = b3 - m4 - n3 | 0;
                  c2[m4 + 4 >> 2] = n3 | 3;
                  do
                    if ((b3 | 0) != (j4 | 0)) {
                      if ((b3 | 0) == (c2[2788] | 0)) {
                        w3 = (c2[2785] | 0) + i4 | 0;
                        c2[2785] = w3;
                        c2[2788] = k4;
                        c2[k4 + 4 >> 2] = w3 | 1;
                        c2[k4 + w3 >> 2] = w3;
                        break;
                      }
                      a3 = c2[b3 + 4 >> 2] | 0;
                      if ((a3 & 3 | 0) == 1) {
                        h3 = a3 & -8;
                        e4 = a3 >>> 3;
                        d:
                          do
                            if (a3 >>> 0 < 256) {
                              a3 = c2[b3 + 8 >> 2] | 0;
                              d4 = c2[b3 + 12 >> 2] | 0;
                              if ((d4 | 0) == (a3 | 0)) {
                                c2[2783] = c2[2783] & ~(1 << e4);
                                break;
                              } else {
                                c2[a3 + 12 >> 2] = d4;
                                c2[d4 + 8 >> 2] = a3;
                                break;
                              }
                            } else {
                              g3 = c2[b3 + 24 >> 2] | 0;
                              a3 = c2[b3 + 12 >> 2] | 0;
                              do
                                if ((a3 | 0) == (b3 | 0)) {
                                  e4 = b3 + 16 | 0;
                                  d4 = e4 + 4 | 0;
                                  a3 = c2[d4 >> 2] | 0;
                                  if (!a3) {
                                    a3 = c2[e4 >> 2] | 0;
                                    if (!a3) {
                                      a3 = 0;
                                      break;
                                    } else
                                      d4 = e4;
                                  }
                                  while (1) {
                                    e4 = a3 + 20 | 0;
                                    f4 = c2[e4 >> 2] | 0;
                                    if (f4 | 0) {
                                      a3 = f4;
                                      d4 = e4;
                                      continue;
                                    }
                                    e4 = a3 + 16 | 0;
                                    f4 = c2[e4 >> 2] | 0;
                                    if (!f4)
                                      break;
                                    else {
                                      a3 = f4;
                                      d4 = e4;
                                    }
                                  }
                                  c2[d4 >> 2] = 0;
                                } else {
                                  w3 = c2[b3 + 8 >> 2] | 0;
                                  c2[w3 + 12 >> 2] = a3;
                                  c2[a3 + 8 >> 2] = w3;
                                }
                              while (0);
                              if (!g3)
                                break;
                              d4 = c2[b3 + 28 >> 2] | 0;
                              e4 = 11436 + (d4 << 2) | 0;
                              do
                                if ((b3 | 0) != (c2[e4 >> 2] | 0)) {
                                  c2[g3 + 16 + (((c2[g3 + 16 >> 2] | 0) != (b3 | 0) & 1) << 2) >> 2] = a3;
                                  if (!a3)
                                    break d;
                                } else {
                                  c2[e4 >> 2] = a3;
                                  if (a3 | 0)
                                    break;
                                  c2[2784] = c2[2784] & ~(1 << d4);
                                  break d;
                                }
                              while (0);
                              c2[a3 + 24 >> 2] = g3;
                              d4 = b3 + 16 | 0;
                              e4 = c2[d4 >> 2] | 0;
                              if (e4 | 0) {
                                c2[a3 + 16 >> 2] = e4;
                                c2[e4 + 24 >> 2] = a3;
                              }
                              d4 = c2[d4 + 4 >> 2] | 0;
                              if (!d4)
                                break;
                              c2[a3 + 20 >> 2] = d4;
                              c2[d4 + 24 >> 2] = a3;
                            }
                          while (0);
                        b3 = b3 + h3 | 0;
                        f4 = h3 + i4 | 0;
                      } else
                        f4 = i4;
                      b3 = b3 + 4 | 0;
                      c2[b3 >> 2] = c2[b3 >> 2] & -2;
                      c2[k4 + 4 >> 2] = f4 | 1;
                      c2[k4 + f4 >> 2] = f4;
                      b3 = f4 >>> 3;
                      if (f4 >>> 0 < 256) {
                        d4 = 11172 + (b3 << 1 << 2) | 0;
                        a3 = c2[2783] | 0;
                        b3 = 1 << b3;
                        if (!(a3 & b3)) {
                          c2[2783] = a3 | b3;
                          b3 = d4;
                          a3 = d4 + 8 | 0;
                        } else {
                          a3 = d4 + 8 | 0;
                          b3 = c2[a3 >> 2] | 0;
                        }
                        c2[a3 >> 2] = k4;
                        c2[b3 + 12 >> 2] = k4;
                        c2[k4 + 8 >> 2] = b3;
                        c2[k4 + 12 >> 2] = d4;
                        break;
                      }
                      b3 = f4 >>> 8;
                      do
                        if (!b3)
                          b3 = 0;
                        else {
                          if (f4 >>> 0 > 16777215) {
                            b3 = 31;
                            break;
                          }
                          v4 = (b3 + 1048320 | 0) >>> 16 & 8;
                          w3 = b3 << v4;
                          u4 = (w3 + 520192 | 0) >>> 16 & 4;
                          w3 = w3 << u4;
                          b3 = (w3 + 245760 | 0) >>> 16 & 2;
                          b3 = 14 - (u4 | v4 | b3) + (w3 << b3 >>> 15) | 0;
                          b3 = f4 >>> (b3 + 7 | 0) & 1 | b3 << 1;
                        }
                      while (0);
                      e4 = 11436 + (b3 << 2) | 0;
                      c2[k4 + 28 >> 2] = b3;
                      a3 = k4 + 16 | 0;
                      c2[a3 + 4 >> 2] = 0;
                      c2[a3 >> 2] = 0;
                      a3 = c2[2784] | 0;
                      d4 = 1 << b3;
                      if (!(a3 & d4)) {
                        c2[2784] = a3 | d4;
                        c2[e4 >> 2] = k4;
                        c2[k4 + 24 >> 2] = e4;
                        c2[k4 + 12 >> 2] = k4;
                        c2[k4 + 8 >> 2] = k4;
                        break;
                      }
                      a3 = f4 << ((b3 | 0) == 31 ? 0 : 25 - (b3 >>> 1) | 0);
                      d4 = c2[e4 >> 2] | 0;
                      while (1) {
                        if ((c2[d4 + 4 >> 2] & -8 | 0) == (f4 | 0)) {
                          v4 = 194;
                          break;
                        }
                        e4 = d4 + 16 + (a3 >>> 31 << 2) | 0;
                        b3 = c2[e4 >> 2] | 0;
                        if (!b3) {
                          v4 = 193;
                          break;
                        } else {
                          a3 = a3 << 1;
                          d4 = b3;
                        }
                      }
                      if ((v4 | 0) == 193) {
                        c2[e4 >> 2] = k4;
                        c2[k4 + 24 >> 2] = d4;
                        c2[k4 + 12 >> 2] = k4;
                        c2[k4 + 8 >> 2] = k4;
                        break;
                      } else if ((v4 | 0) == 194) {
                        v4 = d4 + 8 | 0;
                        w3 = c2[v4 >> 2] | 0;
                        c2[w3 + 12 >> 2] = k4;
                        c2[v4 >> 2] = k4;
                        c2[k4 + 8 >> 2] = w3;
                        c2[k4 + 12 >> 2] = d4;
                        c2[k4 + 24 >> 2] = 0;
                        break;
                      }
                    } else {
                      w3 = (c2[2786] | 0) + i4 | 0;
                      c2[2786] = w3;
                      c2[2789] = k4;
                      c2[k4 + 4 >> 2] = w3 | 1;
                    }
                  while (0);
                  w3 = m4 + 8 | 0;
                  l3 = x4;
                  return w3 | 0;
                }
                b3 = 11580;
                while (1) {
                  a3 = c2[b3 >> 2] | 0;
                  if (a3 >>> 0 <= j4 >>> 0 ? (w3 = a3 + (c2[b3 + 4 >> 2] | 0) | 0, w3 >>> 0 > j4 >>> 0) : 0)
                    break;
                  b3 = c2[b3 + 8 >> 2] | 0;
                }
                f4 = w3 + -47 | 0;
                a3 = f4 + 8 | 0;
                a3 = f4 + ((a3 & 7 | 0) == 0 ? 0 : 0 - a3 & 7) | 0;
                f4 = j4 + 16 | 0;
                a3 = a3 >>> 0 < f4 >>> 0 ? j4 : a3;
                b3 = a3 + 8 | 0;
                d4 = g3 + 8 | 0;
                d4 = (d4 & 7 | 0) == 0 ? 0 : 0 - d4 & 7;
                v4 = g3 + d4 | 0;
                d4 = h3 + -40 - d4 | 0;
                c2[2789] = v4;
                c2[2786] = d4;
                c2[v4 + 4 >> 2] = d4 | 1;
                c2[v4 + d4 + 4 >> 2] = 40;
                c2[2790] = c2[2905];
                d4 = a3 + 4 | 0;
                c2[d4 >> 2] = 27;
                c2[b3 >> 2] = c2[2895];
                c2[b3 + 4 >> 2] = c2[2896];
                c2[b3 + 8 >> 2] = c2[2897];
                c2[b3 + 12 >> 2] = c2[2898];
                c2[2895] = g3;
                c2[2896] = h3;
                c2[2898] = 0;
                c2[2897] = b3;
                b3 = a3 + 24 | 0;
                do {
                  v4 = b3;
                  b3 = b3 + 4 | 0;
                  c2[b3 >> 2] = 7;
                } while ((v4 + 8 | 0) >>> 0 < w3 >>> 0);
                if ((a3 | 0) != (j4 | 0)) {
                  g3 = a3 - j4 | 0;
                  c2[d4 >> 2] = c2[d4 >> 2] & -2;
                  c2[j4 + 4 >> 2] = g3 | 1;
                  c2[a3 >> 2] = g3;
                  b3 = g3 >>> 3;
                  if (g3 >>> 0 < 256) {
                    d4 = 11172 + (b3 << 1 << 2) | 0;
                    a3 = c2[2783] | 0;
                    b3 = 1 << b3;
                    if (!(a3 & b3)) {
                      c2[2783] = a3 | b3;
                      b3 = d4;
                      a3 = d4 + 8 | 0;
                    } else {
                      a3 = d4 + 8 | 0;
                      b3 = c2[a3 >> 2] | 0;
                    }
                    c2[a3 >> 2] = j4;
                    c2[b3 + 12 >> 2] = j4;
                    c2[j4 + 8 >> 2] = b3;
                    c2[j4 + 12 >> 2] = d4;
                    break;
                  }
                  b3 = g3 >>> 8;
                  if (b3) {
                    if (g3 >>> 0 > 16777215)
                      d4 = 31;
                    else {
                      v4 = (b3 + 1048320 | 0) >>> 16 & 8;
                      w3 = b3 << v4;
                      u4 = (w3 + 520192 | 0) >>> 16 & 4;
                      w3 = w3 << u4;
                      d4 = (w3 + 245760 | 0) >>> 16 & 2;
                      d4 = 14 - (u4 | v4 | d4) + (w3 << d4 >>> 15) | 0;
                      d4 = g3 >>> (d4 + 7 | 0) & 1 | d4 << 1;
                    }
                  } else
                    d4 = 0;
                  e4 = 11436 + (d4 << 2) | 0;
                  c2[j4 + 28 >> 2] = d4;
                  c2[j4 + 20 >> 2] = 0;
                  c2[f4 >> 2] = 0;
                  b3 = c2[2784] | 0;
                  a3 = 1 << d4;
                  if (!(b3 & a3)) {
                    c2[2784] = b3 | a3;
                    c2[e4 >> 2] = j4;
                    c2[j4 + 24 >> 2] = e4;
                    c2[j4 + 12 >> 2] = j4;
                    c2[j4 + 8 >> 2] = j4;
                    break;
                  }
                  a3 = g3 << ((d4 | 0) == 31 ? 0 : 25 - (d4 >>> 1) | 0);
                  d4 = c2[e4 >> 2] | 0;
                  while (1) {
                    if ((c2[d4 + 4 >> 2] & -8 | 0) == (g3 | 0)) {
                      v4 = 216;
                      break;
                    }
                    e4 = d4 + 16 + (a3 >>> 31 << 2) | 0;
                    b3 = c2[e4 >> 2] | 0;
                    if (!b3) {
                      v4 = 215;
                      break;
                    } else {
                      a3 = a3 << 1;
                      d4 = b3;
                    }
                  }
                  if ((v4 | 0) == 215) {
                    c2[e4 >> 2] = j4;
                    c2[j4 + 24 >> 2] = d4;
                    c2[j4 + 12 >> 2] = j4;
                    c2[j4 + 8 >> 2] = j4;
                    break;
                  } else if ((v4 | 0) == 216) {
                    v4 = d4 + 8 | 0;
                    w3 = c2[v4 >> 2] | 0;
                    c2[w3 + 12 >> 2] = j4;
                    c2[v4 >> 2] = j4;
                    c2[j4 + 8 >> 2] = w3;
                    c2[j4 + 12 >> 2] = d4;
                    c2[j4 + 24 >> 2] = 0;
                    break;
                  }
                }
              } else {
                w3 = c2[2787] | 0;
                if ((w3 | 0) == 0 | g3 >>> 0 < w3 >>> 0)
                  c2[2787] = g3;
                c2[2895] = g3;
                c2[2896] = h3;
                c2[2898] = 0;
                c2[2792] = c2[2901];
                c2[2791] = -1;
                b3 = 0;
                do {
                  w3 = 11172 + (b3 << 1 << 2) | 0;
                  c2[w3 + 12 >> 2] = w3;
                  c2[w3 + 8 >> 2] = w3;
                  b3 = b3 + 1 | 0;
                } while ((b3 | 0) != 32);
                w3 = g3 + 8 | 0;
                w3 = (w3 & 7 | 0) == 0 ? 0 : 0 - w3 & 7;
                v4 = g3 + w3 | 0;
                w3 = h3 + -40 - w3 | 0;
                c2[2789] = v4;
                c2[2786] = w3;
                c2[v4 + 4 >> 2] = w3 | 1;
                c2[v4 + w3 + 4 >> 2] = 40;
                c2[2790] = c2[2905];
              }
            while (0);
            b3 = c2[2786] | 0;
            if (b3 >>> 0 > n3 >>> 0) {
              u4 = b3 - n3 | 0;
              c2[2786] = u4;
              w3 = c2[2789] | 0;
              v4 = w3 + n3 | 0;
              c2[2789] = v4;
              c2[v4 + 4 >> 2] = u4 | 1;
              c2[w3 + 4 >> 2] = n3 | 3;
              w3 = w3 + 8 | 0;
              l3 = x4;
              return w3 | 0;
            }
          }
          c2[(vB() | 0) >> 2] = 12;
          w3 = 0;
          l3 = x4;
          return w3 | 0;
        }
        function pB(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0, e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          if (!a3)
            return;
          d4 = a3 + -8 | 0;
          f4 = c2[2787] | 0;
          a3 = c2[a3 + -4 >> 2] | 0;
          b3 = a3 & -8;
          j4 = d4 + b3 | 0;
          do
            if (!(a3 & 1)) {
              e4 = c2[d4 >> 2] | 0;
              if (!(a3 & 3))
                return;
              h3 = d4 + (0 - e4) | 0;
              g3 = e4 + b3 | 0;
              if (h3 >>> 0 < f4 >>> 0)
                return;
              if ((h3 | 0) == (c2[2788] | 0)) {
                a3 = j4 + 4 | 0;
                b3 = c2[a3 >> 2] | 0;
                if ((b3 & 3 | 0) != 3) {
                  i4 = h3;
                  b3 = g3;
                  break;
                }
                c2[2785] = g3;
                c2[a3 >> 2] = b3 & -2;
                c2[h3 + 4 >> 2] = g3 | 1;
                c2[h3 + g3 >> 2] = g3;
                return;
              }
              d4 = e4 >>> 3;
              if (e4 >>> 0 < 256) {
                a3 = c2[h3 + 8 >> 2] | 0;
                b3 = c2[h3 + 12 >> 2] | 0;
                if ((b3 | 0) == (a3 | 0)) {
                  c2[2783] = c2[2783] & ~(1 << d4);
                  i4 = h3;
                  b3 = g3;
                  break;
                } else {
                  c2[a3 + 12 >> 2] = b3;
                  c2[b3 + 8 >> 2] = a3;
                  i4 = h3;
                  b3 = g3;
                  break;
                }
              }
              f4 = c2[h3 + 24 >> 2] | 0;
              a3 = c2[h3 + 12 >> 2] | 0;
              do
                if ((a3 | 0) == (h3 | 0)) {
                  d4 = h3 + 16 | 0;
                  b3 = d4 + 4 | 0;
                  a3 = c2[b3 >> 2] | 0;
                  if (!a3) {
                    a3 = c2[d4 >> 2] | 0;
                    if (!a3) {
                      a3 = 0;
                      break;
                    } else
                      b3 = d4;
                  }
                  while (1) {
                    d4 = a3 + 20 | 0;
                    e4 = c2[d4 >> 2] | 0;
                    if (e4 | 0) {
                      a3 = e4;
                      b3 = d4;
                      continue;
                    }
                    d4 = a3 + 16 | 0;
                    e4 = c2[d4 >> 2] | 0;
                    if (!e4)
                      break;
                    else {
                      a3 = e4;
                      b3 = d4;
                    }
                  }
                  c2[b3 >> 2] = 0;
                } else {
                  i4 = c2[h3 + 8 >> 2] | 0;
                  c2[i4 + 12 >> 2] = a3;
                  c2[a3 + 8 >> 2] = i4;
                }
              while (0);
              if (f4) {
                b3 = c2[h3 + 28 >> 2] | 0;
                d4 = 11436 + (b3 << 2) | 0;
                if ((h3 | 0) == (c2[d4 >> 2] | 0)) {
                  c2[d4 >> 2] = a3;
                  if (!a3) {
                    c2[2784] = c2[2784] & ~(1 << b3);
                    i4 = h3;
                    b3 = g3;
                    break;
                  }
                } else {
                  c2[f4 + 16 + (((c2[f4 + 16 >> 2] | 0) != (h3 | 0) & 1) << 2) >> 2] = a3;
                  if (!a3) {
                    i4 = h3;
                    b3 = g3;
                    break;
                  }
                }
                c2[a3 + 24 >> 2] = f4;
                b3 = h3 + 16 | 0;
                d4 = c2[b3 >> 2] | 0;
                if (d4 | 0) {
                  c2[a3 + 16 >> 2] = d4;
                  c2[d4 + 24 >> 2] = a3;
                }
                b3 = c2[b3 + 4 >> 2] | 0;
                if (b3) {
                  c2[a3 + 20 >> 2] = b3;
                  c2[b3 + 24 >> 2] = a3;
                  i4 = h3;
                  b3 = g3;
                } else {
                  i4 = h3;
                  b3 = g3;
                }
              } else {
                i4 = h3;
                b3 = g3;
              }
            } else {
              i4 = d4;
              h3 = d4;
            }
          while (0);
          if (h3 >>> 0 >= j4 >>> 0)
            return;
          a3 = j4 + 4 | 0;
          e4 = c2[a3 >> 2] | 0;
          if (!(e4 & 1))
            return;
          if (!(e4 & 2)) {
            a3 = c2[2788] | 0;
            if ((j4 | 0) == (c2[2789] | 0)) {
              j4 = (c2[2786] | 0) + b3 | 0;
              c2[2786] = j4;
              c2[2789] = i4;
              c2[i4 + 4 >> 2] = j4 | 1;
              if ((i4 | 0) != (a3 | 0))
                return;
              c2[2788] = 0;
              c2[2785] = 0;
              return;
            }
            if ((j4 | 0) == (a3 | 0)) {
              j4 = (c2[2785] | 0) + b3 | 0;
              c2[2785] = j4;
              c2[2788] = h3;
              c2[i4 + 4 >> 2] = j4 | 1;
              c2[h3 + j4 >> 2] = j4;
              return;
            }
            f4 = (e4 & -8) + b3 | 0;
            d4 = e4 >>> 3;
            do
              if (e4 >>> 0 < 256) {
                b3 = c2[j4 + 8 >> 2] | 0;
                a3 = c2[j4 + 12 >> 2] | 0;
                if ((a3 | 0) == (b3 | 0)) {
                  c2[2783] = c2[2783] & ~(1 << d4);
                  break;
                } else {
                  c2[b3 + 12 >> 2] = a3;
                  c2[a3 + 8 >> 2] = b3;
                  break;
                }
              } else {
                g3 = c2[j4 + 24 >> 2] | 0;
                a3 = c2[j4 + 12 >> 2] | 0;
                do
                  if ((a3 | 0) == (j4 | 0)) {
                    d4 = j4 + 16 | 0;
                    b3 = d4 + 4 | 0;
                    a3 = c2[b3 >> 2] | 0;
                    if (!a3) {
                      a3 = c2[d4 >> 2] | 0;
                      if (!a3) {
                        d4 = 0;
                        break;
                      } else
                        b3 = d4;
                    }
                    while (1) {
                      d4 = a3 + 20 | 0;
                      e4 = c2[d4 >> 2] | 0;
                      if (e4 | 0) {
                        a3 = e4;
                        b3 = d4;
                        continue;
                      }
                      d4 = a3 + 16 | 0;
                      e4 = c2[d4 >> 2] | 0;
                      if (!e4)
                        break;
                      else {
                        a3 = e4;
                        b3 = d4;
                      }
                    }
                    c2[b3 >> 2] = 0;
                    d4 = a3;
                  } else {
                    d4 = c2[j4 + 8 >> 2] | 0;
                    c2[d4 + 12 >> 2] = a3;
                    c2[a3 + 8 >> 2] = d4;
                    d4 = a3;
                  }
                while (0);
                if (g3 | 0) {
                  a3 = c2[j4 + 28 >> 2] | 0;
                  b3 = 11436 + (a3 << 2) | 0;
                  if ((j4 | 0) == (c2[b3 >> 2] | 0)) {
                    c2[b3 >> 2] = d4;
                    if (!d4) {
                      c2[2784] = c2[2784] & ~(1 << a3);
                      break;
                    }
                  } else {
                    c2[g3 + 16 + (((c2[g3 + 16 >> 2] | 0) != (j4 | 0) & 1) << 2) >> 2] = d4;
                    if (!d4)
                      break;
                  }
                  c2[d4 + 24 >> 2] = g3;
                  a3 = j4 + 16 | 0;
                  b3 = c2[a3 >> 2] | 0;
                  if (b3 | 0) {
                    c2[d4 + 16 >> 2] = b3;
                    c2[b3 + 24 >> 2] = d4;
                  }
                  a3 = c2[a3 + 4 >> 2] | 0;
                  if (a3 | 0) {
                    c2[d4 + 20 >> 2] = a3;
                    c2[a3 + 24 >> 2] = d4;
                  }
                }
              }
            while (0);
            c2[i4 + 4 >> 2] = f4 | 1;
            c2[h3 + f4 >> 2] = f4;
            if ((i4 | 0) == (c2[2788] | 0)) {
              c2[2785] = f4;
              return;
            }
          } else {
            c2[a3 >> 2] = e4 & -2;
            c2[i4 + 4 >> 2] = b3 | 1;
            c2[h3 + b3 >> 2] = b3;
            f4 = b3;
          }
          a3 = f4 >>> 3;
          if (f4 >>> 0 < 256) {
            d4 = 11172 + (a3 << 1 << 2) | 0;
            b3 = c2[2783] | 0;
            a3 = 1 << a3;
            if (!(b3 & a3)) {
              c2[2783] = b3 | a3;
              a3 = d4;
              b3 = d4 + 8 | 0;
            } else {
              b3 = d4 + 8 | 0;
              a3 = c2[b3 >> 2] | 0;
            }
            c2[b3 >> 2] = i4;
            c2[a3 + 12 >> 2] = i4;
            c2[i4 + 8 >> 2] = a3;
            c2[i4 + 12 >> 2] = d4;
            return;
          }
          a3 = f4 >>> 8;
          if (a3) {
            if (f4 >>> 0 > 16777215)
              a3 = 31;
            else {
              h3 = (a3 + 1048320 | 0) >>> 16 & 8;
              j4 = a3 << h3;
              g3 = (j4 + 520192 | 0) >>> 16 & 4;
              j4 = j4 << g3;
              a3 = (j4 + 245760 | 0) >>> 16 & 2;
              a3 = 14 - (g3 | h3 | a3) + (j4 << a3 >>> 15) | 0;
              a3 = f4 >>> (a3 + 7 | 0) & 1 | a3 << 1;
            }
          } else
            a3 = 0;
          e4 = 11436 + (a3 << 2) | 0;
          c2[i4 + 28 >> 2] = a3;
          c2[i4 + 20 >> 2] = 0;
          c2[i4 + 16 >> 2] = 0;
          b3 = c2[2784] | 0;
          d4 = 1 << a3;
          do
            if (b3 & d4) {
              b3 = f4 << ((a3 | 0) == 31 ? 0 : 25 - (a3 >>> 1) | 0);
              d4 = c2[e4 >> 2] | 0;
              while (1) {
                if ((c2[d4 + 4 >> 2] & -8 | 0) == (f4 | 0)) {
                  a3 = 73;
                  break;
                }
                e4 = d4 + 16 + (b3 >>> 31 << 2) | 0;
                a3 = c2[e4 >> 2] | 0;
                if (!a3) {
                  a3 = 72;
                  break;
                } else {
                  b3 = b3 << 1;
                  d4 = a3;
                }
              }
              if ((a3 | 0) == 72) {
                c2[e4 >> 2] = i4;
                c2[i4 + 24 >> 2] = d4;
                c2[i4 + 12 >> 2] = i4;
                c2[i4 + 8 >> 2] = i4;
                break;
              } else if ((a3 | 0) == 73) {
                h3 = d4 + 8 | 0;
                j4 = c2[h3 >> 2] | 0;
                c2[j4 + 12 >> 2] = i4;
                c2[h3 >> 2] = i4;
                c2[i4 + 8 >> 2] = j4;
                c2[i4 + 12 >> 2] = d4;
                c2[i4 + 24 >> 2] = 0;
                break;
              }
            } else {
              c2[2784] = b3 | d4;
              c2[e4 >> 2] = i4;
              c2[i4 + 24 >> 2] = e4;
              c2[i4 + 12 >> 2] = i4;
              c2[i4 + 8 >> 2] = i4;
            }
          while (0);
          j4 = (c2[2791] | 0) + -1 | 0;
          c2[2791] = j4;
          if (!j4)
            a3 = 11588;
          else
            return;
          while (1) {
            a3 = c2[a3 >> 2] | 0;
            if (!a3)
              break;
            else
              a3 = a3 + 8 | 0;
          }
          c2[2791] = -1;
          return;
        }
        function qB() {
          return 11628;
        }
        function rB(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0;
          b3 = l3;
          l3 = l3 + 16 | 0;
          d4 = b3;
          c2[d4 >> 2] = yB(c2[a3 + 60 >> 2] | 0) | 0;
          a3 = uB(db(6, d4 | 0) | 0) | 0;
          l3 = b3;
          return a3 | 0;
        }
        function sB(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0, p4 = 0;
          n3 = l3;
          l3 = l3 + 48 | 0;
          k4 = n3 + 16 | 0;
          g3 = n3;
          f4 = n3 + 32 | 0;
          i4 = a3 + 28 | 0;
          e4 = c2[i4 >> 2] | 0;
          c2[f4 >> 2] = e4;
          j4 = a3 + 20 | 0;
          e4 = (c2[j4 >> 2] | 0) - e4 | 0;
          c2[f4 + 4 >> 2] = e4;
          c2[f4 + 8 >> 2] = b3;
          c2[f4 + 12 >> 2] = d4;
          e4 = e4 + d4 | 0;
          h3 = a3 + 60 | 0;
          c2[g3 >> 2] = c2[h3 >> 2];
          c2[g3 + 4 >> 2] = f4;
          c2[g3 + 8 >> 2] = 2;
          g3 = uB(gb(146, g3 | 0) | 0) | 0;
          a:
            do
              if ((e4 | 0) != (g3 | 0)) {
                b3 = 2;
                while (1) {
                  if ((g3 | 0) < 0)
                    break;
                  e4 = e4 - g3 | 0;
                  p4 = c2[f4 + 4 >> 2] | 0;
                  o3 = g3 >>> 0 > p4 >>> 0;
                  f4 = o3 ? f4 + 8 | 0 : f4;
                  b3 = (o3 << 31 >> 31) + b3 | 0;
                  p4 = g3 - (o3 ? p4 : 0) | 0;
                  c2[f4 >> 2] = (c2[f4 >> 2] | 0) + p4;
                  o3 = f4 + 4 | 0;
                  c2[o3 >> 2] = (c2[o3 >> 2] | 0) - p4;
                  c2[k4 >> 2] = c2[h3 >> 2];
                  c2[k4 + 4 >> 2] = f4;
                  c2[k4 + 8 >> 2] = b3;
                  g3 = uB(gb(146, k4 | 0) | 0) | 0;
                  if ((e4 | 0) == (g3 | 0)) {
                    m4 = 3;
                    break a;
                  }
                }
                c2[a3 + 16 >> 2] = 0;
                c2[i4 >> 2] = 0;
                c2[j4 >> 2] = 0;
                c2[a3 >> 2] = c2[a3 >> 2] | 32;
                if ((b3 | 0) == 2)
                  d4 = 0;
                else
                  d4 = d4 - (c2[f4 + 4 >> 2] | 0) | 0;
              } else
                m4 = 3;
            while (0);
          if ((m4 | 0) == 3) {
            p4 = c2[a3 + 44 >> 2] | 0;
            c2[a3 + 16 >> 2] = p4 + (c2[a3 + 48 >> 2] | 0);
            c2[i4 >> 2] = p4;
            c2[j4 >> 2] = p4;
          }
          l3 = n3;
          return d4 | 0;
        }
        function tB(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0;
          f4 = l3;
          l3 = l3 + 32 | 0;
          g3 = f4;
          e4 = f4 + 20 | 0;
          c2[g3 >> 2] = c2[a3 + 60 >> 2];
          c2[g3 + 4 >> 2] = 0;
          c2[g3 + 8 >> 2] = b3;
          c2[g3 + 12 >> 2] = e4;
          c2[g3 + 16 >> 2] = d4;
          if ((uB(fb(140, g3 | 0) | 0) | 0) < 0) {
            c2[e4 >> 2] = -1;
            a3 = -1;
          } else
            a3 = c2[e4 >> 2] | 0;
          l3 = f4;
          return a3 | 0;
        }
        function uB(a3) {
          a3 = a3 | 0;
          if (a3 >>> 0 > 4294963200) {
            c2[(vB() | 0) >> 2] = 0 - a3;
            a3 = -1;
          }
          return a3 | 0;
        }
        function vB() {
          return (wB() | 0) + 64 | 0;
        }
        function wB() {
          return xB() | 0;
        }
        function xB() {
          return 2084;
        }
        function yB(a3) {
          a3 = a3 | 0;
          return a3 | 0;
        }
        function zB(b3, d4, e4) {
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0;
          g3 = l3;
          l3 = l3 + 32 | 0;
          f4 = g3;
          c2[b3 + 36 >> 2] = 1;
          if ((c2[b3 >> 2] & 64 | 0) == 0 ? (c2[f4 >> 2] = c2[b3 + 60 >> 2], c2[f4 + 4 >> 2] = 21523, c2[f4 + 8 >> 2] = g3 + 16, Wa(54, f4 | 0) | 0) : 0)
            a2[b3 + 75 >> 0] = -1;
          f4 = sB(b3, d4, e4) | 0;
          l3 = g3;
          return f4 | 0;
        }
        function AB(b3, c3) {
          b3 = b3 | 0;
          c3 = c3 | 0;
          var d4 = 0, e4 = 0;
          d4 = a2[b3 >> 0] | 0;
          e4 = a2[c3 >> 0] | 0;
          if (d4 << 24 >> 24 == 0 ? 1 : d4 << 24 >> 24 != e4 << 24 >> 24)
            b3 = e4;
          else {
            do {
              b3 = b3 + 1 | 0;
              c3 = c3 + 1 | 0;
              d4 = a2[b3 >> 0] | 0;
              e4 = a2[c3 >> 0] | 0;
            } while (!(d4 << 24 >> 24 == 0 ? 1 : d4 << 24 >> 24 != e4 << 24 >> 24));
            b3 = e4;
          }
          return (d4 & 255) - (b3 & 255) | 0;
        }
        function BB(b3, c3, d4) {
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0;
          a:
            do
              if (!d4)
                b3 = 0;
              else {
                while (1) {
                  e4 = a2[b3 >> 0] | 0;
                  f4 = a2[c3 >> 0] | 0;
                  if (e4 << 24 >> 24 != f4 << 24 >> 24)
                    break;
                  d4 = d4 + -1 | 0;
                  if (!d4) {
                    b3 = 0;
                    break a;
                  } else {
                    b3 = b3 + 1 | 0;
                    c3 = c3 + 1 | 0;
                  }
                }
                b3 = (e4 & 255) - (f4 & 255) | 0;
              }
            while (0);
          return b3 | 0;
        }
        function CB(b3, d4, e4) {
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0, p4 = 0, q3 = 0, r3 = 0, s3 = 0;
          s3 = l3;
          l3 = l3 + 224 | 0;
          n3 = s3 + 120 | 0;
          o3 = s3 + 80 | 0;
          q3 = s3;
          r3 = s3 + 136 | 0;
          f4 = o3;
          g3 = f4 + 40 | 0;
          do {
            c2[f4 >> 2] = 0;
            f4 = f4 + 4 | 0;
          } while ((f4 | 0) < (g3 | 0));
          c2[n3 >> 2] = c2[e4 >> 2];
          if ((DB(0, d4, n3, q3, o3) | 0) < 0)
            e4 = -1;
          else {
            if ((c2[b3 + 76 >> 2] | 0) > -1)
              p4 = EB(b3) | 0;
            else
              p4 = 0;
            e4 = c2[b3 >> 2] | 0;
            m4 = e4 & 32;
            if ((a2[b3 + 74 >> 0] | 0) < 1)
              c2[b3 >> 2] = e4 & -33;
            f4 = b3 + 48 | 0;
            if (!(c2[f4 >> 2] | 0)) {
              g3 = b3 + 44 | 0;
              h3 = c2[g3 >> 2] | 0;
              c2[g3 >> 2] = r3;
              i4 = b3 + 28 | 0;
              c2[i4 >> 2] = r3;
              j4 = b3 + 20 | 0;
              c2[j4 >> 2] = r3;
              c2[f4 >> 2] = 80;
              k4 = b3 + 16 | 0;
              c2[k4 >> 2] = r3 + 80;
              e4 = DB(b3, d4, n3, q3, o3) | 0;
              if (h3) {
                sb[c2[b3 + 36 >> 2] & 7](b3, 0, 0) | 0;
                e4 = (c2[j4 >> 2] | 0) == 0 ? -1 : e4;
                c2[g3 >> 2] = h3;
                c2[f4 >> 2] = 0;
                c2[k4 >> 2] = 0;
                c2[i4 >> 2] = 0;
                c2[j4 >> 2] = 0;
              }
            } else
              e4 = DB(b3, d4, n3, q3, o3) | 0;
            f4 = c2[b3 >> 2] | 0;
            c2[b3 >> 2] = f4 | m4;
            if (p4 | 0)
              FB(b3);
            e4 = (f4 & 32 | 0) == 0 ? e4 : -1;
          }
          l3 = s3;
          return e4 | 0;
        }
        function DB(d4, e4, f4, g3, i4) {
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          g3 = g3 | 0;
          i4 = i4 | 0;
          var j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0, p4 = 0, q3 = 0, r3 = 0, s3 = 0, t3 = 0, u4 = 0, v4 = 0, w3 = 0, x4 = 0, y3 = 0, z3 = 0, B3 = 0, C3 = 0, D3 = 0, E3 = 0, F3 = 0, G3 = 0, H3 = 0;
          H3 = l3;
          l3 = l3 + 64 | 0;
          D3 = H3 + 16 | 0;
          E3 = H3;
          B3 = H3 + 24 | 0;
          F3 = H3 + 8 | 0;
          G3 = H3 + 20 | 0;
          c2[D3 >> 2] = e4;
          x4 = (d4 | 0) != 0;
          y3 = B3 + 40 | 0;
          z3 = y3;
          B3 = B3 + 39 | 0;
          C3 = F3 + 4 | 0;
          k4 = 0;
          j4 = 0;
          p4 = 0;
          a:
            while (1) {
              do
                if ((j4 | 0) > -1)
                  if ((k4 | 0) > (2147483647 - j4 | 0)) {
                    c2[(vB() | 0) >> 2] = 75;
                    j4 = -1;
                    break;
                  } else {
                    j4 = k4 + j4 | 0;
                    break;
                  }
              while (0);
              k4 = a2[e4 >> 0] | 0;
              if (!(k4 << 24 >> 24)) {
                w3 = 87;
                break;
              } else
                m4 = e4;
              b:
                while (1) {
                  switch (k4 << 24 >> 24) {
                    case 37: {
                      k4 = m4;
                      w3 = 9;
                      break b;
                    }
                    case 0: {
                      k4 = m4;
                      break b;
                    }
                    default: {
                    }
                  }
                  v4 = m4 + 1 | 0;
                  c2[D3 >> 2] = v4;
                  k4 = a2[v4 >> 0] | 0;
                  m4 = v4;
                }
              c:
                do
                  if ((w3 | 0) == 9)
                    while (1) {
                      w3 = 0;
                      if ((a2[m4 + 1 >> 0] | 0) != 37)
                        break c;
                      k4 = k4 + 1 | 0;
                      m4 = m4 + 2 | 0;
                      c2[D3 >> 2] = m4;
                      if ((a2[m4 >> 0] | 0) == 37)
                        w3 = 9;
                      else
                        break;
                    }
                while (0);
              k4 = k4 - e4 | 0;
              if (x4)
                GB(d4, e4, k4);
              if (k4 | 0) {
                e4 = m4;
                continue;
              }
              n3 = m4 + 1 | 0;
              k4 = (a2[n3 >> 0] | 0) + -48 | 0;
              if (k4 >>> 0 < 10) {
                v4 = (a2[m4 + 2 >> 0] | 0) == 36;
                u4 = v4 ? k4 : -1;
                p4 = v4 ? 1 : p4;
                n3 = v4 ? m4 + 3 | 0 : n3;
              } else
                u4 = -1;
              c2[D3 >> 2] = n3;
              k4 = a2[n3 >> 0] | 0;
              m4 = (k4 << 24 >> 24) + -32 | 0;
              d:
                do
                  if (m4 >>> 0 < 32) {
                    o3 = 0;
                    q3 = k4;
                    while (1) {
                      k4 = 1 << m4;
                      if (!(k4 & 75913)) {
                        k4 = q3;
                        break d;
                      }
                      o3 = k4 | o3;
                      n3 = n3 + 1 | 0;
                      c2[D3 >> 2] = n3;
                      k4 = a2[n3 >> 0] | 0;
                      m4 = (k4 << 24 >> 24) + -32 | 0;
                      if (m4 >>> 0 >= 32)
                        break;
                      else
                        q3 = k4;
                    }
                  } else
                    o3 = 0;
                while (0);
              if (k4 << 24 >> 24 == 42) {
                m4 = n3 + 1 | 0;
                k4 = (a2[m4 >> 0] | 0) + -48 | 0;
                if (k4 >>> 0 < 10 ? (a2[n3 + 2 >> 0] | 0) == 36 : 0) {
                  c2[i4 + (k4 << 2) >> 2] = 10;
                  k4 = c2[g3 + ((a2[m4 >> 0] | 0) + -48 << 3) >> 2] | 0;
                  p4 = 1;
                  n3 = n3 + 3 | 0;
                } else {
                  if (p4 | 0) {
                    j4 = -1;
                    break;
                  }
                  if (x4) {
                    p4 = (c2[f4 >> 2] | 0) + (4 - 1) & ~(4 - 1);
                    k4 = c2[p4 >> 2] | 0;
                    c2[f4 >> 2] = p4 + 4;
                    p4 = 0;
                    n3 = m4;
                  } else {
                    k4 = 0;
                    p4 = 0;
                    n3 = m4;
                  }
                }
                c2[D3 >> 2] = n3;
                v4 = (k4 | 0) < 0;
                k4 = v4 ? 0 - k4 | 0 : k4;
                o3 = v4 ? o3 | 8192 : o3;
              } else {
                k4 = HB(D3) | 0;
                if ((k4 | 0) < 0) {
                  j4 = -1;
                  break;
                }
                n3 = c2[D3 >> 2] | 0;
              }
              do
                if ((a2[n3 >> 0] | 0) == 46) {
                  if ((a2[n3 + 1 >> 0] | 0) != 42) {
                    c2[D3 >> 2] = n3 + 1;
                    m4 = HB(D3) | 0;
                    n3 = c2[D3 >> 2] | 0;
                    break;
                  }
                  q3 = n3 + 2 | 0;
                  m4 = (a2[q3 >> 0] | 0) + -48 | 0;
                  if (m4 >>> 0 < 10 ? (a2[n3 + 3 >> 0] | 0) == 36 : 0) {
                    c2[i4 + (m4 << 2) >> 2] = 10;
                    m4 = c2[g3 + ((a2[q3 >> 0] | 0) + -48 << 3) >> 2] | 0;
                    n3 = n3 + 4 | 0;
                    c2[D3 >> 2] = n3;
                    break;
                  }
                  if (p4 | 0) {
                    j4 = -1;
                    break a;
                  }
                  if (x4) {
                    v4 = (c2[f4 >> 2] | 0) + (4 - 1) & ~(4 - 1);
                    m4 = c2[v4 >> 2] | 0;
                    c2[f4 >> 2] = v4 + 4;
                  } else
                    m4 = 0;
                  c2[D3 >> 2] = q3;
                  n3 = q3;
                } else
                  m4 = -1;
              while (0);
              t3 = 0;
              while (1) {
                if (((a2[n3 >> 0] | 0) + -65 | 0) >>> 0 > 57) {
                  j4 = -1;
                  break a;
                }
                v4 = n3 + 1 | 0;
                c2[D3 >> 2] = v4;
                q3 = a2[(a2[n3 >> 0] | 0) + -65 + (5178 + (t3 * 58 | 0)) >> 0] | 0;
                r3 = q3 & 255;
                if ((r3 + -1 | 0) >>> 0 < 8) {
                  t3 = r3;
                  n3 = v4;
                } else
                  break;
              }
              if (!(q3 << 24 >> 24)) {
                j4 = -1;
                break;
              }
              s3 = (u4 | 0) > -1;
              do
                if (q3 << 24 >> 24 == 19) {
                  if (s3) {
                    j4 = -1;
                    break a;
                  } else
                    w3 = 49;
                } else {
                  if (s3) {
                    c2[i4 + (u4 << 2) >> 2] = r3;
                    s3 = g3 + (u4 << 3) | 0;
                    u4 = c2[s3 + 4 >> 2] | 0;
                    w3 = E3;
                    c2[w3 >> 2] = c2[s3 >> 2];
                    c2[w3 + 4 >> 2] = u4;
                    w3 = 49;
                    break;
                  }
                  if (!x4) {
                    j4 = 0;
                    break a;
                  }
                  IB(E3, r3, f4);
                }
              while (0);
              if ((w3 | 0) == 49 ? (w3 = 0, !x4) : 0) {
                k4 = 0;
                e4 = v4;
                continue;
              }
              n3 = a2[n3 >> 0] | 0;
              n3 = (t3 | 0) != 0 & (n3 & 15 | 0) == 3 ? n3 & -33 : n3;
              s3 = o3 & -65537;
              u4 = (o3 & 8192 | 0) == 0 ? o3 : s3;
              e:
                do
                  switch (n3 | 0) {
                    case 110:
                      switch ((t3 & 255) << 24 >> 24) {
                        case 0: {
                          c2[c2[E3 >> 2] >> 2] = j4;
                          k4 = 0;
                          e4 = v4;
                          continue a;
                        }
                        case 1: {
                          c2[c2[E3 >> 2] >> 2] = j4;
                          k4 = 0;
                          e4 = v4;
                          continue a;
                        }
                        case 2: {
                          k4 = c2[E3 >> 2] | 0;
                          c2[k4 >> 2] = j4;
                          c2[k4 + 4 >> 2] = ((j4 | 0) < 0) << 31 >> 31;
                          k4 = 0;
                          e4 = v4;
                          continue a;
                        }
                        case 3: {
                          b2[c2[E3 >> 2] >> 1] = j4;
                          k4 = 0;
                          e4 = v4;
                          continue a;
                        }
                        case 4: {
                          a2[c2[E3 >> 2] >> 0] = j4;
                          k4 = 0;
                          e4 = v4;
                          continue a;
                        }
                        case 6: {
                          c2[c2[E3 >> 2] >> 2] = j4;
                          k4 = 0;
                          e4 = v4;
                          continue a;
                        }
                        case 7: {
                          k4 = c2[E3 >> 2] | 0;
                          c2[k4 >> 2] = j4;
                          c2[k4 + 4 >> 2] = ((j4 | 0) < 0) << 31 >> 31;
                          k4 = 0;
                          e4 = v4;
                          continue a;
                        }
                        default: {
                          k4 = 0;
                          e4 = v4;
                          continue a;
                        }
                      }
                    case 112: {
                      n3 = 120;
                      m4 = m4 >>> 0 > 8 ? m4 : 8;
                      e4 = u4 | 8;
                      w3 = 61;
                      break;
                    }
                    case 88:
                    case 120: {
                      e4 = u4;
                      w3 = 61;
                      break;
                    }
                    case 111: {
                      n3 = E3;
                      e4 = c2[n3 >> 2] | 0;
                      n3 = c2[n3 + 4 >> 2] | 0;
                      r3 = KB(e4, n3, y3) | 0;
                      s3 = z3 - r3 | 0;
                      o3 = 0;
                      q3 = 5642;
                      m4 = (u4 & 8 | 0) == 0 | (m4 | 0) > (s3 | 0) ? m4 : s3 + 1 | 0;
                      s3 = u4;
                      w3 = 67;
                      break;
                    }
                    case 105:
                    case 100: {
                      n3 = E3;
                      e4 = c2[n3 >> 2] | 0;
                      n3 = c2[n3 + 4 >> 2] | 0;
                      if ((n3 | 0) < 0) {
                        e4 = wC(0, 0, e4 | 0, n3 | 0) | 0;
                        n3 = A2;
                        o3 = E3;
                        c2[o3 >> 2] = e4;
                        c2[o3 + 4 >> 2] = n3;
                        o3 = 1;
                        q3 = 5642;
                        w3 = 66;
                        break e;
                      } else {
                        o3 = (u4 & 2049 | 0) != 0 & 1;
                        q3 = (u4 & 2048 | 0) == 0 ? (u4 & 1 | 0) == 0 ? 5642 : 5644 : 5643;
                        w3 = 66;
                        break e;
                      }
                    }
                    case 117: {
                      n3 = E3;
                      o3 = 0;
                      q3 = 5642;
                      e4 = c2[n3 >> 2] | 0;
                      n3 = c2[n3 + 4 >> 2] | 0;
                      w3 = 66;
                      break;
                    }
                    case 99: {
                      a2[B3 >> 0] = c2[E3 >> 2];
                      e4 = B3;
                      o3 = 0;
                      q3 = 5642;
                      r3 = y3;
                      n3 = 1;
                      m4 = s3;
                      break;
                    }
                    case 109: {
                      n3 = MB(c2[(vB() | 0) >> 2] | 0) | 0;
                      w3 = 71;
                      break;
                    }
                    case 115: {
                      n3 = c2[E3 >> 2] | 0;
                      n3 = n3 | 0 ? n3 : 5652;
                      w3 = 71;
                      break;
                    }
                    case 67: {
                      c2[F3 >> 2] = c2[E3 >> 2];
                      c2[C3 >> 2] = 0;
                      c2[E3 >> 2] = F3;
                      r3 = -1;
                      n3 = F3;
                      w3 = 75;
                      break;
                    }
                    case 83: {
                      e4 = c2[E3 >> 2] | 0;
                      if (!m4) {
                        OB(d4, 32, k4, 0, u4);
                        e4 = 0;
                        w3 = 84;
                      } else {
                        r3 = m4;
                        n3 = e4;
                        w3 = 75;
                      }
                      break;
                    }
                    case 65:
                    case 71:
                    case 70:
                    case 69:
                    case 97:
                    case 103:
                    case 102:
                    case 101: {
                      k4 = QB(d4, +h2[E3 >> 3], k4, m4, u4, n3) | 0;
                      e4 = v4;
                      continue a;
                    }
                    default: {
                      o3 = 0;
                      q3 = 5642;
                      r3 = y3;
                      n3 = m4;
                      m4 = u4;
                    }
                  }
                while (0);
              f:
                do
                  if ((w3 | 0) == 61) {
                    u4 = E3;
                    t3 = c2[u4 >> 2] | 0;
                    u4 = c2[u4 + 4 >> 2] | 0;
                    r3 = JB(t3, u4, y3, n3 & 32) | 0;
                    q3 = (e4 & 8 | 0) == 0 | (t3 | 0) == 0 & (u4 | 0) == 0;
                    o3 = q3 ? 0 : 2;
                    q3 = q3 ? 5642 : 5642 + (n3 >> 4) | 0;
                    s3 = e4;
                    e4 = t3;
                    n3 = u4;
                    w3 = 67;
                  } else if ((w3 | 0) == 66) {
                    r3 = LB(e4, n3, y3) | 0;
                    s3 = u4;
                    w3 = 67;
                  } else if ((w3 | 0) == 71) {
                    w3 = 0;
                    u4 = NB(n3, 0, m4) | 0;
                    t3 = (u4 | 0) == 0;
                    e4 = n3;
                    o3 = 0;
                    q3 = 5642;
                    r3 = t3 ? n3 + m4 | 0 : u4;
                    n3 = t3 ? m4 : u4 - n3 | 0;
                    m4 = s3;
                  } else if ((w3 | 0) == 75) {
                    w3 = 0;
                    q3 = n3;
                    e4 = 0;
                    m4 = 0;
                    while (1) {
                      o3 = c2[q3 >> 2] | 0;
                      if (!o3)
                        break;
                      m4 = PB(G3, o3) | 0;
                      if ((m4 | 0) < 0 | m4 >>> 0 > (r3 - e4 | 0) >>> 0)
                        break;
                      e4 = m4 + e4 | 0;
                      if (r3 >>> 0 > e4 >>> 0)
                        q3 = q3 + 4 | 0;
                      else
                        break;
                    }
                    if ((m4 | 0) < 0) {
                      j4 = -1;
                      break a;
                    }
                    OB(d4, 32, k4, e4, u4);
                    if (!e4) {
                      e4 = 0;
                      w3 = 84;
                    } else {
                      o3 = 0;
                      while (1) {
                        m4 = c2[n3 >> 2] | 0;
                        if (!m4) {
                          w3 = 84;
                          break f;
                        }
                        m4 = PB(G3, m4) | 0;
                        o3 = m4 + o3 | 0;
                        if ((o3 | 0) > (e4 | 0)) {
                          w3 = 84;
                          break f;
                        }
                        GB(d4, G3, m4);
                        if (o3 >>> 0 >= e4 >>> 0) {
                          w3 = 84;
                          break;
                        } else
                          n3 = n3 + 4 | 0;
                      }
                    }
                  }
                while (0);
              if ((w3 | 0) == 67) {
                w3 = 0;
                n3 = (e4 | 0) != 0 | (n3 | 0) != 0;
                u4 = (m4 | 0) != 0 | n3;
                n3 = ((n3 ^ 1) & 1) + (z3 - r3) | 0;
                e4 = u4 ? r3 : y3;
                r3 = y3;
                n3 = u4 ? (m4 | 0) > (n3 | 0) ? m4 : n3 : m4;
                m4 = (m4 | 0) > -1 ? s3 & -65537 : s3;
              } else if ((w3 | 0) == 84) {
                w3 = 0;
                OB(d4, 32, k4, e4, u4 ^ 8192);
                k4 = (k4 | 0) > (e4 | 0) ? k4 : e4;
                e4 = v4;
                continue;
              }
              t3 = r3 - e4 | 0;
              s3 = (n3 | 0) < (t3 | 0) ? t3 : n3;
              u4 = s3 + o3 | 0;
              k4 = (k4 | 0) < (u4 | 0) ? u4 : k4;
              OB(d4, 32, k4, u4, m4);
              GB(d4, q3, o3);
              OB(d4, 48, k4, u4, m4 ^ 65536);
              OB(d4, 48, s3, t3, 0);
              GB(d4, e4, t3);
              OB(d4, 32, k4, u4, m4 ^ 8192);
              e4 = v4;
            }
          g:
            do
              if ((w3 | 0) == 87) {
                if (!d4)
                  if (!p4)
                    j4 = 0;
                  else {
                    j4 = 1;
                    while (1) {
                      e4 = c2[i4 + (j4 << 2) >> 2] | 0;
                      if (!e4)
                        break;
                      IB(g3 + (j4 << 3) | 0, e4, f4);
                      j4 = j4 + 1 | 0;
                      if ((j4 | 0) >= 10) {
                        j4 = 1;
                        break g;
                      }
                    }
                    while (1) {
                      if (c2[i4 + (j4 << 2) >> 2] | 0) {
                        j4 = -1;
                        break g;
                      }
                      j4 = j4 + 1 | 0;
                      if ((j4 | 0) >= 10) {
                        j4 = 1;
                        break;
                      }
                    }
                  }
              }
            while (0);
          l3 = H3;
          return j4 | 0;
        }
        function EB(a3) {
          a3 = a3 | 0;
          return 0;
        }
        function FB(a3) {
          a3 = a3 | 0;
          return;
        }
        function GB(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          if (!(c2[a3 >> 2] & 32))
            aC(b3, d4, a3) | 0;
          return;
        }
        function HB(b3) {
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0;
          e4 = c2[b3 >> 2] | 0;
          f4 = (a2[e4 >> 0] | 0) + -48 | 0;
          if (f4 >>> 0 < 10) {
            d4 = 0;
            do {
              d4 = f4 + (d4 * 10 | 0) | 0;
              e4 = e4 + 1 | 0;
              c2[b3 >> 2] = e4;
              f4 = (a2[e4 >> 0] | 0) + -48 | 0;
            } while (f4 >>> 0 < 10);
          } else
            d4 = 0;
          return d4 | 0;
        }
        function IB(a3, b3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          var e4 = 0, f4 = 0, g3 = 0;
          a:
            do
              if (b3 >>> 0 <= 20)
                do
                  switch (b3 | 0) {
                    case 9: {
                      e4 = (c2[d4 >> 2] | 0) + (4 - 1) & ~(4 - 1);
                      b3 = c2[e4 >> 2] | 0;
                      c2[d4 >> 2] = e4 + 4;
                      c2[a3 >> 2] = b3;
                      break a;
                    }
                    case 10: {
                      e4 = (c2[d4 >> 2] | 0) + (4 - 1) & ~(4 - 1);
                      b3 = c2[e4 >> 2] | 0;
                      c2[d4 >> 2] = e4 + 4;
                      e4 = a3;
                      c2[e4 >> 2] = b3;
                      c2[e4 + 4 >> 2] = ((b3 | 0) < 0) << 31 >> 31;
                      break a;
                    }
                    case 11: {
                      e4 = (c2[d4 >> 2] | 0) + (4 - 1) & ~(4 - 1);
                      b3 = c2[e4 >> 2] | 0;
                      c2[d4 >> 2] = e4 + 4;
                      e4 = a3;
                      c2[e4 >> 2] = b3;
                      c2[e4 + 4 >> 2] = 0;
                      break a;
                    }
                    case 12: {
                      e4 = (c2[d4 >> 2] | 0) + (8 - 1) & ~(8 - 1);
                      b3 = e4;
                      f4 = c2[b3 >> 2] | 0;
                      b3 = c2[b3 + 4 >> 2] | 0;
                      c2[d4 >> 2] = e4 + 8;
                      e4 = a3;
                      c2[e4 >> 2] = f4;
                      c2[e4 + 4 >> 2] = b3;
                      break a;
                    }
                    case 13: {
                      f4 = (c2[d4 >> 2] | 0) + (4 - 1) & ~(4 - 1);
                      e4 = c2[f4 >> 2] | 0;
                      c2[d4 >> 2] = f4 + 4;
                      e4 = (e4 & 65535) << 16 >> 16;
                      f4 = a3;
                      c2[f4 >> 2] = e4;
                      c2[f4 + 4 >> 2] = ((e4 | 0) < 0) << 31 >> 31;
                      break a;
                    }
                    case 14: {
                      f4 = (c2[d4 >> 2] | 0) + (4 - 1) & ~(4 - 1);
                      e4 = c2[f4 >> 2] | 0;
                      c2[d4 >> 2] = f4 + 4;
                      f4 = a3;
                      c2[f4 >> 2] = e4 & 65535;
                      c2[f4 + 4 >> 2] = 0;
                      break a;
                    }
                    case 15: {
                      f4 = (c2[d4 >> 2] | 0) + (4 - 1) & ~(4 - 1);
                      e4 = c2[f4 >> 2] | 0;
                      c2[d4 >> 2] = f4 + 4;
                      e4 = (e4 & 255) << 24 >> 24;
                      f4 = a3;
                      c2[f4 >> 2] = e4;
                      c2[f4 + 4 >> 2] = ((e4 | 0) < 0) << 31 >> 31;
                      break a;
                    }
                    case 16: {
                      f4 = (c2[d4 >> 2] | 0) + (4 - 1) & ~(4 - 1);
                      e4 = c2[f4 >> 2] | 0;
                      c2[d4 >> 2] = f4 + 4;
                      f4 = a3;
                      c2[f4 >> 2] = e4 & 255;
                      c2[f4 + 4 >> 2] = 0;
                      break a;
                    }
                    case 17: {
                      f4 = (c2[d4 >> 2] | 0) + (8 - 1) & ~(8 - 1);
                      g3 = +h2[f4 >> 3];
                      c2[d4 >> 2] = f4 + 8;
                      h2[a3 >> 3] = g3;
                      break a;
                    }
                    case 18: {
                      f4 = (c2[d4 >> 2] | 0) + (8 - 1) & ~(8 - 1);
                      g3 = +h2[f4 >> 3];
                      c2[d4 >> 2] = f4 + 8;
                      h2[a3 >> 3] = g3;
                      break a;
                    }
                    default:
                      break a;
                  }
                while (0);
            while (0);
          return;
        }
        function JB(b3, c3, e4, f4) {
          b3 = b3 | 0;
          c3 = c3 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          if (!((b3 | 0) == 0 & (c3 | 0) == 0))
            do {
              e4 = e4 + -1 | 0;
              a2[e4 >> 0] = d3[5694 + (b3 & 15) >> 0] | 0 | f4;
              b3 = AC(b3 | 0, c3 | 0, 4) | 0;
              c3 = A2;
            } while (!((b3 | 0) == 0 & (c3 | 0) == 0));
          return e4 | 0;
        }
        function KB(b3, c3, d4) {
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          if (!((b3 | 0) == 0 & (c3 | 0) == 0))
            do {
              d4 = d4 + -1 | 0;
              a2[d4 >> 0] = b3 & 7 | 48;
              b3 = AC(b3 | 0, c3 | 0, 3) | 0;
              c3 = A2;
            } while (!((b3 | 0) == 0 & (c3 | 0) == 0));
          return d4 | 0;
        }
        function LB(b3, c3, d4) {
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          if (c3 >>> 0 > 0 | (c3 | 0) == 0 & b3 >>> 0 > 4294967295) {
            while (1) {
              e4 = HC(b3 | 0, c3 | 0, 10, 0) | 0;
              d4 = d4 + -1 | 0;
              a2[d4 >> 0] = e4 & 255 | 48;
              e4 = b3;
              b3 = EC(b3 | 0, c3 | 0, 10, 0) | 0;
              if (!(c3 >>> 0 > 9 | (c3 | 0) == 9 & e4 >>> 0 > 4294967295))
                break;
              else
                c3 = A2;
            }
            c3 = b3;
          } else
            c3 = b3;
          if (c3)
            while (1) {
              d4 = d4 + -1 | 0;
              a2[d4 >> 0] = (c3 >>> 0) % 10 | 0 | 48;
              if (c3 >>> 0 < 10)
                break;
              else
                c3 = (c3 >>> 0) / 10 | 0;
            }
          return d4 | 0;
        }
        function MB(a3) {
          a3 = a3 | 0;
          return XB(a3, c2[(WB() | 0) + 188 >> 2] | 0) | 0;
        }
        function NB(b3, d4, e4) {
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          h3 = d4 & 255;
          f4 = (e4 | 0) != 0;
          a:
            do
              if (f4 & (b3 & 3 | 0) != 0) {
                g3 = d4 & 255;
                while (1) {
                  if ((a2[b3 >> 0] | 0) == g3 << 24 >> 24) {
                    i4 = 6;
                    break a;
                  }
                  b3 = b3 + 1 | 0;
                  e4 = e4 + -1 | 0;
                  f4 = (e4 | 0) != 0;
                  if (!(f4 & (b3 & 3 | 0) != 0)) {
                    i4 = 5;
                    break;
                  }
                }
              } else
                i4 = 5;
            while (0);
          if ((i4 | 0) == 5)
            if (f4)
              i4 = 6;
            else
              e4 = 0;
          b:
            do
              if ((i4 | 0) == 6) {
                g3 = d4 & 255;
                if ((a2[b3 >> 0] | 0) != g3 << 24 >> 24) {
                  f4 = P2(h3, 16843009) | 0;
                  c:
                    do
                      if (e4 >>> 0 > 3)
                        while (1) {
                          h3 = c2[b3 >> 2] ^ f4;
                          if ((h3 & -2139062144 ^ -2139062144) & h3 + -16843009 | 0)
                            break;
                          b3 = b3 + 4 | 0;
                          e4 = e4 + -4 | 0;
                          if (e4 >>> 0 <= 3) {
                            i4 = 11;
                            break c;
                          }
                        }
                      else
                        i4 = 11;
                    while (0);
                  if ((i4 | 0) == 11) {
                    if (!e4) {
                      e4 = 0;
                      break;
                    }
                  }
                  while (1) {
                    if ((a2[b3 >> 0] | 0) == g3 << 24 >> 24)
                      break b;
                    b3 = b3 + 1 | 0;
                    e4 = e4 + -1 | 0;
                    if (!e4) {
                      e4 = 0;
                      break;
                    }
                  }
                }
              }
            while (0);
          return (e4 | 0 ? b3 : 0) | 0;
        }
        function OB(a3, b3, c3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0;
          g3 = l3;
          l3 = l3 + 256 | 0;
          f4 = g3;
          if ((c3 | 0) > (d4 | 0) & (e4 & 73728 | 0) == 0) {
            e4 = c3 - d4 | 0;
            yC(f4 | 0, b3 | 0, (e4 >>> 0 < 256 ? e4 : 256) | 0) | 0;
            if (e4 >>> 0 > 255) {
              b3 = c3 - d4 | 0;
              do {
                GB(a3, f4, 256);
                e4 = e4 + -256 | 0;
              } while (e4 >>> 0 > 255);
              e4 = b3 & 255;
            }
            GB(a3, f4, e4);
          }
          l3 = g3;
          return;
        }
        function PB(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          if (!a3)
            a3 = 0;
          else
            a3 = UB(a3, b3, 0) | 0;
          return a3 | 0;
        }
        function QB(b3, e4, f4, g3, h3, i4) {
          b3 = b3 | 0;
          e4 = +e4;
          f4 = f4 | 0;
          g3 = g3 | 0;
          h3 = h3 | 0;
          i4 = i4 | 0;
          var j4 = 0, k4 = 0, m4 = 0, n3 = 0, o3 = 0, p4 = 0, q3 = 0, r3 = 0, s3 = 0, t3 = 0, u4 = 0, v4 = 0, w3 = 0, x4 = 0, y3 = 0, z3 = 0, B3 = 0, C3 = 0, D3 = 0, E3 = 0, F3 = 0, G3 = 0, H3 = 0;
          H3 = l3;
          l3 = l3 + 560 | 0;
          m4 = H3 + 8 | 0;
          u4 = H3;
          G3 = H3 + 524 | 0;
          F3 = G3;
          n3 = H3 + 512 | 0;
          c2[u4 >> 2] = 0;
          E3 = n3 + 12 | 0;
          RB(e4) | 0;
          if ((A2 | 0) < 0) {
            e4 = -e4;
            C3 = 1;
            B3 = 5659;
          } else {
            C3 = (h3 & 2049 | 0) != 0 & 1;
            B3 = (h3 & 2048 | 0) == 0 ? (h3 & 1 | 0) == 0 ? 5660 : 5665 : 5662;
          }
          RB(e4) | 0;
          D3 = A2 & 2146435072;
          do
            if (D3 >>> 0 < 2146435072 | (D3 | 0) == 2146435072 & 0 < 0) {
              r3 = +SB(e4, u4) * 2;
              j4 = r3 != 0;
              if (j4)
                c2[u4 >> 2] = (c2[u4 >> 2] | 0) + -1;
              w3 = i4 | 32;
              if ((w3 | 0) == 97) {
                s3 = i4 & 32;
                q3 = (s3 | 0) == 0 ? B3 : B3 + 9 | 0;
                p4 = C3 | 2;
                j4 = 12 - g3 | 0;
                do
                  if (!(g3 >>> 0 > 11 | (j4 | 0) == 0)) {
                    e4 = 8;
                    do {
                      j4 = j4 + -1 | 0;
                      e4 = e4 * 16;
                    } while ((j4 | 0) != 0);
                    if ((a2[q3 >> 0] | 0) == 45) {
                      e4 = -(e4 + (-r3 - e4));
                      break;
                    } else {
                      e4 = r3 + e4 - e4;
                      break;
                    }
                  } else
                    e4 = r3;
                while (0);
                k4 = c2[u4 >> 2] | 0;
                j4 = (k4 | 0) < 0 ? 0 - k4 | 0 : k4;
                j4 = LB(j4, ((j4 | 0) < 0) << 31 >> 31, E3) | 0;
                if ((j4 | 0) == (E3 | 0)) {
                  j4 = n3 + 11 | 0;
                  a2[j4 >> 0] = 48;
                }
                a2[j4 + -1 >> 0] = (k4 >> 31 & 2) + 43;
                o3 = j4 + -2 | 0;
                a2[o3 >> 0] = i4 + 15;
                n3 = (g3 | 0) < 1;
                m4 = (h3 & 8 | 0) == 0;
                j4 = G3;
                do {
                  D3 = ~~e4;
                  k4 = j4 + 1 | 0;
                  a2[j4 >> 0] = d3[5694 + D3 >> 0] | s3;
                  e4 = (e4 - +(D3 | 0)) * 16;
                  if ((k4 - F3 | 0) == 1 ? !(m4 & (n3 & e4 == 0)) : 0) {
                    a2[k4 >> 0] = 46;
                    j4 = j4 + 2 | 0;
                  } else
                    j4 = k4;
                } while (e4 != 0);
                D3 = j4 - F3 | 0;
                F3 = E3 - o3 | 0;
                E3 = (g3 | 0) != 0 & (D3 + -2 | 0) < (g3 | 0) ? g3 + 2 | 0 : D3;
                j4 = F3 + p4 + E3 | 0;
                OB(b3, 32, f4, j4, h3);
                GB(b3, q3, p4);
                OB(b3, 48, f4, j4, h3 ^ 65536);
                GB(b3, G3, D3);
                OB(b3, 48, E3 - D3 | 0, 0, 0);
                GB(b3, o3, F3);
                OB(b3, 32, f4, j4, h3 ^ 8192);
                break;
              }
              k4 = (g3 | 0) < 0 ? 6 : g3;
              if (j4) {
                j4 = (c2[u4 >> 2] | 0) + -28 | 0;
                c2[u4 >> 2] = j4;
                e4 = r3 * 268435456;
              } else {
                e4 = r3;
                j4 = c2[u4 >> 2] | 0;
              }
              D3 = (j4 | 0) < 0 ? m4 : m4 + 288 | 0;
              m4 = D3;
              do {
                y3 = ~~e4 >>> 0;
                c2[m4 >> 2] = y3;
                m4 = m4 + 4 | 0;
                e4 = (e4 - +(y3 >>> 0)) * 1e9;
              } while (e4 != 0);
              if ((j4 | 0) > 0) {
                n3 = D3;
                p4 = m4;
                while (1) {
                  o3 = (j4 | 0) < 29 ? j4 : 29;
                  j4 = p4 + -4 | 0;
                  if (j4 >>> 0 >= n3 >>> 0) {
                    m4 = 0;
                    do {
                      x4 = zC(c2[j4 >> 2] | 0, 0, o3 | 0) | 0;
                      x4 = xC(x4 | 0, A2 | 0, m4 | 0, 0) | 0;
                      y3 = A2;
                      v4 = HC(x4 | 0, y3 | 0, 1e9, 0) | 0;
                      c2[j4 >> 2] = v4;
                      m4 = EC(x4 | 0, y3 | 0, 1e9, 0) | 0;
                      j4 = j4 + -4 | 0;
                    } while (j4 >>> 0 >= n3 >>> 0);
                    if (m4) {
                      n3 = n3 + -4 | 0;
                      c2[n3 >> 2] = m4;
                    }
                  }
                  m4 = p4;
                  while (1) {
                    if (m4 >>> 0 <= n3 >>> 0)
                      break;
                    j4 = m4 + -4 | 0;
                    if (!(c2[j4 >> 2] | 0))
                      m4 = j4;
                    else
                      break;
                  }
                  j4 = (c2[u4 >> 2] | 0) - o3 | 0;
                  c2[u4 >> 2] = j4;
                  if ((j4 | 0) > 0)
                    p4 = m4;
                  else
                    break;
                }
              } else
                n3 = D3;
              if ((j4 | 0) < 0) {
                g3 = ((k4 + 25 | 0) / 9 | 0) + 1 | 0;
                t3 = (w3 | 0) == 102;
                do {
                  s3 = 0 - j4 | 0;
                  s3 = (s3 | 0) < 9 ? s3 : 9;
                  if (n3 >>> 0 < m4 >>> 0) {
                    o3 = (1 << s3) + -1 | 0;
                    p4 = 1e9 >>> s3;
                    q3 = 0;
                    j4 = n3;
                    do {
                      y3 = c2[j4 >> 2] | 0;
                      c2[j4 >> 2] = (y3 >>> s3) + q3;
                      q3 = P2(y3 & o3, p4) | 0;
                      j4 = j4 + 4 | 0;
                    } while (j4 >>> 0 < m4 >>> 0);
                    j4 = (c2[n3 >> 2] | 0) == 0 ? n3 + 4 | 0 : n3;
                    if (!q3) {
                      n3 = j4;
                      j4 = m4;
                    } else {
                      c2[m4 >> 2] = q3;
                      n3 = j4;
                      j4 = m4 + 4 | 0;
                    }
                  } else {
                    n3 = (c2[n3 >> 2] | 0) == 0 ? n3 + 4 | 0 : n3;
                    j4 = m4;
                  }
                  m4 = t3 ? D3 : n3;
                  m4 = (j4 - m4 >> 2 | 0) > (g3 | 0) ? m4 + (g3 << 2) | 0 : j4;
                  j4 = (c2[u4 >> 2] | 0) + s3 | 0;
                  c2[u4 >> 2] = j4;
                } while ((j4 | 0) < 0);
                j4 = n3;
                g3 = m4;
              } else {
                j4 = n3;
                g3 = m4;
              }
              y3 = D3;
              if (j4 >>> 0 < g3 >>> 0) {
                m4 = (y3 - j4 >> 2) * 9 | 0;
                o3 = c2[j4 >> 2] | 0;
                if (o3 >>> 0 >= 10) {
                  n3 = 10;
                  do {
                    n3 = n3 * 10 | 0;
                    m4 = m4 + 1 | 0;
                  } while (o3 >>> 0 >= n3 >>> 0);
                }
              } else
                m4 = 0;
              t3 = (w3 | 0) == 103;
              v4 = (k4 | 0) != 0;
              n3 = k4 - ((w3 | 0) != 102 ? m4 : 0) + ((v4 & t3) << 31 >> 31) | 0;
              if ((n3 | 0) < (((g3 - y3 >> 2) * 9 | 0) + -9 | 0)) {
                n3 = n3 + 9216 | 0;
                s3 = D3 + 4 + (((n3 | 0) / 9 | 0) + -1024 << 2) | 0;
                n3 = ((n3 | 0) % 9 | 0) + 1 | 0;
                if ((n3 | 0) < 9) {
                  o3 = 10;
                  do {
                    o3 = o3 * 10 | 0;
                    n3 = n3 + 1 | 0;
                  } while ((n3 | 0) != 9);
                } else
                  o3 = 10;
                p4 = c2[s3 >> 2] | 0;
                q3 = (p4 >>> 0) % (o3 >>> 0) | 0;
                n3 = (s3 + 4 | 0) == (g3 | 0);
                if (!(n3 & (q3 | 0) == 0)) {
                  r3 = (((p4 >>> 0) / (o3 >>> 0) | 0) & 1 | 0) == 0 ? 9007199254740992 : 9007199254740994;
                  x4 = (o3 | 0) / 2 | 0;
                  e4 = q3 >>> 0 < x4 >>> 0 ? 0.5 : n3 & (q3 | 0) == (x4 | 0) ? 1 : 1.5;
                  if (C3) {
                    x4 = (a2[B3 >> 0] | 0) == 45;
                    e4 = x4 ? -e4 : e4;
                    r3 = x4 ? -r3 : r3;
                  }
                  n3 = p4 - q3 | 0;
                  c2[s3 >> 2] = n3;
                  if (r3 + e4 != r3) {
                    x4 = n3 + o3 | 0;
                    c2[s3 >> 2] = x4;
                    if (x4 >>> 0 > 999999999) {
                      m4 = s3;
                      while (1) {
                        n3 = m4 + -4 | 0;
                        c2[m4 >> 2] = 0;
                        if (n3 >>> 0 < j4 >>> 0) {
                          j4 = j4 + -4 | 0;
                          c2[j4 >> 2] = 0;
                        }
                        x4 = (c2[n3 >> 2] | 0) + 1 | 0;
                        c2[n3 >> 2] = x4;
                        if (x4 >>> 0 > 999999999)
                          m4 = n3;
                        else
                          break;
                      }
                    } else
                      n3 = s3;
                    m4 = (y3 - j4 >> 2) * 9 | 0;
                    p4 = c2[j4 >> 2] | 0;
                    if (p4 >>> 0 >= 10) {
                      o3 = 10;
                      do {
                        o3 = o3 * 10 | 0;
                        m4 = m4 + 1 | 0;
                      } while (p4 >>> 0 >= o3 >>> 0);
                    }
                  } else
                    n3 = s3;
                } else
                  n3 = s3;
                n3 = n3 + 4 | 0;
                n3 = g3 >>> 0 > n3 >>> 0 ? n3 : g3;
                x4 = j4;
              } else {
                n3 = g3;
                x4 = j4;
              }
              w3 = n3;
              while (1) {
                if (w3 >>> 0 <= x4 >>> 0) {
                  u4 = 0;
                  break;
                }
                j4 = w3 + -4 | 0;
                if (!(c2[j4 >> 2] | 0))
                  w3 = j4;
                else {
                  u4 = 1;
                  break;
                }
              }
              g3 = 0 - m4 | 0;
              do
                if (t3) {
                  j4 = ((v4 ^ 1) & 1) + k4 | 0;
                  if ((j4 | 0) > (m4 | 0) & (m4 | 0) > -5) {
                    o3 = i4 + -1 | 0;
                    k4 = j4 + -1 - m4 | 0;
                  } else {
                    o3 = i4 + -2 | 0;
                    k4 = j4 + -1 | 0;
                  }
                  j4 = h3 & 8;
                  if (!j4) {
                    if (u4 ? (z3 = c2[w3 + -4 >> 2] | 0, (z3 | 0) != 0) : 0) {
                      if (!((z3 >>> 0) % 10 | 0)) {
                        n3 = 0;
                        j4 = 10;
                        do {
                          j4 = j4 * 10 | 0;
                          n3 = n3 + 1 | 0;
                        } while (!((z3 >>> 0) % (j4 >>> 0) | 0 | 0));
                      } else
                        n3 = 0;
                    } else
                      n3 = 9;
                    j4 = ((w3 - y3 >> 2) * 9 | 0) + -9 | 0;
                    if ((o3 | 32 | 0) == 102) {
                      s3 = j4 - n3 | 0;
                      s3 = (s3 | 0) > 0 ? s3 : 0;
                      k4 = (k4 | 0) < (s3 | 0) ? k4 : s3;
                      s3 = 0;
                      break;
                    } else {
                      s3 = j4 + m4 - n3 | 0;
                      s3 = (s3 | 0) > 0 ? s3 : 0;
                      k4 = (k4 | 0) < (s3 | 0) ? k4 : s3;
                      s3 = 0;
                      break;
                    }
                  } else
                    s3 = j4;
                } else {
                  o3 = i4;
                  s3 = h3 & 8;
                }
              while (0);
              t3 = k4 | s3;
              p4 = (t3 | 0) != 0 & 1;
              q3 = (o3 | 32 | 0) == 102;
              if (q3) {
                v4 = 0;
                j4 = (m4 | 0) > 0 ? m4 : 0;
              } else {
                j4 = (m4 | 0) < 0 ? g3 : m4;
                j4 = LB(j4, ((j4 | 0) < 0) << 31 >> 31, E3) | 0;
                n3 = E3;
                if ((n3 - j4 | 0) < 2)
                  do {
                    j4 = j4 + -1 | 0;
                    a2[j4 >> 0] = 48;
                  } while ((n3 - j4 | 0) < 2);
                a2[j4 + -1 >> 0] = (m4 >> 31 & 2) + 43;
                j4 = j4 + -2 | 0;
                a2[j4 >> 0] = o3;
                v4 = j4;
                j4 = n3 - j4 | 0;
              }
              j4 = C3 + 1 + k4 + p4 + j4 | 0;
              OB(b3, 32, f4, j4, h3);
              GB(b3, B3, C3);
              OB(b3, 48, f4, j4, h3 ^ 65536);
              if (q3) {
                o3 = x4 >>> 0 > D3 >>> 0 ? D3 : x4;
                s3 = G3 + 9 | 0;
                p4 = s3;
                q3 = G3 + 8 | 0;
                n3 = o3;
                do {
                  m4 = LB(c2[n3 >> 2] | 0, 0, s3) | 0;
                  if ((n3 | 0) == (o3 | 0)) {
                    if ((m4 | 0) == (s3 | 0)) {
                      a2[q3 >> 0] = 48;
                      m4 = q3;
                    }
                  } else if (m4 >>> 0 > G3 >>> 0) {
                    yC(G3 | 0, 48, m4 - F3 | 0) | 0;
                    do
                      m4 = m4 + -1 | 0;
                    while (m4 >>> 0 > G3 >>> 0);
                  }
                  GB(b3, m4, p4 - m4 | 0);
                  n3 = n3 + 4 | 0;
                } while (n3 >>> 0 <= D3 >>> 0);
                if (t3 | 0)
                  GB(b3, 5710, 1);
                if (n3 >>> 0 < w3 >>> 0 & (k4 | 0) > 0)
                  while (1) {
                    m4 = LB(c2[n3 >> 2] | 0, 0, s3) | 0;
                    if (m4 >>> 0 > G3 >>> 0) {
                      yC(G3 | 0, 48, m4 - F3 | 0) | 0;
                      do
                        m4 = m4 + -1 | 0;
                      while (m4 >>> 0 > G3 >>> 0);
                    }
                    GB(b3, m4, (k4 | 0) < 9 ? k4 : 9);
                    n3 = n3 + 4 | 0;
                    m4 = k4 + -9 | 0;
                    if (!(n3 >>> 0 < w3 >>> 0 & (k4 | 0) > 9)) {
                      k4 = m4;
                      break;
                    } else
                      k4 = m4;
                  }
                OB(b3, 48, k4 + 9 | 0, 9, 0);
              } else {
                t3 = u4 ? w3 : x4 + 4 | 0;
                if ((k4 | 0) > -1) {
                  u4 = G3 + 9 | 0;
                  s3 = (s3 | 0) == 0;
                  g3 = u4;
                  p4 = 0 - F3 | 0;
                  q3 = G3 + 8 | 0;
                  o3 = x4;
                  do {
                    m4 = LB(c2[o3 >> 2] | 0, 0, u4) | 0;
                    if ((m4 | 0) == (u4 | 0)) {
                      a2[q3 >> 0] = 48;
                      m4 = q3;
                    }
                    do
                      if ((o3 | 0) == (x4 | 0)) {
                        n3 = m4 + 1 | 0;
                        GB(b3, m4, 1);
                        if (s3 & (k4 | 0) < 1) {
                          m4 = n3;
                          break;
                        }
                        GB(b3, 5710, 1);
                        m4 = n3;
                      } else {
                        if (m4 >>> 0 <= G3 >>> 0)
                          break;
                        yC(G3 | 0, 48, m4 + p4 | 0) | 0;
                        do
                          m4 = m4 + -1 | 0;
                        while (m4 >>> 0 > G3 >>> 0);
                      }
                    while (0);
                    F3 = g3 - m4 | 0;
                    GB(b3, m4, (k4 | 0) > (F3 | 0) ? F3 : k4);
                    k4 = k4 - F3 | 0;
                    o3 = o3 + 4 | 0;
                  } while (o3 >>> 0 < t3 >>> 0 & (k4 | 0) > -1);
                }
                OB(b3, 48, k4 + 18 | 0, 18, 0);
                GB(b3, v4, E3 - v4 | 0);
              }
              OB(b3, 32, f4, j4, h3 ^ 8192);
            } else {
              G3 = (i4 & 32 | 0) != 0;
              j4 = C3 + 3 | 0;
              OB(b3, 32, f4, j4, h3 & -65537);
              GB(b3, B3, C3);
              GB(b3, e4 != e4 | false ? G3 ? 5686 : 5690 : G3 ? 5678 : 5682, 3);
              OB(b3, 32, f4, j4, h3 ^ 8192);
            }
          while (0);
          l3 = H3;
          return ((j4 | 0) < (f4 | 0) ? f4 : j4) | 0;
        }
        function RB(a3) {
          a3 = +a3;
          var b3 = 0;
          h2[j3 >> 3] = a3;
          b3 = c2[j3 >> 2] | 0;
          A2 = c2[j3 + 4 >> 2] | 0;
          return b3 | 0;
        }
        function SB(a3, b3) {
          a3 = +a3;
          b3 = b3 | 0;
          return + +TB(a3, b3);
        }
        function TB(a3, b3) {
          a3 = +a3;
          b3 = b3 | 0;
          var d4 = 0, e4 = 0, f4 = 0;
          h2[j3 >> 3] = a3;
          d4 = c2[j3 >> 2] | 0;
          e4 = c2[j3 + 4 >> 2] | 0;
          f4 = AC(d4 | 0, e4 | 0, 52) | 0;
          switch (f4 & 2047) {
            case 0: {
              if (a3 != 0) {
                a3 = +TB(a3 * 18446744073709552e3, b3);
                d4 = (c2[b3 >> 2] | 0) + -64 | 0;
              } else
                d4 = 0;
              c2[b3 >> 2] = d4;
              break;
            }
            case 2047:
              break;
            default: {
              c2[b3 >> 2] = (f4 & 2047) + -1022;
              c2[j3 >> 2] = d4;
              c2[j3 + 4 >> 2] = e4 & -2146435073 | 1071644672;
              a3 = +h2[j3 >> 3];
            }
          }
          return +a3;
        }
        function UB(b3, d4, e4) {
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          do
            if (b3) {
              if (d4 >>> 0 < 128) {
                a2[b3 >> 0] = d4;
                b3 = 1;
                break;
              }
              if (!(c2[c2[(VB() | 0) + 188 >> 2] >> 2] | 0))
                if ((d4 & -128 | 0) == 57216) {
                  a2[b3 >> 0] = d4;
                  b3 = 1;
                  break;
                } else {
                  c2[(vB() | 0) >> 2] = 84;
                  b3 = -1;
                  break;
                }
              if (d4 >>> 0 < 2048) {
                a2[b3 >> 0] = d4 >>> 6 | 192;
                a2[b3 + 1 >> 0] = d4 & 63 | 128;
                b3 = 2;
                break;
              }
              if (d4 >>> 0 < 55296 | (d4 & -8192 | 0) == 57344) {
                a2[b3 >> 0] = d4 >>> 12 | 224;
                a2[b3 + 1 >> 0] = d4 >>> 6 & 63 | 128;
                a2[b3 + 2 >> 0] = d4 & 63 | 128;
                b3 = 3;
                break;
              }
              if ((d4 + -65536 | 0) >>> 0 < 1048576) {
                a2[b3 >> 0] = d4 >>> 18 | 240;
                a2[b3 + 1 >> 0] = d4 >>> 12 & 63 | 128;
                a2[b3 + 2 >> 0] = d4 >>> 6 & 63 | 128;
                a2[b3 + 3 >> 0] = d4 & 63 | 128;
                b3 = 4;
                break;
              } else {
                c2[(vB() | 0) >> 2] = 84;
                b3 = -1;
                break;
              }
            } else
              b3 = 1;
          while (0);
          return b3 | 0;
        }
        function VB() {
          return xB() | 0;
        }
        function WB() {
          return xB() | 0;
        }
        function XB(b3, e4) {
          b3 = b3 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0;
          g3 = 0;
          while (1) {
            if ((d3[5712 + g3 >> 0] | 0) == (b3 | 0)) {
              b3 = 2;
              break;
            }
            f4 = g3 + 1 | 0;
            if ((f4 | 0) == 87) {
              f4 = 5800;
              g3 = 87;
              b3 = 5;
              break;
            } else
              g3 = f4;
          }
          if ((b3 | 0) == 2)
            if (!g3)
              f4 = 5800;
            else {
              f4 = 5800;
              b3 = 5;
            }
          if ((b3 | 0) == 5)
            while (1) {
              do {
                b3 = f4;
                f4 = f4 + 1 | 0;
              } while ((a2[b3 >> 0] | 0) != 0);
              g3 = g3 + -1 | 0;
              if (!g3)
                break;
              else
                b3 = 5;
            }
          return YB(f4, c2[e4 + 20 >> 2] | 0) | 0;
        }
        function YB(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return ZB(a3, b3) | 0;
        }
        function ZB(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          if (!b3)
            b3 = 0;
          else
            b3 = _B(c2[b3 >> 2] | 0, c2[b3 + 4 >> 2] | 0, a3) | 0;
          return (b3 | 0 ? b3 : a3) | 0;
        }
        function _B(b3, d4, e4) {
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, l4 = 0, m4 = 0, n3 = 0, o3 = 0;
          o3 = (c2[b3 >> 2] | 0) + 1794895138 | 0;
          h3 = $B(c2[b3 + 8 >> 2] | 0, o3) | 0;
          f4 = $B(c2[b3 + 12 >> 2] | 0, o3) | 0;
          g3 = $B(c2[b3 + 16 >> 2] | 0, o3) | 0;
          a:
            do
              if ((h3 >>> 0 < d4 >>> 2 >>> 0 ? (n3 = d4 - (h3 << 2) | 0, f4 >>> 0 < n3 >>> 0 & g3 >>> 0 < n3 >>> 0) : 0) ? ((g3 | f4) & 3 | 0) == 0 : 0) {
                n3 = f4 >>> 2;
                m4 = g3 >>> 2;
                l4 = 0;
                while (1) {
                  j4 = h3 >>> 1;
                  k4 = l4 + j4 | 0;
                  i4 = k4 << 1;
                  g3 = i4 + n3 | 0;
                  f4 = $B(c2[b3 + (g3 << 2) >> 2] | 0, o3) | 0;
                  g3 = $B(c2[b3 + (g3 + 1 << 2) >> 2] | 0, o3) | 0;
                  if (!(g3 >>> 0 < d4 >>> 0 & f4 >>> 0 < (d4 - g3 | 0) >>> 0)) {
                    f4 = 0;
                    break a;
                  }
                  if (a2[b3 + (g3 + f4) >> 0] | 0) {
                    f4 = 0;
                    break a;
                  }
                  f4 = AB(e4, b3 + g3 | 0) | 0;
                  if (!f4)
                    break;
                  f4 = (f4 | 0) < 0;
                  if ((h3 | 0) == 1) {
                    f4 = 0;
                    break a;
                  } else {
                    l4 = f4 ? l4 : k4;
                    h3 = f4 ? j4 : h3 - j4 | 0;
                  }
                }
                f4 = i4 + m4 | 0;
                g3 = $B(c2[b3 + (f4 << 2) >> 2] | 0, o3) | 0;
                f4 = $B(c2[b3 + (f4 + 1 << 2) >> 2] | 0, o3) | 0;
                if (f4 >>> 0 < d4 >>> 0 & g3 >>> 0 < (d4 - f4 | 0) >>> 0)
                  f4 = (a2[b3 + (f4 + g3) >> 0] | 0) == 0 ? b3 + f4 | 0 : 0;
                else
                  f4 = 0;
              } else
                f4 = 0;
            while (0);
          return f4 | 0;
        }
        function $B(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          var c3 = 0;
          c3 = IC(a3 | 0) | 0;
          return ((b3 | 0) == 0 ? a3 : c3) | 0;
        }
        function aC(b3, d4, e4) {
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0, j4 = 0;
          f4 = e4 + 16 | 0;
          g3 = c2[f4 >> 2] | 0;
          if (!g3) {
            if (!(bC(e4) | 0)) {
              g3 = c2[f4 >> 2] | 0;
              h3 = 5;
            } else
              f4 = 0;
          } else
            h3 = 5;
          a:
            do
              if ((h3 | 0) == 5) {
                j4 = e4 + 20 | 0;
                i4 = c2[j4 >> 2] | 0;
                f4 = i4;
                if ((g3 - i4 | 0) >>> 0 < d4 >>> 0) {
                  f4 = sb[c2[e4 + 36 >> 2] & 7](e4, b3, d4) | 0;
                  break;
                }
                b:
                  do
                    if ((a2[e4 + 75 >> 0] | 0) > -1) {
                      i4 = d4;
                      while (1) {
                        if (!i4) {
                          h3 = 0;
                          g3 = b3;
                          break b;
                        }
                        g3 = i4 + -1 | 0;
                        if ((a2[b3 + g3 >> 0] | 0) == 10)
                          break;
                        else
                          i4 = g3;
                      }
                      f4 = sb[c2[e4 + 36 >> 2] & 7](e4, b3, i4) | 0;
                      if (f4 >>> 0 < i4 >>> 0)
                        break a;
                      h3 = i4;
                      g3 = b3 + i4 | 0;
                      d4 = d4 - i4 | 0;
                      f4 = c2[j4 >> 2] | 0;
                    } else {
                      h3 = 0;
                      g3 = b3;
                    }
                  while (0);
                BC(f4 | 0, g3 | 0, d4 | 0) | 0;
                c2[j4 >> 2] = (c2[j4 >> 2] | 0) + d4;
                f4 = h3 + d4 | 0;
              }
            while (0);
          return f4 | 0;
        }
        function bC(b3) {
          b3 = b3 | 0;
          var d4 = 0, e4 = 0;
          d4 = b3 + 74 | 0;
          e4 = a2[d4 >> 0] | 0;
          a2[d4 >> 0] = e4 + 255 | e4;
          d4 = c2[b3 >> 2] | 0;
          if (!(d4 & 8)) {
            c2[b3 + 8 >> 2] = 0;
            c2[b3 + 4 >> 2] = 0;
            e4 = c2[b3 + 44 >> 2] | 0;
            c2[b3 + 28 >> 2] = e4;
            c2[b3 + 20 >> 2] = e4;
            c2[b3 + 16 >> 2] = e4 + (c2[b3 + 48 >> 2] | 0);
            b3 = 0;
          } else {
            c2[b3 >> 2] = d4 | 32;
            b3 = -1;
          }
          return b3 | 0;
        }
        function cC(a3, b3) {
          a3 = T2(a3);
          b3 = T2(b3);
          var c3 = 0, d4 = 0;
          c3 = dC(a3) | 0;
          do
            if ((c3 & 2147483647) >>> 0 <= 2139095040) {
              d4 = dC(b3) | 0;
              if ((d4 & 2147483647) >>> 0 <= 2139095040)
                if ((d4 ^ c3 | 0) < 0) {
                  a3 = (c3 | 0) < 0 ? b3 : a3;
                  break;
                } else {
                  a3 = a3 < b3 ? b3 : a3;
                  break;
                }
            } else
              a3 = b3;
          while (0);
          return T2(a3);
        }
        function dC(a3) {
          a3 = T2(a3);
          return (g2[j3 >> 2] = a3, c2[j3 >> 2] | 0) | 0;
        }
        function eC(a3, b3) {
          a3 = T2(a3);
          b3 = T2(b3);
          var c3 = 0, d4 = 0;
          c3 = fC(a3) | 0;
          do
            if ((c3 & 2147483647) >>> 0 <= 2139095040) {
              d4 = fC(b3) | 0;
              if ((d4 & 2147483647) >>> 0 <= 2139095040)
                if ((d4 ^ c3 | 0) < 0) {
                  a3 = (c3 | 0) < 0 ? a3 : b3;
                  break;
                } else {
                  a3 = a3 < b3 ? a3 : b3;
                  break;
                }
            } else
              a3 = b3;
          while (0);
          return T2(a3);
        }
        function fC(a3) {
          a3 = T2(a3);
          return (g2[j3 >> 2] = a3, c2[j3 >> 2] | 0) | 0;
        }
        function gC(a3, b3) {
          a3 = T2(a3);
          b3 = T2(b3);
          var d4 = 0, e4 = 0, f4 = 0, h3 = 0, i4 = 0, k4 = 0, l4 = 0, m4 = 0;
          h3 = (g2[j3 >> 2] = a3, c2[j3 >> 2] | 0);
          k4 = (g2[j3 >> 2] = b3, c2[j3 >> 2] | 0);
          d4 = h3 >>> 23 & 255;
          i4 = k4 >>> 23 & 255;
          l4 = h3 & -2147483648;
          f4 = k4 << 1;
          a:
            do
              if ((f4 | 0) != 0 ? !((d4 | 0) == 255 | ((hC(b3) | 0) & 2147483647) >>> 0 > 2139095040) : 0) {
                e4 = h3 << 1;
                if (e4 >>> 0 <= f4 >>> 0) {
                  b3 = T2(a3 * T2(0));
                  return T2((e4 | 0) == (f4 | 0) ? b3 : a3);
                }
                if (!d4) {
                  d4 = h3 << 9;
                  if ((d4 | 0) > -1) {
                    e4 = d4;
                    d4 = 0;
                    do {
                      d4 = d4 + -1 | 0;
                      e4 = e4 << 1;
                    } while ((e4 | 0) > -1);
                  } else
                    d4 = 0;
                  e4 = h3 << 1 - d4;
                } else
                  e4 = h3 & 8388607 | 8388608;
                if (!i4) {
                  h3 = k4 << 9;
                  if ((h3 | 0) > -1) {
                    f4 = 0;
                    do {
                      f4 = f4 + -1 | 0;
                      h3 = h3 << 1;
                    } while ((h3 | 0) > -1);
                  } else
                    f4 = 0;
                  i4 = f4;
                  k4 = k4 << 1 - f4;
                } else
                  k4 = k4 & 8388607 | 8388608;
                f4 = e4 - k4 | 0;
                h3 = (f4 | 0) > -1;
                b:
                  do
                    if ((d4 | 0) > (i4 | 0)) {
                      while (1) {
                        if (h3)
                          if (!f4)
                            break;
                          else
                            e4 = f4;
                        e4 = e4 << 1;
                        d4 = d4 + -1 | 0;
                        f4 = e4 - k4 | 0;
                        h3 = (f4 | 0) > -1;
                        if ((d4 | 0) <= (i4 | 0))
                          break b;
                      }
                      b3 = T2(a3 * T2(0));
                      break a;
                    }
                  while (0);
                if (h3)
                  if (!f4) {
                    b3 = T2(a3 * T2(0));
                    break;
                  } else
                    e4 = f4;
                if (e4 >>> 0 < 8388608)
                  do {
                    e4 = e4 << 1;
                    d4 = d4 + -1 | 0;
                  } while (e4 >>> 0 < 8388608);
                if ((d4 | 0) > 0)
                  d4 = e4 + -8388608 | d4 << 23;
                else
                  d4 = e4 >>> (1 - d4 | 0);
                b3 = (c2[j3 >> 2] = d4 | l4, T2(g2[j3 >> 2]));
              } else
                m4 = 3;
            while (0);
          if ((m4 | 0) == 3) {
            b3 = T2(a3 * b3);
            b3 = T2(b3 / b3);
          }
          return T2(b3);
        }
        function hC(a3) {
          a3 = T2(a3);
          return (g2[j3 >> 2] = a3, c2[j3 >> 2] | 0) | 0;
        }
        function iC(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return CB(c2[582] | 0, a3, b3) | 0;
        }
        function jC(a3) {
          a3 = a3 | 0;
          Ta();
        }
        function kC(a3) {
          a3 = a3 | 0;
          return;
        }
        function lC(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return 0;
        }
        function mC(a3) {
          a3 = a3 | 0;
          if ((nC(a3 + 4 | 0) | 0) == -1) {
            nb[c2[(c2[a3 >> 2] | 0) + 8 >> 2] & 127](a3);
            a3 = 1;
          } else
            a3 = 0;
          return a3 | 0;
        }
        function nC(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = c2[a3 >> 2] | 0;
          c2[a3 >> 2] = b3 + -1;
          return b3 + -1 | 0;
        }
        function oC(a3) {
          a3 = a3 | 0;
          if (mC(a3) | 0)
            pC(a3);
          return;
        }
        function pC(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = a3 + 8 | 0;
          if (!((c2[b3 >> 2] | 0) != 0 ? (nC(b3) | 0) != -1 : 0))
            nb[c2[(c2[a3 >> 2] | 0) + 16 >> 2] & 127](a3);
          return;
        }
        function qC(a3) {
          a3 = a3 | 0;
          var b3 = 0;
          b3 = (a3 | 0) == 0 ? 1 : a3;
          while (1) {
            a3 = oB(b3) | 0;
            if (a3 | 0)
              break;
            a3 = uC() | 0;
            if (!a3) {
              a3 = 0;
              break;
            }
            Fb[a3 & 0]();
          }
          return a3 | 0;
        }
        function rC(a3) {
          a3 = a3 | 0;
          return qC(a3) | 0;
        }
        function sC(a3) {
          a3 = a3 | 0;
          pB(a3);
          return;
        }
        function tC(b3) {
          b3 = b3 | 0;
          if ((a2[b3 + 11 >> 0] | 0) < 0)
            sC(c2[b3 >> 2] | 0);
          return;
        }
        function uC() {
          var a3 = 0;
          a3 = c2[2923] | 0;
          c2[2923] = a3 + 0;
          return a3 | 0;
        }
        function vC() {
        }
        function wC(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          d4 = b3 - d4 - (c3 >>> 0 > a3 >>> 0 | 0) >>> 0;
          return (A2 = d4, a3 - c3 >>> 0 | 0) | 0;
        }
        function xC(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          c3 = a3 + c3 >>> 0;
          return (A2 = b3 + d4 + (c3 >>> 0 < a3 >>> 0 | 0) >>> 0, c3 | 0) | 0;
        }
        function yC(b3, d4, e4) {
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0, i4 = 0;
          h3 = b3 + e4 | 0;
          d4 = d4 & 255;
          if ((e4 | 0) >= 67) {
            while (b3 & 3) {
              a2[b3 >> 0] = d4;
              b3 = b3 + 1 | 0;
            }
            f4 = h3 & -4 | 0;
            g3 = f4 - 64 | 0;
            i4 = d4 | d4 << 8 | d4 << 16 | d4 << 24;
            while ((b3 | 0) <= (g3 | 0)) {
              c2[b3 >> 2] = i4;
              c2[b3 + 4 >> 2] = i4;
              c2[b3 + 8 >> 2] = i4;
              c2[b3 + 12 >> 2] = i4;
              c2[b3 + 16 >> 2] = i4;
              c2[b3 + 20 >> 2] = i4;
              c2[b3 + 24 >> 2] = i4;
              c2[b3 + 28 >> 2] = i4;
              c2[b3 + 32 >> 2] = i4;
              c2[b3 + 36 >> 2] = i4;
              c2[b3 + 40 >> 2] = i4;
              c2[b3 + 44 >> 2] = i4;
              c2[b3 + 48 >> 2] = i4;
              c2[b3 + 52 >> 2] = i4;
              c2[b3 + 56 >> 2] = i4;
              c2[b3 + 60 >> 2] = i4;
              b3 = b3 + 64 | 0;
            }
            while ((b3 | 0) < (f4 | 0)) {
              c2[b3 >> 2] = i4;
              b3 = b3 + 4 | 0;
            }
          }
          while ((b3 | 0) < (h3 | 0)) {
            a2[b3 >> 0] = d4;
            b3 = b3 + 1 | 0;
          }
          return h3 - e4 | 0;
        }
        function zC(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          if ((c3 | 0) < 32) {
            A2 = b3 << c3 | (a3 & (1 << c3) - 1 << 32 - c3) >>> 32 - c3;
            return a3 << c3;
          }
          A2 = a3 << c3 - 32;
          return 0;
        }
        function AC(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          if ((c3 | 0) < 32) {
            A2 = b3 >>> c3;
            return a3 >>> c3 | (b3 & (1 << c3) - 1) << 32 - c3;
          }
          A2 = 0;
          return b3 >>> c3 - 32 | 0;
        }
        function BC(b3, d4, e4) {
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0, h3 = 0;
          if ((e4 | 0) >= 8192)
            return Oa(b3 | 0, d4 | 0, e4 | 0) | 0;
          h3 = b3 | 0;
          g3 = b3 + e4 | 0;
          if ((b3 & 3) == (d4 & 3)) {
            while (b3 & 3) {
              if (!e4)
                return h3 | 0;
              a2[b3 >> 0] = a2[d4 >> 0] | 0;
              b3 = b3 + 1 | 0;
              d4 = d4 + 1 | 0;
              e4 = e4 - 1 | 0;
            }
            e4 = g3 & -4 | 0;
            f4 = e4 - 64 | 0;
            while ((b3 | 0) <= (f4 | 0)) {
              c2[b3 >> 2] = c2[d4 >> 2];
              c2[b3 + 4 >> 2] = c2[d4 + 4 >> 2];
              c2[b3 + 8 >> 2] = c2[d4 + 8 >> 2];
              c2[b3 + 12 >> 2] = c2[d4 + 12 >> 2];
              c2[b3 + 16 >> 2] = c2[d4 + 16 >> 2];
              c2[b3 + 20 >> 2] = c2[d4 + 20 >> 2];
              c2[b3 + 24 >> 2] = c2[d4 + 24 >> 2];
              c2[b3 + 28 >> 2] = c2[d4 + 28 >> 2];
              c2[b3 + 32 >> 2] = c2[d4 + 32 >> 2];
              c2[b3 + 36 >> 2] = c2[d4 + 36 >> 2];
              c2[b3 + 40 >> 2] = c2[d4 + 40 >> 2];
              c2[b3 + 44 >> 2] = c2[d4 + 44 >> 2];
              c2[b3 + 48 >> 2] = c2[d4 + 48 >> 2];
              c2[b3 + 52 >> 2] = c2[d4 + 52 >> 2];
              c2[b3 + 56 >> 2] = c2[d4 + 56 >> 2];
              c2[b3 + 60 >> 2] = c2[d4 + 60 >> 2];
              b3 = b3 + 64 | 0;
              d4 = d4 + 64 | 0;
            }
            while ((b3 | 0) < (e4 | 0)) {
              c2[b3 >> 2] = c2[d4 >> 2];
              b3 = b3 + 4 | 0;
              d4 = d4 + 4 | 0;
            }
          } else {
            e4 = g3 - 4 | 0;
            while ((b3 | 0) < (e4 | 0)) {
              a2[b3 >> 0] = a2[d4 >> 0] | 0;
              a2[b3 + 1 >> 0] = a2[d4 + 1 >> 0] | 0;
              a2[b3 + 2 >> 0] = a2[d4 + 2 >> 0] | 0;
              a2[b3 + 3 >> 0] = a2[d4 + 3 >> 0] | 0;
              b3 = b3 + 4 | 0;
              d4 = d4 + 4 | 0;
            }
          }
          while ((b3 | 0) < (g3 | 0)) {
            a2[b3 >> 0] = a2[d4 >> 0] | 0;
            b3 = b3 + 1 | 0;
            d4 = d4 + 1 | 0;
          }
          return h3 | 0;
        }
        function CC(b3) {
          b3 = b3 | 0;
          var c3 = 0;
          c3 = a2[n2 + (b3 & 255) >> 0] | 0;
          if ((c3 | 0) < 8)
            return c3 | 0;
          c3 = a2[n2 + (b3 >> 8 & 255) >> 0] | 0;
          if ((c3 | 0) < 8)
            return c3 + 8 | 0;
          c3 = a2[n2 + (b3 >> 16 & 255) >> 0] | 0;
          if ((c3 | 0) < 8)
            return c3 + 16 | 0;
          return (a2[n2 + (b3 >>> 24) >> 0] | 0) + 24 | 0;
        }
        function DC(a3, b3, d4, e4, f4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          var g3 = 0, h3 = 0, i4 = 0, j4 = 0, k4 = 0, l4 = 0, m4 = 0, n3 = 0, o3 = 0, p4 = 0;
          l4 = a3;
          j4 = b3;
          k4 = j4;
          h3 = d4;
          n3 = e4;
          i4 = n3;
          if (!k4) {
            g3 = (f4 | 0) != 0;
            if (!i4) {
              if (g3) {
                c2[f4 >> 2] = (l4 >>> 0) % (h3 >>> 0);
                c2[f4 + 4 >> 2] = 0;
              }
              n3 = 0;
              f4 = (l4 >>> 0) / (h3 >>> 0) >>> 0;
              return (A2 = n3, f4) | 0;
            } else {
              if (!g3) {
                n3 = 0;
                f4 = 0;
                return (A2 = n3, f4) | 0;
              }
              c2[f4 >> 2] = a3 | 0;
              c2[f4 + 4 >> 2] = b3 & 0;
              n3 = 0;
              f4 = 0;
              return (A2 = n3, f4) | 0;
            }
          }
          g3 = (i4 | 0) == 0;
          do
            if (h3) {
              if (!g3) {
                g3 = (S3(i4 | 0) | 0) - (S3(k4 | 0) | 0) | 0;
                if (g3 >>> 0 <= 31) {
                  m4 = g3 + 1 | 0;
                  i4 = 31 - g3 | 0;
                  b3 = g3 - 31 >> 31;
                  h3 = m4;
                  a3 = l4 >>> (m4 >>> 0) & b3 | k4 << i4;
                  b3 = k4 >>> (m4 >>> 0) & b3;
                  g3 = 0;
                  i4 = l4 << i4;
                  break;
                }
                if (!f4) {
                  n3 = 0;
                  f4 = 0;
                  return (A2 = n3, f4) | 0;
                }
                c2[f4 >> 2] = a3 | 0;
                c2[f4 + 4 >> 2] = j4 | b3 & 0;
                n3 = 0;
                f4 = 0;
                return (A2 = n3, f4) | 0;
              }
              g3 = h3 - 1 | 0;
              if (g3 & h3 | 0) {
                i4 = (S3(h3 | 0) | 0) + 33 - (S3(k4 | 0) | 0) | 0;
                p4 = 64 - i4 | 0;
                m4 = 32 - i4 | 0;
                j4 = m4 >> 31;
                o3 = i4 - 32 | 0;
                b3 = o3 >> 31;
                h3 = i4;
                a3 = m4 - 1 >> 31 & k4 >>> (o3 >>> 0) | (k4 << m4 | l4 >>> (i4 >>> 0)) & b3;
                b3 = b3 & k4 >>> (i4 >>> 0);
                g3 = l4 << p4 & j4;
                i4 = (k4 << p4 | l4 >>> (o3 >>> 0)) & j4 | l4 << m4 & i4 - 33 >> 31;
                break;
              }
              if (f4 | 0) {
                c2[f4 >> 2] = g3 & l4;
                c2[f4 + 4 >> 2] = 0;
              }
              if ((h3 | 0) == 1) {
                o3 = j4 | b3 & 0;
                p4 = a3 | 0 | 0;
                return (A2 = o3, p4) | 0;
              } else {
                p4 = CC(h3 | 0) | 0;
                o3 = k4 >>> (p4 >>> 0) | 0;
                p4 = k4 << 32 - p4 | l4 >>> (p4 >>> 0) | 0;
                return (A2 = o3, p4) | 0;
              }
            } else {
              if (g3) {
                if (f4 | 0) {
                  c2[f4 >> 2] = (k4 >>> 0) % (h3 >>> 0);
                  c2[f4 + 4 >> 2] = 0;
                }
                o3 = 0;
                p4 = (k4 >>> 0) / (h3 >>> 0) >>> 0;
                return (A2 = o3, p4) | 0;
              }
              if (!l4) {
                if (f4 | 0) {
                  c2[f4 >> 2] = 0;
                  c2[f4 + 4 >> 2] = (k4 >>> 0) % (i4 >>> 0);
                }
                o3 = 0;
                p4 = (k4 >>> 0) / (i4 >>> 0) >>> 0;
                return (A2 = o3, p4) | 0;
              }
              g3 = i4 - 1 | 0;
              if (!(g3 & i4)) {
                if (f4 | 0) {
                  c2[f4 >> 2] = a3 | 0;
                  c2[f4 + 4 >> 2] = g3 & k4 | b3 & 0;
                }
                o3 = 0;
                p4 = k4 >>> ((CC(i4 | 0) | 0) >>> 0);
                return (A2 = o3, p4) | 0;
              }
              g3 = (S3(i4 | 0) | 0) - (S3(k4 | 0) | 0) | 0;
              if (g3 >>> 0 <= 30) {
                b3 = g3 + 1 | 0;
                i4 = 31 - g3 | 0;
                h3 = b3;
                a3 = k4 << i4 | l4 >>> (b3 >>> 0);
                b3 = k4 >>> (b3 >>> 0);
                g3 = 0;
                i4 = l4 << i4;
                break;
              }
              if (!f4) {
                o3 = 0;
                p4 = 0;
                return (A2 = o3, p4) | 0;
              }
              c2[f4 >> 2] = a3 | 0;
              c2[f4 + 4 >> 2] = j4 | b3 & 0;
              o3 = 0;
              p4 = 0;
              return (A2 = o3, p4) | 0;
            }
          while (0);
          if (!h3) {
            k4 = i4;
            j4 = 0;
            i4 = 0;
          } else {
            m4 = d4 | 0 | 0;
            l4 = n3 | e4 & 0;
            k4 = xC(m4 | 0, l4 | 0, -1, -1) | 0;
            d4 = A2;
            j4 = i4;
            i4 = 0;
            do {
              e4 = j4;
              j4 = g3 >>> 31 | j4 << 1;
              g3 = i4 | g3 << 1;
              e4 = a3 << 1 | e4 >>> 31 | 0;
              n3 = a3 >>> 31 | b3 << 1 | 0;
              wC(k4 | 0, d4 | 0, e4 | 0, n3 | 0) | 0;
              p4 = A2;
              o3 = p4 >> 31 | ((p4 | 0) < 0 ? -1 : 0) << 1;
              i4 = o3 & 1;
              a3 = wC(e4 | 0, n3 | 0, o3 & m4 | 0, (((p4 | 0) < 0 ? -1 : 0) >> 31 | ((p4 | 0) < 0 ? -1 : 0) << 1) & l4 | 0) | 0;
              b3 = A2;
              h3 = h3 - 1 | 0;
            } while ((h3 | 0) != 0);
            k4 = j4;
            j4 = 0;
          }
          h3 = 0;
          if (f4 | 0) {
            c2[f4 >> 2] = a3;
            c2[f4 + 4 >> 2] = b3;
          }
          o3 = (g3 | 0) >>> 31 | (k4 | h3) << 1 | (h3 << 1 | g3 >>> 31) & 0 | j4;
          p4 = (g3 << 1 | 0 >>> 31) & -2 | i4;
          return (A2 = o3, p4) | 0;
        }
        function EC(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          return DC(a3, b3, c3, d4, 0) | 0;
        }
        function FC(a3) {
          a3 = a3 | 0;
          var b3 = 0, d4 = 0;
          d4 = a3 + 15 & -16 | 0;
          b3 = c2[i3 >> 2] | 0;
          a3 = b3 + d4 | 0;
          if ((d4 | 0) > 0 & (a3 | 0) < (b3 | 0) | (a3 | 0) < 0) {
            Y2() | 0;
            Qa(12);
            return -1;
          }
          c2[i3 >> 2] = a3;
          if ((a3 | 0) > (X2() | 0) ? (W2() | 0) == 0 : 0) {
            c2[i3 >> 2] = b3;
            Qa(12);
            return -1;
          }
          return b3 | 0;
        }
        function GC(b3, c3, d4) {
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          var e4 = 0;
          if ((c3 | 0) < (b3 | 0) & (b3 | 0) < (c3 + d4 | 0)) {
            e4 = b3;
            c3 = c3 + d4 | 0;
            b3 = b3 + d4 | 0;
            while ((d4 | 0) > 0) {
              b3 = b3 - 1 | 0;
              c3 = c3 - 1 | 0;
              d4 = d4 - 1 | 0;
              a2[b3 >> 0] = a2[c3 >> 0] | 0;
            }
            b3 = e4;
          } else
            BC(b3, c3, d4) | 0;
          return b3 | 0;
        }
        function HC(a3, b3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          var f4 = 0, g3 = 0;
          g3 = l3;
          l3 = l3 + 16 | 0;
          f4 = g3 | 0;
          DC(a3, b3, d4, e4, f4) | 0;
          l3 = g3;
          return (A2 = c2[f4 + 4 >> 2] | 0, c2[f4 >> 2] | 0) | 0;
        }
        function IC(a3) {
          a3 = a3 | 0;
          return (a3 & 255) << 24 | (a3 >> 8 & 255) << 16 | (a3 >> 16 & 255) << 8 | a3 >>> 24 | 0;
        }
        function JC(a3, b3, c3, d4, e4, f4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          jb[a3 & 1](b3 | 0, c3 | 0, d4 | 0, e4 | 0, f4 | 0);
        }
        function KC(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = T2(c3);
          kb[a3 & 1](b3 | 0, T2(c3));
        }
        function LC(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = +c3;
          lb[a3 & 31](b3 | 0, +c3);
        }
        function MC(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = T2(c3);
          d4 = T2(d4);
          return T2(mb[a3 & 0](b3 | 0, T2(c3), T2(d4)));
        }
        function NC(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          nb[a3 & 127](b3 | 0);
        }
        function OC(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          ob[a3 & 31](b3 | 0, c3 | 0);
        }
        function PC(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return pb[a3 & 31](b3 | 0) | 0;
        }
        function QC(a3, b3, c3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = +c3;
          d4 = +d4;
          e4 = e4 | 0;
          qb[a3 & 1](b3 | 0, +c3, +d4, e4 | 0);
        }
        function RC(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = +c3;
          d4 = +d4;
          rb[a3 & 1](b3 | 0, +c3, +d4);
        }
        function SC(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          return sb[a3 & 7](b3 | 0, c3 | 0, d4 | 0) | 0;
        }
        function TC(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          return +tb[a3 & 1](b3 | 0, c3 | 0, d4 | 0);
        }
        function UC(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          return +ub[a3 & 15](b3 | 0);
        }
        function VC(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = +c3;
          return vb[a3 & 1](b3 | 0, +c3) | 0;
        }
        function WC(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          return wb[a3 & 15](b3 | 0, c3 | 0) | 0;
        }
        function XC(a3, b3, c3, d4, e4, f4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = +d4;
          e4 = +e4;
          f4 = f4 | 0;
          xb[a3 & 1](b3 | 0, c3 | 0, +d4, +e4, f4 | 0);
        }
        function YC(a3, b3, c3, d4, e4, f4, g3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          g3 = g3 | 0;
          yb[a3 & 1](b3 | 0, c3 | 0, d4 | 0, e4 | 0, f4 | 0, g3 | 0);
        }
        function ZC(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          return +zb[a3 & 7](b3 | 0, c3 | 0);
        }
        function _C(a3) {
          a3 = a3 | 0;
          return Ab[a3 & 7]() | 0;
        }
        function $C(a3, b3, c3, d4, e4, f4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          return Bb[a3 & 1](b3 | 0, c3 | 0, d4 | 0, e4 | 0, f4 | 0) | 0;
        }
        function aD(a3, b3, c3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          e4 = +e4;
          Cb[a3 & 1](b3 | 0, c3 | 0, d4 | 0, +e4);
        }
        function bD(a3, b3, c3, d4, e4, f4, g3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = T2(d4);
          e4 = e4 | 0;
          f4 = T2(f4);
          g3 = g3 | 0;
          Db[a3 & 1](b3 | 0, c3 | 0, T2(d4), e4 | 0, T2(f4), g3 | 0);
        }
        function cD(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          Eb[a3 & 15](b3 | 0, c3 | 0, d4 | 0);
        }
        function dD(a3) {
          a3 = a3 | 0;
          Fb[a3 & 0]();
        }
        function eD(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = +d4;
          Gb[a3 & 15](b3 | 0, c3 | 0, +d4);
        }
        function fD(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = +b3;
          c3 = +c3;
          return Hb[a3 & 1](+b3, +c3) | 0;
        }
        function gD(a3, b3, c3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          Ib[a3 & 15](b3 | 0, c3 | 0, d4 | 0, e4 | 0);
        }
        function hD(a3, b3, c3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          U2(0);
        }
        function iD(a3, b3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          U2(1);
        }
        function jD(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          U2(2);
        }
        function kD(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = T2(b3);
          c3 = T2(c3);
          U2(3);
          return ib;
        }
        function lD(a3) {
          a3 = a3 | 0;
          U2(4);
        }
        function mD(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          U2(5);
        }
        function nD(a3) {
          a3 = a3 | 0;
          U2(6);
          return 0;
        }
        function oD(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = +b3;
          c3 = +c3;
          d4 = d4 | 0;
          U2(7);
        }
        function pD(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = +b3;
          c3 = +c3;
          U2(8);
        }
        function qD(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          U2(9);
          return 0;
        }
        function rD(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          U2(10);
          return 0;
        }
        function sD(a3) {
          a3 = a3 | 0;
          U2(11);
          return 0;
        }
        function tD(a3, b3) {
          a3 = a3 | 0;
          b3 = +b3;
          U2(12);
          return 0;
        }
        function uD(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          U2(13);
          return 0;
        }
        function vD(a3, b3, c3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = +c3;
          d4 = +d4;
          e4 = e4 | 0;
          U2(14);
        }
        function wD(a3, b3, c3, d4, e4, f4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          f4 = f4 | 0;
          U2(15);
        }
        function xD(a3, b3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          U2(16);
          return 0;
        }
        function yD() {
          U2(17);
          return 0;
        }
        function zD(a3, b3, c3, d4, e4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          e4 = e4 | 0;
          U2(18);
          return 0;
        }
        function AD(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = +d4;
          U2(19);
        }
        function BD(a3, b3, c3, d4, e4, f4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = T2(c3);
          d4 = d4 | 0;
          e4 = T2(e4);
          f4 = f4 | 0;
          U2(20);
        }
        function CD(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          U2(21);
        }
        function DD() {
          U2(22);
        }
        function ED(a3, b3, c3) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = +c3;
          U2(23);
        }
        function FD(a3, b3) {
          a3 = +a3;
          b3 = +b3;
          U2(24);
          return 0;
        }
        function GD(a3, b3, c3, d4) {
          a3 = a3 | 0;
          b3 = b3 | 0;
          c3 = c3 | 0;
          d4 = d4 | 0;
          U2(25);
        }
        var jb = [hD, Uw];
        var kb = [iD, of];
        var lb = [jD, Of, Pf, Qf, Rf, Sf, Tf, Uf, Wf, Xf, Zf, _f, $f, ag, bg, cg, dg, eg, fg, jD, jD, jD, jD, jD, jD, jD, jD, jD, jD, jD, jD, jD];
        var mb = [kD];
        var nb = [lD, kC, Ki, Li, Mi, rn, sn, tn, Pu, Qu, Ru, Cw, Dw, Ew, DA, EA, FA, Rb, tf, yf, Vf, Yf, hh, ih, ri, Ui, kj, Jj, bk, zk, Wk, nl, Hl, bm, um, Nm, en, Nn, fo, yo, Ro, ip, Bp, Xp, nq, Eq, Zq, lf, Hr, _r, us, Ps, ft, Ct, Ot, Rt, ju, mu, Eu, Uu, Xu, pv, Kv, Vi, $x, Ky, az, sz, Rz, hA, tA, wA, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD, lD];
        var ob = [mD, zf, Af, Df, Ef, Ff, Gf, Hf, If, Lf, Mf, Nf, wg, zg, Ag, Bg, Cg, Dg, Eg, Jg, Ng, rh, $p, qq, Ts, cy, Sv, xy, mD, mD, mD, mD];
        var pb = [nD, rB, sf, jg, ng, og, pg, qg, rg, sg, ug, vg, Kg, Lg, jh, ar, jt, sv, hy, jy, nD, nD, nD, nD, nD, nD, nD, nD, nD, nD, nD, nD];
        var qb = [oD, kh];
        var rb = [pD, Hu];
        var sb = [qD, sB, tB, zB, Dk, Rn, Lr, wz];
        var tb = [rD, ym];
        var ub = [sD, xg, yg, Fg, lh, mh, nh, oh, ph, qh, sD, sD, sD, sD, sD, sD];
        var vb = [tD, Kt];
        var wb = [uD, lC, Mg, xi, Nj, _k, rl, jn, jo, Iq, pf, ez, uD, uD, uD, uD];
        var xb = [vD, oj];
        var yb = [wD, Vz];
        var zb = [xD, Gg, sh, th, uh, Rm, xD, xD];
        var Ab = [yD, vh, qf, jf, Wt, qu, av, AA];
        var Bb = [zD, ee];
        var Cb = [AD, Vo];
        var Db = [BD, Pg];
        var Eb = [CD, kg, tg, Hg, Ig, fk, Ll, mp, Fp, nf, vx4, Oy, lA, CD, CD, CD];
        var Fb = [DD];
        var Gb = [ED, Bf, Cf, Jf, Kf, gg, hg, ig, Co, cs, Ft, ED, ED, ED, ED, ED];
        var Hb = [FD, Mu];
        var Ib = [GD, fm, ir, ys, st, au, wu, hv, Pv, oy, LA, GD, GD, GD, GD, GD];
        return { _llvm_bswap_i32: IC, dynCall_idd: fD, dynCall_i: _C, _i64Subtract: wC, ___udivdi3: EC, dynCall_vif: KC, setThrew: Nb, dynCall_viii: cD, _bitshift64Lshr: AC, _bitshift64Shl: zC, dynCall_vi: NC, dynCall_viiddi: XC, dynCall_diii: TC, dynCall_iii: WC, _memset: yC, _sbrk: FC, _memcpy: BC, __GLOBAL__sub_I_Yoga_cpp: hf, dynCall_vii: OC, ___uremdi3: HC, dynCall_vid: LC, stackAlloc: Jb, _nbind_init: _A, getTempRet0: Pb, dynCall_di: UC, dynCall_iid: VC, setTempRet0: Ob, _i64Add: xC, dynCall_fiff: MC, dynCall_iiii: SC, _emscripten_get_global_libc: qB, dynCall_viid: eD, dynCall_viiid: aD, dynCall_viififi: bD, dynCall_ii: PC, __GLOBAL__sub_I_Binding_cc: Sx, dynCall_viiii: gD, dynCall_iiiiii: $C, stackSave: Kb, dynCall_viiiii: JC, __GLOBAL__sub_I_nbind_cc: wh, dynCall_vidd: RC, _free: pB, runPostSets: vC, dynCall_viiiiii: YC, establishStackSpace: Mb, _memmove: GC, stackRestore: Lb, _malloc: oB, __GLOBAL__sub_I_common_cc: Bv, dynCall_viddi: QC, dynCall_dii: ZC, dynCall_v: dD };
      }(
        // EMSCRIPTEN_END_ASM
        Module.asmGlobalArg,
        Module.asmLibraryArg,
        buffer
      );
      var _llvm_bswap_i32 = Module["_llvm_bswap_i32"] = asm["_llvm_bswap_i32"];
      var getTempRet0 = Module["getTempRet0"] = asm["getTempRet0"];
      var ___udivdi3 = Module["___udivdi3"] = asm["___udivdi3"];
      var setThrew = Module["setThrew"] = asm["setThrew"];
      var _bitshift64Lshr = Module["_bitshift64Lshr"] = asm["_bitshift64Lshr"];
      var _bitshift64Shl = Module["_bitshift64Shl"] = asm["_bitshift64Shl"];
      var _memset = Module["_memset"] = asm["_memset"];
      var _sbrk = Module["_sbrk"] = asm["_sbrk"];
      var _memcpy = Module["_memcpy"] = asm["_memcpy"];
      var stackAlloc = Module["stackAlloc"] = asm["stackAlloc"];
      var ___uremdi3 = Module["___uremdi3"] = asm["___uremdi3"];
      var _nbind_init = Module["_nbind_init"] = asm["_nbind_init"];
      var _i64Subtract = Module["_i64Subtract"] = asm["_i64Subtract"];
      var setTempRet0 = Module["setTempRet0"] = asm["setTempRet0"];
      var _i64Add = Module["_i64Add"] = asm["_i64Add"];
      var _emscripten_get_global_libc = Module["_emscripten_get_global_libc"] = asm["_emscripten_get_global_libc"];
      var __GLOBAL__sub_I_Yoga_cpp = Module["__GLOBAL__sub_I_Yoga_cpp"] = asm["__GLOBAL__sub_I_Yoga_cpp"];
      var __GLOBAL__sub_I_Binding_cc = Module["__GLOBAL__sub_I_Binding_cc"] = asm["__GLOBAL__sub_I_Binding_cc"];
      var stackSave = Module["stackSave"] = asm["stackSave"];
      var __GLOBAL__sub_I_nbind_cc = Module["__GLOBAL__sub_I_nbind_cc"] = asm["__GLOBAL__sub_I_nbind_cc"];
      var _free = Module["_free"] = asm["_free"];
      var runPostSets = Module["runPostSets"] = asm["runPostSets"];
      var establishStackSpace = Module["establishStackSpace"] = asm["establishStackSpace"];
      var _memmove = Module["_memmove"] = asm["_memmove"];
      var stackRestore = Module["stackRestore"] = asm["stackRestore"];
      var _malloc = Module["_malloc"] = asm["_malloc"];
      var __GLOBAL__sub_I_common_cc = Module["__GLOBAL__sub_I_common_cc"] = asm["__GLOBAL__sub_I_common_cc"];
      var dynCall_viiiii = Module["dynCall_viiiii"] = asm["dynCall_viiiii"];
      var dynCall_vif = Module["dynCall_vif"] = asm["dynCall_vif"];
      var dynCall_vid = Module["dynCall_vid"] = asm["dynCall_vid"];
      var dynCall_fiff = Module["dynCall_fiff"] = asm["dynCall_fiff"];
      var dynCall_vi = Module["dynCall_vi"] = asm["dynCall_vi"];
      var dynCall_vii = Module["dynCall_vii"] = asm["dynCall_vii"];
      var dynCall_ii = Module["dynCall_ii"] = asm["dynCall_ii"];
      var dynCall_viddi = Module["dynCall_viddi"] = asm["dynCall_viddi"];
      var dynCall_vidd = Module["dynCall_vidd"] = asm["dynCall_vidd"];
      var dynCall_iiii = Module["dynCall_iiii"] = asm["dynCall_iiii"];
      var dynCall_diii = Module["dynCall_diii"] = asm["dynCall_diii"];
      var dynCall_di = Module["dynCall_di"] = asm["dynCall_di"];
      var dynCall_iid = Module["dynCall_iid"] = asm["dynCall_iid"];
      var dynCall_iii = Module["dynCall_iii"] = asm["dynCall_iii"];
      var dynCall_viiddi = Module["dynCall_viiddi"] = asm["dynCall_viiddi"];
      var dynCall_viiiiii = Module["dynCall_viiiiii"] = asm["dynCall_viiiiii"];
      var dynCall_dii = Module["dynCall_dii"] = asm["dynCall_dii"];
      var dynCall_i = Module["dynCall_i"] = asm["dynCall_i"];
      var dynCall_iiiiii = Module["dynCall_iiiiii"] = asm["dynCall_iiiiii"];
      var dynCall_viiid = Module["dynCall_viiid"] = asm["dynCall_viiid"];
      var dynCall_viififi = Module["dynCall_viififi"] = asm["dynCall_viififi"];
      var dynCall_viii = Module["dynCall_viii"] = asm["dynCall_viii"];
      var dynCall_v = Module["dynCall_v"] = asm["dynCall_v"];
      var dynCall_viid = Module["dynCall_viid"] = asm["dynCall_viid"];
      var dynCall_idd = Module["dynCall_idd"] = asm["dynCall_idd"];
      var dynCall_viiii = Module["dynCall_viiii"] = asm["dynCall_viiii"];
      Runtime.stackAlloc = Module["stackAlloc"];
      Runtime.stackSave = Module["stackSave"];
      Runtime.stackRestore = Module["stackRestore"];
      Runtime.establishStackSpace = Module["establishStackSpace"];
      Runtime.setTempRet0 = Module["setTempRet0"];
      Runtime.getTempRet0 = Module["getTempRet0"];
      Module["asm"] = asm;
      function ExitStatus(status) {
        this.name = "ExitStatus";
        this.message = "Program terminated with exit(" + status + ")";
        this.status = status;
      }
      ExitStatus.prototype = new Error();
      ExitStatus.prototype.constructor = ExitStatus;
      var initialStackTop;
      var preloadStartTime = null;
      var calledMain = false;
      dependenciesFulfilled = function runCaller() {
        if (!Module["calledRun"])
          run();
        if (!Module["calledRun"])
          dependenciesFulfilled = runCaller;
      };
      Module["callMain"] = Module.callMain = function callMain(args) {
        args = args || [];
        ensureInitRuntime();
        var argc = args.length + 1;
        function pad() {
          for (var i4 = 0; i4 < 4 - 1; i4++) {
            argv.push(0);
          }
        }
        var argv = [allocate(intArrayFromString(Module["thisProgram"]), "i8", ALLOC_NORMAL)];
        pad();
        for (var i3 = 0; i3 < argc - 1; i3 = i3 + 1) {
          argv.push(allocate(intArrayFromString(args[i3]), "i8", ALLOC_NORMAL));
          pad();
        }
        argv.push(0);
        argv = allocate(argv, "i32", ALLOC_NORMAL);
        try {
          var ret = Module["_main"](argc, argv, 0);
          exit(ret, true);
        } catch (e3) {
          if (e3 instanceof ExitStatus) {
            return;
          } else if (e3 == "SimulateInfiniteLoop") {
            Module["noExitRuntime"] = true;
            return;
          } else {
            var toLog = e3;
            if (e3 && typeof e3 === "object" && e3.stack) {
              toLog = [e3, e3.stack];
            }
            Module.printErr("exception thrown: " + toLog);
            Module["quit"](1, e3);
          }
        } finally {
          calledMain = true;
        }
      };
      function run(args) {
        args = args || Module["arguments"];
        if (preloadStartTime === null)
          preloadStartTime = Date.now();
        if (runDependencies > 0) {
          return;
        }
        preRun();
        if (runDependencies > 0)
          return;
        if (Module["calledRun"])
          return;
        function doRun() {
          if (Module["calledRun"])
            return;
          Module["calledRun"] = true;
          if (ABORT)
            return;
          ensureInitRuntime();
          preMain();
          if (Module["onRuntimeInitialized"])
            Module["onRuntimeInitialized"]();
          if (Module["_main"] && shouldRunNow)
            Module["callMain"](args);
          postRun();
        }
        if (Module["setStatus"]) {
          Module["setStatus"]("Running...");
          setTimeout(function() {
            setTimeout(function() {
              Module["setStatus"]("");
            }, 1);
            doRun();
          }, 1);
        } else {
          doRun();
        }
      }
      Module["run"] = Module.run = run;
      function exit(status, implicit) {
        if (implicit && Module["noExitRuntime"]) {
          return;
        }
        if (Module["noExitRuntime"]) {
        } else {
          ABORT = true;
          EXITSTATUS = status;
          STACKTOP = initialStackTop;
          exitRuntime();
          if (Module["onExit"])
            Module["onExit"](status);
        }
        if (ENVIRONMENT_IS_NODE) {
          process["exit"](status);
        }
        Module["quit"](status, new ExitStatus(status));
      }
      Module["exit"] = Module.exit = exit;
      var abortDecorators = [];
      function abort(what) {
        if (Module["onAbort"]) {
          Module["onAbort"](what);
        }
        if (what !== void 0) {
          Module.print(what);
          Module.printErr(what);
          what = JSON.stringify(what);
        } else {
          what = "";
        }
        ABORT = true;
        EXITSTATUS = 1;
        var extra = "\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.";
        var output = "abort(" + what + ") at " + stackTrace() + extra;
        if (abortDecorators) {
          abortDecorators.forEach(function(decorator) {
            output = decorator(output, what);
          });
        }
        throw output;
      }
      Module["abort"] = Module.abort = abort;
      if (Module["preInit"]) {
        if (typeof Module["preInit"] == "function")
          Module["preInit"] = [Module["preInit"]];
        while (Module["preInit"].length > 0) {
          Module["preInit"].pop()();
        }
      }
      var shouldRunNow = true;
      if (Module["noInitialRun"]) {
        shouldRunNow = false;
      }
      run();
    });
  }
});

// ../../node_modules/.pnpm/@aeolun+yoga-layout-prebuilt@1.10.0/node_modules/@aeolun/yoga-layout-prebuilt/yoga-layout/dist/entry-browser.js
var require_entry_browser = __commonJS({
  "../../node_modules/.pnpm/@aeolun+yoga-layout-prebuilt@1.10.0/node_modules/@aeolun/yoga-layout-prebuilt/yoga-layout/dist/entry-browser.js"(exports2, module2) {
    "use strict";
    var Yoga = require_entry_common();
    var nbind = require_nbind();
    var ran = false;
    var ret = null;
    nbind({}, function(err2, result) {
      if (ran) {
        return;
      }
      ran = true;
      if (err2) {
        throw err2;
      }
      ret = result;
    });
    if (!ran) {
      throw new Error("Failed to load the yoga module - it needed to be loaded synchronously, but didn't");
    }
    module2.exports = Yoga(ret.bind, ret.lib);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/index.mjs
init_init();
init_all();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/app/Application.mjs
init_Extensions();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs
init_settings();
var supported;
function isWebGLSupported() {
  if (typeof supported === "undefined") {
    supported = function supported22() {
      const contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
      };
      try {
        if (!settings.ADAPTER.getWebGLRenderingContext()) {
          return false;
        }
        const canvas3 = settings.ADAPTER.createCanvas();
        let gl = canvas3.getContext("webgl2", contextOptions);
        const success = !!gl?.getContextAttributes()?.stencil;
        if (gl) {
          const loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success;
      } catch (e3) {
        return false;
      }
    }();
  }
  return supported;
}

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs
init_settings();
async function isWebGPUSupported(options = {}) {
  const gpu = settings.ADAPTER.getNavigator().gpu;
  if (!gpu)
    return false;
  try {
    const adapter = await navigator.gpu.requestAdapter(options);
    await adapter.requestDevice();
    return true;
  } catch (e3) {
    return false;
  }
}

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs
var renderPriority = ["webgpu", "webgl", "canvas"];
async function autoDetectRenderer(options) {
  let preferredOrder = [];
  if (options.preference) {
    preferredOrder.push(options.preference);
    renderPriority.forEach((item) => {
      if (item !== options.preference) {
        preferredOrder.push(item);
      }
    });
  } else {
    preferredOrder = renderPriority.slice();
  }
  let RendererClass;
  if (options.manageImports ?? true) {
    await Promise.resolve().then(() => (init_all(), all_exports));
  }
  let finalOptions = {};
  for (let i3 = 0; i3 < preferredOrder.length; i3++) {
    const rendererType = preferredOrder[i3];
    if (rendererType === "webgpu" && await isWebGPUSupported()) {
      const { WebGPURenderer: WebGPURenderer2 } = await Promise.resolve().then(() => (init_WebGPURenderer(), WebGPURenderer_exports));
      RendererClass = WebGPURenderer2;
      finalOptions = { ...options, ...options.webgpu };
      break;
    } else if (rendererType === "webgl" && isWebGLSupported()) {
      const { WebGLRenderer: WebGLRenderer2 } = await Promise.resolve().then(() => (init_WebGLRenderer(), WebGLRenderer_exports));
      RendererClass = WebGLRenderer2;
      finalOptions = { ...options, ...options.webgl };
      break;
    } else if (rendererType === "canvas") {
      finalOptions = { ...options };
      break;
    }
  }
  delete finalOptions.webgpu;
  delete finalOptions.webgl;
  const renderer = new RendererClass();
  await renderer.init(finalOptions);
  return renderer;
}

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/app/Application.mjs
init_Container();
var _Application = class {
  constructor() {
    this.stage = new Container();
  }
  /**
   * @param options - The optional application and renderer parameters.
   */
  async init(options) {
    options = {
      ...{
        // forceCanvas: false,
      },
      ...options
    };
    this.renderer = await autoDetectRenderer(options);
    _Application._plugins.forEach((plugin) => {
      plugin.init.call(this, options);
    });
  }
  /** Render the current stage. */
  render() {
    this.renderer.render({ container: this.stage });
  }
  /**
   * Reference to the renderer's canvas element.
   * @member {ICanvas}
   * @readonly
   */
  get canvas() {
    return this.renderer.canvas;
  }
  /**
   * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
   * @member {Rectangle}
   * @readonly
   */
  get screen() {
    return this.renderer.screen;
  }
  /**
   * Destroys the application and all of its resources.
   * @param {object|boolean} [options=false] - The options for destroying the application.
   * @param {boolean} [options.removeView=false] - Whether to remove the application's canvas element from the DOM.
   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method
   * called as well. `options` will be passed on to those calls.
   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.
   * If options.children is set to true,
   * it should destroy the texture of the child sprite.
   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
   *  If options.children is set to true,
   * it should destroy the texture source of the child sprite.
   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
   * If options.children is set to true,
   * it should destroy the context of the child graphics.
   */
  destroy(options = false) {
    const plugins = _Application._plugins.slice(0);
    plugins.reverse();
    plugins.forEach((plugin) => {
      plugin.destroy.call(this);
    });
    this.stage.destroy(options);
    this.stage = null;
    this.renderer.destroy(options);
    this.renderer = null;
  }
};
var Application = _Application;
Application._plugins = [];
extensions.handleByList(ExtensionType.Application, Application._plugins);

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/index.mjs
init_init2();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/Assets.mjs
init_Extensions();
init_warn();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/BackgroundLoader.mjs
var BackgroundLoader = class {
  /**
   * @param loader
   * @param verbose - should the loader log to the console
   */
  constructor(loader, verbose = false) {
    this._loader = loader;
    this._assetList = [];
    this._isLoading = false;
    this._maxConcurrent = 1;
    this.verbose = verbose;
  }
  /**
   * Adds an array of assets to load.
   * @param assetUrls - assets to load
   */
  add(assetUrls) {
    assetUrls.forEach((a2) => {
      this._assetList.push(a2);
    });
    if (this.verbose) {
      console.log("[BackgroundLoader] assets: ", this._assetList);
    }
    if (this._isActive && !this._isLoading) {
      void this._next();
    }
  }
  /**
   * Loads the next set of assets. Will try to load as many assets as it can at the same time.
   *
   * The max assets it will try to load at one time will be 4.
   */
  async _next() {
    if (this._assetList.length && this._isActive) {
      this._isLoading = true;
      const toLoad = [];
      const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
      for (let i3 = 0; i3 < toLoadAmount; i3++) {
        toLoad.push(this._assetList.pop());
      }
      await this._loader.load(toLoad);
      this._isLoading = false;
      void this._next();
    }
  }
  /**
   * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.
   * @returns whether the class is active
   */
  get active() {
    return this._isActive;
  }
  set active(value) {
    if (this._isActive === value)
      return;
    this._isActive = value;
    if (value && !this._isLoading) {
      void this._next();
    }
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/Assets.mjs
init_Cache();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/loader/Loader.mjs
init_warn();
init_path();
init_convertToList();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs
var isSingleItem = (item) => !Array.isArray(item);

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/loader/Loader.mjs
var Loader = class {
  constructor() {
    this._parsers = [];
    this._parsersValidated = false;
    this.parsers = new Proxy(this._parsers, {
      set: (target, key2, value) => {
        this._parsersValidated = false;
        target[key2] = value;
        return true;
      }
    });
    this.promiseCache = {};
  }
  /** function used for testing */
  reset() {
    this._parsersValidated = false;
    this.promiseCache = {};
  }
  /**
   * Used internally to generate a promise for the asset to be loaded.
   * @param url - The URL to be loaded
   * @param data - any custom additional information relevant to the asset being loaded
   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object
   */
  _getLoadPromiseAndParser(url2, data) {
    const result = {
      promise: null,
      parser: null
    };
    result.promise = (async () => {
      let asset = null;
      let parser = null;
      if (data.loadParser) {
        parser = this._parserHash[data.loadParser];
        if (!parser) {
          warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url2}`);
        }
      }
      if (!parser) {
        for (let i3 = 0; i3 < this.parsers.length; i3++) {
          const parserX = this.parsers[i3];
          if (parserX.load && parserX.test?.(url2, data, this)) {
            parser = parserX;
            break;
          }
        }
        if (!parser) {
          warn(`[Assets] ${url2} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);
          return null;
        }
      }
      asset = await parser.load(url2, data, this);
      result.parser = parser;
      for (let i3 = 0; i3 < this.parsers.length; i3++) {
        const parser2 = this.parsers[i3];
        if (parser2.parse) {
          if (parser2.parse && await parser2.testParse?.(asset, data, this)) {
            asset = await parser2.parse(asset, data, this) || asset;
            result.parser = parser2;
          }
        }
      }
      return asset;
    })();
    return result;
  }
  async load(assetsToLoadIn, onProgress) {
    if (!this._parsersValidated) {
      this._validateParsers();
    }
    let count2 = 0;
    const assets = {};
    const singleAsset = isSingleItem(assetsToLoadIn);
    const assetsToLoad = convertToList(assetsToLoadIn, (item) => ({
      alias: [item],
      src: item
    }));
    const total = assetsToLoad.length;
    const promises = assetsToLoad.map(async (asset) => {
      const url2 = path.toAbsolute(asset.src);
      if (!assets[asset.src]) {
        try {
          if (!this.promiseCache[url2]) {
            this.promiseCache[url2] = this._getLoadPromiseAndParser(url2, asset);
          }
          assets[asset.src] = await this.promiseCache[url2].promise;
          if (onProgress)
            onProgress(++count2 / total);
        } catch (e3) {
          delete this.promiseCache[url2];
          delete assets[asset.src];
          throw new Error(`[Loader.load] Failed to load ${url2}.
${e3}`);
        }
      }
    });
    await Promise.all(promises);
    return singleAsset ? assets[assetsToLoad[0].src] : assets;
  }
  /**
   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.
   * The parser that created the asset, will be the one that unloads it.
   * @example
   * // Single asset:
   * const asset = await Loader.load('cool.png');
   *
   * await Loader.unload('cool.png');
   *
   * console.log(asset.destroyed); // true
   * @param assetsToUnloadIn - urls that you want to unload, or a single one!
   */
  async unload(assetsToUnloadIn) {
    const assetsToUnload = convertToList(assetsToUnloadIn, (item) => ({
      alias: [item],
      src: item
    }));
    const promises = assetsToUnload.map(async (asset) => {
      const url2 = path.toAbsolute(asset.src);
      const loadPromise = this.promiseCache[url2];
      if (loadPromise) {
        const loadedAsset = await loadPromise.promise;
        delete this.promiseCache[url2];
        loadPromise.parser?.unload?.(loadedAsset, asset, this);
      }
    });
    await Promise.all(promises);
  }
  /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */
  _validateParsers() {
    this._parsersValidated = true;
    this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {
      if (!parser.name) {
        warn(`[Assets] loadParser should have a name`);
      } else if (hash[parser.name]) {
        warn(`[Assets] loadParser name conflict "${parser.name}"`);
      }
      return { ...hash, [parser.name]: parser };
    }, {});
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/resolver/Resolver.mjs
init_warn();
init_path();
init_convertToList();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs
function processX(base, ids, depth, result, tags) {
  const id = ids[depth];
  for (let i3 = 0; i3 < id.length; i3++) {
    const value = id[i3];
    if (depth < ids.length - 1) {
      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);
    } else {
      tags.push(base.replace(result[depth], value));
    }
  }
}
function createStringVariations(string) {
  const regex = /\{(.*?)\}/g;
  const result = string.match(regex);
  const tags = [];
  if (result) {
    const ids = [];
    result.forEach((vars) => {
      const split = vars.substring(1, vars.length - 1).split(",");
      ids.push(split);
    });
    processX(string, ids, 0, result, tags);
  } else {
    tags.push(string);
  }
  return tags;
}

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/resolver/Resolver.mjs
var Resolver = class {
  constructor() {
    this._defaultBundleIdentifierOptions = {
      connector: "-",
      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
    };
    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
    this._assetMap = {};
    this._preferredOrder = [];
    this._parsers = [];
    this._resolverHash = {};
    this._bundles = {};
  }
  /**
   * Override how the resolver deals with generating bundle ids.
   * must be called before any bundles are added
   * @param bundleIdentifier - the bundle identifier options
   */
  setBundleIdentifier(bundleIdentifier) {
    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
    if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
    }
  }
  /**
   * Let the resolver know which assets you prefer to use when resolving assets.
   * Multiple prefer user defined rules can be added.
   * @example
   * resolver.prefer({
   *     // first look for something with the correct format, and then then correct resolution
   *     priority: ['format', 'resolution'],
   *     params:{
   *         format:'webp', // prefer webp images
   *         resolution: 2, // prefer a resolution of 2
   *     }
   * })
   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
   * resolver.resolveUrl('foo') // => 'bar@2x.webp'
   * @param preferOrders - the prefer options
   */
  prefer(...preferOrders) {
    preferOrders.forEach((prefer) => {
      this._preferredOrder.push(prefer);
      if (!prefer.priority) {
        prefer.priority = Object.keys(prefer.params);
      }
    });
    this._resolverHash = {};
  }
  /**
   * Set the base path to prepend to all urls when resolving
   * @example
   * resolver.basePath = 'https://home.com/';
   * resolver.add('foo', 'bar.ong');
   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
   * @param basePath - the base path to use
   */
  set basePath(basePath) {
    this._basePath = basePath;
  }
  get basePath() {
    return this._basePath;
  }
  /**
   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
   * default value for browsers is `window.location.origin`
   * @example
   * // Application hosted on https://home.com/some-path/index.html
   * resolver.basePath = 'https://home.com/some-path/';
   * resolver.rootPath = 'https://home.com/';
   * resolver.add('foo', '/bar.png');
   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
   * @param rootPath - the root path to use
   */
  set rootPath(rootPath) {
    this._rootPath = rootPath;
  }
  get rootPath() {
    return this._rootPath;
  }
  /**
   * All the active URL parsers that help the parser to extract information and create
   * an asset object-based on parsing the URL itself.
   *
   * Can be added using the extensions API
   * @example
   * resolver.add('foo', [
   *     {
   *         resolution: 2,
   *         format: 'png',
   *         src: 'image@2x.png',
   *     },
   *     {
   *         resolution:1,
   *         format:'png',
   *         src: 'image.png',
   *     },
   * ]);
   *
   * // With a url parser the information such as resolution and file format could extracted from the url itself:
   * extensions.add({
   *     extension: ExtensionType.ResolveParser,
   *     test: loadTextures.test, // test if url ends in an image
   *     parse: (value: string) =>
   *     ({
   *         resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
   *         format: value.split('.').pop(),
   *         src: value,
   *     }),
   * });
   *
   * // Now resolution and format can be extracted from the url
   * resolver.add('foo', [
   *     'image@2x.png',
   *     'image.png',
   * ]);
   */
  get parsers() {
    return this._parsers;
  }
  /** Used for testing, this resets the resolver to its initial state */
  reset() {
    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
    this._assetMap = {};
    this._preferredOrder = [];
    this._resolverHash = {};
    this._rootPath = null;
    this._basePath = null;
    this._manifest = null;
    this._bundles = {};
    this._defaultSearchParams = null;
  }
  /**
   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.
   * @param searchParams - the default url parameters to append when resolving urls
   */
  setDefaultSearchParams(searchParams) {
    if (typeof searchParams === "string") {
      this._defaultSearchParams = searchParams;
    } else {
      const queryValues = searchParams;
      this._defaultSearchParams = Object.keys(queryValues).map((key2) => `${encodeURIComponent(key2)}=${encodeURIComponent(queryValues[key2])}`).join("&");
    }
  }
  /**
   * Returns the aliases for a given asset
   * @param asset - the asset to get the aliases for
   */
  getAlias(asset) {
    const { alias, name, src, srcs } = asset;
    const aliasesToUse = convertToList(
      alias || name || src || srcs,
      (value) => {
        if (typeof value === "string")
          return value;
        if (Array.isArray(value))
          return value.map((v3) => v3?.src ?? v3?.srcs ?? v3);
        if (value?.src || value?.srcs)
          return value.src ?? value.srcs;
        return value;
      },
      true
    );
    return aliasesToUse;
  }
  /**
   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
   * generally a manifest would be built using a tool.
   * @param manifest - the manifest to add to the resolver
   */
  addManifest(manifest) {
    if (this._manifest) {
      warn("[Resolver] Manifest already exists, this will be overwritten");
    }
    this._manifest = manifest;
    manifest.bundles.forEach((bundle) => {
      this.addBundle(bundle.name, bundle.assets);
    });
  }
  /**
   * This adds a bundle of assets in one go so that you can resolve them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * resolver.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const resolvedAssets = await resolver.resolveBundle('animals');
   * @param bundleId - The id of the bundle to add
   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
   */
  addBundle(bundleId, assets) {
    const assetNames = [];
    if (Array.isArray(assets)) {
      assets.forEach((asset) => {
        const srcs = asset.src ?? asset.srcs;
        const aliases = asset.alias ?? asset.name;
        let ids;
        if (typeof aliases === "string") {
          const bundleAssetId = this._createBundleAssetId(bundleId, aliases);
          assetNames.push(bundleAssetId);
          ids = [aliases, bundleAssetId];
        } else {
          const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));
          assetNames.push(...bundleIds);
          ids = [...aliases, ...bundleIds];
        }
        this.add({
          ...asset,
          ...{
            alias: ids,
            src: srcs
          }
        });
      });
    } else {
      Object.keys(assets).forEach((key2) => {
        const aliases = [key2, this._createBundleAssetId(bundleId, key2)];
        if (typeof assets[key2] === "string") {
          this.add({
            alias: aliases,
            src: assets[key2]
          });
        } else if (Array.isArray(assets[key2])) {
          this.add({
            alias: aliases,
            src: assets[key2]
          });
        } else {
          const asset = assets[key2];
          const assetSrc = asset.src ?? asset.srcs;
          this.add({
            ...asset,
            ...{
              alias: aliases,
              src: Array.isArray(assetSrc) ? assetSrc : [assetSrc]
            }
          });
        }
        assetNames.push(...aliases);
      });
    }
    this._bundles[bundleId] = assetNames;
  }
  /**
   * Tells the resolver what keys are associated with witch asset.
   * The most important thing the resolver does
   * @example
   * // Single key, single asset:
   * resolver.add({alias: 'foo', src: 'bar.png');
   * resolver.resolveUrl('foo') // => 'bar.png'
   *
   * // Multiple keys, single asset:
   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});
   * resolver.resolveUrl('foo') // => 'bar.png'
   * resolver.resolveUrl('boo') // => 'bar.png'
   *
   * // Multiple keys, multiple assets:
   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});
   * resolver.resolveUrl('foo') // => 'bar.png'
   *
   * // Add custom data attached to the resolver
   * Resolver.add({
   *     alias: 'bunnyBooBooSmooth',
   *     src: 'bunny{png,webp}',
   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options
   * });
   *
   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }
   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver
   */
  add(aliases) {
    const assets = [];
    if (Array.isArray(aliases)) {
      assets.push(...aliases);
    } else {
      assets.push(aliases);
    }
    let keyCheck;
    keyCheck = (key2) => {
      if (this.hasKey(key2)) {
        warn(`[Resolver] already has key: ${key2} overwriting`);
      }
    };
    const assetArray = convertToList(assets);
    assetArray.forEach((asset) => {
      const { src, srcs } = asset;
      let { data, format: format3, loadParser } = asset;
      const srcsToUse = convertToList(src || srcs).map((src2) => {
        if (typeof src2 === "string") {
          return createStringVariations(src2);
        }
        return Array.isArray(src2) ? src2 : [src2];
      });
      const aliasesToUse = this.getAlias(asset);
      Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
      const resolvedAssets = [];
      srcsToUse.forEach((srcs2) => {
        srcs2.forEach((src2) => {
          let formattedAsset = {};
          if (typeof src2 !== "object") {
            formattedAsset.src = src2;
            for (let i3 = 0; i3 < this._parsers.length; i3++) {
              const parser = this._parsers[i3];
              if (parser.test(src2)) {
                formattedAsset = parser.parse(src2);
                break;
              }
            }
          } else {
            data = src2.data ?? data;
            format3 = src2.format ?? format3;
            loadParser = src2.loadParser ?? loadParser;
            formattedAsset = {
              ...formattedAsset,
              ...src2
            };
          }
          if (!aliasesToUse) {
            throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
          }
          formattedAsset = this._buildResolvedAsset(formattedAsset, {
            aliases: aliasesToUse,
            data,
            format: format3,
            loadParser
          });
          resolvedAssets.push(formattedAsset);
        });
      });
      aliasesToUse.forEach((alias) => {
        this._assetMap[alias] = resolvedAssets;
      });
    });
  }
  // TODO: this needs an overload like load did in Assets
  /**
   * If the resolver has had a manifest set via setManifest, this will return the assets urls for
   * a given bundleId or bundleIds.
   * @example
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * resolver.setManifest(manifest);
   * const resolved = resolver.resolveBundle('load-screen');
   * @param bundleIds - The bundle ids to resolve
   * @returns All the bundles assets or a hash of assets for each bundle specified
   */
  resolveBundle(bundleIds) {
    const singleAsset = isSingleItem(bundleIds);
    bundleIds = convertToList(bundleIds);
    const out3 = {};
    bundleIds.forEach((bundleId) => {
      const assetNames = this._bundles[bundleId];
      if (assetNames) {
        const results = this.resolve(assetNames);
        const assets = {};
        for (const key2 in results) {
          const asset = results[key2];
          assets[this._extractAssetIdFromBundle(bundleId, key2)] = asset;
        }
        out3[bundleId] = assets;
      }
    });
    return singleAsset ? out3[bundleIds[0]] : out3;
  }
  /**
   * Does exactly what resolve does, but returns just the URL rather than the whole asset object
   * @param key - The key or keys to resolve
   * @returns - The URLs associated with the key(s)
   */
  resolveUrl(key2) {
    const result = this.resolve(key2);
    if (typeof key2 !== "string") {
      const out3 = {};
      for (const i3 in result) {
        out3[i3] = result[i3].src;
      }
      return out3;
    }
    return result.src;
  }
  resolve(keys) {
    const singleAsset = isSingleItem(keys);
    keys = convertToList(keys);
    const result = {};
    keys.forEach((key2) => {
      if (!this._resolverHash[key2]) {
        if (this._assetMap[key2]) {
          let assets = this._assetMap[key2];
          const bestAsset = assets[0];
          const preferredOrder = this._getPreferredOrder(assets);
          preferredOrder?.priority.forEach((priorityKey) => {
            preferredOrder.params[priorityKey].forEach((value) => {
              const filteredAssets = assets.filter((asset) => {
                if (asset[priorityKey]) {
                  return asset[priorityKey] === value;
                }
                return false;
              });
              if (filteredAssets.length) {
                assets = filteredAssets;
              }
            });
          });
          this._resolverHash[key2] = assets[0] ?? bestAsset;
        } else {
          this._resolverHash[key2] = this._buildResolvedAsset({
            alias: [key2],
            src: key2
          }, {});
        }
      }
      result[key2] = this._resolverHash[key2];
    });
    return singleAsset ? result[keys[0]] : result;
  }
  /**
   * Checks if an asset with a given key exists in the resolver
   * @param key - The key of the asset
   */
  hasKey(key2) {
    return !!this._assetMap[key2];
  }
  /**
   * Checks if a bundle with the given key exists in the resolver
   * @param key - The key of the bundle
   */
  hasBundle(key2) {
    return !!this._bundles[key2];
  }
  /**
   * Internal function for figuring out what prefer criteria an asset should use.
   * @param assets
   */
  _getPreferredOrder(assets) {
    for (let i3 = 0; i3 < assets.length; i3++) {
      const asset = assets[0];
      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
      if (preferred) {
        return preferred;
      }
    }
    return this._preferredOrder[0];
  }
  /**
   * Appends the default url parameters to the url
   * @param url - The url to append the default parameters to
   * @returns - The url with the default parameters appended
   */
  _appendDefaultSearchParams(url2) {
    if (!this._defaultSearchParams)
      return url2;
    const paramConnector = /\?/.test(url2) ? "&" : "?";
    return `${url2}${paramConnector}${this._defaultSearchParams}`;
  }
  _buildResolvedAsset(formattedAsset, data) {
    const { aliases, data: assetData, loadParser, format: format3 } = data;
    if (this._basePath || this._rootPath) {
      formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
    }
    formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];
    formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
    formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };
    formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;
    formattedAsset.format = format3 ?? formattedAsset.src.split(".").pop();
    formattedAsset.srcs = formattedAsset.src;
    formattedAsset.name = formattedAsset.alias;
    return formattedAsset;
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/assets/Assets.mjs
init_convertToList();
var AssetsClass = class {
  constructor() {
    this._detections = [];
    this._initialized = false;
    this.resolver = new Resolver();
    this.loader = new Loader();
    this.cache = Cache;
    this._backgroundLoader = new BackgroundLoader(this.loader);
    this._backgroundLoader.active = true;
    this.reset();
  }
  /**
   * Best practice is to call this function before any loading commences
   * Initiating is the best time to add any customization to the way things are loaded.
   *
   * you do not need to call this for the Asset class to work, only if you want to set any initial properties
   * @param options - options to initialize the Asset manager with
   */
  async init(options = {}) {
    if (this._initialized) {
      warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
      return;
    }
    this._initialized = true;
    if (options.defaultSearchParams) {
      this.resolver.setDefaultSearchParams(options.defaultSearchParams);
    }
    if (options.basePath) {
      this.resolver.basePath = options.basePath;
    }
    if (options.bundleIdentifier) {
      this.resolver.setBundleIdentifier(options.bundleIdentifier);
    }
    if (options.manifest) {
      let manifest = options.manifest;
      if (typeof manifest === "string") {
        manifest = await this.load(manifest);
      }
      this.resolver.addManifest(manifest);
    }
    const resolutionPref = options.texturePreference?.resolution ?? 1;
    const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;
    const formats = await this._detectFormats({
      preferredFormats: options.texturePreference?.format,
      skipDetections: options.skipDetections,
      detections: this._detections
    });
    this.resolver.prefer({
      params: {
        format: formats,
        resolution
      }
    });
    if (options.preferences) {
      this.setPreferences(options.preferences);
    }
  }
  /**
   * Allows you to specify how to resolve any assets load requests.
   * There are a few ways to add things here as shown below:
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Simple
   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});
   * const bunny = await Assets.load('bunnyBooBoo');
   *
   * // Multiple keys:
   * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});
   *
   * const bunny = await Assets.load('burger');
   * const bunny2 = await Assets.load('chicken');
   *
   * // passing options to to the object
   * Assets.add({
   *     alias: 'bunnyBooBooSmooth',
   *     src: 'bunny{png,webp}',
   *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options
   * });
   *
   * // Multiple assets
   *
   * // The following all do the same thing:
   *
   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny{png,webp}'});
   *
   * Assets.add({
   *     alias: 'bunnyBooBoo',
   *     src: [
   *         'bunny.png',
   *         'bunny.webp',
   *    ],
   * });
   *
   * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available
   * @param assets - the unresolved assets to add to the resolver
   */
  add(assets) {
    this.resolver.add(assets);
  }
  async load(urls, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    const singleAsset = isSingleItem(urls);
    const urlArray = convertToList(urls).map((url2) => {
      if (typeof url2 !== "string") {
        const aliases = this.resolver.getAlias(url2);
        if (aliases.some((alias) => !this.resolver.hasKey(alias))) {
          this.add(url2);
        }
        return Array.isArray(aliases) ? aliases[0] : aliases;
      }
      if (!this.resolver.hasKey(url2))
        this.add({ alias: url2, src: url2 });
      return url2;
    });
    const resolveResults = this.resolver.resolve(urlArray);
    const out3 = await this._mapLoadToResolve(resolveResults, onProgress);
    return singleAsset ? out3[urlArray[0]] : out3;
  }
  /**
   * This adds a bundle of assets in one go so that you can load them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const assets = await Assets.loadBundle('animals');
   * @param bundleId - the id of the bundle to add
   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key
   */
  addBundle(bundleId, assets) {
    this.resolver.addBundle(bundleId, assets);
  }
  /**
   * Bundles are a way to load multiple assets at once.
   * If a manifest has been provided to the init function then you can load a bundle, or bundles.
   * you can also add bundles via `addBundle`
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * await Asset.init({ manifest });
   *
   * // Load a bundle...
   * loadScreenAssets = await Assets.loadBundle('load-screen');
   * // Load another bundle...
   * gameScreenAssets = await Assets.loadBundle('game-screen');
   * @param bundleIds - the bundle id or ids to load
   * @param onProgress - Optional function that is called when progress on asset loading is made.
   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)
   * of the assets loaded. Do not use this function to detect when assets are complete and available,
   * instead use the Promise returned by this function.
   * @returns all the bundles assets or a hash of assets for each bundle specified
   */
  async loadBundle(bundleIds, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    let singleAsset = false;
    if (typeof bundleIds === "string") {
      singleAsset = true;
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const out3 = {};
    const keys = Object.keys(resolveResults);
    let count2 = 0;
    let total = 0;
    const _onProgress = () => {
      onProgress?.(++count2 / total);
    };
    const promises = keys.map((bundleId) => {
      const resolveResult = resolveResults[bundleId];
      total += Object.keys(resolveResult).length;
      return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
        out3[bundleId] = resolveResult2;
      });
    });
    await Promise.all(promises);
    return singleAsset ? out3[bundleIds[0]] : out3;
  }
  /**
   * Initiate a background load of some assets. It will passively begin to load these assets in the background.
   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately
   *
   * An example of this might be that you would background load game assets after your inital load.
   * then when you got to actually load your game screen assets when a player goes to the game - the loading
   * would already have stared or may even be complete, saving you having to show an interim load bar.
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.backgroundLoad('bunny.png');
   *
   * // later on in your app...
   * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!
   * @param urls - the url / urls you want to background load
   */
  async backgroundLoad(urls) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof urls === "string") {
      urls = [urls];
    }
    const resolveResults = this.resolver.resolve(urls);
    this._backgroundLoader.add(Object.values(resolveResults));
  }
  /**
   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.
   * this can only be used if the loader has been initiated with a manifest
   * @example
   * import { Assets } from 'pixi.js';
   *
   * await Assets.init({
   *     manifest: {
   *         bundles: [
   *             {
   *                 name: 'load-screen',
   *                 assets: [...],
   *             },
   *             ...
   *         ],
   *     },
   * });
   *
   * Assets.backgroundLoadBundle('load-screen');
   *
   * // Later on in your app...
   * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!
   * @param bundleIds - the bundleId / bundleIds you want to background load
   */
  async backgroundLoadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof bundleIds === "string") {
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    Object.values(resolveResults).forEach((resolveResult) => {
      this._backgroundLoader.add(Object.values(resolveResult));
    });
  }
  /**
   * Only intended for development purposes.
   * This will wipe the resolver and caches.
   * You will need to reinitialize the Asset
   */
  reset() {
    this.resolver.reset();
    this.loader.reset();
    this.cache.reset();
    this._initialized = false;
  }
  get(keys) {
    if (typeof keys === "string") {
      return Cache.get(keys);
    }
    const assets = {};
    for (let i3 = 0; i3 < keys.length; i3++) {
      assets[i3] = Cache.get(keys[i3]);
    }
    return assets;
  }
  /**
   * helper function to map resolved assets back to loaded assets
   * @param resolveResults - the resolve results from the resolver
   * @param onProgress - the progress callback
   */
  async _mapLoadToResolve(resolveResults, onProgress) {
    const resolveArray = Object.values(resolveResults);
    const resolveKeys = Object.keys(resolveResults);
    this._backgroundLoader.active = false;
    const loadedAssets3 = await this.loader.load(resolveArray, onProgress);
    this._backgroundLoader.active = true;
    const out3 = {};
    resolveArray.forEach((resolveResult, i3) => {
      const asset = loadedAssets3[resolveResult.src];
      const keys = [resolveResult.src];
      if (resolveResult.alias) {
        keys.push(...resolveResult.alias);
      }
      out3[resolveKeys[i3]] = asset;
      Cache.set(keys, asset);
    });
    return out3;
  }
  /**
   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function
   * this will make sure to destroy any assets and release them from memory.
   * Once unloaded, you will need to load the asset again.
   *
   * Use this to help manage assets if you find that you have a large app and you want to free up memory.
   *
   * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,
   * Pixi won't break but you will end up with missing assets. Not a good look for the user!
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Load a URL:
   * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture
   *
   * await Assets.unload('http://some.url.com/image.png')
   *
   * // myImageTexture will be destroyed now.
   *
   * // Unload multiple assets:
   * const textures = await Assets.unload(['thumper', 'chicko']);
   * @param urls - the urls to unload
   */
  async unload(urls) {
    if (!this._initialized) {
      await this.init();
    }
    const urlArray = convertToList(urls).map((url2) => typeof url2 !== "string" ? url2.src : url2);
    const resolveResults = this.resolver.resolve(urlArray);
    await this._unloadFromResolved(resolveResults);
  }
  /**
   * Bundles are a way to manage multiple assets at once.
   * this will unload all files in a bundle.
   *
   * once a bundle has been unloaded, you need to load it again to have access to the assets.
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.addBundle({
   *     'thumper': 'http://some.url.com/thumper.png',
   * })
   *
   * const assets = await Assets.loadBundle('thumper');
   *
   * // Now to unload...
   *
   * await Assets.unloadBundle('thumper');
   *
   * // All assets in the assets object will now have been destroyed and purged from the cache
   * @param bundleIds - the bundle id or ids to unload
   */
  async unloadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    bundleIds = convertToList(bundleIds);
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
    await Promise.all(promises);
  }
  async _unloadFromResolved(resolveResult) {
    const resolveArray = Object.values(resolveResult);
    resolveArray.forEach((resolveResult2) => {
      Cache.remove(resolveResult2.src);
    });
    await this.loader.unload(resolveArray);
  }
  /**
   * Detects the supported formats for the browser, and returns an array of supported formats, respecting
   * the users preferred formats order.
   * @param options - the options to use when detecting formats
   * @param options.preferredFormats - the preferred formats to use
   * @param options.skipDetections - if we should skip the detections altogether
   * @param options.detections - the detections to use
   * @returns - the detected formats
   */
  async _detectFormats(options) {
    let formats = [];
    if (options.preferredFormats) {
      formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats];
    }
    for (const detection of options.detections) {
      if (options.skipDetections || await detection.test()) {
        formats = await detection.add(formats);
      } else if (!options.skipDetections) {
        formats = await detection.remove(formats);
      }
    }
    formats = formats.filter((format3, index) => formats.indexOf(format3) === index);
    return formats;
  }
  /** All the detection parsers currently added to the Assets class. */
  get detections() {
    return this._detections;
  }
  /**
   * General setter for preferences. This is a helper function to set preferences on all parsers.
   * @param preferences - the preferences to set
   */
  setPreferences(preferences) {
    this.loader.parsers.forEach((parser) => {
      if (!parser.config)
        return;
      Object.keys(parser.config).filter((key2) => key2 in preferences).forEach((key2) => {
        parser.config[key2] = preferences[key2];
      });
    });
  }
};
var Assets = new AssetsClass();
extensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/index.mjs
init_init3();
init_init4();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/defaults/alpha/AlphaFilter.mjs
init_GpuProgram();
init_UniformGroup();
init_Filter();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/defaults/alpha/alpha.mjs
var source2 = "struct GlobalUniforms {\n  projectionMatrix:mat3x3<f32>,\n  worldTransformMatrix:mat3x3<f32>,\n  worldAlpha: f32\n}\n\nstruct GlobalFilterUniforms {\n  inputSize:vec4<f32>,\n  inputPixel:vec4<f32>,\n  inputClamp:vec4<f32>,\n  outputFrame:vec4<f32>,\n  backgroundFrame:vec4<f32>,\n  globalFrame:vec4<f32>,\n};\n\nstruct AlphaUniforms {\n  uAlpha:f32,\n};\n\n@group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n\n@group(1) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(1) @binding(1) var iTexture: texture_2d<f32>;\n@group(1) @binding(2) var iSampler : sampler;\n\n@group(2) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * max(gfu.outputFrame.zw, vec2(0.)) + gfu.outputFrame.xy;\n\n    return vec4((globalUniforms.projectionMatrix * globalUniforms.worldTransformMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);\n}\n\nfn filterBackgroundTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * gfu.backgroundFrame.zw;\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.globalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n) -> @location(0) vec4<f32> {\n  return textureSample(iTexture, iSampler, uv) * alphaUniforms.uAlpha;\n}";

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/filters/defaults/alpha/AlphaFilter.mjs
var _AlphaFilter = class extends Filter {
  constructor(options) {
    options = { ..._AlphaFilter.DEFAULT_OPTIONS, ...options };
    const gpuProgram = new GpuProgram({
      vertex: {
        source: source2,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source2,
        entryPoint: "mainFragment"
      }
    });
    const filterUniforms = new UniformGroup({
      uAlpha: { value: options.alpha, type: "f32" }
    });
    super({
      gpuProgram,
      resources: {
        filterUniforms
      }
    });
  }
  /**
   * Coefficient for alpha multiplication
   * @default 1
   */
  get alpha() {
    return this.resources.filterUniforms.uniforms.uAlpha;
  }
  set alpha(value) {
    this.resources.filterUniforms.uniforms.uAlpha = value;
  }
};
var AlphaFilter = _AlphaFilter;
AlphaFilter.DEFAULT_OPTIONS = {
  alpha: 1
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/index.mjs
init_Point();
init_init6();
init_Container();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs
init_deprecation();
init_Container();
init_GraphicsContext();
init_GraphicsView();
var Graphics = class extends Container {
  constructor(options) {
    if (options instanceof GraphicsContext) {
      options = { context: options };
    }
    const { context: context4, ...rest } = options || {};
    super({
      view: new GraphicsView(context4),
      label: "Graphics",
      ...rest
    });
    this.allowChildren = false;
  }
  get context() {
    return this.view.context;
  }
  set context(context4) {
    this.view.context = context4;
  }
  _callContextMethod(method, args) {
    this.view.context[method](...args);
    return this;
  }
  fill(...args) {
    return this._callContextMethod("fill", args);
  }
  stroke(...args) {
    return this._callContextMethod("stroke", args);
  }
  texture(...args) {
    return this._callContextMethod("texture", args);
  }
  beginPath(...args) {
    return this._callContextMethod("beginPath", args);
  }
  cut(...args) {
    return this._callContextMethod("cut", args);
  }
  arc(...args) {
    return this._callContextMethod("arc", args);
  }
  arcTo(...args) {
    return this._callContextMethod("arcTo", args);
  }
  arcToSvg(...args) {
    return this._callContextMethod("arcToSvg", args);
  }
  bezierCurveTo(...args) {
    return this._callContextMethod("bezierCurveTo", args);
  }
  closePath(...args) {
    return this._callContextMethod("closePath", args);
  }
  ellipse(...args) {
    return this._callContextMethod("ellipse", args);
  }
  circle(...args) {
    return this._callContextMethod("circle", args);
  }
  path(...args) {
    return this._callContextMethod("path", args);
  }
  lineTo(...args) {
    return this._callContextMethod("lineTo", args);
  }
  moveTo(...args) {
    return this._callContextMethod("moveTo", args);
  }
  quadraticCurveTo(...args) {
    return this._callContextMethod("quadraticCurveTo", args);
  }
  rect(...args) {
    return this._callContextMethod("rect", args);
  }
  roundRect(...args) {
    return this._callContextMethod("roundRect", args);
  }
  poly(...args) {
    return this._callContextMethod("poly", args);
  }
  star(...args) {
    return this._callContextMethod("star", args);
  }
  svg(...args) {
    return this._callContextMethod("svg", args);
  }
  restore(...args) {
    return this._callContextMethod("restore", args);
  }
  save(...args) {
    return this._callContextMethod("save", args);
  }
  getTransform(...args) {
    return this._callContextMethod("getTransform", args);
  }
  resetTransform(...args) {
    return this._callContextMethod("resetTransform", args);
  }
  rotateTransform(...args) {
    return this._callContextMethod("rotate", args);
  }
  scaleTransform(...args) {
    return this._callContextMethod("scale", args);
  }
  setTransform(...args) {
    return this._callContextMethod("setTransform", args);
  }
  transform(...args) {
    return this._callContextMethod("transform", args);
  }
  translateTransform(...args) {
    return this._callContextMethod("translate", args);
  }
  clear(...args) {
    return this._callContextMethod("clear", args);
  }
  get fillStyle() {
    return this.view.context.fillStyle;
  }
  set fillStyle(value) {
    this.view.context.fillStyle = value;
  }
  get strokeStyle() {
    return this.view.context.strokeStyle;
  }
  set strokeStyle(value) {
    this.view.context.strokeStyle = value;
  }
  // v7 deprecations
  /**
   * @param color
   * @param alpha
   * @deprecated since 8.0.0
   */
  beginFill(color, alpha) {
    deprecation("8.0.0", "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
    this.endFill();
    this.context.fillStyle = { color, alpha };
    return this;
  }
  /**
   * @deprecated since 8.0.0
   */
  endFill() {
    deprecation("8.0.0", "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
    this.context.fill();
    return this;
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0
   */
  drawCircle(...args) {
    deprecation("8.0.0", "Graphics#drawCircle has been renamed to Graphics#circle");
    return this._callContextMethod("circle", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0
   */
  drawEllipse(...args) {
    deprecation("8.0.0", "Graphics#drawEllipse has been renamed to Graphics#ellipse");
    return this._callContextMethod("ellipse", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0
   */
  drawPolygon(...args) {
    deprecation("8.0.0", "Graphics#drawPolygon has been renamed to Graphics#poly");
    return this._callContextMethod("poly", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0
   */
  drawRect(...args) {
    deprecation("8.0.0", "Graphics#drawRect has been renamed to Graphics#rect");
    return this._callContextMethod("rect", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0
   */
  drawRoundedRect(...args) {
    deprecation("8.0.0", "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");
    return this._callContextMethod("roundRect", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0
   */
  drawStar(...args) {
    deprecation("8.0.0", "Graphics#drawStar has been renamed to Graphics#star");
    return this._callContextMethod("star", args);
  }
  get roundPixels() {
    return !!this.view.roundPixels;
  }
  set roundPixels(value) {
    this.view.roundPixels = value ? 1 : 0;
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/mesh-extras/NineSliceGeometry.mjs
init_Matrix();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/mesh-extras/PlaneGeometry.mjs
init_deprecation();
init_MeshGeometry();
var _PlaneGeometry = class extends MeshGeometry {
  constructor(...args) {
    super({});
    let options = args[0] ?? {};
    if (typeof options === "number") {
      deprecation(v8_0_0, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead");
      options = {
        width: options,
        height: args[1],
        verticesX: args[2],
        verticesY: args[3]
      };
    }
    this.build(options);
  }
  /**
   * Refreshes plane coordinates
   * @param options
   */
  build(options) {
    options = { ..._PlaneGeometry.defaultOptions, ...options };
    this.verticesX = this.verticesX ?? options.verticesX;
    this.verticesY = this.verticesY ?? options.verticesY;
    this.width = this.width ?? options.width;
    this.height = this.height ?? options.height;
    const total = this.verticesX * this.verticesY;
    const verts = [];
    const uvs = [];
    const indices = [];
    const verticesX = this.verticesX - 1;
    const verticesY = this.verticesY - 1;
    const sizeX = this.width / verticesX;
    const sizeY = this.height / verticesY;
    for (let i3 = 0; i3 < total; i3++) {
      const x3 = i3 % this.verticesX;
      const y2 = i3 / this.verticesX | 0;
      verts.push(x3 * sizeX, y2 * sizeY);
      uvs.push(x3 / verticesX, y2 / verticesY);
    }
    const totalSub = verticesX * verticesY;
    for (let i3 = 0; i3 < totalSub; i3++) {
      const xpos = i3 % verticesX;
      const ypos = i3 / verticesX | 0;
      const value = ypos * this.verticesX + xpos;
      const value2 = ypos * this.verticesX + xpos + 1;
      const value3 = (ypos + 1) * this.verticesX + xpos;
      const value4 = (ypos + 1) * this.verticesX + xpos + 1;
      indices.push(
        value,
        value2,
        value3,
        value2,
        value4,
        value3
      );
    }
    this.buffers[0].data = new Float32Array(verts);
    this.buffers[1].data = new Float32Array(uvs);
    this.indexBuffer.data = new Uint32Array(indices);
    this.buffers[0].update();
    this.buffers[1].update();
    this.indexBuffer.update();
  }
};
var PlaneGeometry = _PlaneGeometry;
PlaneGeometry.defaultOptions = {
  width: 100,
  height: 100,
  verticesX: 10,
  verticesY: 10
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/mesh-extras/NineSliceGeometry.mjs
var _NineSliceGeometry = class extends PlaneGeometry {
  constructor(options) {
    options = { ..._NineSliceGeometry.defaultOptions, ...options };
    super({
      width: options.width,
      height: options.height,
      verticesX: 4,
      verticesY: 4
    });
    this._textureMatrix = new Matrix();
    this.update(options);
  }
  update(options) {
    this.updateUvs(options);
    this.updatePositions(options);
  }
  updatePositions(options) {
    this.width = options.width ?? this.width;
    this.height = options.height ?? this.height;
    this._leftWidth = options.leftWidth ?? this._leftWidth;
    this._rightWidth = options.rightWidth ?? this._rightWidth;
    this._topHeight = options.topHeight ?? this._topHeight;
    this._bottomHeight = options.bottomHeight ?? this._bottomHeight;
    const positions = this.positions;
    const w2 = this._leftWidth + this._rightWidth;
    const scaleW = this.width > w2 ? 1 : this.width / w2;
    const h2 = this._topHeight + this._bottomHeight;
    const scaleH = this.height > h2 ? 1 : this.height / h2;
    const scale3 = Math.min(scaleW, scaleH);
    positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale3;
    positions[17] = positions[19] = positions[21] = positions[23] = this.height - this._bottomHeight * scale3;
    positions[25] = positions[27] = positions[29] = positions[31] = this.height;
    positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale3;
    positions[4] = positions[12] = positions[20] = positions[28] = this.width - this._rightWidth * scale3;
    positions[6] = positions[14] = positions[22] = positions[30] = this.width;
    this.getBuffer("aPosition").update();
  }
  updateUvs(options) {
    this._originalWidth = options.originalWidth ?? this._originalWidth;
    this._originalHeight = options.originalHeight ?? this._originalHeight;
    this._leftWidth = options.leftWidth ?? this._leftWidth;
    this._rightWidth = options.rightWidth ?? this._rightWidth;
    this._topHeight = options.topHeight ?? this._topHeight;
    this._bottomHeight = options.bottomHeight ?? this._bottomHeight;
    if (options.textureMatrix) {
      this._textureMatrix.copyFrom(options.textureMatrix);
    }
    const textureMatrix = this._textureMatrix;
    const uvs = this.uvs;
    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
    const _uvw = 1 / this._originalWidth;
    const _uvh = 1 / this._originalHeight;
    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
    multiplyUvs(textureMatrix, uvs);
    this.getBuffer("aUV").update();
  }
};
var NineSliceGeometry = _NineSliceGeometry;
NineSliceGeometry.defaultOptions = {
  width: 100,
  height: 100,
  leftWidth: 10,
  topHeight: 10,
  rightWidth: 10,
  bottomHeight: 10,
  originalWidth: 100,
  originalHeight: 100
};
function multiplyUvs(matrix, uvs, out3) {
  out3 ?? (out3 = uvs);
  const a2 = matrix.a;
  const b2 = matrix.b;
  const c2 = matrix.c;
  const d3 = matrix.d;
  const tx = matrix.tx;
  const ty = matrix.ty;
  for (let i3 = 0; i3 < uvs.length; i3 += 2) {
    const x3 = uvs[i3];
    const y2 = uvs[i3 + 1];
    out3[i3] = x3 * a2 + y2 * c2 + tx;
    out3[i3 + 1] = x3 * b2 + y2 * d3 + ty;
  }
  return out3;
}

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/mesh-extras/NineSliceSprite.mjs
init_Texture();
init_deprecation();
init_Container();
init_definedProps();
init_MeshView();
var _NineSliceSprite = class extends Container {
  /**
   * @param options - Options to use
   * @param options.texture - The texture to use on the NineSlicePlane.
   * @param options.leftWidth - Width of the left vertical bar (A)
   * @param options.topHeight - Height of the top horizontal bar (C)
   * @param options.rightWidth - Width of the right vertical bar (B)
   * @param options.bottomHeight - Height of the bottom horizontal bar (D)
   * @param options.width - Width of the NineSlicePlane,
   * setting this will actually modify the vertices and not the UV's of this plane.
   * @param options.height - Height of the NineSlicePlane,
   * setting this will actually modify the vertices and not UV's of this plane.
   */
  constructor(options) {
    if (options instanceof Texture) {
      options = { texture: options };
    }
    const { leftWidth, rightWidth, topHeight, bottomHeight, texture: optTex, ...rest } = options;
    const texture = optTex ?? _NineSliceSprite.defaultOptions.texture;
    const borders = texture.layout.defaultBorders;
    const nineSliceGeometry = new NineSliceGeometry(definedProps({
      width: texture.width,
      height: texture.height,
      originalWidth: texture.width,
      originalHeight: texture.height,
      leftWidth: leftWidth ?? borders?.left ?? _NineSliceSprite.defaultOptions.leftWidth,
      topHeight: topHeight ?? borders?.top ?? _NineSliceSprite.defaultOptions.topHeight,
      rightWidth: rightWidth ?? borders?.right ?? _NineSliceSprite.defaultOptions.rightWidth,
      bottomHeight: bottomHeight ?? borders?.bottom ?? _NineSliceSprite.defaultOptions.bottomHeight,
      textureMatrix: texture.textureMatrix.mapCoord
    }));
    super({
      view: new MeshView(definedProps({
        geometry: nineSliceGeometry,
        texture
      })),
      label: "NineSliceSprite",
      ...rest
    });
    this.allowChildren = false;
  }
  // /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
  get width() {
    return this.view.geometry.width;
  }
  set width(value) {
    this.view.geometry.updatePositions({
      width: value
    });
  }
  get height() {
    return this.view.geometry.height;
  }
  set height(value) {
    this.view.geometry.updatePositions({
      height: value
    });
  }
  get leftWidth() {
    return this.view.geometry._leftWidth;
  }
  set leftWidth(value) {
    this.view.geometry.updateUvs({
      leftWidth: value
    });
  }
  get topHeight() {
    return this.view.geometry._topHeight;
  }
  set topHeight(value) {
    this.view.geometry.updateUvs({
      topHeight: value
    });
  }
  get rightWidth() {
    return this.view.geometry._rightWidth;
  }
  set rightWidth(value) {
    this.view.geometry.updateUvs({
      rightWidth: value
    });
  }
  get bottomHeight() {
    return this.view.geometry._bottomHeight;
  }
  set bottomHeight(value) {
    this.view.geometry.updateUvs({
      bottomHeight: value
    });
  }
  get texture() {
    return this.view.texture;
  }
  set texture(value) {
    if (value === this.view.texture)
      return;
    this.view.geometry.updateUvs({
      originalWidth: value.width,
      originalHeight: value.height,
      textureMatrix: value.textureMatrix.mapCoord
    });
    this.view.texture = value;
  }
  get roundPixels() {
    return !!this.view.roundPixels;
  }
  set roundPixels(value) {
    this.view.roundPixels = value ? 1 : 0;
  }
};
var NineSliceSprite = _NineSliceSprite;
NineSliceSprite.defaultOptions = {
  texture: Texture.EMPTY,
  leftWidth: 10,
  topHeight: 10,
  rightWidth: 10,
  bottomHeight: 10
};
var NineSlicePlane = class extends NineSliceSprite {
  constructor(...args) {
    let options = args[0];
    if (options instanceof Texture) {
      deprecation(v8_0_0, "NineSlicePlane now uses the options object {texture, leftWidth, rightWidth, topHeight, bottomHeight}");
      options = {
        texture: options,
        leftWidth: args[1],
        topHeight: args[2],
        rightWidth: args[3],
        bottomHeight: args[4]
      };
    }
    deprecation(v8_0_0, "NineSlicePlane is deprecated. Use NineSliceSprite instead.");
    super(options);
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/sprite-animated/AnimatedSprite.mjs
init_Texture();
init_const2();
init_Ticker();
init_Sprite();
var AnimatedSprite = class _AnimatedSprite extends Sprite {
  /**
   * @param textures - An array of {@link Texture} or frame
   *  objects that make up the animation.
   * @param {boolean} [autoUpdate=true] - Whether to use Ticker.shared to auto update animation time.
   */
  constructor(textures, autoUpdate = true) {
    super(textures[0] instanceof Texture ? textures[0] : textures[0].texture);
    this._textures = null;
    this._durations = null;
    this._autoUpdate = autoUpdate;
    this._isConnectedToTicker = false;
    this.animationSpeed = 1;
    this.loop = true;
    this.updateAnchor = false;
    this.onComplete = null;
    this.onFrameChange = null;
    this.onLoop = null;
    this._currentTime = 0;
    this._playing = false;
    this._previousFrame = null;
    this.textures = textures;
  }
  /** Stops the AnimatedSprite. */
  stop() {
    if (!this._playing) {
      return;
    }
    this._playing = false;
    if (this._autoUpdate && this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  }
  /** Plays the AnimatedSprite. */
  play() {
    if (this._playing) {
      return;
    }
    this._playing = true;
    if (this._autoUpdate && !this._isConnectedToTicker) {
      Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);
      this._isConnectedToTicker = true;
    }
  }
  /**
   * Stops the AnimatedSprite and goes to a specific frame.
   * @param frameNumber - Frame index to stop at.
   */
  gotoAndStop(frameNumber) {
    this.stop();
    this.currentFrame = frameNumber;
  }
  /**
   * Goes to a specific frame and begins playing the AnimatedSprite.
   * @param frameNumber - Frame index to start at.
   */
  gotoAndPlay(frameNumber) {
    this.currentFrame = frameNumber;
    this.play();
  }
  /**
   * Updates the object transform for rendering.
   * @param ticker - {Ticker} - current delta time
   * @param ticker.deltaTime - the delta time since the last tick
   */
  update(ticker) {
    if (!this._playing) {
      return;
    }
    const deltaTime = ticker.deltaTime;
    const elapsed = this.animationSpeed * deltaTime;
    const previousFrame = this.currentFrame;
    if (this._durations !== null) {
      let lag = this._currentTime % 1 * this._durations[this.currentFrame];
      lag += elapsed / 60 * 1e3;
      while (lag < 0) {
        this._currentTime--;
        lag += this._durations[this.currentFrame];
      }
      const sign2 = Math.sign(this.animationSpeed * deltaTime);
      this._currentTime = Math.floor(this._currentTime);
      while (lag >= this._durations[this.currentFrame]) {
        lag -= this._durations[this.currentFrame] * sign2;
        this._currentTime += sign2;
      }
      this._currentTime += lag / this._durations[this.currentFrame];
    } else {
      this._currentTime += elapsed;
    }
    if (this._currentTime < 0 && !this.loop) {
      this.gotoAndStop(0);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (this._currentTime >= this._textures.length && !this.loop) {
      this.gotoAndStop(this._textures.length - 1);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (previousFrame !== this.currentFrame) {
      if (this.loop && this.onLoop) {
        if (this.animationSpeed > 0 && this.currentFrame < previousFrame || this.animationSpeed < 0 && this.currentFrame > previousFrame) {
          this.onLoop();
        }
      }
      this._updateTexture();
    }
  }
  /** Updates the displayed texture to match the current frame index. */
  _updateTexture() {
    const currentFrame = this.currentFrame;
    if (this._previousFrame === currentFrame) {
      return;
    }
    this._previousFrame = currentFrame;
    this.texture = this._textures[currentFrame];
    if (this.updateAnchor) {
      this.anchor.copyFrom(this.texture.layout.defaultAnchor);
    }
    if (this.onFrameChange) {
      this.onFrameChange(this.currentFrame);
    }
  }
  /** Stops the AnimatedSprite and destroys it. */
  destroy() {
    this.stop();
    super.destroy();
    this.onComplete = null;
    this.onFrameChange = null;
    this.onLoop = null;
  }
  /**
   * A short hand way of creating an AnimatedSprite from an array of frame ids.
   * @param frames - The array of frames ids the AnimatedSprite will use as its texture frames.
   * @returns - The new animated sprite with the specified frames.
   */
  static fromFrames(frames) {
    const textures = [];
    for (let i3 = 0; i3 < frames.length; ++i3) {
      textures.push(Texture.from(frames[i3]));
    }
    return new _AnimatedSprite(textures);
  }
  /**
   * A short hand way of creating an AnimatedSprite from an array of image ids.
   * @param images - The array of image urls the AnimatedSprite will use as its texture frames.
   * @returns The new animate sprite with the specified images as frames.
   */
  static fromImages(images) {
    const textures = [];
    for (let i3 = 0; i3 < images.length; ++i3) {
      textures.push(Texture.from(images[i3]));
    }
    return new _AnimatedSprite(textures);
  }
  /**
   * The total number of frames in the AnimatedSprite. This is the same as number of textures
   * assigned to the AnimatedSprite.
   * @readonly
   * @default 0
   */
  get totalFrames() {
    return this._textures.length;
  }
  /** The array of textures used for this AnimatedSprite. */
  get textures() {
    return this._textures;
  }
  set textures(value) {
    if (value[0] instanceof Texture) {
      this._textures = value;
      this._durations = null;
    } else {
      this._textures = [];
      this._durations = [];
      for (let i3 = 0; i3 < value.length; i3++) {
        this._textures.push(value[i3].texture);
        this._durations.push(value[i3].time);
      }
    }
    this._previousFrame = null;
    this.gotoAndStop(0);
    this._updateTexture();
  }
  /** The AnimatedSprite's current frame index. */
  get currentFrame() {
    let currentFrame = Math.floor(this._currentTime) % this._textures.length;
    if (currentFrame < 0) {
      currentFrame += this._textures.length;
    }
    return currentFrame;
  }
  set currentFrame(value) {
    if (value < 0 || value > this.totalFrames - 1) {
      throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
    }
    const previousFrame = this.currentFrame;
    this._currentTime = value;
    if (previousFrame !== this.currentFrame) {
      this._updateTexture();
    }
  }
  /**
   * Indicates if the AnimatedSprite is currently playing.
   * @readonly
   */
  get playing() {
    return this._playing;
  }
  /** Whether to use Ticker.shared to auto update animation time. */
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    if (value !== this._autoUpdate) {
      this._autoUpdate = value;
      if (!this._autoUpdate && this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
        Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    }
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.mjs
init_Container();
init_definedProps();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpriteView.mjs
init_ObservablePoint();
init_Texture();
init_View();
init_uid();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/utils/Transform.mjs
init_Matrix();
init_ObservablePoint();
var Transform = class {
  constructor({ matrix, observer } = {}) {
    this.dirty = true;
    this._matrix = matrix ?? new Matrix();
    this.observer = observer;
    this.position = new ObservablePoint(this, 0, 0);
    this.scale = new ObservablePoint(this, 1, 1);
    this.pivot = new ObservablePoint(this, 0, 0);
    this.skew = new ObservablePoint(this, 0, 0);
    this._rotation = 0;
    this._cx = 1;
    this._sx = 0;
    this._cy = 0;
    this._sy = 1;
  }
  get matrix() {
    const lt = this._matrix;
    if (!this.dirty)
      return lt;
    lt.a = this._cx * this.scale.x;
    lt.b = this._sx * this.scale.x;
    lt.c = this._cy * this.scale.y;
    lt.d = this._sy * this.scale.y;
    lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
    lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
    this.dirty = false;
    return lt;
  }
  /**
   * Called when a value changes.
   * @param point
   * @internal
   */
  onUpdate(point) {
    this.dirty = true;
    if (point === this.skew) {
      this.updateSkew();
    }
    this.observer?.onUpdate(this);
  }
  /** Called when the skew or the rotation changes. */
  updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew.y);
    this._sx = Math.sin(this._rotation + this.skew.y);
    this._cy = -Math.sin(this._rotation - this.skew.x);
    this._sy = Math.cos(this._rotation - this.skew.x);
    this.dirty = true;
  }
  toString() {
    return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
  }
  /**
   * Decomposes a matrix and sets the transforms properties based on it.
   * @param matrix - The matrix to decompose
   */
  setFromMatrix(matrix) {
    matrix.decompose(this);
    this.dirty = true;
  }
  /** The rotation of the object in radians. */
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    if (this._rotation !== value) {
      this._rotation = value;
      this.updateSkew();
    }
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpriteView.mjs
var _TilingSpriteView = class {
  constructor(options) {
    this.owner = emptyViewObserver;
    this.uid = uid("tilingSpriteView");
    this.renderPipeId = "tilingSprite";
    this.batched = true;
    this.roundPixels = 0;
    this._bounds = [0, 1, 0, 0];
    this._boundsDirty = true;
    options = { ..._TilingSpriteView.defaultOptions, ...options };
    this.anchor = new ObservablePoint(this, 0, 0);
    this._applyAnchorToTexture = options.applyAnchorToTexture;
    this.texture = options.texture;
    this._width = options.width;
    this._height = options.height;
    this._tileTransform = new Transform({ observer: this });
  }
  get bounds() {
    if (this._boundsDirty) {
      this._updateBounds();
      this._boundsDirty = false;
    }
    return this._bounds;
  }
  set texture(value) {
    if (this._texture === value)
      return;
    this._texture = value;
    this.onUpdate();
  }
  get texture() {
    return this._texture;
  }
  set width(value) {
    this._width = value;
    this.onUpdate();
  }
  get width() {
    return this._width;
  }
  set height(value) {
    this._height = value;
    this.onUpdate();
  }
  get height() {
    return this._height;
  }
  _updateBounds() {
    const bounds = this._bounds;
    const anchor = this.anchor;
    const width = this._width;
    const height = this._height;
    bounds[1] = -anchor._x * width;
    bounds[0] = bounds[1] + width;
    bounds[3] = -anchor._y * height;
    bounds[2] = bounds[3] + height;
  }
  addBounds(bounds) {
    const _bounds = this.bounds;
    bounds.addFrame(
      _bounds[0],
      _bounds[2],
      _bounds[1],
      _bounds[3]
    );
  }
  containsPoint(point) {
    const width = this.bounds[2];
    const height = this.bounds[3];
    const x1 = -width * this.anchor.x;
    let y1 = 0;
    if (point.x >= x1 && point.x < x1 + width) {
      y1 = -height * this.anchor.y;
      if (point.y >= y1 && point.y < y1 + height)
        return true;
    }
    return false;
  }
  /**
   * @internal
   */
  onUpdate() {
    this._boundsDirty = true;
    this._didUpdate = true;
    this.owner.onViewUpdate();
  }
  /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
   */
  destroy(options = false) {
    this.anchor = null;
    this._tileTransform = null;
    this._bounds = null;
    const destroyTexture = typeof options === "boolean" ? options : options?.texture;
    if (destroyTexture) {
      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
      this._texture.destroy(destroyTextureSource);
    }
    this._texture = null;
  }
};
var TilingSpriteView = _TilingSpriteView;
TilingSpriteView.defaultOptions = {
  texture: Texture.WHITE,
  width: 256,
  height: 256,
  applyAnchorToTexture: false
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.mjs
var TilingSprite = class extends Container {
  constructor(options) {
    const { texture, width, height, applyAnchorToTexture, ...rest } = options ?? {};
    super({
      view: new TilingSpriteView(definedProps({
        texture,
        width,
        height,
        applyAnchorToTexture
      })),
      label: "TilingSprite",
      ...rest
    });
    this.allowChildren = false;
  }
  set texture(value) {
    this.view.texture = value;
  }
  get texture() {
    return this.view.texture;
  }
  get anchor() {
    return this.view.anchor;
  }
  set anchor(value) {
    this.view.anchor.x = value.x;
    this.view.anchor.y = value.y;
  }
  get width() {
    return this.view.width;
  }
  set width(value) {
    this.view.width = value;
  }
  get height() {
    return this.view.height;
  }
  set height(value) {
    this.view.height = value;
  }
  get tilePosition() {
    return this.view._tileTransform.position;
  }
  set tilePosition(value) {
    this.view._tileTransform.position.copyFrom(value);
  }
  get tileScale() {
    return this.view._tileTransform.scale;
  }
  set tileScale(value) {
    this.view._tileTransform.scale.copyFrom(value);
  }
  set tileRotation(value) {
    this.view._tileTransform.rotation = value;
  }
  get tileRotation() {
    return this.view._tileTransform.rotation;
  }
  get tileTransform() {
    return this.view._tileTransform;
  }
  get roundPixels() {
    return !!this.view.roundPixels;
  }
  set roundPixels(value) {
    this.view.roundPixels = value ? 1 : 0;
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/index.mjs
init_Sprite();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/HtmlTextStyle.mjs
init_warn();
init_TextStyle();
init_generateTextStyleKey();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/utils/textStyleToCSS.mjs
init_Color();
function textStyleToCSS(style) {
  const stroke = style._stroke;
  const fill = style._fill;
  return [
    `transform-origin: top left`,
    "display: inline-block",
    `color: ${Color.shared.setValue(fill.color).toHex()}`,
    `font-size: ${style.fontSize}px`,
    `font-family: ${style.fontFamily}`,
    `font-weight: ${style.fontWeight}`,
    `font-style: ${style.fontStyle}`,
    `font-variant: ${style.fontVariant}`,
    `letter-spacing: ${style.letterSpacing}px`,
    `text-align: ${style.align}`,
    `padding: ${style.padding}px`,
    `white-space: ${style.whiteSpace}`,
    ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],
    ...style.wordWrap ? [
      `word-wrap: ${style.breakWords ? "break-all" : "break-word"}`,
      `max-width: ${style.wordWrapWidth}px`
    ] : [],
    ...stroke ? [
      `-webkit-text-stroke-width: ${stroke.width}px`,
      `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,
      `text-stroke-width: ${stroke.width}px`,
      `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,
      "paint-order: stroke"
    ] : [],
    ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],
    ...style.cssOverrides
  ].join(";");
}
function dropShadowToCSS(dropShadowStyle) {
  const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();
  const x3 = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);
  const y2 = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);
  const position = `${x3}px ${y2}px`;
  if (dropShadowStyle.blur > 0) {
    return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;
  }
  return `text-shadow: ${position} ${color}`;
}

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/html/HtmlTextStyle.mjs
var HTMLTextStyle = class _HTMLTextStyle extends TextStyle {
  constructor(options) {
    super(options);
    this._cssOverrides = [];
    this.cssOverrides ?? (this.cssOverrides = options.cssOverrides);
  }
  set cssOverrides(value) {
    this._cssOverrides = value instanceof Array ? value : [value];
    this.update();
  }
  get cssOverrides() {
    return this._cssOverrides;
  }
  _generateKey() {
    this._styleKey = generateTextStyleKey(this) + this._cssOverrides.join("-");
    return this._styleKey;
  }
  update() {
    this._cssStyle = null;
    super.update();
  }
  clone() {
    return new _HTMLTextStyle({
      align: this.align,
      breakWords: this.breakWords,
      dropShadow: this.dropShadow,
      fill: this._fill,
      fontFamily: this.fontFamily,
      fontSize: this.fontSize,
      fontStyle: this.fontStyle,
      fontVariant: this.fontVariant,
      fontWeight: this.fontWeight,
      letterSpacing: this.letterSpacing,
      lineHeight: this.lineHeight,
      padding: this.padding,
      stroke: this._stroke,
      whiteSpace: this.whiteSpace,
      wordWrap: this.wordWrap,
      wordWrapWidth: this.wordWrapWidth,
      cssOverrides: this.cssOverrides
    });
  }
  get cssStyle() {
    if (!this._cssStyle) {
      this._cssStyle = textStyleToCSS(this);
    }
    return this._cssStyle;
  }
  /**
   * Add a style override, this can be any CSS property
   * it will override any built-in style. This is the
   * property and the value as a string (e.g., `color: red`).
   * This will override any other internal style.
   * @param {string} value - CSS style(s) to add.
   * @example
   * style.addOverride('background-color: red');
   */
  addOverride(...value) {
    const toAdd = value.filter((v3) => !this.cssOverrides.includes(v3));
    if (toAdd.length > 0) {
      this.cssOverrides.push(...toAdd);
      this.update();
    }
  }
  /**
   * Remove any overrides that match the value.
   * @param {string} value - CSS style to remove.
   * @example
   * style.removeOverride('background-color: red');
   */
  removeOverride(...value) {
    const toRemove = value.filter((v3) => this.cssOverrides.includes(v3));
    if (toRemove.length > 0) {
      this.cssOverrides = this.cssOverrides.filter((v3) => !toRemove.includes(v3));
      this.update();
    }
  }
  set fill(value) {
    if (typeof value !== "string" && typeof value !== "number") {
      warn("[HTMLTextStyle] only color fill is not supported by HTMLText");
    }
    super.fill = value;
  }
  set stroke(value) {
    if (value && typeof value !== "string" && typeof value !== "number") {
      warn("[HTMLTextStyle] only color stroke is not supported by HTMLText");
    }
    super.stroke = value;
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/Text.mjs
init_deprecation();
init_Container();
init_definedProps();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/TextView.mjs
init_Cache();
init_ObservablePoint();
init_View();
init_uid();
init_BitmapFont();
init_BitmapFontManager();
init_DynamicBitmapFont();
init_CanvasTextMetrics();
init_measureHtmlText();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/utils/ensureTextStyle.mjs
init_TextStyle();
function ensureTextStyle(renderMode, style) {
  if (style instanceof TextStyle || style instanceof HTMLTextStyle) {
    return style;
  }
  return renderMode === "html" ? new HTMLTextStyle(style) : new TextStyle(style);
}

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/TextView.mjs
var map = {
  canvas: "text",
  html: "htmlText",
  bitmap: "bitmapText"
};
var TextView = class {
  constructor(options) {
    this.uid = uid("textView");
    this.renderPipeId = "text";
    this.owner = emptyViewObserver;
    this.batched = true;
    this.resolution = null;
    this._didUpdate = true;
    this.roundPixels = 0;
    this._bounds = [0, 1, 0, 0];
    this._boundsDirty = true;
    this.text = options.text ?? "";
    const renderMode = options.renderMode ?? this._detectRenderType(options.style);
    this._renderMode = renderMode;
    this._style = ensureTextStyle(renderMode, options.style);
    this.renderPipeId = map[renderMode];
    this.anchor = new ObservablePoint(this, 0, 0);
    this.resolution = options.resolution ?? null;
  }
  set text(value) {
    value = value.toString();
    if (this._text === value)
      return;
    this._text = value;
    this.onUpdate();
  }
  get text() {
    return this._text;
  }
  get style() {
    return this._style;
  }
  set style(style) {
    style = style || {};
    this._style?.off("update", this.onUpdate, this);
    this._style = ensureTextStyle(this._renderMode, style);
    this._style.on("update", this.onUpdate, this);
    this.onUpdate();
  }
  get bounds() {
    if (this._boundsDirty) {
      this._updateBounds();
      this._boundsDirty = false;
    }
    return this._bounds;
  }
  addBounds(bounds) {
    const _bounds = this.bounds;
    bounds.addFrame(
      _bounds[0],
      _bounds[2],
      _bounds[1],
      _bounds[3]
    );
  }
  containsPoint(point) {
    const width = this.bounds[2];
    const height = this.bounds[3];
    const x1 = -width * this.anchor.x;
    let y1 = 0;
    if (point.x >= x1 && point.x < x1 + width) {
      y1 = -height * this.anchor.y;
      if (point.y >= y1 && point.y < y1 + height)
        return true;
    }
    return false;
  }
  /** @internal */
  onUpdate() {
    this._didUpdate = true;
    this._boundsDirty = true;
    this.owner.onViewUpdate();
  }
  /** @internal */
  _getKey() {
    return `${this.text}:${this._style.styleKey}`;
  }
  _updateBounds() {
    const bounds = this._bounds;
    const padding = this._style.padding;
    const anchor = this.anchor;
    if (this.renderPipeId === "bitmapText") {
      const bitmapMeasurement = BitmapFontManager.measureText(this.text, this._style);
      const scale3 = bitmapMeasurement.scale;
      const offset = bitmapMeasurement.offsetY * scale3;
      const width = bitmapMeasurement.width * scale3;
      const height = bitmapMeasurement.height * scale3;
      bounds[0] = -anchor._x * width - padding;
      bounds[1] = bounds[0] + width;
      bounds[2] = -anchor._y * (height + offset) - padding;
      bounds[3] = bounds[2] + height;
    } else if (this.renderPipeId === "htmlText") {
      const htmlMeasurement = measureHtmlText(this.text, this._style);
      const { width, height } = htmlMeasurement;
      bounds[0] = -anchor._x * width - padding;
      bounds[1] = bounds[0] + width;
      bounds[2] = -anchor._y * height - padding;
      bounds[3] = bounds[2] + height;
    } else {
      const canvasMeasurement = CanvasTextMetrics.measureText(this.text, this._style);
      const { width, height } = canvasMeasurement;
      bounds[0] = -anchor._x * width - padding;
      bounds[1] = bounds[0] + width;
      bounds[2] = -anchor._y * height - padding;
      bounds[3] = bounds[2] + height;
    }
  }
  _detectRenderType(style) {
    if (style instanceof HTMLTextStyle) {
      return "html";
    }
    const fontData = Cache.get(style?.fontFamily);
    if (fontData instanceof DynamicBitmapFont || fontData instanceof BitmapFont) {
      return "bitmap";
    }
    return "canvas";
  }
  /**
   * Destroys this text renderable and optionally its style texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style
   */
  destroy(options = false) {
    this.owner = null;
    this._bounds = null;
    this.anchor = null;
    this._style.destroy(options);
    this._style = null;
    this._text = null;
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/scene/text/Text.mjs
var Text = class extends Container {
  constructor(...args) {
    let options = args[0];
    if (typeof options === "string" || args[1]) {
      deprecation(v8_0_0, 'use new Text({ text: "hi!", style }) instead');
      options = {
        text: options,
        style: args[1]
      };
    }
    const { style, text, renderMode, resolution, ...rest } = options;
    super({
      view: new TextView(definedProps({ style, text, renderMode, resolution })),
      label: "Text",
      ...rest
    });
    this.allowChildren = false;
  }
  get anchor() {
    return this.view.anchor;
  }
  set anchor(value) {
    this.view.anchor.x = value.x;
    this.view.anchor.y = value.y;
  }
  set text(value) {
    this.view.text = value;
  }
  get text() {
    return this.view.text;
  }
  set style(value) {
    this.view.style = value;
  }
  get style() {
    return this.view.style;
  }
  get roundPixels() {
    return !!this.view.roundPixels;
  }
  set roundPixels(value) {
    this.view.roundPixels = value ? 1 : 0;
  }
};
var BitmapText2 = class extends Text {
  constructor(...args) {
    deprecation(v8_0_0, 'use new Text({ text: "hi!", style, renderMode: "bitmap" }) instead');
    let options = args[0];
    if (typeof options === "string" || args[1]) {
      options = {
        text: options,
        style: args[1]
      };
    }
    options.renderMode = "bitmap";
    super(options);
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.3/node_modules/pixi.js/lib/index.mjs
init_init5();
init_eventemitter3();
var import_earcut2 = __toESM(require_earcut(), 1);

// src/frontend/game/assets.ts
var loadedAssets = {};
async function loadAssets() {
  const sheet = await Assets.load("stars.json");
  const planetsheet = await Assets.load("planets.json");
  const uisheet = await Assets.load("uisheet.json");
  const planet = await Assets.load("planet.json");
  const buttonSheet = await Assets.load("ui/button.json");
  const font = await Assets.load("font.fnt");
  const buttonText = await Assets.load("buttontext.fnt");
  const segment = await Assets.load("segment.fnt");
  const buttonTextWhite = await Assets.load("buttontext_white.fnt");
  const bgTexture = await Assets.load("starfield.png");
  const navArrow = await Assets.load("navarrow.png");
  const starTexture = await Assets.load("stars.png");
  const shipyard = await Assets.load("shipyard.png");
  const station = await Assets.load("station.png");
  const jumpgate = await Assets.load("jumpgate.png");
  const treasure = await Assets.load("treasure-map.png");
  const select = await Assets.load("ui/select.png");
  const statsBlock = await Assets.load("ui/stats.png");
  const panel2 = await Assets.load("ui/panel2.png");
  const panelInvisible = await Assets.load("ui/panel_invisible.png");
  const selectInactive = await Assets.load("ui/select_inactive.png");
  const asteroidBelt = await Assets.load("asteroid_belt.png");
  const market = await Assets.load("money-bag-xxl.png");
  const spaceshipTexture = await Assets.load("spaceship.png");
  const probeTexture = await Assets.load("ships/PROBE.png");
  const lightFreighterTexture = await Assets.load("ships/LIGHT_FREIGHTER.png");
  loadedAssets = {
    sheet,
    planetsheet,
    uisheet,
    font,
    buttonsheet: buttonSheet,
    buttonText,
    planet,
    buttonTextWhite,
    bgTexture,
    navArrow,
    panelInvisible,
    starTexture,
    statsBlock,
    panel2,
    station,
    jumpgate,
    treasure,
    spaceshipTexture,
    spaceshipTextures: {
      FRAME_PROBE: probeTexture,
      FRAME_LIGHT_FREIGHTER: lightFreighterTexture,
      FRAME_EXPLORER: await Assets.load("ships/FRAME_EXPLORER.png")
    },
    asteroidBelt,
    shipyard,
    select,
    selectInactive,
    market,
    panel: await Assets.load("ui/panel.png"),
    button: await Assets.load("ui/button.png"),
    panelBg: await Assets.load("ui/panelbg.png")
  };
}

// ../../node_modules/.pnpm/@trpc+server@10.38.5/node_modules/@trpc/server/dist/observable-ade1bad8.mjs
function identity(x3) {
  return x3;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce((prev, fn) => fn(prev), input);
  };
}
function observable(subscribe) {
  const self2 = {
    subscribe(observer) {
      let teardownRef = null;
      let isDone = false;
      let unsubscribed = false;
      let teardownImmediately = false;
      function unsubscribe() {
        if (teardownRef === null) {
          teardownImmediately = true;
          return;
        }
        if (unsubscribed) {
          return;
        }
        unsubscribed = true;
        if (typeof teardownRef === "function") {
          teardownRef();
        } else if (teardownRef) {
          teardownRef.unsubscribe();
        }
      }
      teardownRef = subscribe({
        next(value) {
          if (isDone) {
            return;
          }
          observer.next?.(value);
        },
        error(err2) {
          if (isDone) {
            return;
          }
          isDone = true;
          observer.error?.(err2);
          unsubscribe();
        },
        complete() {
          if (isDone) {
            return;
          }
          isDone = true;
          observer.complete?.();
          unsubscribe();
        }
      });
      if (teardownImmediately) {
        unsubscribe();
      }
      return {
        unsubscribe
      };
    },
    pipe(...operations) {
      return pipeFromArray(operations)(self2);
    }
  };
  return self2;
}

// ../../node_modules/.pnpm/@trpc+server@10.38.5/node_modules/@trpc/server/dist/observable/index.mjs
function share(_opts) {
  return (originalObserver) => {
    let refCount = 0;
    let subscription = null;
    const observers = [];
    function startIfNeeded() {
      if (subscription) {
        return;
      }
      subscription = originalObserver.subscribe({
        next(value) {
          for (const observer of observers) {
            observer.next?.(value);
          }
        },
        error(error) {
          for (const observer of observers) {
            observer.error?.(error);
          }
        },
        complete() {
          for (const observer of observers) {
            observer.complete?.();
          }
        }
      });
    }
    function resetIfNeeded() {
      if (refCount === 0 && subscription) {
        const _sub = subscription;
        subscription = null;
        _sub.unsubscribe();
      }
    }
    return {
      subscribe(observer) {
        refCount++;
        observers.push(observer);
        startIfNeeded();
        return {
          unsubscribe() {
            refCount--;
            resetIfNeeded();
            const index = observers.findIndex((v3) => v3 === observer);
            if (index > -1) {
              observers.splice(index, 1);
            }
          }
        };
      }
    };
  };
}
var ObservableAbortError = class _ObservableAbortError extends Error {
  constructor(message) {
    super(message);
    this.name = "ObservableAbortError";
    Object.setPrototypeOf(this, _ObservableAbortError.prototype);
  }
};
function observableToPromise(observable2) {
  let abort2;
  const promise4 = new Promise((resolve2, reject) => {
    let isDone = false;
    function onDone() {
      if (isDone) {
        return;
      }
      isDone = true;
      reject(new ObservableAbortError("This operation was aborted."));
      obs$.unsubscribe();
    }
    const obs$ = observable2.subscribe({
      next(data) {
        isDone = true;
        resolve2(data);
        onDone();
      },
      error(data) {
        isDone = true;
        reject(data);
        onDone();
      },
      complete() {
        isDone = true;
        onDone();
      }
    });
    abort2 = onDone;
  });
  return {
    promise: promise4,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: abort2
  };
}

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/splitLink-4c75f7be.mjs
function createChain(opts) {
  return observable((observer) => {
    function execute(index = 0, op = opts.op) {
      const next = opts.links[index];
      if (!next) {
        throw new Error("No more links to execute - did you forget to add an ending link?");
      }
      const subscription = next({
        op,
        next(nextOp) {
          const nextObserver = execute(index + 1, nextOp);
          return nextObserver;
        }
      });
      return subscription;
    }
    const obs$ = execute();
    return obs$.subscribe(observer);
  });
}
function asArray(value) {
  return Array.isArray(value) ? value : [
    value
  ];
}
function splitLink(opts) {
  return (runtime) => {
    const yes = asArray(opts.true).map((link) => link(runtime));
    const no = asArray(opts.false).map((link) => link(runtime));
    return (props) => {
      return observable((observer) => {
        const links = opts.condition(props.op) ? yes : no;
        return createChain({
          op: props.op,
          links
        }).subscribe(observer);
      });
    };
  };
}

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/transformResult-ace864b8.mjs
function isObject(value) {
  return !!value && !Array.isArray(value) && typeof value === "object";
}
function transformResultInner(response, runtime) {
  if ("error" in response) {
    const error = runtime.transformer.deserialize(response.error);
    return {
      ok: false,
      error: {
        ...response,
        error
      }
    };
  }
  const result = {
    ...response.result,
    ...(!response.result.type || response.result.type === "data") && {
      type: "data",
      data: runtime.transformer.deserialize(response.result.data)
    }
  };
  return {
    ok: true,
    result
  };
}
var TransformResultError = class extends Error {
  constructor() {
    super("Unable to transform response from server");
  }
};
function transformResult(response, runtime) {
  let result;
  try {
    result = transformResultInner(response, runtime);
  } catch (err2) {
    throw new TransformResultError();
  }
  if (!result.ok && (!isObject(result.error.error) || typeof result.error.error.code !== "number")) {
    throw new TransformResultError();
  }
  if (result.ok && !isObject(result.result)) {
    throw new TransformResultError();
  }
  return result;
}

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/TRPCClientError-0de4d231.mjs
function isTRPCClientError(cause) {
  return cause instanceof TRPCClientError || /**
  * @deprecated
  * Delete in next major
  */
  cause instanceof Error && cause.name === "TRPCClientError";
}
function isTRPCErrorResponse(obj) {
  return isObject(obj) && isObject(obj.error) && typeof obj.error.code === "number" && typeof obj.error.message === "string";
}
var TRPCClientError = class _TRPCClientError extends Error {
  static from(_cause, opts = {}) {
    const cause = _cause;
    if (isTRPCClientError(cause)) {
      if (opts.meta) {
        cause.meta = {
          ...cause.meta,
          ...opts.meta
        };
      }
      return cause;
    }
    if (isTRPCErrorResponse(cause)) {
      return new _TRPCClientError(cause.error.message, {
        ...opts,
        result: cause
      });
    }
    if (!(cause instanceof Error)) {
      return new _TRPCClientError("Unknown error", {
        ...opts,
        cause
      });
    }
    return new _TRPCClientError(cause.message, {
      ...opts,
      cause
    });
  }
  constructor(message, opts) {
    const cause = opts?.cause;
    super(message, {
      cause
    });
    this.meta = opts?.meta;
    this.cause = cause;
    this.shape = opts?.result?.error;
    this.data = opts?.result?.error.data;
    this.name = "TRPCClientError";
    Object.setPrototypeOf(this, _TRPCClientError.prototype);
  }
};

// ../../node_modules/.pnpm/@trpc+server@10.38.5/node_modules/@trpc/server/dist/codes-c924c3db.mjs
function invert(obj) {
  const newObj = /* @__PURE__ */ Object.create(null);
  for (const key2 in obj) {
    const v3 = obj[key2];
    newObj[v3] = key2;
  }
  return newObj;
}
var TRPC_ERROR_CODES_BY_KEY = {
  /**
  * Invalid JSON was received by the server.
  * An error occurred on the server while parsing the JSON text.
  */
  PARSE_ERROR: -32700,
  /**
  * The JSON sent is not a valid Request object.
  */
  BAD_REQUEST: -32600,
  // Internal JSON-RPC error
  INTERNAL_SERVER_ERROR: -32603,
  NOT_IMPLEMENTED: -32603,
  // Implementation specific errors
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099
};
var TRPC_ERROR_CODES_BY_NUMBER = invert(TRPC_ERROR_CODES_BY_KEY);

// ../../node_modules/.pnpm/@trpc+server@10.38.5/node_modules/@trpc/server/dist/index-f91d720c.mjs
var TRPC_ERROR_CODES_BY_NUMBER2 = invert(TRPC_ERROR_CODES_BY_KEY);
var noop = () => {
};
function createInnerProxy(callback, path4) {
  const proxy = new Proxy(noop, {
    get(_obj, key2) {
      if (typeof key2 !== "string" || key2 === "then") {
        return void 0;
      }
      return createInnerProxy(callback, [
        ...path4,
        key2
      ]);
    },
    apply(_1, _2, args) {
      const isApply = path4[path4.length - 1] === "apply";
      return callback({
        args: isApply ? args.length >= 2 ? args[1] : [] : args,
        path: isApply ? path4.slice(0, -1) : path4
      });
    }
  });
  return proxy;
}
var createRecursiveProxy = (callback) => createInnerProxy(callback, []);
var createFlatProxy = (callback) => {
  return new Proxy(noop, {
    get(_obj, name) {
      if (typeof name !== "string" || name === "then") {
        return void 0;
      }
      return callback(name);
    }
  });
};

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/httpUtils-0cb58db4.mjs
var isFunction = (fn) => typeof fn === "function";
function getFetch(customFetchImpl) {
  if (customFetchImpl) {
    return customFetchImpl;
  }
  if (typeof window !== "undefined" && isFunction(window.fetch)) {
    return window.fetch;
  }
  if (typeof globalThis !== "undefined" && isFunction(globalThis.fetch)) {
    return globalThis.fetch;
  }
  throw new Error("No fetch implementation found");
}
function getAbortController(customAbortControllerImpl) {
  if (customAbortControllerImpl) {
    return customAbortControllerImpl;
  }
  if (typeof window !== "undefined" && window.AbortController) {
    return window.AbortController;
  }
  if (typeof globalThis !== "undefined" && globalThis.AbortController) {
    return globalThis.AbortController;
  }
  return null;
}
function resolveHTTPLinkOptions(opts) {
  return {
    url: opts.url,
    fetch: opts.fetch,
    AbortController: getAbortController(opts.AbortController)
  };
}
function arrayToDict(array) {
  const dict = {};
  for (let index = 0; index < array.length; index++) {
    const element = array[index];
    dict[index] = element;
  }
  return dict;
}
var METHOD = {
  query: "GET",
  mutation: "POST"
};
function getInput(opts) {
  return "input" in opts ? opts.runtime.transformer.serialize(opts.input) : arrayToDict(opts.inputs.map((_input) => opts.runtime.transformer.serialize(_input)));
}
var getUrl = (opts) => {
  let url2 = opts.url + "/" + opts.path;
  const queryParts = [];
  if ("inputs" in opts) {
    queryParts.push("batch=1");
  }
  if (opts.type === "query") {
    const input = getInput(opts);
    if (input !== void 0) {
      queryParts.push(`input=${encodeURIComponent(JSON.stringify(input))}`);
    }
  }
  if (queryParts.length) {
    url2 += "?" + queryParts.join("&");
  }
  return url2;
};
var getBody = (opts) => {
  if (opts.type === "query") {
    return void 0;
  }
  const input = getInput(opts);
  return input !== void 0 ? JSON.stringify(input) : void 0;
};
var jsonHttpRequester = (opts) => {
  return httpRequest({
    ...opts,
    contentTypeHeader: "application/json",
    getUrl,
    getBody
  });
};
async function fetchHTTPResponse(opts, ac) {
  const url2 = opts.getUrl(opts);
  const body = opts.getBody(opts);
  const { type: type2 } = opts;
  const resolvedHeaders = await opts.headers();
  if (type2 === "subscription") {
    throw new Error("Subscriptions should use wsLink");
  }
  const headers = {
    ...opts.contentTypeHeader ? {
      "content-type": opts.contentTypeHeader
    } : {},
    ...opts.batchModeHeader ? {
      "trpc-batch-mode": opts.batchModeHeader
    } : {},
    ...resolvedHeaders
  };
  return getFetch(opts.fetch)(url2, {
    method: METHOD[type2],
    signal: ac?.signal,
    body,
    headers
  });
}
function httpRequest(opts) {
  const ac = opts.AbortController ? new opts.AbortController() : null;
  const meta = {};
  let done = false;
  const promise4 = new Promise((resolve2, reject) => {
    fetchHTTPResponse(opts, ac).then((_res) => {
      meta.response = _res;
      done = true;
      return _res.json();
    }).then((json) => {
      meta.responseJSON = json;
      resolve2({
        json,
        meta
      });
    }).catch((err2) => {
      done = true;
      reject(TRPCClientError.from(err2, {
        meta
      }));
    });
  });
  const cancel = () => {
    if (!done) {
      ac?.abort();
    }
  };
  return {
    promise: promise4,
    cancel
  };
}

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/httpBatchLink-cee1f56c.mjs
var throwFatalError = () => {
  throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
};
function dataLoader(batchLoader) {
  let pendingItems = null;
  let dispatchTimer = null;
  const destroyTimerAndPendingItems = () => {
    clearTimeout(dispatchTimer);
    dispatchTimer = null;
    pendingItems = null;
  };
  function groupItems(items) {
    const groupedItems = [
      []
    ];
    let index = 0;
    while (true) {
      const item = items[index];
      if (!item) {
        break;
      }
      const lastGroup = groupedItems[groupedItems.length - 1];
      if (item.aborted) {
        item.reject?.(new Error("Aborted"));
        index++;
        continue;
      }
      const isValid = batchLoader.validate(lastGroup.concat(item).map((it) => it.key));
      if (isValid) {
        lastGroup.push(item);
        index++;
        continue;
      }
      if (lastGroup.length === 0) {
        item.reject?.(new Error("Input is too big for a single dispatch"));
        index++;
        continue;
      }
      groupedItems.push([]);
    }
    return groupedItems;
  }
  function dispatch() {
    const groupedItems = groupItems(pendingItems);
    destroyTimerAndPendingItems();
    for (const items of groupedItems) {
      if (!items.length) {
        continue;
      }
      const batch = {
        items,
        cancel: throwFatalError
      };
      for (const item of items) {
        item.batch = batch;
      }
      const unitResolver = (index, value) => {
        const item = batch.items[index];
        item.resolve?.(value);
        item.batch = null;
        item.reject = null;
        item.resolve = null;
      };
      const { promise: promise4, cancel } = batchLoader.fetch(batch.items.map((_item) => _item.key), unitResolver);
      batch.cancel = cancel;
      promise4.then((result) => {
        for (let i3 = 0; i3 < result.length; i3++) {
          const value = result[i3];
          unitResolver(i3, value);
        }
        for (const item of batch.items) {
          item.reject?.(new Error("Missing result"));
          item.batch = null;
        }
      }).catch((cause) => {
        for (const item of batch.items) {
          item.reject?.(cause);
          item.batch = null;
        }
      });
    }
  }
  function load(key2) {
    const item = {
      aborted: false,
      key: key2,
      batch: null,
      resolve: throwFatalError,
      reject: throwFatalError
    };
    const promise4 = new Promise((resolve2, reject) => {
      item.reject = reject;
      item.resolve = resolve2;
      if (!pendingItems) {
        pendingItems = [];
      }
      pendingItems.push(item);
    });
    if (!dispatchTimer) {
      dispatchTimer = setTimeout(dispatch);
    }
    const cancel = () => {
      item.aborted = true;
      if (item.batch?.items.every((item2) => item2.aborted)) {
        item.batch.cancel();
        item.batch = null;
      }
    };
    return {
      promise: promise4,
      cancel
    };
  }
  return {
    load
  };
}
function createHTTPBatchLink(requester) {
  return function httpBatchLink2(opts) {
    const resolvedOpts = resolveHTTPLinkOptions(opts);
    const maxURLLength = opts.maxURLLength ?? Infinity;
    return (runtime) => {
      const batchLoader = (type2) => {
        const validate = (batchOps) => {
          if (maxURLLength === Infinity) {
            return true;
          }
          const path4 = batchOps.map((op) => op.path).join(",");
          const inputs = batchOps.map((op) => op.input);
          const url2 = getUrl({
            ...resolvedOpts,
            runtime,
            type: type2,
            path: path4,
            inputs
          });
          return url2.length <= maxURLLength;
        };
        const fetch2 = requester({
          ...resolvedOpts,
          runtime,
          type: type2,
          opts
        });
        return {
          validate,
          fetch: fetch2
        };
      };
      const query = dataLoader(batchLoader("query"));
      const mutation = dataLoader(batchLoader("mutation"));
      const subscription = dataLoader(batchLoader("subscription"));
      const loaders = {
        query,
        subscription,
        mutation
      };
      return ({ op }) => {
        return observable((observer) => {
          const loader = loaders[op.type];
          const { promise: promise4, cancel } = loader.load(op);
          let _res = void 0;
          promise4.then((res) => {
            _res = res;
            const transformed = transformResult(res.json, runtime);
            if (!transformed.ok) {
              observer.error(TRPCClientError.from(transformed.error, {
                meta: res.meta
              }));
              return;
            }
            observer.next({
              context: res.meta,
              result: transformed.result
            });
            observer.complete();
          }).catch((err2) => {
            observer.error(TRPCClientError.from(err2, {
              meta: _res?.meta
            }));
          });
          return () => {
            cancel();
          };
        });
      };
    };
  };
}
var batchRequester = (requesterOpts) => {
  return (batchOps) => {
    const path4 = batchOps.map((op) => op.path).join(",");
    const inputs = batchOps.map((op) => op.input);
    const { promise: promise4, cancel } = jsonHttpRequester({
      ...requesterOpts,
      path: path4,
      inputs,
      headers() {
        if (!requesterOpts.opts.headers) {
          return {};
        }
        if (typeof requesterOpts.opts.headers === "function") {
          return requesterOpts.opts.headers({
            opList: batchOps
          });
        }
        return requesterOpts.opts.headers;
      }
    });
    return {
      promise: promise4.then((res) => {
        const resJSON = Array.isArray(res.json) ? res.json : batchOps.map(() => res.json);
        const result = resJSON.map((item) => ({
          meta: res.meta,
          json: item
        }));
        return result;
      }),
      cancel
    };
  };
};
var httpBatchLink = createHTTPBatchLink(batchRequester);

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/links/httpLink.mjs
function httpLinkFactory(factoryOpts) {
  return (opts) => {
    const resolvedOpts = resolveHTTPLinkOptions(opts);
    return (runtime) => ({ op }) => observable((observer) => {
      const { path: path4, input, type: type2 } = op;
      const { promise: promise4, cancel } = factoryOpts.requester({
        ...resolvedOpts,
        runtime,
        type: type2,
        path: path4,
        input,
        headers() {
          if (!opts.headers) {
            return {};
          }
          if (typeof opts.headers === "function") {
            return opts.headers({
              op
            });
          }
          return opts.headers;
        }
      });
      let meta = void 0;
      promise4.then((res) => {
        meta = res.meta;
        const transformed = transformResult(res.json, runtime);
        if (!transformed.ok) {
          observer.error(TRPCClientError.from(transformed.error, {
            meta
          }));
          return;
        }
        observer.next({
          context: res.meta,
          result: transformed.result
        });
        observer.complete();
      }).catch((cause) => {
        observer.error(TRPCClientError.from(cause, {
          meta
        }));
      });
      return () => {
        cancel();
      };
    });
  };
}
var httpLink = httpLinkFactory({
  requester: jsonHttpRequester
});

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/links/wsLink.mjs
var retryDelay = (attemptIndex) => attemptIndex === 0 ? 0 : Math.min(1e3 * 2 ** attemptIndex, 3e4);
function createWSClient(opts) {
  const { url: url2, WebSocket: WebSocketImpl = WebSocket, retryDelayMs: retryDelayFn = retryDelay, onOpen, onClose } = opts;
  if (!WebSocketImpl) {
    throw new Error("No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill");
  }
  let outgoing = [];
  const pendingRequests = /* @__PURE__ */ Object.create(null);
  let connectAttempt = 0;
  let dispatchTimer = null;
  let connectTimer = null;
  let activeConnection = createWS();
  let state = "connecting";
  function dispatch() {
    if (state !== "open" || dispatchTimer) {
      return;
    }
    dispatchTimer = setTimeout(() => {
      dispatchTimer = null;
      if (outgoing.length === 1) {
        activeConnection.send(JSON.stringify(outgoing.pop()));
      } else {
        activeConnection.send(JSON.stringify(outgoing));
      }
      outgoing = [];
    });
  }
  function tryReconnect() {
    if (connectTimer !== null || state === "closed") {
      return;
    }
    const timeout = retryDelayFn(connectAttempt++);
    reconnectInMs(timeout);
  }
  function reconnect() {
    state = "connecting";
    const oldConnection = activeConnection;
    activeConnection = createWS();
    closeIfNoPending(oldConnection);
  }
  function reconnectInMs(ms) {
    if (connectTimer) {
      return;
    }
    state = "connecting";
    connectTimer = setTimeout(reconnect, ms);
  }
  function closeIfNoPending(conn) {
    const hasPendingRequests = Object.values(pendingRequests).some((p3) => p3.ws === conn);
    if (!hasPendingRequests) {
      conn.close();
    }
  }
  function closeActiveSubscriptions() {
    Object.values(pendingRequests).forEach((req) => {
      if (req.type === "subscription") {
        req.callbacks.complete();
      }
    });
  }
  function resumeSubscriptionOnReconnect(req) {
    if (outgoing.some((r2) => r2.id === req.op.id)) {
      return;
    }
    request(req.op, req.callbacks);
  }
  function createWS() {
    const urlString = typeof url2 === "function" ? url2() : url2;
    const conn = new WebSocketImpl(urlString);
    clearTimeout(connectTimer);
    connectTimer = null;
    conn.addEventListener("open", () => {
      if (conn !== activeConnection) {
        return;
      }
      connectAttempt = 0;
      state = "open";
      onOpen?.();
      dispatch();
    });
    conn.addEventListener("error", () => {
      if (conn === activeConnection) {
        tryReconnect();
      }
    });
    const handleIncomingRequest = (req) => {
      if (req.method === "reconnect" && conn === activeConnection) {
        if (state === "open") {
          onClose?.();
        }
        reconnect();
        for (const pendingReq of Object.values(pendingRequests)) {
          if (pendingReq.type === "subscription") {
            resumeSubscriptionOnReconnect(pendingReq);
          }
        }
      }
    };
    const handleIncomingResponse = (data) => {
      const req = data.id !== null && pendingRequests[data.id];
      if (!req) {
        return;
      }
      req.callbacks.next?.(data);
      if (req.ws !== activeConnection && conn === activeConnection) {
        const oldWs = req.ws;
        req.ws = activeConnection;
        closeIfNoPending(oldWs);
      }
      if ("result" in data && data.result.type === "stopped" && conn === activeConnection) {
        req.callbacks.complete();
      }
    };
    conn.addEventListener("message", ({ data }) => {
      const msg = JSON.parse(data);
      if ("method" in msg) {
        handleIncomingRequest(msg);
      } else {
        handleIncomingResponse(msg);
      }
      if (conn !== activeConnection || state === "closed") {
        closeIfNoPending(conn);
      }
    });
    conn.addEventListener("close", ({ code }) => {
      if (state === "open") {
        onClose?.({
          code
        });
      }
      if (activeConnection === conn) {
        tryReconnect();
      }
      for (const [key2, req] of Object.entries(pendingRequests)) {
        if (req.ws !== conn) {
          continue;
        }
        if (state === "closed") {
          delete pendingRequests[key2];
          req.callbacks.complete?.();
          continue;
        }
        if (req.type === "subscription") {
          resumeSubscriptionOnReconnect(req);
        } else {
          delete pendingRequests[key2];
          req.callbacks.error?.(TRPCClientError.from(new TRPCWebSocketClosedError("WebSocket closed prematurely")));
        }
      }
    });
    return conn;
  }
  function request(op, callbacks) {
    const { type: type2, input, path: path4, id } = op;
    const envelope = {
      id,
      method: type2,
      params: {
        input,
        path: path4
      }
    };
    pendingRequests[id] = {
      ws: activeConnection,
      type: type2,
      callbacks,
      op
    };
    outgoing.push(envelope);
    dispatch();
    return () => {
      const callbacks2 = pendingRequests[id]?.callbacks;
      delete pendingRequests[id];
      outgoing = outgoing.filter((msg) => msg.id !== id);
      callbacks2?.complete?.();
      if (activeConnection.readyState === WebSocketImpl.OPEN && op.type === "subscription") {
        outgoing.push({
          id,
          method: "subscription.stop"
        });
        dispatch();
      }
    };
  }
  return {
    close: () => {
      state = "closed";
      onClose?.();
      closeActiveSubscriptions();
      closeIfNoPending(activeConnection);
      clearTimeout(connectTimer);
      connectTimer = null;
    },
    request,
    getConnection() {
      return activeConnection;
    }
  };
}
var TRPCWebSocketClosedError = class _TRPCWebSocketClosedError extends Error {
  constructor(message) {
    super(message);
    this.name = "TRPCWebSocketClosedError";
    Object.setPrototypeOf(this, _TRPCWebSocketClosedError.prototype);
  }
};
function wsLink(opts) {
  return (runtime) => {
    const { client } = opts;
    return ({ op }) => {
      return observable((observer) => {
        const { type: type2, path: path4, id, context: context4 } = op;
        const input = runtime.transformer.serialize(op.input);
        const unsub = client.request({
          type: type2,
          path: path4,
          input,
          id,
          context: context4
        }, {
          error(err2) {
            observer.error(err2);
            unsub();
          },
          complete() {
            observer.complete();
          },
          next(message) {
            const transformed = transformResult(message, runtime);
            if (!transformed.ok) {
              observer.error(TRPCClientError.from(transformed.error));
              return;
            }
            observer.next({
              result: transformed.result
            });
            if (op.type !== "subscription") {
              unsub();
              observer.complete();
            }
          }
        });
        return () => {
          unsub();
        };
      });
    };
  };
}

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/index.mjs
var TRPCUntypedClient = class {
  $request({ type: type2, input, path: path4, context: context4 = {} }) {
    const chain$ = createChain({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: type2,
        path: path4,
        input,
        context: context4
      }
    });
    return chain$.pipe(share());
  }
  requestAsPromise(opts) {
    const req$ = this.$request(opts);
    const { promise: promise4, abort: abort2 } = observableToPromise(req$);
    const abortablePromise = new Promise((resolve2, reject) => {
      opts.signal?.addEventListener("abort", abort2);
      promise4.then((envelope) => {
        resolve2(envelope.result.data);
      }).catch((err2) => {
        reject(TRPCClientError.from(err2));
      });
    });
    return abortablePromise;
  }
  query(path4, input, opts) {
    return this.requestAsPromise({
      type: "query",
      path: path4,
      input,
      context: opts?.context,
      signal: opts?.signal
    });
  }
  mutation(path4, input, opts) {
    return this.requestAsPromise({
      type: "mutation",
      path: path4,
      input,
      context: opts?.context,
      signal: opts?.signal
    });
  }
  subscription(path4, input, opts) {
    const observable$ = this.$request({
      type: "subscription",
      path: path4,
      input,
      context: opts?.context
    });
    return observable$.subscribe({
      next(envelope) {
        if (envelope.result.type === "started") {
          opts.onStarted?.();
        } else if (envelope.result.type === "stopped") {
          opts.onStopped?.();
        } else {
          opts.onData?.(envelope.result.data);
        }
      },
      error(err2) {
        opts.onError?.(err2);
      },
      complete() {
        opts.onComplete?.();
      }
    });
  }
  constructor(opts) {
    this.requestId = 0;
    const combinedTransformer = (() => {
      const transformer = opts.transformer;
      if (!transformer) {
        return {
          input: {
            serialize: (data) => data,
            deserialize: (data) => data
          },
          output: {
            serialize: (data) => data,
            deserialize: (data) => data
          }
        };
      }
      if ("input" in transformer) {
        return opts.transformer;
      }
      return {
        input: transformer,
        output: transformer
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (data) => combinedTransformer.input.serialize(data),
        deserialize: (data) => combinedTransformer.output.deserialize(data)
      },
      combinedTransformer
    };
    this.links = opts.links.map((link) => link(this.runtime));
  }
};
var clientCallTypeMap = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
};
var clientCallTypeToProcedureType = (clientCallType) => {
  return clientCallTypeMap[clientCallType];
};
function createTRPCClientProxy(client) {
  return createFlatProxy((key2) => {
    if (client.hasOwnProperty(key2)) {
      return client[key2];
    }
    if (key2 === "__untypedClient") {
      return client;
    }
    return createRecursiveProxy(({ path: path4, args }) => {
      const pathCopy = [
        key2,
        ...path4
      ];
      const procedureType = clientCallTypeToProcedureType(pathCopy.pop());
      const fullPath = pathCopy.join(".");
      return client[procedureType](fullPath, ...args);
    });
  });
}
function createTRPCProxyClient(opts) {
  const client = new TRPCUntypedClient(opts);
  const proxy = createTRPCClientProxy(client);
  return proxy;
}
function getTextDecoder(customTextDecoder) {
  if (customTextDecoder) {
    return customTextDecoder;
  }
  if (typeof window !== "undefined" && window.TextDecoder) {
    return new window.TextDecoder();
  }
  if (typeof globalThis !== "undefined" && globalThis.TextDecoder) {
    return new globalThis.TextDecoder();
  }
  throw new Error("No TextDecoder implementation found");
}
async function parseJSONStream(opts) {
  const parse2 = opts.parse ?? JSON.parse;
  const onLine = (line) => {
    if (opts.signal?.aborted)
      return;
    if (!line || line === "}") {
      return;
    }
    const indexOfColon = line.indexOf(":");
    const indexAsStr = line.substring(2, indexOfColon - 1);
    const text = line.substring(indexOfColon + 1);
    opts.onSingle(Number(indexAsStr), parse2(text));
  };
  await readLines(opts.readableStream, onLine, opts.textDecoder);
}
async function readLines(readableStream, onLine, textDecoder) {
  let partOfLine = "";
  const onChunk = (chunk) => {
    const chunkText = textDecoder.decode(chunk);
    const chunkLines = chunkText.split("\n");
    if (chunkLines.length === 1) {
      partOfLine += chunkLines[0];
    } else if (chunkLines.length > 1) {
      onLine(partOfLine + chunkLines[0]);
      for (let i3 = 1; i3 < chunkLines.length - 1; i3++) {
        onLine(chunkLines[i3]);
      }
      partOfLine = chunkLines[chunkLines.length - 1];
    }
  };
  if ("getReader" in readableStream) {
    await readStandardChunks(readableStream, onChunk);
  } else {
    await readNodeChunks(readableStream, onChunk);
  }
  onLine(partOfLine);
}
function readNodeChunks(stream, onChunk) {
  return new Promise((resolve2) => {
    stream.on("data", onChunk);
    stream.on("end", resolve2);
  });
}
async function readStandardChunks(stream, onChunk) {
  const reader = stream.getReader();
  let readResult = await reader.read();
  while (!readResult.done) {
    onChunk(readResult.value);
    readResult = await reader.read();
  }
}
var streamingJsonHttpRequester = (opts, onSingle) => {
  const ac = opts.AbortController ? new opts.AbortController() : null;
  const responsePromise = fetchHTTPResponse({
    ...opts,
    contentTypeHeader: "application/json",
    batchModeHeader: "stream",
    getUrl,
    getBody
  }, ac);
  const cancel = () => ac?.abort();
  const promise4 = responsePromise.then(async (res) => {
    if (!res.body)
      throw new Error("Received response without body");
    const meta = {
      response: res
    };
    return parseJSONStream({
      readableStream: res.body,
      onSingle,
      parse: (string) => ({
        json: JSON.parse(string),
        meta
      }),
      signal: ac?.signal,
      textDecoder: opts.textDecoder
    });
  });
  return {
    cancel,
    promise: promise4
  };
};
var streamRequester = (requesterOpts) => {
  const textDecoder = getTextDecoder(requesterOpts.opts.textDecoder);
  return (batchOps, unitResolver) => {
    const path4 = batchOps.map((op) => op.path).join(",");
    const inputs = batchOps.map((op) => op.input);
    const { cancel, promise: promise4 } = streamingJsonHttpRequester({
      ...requesterOpts,
      textDecoder,
      path: path4,
      inputs,
      headers() {
        if (!requesterOpts.opts.headers) {
          return {};
        }
        if (typeof requesterOpts.opts.headers === "function") {
          return requesterOpts.opts.headers({
            opList: batchOps
          });
        }
        return requesterOpts.opts.headers;
      }
    }, (index, res) => {
      unitResolver(index, res);
    });
    return {
      /**
      * return an empty array because the batchLoader expects an array of results
      * but we've already called the `unitResolver` for each of them, there's
      * nothing left to do here.
      */
      promise: promise4.then(() => []),
      cancel
    };
  };
};
var unstable_httpBatchStreamLink = createHTTPBatchLink(streamRequester);
var getBody2 = (opts) => {
  if (!("input" in opts)) {
    return void 0;
  }
  if (!(opts.input instanceof FormData)) {
    throw new Error("Input is not FormData");
  }
  return opts.input;
};
var formDataRequester = (opts) => {
  if (opts.type !== "mutation") {
    throw new Error("We only handle mutations with formdata");
  }
  return httpRequest({
    ...opts,
    getUrl() {
      return `${opts.url}/${opts.path}`;
    },
    getBody: getBody2
  });
};
var experimental_formDataLink = httpLinkFactory({
  requester: formDataRequester
});

// src/frontend/trpc.ts
var backendUrl = "http://coder.us1.serial-experiments.com";
var wsClient = createWSClient({
  // * put ws instead of http on the url
  url: backendUrl.replace("https", "wss").replace("http", "ws") + ":4002/trpc",
  retryDelayMs: (attempt) => {
    if (attempt > 10) {
      return null;
    } else {
      return 1e3;
    }
  }
});
var trpc = createTRPCProxyClient({
  links: [
    splitLink({
      // * only use the web socket link if the operation is a subscription
      condition: (operation) => {
        return operation.type === "subscription";
      },
      true: wsLink({
        client: wsClient
        // * <- use the web socket client
      }),
      // * use the httpBatchLink for everything else (query, mutation)
      false: httpBatchLink({
        url: backendUrl + ":4001",
        async headers() {
          const token = localStorage.getItem("agent-token") ?? localStorage.getItem("user-token");
          return token ? {
            authorization: "Bearer " + token
          } : {};
        }
      })
    })
  ]
});

// ../../node_modules/.pnpm/@pixi+constants@7.3.1/node_modules/@pixi/constants/lib/index.mjs
var ENV = /* @__PURE__ */ ((ENV2) => (ENV2[ENV2.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", ENV2[ENV2.WEBGL = 1] = "WEBGL", ENV2[ENV2.WEBGL2 = 2] = "WEBGL2", ENV2))(ENV || {});
var RENDERER_TYPE = /* @__PURE__ */ ((RENDERER_TYPE2) => (RENDERER_TYPE2[RENDERER_TYPE2.UNKNOWN = 0] = "UNKNOWN", RENDERER_TYPE2[RENDERER_TYPE2.WEBGL = 1] = "WEBGL", RENDERER_TYPE2[RENDERER_TYPE2.CANVAS = 2] = "CANVAS", RENDERER_TYPE2))(RENDERER_TYPE || {});
var BUFFER_BITS = /* @__PURE__ */ ((BUFFER_BITS2) => (BUFFER_BITS2[BUFFER_BITS2.COLOR = 16384] = "COLOR", BUFFER_BITS2[BUFFER_BITS2.DEPTH = 256] = "DEPTH", BUFFER_BITS2[BUFFER_BITS2.STENCIL = 1024] = "STENCIL", BUFFER_BITS2))(BUFFER_BITS || {});
var BLEND_MODES = /* @__PURE__ */ ((BLEND_MODES22) => (BLEND_MODES22[BLEND_MODES22.NORMAL = 0] = "NORMAL", BLEND_MODES22[BLEND_MODES22.ADD = 1] = "ADD", BLEND_MODES22[BLEND_MODES22.MULTIPLY = 2] = "MULTIPLY", BLEND_MODES22[BLEND_MODES22.SCREEN = 3] = "SCREEN", BLEND_MODES22[BLEND_MODES22.OVERLAY = 4] = "OVERLAY", BLEND_MODES22[BLEND_MODES22.DARKEN = 5] = "DARKEN", BLEND_MODES22[BLEND_MODES22.LIGHTEN = 6] = "LIGHTEN", BLEND_MODES22[BLEND_MODES22.COLOR_DODGE = 7] = "COLOR_DODGE", BLEND_MODES22[BLEND_MODES22.COLOR_BURN = 8] = "COLOR_BURN", BLEND_MODES22[BLEND_MODES22.HARD_LIGHT = 9] = "HARD_LIGHT", BLEND_MODES22[BLEND_MODES22.SOFT_LIGHT = 10] = "SOFT_LIGHT", BLEND_MODES22[BLEND_MODES22.DIFFERENCE = 11] = "DIFFERENCE", BLEND_MODES22[BLEND_MODES22.EXCLUSION = 12] = "EXCLUSION", BLEND_MODES22[BLEND_MODES22.HUE = 13] = "HUE", BLEND_MODES22[BLEND_MODES22.SATURATION = 14] = "SATURATION", BLEND_MODES22[BLEND_MODES22.COLOR = 15] = "COLOR", BLEND_MODES22[BLEND_MODES22.LUMINOSITY = 16] = "LUMINOSITY", BLEND_MODES22[BLEND_MODES22.NORMAL_NPM = 17] = "NORMAL_NPM", BLEND_MODES22[BLEND_MODES22.ADD_NPM = 18] = "ADD_NPM", BLEND_MODES22[BLEND_MODES22.SCREEN_NPM = 19] = "SCREEN_NPM", BLEND_MODES22[BLEND_MODES22.NONE = 20] = "NONE", BLEND_MODES22[BLEND_MODES22.SRC_OVER = 0] = "SRC_OVER", BLEND_MODES22[BLEND_MODES22.SRC_IN = 21] = "SRC_IN", BLEND_MODES22[BLEND_MODES22.SRC_OUT = 22] = "SRC_OUT", BLEND_MODES22[BLEND_MODES22.SRC_ATOP = 23] = "SRC_ATOP", BLEND_MODES22[BLEND_MODES22.DST_OVER = 24] = "DST_OVER", BLEND_MODES22[BLEND_MODES22.DST_IN = 25] = "DST_IN", BLEND_MODES22[BLEND_MODES22.DST_OUT = 26] = "DST_OUT", BLEND_MODES22[BLEND_MODES22.DST_ATOP = 27] = "DST_ATOP", BLEND_MODES22[BLEND_MODES22.ERASE = 26] = "ERASE", BLEND_MODES22[BLEND_MODES22.SUBTRACT = 28] = "SUBTRACT", BLEND_MODES22[BLEND_MODES22.XOR = 29] = "XOR", BLEND_MODES22))(BLEND_MODES || {});
var DRAW_MODES = /* @__PURE__ */ ((DRAW_MODES2) => (DRAW_MODES2[DRAW_MODES2.POINTS = 0] = "POINTS", DRAW_MODES2[DRAW_MODES2.LINES = 1] = "LINES", DRAW_MODES2[DRAW_MODES2.LINE_LOOP = 2] = "LINE_LOOP", DRAW_MODES2[DRAW_MODES2.LINE_STRIP = 3] = "LINE_STRIP", DRAW_MODES2[DRAW_MODES2.TRIANGLES = 4] = "TRIANGLES", DRAW_MODES2[DRAW_MODES2.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", DRAW_MODES2[DRAW_MODES2.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", DRAW_MODES2))(DRAW_MODES || {});
var FORMATS = /* @__PURE__ */ ((FORMATS2) => (FORMATS2[FORMATS2.RGBA = 6408] = "RGBA", FORMATS2[FORMATS2.RGB = 6407] = "RGB", FORMATS2[FORMATS2.RG = 33319] = "RG", FORMATS2[FORMATS2.RED = 6403] = "RED", FORMATS2[FORMATS2.RGBA_INTEGER = 36249] = "RGBA_INTEGER", FORMATS2[FORMATS2.RGB_INTEGER = 36248] = "RGB_INTEGER", FORMATS2[FORMATS2.RG_INTEGER = 33320] = "RG_INTEGER", FORMATS2[FORMATS2.RED_INTEGER = 36244] = "RED_INTEGER", FORMATS2[FORMATS2.ALPHA = 6406] = "ALPHA", FORMATS2[FORMATS2.LUMINANCE = 6409] = "LUMINANCE", FORMATS2[FORMATS2.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", FORMATS2[FORMATS2.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", FORMATS2[FORMATS2.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", FORMATS2))(FORMATS || {});
var TARGETS = /* @__PURE__ */ ((TARGETS2) => (TARGETS2[TARGETS2.TEXTURE_2D = 3553] = "TEXTURE_2D", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", TARGETS2[TARGETS2.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", TARGETS2))(TARGETS || {});
var TYPES = /* @__PURE__ */ ((TYPES2) => (TYPES2[TYPES2.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", TYPES2[TYPES2.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", TYPES2[TYPES2.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", TYPES2[TYPES2.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", TYPES2[TYPES2.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", TYPES2[TYPES2.UNSIGNED_INT = 5125] = "UNSIGNED_INT", TYPES2[TYPES2.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", TYPES2[TYPES2.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", TYPES2[TYPES2.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", TYPES2[TYPES2.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", TYPES2[TYPES2.BYTE = 5120] = "BYTE", TYPES2[TYPES2.SHORT = 5122] = "SHORT", TYPES2[TYPES2.INT = 5124] = "INT", TYPES2[TYPES2.FLOAT = 5126] = "FLOAT", TYPES2[TYPES2.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", TYPES2[TYPES2.HALF_FLOAT = 36193] = "HALF_FLOAT", TYPES2))(TYPES || {});
var SAMPLER_TYPES = /* @__PURE__ */ ((SAMPLER_TYPES2) => (SAMPLER_TYPES2[SAMPLER_TYPES2.FLOAT = 0] = "FLOAT", SAMPLER_TYPES2[SAMPLER_TYPES2.INT = 1] = "INT", SAMPLER_TYPES2[SAMPLER_TYPES2.UINT = 2] = "UINT", SAMPLER_TYPES2))(SAMPLER_TYPES || {});
var SCALE_MODES = /* @__PURE__ */ ((SCALE_MODES2) => (SCALE_MODES2[SCALE_MODES2.NEAREST = 0] = "NEAREST", SCALE_MODES2[SCALE_MODES2.LINEAR = 1] = "LINEAR", SCALE_MODES2))(SCALE_MODES || {});
var WRAP_MODES = /* @__PURE__ */ ((WRAP_MODES2) => (WRAP_MODES2[WRAP_MODES2.CLAMP = 33071] = "CLAMP", WRAP_MODES2[WRAP_MODES2.REPEAT = 10497] = "REPEAT", WRAP_MODES2[WRAP_MODES2.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", WRAP_MODES2))(WRAP_MODES || {});
var MIPMAP_MODES = /* @__PURE__ */ ((MIPMAP_MODES2) => (MIPMAP_MODES2[MIPMAP_MODES2.OFF = 0] = "OFF", MIPMAP_MODES2[MIPMAP_MODES2.POW2 = 1] = "POW2", MIPMAP_MODES2[MIPMAP_MODES2.ON = 2] = "ON", MIPMAP_MODES2[MIPMAP_MODES2.ON_MANUAL = 3] = "ON_MANUAL", MIPMAP_MODES2))(MIPMAP_MODES || {});
var ALPHA_MODES = /* @__PURE__ */ ((ALPHA_MODES2) => (ALPHA_MODES2[ALPHA_MODES2.NPM = 0] = "NPM", ALPHA_MODES2[ALPHA_MODES2.UNPACK = 1] = "UNPACK", ALPHA_MODES2[ALPHA_MODES2.PMA = 2] = "PMA", ALPHA_MODES2[ALPHA_MODES2.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", ALPHA_MODES2[ALPHA_MODES2.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", ALPHA_MODES2[ALPHA_MODES2.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA", ALPHA_MODES2))(ALPHA_MODES || {});
var CLEAR_MODES = /* @__PURE__ */ ((CLEAR_MODES2) => (CLEAR_MODES2[CLEAR_MODES2.NO = 0] = "NO", CLEAR_MODES2[CLEAR_MODES2.YES = 1] = "YES", CLEAR_MODES2[CLEAR_MODES2.AUTO = 2] = "AUTO", CLEAR_MODES2[CLEAR_MODES2.BLEND = 0] = "BLEND", CLEAR_MODES2[CLEAR_MODES2.CLEAR = 1] = "CLEAR", CLEAR_MODES2[CLEAR_MODES2.BLIT = 2] = "BLIT", CLEAR_MODES2))(CLEAR_MODES || {});
var GC_MODES = /* @__PURE__ */ ((GC_MODES2) => (GC_MODES2[GC_MODES2.AUTO = 0] = "AUTO", GC_MODES2[GC_MODES2.MANUAL = 1] = "MANUAL", GC_MODES2))(GC_MODES || {});
var PRECISION = /* @__PURE__ */ ((PRECISION2) => (PRECISION2.LOW = "lowp", PRECISION2.MEDIUM = "mediump", PRECISION2.HIGH = "highp", PRECISION2))(PRECISION || {});
var MASK_TYPES = /* @__PURE__ */ ((MASK_TYPES2) => (MASK_TYPES2[MASK_TYPES2.NONE = 0] = "NONE", MASK_TYPES2[MASK_TYPES2.SCISSOR = 1] = "SCISSOR", MASK_TYPES2[MASK_TYPES2.STENCIL = 2] = "STENCIL", MASK_TYPES2[MASK_TYPES2.SPRITE = 3] = "SPRITE", MASK_TYPES2[MASK_TYPES2.COLOR = 4] = "COLOR", MASK_TYPES2))(MASK_TYPES || {});
var MSAA_QUALITY = /* @__PURE__ */ ((MSAA_QUALITY2) => (MSAA_QUALITY2[MSAA_QUALITY2.NONE = 0] = "NONE", MSAA_QUALITY2[MSAA_QUALITY2.LOW = 2] = "LOW", MSAA_QUALITY2[MSAA_QUALITY2.MEDIUM = 4] = "MEDIUM", MSAA_QUALITY2[MSAA_QUALITY2.HIGH = 8] = "HIGH", MSAA_QUALITY2))(MSAA_QUALITY || {});
var BUFFER_TYPE2 = /* @__PURE__ */ ((BUFFER_TYPE22) => (BUFFER_TYPE22[BUFFER_TYPE22.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", BUFFER_TYPE22[BUFFER_TYPE22.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", BUFFER_TYPE22[BUFFER_TYPE22.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", BUFFER_TYPE22))(BUFFER_TYPE2 || {});

// ../../node_modules/.pnpm/@pixi+settings@7.3.1/node_modules/@pixi/settings/lib/adapter.mjs
var BrowserAdapter2 = {
  /**
   * Creates a canvas element of the given size.
   * This canvas is created using the browser's native canvas element.
   * @param width - width of the canvas
   * @param height - height of the canvas
   */
  createCanvas: (width, height) => {
    const canvas3 = document.createElement("canvas");
    return canvas3.width = width, canvas3.height = height, canvas3;
  },
  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
  getWebGLRenderingContext: () => WebGLRenderingContext,
  getNavigator: () => navigator,
  getBaseUrl: () => document.baseURI ?? window.location.href,
  getFontFaceSet: () => document.fonts,
  fetch: (url2, options) => fetch(url2, options),
  parseXML: (xml) => new DOMParser().parseFromString(xml, "text/xml")
};

// ../../node_modules/.pnpm/@pixi+settings@7.3.1/node_modules/@pixi/settings/lib/settings.mjs
var settings2 = {
  /**
   * This adapter is used to call methods that are platform dependent.
   * For example `document.createElement` only runs on the web but fails in node environments.
   * This allows us to support more platforms by abstracting away specific implementations per platform.
   *
   * By default the adapter is set to work in the browser. However you can create your own
   * by implementing the `IAdapter` interface. See `IAdapter` for more information.
   * @name ADAPTER
   * @memberof PIXI.settings
   * @type {PIXI.IAdapter}
   * @default PIXI.BrowserAdapter
   */
  ADAPTER: BrowserAdapter2,
  /**
   * Default resolution / device pixel ratio of the renderer.
   * @static
   * @name RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  RESOLUTION: 1,
  /**
   * Enables bitmap creation before image load. This feature is experimental.
   * @static
   * @name CREATE_IMAGE_BITMAP
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  CREATE_IMAGE_BITMAP: false,
  /**
   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
   * Advantages can include sharper image quality (like text) and faster rendering on canvas.
   * The main disadvantage is movement of objects may appear less smooth.
   * @static
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  ROUND_PIXELS: false
};

// ../../node_modules/.pnpm/@pixi+settings@7.3.1/node_modules/@pixi/settings/lib/utils/isMobile.mjs
init_esm();
var isMobileCall2 = isMobile.default ?? isMobile;
var isMobile3 = isMobileCall2(globalThis.navigator);

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/index.mjs
var lib_exports = {};
__export(lib_exports, {
  BaseTextureCache: () => BaseTextureCache,
  BoundingBox: () => BoundingBox,
  CanvasRenderTarget: () => CanvasRenderTarget,
  DATA_URI: () => DATA_URI,
  EventEmitter: () => import_eventemitter317.default,
  ProgramCache: () => ProgramCache,
  TextureCache: () => TextureCache,
  clearTextureCache: () => clearTextureCache,
  correctBlendMode: () => correctBlendMode,
  createIndicesForQuads: () => createIndicesForQuads,
  decomposeDataUri: () => decomposeDataUri,
  deprecation: () => deprecation2,
  destroyTextureCache: () => destroyTextureCache,
  detectVideoAlphaMode: () => detectVideoAlphaMode2,
  determineCrossOrigin: () => determineCrossOrigin2,
  earcut: () => import_earcut3.default,
  getBufferType: () => getBufferType,
  getCanvasBoundingBox: () => getCanvasBoundingBox,
  getResolutionOfUrl: () => getResolutionOfUrl2,
  hex2rgb: () => hex2rgb,
  hex2string: () => hex2string,
  interleaveTypedArrays: () => interleaveTypedArrays,
  isMobile: () => isMobile3,
  isPow2: () => isPow2,
  isWebGLSupported: () => isWebGLSupported2,
  log2: () => log2,
  nextPow2: () => nextPow22,
  path: () => path2,
  premultiplyBlendMode: () => premultiplyBlendMode,
  premultiplyRgba: () => premultiplyRgba,
  premultiplyTint: () => premultiplyTint,
  premultiplyTintToRgba: () => premultiplyTintToRgba,
  removeItems: () => removeItems2,
  rgb2hex: () => rgb2hex,
  sayHello: () => sayHello2,
  sign: () => sign,
  skipHello: () => skipHello,
  string2hex: () => string2hex,
  trimCanvas: () => trimCanvas,
  uid: () => uid2,
  url: () => url
});

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/settings.mjs
settings2.RETINA_PREFIX = /@([0-9\.]+)x/;
settings2.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/index.mjs
var import_eventemitter317 = __toESM(require_eventemitter32(), 1);
var import_earcut3 = __toESM(require_earcut(), 1);

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/url.mjs
var import_url = __toESM(require_url(), 1);

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/logging/deprecation.mjs
var warnings2 = {};
function deprecation2(version, message, ignoreDepth = 3) {
  if (warnings2[message])
    return;
  let stack = new Error().stack;
  typeof stack > "u" ? console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`) : (stack = stack.split(`
`).splice(ignoreDepth).join(`
`), console.groupCollapsed ? (console.groupCollapsed(
    "%cPixiJS Deprecation Warning: %c%s",
    "color:#614108;background:#fffbe6",
    "font-weight:normal;color:#614108;background:#fffbe6",
    `${message}
Deprecated since v${version}`
  ), console.warn(stack), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`), console.warn(stack))), warnings2[message] = true;
}

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/url.mjs
var url = {
  /**
   * @deprecated since 7.3.0
   */
  get parse() {
    return deprecation2("7.3.0", "utils.url.parse is deprecated, use native URL API instead."), import_url.parse;
  },
  /**
   * @deprecated since 7.3.0
   */
  get format() {
    return deprecation2("7.3.0", "utils.url.format is deprecated, use native URL API instead."), import_url.format;
  },
  /**
   * @deprecated since 7.3.0
   */
  get resolve() {
    return deprecation2("7.3.0", "utils.url.resolve is deprecated, use native URL API instead."), import_url.resolve;
  }
};

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/path.mjs
function assertPath2(path22) {
  if (typeof path22 != "string")
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path22)}`);
}
function removeUrlParams2(url2) {
  return url2.split("?")[0].split("#")[0];
}
function escapeRegExp2(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll2(str, find, replace) {
  return str.replace(new RegExp(escapeRegExp2(find), "g"), replace);
}
function normalizeStringPosix2(path22, allowAboveRoot) {
  let res = "", lastSegmentLength = 0, lastSlash = -1, dots = 0, code = -1;
  for (let i3 = 0; i3 <= path22.length; ++i3) {
    if (i3 < path22.length)
      code = path22.charCodeAt(i3);
    else {
      if (code === 47)
        break;
      code = 47;
    }
    if (code === 47) {
      if (!(lastSlash === i3 - 1 || dots === 1))
        if (lastSlash !== i3 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                lastSlashIndex === -1 ? (res = "", lastSegmentLength = 0) : (res = res.slice(0, lastSlashIndex), lastSegmentLength = res.length - 1 - res.lastIndexOf("/")), lastSlash = i3, dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "", lastSegmentLength = 0, lastSlash = i3, dots = 0;
              continue;
            }
          }
          allowAboveRoot && (res.length > 0 ? res += "/.." : res = "..", lastSegmentLength = 2);
        } else
          res.length > 0 ? res += `/${path22.slice(lastSlash + 1, i3)}` : res = path22.slice(lastSlash + 1, i3), lastSegmentLength = i3 - lastSlash - 1;
      lastSlash = i3, dots = 0;
    } else
      code === 46 && dots !== -1 ? ++dots : dots = -1;
  }
  return res;
}
var path2 = {
  /**
   * Converts a path to posix format.
   * @param path - The path to convert to posix
   */
  toPosix(path22) {
    return replaceAll2(path22, "\\", "/");
  },
  /**
   * Checks if the path is a URL e.g. http://, https://
   * @param path - The path to check
   */
  isUrl(path22) {
    return /^https?:/.test(this.toPosix(path22));
  },
  /**
   * Checks if the path is a data URL
   * @param path - The path to check
   */
  isDataUrl(path22) {
    return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path22);
  },
  /**
   * Checks if the path is a blob URL
   * @param path - The path to check
   */
  isBlobUrl(path22) {
    return path22.startsWith("blob:");
  },
  /**
   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
   * This will return true for windows file paths
   * @param path - The path to check
   */
  hasProtocol(path22) {
    return /^[^/:]+:/.test(this.toPosix(path22));
  },
  /**
   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
   * @param path - The path to get the protocol from
   */
  getProtocol(path22) {
    assertPath2(path22), path22 = this.toPosix(path22);
    const matchFile = /^file:\/\/\//.exec(path22);
    if (matchFile)
      return matchFile[0];
    const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path22);
    return matchProtocol ? matchProtocol[0] : "";
  },
  /**
   * Converts URL to an absolute path.
   * When loading from a Web Worker, we must use absolute paths.
   * If the URL is already absolute we return it as is
   * If it's not, we convert it
   * @param url - The URL to test
   * @param customBaseUrl - The base URL to use
   * @param customRootUrl - The root URL to use
   */
  toAbsolute(url2, customBaseUrl, customRootUrl) {
    if (assertPath2(url2), this.isDataUrl(url2) || this.isBlobUrl(url2))
      return url2;
    const baseUrl = removeUrlParams2(this.toPosix(customBaseUrl ?? settings2.ADAPTER.getBaseUrl())), rootUrl = removeUrlParams2(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
    return url2 = this.toPosix(url2), url2.startsWith("/") ? path2.join(rootUrl, url2.slice(1)) : this.isAbsolute(url2) ? url2 : this.join(baseUrl, url2);
  },
  /**
   * Normalizes the given path, resolving '..' and '.' segments
   * @param path - The path to normalize
   */
  normalize(path22) {
    if (assertPath2(path22), path22.length === 0)
      return ".";
    if (this.isDataUrl(path22) || this.isBlobUrl(path22))
      return path22;
    path22 = this.toPosix(path22);
    let protocol = "";
    const isAbsolute = path22.startsWith("/");
    this.hasProtocol(path22) && (protocol = this.rootname(path22), path22 = path22.slice(protocol.length));
    const trailingSeparator = path22.endsWith("/");
    return path22 = normalizeStringPosix2(path22, false), path22.length > 0 && trailingSeparator && (path22 += "/"), isAbsolute ? `/${path22}` : protocol + path22;
  },
  /**
   * Determines if path is an absolute path.
   * Absolute paths can be urls, data urls, or paths on disk
   * @param path - The path to test
   */
  isAbsolute(path22) {
    return assertPath2(path22), path22 = this.toPosix(path22), this.hasProtocol(path22) ? true : path22.startsWith("/");
  },
  /**
   * Joins all given path segments together using the platform-specific separator as a delimiter,
   * then normalizes the resulting path
   * @param segments - The segments of the path to join
   */
  join(...segments) {
    if (segments.length === 0)
      return ".";
    let joined;
    for (let i3 = 0; i3 < segments.length; ++i3) {
      const arg2 = segments[i3];
      if (assertPath2(arg2), arg2.length > 0)
        if (joined === void 0)
          joined = arg2;
        else {
          const prevArg = segments[i3 - 1] ?? "";
          this.extname(prevArg) ? joined += `/../${arg2}` : joined += `/${arg2}`;
        }
    }
    return joined === void 0 ? "." : this.normalize(joined);
  },
  /**
   * Returns the directory name of a path
   * @param path - The path to parse
   */
  dirname(path22) {
    if (assertPath2(path22), path22.length === 0)
      return ".";
    path22 = this.toPosix(path22);
    let code = path22.charCodeAt(0);
    const hasRoot = code === 47;
    let end = -1, matchedSlash = true;
    const proto = this.getProtocol(path22), origpath = path22;
    path22 = path22.slice(proto.length);
    for (let i3 = path22.length - 1; i3 >= 1; --i3)
      if (code = path22.charCodeAt(i3), code === 47) {
        if (!matchedSlash) {
          end = i3;
          break;
        }
      } else
        matchedSlash = false;
    return end === -1 ? hasRoot ? "/" : this.isUrl(origpath) ? proto + path22 : proto : hasRoot && end === 1 ? "//" : proto + path22.slice(0, end);
  },
  /**
   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
   * @param path - The path to parse
   */
  rootname(path22) {
    assertPath2(path22), path22 = this.toPosix(path22);
    let root = "";
    if (path22.startsWith("/") ? root = "/" : root = this.getProtocol(path22), this.isUrl(path22)) {
      const index = path22.indexOf("/", root.length);
      index !== -1 ? root = path22.slice(0, index) : root = path22, root.endsWith("/") || (root += "/");
    }
    return root;
  },
  /**
   * Returns the last portion of a path
   * @param path - The path to test
   * @param ext - Optional extension to remove
   */
  basename(path22, ext) {
    assertPath2(path22), ext && assertPath2(ext), path22 = removeUrlParams2(this.toPosix(path22));
    let start = 0, end = -1, matchedSlash = true, i3;
    if (ext !== void 0 && ext.length > 0 && ext.length <= path22.length) {
      if (ext.length === path22.length && ext === path22)
        return "";
      let extIdx = ext.length - 1, firstNonSlashEnd = -1;
      for (i3 = path22.length - 1; i3 >= 0; --i3) {
        const code = path22.charCodeAt(i3);
        if (code === 47) {
          if (!matchedSlash) {
            start = i3 + 1;
            break;
          }
        } else
          firstNonSlashEnd === -1 && (matchedSlash = false, firstNonSlashEnd = i3 + 1), extIdx >= 0 && (code === ext.charCodeAt(extIdx) ? --extIdx === -1 && (end = i3) : (extIdx = -1, end = firstNonSlashEnd));
      }
      return start === end ? end = firstNonSlashEnd : end === -1 && (end = path22.length), path22.slice(start, end);
    }
    for (i3 = path22.length - 1; i3 >= 0; --i3)
      if (path22.charCodeAt(i3) === 47) {
        if (!matchedSlash) {
          start = i3 + 1;
          break;
        }
      } else
        end === -1 && (matchedSlash = false, end = i3 + 1);
    return end === -1 ? "" : path22.slice(start, end);
  },
  /**
   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
   * the first character of the basename of path, an empty string is returned.
   * @param path - The path to parse
   */
  extname(path22) {
    assertPath2(path22), path22 = removeUrlParams2(this.toPosix(path22));
    let startDot = -1, startPart = 0, end = -1, matchedSlash = true, preDotState = 0;
    for (let i3 = path22.length - 1; i3 >= 0; --i3) {
      const code = path22.charCodeAt(i3);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i3 + 1;
          break;
        }
        continue;
      }
      end === -1 && (matchedSlash = false, end = i3 + 1), code === 46 ? startDot === -1 ? startDot = i3 : preDotState !== 1 && (preDotState = 1) : startDot !== -1 && (preDotState = -1);
    }
    return startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1 ? "" : path22.slice(startDot, end);
  },
  /**
   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
   * @param path - The path to parse
   */
  parse(path22) {
    assertPath2(path22);
    const ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path22.length === 0)
      return ret;
    path22 = removeUrlParams2(this.toPosix(path22));
    let code = path22.charCodeAt(0);
    const isAbsolute = this.isAbsolute(path22);
    let start;
    const protocol = "";
    ret.root = this.rootname(path22), isAbsolute || this.hasProtocol(path22) ? start = 1 : start = 0;
    let startDot = -1, startPart = 0, end = -1, matchedSlash = true, i3 = path22.length - 1, preDotState = 0;
    for (; i3 >= start; --i3) {
      if (code = path22.charCodeAt(i3), code === 47) {
        if (!matchedSlash) {
          startPart = i3 + 1;
          break;
        }
        continue;
      }
      end === -1 && (matchedSlash = false, end = i3 + 1), code === 46 ? startDot === -1 ? startDot = i3 : preDotState !== 1 && (preDotState = 1) : startDot !== -1 && (preDotState = -1);
    }
    return startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1 ? end !== -1 && (startPart === 0 && isAbsolute ? ret.base = ret.name = path22.slice(1, end) : ret.base = ret.name = path22.slice(startPart, end)) : (startPart === 0 && isAbsolute ? (ret.name = path22.slice(1, startDot), ret.base = path22.slice(1, end)) : (ret.name = path22.slice(startPart, startDot), ret.base = path22.slice(startPart, end)), ret.ext = path22.slice(startDot, end)), ret.dir = this.dirname(path22), protocol && (ret.dir = protocol + ret.dir), ret;
  },
  sep: "/",
  delimiter: ":"
};

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/browser/detectVideoAlphaMode.mjs
var promise2;
async function detectVideoAlphaMode2() {
  return promise2 ?? (promise2 = (async () => {
    const gl = document.createElement("canvas").getContext("webgl");
    if (!gl)
      return ALPHA_MODES.UNPACK;
    const video = await new Promise((resolve2) => {
      const video2 = document.createElement("video");
      video2.onloadeddata = () => resolve2(video2), video2.onerror = () => resolve2(null), video2.autoplay = false, video2.crossOrigin = "anonymous", video2.preload = "auto", video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", video2.load();
    });
    if (!video)
      return ALPHA_MODES.UNPACK;
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    const framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer), gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      texture,
      0
    ), gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false), gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
    const pixel = new Uint8Array(4);
    return gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel), gl.deleteFramebuffer(framebuffer), gl.deleteTexture(texture), gl.getExtension("WEBGL_lose_context")?.loseContext(), pixel[0] <= pixel[3] ? ALPHA_MODES.PMA : ALPHA_MODES.UNPACK;
  })()), promise2;
}

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/browser/hello.mjs
function skipHello() {
  deprecation2("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello");
}
function sayHello2() {
  deprecation2("7.0.0", `sayHello is deprecated, please use Renderer's "hello" option`);
}

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/browser/isWebGLSupported.mjs
var supported2;
function isWebGLSupported2() {
  return typeof supported2 > "u" && (supported2 = function() {
    const contextOptions = {
      stencil: true,
      failIfMajorPerformanceCaveat: settings2.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
    };
    try {
      if (!settings2.ADAPTER.getWebGLRenderingContext())
        return false;
      const canvas3 = settings2.ADAPTER.createCanvas();
      let gl = canvas3.getContext("webgl", contextOptions) || canvas3.getContext("experimental-webgl", contextOptions);
      const success = !!gl?.getContextAttributes()?.stencil;
      if (gl) {
        const loseContext = gl.getExtension("WEBGL_lose_context");
        loseContext && loseContext.loseContext();
      }
      return gl = null, success;
    } catch {
      return false;
    }
  }()), supported2;
}

// ../../node_modules/.pnpm/@pixi+color@7.3.1/node_modules/@pixi/color/lib/Color.mjs
init_colord();
init_names();
k([names_default]);
var _Color2 = class _Color22 {
  /**
   * @param {PIXI.ColorSource} value - Optional value to use, if not provided, white is used.
   */
  constructor(value = 16777215) {
    this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = value;
  }
  /** Get red component (0 - 1) */
  get red() {
    return this._components[0];
  }
  /** Get green component (0 - 1) */
  get green() {
    return this._components[1];
  }
  /** Get blue component (0 - 1) */
  get blue() {
    return this._components[2];
  }
  /** Get alpha component (0 - 1) */
  get alpha() {
    return this._components[3];
  }
  /**
   * Set the value, suitable for chaining
   * @param value
   * @see PIXI.Color.value
   */
  setValue(value) {
    return this.value = value, this;
  }
  /**
   * The current color source.
   *
   * When setting:
   * - Setting to an instance of `Color` will copy its color source and components.
   * - Otherwise, `Color` will try to normalize the color source and set the components.
   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.
   *
   * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter
   * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.
   *
   * When getting:
   * - A return value of `null` means the previous value was overridden (e.g., {@link PIXI.Color.multiply multiply},
   *   {@link PIXI.Color.premultiply premultiply} or {@link PIXI.Color.round round}).
   * - Otherwise, the color source used when setting is returned.
   * @type {PIXI.ColorSource}
   */
  set value(value) {
    if (value instanceof _Color22)
      this._value = this.cloneSource(value._value), this._int = value._int, this._components.set(value._components);
    else {
      if (value === null)
        throw new Error("Cannot set PIXI.Color#value to null");
      (this._value === null || !this.isSourceEqual(this._value, value)) && (this.normalize(value), this._value = this.cloneSource(value));
    }
  }
  get value() {
    return this._value;
  }
  /**
   * Copy a color source internally.
   * @param value - Color source
   */
  cloneSource(value) {
    return typeof value == "string" || typeof value == "number" || value instanceof Number || value === null ? value : Array.isArray(value) || ArrayBuffer.isView(value) ? value.slice(0) : typeof value == "object" && value !== null ? { ...value } : value;
  }
  /**
   * Equality check for color sources.
   * @param value1 - First color source
   * @param value2 - Second color source
   * @returns `true` if the color sources are equal, `false` otherwise.
   */
  isSourceEqual(value1, value2) {
    const type1 = typeof value1;
    if (type1 !== typeof value2)
      return false;
    if (type1 === "number" || type1 === "string" || value1 instanceof Number)
      return value1 === value2;
    if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2))
      return value1.length !== value2.length ? false : value1.every((v3, i3) => v3 === value2[i3]);
    if (value1 !== null && value2 !== null) {
      const keys1 = Object.keys(value1), keys2 = Object.keys(value2);
      return keys1.length !== keys2.length ? false : keys1.every((key2) => value1[key2] === value2[key2]);
    }
    return value1 === value2;
  }
  /**
   * Convert to a RGBA color object.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }
   */
  toRgba() {
    const [r2, g2, b2, a2] = this._components;
    return { r: r2, g: g2, b: b2, a: a2 };
  }
  /**
   * Convert to a RGB color object.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }
   */
  toRgb() {
    const [r2, g2, b2] = this._components;
    return { r: r2, g: g2, b: b2 };
  }
  /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */
  toRgbaString() {
    const [r2, g2, b2] = this.toUint8RgbArray();
    return `rgba(${r2},${g2},${b2},${this.alpha})`;
  }
  toUint8RgbArray(out3) {
    const [r2, g2, b2] = this._components;
    return out3 = out3 ?? [], out3[0] = Math.round(r2 * 255), out3[1] = Math.round(g2 * 255), out3[2] = Math.round(b2 * 255), out3;
  }
  toRgbArray(out3) {
    out3 = out3 ?? [];
    const [r2, g2, b2] = this._components;
    return out3[0] = r2, out3[1] = g2, out3[2] = b2, out3;
  }
  /**
   * Convert to a hexadecimal number.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toNumber(); // returns 16777215
   */
  toNumber() {
    return this._int;
  }
  /**
   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
   * @example
   * import { Color } from 'pixi.js';
   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
   * @returns {number} - The color as a number in little endian format.
   */
  toLittleEndianNumber() {
    const value = this._int;
    return (value >> 16) + (value & 65280) + ((value & 255) << 16);
  }
  /**
   * Multiply with another color. This action is destructive, and will
   * override the previous `value` property to be `null`.
   * @param {PIXI.ColorSource} value - The color to multiply by.
   */
  multiply(value) {
    const [r2, g2, b2, a2] = _Color22.temp.setValue(value)._components;
    return this._components[0] *= r2, this._components[1] *= g2, this._components[2] *= b2, this._components[3] *= a2, this.refreshInt(), this._value = null, this;
  }
  /**
   * Converts color to a premultiplied alpha format. This action is destructive, and will
   * override the previous `value` property to be `null`.
   * @param alpha - The alpha to multiply by.
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
   * @returns {PIXI.Color} - Itself.
   */
  premultiply(alpha, applyToRGB = true) {
    return applyToRGB && (this._components[0] *= alpha, this._components[1] *= alpha, this._components[2] *= alpha), this._components[3] = alpha, this.refreshInt(), this._value = null, this;
  }
  /**
   * Premultiplies alpha with current color.
   * @param {number} alpha - The alpha to multiply by.
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
   * @returns {number} tint multiplied by alpha
   */
  toPremultiplied(alpha, applyToRGB = true) {
    if (alpha === 1)
      return (255 << 24) + this._int;
    if (alpha === 0)
      return applyToRGB ? 0 : this._int;
    let r2 = this._int >> 16 & 255, g2 = this._int >> 8 & 255, b2 = this._int & 255;
    return applyToRGB && (r2 = r2 * alpha + 0.5 | 0, g2 = g2 * alpha + 0.5 | 0, b2 = b2 * alpha + 0.5 | 0), (alpha * 255 << 24) + (r2 << 16) + (g2 << 8) + b2;
  }
  /**
   * Convert to a hexidecimal string.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toHex(); // returns "#ffffff"
   */
  toHex() {
    const hexString = this._int.toString(16);
    return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
  }
  /**
   * Convert to a hexidecimal string with alpha.
   * @example
   * import { Color } from 'pixi.js';
   * new Color('white').toHexa(); // returns "#ffffffff"
   */
  toHexa() {
    const alphaString = Math.round(this._components[3] * 255).toString(16);
    return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
  }
  /**
   * Set alpha, suitable for chaining.
   * @param alpha
   */
  setAlpha(alpha) {
    return this._components[3] = this._clamp(alpha), this;
  }
  /**
   * Rounds the specified color according to the step. This action is destructive, and will
   * override the previous `value` property to be `null`. The alpha component is not rounded.
   * @param steps - Number of steps which will be used as a cap when rounding colors
   * @deprecated since 7.3.0
   */
  round(steps) {
    const [r2, g2, b2] = this._components;
    return this._components[0] = Math.round(r2 * steps) / steps, this._components[1] = Math.round(g2 * steps) / steps, this._components[2] = Math.round(b2 * steps) / steps, this.refreshInt(), this._value = null, this;
  }
  toArray(out3) {
    out3 = out3 ?? [];
    const [r2, g2, b2, a2] = this._components;
    return out3[0] = r2, out3[1] = g2, out3[2] = b2, out3[3] = a2, out3;
  }
  /**
   * Normalize the input value into rgba
   * @param value - Input value
   */
  normalize(value) {
    let r2, g2, b2, a2;
    if ((typeof value == "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
      const int = value;
      r2 = (int >> 16 & 255) / 255, g2 = (int >> 8 & 255) / 255, b2 = (int & 255) / 255, a2 = 1;
    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4)
      value = this._clamp(value), [r2, g2, b2, a2 = 1] = value;
    else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4)
      value = this._clamp(value, 0, 255), [r2, g2, b2, a2 = 255] = value, r2 /= 255, g2 /= 255, b2 /= 255, a2 /= 255;
    else if (typeof value == "string" || typeof value == "object") {
      if (typeof value == "string") {
        const match = _Color22.HEX_PATTERN.exec(value);
        match && (value = `#${match[2]}`);
      }
      const color = w(value);
      color.isValid() && ({ r: r2, g: g2, b: b2, a: a2 } = color.rgba, r2 /= 255, g2 /= 255, b2 /= 255);
    }
    if (r2 !== void 0)
      this._components[0] = r2, this._components[1] = g2, this._components[2] = b2, this._components[3] = a2, this.refreshInt();
    else
      throw new Error(`Unable to convert color ${value}`);
  }
  /** Refresh the internal color rgb number */
  refreshInt() {
    this._clamp(this._components);
    const [r2, g2, b2] = this._components;
    this._int = (r2 * 255 << 16) + (g2 * 255 << 8) + (b2 * 255 | 0);
  }
  /**
   * Clamps values to a range. Will override original values
   * @param value - Value(s) to clamp
   * @param min - Minimum value
   * @param max - Maximum value
   */
  _clamp(value, min = 0, max = 1) {
    return typeof value == "number" ? Math.min(Math.max(value, min), max) : (value.forEach((v3, i3) => {
      value[i3] = Math.min(Math.max(v3, min), max);
    }), value);
  }
};
_Color2.shared = new _Color2(), /**
* Temporary Color object for static uses internally.
* As to not conflict with Color.shared.
* @ignore
*/
_Color2.temp = new _Color2(), /** Pattern for hex strings */
_Color2.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
var Color2 = _Color2;

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/color/hex.mjs
function hex2rgb(hex, out3 = []) {
  return deprecation2("7.2.0", "utils.hex2rgb is deprecated, use Color#toRgbArray instead"), Color2.shared.setValue(hex).toRgbArray(out3);
}
function hex2string(hex) {
  return deprecation2("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead"), Color2.shared.setValue(hex).toHex();
}
function string2hex(string) {
  return deprecation2("7.2.0", "utils.string2hex is deprecated, use Color#toNumber instead"), Color2.shared.setValue(string).toNumber();
}
function rgb2hex(rgb) {
  return deprecation2("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead"), Color2.shared.setValue(rgb).toNumber();
}

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/color/premultiply.mjs
function mapPremultipliedBlendModes() {
  const pm = [], npm = [];
  for (let i3 = 0; i3 < 32; i3++)
    pm[i3] = i3, npm[i3] = i3;
  pm[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL, pm[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD, pm[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN, npm[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM, npm[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM, npm[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;
  const array = [];
  return array.push(npm), array.push(pm), array;
}
var premultiplyBlendMode = mapPremultipliedBlendModes();
function correctBlendMode(blendMode, premultiplied) {
  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
}
function premultiplyRgba(rgb, alpha, out3, premultiply = true) {
  return deprecation2("7.2.0", "utils.premultiplyRgba has moved to Color.premultiply"), Color2.shared.setValue(rgb).premultiply(alpha, premultiply).toArray(out3 ?? new Float32Array(4));
}
function premultiplyTint(tint, alpha) {
  return deprecation2("7.2.0", "utils.premultiplyTint has moved to Color.toPremultiplied"), Color2.shared.setValue(tint).toPremultiplied(alpha);
}
function premultiplyTintToRgba(tint, alpha, out3, premultiply = true) {
  return deprecation2("7.2.0", "utils.premultiplyTintToRgba has moved to Color.premultiply"), Color2.shared.setValue(tint).premultiply(alpha, premultiply).toArray(out3 ?? new Float32Array(4));
}

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/const.mjs
var DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/data/createIndicesForQuads.mjs
function createIndicesForQuads(size3, outBuffer = null) {
  const totalIndices = size3 * 6;
  if (outBuffer = outBuffer || new Uint16Array(totalIndices), outBuffer.length !== totalIndices)
    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
  for (let i3 = 0, j3 = 0; i3 < totalIndices; i3 += 6, j3 += 4)
    outBuffer[i3 + 0] = j3 + 0, outBuffer[i3 + 1] = j3 + 1, outBuffer[i3 + 2] = j3 + 2, outBuffer[i3 + 3] = j3 + 0, outBuffer[i3 + 4] = j3 + 2, outBuffer[i3 + 5] = j3 + 3;
  return outBuffer;
}

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/data/getBufferType.mjs
function getBufferType(array) {
  if (array.BYTES_PER_ELEMENT === 4)
    return array instanceof Float32Array ? "Float32Array" : array instanceof Uint32Array ? "Uint32Array" : "Int32Array";
  if (array.BYTES_PER_ELEMENT === 2) {
    if (array instanceof Uint16Array)
      return "Uint16Array";
  } else if (array.BYTES_PER_ELEMENT === 1 && array instanceof Uint8Array)
    return "Uint8Array";
  return null;
}

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/data/interleaveTypedArrays.mjs
var map2 = { Float32Array, Uint32Array, Int32Array, Uint8Array };
function interleaveTypedArrays(arrays, sizes) {
  let outSize = 0, stride = 0;
  const views = {};
  for (let i3 = 0; i3 < arrays.length; i3++)
    stride += sizes[i3], outSize += arrays[i3].length;
  const buffer2 = new ArrayBuffer(outSize * 4);
  let out3 = null, littleOffset = 0;
  for (let i3 = 0; i3 < arrays.length; i3++) {
    const size3 = sizes[i3], array = arrays[i3], type2 = getBufferType(array);
    views[type2] || (views[type2] = new map2[type2](buffer2)), out3 = views[type2];
    for (let j3 = 0; j3 < array.length; j3++) {
      const indexStart = (j3 / size3 | 0) * stride + littleOffset, index = j3 % size3;
      out3[indexStart + index] = array[j3];
    }
    littleOffset += size3;
  }
  return new Float32Array(buffer2);
}

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/data/pow2.mjs
function nextPow22(v3) {
  return v3 += v3 === 0 ? 1 : 0, --v3, v3 |= v3 >>> 1, v3 |= v3 >>> 2, v3 |= v3 >>> 4, v3 |= v3 >>> 8, v3 |= v3 >>> 16, v3 + 1;
}
function isPow2(v3) {
  return !(v3 & v3 - 1) && !!v3;
}
function log2(v3) {
  let r2 = (v3 > 65535 ? 1 : 0) << 4;
  v3 >>>= r2;
  let shift = (v3 > 255 ? 1 : 0) << 3;
  return v3 >>>= shift, r2 |= shift, shift = (v3 > 15 ? 1 : 0) << 2, v3 >>>= shift, r2 |= shift, shift = (v3 > 3 ? 1 : 0) << 1, v3 >>>= shift, r2 |= shift, r2 | v3 >> 1;
}

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/data/removeItems.mjs
function removeItems2(arr, startIdx, removeCount) {
  const length = arr.length;
  let i3;
  if (startIdx >= length || removeCount === 0)
    return;
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  const len = length - removeCount;
  for (i3 = startIdx; i3 < len; ++i3)
    arr[i3] = arr[i3 + removeCount];
  arr.length = len;
}

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/data/sign.mjs
function sign(n2) {
  return n2 === 0 ? 0 : n2 < 0 ? -1 : 1;
}

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/data/uid.mjs
var nextUid = 0;
function uid2() {
  return ++nextUid;
}

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/media/BoundingBox.mjs
var _BoundingBox = class {
  /**
   * @param left - The left coordinate value of the bounding box.
   * @param top - The top coordinate value of the bounding box.
   * @param right - The right coordinate value of the bounding box.
   * @param bottom - The bottom coordinate value of the bounding box.
   */
  constructor(left, top, right, bottom) {
    this.left = left, this.top = top, this.right = right, this.bottom = bottom;
  }
  /** The width of the bounding box. */
  get width() {
    return this.right - this.left;
  }
  /** The height of the bounding box. */
  get height() {
    return this.bottom - this.top;
  }
  /** Determines whether the BoundingBox is empty. */
  isEmpty() {
    return this.left === this.right || this.top === this.bottom;
  }
};
_BoundingBox.EMPTY = new _BoundingBox(0, 0, 0, 0);
var BoundingBox = _BoundingBox;

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/media/caches.mjs
var ProgramCache = {};
var TextureCache = /* @__PURE__ */ Object.create(null);
var BaseTextureCache = /* @__PURE__ */ Object.create(null);
function destroyTextureCache() {
  let key2;
  for (key2 in TextureCache)
    TextureCache[key2].destroy();
  for (key2 in BaseTextureCache)
    BaseTextureCache[key2].destroy();
}
function clearTextureCache() {
  let key2;
  for (key2 in TextureCache)
    delete TextureCache[key2];
  for (key2 in BaseTextureCache)
    delete BaseTextureCache[key2];
}

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/media/CanvasRenderTarget.mjs
var CanvasRenderTarget = class {
  /**
   * @param width - the width for the newly created canvas
   * @param height - the height for the newly created canvas
   * @param {number} [resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio of the canvas
   */
  constructor(width, height, resolution) {
    this._canvas = settings2.ADAPTER.createCanvas(), this._context = this._canvas.getContext("2d"), this.resolution = resolution || settings2.RESOLUTION, this.resize(width, height);
  }
  /**
   * Clears the canvas that was created by the CanvasRenderTarget class.
   * @private
   */
  clear() {
    this._checkDestroyed(), this._context.setTransform(1, 0, 0, 1, 0, 0), this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
  }
  /**
   * Resizes the canvas to the specified width and height.
   * @param desiredWidth - the desired width of the canvas
   * @param desiredHeight - the desired height of the canvas
   */
  resize(desiredWidth, desiredHeight) {
    this._checkDestroyed(), this._canvas.width = Math.round(desiredWidth * this.resolution), this._canvas.height = Math.round(desiredHeight * this.resolution);
  }
  /** Destroys this canvas. */
  destroy() {
    this._context = null, this._canvas = null;
  }
  /**
   * The width of the canvas buffer in pixels.
   * @member {number}
   */
  get width() {
    return this._checkDestroyed(), this._canvas.width;
  }
  set width(val) {
    this._checkDestroyed(), this._canvas.width = Math.round(val);
  }
  /**
   * The height of the canvas buffer in pixels.
   * @member {number}
   */
  get height() {
    return this._checkDestroyed(), this._canvas.height;
  }
  set height(val) {
    this._checkDestroyed(), this._canvas.height = Math.round(val);
  }
  /** The Canvas object that belongs to this CanvasRenderTarget. */
  get canvas() {
    return this._checkDestroyed(), this._canvas;
  }
  /** A CanvasRenderingContext2D object representing a two-dimensional rendering context. */
  get context() {
    return this._checkDestroyed(), this._context;
  }
  _checkDestroyed() {
    if (this._canvas === null)
      throw new TypeError("The CanvasRenderTarget has already been destroyed");
  }
};

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.mjs
function checkRow(data, width, y2) {
  for (let x3 = 0, index = 4 * y2 * width; x3 < width; ++x3, index += 4)
    if (data[index + 3] !== 0)
      return false;
  return true;
}
function checkColumn(data, width, x3, top, bottom) {
  const stride = 4 * width;
  for (let y2 = top, index = top * stride + 4 * x3; y2 <= bottom; ++y2, index += stride)
    if (data[index + 3] !== 0)
      return false;
  return true;
}
function getCanvasBoundingBox(canvas3) {
  const { width, height } = canvas3, context4 = canvas3.getContext("2d", {
    willReadFrequently: true
  });
  if (context4 === null)
    throw new TypeError("Failed to get canvas 2D context");
  const data = context4.getImageData(0, 0, width, height).data;
  let left = 0, top = 0, right = width - 1, bottom = height - 1;
  for (; top < height && checkRow(data, width, top); )
    ++top;
  if (top === height)
    return BoundingBox.EMPTY;
  for (; checkRow(data, width, bottom); )
    --bottom;
  for (; checkColumn(data, width, left, top, bottom); )
    ++left;
  for (; checkColumn(data, width, right, top, bottom); )
    --right;
  return ++right, ++bottom, new BoundingBox(left, top, right, bottom);
}

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/media/trimCanvas.mjs
function trimCanvas(canvas3) {
  const boundingBox = getCanvasBoundingBox(canvas3), { width, height } = boundingBox;
  let data = null;
  if (!boundingBox.isEmpty()) {
    const context4 = canvas3.getContext("2d");
    if (context4 === null)
      throw new TypeError("Failed to get canvas 2D context");
    data = context4.getImageData(
      boundingBox.left,
      boundingBox.top,
      width,
      height
    );
  }
  return { width, height, data };
}

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/network/decomposeDataUri.mjs
function decomposeDataUri(dataUri) {
  const dataUriMatch = DATA_URI.exec(dataUri);
  if (dataUriMatch)
    return {
      mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : void 0,
      subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : void 0,
      charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : void 0,
      encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : void 0,
      data: dataUriMatch[5]
    };
}

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/network/determineCrossOrigin.mjs
function determineCrossOrigin2(url2, loc = globalThis.location) {
  if (url2.startsWith("data:"))
    return "";
  loc = loc || globalThis.location;
  const parsedUrl = new URL(url2, document.baseURI);
  return parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol ? "anonymous" : "";
}

// ../../node_modules/.pnpm/@pixi+utils@7.3.1/node_modules/@pixi/utils/lib/network/getResolutionOfUrl.mjs
function getResolutionOfUrl2(url2, defaultValue3 = 1) {
  const resolution = settings2.RETINA_PREFIX?.exec(url2);
  return resolution ? parseFloat(resolution[1]) : defaultValue3;
}

// ../../node_modules/.pnpm/@pixi+extensions@7.3.1/node_modules/@pixi/extensions/lib/index.mjs
var ExtensionType2 = /* @__PURE__ */ ((ExtensionType22) => (ExtensionType22.Renderer = "renderer", ExtensionType22.Application = "application", ExtensionType22.RendererSystem = "renderer-webgl-system", ExtensionType22.RendererPlugin = "renderer-webgl-plugin", ExtensionType22.CanvasRendererSystem = "renderer-canvas-system", ExtensionType22.CanvasRendererPlugin = "renderer-canvas-plugin", ExtensionType22.Asset = "asset", ExtensionType22.LoadParser = "load-parser", ExtensionType22.ResolveParser = "resolve-parser", ExtensionType22.CacheParser = "cache-parser", ExtensionType22.DetectionParser = "detection-parser", ExtensionType22))(ExtensionType2 || {});
var normalizeExtension2 = (ext) => {
  if (typeof ext == "function" || typeof ext == "object" && ext.extension) {
    if (!ext.extension)
      throw new Error("Extension class must have an extension object");
    ext = { ...typeof ext.extension != "object" ? { type: ext.extension } : ext.extension, ref: ext };
  }
  if (typeof ext == "object")
    ext = { ...ext };
  else
    throw new Error("Invalid extension type");
  return typeof ext.type == "string" && (ext.type = [ext.type]), ext;
};
var normalizePriority = (ext, defaultPriority) => normalizeExtension2(ext).priority ?? defaultPriority;
var extensions2 = {
  /** @ignore */
  _addHandlers: {},
  /** @ignore */
  _removeHandlers: {},
  /** @ignore */
  _queue: {},
  /**
   * Remove extensions from PixiJS.
   * @param extensions - Extensions to be removed.
   * @returns {PIXI.extensions} For chaining.
   */
  remove(...extensions22) {
    return extensions22.map(normalizeExtension2).forEach((ext) => {
      ext.type.forEach((type2) => this._removeHandlers[type2]?.(ext));
    }), this;
  },
  /**
   * Register new extensions with PixiJS.
   * @param extensions - The spread of extensions to add to PixiJS.
   * @returns {PIXI.extensions} For chaining.
   */
  add(...extensions22) {
    return extensions22.map(normalizeExtension2).forEach((ext) => {
      ext.type.forEach((type2) => {
        const handlers = this._addHandlers, queue = this._queue;
        handlers[type2] ? handlers[type2](ext) : (queue[type2] = queue[type2] || [], queue[type2].push(ext));
      });
    }), this;
  },
  /**
   * Internal method to handle extensions by name.
   * @param type - The extension type.
   * @param onAdd  - Function for handling when extensions are added/registered passes {@link PIXI.ExtensionFormat}.
   * @param onRemove  - Function for handling when extensions are removed/unregistered passes {@link PIXI.ExtensionFormat}.
   * @returns {PIXI.extensions} For chaining.
   */
  handle(type2, onAdd, onRemove) {
    const addHandlers = this._addHandlers, removeHandlers = this._removeHandlers;
    if (addHandlers[type2] || removeHandlers[type2])
      throw new Error(`Extension type ${type2} already has a handler`);
    addHandlers[type2] = onAdd, removeHandlers[type2] = onRemove;
    const queue = this._queue;
    return queue[type2] && (queue[type2].forEach((ext) => onAdd(ext)), delete queue[type2]), this;
  },
  /**
   * Handle a type, but using a map by `name` property.
   * @param type - Type of extension to handle.
   * @param map - The object map of named extensions.
   * @returns {PIXI.extensions} For chaining.
   */
  handleByMap(type2, map5) {
    return this.handle(
      type2,
      (extension) => {
        map5[extension.name] = extension.ref;
      },
      (extension) => {
        delete map5[extension.name];
      }
    );
  },
  /**
   * Handle a type, but using a list of extensions.
   * @param type - Type of extension to handle.
   * @param list - The list of extensions.
   * @param defaultPriority - The default priority to use if none is specified.
   * @returns {PIXI.extensions} For chaining.
   */
  handleByList(type2, list, defaultPriority = -1) {
    return this.handle(
      type2,
      (extension) => {
        list.includes(extension.ref) || (list.push(extension.ref), list.sort((a2, b2) => normalizePriority(b2, defaultPriority) - normalizePriority(a2, defaultPriority)));
      },
      (extension) => {
        const index = list.indexOf(extension.ref);
        index !== -1 && list.splice(index, 1);
      }
    );
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/geometry/ViewableBuffer.mjs
var ViewableBuffer2 = class {
  constructor(sizeOrBuffer) {
    typeof sizeOrBuffer == "number" ? this.rawBinaryData = new ArrayBuffer(sizeOrBuffer) : sizeOrBuffer instanceof Uint8Array ? this.rawBinaryData = sizeOrBuffer.buffer : this.rawBinaryData = sizeOrBuffer, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);
  }
  /** View on the raw binary data as a `Int8Array`. */
  get int8View() {
    return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
  }
  /** View on the raw binary data as a `Uint8Array`. */
  get uint8View() {
    return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
  }
  /**  View on the raw binary data as a `Int16Array`. */
  get int16View() {
    return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
  }
  /** View on the raw binary data as a `Uint16Array`. */
  get uint16View() {
    return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;
  }
  /** View on the raw binary data as a `Int32Array`. */
  get int32View() {
    return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
  }
  /**
   * Returns the view of the given type.
   * @param type - One of `int8`, `uint8`, `int16`,
   *    `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - typed array of given type
   */
  view(type2) {
    return this[`${type2}View`];
  }
  /** Destroys all buffer references. Do not use after calling this. */
  destroy() {
    this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
  }
  static sizeOf(type2) {
    switch (type2) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(`${type2} isn't a valid view type`);
    }
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.mjs
var fragTemplate = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join(`
`);
function generateIfTestSrc(maxIfs) {
  let src = "";
  for (let i3 = 0; i3 < maxIfs; ++i3)
    i3 > 0 && (src += `
else `), i3 < maxIfs - 1 && (src += `if(test == ${i3}.0){}`);
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl) {
  if (maxIfs === 0)
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  const shader = gl.createShader(gl.FRAGMENT_SHADER);
  for (; ; ) {
    const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
    if (gl.shaderSource(shader, fragmentSrc), gl.compileShader(shader), !gl.getShaderParameter(shader, gl.COMPILE_STATUS))
      maxIfs = maxIfs / 2 | 0;
    else
      break;
  }
  return maxIfs;
}

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/state/State.mjs
var BLEND3 = 0;
var OFFSET3 = 1;
var CULLING3 = 2;
var DEPTH_TEST3 = 3;
var WINDING3 = 4;
var DEPTH_MASK3 = 5;
var State2 = class _State {
  constructor() {
    this.data = 0, this.blendMode = BLEND_MODES.NORMAL, this.polygonOffset = 0, this.blend = true, this.depthMask = true;
  }
  /**
   * Activates blending of the computed fragment color values.
   * @default true
   */
  get blend() {
    return !!(this.data & 1 << BLEND3);
  }
  set blend(value) {
    !!(this.data & 1 << BLEND3) !== value && (this.data ^= 1 << BLEND3);
  }
  /**
   * Activates adding an offset to depth values of polygon's fragments
   * @default false
   */
  get offsets() {
    return !!(this.data & 1 << OFFSET3);
  }
  set offsets(value) {
    !!(this.data & 1 << OFFSET3) !== value && (this.data ^= 1 << OFFSET3);
  }
  /**
   * Activates culling of polygons.
   * @default false
   */
  get culling() {
    return !!(this.data & 1 << CULLING3);
  }
  set culling(value) {
    !!(this.data & 1 << CULLING3) !== value && (this.data ^= 1 << CULLING3);
  }
  /**
   * Activates depth comparisons and updates to the depth buffer.
   * @default false
   */
  get depthTest() {
    return !!(this.data & 1 << DEPTH_TEST3);
  }
  set depthTest(value) {
    !!(this.data & 1 << DEPTH_TEST3) !== value && (this.data ^= 1 << DEPTH_TEST3);
  }
  /**
   * Enables or disables writing to the depth buffer.
   * @default true
   */
  get depthMask() {
    return !!(this.data & 1 << DEPTH_MASK3);
  }
  set depthMask(value) {
    !!(this.data & 1 << DEPTH_MASK3) !== value && (this.data ^= 1 << DEPTH_MASK3);
  }
  /**
   * Specifies whether or not front or back-facing polygons can be culled.
   * @default false
   */
  get clockwiseFrontFace() {
    return !!(this.data & 1 << WINDING3);
  }
  set clockwiseFrontFace(value) {
    !!(this.data & 1 << WINDING3) !== value && (this.data ^= 1 << WINDING3);
  }
  /**
   * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
   * @default PIXI.BLEND_MODES.NORMAL
   */
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(value) {
    this.blend = value !== BLEND_MODES.NONE, this._blendMode = value;
  }
  /**
   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
   * @default 0
   */
  get polygonOffset() {
    return this._polygonOffset;
  }
  set polygonOffset(value) {
    this.offsets = !!value, this._polygonOffset = value;
  }
  static for2d() {
    const state = new _State();
    return state.depthTest = false, state.blend = true, state;
  }
};
State2.prototype.toString = function() {
  return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/textures/resources/autoDetectResource.mjs
var INSTALLED = [];
function autoDetectResource(source3, options) {
  if (!source3)
    return null;
  let extension = "";
  if (typeof source3 == "string") {
    const result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source3);
    result && (extension = result[1].toLowerCase());
  }
  for (let i3 = INSTALLED.length - 1; i3 >= 0; --i3) {
    const ResourcePlugin = INSTALLED[i3];
    if (ResourcePlugin.test && ResourcePlugin.test(source3, extension))
      return new ResourcePlugin(source3, options);
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}

// ../../node_modules/.pnpm/@pixi+runner@7.3.1/node_modules/@pixi/runner/lib/Runner.mjs
var Runner = class {
  /**
   * @param name - The function name that will be executed on the listeners added to this Runner.
   */
  constructor(name) {
    this.items = [], this._name = name, this._aliasCount = 0;
  }
  /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */
  /**
   * Dispatch/Broadcast Runner to all listeners added to the queue.
   * @param {...any} params - (optional) parameters to pass to each listener
   */
  /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */
  emit(a0, a1, a2, a3, a4, a5, a6, a7) {
    if (arguments.length > 8)
      throw new Error("max arguments reached");
    const { name, items } = this;
    this._aliasCount++;
    for (let i3 = 0, len = items.length; i3 < len; i3++)
      items[i3][name](a0, a1, a2, a3, a4, a5, a6, a7);
    return items === this.items && this._aliasCount--, this;
  }
  ensureNonAliasedItems() {
    this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));
  }
  /**
   * Add a listener to the Runner
   *
   * Runners do not need to have scope or functions passed to them.
   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
   * as the name provided to the Runner when it was created.
   *
   * E.g. A listener passed to this Runner will require a 'complete' function.
   *
   * ```js
   * import { Runner } from '@pixi/runner';
   *
   * const complete = new Runner('complete');
   * ```
   *
   * The scope used will be the object itself.
   * @param {any} item - The object that will be listening.
   */
  add(item) {
    return item[this._name] && (this.ensureNonAliasedItems(), this.remove(item), this.items.push(item)), this;
  }
  /**
   * Remove a single listener from the dispatch queue.
   * @param {any} item - The listener that you would like to remove.
   */
  remove(item) {
    const index = this.items.indexOf(item);
    return index !== -1 && (this.ensureNonAliasedItems(), this.items.splice(index, 1)), this;
  }
  /**
   * Check to see if the listener is already in the Runner
   * @param {any} item - The listener that you would like to check.
   */
  contains(item) {
    return this.items.includes(item);
  }
  /** Remove all listeners from the Runner */
  removeAll() {
    return this.ensureNonAliasedItems(), this.items.length = 0, this;
  }
  /** Remove all references, don't use after this. */
  destroy() {
    this.removeAll(), this.items = null, this._name = null;
  }
  /**
   * `true` if there are no this Runner contains no listeners
   * @readonly
   */
  get empty() {
    return this.items.length === 0;
  }
  /**
   * The name of the runner.
   * @readonly
   */
  get name() {
    return this._name;
  }
};
Object.defineProperties(Runner.prototype, {
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method dispatch
   * @see PIXI.Runner#emit
   */
  dispatch: { value: Runner.prototype.emit },
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method run
   * @see PIXI.Runner#emit
   */
  run: { value: Runner.prototype.emit }
});

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/textures/resources/Resource.mjs
var Resource2 = class {
  /**
   * @param width - Width of the resource
   * @param height - Height of the resource
   */
  constructor(width = 0, height = 0) {
    this._width = width, this._height = height, this.destroyed = false, this.internal = false, this.onResize = new Runner("setRealSize"), this.onUpdate = new Runner("update"), this.onError = new Runner("onError");
  }
  /**
   * Bind to a parent BaseTexture
   * @param baseTexture - Parent texture
   */
  bind(baseTexture) {
    this.onResize.add(baseTexture), this.onUpdate.add(baseTexture), this.onError.add(baseTexture), (this._width || this._height) && this.onResize.emit(this._width, this._height);
  }
  /**
   * Unbind to a parent BaseTexture
   * @param baseTexture - Parent texture
   */
  unbind(baseTexture) {
    this.onResize.remove(baseTexture), this.onUpdate.remove(baseTexture), this.onError.remove(baseTexture);
  }
  /**
   * Trigger a resize event
   * @param width - X dimension
   * @param height - Y dimension
   */
  resize(width, height) {
    (width !== this._width || height !== this._height) && (this._width = width, this._height = height, this.onResize.emit(width, height));
  }
  /**
   * Has been validated
   * @readonly
   */
  get valid() {
    return !!this._width && !!this._height;
  }
  /** Has been updated trigger event. */
  update() {
    this.destroyed || this.onUpdate.emit();
  }
  /**
   * This can be overridden to start preloading a resource
   * or do any other prepare step.
   * @protected
   * @returns Handle the validate event
   */
  load() {
    return Promise.resolve(this);
  }
  /**
   * The width of the resource.
   * @readonly
   */
  get width() {
    return this._width;
  }
  /**
   * The height of the resource.
   * @readonly
   */
  get height() {
    return this._height;
  }
  /**
   * Set the style, optional to override
   * @param _renderer - yeah, renderer!
   * @param _baseTexture - the texture
   * @param _glTexture - texture instance for this webgl context
   * @returns - `true` is success
   */
  style(_renderer, _baseTexture, _glTexture) {
    return false;
  }
  /** Clean up anything, this happens when destroying is ready. */
  dispose() {
  }
  /**
   * Call when destroying resource, unbind any BaseTexture object
   * before calling this method, as reference counts are maintained
   * internally.
   */
  destroy() {
    this.destroyed || (this.destroyed = true, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);
  }
  /**
   * Abstract, used to auto-detect resource type.
   * @param {*} _source - The source object
   * @param {string} _extension - The extension of source, if set
   */
  static test(_source, _extension) {
    return false;
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/textures/resources/BufferResource.mjs
var BufferResource2 = class extends Resource2 {
  /**
   * @param source - Source buffer
   * @param options - Options
   * @param {number} options.width - Width of the texture
   * @param {number} options.height - Height of the texture
   * @param {1|2|4|8} [options.unpackAlignment=4] - The alignment of the pixel rows.
   */
  constructor(source3, options) {
    const { width, height } = options || {};
    if (!width || !height)
      throw new Error("BufferResource width or height invalid");
    super(width, height), this.data = source3, this.unpackAlignment = options.unpackAlignment ?? 4;
  }
  /**
   * Upload the texture to the GPU.
   * @param renderer - Upload to the renderer
   * @param baseTexture - Reference to parent texture
   * @param glTexture - glTexture
   * @returns - true is success
   */
  upload(renderer, baseTexture, glTexture) {
    const gl = renderer.gl;
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, this.unpackAlignment), gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
    const width = baseTexture.realWidth, height = baseTexture.realHeight;
    return glTexture.width === width && glTexture.height === height ? gl.texSubImage2D(
      baseTexture.target,
      0,
      0,
      0,
      width,
      height,
      baseTexture.format,
      glTexture.type,
      this.data
    ) : (glTexture.width = width, glTexture.height = height, gl.texImage2D(
      baseTexture.target,
      0,
      glTexture.internalFormat,
      width,
      height,
      0,
      baseTexture.format,
      glTexture.type,
      this.data
    )), true;
  }
  /** Destroy and don't use after this. */
  dispose() {
    this.data = null;
  }
  /**
   * Used to auto-detect the type of resource.
   * @param {*} source - The source object
   * @returns {boolean} `true` if buffer source
   */
  static test(source3) {
    return source3 === null || source3 instanceof Int8Array || source3 instanceof Uint8Array || source3 instanceof Uint8ClampedArray || source3 instanceof Int16Array || source3 instanceof Uint16Array || source3 instanceof Int32Array || source3 instanceof Uint32Array || source3 instanceof Float32Array;
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/textures/BaseTexture.mjs
var defaultBufferOptions = {
  scaleMode: SCALE_MODES.NEAREST,
  alphaMode: ALPHA_MODES.NPM
};
var _BaseTexture = class _BaseTexture2 extends import_eventemitter317.default {
  /**
   * @param {PIXI.Resource|HTMLImageElement|HTMLVideoElement|ImageBitmap|ICanvas|string} [resource=null] -
   *        The current resource to use, for things that aren't Resource objects, will be converted
   *        into a Resource.
   * @param options - Collection of options, default options inherited from {@link PIXI.BaseTexture.defaultOptions}.
   * @param {PIXI.MIPMAP_MODES} [options.mipmap] - If mipmapping is enabled for texture
   * @param {number} [options.anisotropicLevel] - Anisotropic filtering level of texture
   * @param {PIXI.WRAP_MODES} [options.wrapMode] - Wrap mode for textures
   * @param {PIXI.SCALE_MODES} [options.scaleMode] - Default scale mode, linear, nearest
   * @param {PIXI.FORMATS} [options.format] - GL format type
   * @param {PIXI.TYPES} [options.type] - GL data type
   * @param {PIXI.TARGETS} [options.target] - GL texture target
   * @param {PIXI.ALPHA_MODES} [options.alphaMode] - Pre multiply the image alpha
   * @param {number} [options.width=0] - Width of the texture
   * @param {number} [options.height=0] - Height of the texture
   * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - Resolution of the base texture
   * @param {object} [options.resourceOptions] - Optional resource options,
   *        see {@link PIXI.autoDetectResource autoDetectResource}
   */
  constructor(resource = null, options = null) {
    super(), options = Object.assign({}, _BaseTexture2.defaultOptions, options);
    const {
      alphaMode,
      mipmap,
      anisotropicLevel,
      scaleMode,
      width,
      height,
      wrapMode,
      format: format3,
      type: type2,
      target,
      resolution,
      resourceOptions
    } = options;
    resource && !(resource instanceof Resource2) && (resource = autoDetectResource(resource, resourceOptions), resource.internal = true), this.resolution = resolution || settings2.RESOLUTION, this.width = Math.round((width || 0) * this.resolution) / this.resolution, this.height = Math.round((height || 0) * this.resolution) / this.resolution, this._mipmap = mipmap, this.anisotropicLevel = anisotropicLevel, this._wrapMode = wrapMode, this._scaleMode = scaleMode, this.format = format3, this.type = type2, this.target = target, this.alphaMode = alphaMode, this.uid = uid2(), this.touched = 0, this.isPowerOfTwo = false, this._refreshPOT(), this._glTextures = {}, this.dirtyId = 0, this.dirtyStyleId = 0, this.cacheId = null, this.valid = width > 0 && height > 0, this.textureCacheIds = [], this.destroyed = false, this.resource = null, this._batchEnabled = 0, this._batchLocation = 0, this.parentTextureArray = null, this.setResource(resource);
  }
  /**
   * Pixel width of the source of this texture
   * @readonly
   */
  get realWidth() {
    return Math.round(this.width * this.resolution);
  }
  /**
   * Pixel height of the source of this texture
   * @readonly
   */
  get realHeight() {
    return Math.round(this.height * this.resolution);
  }
  /**
   * Mipmap mode of the texture, affects downscaled images
   * @default PIXI.MIPMAP_MODES.POW2
   */
  get mipmap() {
    return this._mipmap;
  }
  set mipmap(value) {
    this._mipmap !== value && (this._mipmap = value, this.dirtyStyleId++);
  }
  /**
   * The scale mode to apply when scaling this texture
   * @default PIXI.SCALE_MODES.LINEAR
   */
  get scaleMode() {
    return this._scaleMode;
  }
  set scaleMode(value) {
    this._scaleMode !== value && (this._scaleMode = value, this.dirtyStyleId++);
  }
  /**
   * How the texture wraps
   * @default PIXI.WRAP_MODES.CLAMP
   */
  get wrapMode() {
    return this._wrapMode;
  }
  set wrapMode(value) {
    this._wrapMode !== value && (this._wrapMode = value, this.dirtyStyleId++);
  }
  /**
   * Changes style options of BaseTexture
   * @param scaleMode - Pixi scalemode
   * @param mipmap - enable mipmaps
   * @returns - this
   */
  setStyle(scaleMode, mipmap) {
    let dirty;
    return scaleMode !== void 0 && scaleMode !== this.scaleMode && (this.scaleMode = scaleMode, dirty = true), mipmap !== void 0 && mipmap !== this.mipmap && (this.mipmap = mipmap, dirty = true), dirty && this.dirtyStyleId++, this;
  }
  /**
   * Changes w/h/resolution. Texture becomes valid if width and height are greater than zero.
   * @param desiredWidth - Desired visual width
   * @param desiredHeight - Desired visual height
   * @param resolution - Optionally set resolution
   * @returns - this
   */
  setSize(desiredWidth, desiredHeight, resolution) {
    return resolution = resolution || this.resolution, this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);
  }
  /**
   * Sets real size of baseTexture, preserves current resolution.
   * @param realWidth - Full rendered width
   * @param realHeight - Full rendered height
   * @param resolution - Optionally set resolution
   * @returns - this
   */
  setRealSize(realWidth, realHeight, resolution) {
    return this.resolution = resolution || this.resolution, this.width = Math.round(realWidth) / this.resolution, this.height = Math.round(realHeight) / this.resolution, this._refreshPOT(), this.update(), this;
  }
  /**
   * Refresh check for isPowerOfTwo texture based on size
   * @private
   */
  _refreshPOT() {
    this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
  }
  /**
   * Changes resolution
   * @param resolution - res
   * @returns - this
   */
  setResolution(resolution) {
    const oldResolution = this.resolution;
    return oldResolution === resolution ? this : (this.resolution = resolution, this.valid && (this.width = Math.round(this.width * oldResolution) / resolution, this.height = Math.round(this.height * oldResolution) / resolution, this.emit("update", this)), this._refreshPOT(), this);
  }
  /**
   * Sets the resource if it wasn't set. Throws error if resource already present
   * @param resource - that is managing this BaseTexture
   * @returns - this
   */
  setResource(resource) {
    if (this.resource === resource)
      return this;
    if (this.resource)
      throw new Error("Resource can be set only once");
    return resource.bind(this), this.resource = resource, this;
  }
  /** Invalidates the object. Texture becomes valid if width and height are greater than zero. */
  update() {
    this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = true, this.emit("loaded", this), this.emit("update", this));
  }
  /**
   * Handle errors with resources.
   * @private
   * @param event - Error event emitted.
   */
  onError(event) {
    this.emit("error", this, event);
  }
  /**
   * Destroys this base texture.
   * The method stops if resource doesn't want this texture to be destroyed.
   * Removes texture from all caches.
   * @fires PIXI.BaseTexture#destroyed
   */
  destroy() {
    this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete BaseTextureCache[this.cacheId], delete TextureCache[this.cacheId], this.cacheId = null), this.valid = false, this.dispose(), _BaseTexture2.removeFromCache(this), this.textureCacheIds = null, this.destroyed = true, this.emit("destroyed", this), this.removeAllListeners();
  }
  /**
   * Frees the texture from WebGL memory without destroying this texture object.
   * This means you can still use the texture later which will upload it to GPU
   * memory again.
   * @fires PIXI.BaseTexture#dispose
   */
  dispose() {
    this.emit("dispose", this);
  }
  /** Utility function for BaseTexture|Texture cast. */
  castToBaseTexture() {
    return this;
  }
  /**
   * Helper function that creates a base texture based on the source you provide.
   * The source can be - image url, image element, canvas element. If the
   * source is an image url or an image element and not in the base texture
   * cache, it will be created and loaded.
   * @static
   * @param {HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas|string|string[]} source - The
   *        source to create base texture from.
   * @param options - See {@link PIXI.BaseTexture}'s constructor for options.
   * @param {string} [options.pixiIdPrefix=pixiid] - If a source has no id, this is the prefix of the generated id
   * @param {boolean} [strict] - Enforce strict-mode, see {@link PIXI.settings.STRICT_TEXTURE_CACHE}.
   * @returns {PIXI.BaseTexture} The new base texture.
   */
  static from(source3, options, strict = settings2.STRICT_TEXTURE_CACHE) {
    const isFrame = typeof source3 == "string";
    let cacheId = null;
    if (isFrame)
      cacheId = source3;
    else {
      if (!source3._pixiId) {
        const prefix2 = options?.pixiIdPrefix || "pixiid";
        source3._pixiId = `${prefix2}_${uid2()}`;
      }
      cacheId = source3._pixiId;
    }
    let baseTexture = BaseTextureCache[cacheId];
    if (isFrame && strict && !baseTexture)
      throw new Error(`The cacheId "${cacheId}" does not exist in BaseTextureCache.`);
    return baseTexture || (baseTexture = new _BaseTexture2(source3, options), baseTexture.cacheId = cacheId, _BaseTexture2.addToCache(baseTexture, cacheId)), baseTexture;
  }
  /**
   * Create a new Texture with a BufferResource from a typed array.
   * @param buffer - The optional array to use. If no data is provided, a new Float32Array is created.
   * @param width - Width of the resource
   * @param height - Height of the resource
   * @param options - See {@link PIXI.BaseTexture}'s constructor for options.
   *        Default properties are different from the constructor's defaults.
   * @param {PIXI.FORMATS} [options.format] - The format is not given, the type is inferred from the
   *        type of the buffer: `RGBA` if Float32Array, Int8Array, Uint8Array, or Uint8ClampedArray,
   *        otherwise `RGBA_INTEGER`.
   * @param {PIXI.TYPES} [options.type] - The type is not given, the type is inferred from the
   *        type of the buffer. Maps Float32Array to `FLOAT`, Int32Array to `INT`, Uint32Array to
   *        `UNSIGNED_INT`, Int16Array to `SHORT`, Uint16Array to `UNSIGNED_SHORT`, Int8Array to `BYTE`,
   *        Uint8Array/Uint8ClampedArray to `UNSIGNED_BYTE`.
   * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.NPM]
   * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.SCALE_MODES.NEAREST]
   * @returns - The resulting new BaseTexture
   */
  static fromBuffer(buffer2, width, height, options) {
    buffer2 = buffer2 || new Float32Array(width * height * 4);
    const resource = new BufferResource2(buffer2, { width, height, ...options?.resourceOptions });
    let format3, type2;
    return buffer2 instanceof Float32Array ? (format3 = FORMATS.RGBA, type2 = TYPES.FLOAT) : buffer2 instanceof Int32Array ? (format3 = FORMATS.RGBA_INTEGER, type2 = TYPES.INT) : buffer2 instanceof Uint32Array ? (format3 = FORMATS.RGBA_INTEGER, type2 = TYPES.UNSIGNED_INT) : buffer2 instanceof Int16Array ? (format3 = FORMATS.RGBA_INTEGER, type2 = TYPES.SHORT) : buffer2 instanceof Uint16Array ? (format3 = FORMATS.RGBA_INTEGER, type2 = TYPES.UNSIGNED_SHORT) : buffer2 instanceof Int8Array ? (format3 = FORMATS.RGBA, type2 = TYPES.BYTE) : (format3 = FORMATS.RGBA, type2 = TYPES.UNSIGNED_BYTE), resource.internal = true, new _BaseTexture2(resource, Object.assign({}, defaultBufferOptions, { type: type2, format: format3 }, options));
  }
  /**
   * Adds a BaseTexture to the global BaseTextureCache. This cache is shared across the whole PIXI object.
   * @param {PIXI.BaseTexture} baseTexture - The BaseTexture to add to the cache.
   * @param {string} id - The id that the BaseTexture will be stored against.
   */
  static addToCache(baseTexture, id) {
    id && (baseTexture.textureCacheIds.includes(id) || baseTexture.textureCacheIds.push(id), BaseTextureCache[id] && BaseTextureCache[id] !== baseTexture && console.warn(`BaseTexture added to the cache with an id [${id}] that already had an entry`), BaseTextureCache[id] = baseTexture);
  }
  /**
   * Remove a BaseTexture from the global BaseTextureCache.
   * @param {string|PIXI.BaseTexture} baseTexture - id of a BaseTexture to be removed, or a BaseTexture instance itself.
   * @returns {PIXI.BaseTexture|null} The BaseTexture that was removed.
   */
  static removeFromCache(baseTexture) {
    if (typeof baseTexture == "string") {
      const baseTextureFromCache = BaseTextureCache[baseTexture];
      if (baseTextureFromCache) {
        const index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
        return index > -1 && baseTextureFromCache.textureCacheIds.splice(index, 1), delete BaseTextureCache[baseTexture], baseTextureFromCache;
      }
    } else if (baseTexture?.textureCacheIds) {
      for (let i3 = 0; i3 < baseTexture.textureCacheIds.length; ++i3)
        delete BaseTextureCache[baseTexture.textureCacheIds[i3]];
      return baseTexture.textureCacheIds.length = 0, baseTexture;
    }
    return null;
  }
};
_BaseTexture.defaultOptions = {
  /**
   * If mipmapping is enabled for texture.
   * @type {PIXI.MIPMAP_MODES}
   * @default PIXI.MIPMAP_MODES.POW2
   */
  mipmap: MIPMAP_MODES.POW2,
  /** Anisotropic filtering level of texture */
  anisotropicLevel: 0,
  /**
   * Default scale mode, linear, nearest.
   * @type {PIXI.SCALE_MODES}
   * @default PIXI.SCALE_MODES.LINEAR
   */
  scaleMode: SCALE_MODES.LINEAR,
  /**
   * Wrap mode for textures.
   * @type {PIXI.WRAP_MODES}
   * @default PIXI.WRAP_MODES.CLAMP
   */
  wrapMode: WRAP_MODES.CLAMP,
  /**
   * Pre multiply the image alpha
   * @type {PIXI.ALPHA_MODES}
   * @default PIXI.ALPHA_MODES.UNPACK
   */
  alphaMode: ALPHA_MODES.UNPACK,
  /**
   * GL texture target
   * @type {PIXI.TARGETS}
   * @default PIXI.TARGETS.TEXTURE_2D
   */
  target: TARGETS.TEXTURE_2D,
  /**
   * GL format type
   * @type {PIXI.FORMATS}
   * @default PIXI.FORMATS.RGBA
   */
  format: FORMATS.RGBA,
  /**
   * GL data type
   * @type {PIXI.TYPES}
   * @default PIXI.TYPES.UNSIGNED_BYTE
   */
  type: TYPES.UNSIGNED_BYTE
}, /** Global number of the texture batch, used by multi-texture renderers. */
_BaseTexture._globalBatch = 0;
var BaseTexture = _BaseTexture;

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/batch/BatchDrawCall.mjs
var BatchDrawCall = class {
  constructor() {
    this.texArray = null, this.blend = 0, this.type = DRAW_MODES.TRIANGLES, this.start = 0, this.size = 0, this.data = null;
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/geometry/Buffer.mjs
var UID = 0;
var Buffer3 = class _Buffer {
  /**
   * @param {PIXI.IArrayBuffer} data - the data to store in the buffer.
   * @param _static - `true` for static buffer
   * @param index - `true` for index buffer
   */
  constructor(data, _static = true, index = false) {
    this.data = data || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = index, this.static = _static, this.id = UID++, this.disposeRunner = new Runner("disposeBuffer");
  }
  // TODO could explore flagging only a partial upload?
  /**
   * Flags this buffer as requiring an upload to the GPU.
   * @param {PIXI.IArrayBuffer|number[]} [data] - the data to update in the buffer.
   */
  update(data) {
    data instanceof Array && (data = new Float32Array(data)), this.data = data || this.data, this._updateID++;
  }
  /** Disposes WebGL resources that are connected to this geometry. */
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  /** Destroys the buffer. */
  destroy() {
    this.dispose(), this.data = null;
  }
  /**
   * Flags whether this is an index buffer.
   *
   * Index buffers are of type `ELEMENT_ARRAY_BUFFER`. Note that setting this property to false will make
   * the buffer of type `ARRAY_BUFFER`.
   *
   * For backwards compatibility.
   */
  set index(value) {
    this.type = value ? BUFFER_TYPE2.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE2.ARRAY_BUFFER;
  }
  get index() {
    return this.type === BUFFER_TYPE2.ELEMENT_ARRAY_BUFFER;
  }
  /**
   * Helper function that creates a buffer based on an array or TypedArray
   * @param {ArrayBufferView | number[]} data - the TypedArray that the buffer will store. If this is a regular Array it will be converted to a Float32Array.
   * @returns - A new Buffer based on the data provided.
   */
  static from(data) {
    return data instanceof Array && (data = new Float32Array(data)), new _Buffer(data);
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/geometry/Attribute.mjs
var Attribute = class _Attribute {
  /**
   * @param buffer - the id of the buffer that this attribute will look for
   * @param size - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2.
   * @param normalized - should the data be normalized.
   * @param {PIXI.TYPES} [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available
   * @param [stride=0] - How far apart, in bytes, the start of each value is. (used for interleaving data)
   * @param [start=0] - How far into the array to start reading values (used for interleaving data)
   * @param [instance=false] - Whether the geometry is instanced.
   * @param [divisor=1] - Divisor to use when doing instanced rendering
   */
  constructor(buffer2, size3 = 0, normalized = false, type2 = TYPES.FLOAT, stride, start, instance, divisor = 1) {
    this.buffer = buffer2, this.size = size3, this.normalized = normalized, this.type = type2, this.stride = stride, this.start = start, this.instance = instance, this.divisor = divisor;
  }
  /** Destroys the Attribute. */
  destroy() {
    this.buffer = null;
  }
  /**
   * Helper function that creates an Attribute based on the information provided
   * @param buffer - the id of the buffer that this attribute will look for
   * @param [size=0] - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2
   * @param [normalized=false] - should the data be normalized.
   * @param [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available
   * @param [stride=0] - How far apart, in bytes, the start of each value is. (used for interleaving data)
   * @returns - A new {@link PIXI.Attribute} based on the information provided
   */
  static from(buffer2, size3, normalized, type2, stride) {
    return new _Attribute(buffer2, size3, normalized, type2, stride);
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/geometry/utils/interleaveTypedArrays.mjs
var map3 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function interleaveTypedArrays2(arrays, sizes) {
  let outSize = 0, stride = 0;
  const views = {};
  for (let i3 = 0; i3 < arrays.length; i3++)
    stride += sizes[i3], outSize += arrays[i3].length;
  const buffer2 = new ArrayBuffer(outSize * 4);
  let out3 = null, littleOffset = 0;
  for (let i3 = 0; i3 < arrays.length; i3++) {
    const size3 = sizes[i3], array = arrays[i3], type2 = getBufferType(array);
    views[type2] || (views[type2] = new map3[type2](buffer2)), out3 = views[type2];
    for (let j3 = 0; j3 < array.length; j3++) {
      const indexStart = (j3 / size3 | 0) * stride + littleOffset, index = j3 % size3;
      out3[indexStart + index] = array[j3];
    }
    littleOffset += size3;
  }
  return new Float32Array(buffer2);
}

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/geometry/Geometry.mjs
var byteSizeMap2 = { 5126: 4, 5123: 2, 5121: 1 };
var UID2 = 0;
var map4 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
};
var Geometry2 = class _Geometry {
  /**
   * @param buffers - An array of buffers. optional.
   * @param attributes - Of the geometry, optional structure of the attributes layout
   */
  constructor(buffers = [], attributes = {}) {
    this.buffers = buffers, this.indexBuffer = null, this.attributes = attributes, this.glVertexArrayObjects = {}, this.id = UID2++, this.instanced = false, this.instanceCount = 1, this.disposeRunner = new Runner("disposeGeometry"), this.refCount = 0;
  }
  /**
   *
   * Adds an attribute to the geometry
   * Note: `stride` and `start` should be `undefined` if you dont know them, not 0!
   * @param id - the name of the attribute (matching up to a shader)
   * @param {PIXI.Buffer|number[]} buffer - the buffer that holds the data of the attribute . You can also provide an Array and a buffer will be created from it.
   * @param size - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2
   * @param normalized - should the data be normalized.
   * @param [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available
   * @param [stride=0] - How far apart, in bytes, the start of each value is. (used for interleaving data)
   * @param [start=0] - How far into the array to start reading values (used for interleaving data)
   * @param instance - Instancing flag
   * @returns - Returns self, useful for chaining.
   */
  addAttribute(id, buffer2, size3 = 0, normalized = false, type2, stride, start, instance = false) {
    if (!buffer2)
      throw new Error("You must pass a buffer when creating an attribute");
    buffer2 instanceof Buffer3 || (buffer2 instanceof Array && (buffer2 = new Float32Array(buffer2)), buffer2 = new Buffer3(buffer2));
    const ids = id.split("|");
    if (ids.length > 1) {
      for (let i3 = 0; i3 < ids.length; i3++)
        this.addAttribute(ids[i3], buffer2, size3, normalized, type2);
      return this;
    }
    let bufferIndex = this.buffers.indexOf(buffer2);
    return bufferIndex === -1 && (this.buffers.push(buffer2), bufferIndex = this.buffers.length - 1), this.attributes[id] = new Attribute(bufferIndex, size3, normalized, type2, stride, start, instance), this.instanced = this.instanced || instance, this;
  }
  /**
   * Returns the requested attribute.
   * @param id - The name of the attribute required
   * @returns - The attribute requested.
   */
  getAttribute(id) {
    return this.attributes[id];
  }
  /**
   * Returns the requested buffer.
   * @param id - The name of the buffer required.
   * @returns - The buffer requested.
   */
  getBuffer(id) {
    return this.buffers[this.getAttribute(id).buffer];
  }
  /**
   *
   * Adds an index buffer to the geometry
   * The index buffer contains integers, three for each triangle in the geometry, which reference the various attribute buffers (position, colour, UV coordinates, other UV coordinates, normal, …). There is only ONE index buffer.
   * @param {PIXI.Buffer|number[]} [buffer] - The buffer that holds the data of the index buffer. You can also provide an Array and a buffer will be created from it.
   * @returns - Returns self, useful for chaining.
   */
  addIndex(buffer2) {
    return buffer2 instanceof Buffer3 || (buffer2 instanceof Array && (buffer2 = new Uint16Array(buffer2)), buffer2 = new Buffer3(buffer2)), buffer2.type = BUFFER_TYPE2.ELEMENT_ARRAY_BUFFER, this.indexBuffer = buffer2, this.buffers.includes(buffer2) || this.buffers.push(buffer2), this;
  }
  /**
   * Returns the index buffer
   * @returns - The index buffer.
   */
  getIndex() {
    return this.indexBuffer;
  }
  /**
   * This function modifies the structure so that all current attributes become interleaved into a single buffer
   * This can be useful if your model remains static as it offers a little performance boost
   * @returns - Returns self, useful for chaining.
   */
  interleave() {
    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
      return this;
    const arrays = [], sizes = [], interleavedBuffer = new Buffer3();
    let i3;
    for (i3 in this.attributes) {
      const attribute = this.attributes[i3], buffer2 = this.buffers[attribute.buffer];
      arrays.push(buffer2.data), sizes.push(attribute.size * byteSizeMap2[attribute.type] / 4), attribute.buffer = 0;
    }
    for (interleavedBuffer.data = interleaveTypedArrays2(arrays, sizes), i3 = 0; i3 < this.buffers.length; i3++)
      this.buffers[i3] !== this.indexBuffer && this.buffers[i3].destroy();
    return this.buffers = [interleavedBuffer], this.indexBuffer && this.buffers.push(this.indexBuffer), this;
  }
  /** Get the size of the geometries, in vertices. */
  getSize() {
    for (const i3 in this.attributes) {
      const attribute = this.attributes[i3];
      return this.buffers[attribute.buffer].data.length / (attribute.stride / 4 || attribute.size);
    }
    return 0;
  }
  /** Disposes WebGL resources that are connected to this geometry. */
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  /** Destroys the geometry. */
  destroy() {
    this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;
  }
  /**
   * Returns a clone of the geometry.
   * @returns - A new clone of this geometry.
   */
  clone() {
    const geometry = new _Geometry();
    for (let i3 = 0; i3 < this.buffers.length; i3++)
      geometry.buffers[i3] = new Buffer3(this.buffers[i3].data.slice(0));
    for (const i3 in this.attributes) {
      const attrib = this.attributes[i3];
      geometry.attributes[i3] = new Attribute(
        attrib.buffer,
        attrib.size,
        attrib.normalized,
        attrib.type,
        attrib.stride,
        attrib.start,
        attrib.instance
      );
    }
    return this.indexBuffer && (geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)], geometry.indexBuffer.type = BUFFER_TYPE2.ELEMENT_ARRAY_BUFFER), geometry;
  }
  /**
   * Merges an array of geometries into a new single one.
   *
   * Geometry attribute styles must match for this operation to work.
   * @param geometries - array of geometries to merge
   * @returns - Shiny new geometry!
   */
  static merge(geometries) {
    const geometryOut = new _Geometry(), arrays = [], sizes = [], offsets = [];
    let geometry;
    for (let i3 = 0; i3 < geometries.length; i3++) {
      geometry = geometries[i3];
      for (let j3 = 0; j3 < geometry.buffers.length; j3++)
        sizes[j3] = sizes[j3] || 0, sizes[j3] += geometry.buffers[j3].data.length, offsets[j3] = 0;
    }
    for (let i3 = 0; i3 < geometry.buffers.length; i3++)
      arrays[i3] = new map4[getBufferType(geometry.buffers[i3].data)](sizes[i3]), geometryOut.buffers[i3] = new Buffer3(arrays[i3]);
    for (let i3 = 0; i3 < geometries.length; i3++) {
      geometry = geometries[i3];
      for (let j3 = 0; j3 < geometry.buffers.length; j3++)
        arrays[j3].set(geometry.buffers[j3].data, offsets[j3]), offsets[j3] += geometry.buffers[j3].data.length;
    }
    if (geometryOut.attributes = geometry.attributes, geometry.indexBuffer) {
      geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)], geometryOut.indexBuffer.type = BUFFER_TYPE2.ELEMENT_ARRAY_BUFFER;
      let offset = 0, stride = 0, offset2 = 0, bufferIndexToCount = 0;
      for (let i3 = 0; i3 < geometry.buffers.length; i3++)
        if (geometry.buffers[i3] !== geometry.indexBuffer) {
          bufferIndexToCount = i3;
          break;
        }
      for (const i3 in geometry.attributes) {
        const attribute = geometry.attributes[i3];
        (attribute.buffer | 0) === bufferIndexToCount && (stride += attribute.size * byteSizeMap2[attribute.type] / 4);
      }
      for (let i3 = 0; i3 < geometries.length; i3++) {
        const indexBufferData = geometries[i3].indexBuffer.data;
        for (let j3 = 0; j3 < indexBufferData.length; j3++)
          geometryOut.indexBuffer.data[j3 + offset2] += offset;
        offset += geometries[i3].buffers[bufferIndexToCount].data.length / stride, offset2 += indexBufferData.length;
      }
    }
    return geometryOut;
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/batch/BatchGeometry.mjs
var BatchGeometry2 = class extends Geometry2 {
  /**
   * @param {boolean} [_static=false] - Optimization flag, where `false`
   *        is updated every frame, `true` doesn't change frame-to-frame.
   */
  constructor(_static = false) {
    super(), this._buffer = new Buffer3(null, _static, false), this._indexBuffer = new Buffer3(null, _static, true), this.addAttribute("aVertexPosition", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aColor", this._buffer, 4, true, TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, true, TYPES.FLOAT).addIndex(this._indexBuffer);
  }
};

// ../../node_modules/.pnpm/@pixi+math@7.3.1/node_modules/@pixi/math/lib/const.mjs
var PI_22 = Math.PI * 2;
var RAD_TO_DEG2 = 180 / Math.PI;
var DEG_TO_RAD2 = Math.PI / 180;
var SHAPES = /* @__PURE__ */ ((SHAPES2) => (SHAPES2[SHAPES2.POLY = 0] = "POLY", SHAPES2[SHAPES2.RECT = 1] = "RECT", SHAPES2[SHAPES2.CIRC = 2] = "CIRC", SHAPES2[SHAPES2.ELIP = 3] = "ELIP", SHAPES2[SHAPES2.RREC = 4] = "RREC", SHAPES2))(SHAPES || {});

// ../../node_modules/.pnpm/@pixi+math@7.3.1/node_modules/@pixi/math/lib/Point.mjs
var Point2 = class _Point {
  /**
   * Creates a new `Point`
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(x3 = 0, y2 = 0) {
    this.x = 0, this.y = 0, this.x = x3, this.y = y2;
  }
  /**
   * Creates a clone of this point
   * @returns A clone of this point
   */
  clone() {
    return new _Point(this.x, this.y);
  }
  /**
   * Copies `x` and `y` from the given point into this point
   * @param p - The point to copy from
   * @returns The point instance itself
   */
  copyFrom(p3) {
    return this.set(p3.x, p3.y), this;
  }
  /**
   * Copies this point's x and y into the given point (`p`).
   * @param p - The point to copy to. Can be any of type that is or extends `IPointData`
   * @returns The point (`p`) with values updated
   */
  copyTo(p3) {
    return p3.set(this.x, this.y), p3;
  }
  /**
   * Accepts another point (`p`) and returns `true` if the given point is equal to this point
   * @param p - The point to check
   * @returns Returns `true` if both `x` and `y` are equal
   */
  equals(p3) {
    return p3.x === this.x && p3.y === this.y;
  }
  /**
   * Sets the point to a new `x` and `y` position.
   * If `y` is omitted, both `x` and `y` will be set to `x`.
   * @param {number} [x=0] - position of the point on the `x` axis
   * @param {number} [y=x] - position of the point on the `y` axis
   * @returns The point instance itself
   */
  set(x3 = 0, y2 = x3) {
    return this.x = x3, this.y = y2, this;
  }
};
Point2.prototype.toString = function() {
  return `[@pixi/math:Point x=${this.x} y=${this.y}]`;
};

// ../../node_modules/.pnpm/@pixi+math@7.3.1/node_modules/@pixi/math/lib/shapes/Rectangle.mjs
var tempPoints2 = [new Point2(), new Point2(), new Point2(), new Point2()];
var Rectangle2 = class _Rectangle {
  /**
   * @param x - The X coordinate of the upper-left corner of the rectangle
   * @param y - The Y coordinate of the upper-left corner of the rectangle
   * @param width - The overall width of the rectangle
   * @param height - The overall height of the rectangle
   */
  constructor(x3 = 0, y2 = 0, width = 0, height = 0) {
    this.x = Number(x3), this.y = Number(y2), this.width = Number(width), this.height = Number(height), this.type = SHAPES.RECT;
  }
  /** Returns the left edge of the rectangle. */
  get left() {
    return this.x;
  }
  /** Returns the right edge of the rectangle. */
  get right() {
    return this.x + this.width;
  }
  /** Returns the top edge of the rectangle. */
  get top() {
    return this.y;
  }
  /** Returns the bottom edge of the rectangle. */
  get bottom() {
    return this.y + this.height;
  }
  /** A constant empty rectangle. */
  static get EMPTY() {
    return new _Rectangle(0, 0, 0, 0);
  }
  /**
   * Creates a clone of this Rectangle
   * @returns a copy of the rectangle
   */
  clone() {
    return new _Rectangle(this.x, this.y, this.width, this.height);
  }
  /**
   * Copies another rectangle to this one.
   * @param rectangle - The rectangle to copy from.
   * @returns Returns itself.
   */
  copyFrom(rectangle) {
    return this.x = rectangle.x, this.y = rectangle.y, this.width = rectangle.width, this.height = rectangle.height, this;
  }
  /**
   * Copies this rectangle to another one.
   * @param rectangle - The rectangle to copy to.
   * @returns Returns given parameter.
   */
  copyTo(rectangle) {
    return rectangle.x = this.x, rectangle.y = this.y, rectangle.width = this.width, rectangle.height = this.height, rectangle;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rectangle
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Rectangle
   */
  contains(x3, y2) {
    return this.width <= 0 || this.height <= 0 ? false : x3 >= this.x && x3 < this.x + this.width && y2 >= this.y && y2 < this.y + this.height;
  }
  /**
   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
   * Returns true only if the area of the intersection is >0, this means that Rectangles
   * sharing a side are not overlapping. Another side effect is that an arealess rectangle
   * (width or height equal to zero) can't intersect any other rectangle.
   * @param {Rectangle} other - The Rectangle to intersect with `this`.
   * @param {Matrix} transform - The transformation matrix of `other`.
   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
   */
  intersects(other, transform) {
    if (!transform) {
      const x02 = this.x < other.x ? other.x : this.x;
      if ((this.right > other.right ? other.right : this.right) <= x02)
        return false;
      const y02 = this.y < other.y ? other.y : this.y;
      return (this.bottom > other.bottom ? other.bottom : this.bottom) > y02;
    }
    const x0 = this.left, x1 = this.right, y0 = this.top, y1 = this.bottom;
    if (x1 <= x0 || y1 <= y0)
      return false;
    const lt = tempPoints2[0].set(other.left, other.top), lb = tempPoints2[1].set(other.left, other.bottom), rt = tempPoints2[2].set(other.right, other.top), rb = tempPoints2[3].set(other.right, other.bottom);
    if (rt.x <= lt.x || lb.y <= lt.y)
      return false;
    const s2 = Math.sign(transform.a * transform.d - transform.b * transform.c);
    if (s2 === 0 || (transform.apply(lt, lt), transform.apply(lb, lb), transform.apply(rt, rt), transform.apply(rb, rb), Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1))
      return false;
    const nx = s2 * (lb.y - lt.y), ny = s2 * (lt.x - lb.x), n00 = nx * x0 + ny * y0, n10 = nx * x1 + ny * y0, n01 = nx * x0 + ny * y1, n11 = nx * x1 + ny * y1;
    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y)
      return false;
    const mx = s2 * (lt.y - rt.y), my = s2 * (rt.x - lt.x), m00 = mx * x0 + my * y0, m10 = mx * x1 + my * y0, m01 = mx * x0 + my * y1, m11 = mx * x1 + my * y1;
    return !(Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y);
  }
  /**
   * Pads the rectangle making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @param paddingX - The horizontal padding amount.
   * @param paddingY - The vertical padding amount.
   * @returns Returns itself.
   */
  pad(paddingX = 0, paddingY = paddingX) {
    return this.x -= paddingX, this.y -= paddingY, this.width += paddingX * 2, this.height += paddingY * 2, this;
  }
  /**
   * Fits this rectangle around the passed one.
   * @param rectangle - The rectangle to fit.
   * @returns Returns itself.
   */
  fit(rectangle) {
    const x1 = Math.max(this.x, rectangle.x), x22 = Math.min(this.x + this.width, rectangle.x + rectangle.width), y1 = Math.max(this.y, rectangle.y), y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
    return this.x = x1, this.width = Math.max(x22 - x1, 0), this.y = y1, this.height = Math.max(y2 - y1, 0), this;
  }
  /**
   * Enlarges rectangle that way its corners lie on grid
   * @param resolution - resolution
   * @param eps - precision
   * @returns Returns itself.
   */
  ceil(resolution = 1, eps = 1e-3) {
    const x22 = Math.ceil((this.x + this.width - eps) * resolution) / resolution, y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
    return this.x = Math.floor((this.x + eps) * resolution) / resolution, this.y = Math.floor((this.y + eps) * resolution) / resolution, this.width = x22 - this.x, this.height = y2 - this.y, this;
  }
  /**
   * Enlarges this rectangle to include the passed rectangle.
   * @param rectangle - The rectangle to include.
   * @returns Returns itself.
   */
  enlarge(rectangle) {
    const x1 = Math.min(this.x, rectangle.x), x22 = Math.max(this.x + this.width, rectangle.x + rectangle.width), y1 = Math.min(this.y, rectangle.y), y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
    return this.x = x1, this.width = x22 - x1, this.y = y1, this.height = y2 - y1, this;
  }
};
Rectangle2.prototype.toString = function() {
  return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
};

// ../../node_modules/.pnpm/@pixi+math@7.3.1/node_modules/@pixi/math/lib/shapes/Circle.mjs
var Circle2 = class _Circle {
  /**
   * @param x - The X coordinate of the center of this circle
   * @param y - The Y coordinate of the center of this circle
   * @param radius - The radius of the circle
   */
  constructor(x3 = 0, y2 = 0, radius = 0) {
    this.x = x3, this.y = y2, this.radius = radius, this.type = SHAPES.CIRC;
  }
  /**
   * Creates a clone of this Circle instance
   * @returns A copy of the Circle
   */
  clone() {
    return new _Circle(this.x, this.y, this.radius);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Circle
   */
  contains(x3, y2) {
    if (this.radius <= 0)
      return false;
    const r2 = this.radius * this.radius;
    let dx = this.x - x3, dy = this.y - y2;
    return dx *= dx, dy *= dy, dx + dy <= r2;
  }
  /**
   * Returns the framing rectangle of the circle as a Rectangle object
   * @returns The framing rectangle
   */
  getBounds() {
    return new Rectangle2(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
  }
};
Circle2.prototype.toString = function() {
  return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
};

// ../../node_modules/.pnpm/@pixi+math@7.3.1/node_modules/@pixi/math/lib/shapes/Ellipse.mjs
var Ellipse2 = class _Ellipse {
  /**
   * @param x - The X coordinate of the center of this ellipse
   * @param y - The Y coordinate of the center of this ellipse
   * @param halfWidth - The half width of this ellipse
   * @param halfHeight - The half height of this ellipse
   */
  constructor(x3 = 0, y2 = 0, halfWidth = 0, halfHeight = 0) {
    this.x = x3, this.y = y2, this.width = halfWidth, this.height = halfHeight, this.type = SHAPES.ELIP;
  }
  /**
   * Creates a clone of this Ellipse instance
   * @returns {PIXI.Ellipse} A copy of the ellipse
   */
  clone() {
    return new _Ellipse(this.x, this.y, this.width, this.height);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coords are within this ellipse
   */
  contains(x3, y2) {
    if (this.width <= 0 || this.height <= 0)
      return false;
    let normx = (x3 - this.x) / this.width, normy = (y2 - this.y) / this.height;
    return normx *= normx, normy *= normy, normx + normy <= 1;
  }
  /**
   * Returns the framing rectangle of the ellipse as a Rectangle object
   * @returns The framing rectangle
   */
  getBounds() {
    return new Rectangle2(this.x - this.width, this.y - this.height, this.width, this.height);
  }
};
Ellipse2.prototype.toString = function() {
  return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
};

// ../../node_modules/.pnpm/@pixi+math@7.3.1/node_modules/@pixi/math/lib/shapes/Polygon.mjs
var Polygon2 = class _Polygon {
  /**
   * @param {PIXI.IPointData[]|number[]} points - This can be an array of Points
   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
   *  the arguments passed can be all the points of the polygon e.g.
   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
   */
  constructor(...points) {
    let flat = Array.isArray(points[0]) ? points[0] : points;
    if (typeof flat[0] != "number") {
      const p3 = [];
      for (let i3 = 0, il = flat.length; i3 < il; i3++)
        p3.push(flat[i3].x, flat[i3].y);
      flat = p3;
    }
    this.points = flat, this.type = SHAPES.POLY, this.closeStroke = true;
  }
  /**
   * Creates a clone of this polygon.
   * @returns - A copy of the polygon.
   */
  clone() {
    const points = this.points.slice(), polygon = new _Polygon(points);
    return polygon.closeStroke = this.closeStroke, polygon;
  }
  /**
   * Checks whether the x and y coordinates passed to this function are contained within this polygon.
   * @param x - The X coordinate of the point to test.
   * @param y - The Y coordinate of the point to test.
   * @returns - Whether the x/y coordinates are within this polygon.
   */
  contains(x3, y2) {
    let inside = false;
    const length = this.points.length / 2;
    for (let i3 = 0, j3 = length - 1; i3 < length; j3 = i3++) {
      const xi = this.points[i3 * 2], yi = this.points[i3 * 2 + 1], xj = this.points[j3 * 2], yj = this.points[j3 * 2 + 1];
      yi > y2 != yj > y2 && x3 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi && (inside = !inside);
    }
    return inside;
  }
};
Polygon2.prototype.toString = function() {
  return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
};

// ../../node_modules/.pnpm/@pixi+math@7.3.1/node_modules/@pixi/math/lib/shapes/RoundedRectangle.mjs
var RoundedRectangle2 = class _RoundedRectangle {
  /**
   * @param x - The X coordinate of the upper-left corner of the rounded rectangle
   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
   * @param width - The overall width of this rounded rectangle
   * @param height - The overall height of this rounded rectangle
   * @param radius - Controls the radius of the rounded corners
   */
  constructor(x3 = 0, y2 = 0, width = 0, height = 0, radius = 20) {
    this.x = x3, this.y = y2, this.width = width, this.height = height, this.radius = radius, this.type = SHAPES.RREC;
  }
  /**
   * Creates a clone of this Rounded Rectangle.
   * @returns - A copy of the rounded rectangle.
   */
  clone() {
    return new _RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
   * @param x - The X coordinate of the point to test.
   * @param y - The Y coordinate of the point to test.
   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.
   */
  contains(x3, y2) {
    if (this.width <= 0 || this.height <= 0)
      return false;
    if (x3 >= this.x && x3 <= this.x + this.width && y2 >= this.y && y2 <= this.y + this.height) {
      const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
      if (y2 >= this.y + radius && y2 <= this.y + this.height - radius || x3 >= this.x + radius && x3 <= this.x + this.width - radius)
        return true;
      let dx = x3 - (this.x + radius), dy = y2 - (this.y + radius);
      const radius2 = radius * radius;
      if (dx * dx + dy * dy <= radius2 || (dx = x3 - (this.x + this.width - radius), dx * dx + dy * dy <= radius2) || (dy = y2 - (this.y + this.height - radius), dx * dx + dy * dy <= radius2) || (dx = x3 - (this.x + radius), dx * dx + dy * dy <= radius2))
        return true;
    }
    return false;
  }
};
RoundedRectangle2.prototype.toString = function() {
  return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
};

// ../../node_modules/.pnpm/@pixi+math@7.3.1/node_modules/@pixi/math/lib/Matrix.mjs
var Matrix2 = class _Matrix {
  /**
   * @param a - x scale
   * @param b - y skew
   * @param c - x skew
   * @param d - y scale
   * @param tx - x translation
   * @param ty - y translation
   */
  constructor(a2 = 1, b2 = 0, c2 = 0, d3 = 1, tx = 0, ty = 0) {
    this.array = null, this.a = a2, this.b = b2, this.c = c2, this.d = d3, this.tx = tx, this.ty = ty;
  }
  /**
   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
   *
   * a = array[0]
   * b = array[1]
   * c = array[3]
   * d = array[4]
   * tx = array[2]
   * ty = array[5]
   * @param array - The array that the matrix will be populated from.
   */
  fromArray(array) {
    this.a = array[0], this.b = array[1], this.c = array[3], this.d = array[4], this.tx = array[2], this.ty = array[5];
  }
  /**
   * Sets the matrix properties.
   * @param a - Matrix component
   * @param b - Matrix component
   * @param c - Matrix component
   * @param d - Matrix component
   * @param tx - Matrix component
   * @param ty - Matrix component
   * @returns This matrix. Good for chaining method calls.
   */
  set(a2, b2, c2, d3, tx, ty) {
    return this.a = a2, this.b = b2, this.c = c2, this.d = d3, this.tx = tx, this.ty = ty, this;
  }
  /**
   * Creates an array from the current Matrix object.
   * @param transpose - Whether we need to transpose the matrix or not
   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out
   * @returns The newly created array which contains the matrix
   */
  toArray(transpose, out3) {
    this.array || (this.array = new Float32Array(9));
    const array = out3 || this.array;
    return transpose ? (array[0] = this.a, array[1] = this.b, array[2] = 0, array[3] = this.c, array[4] = this.d, array[5] = 0, array[6] = this.tx, array[7] = this.ty, array[8] = 1) : (array[0] = this.a, array[1] = this.c, array[2] = this.tx, array[3] = this.b, array[4] = this.d, array[5] = this.ty, array[6] = 0, array[7] = 0, array[8] = 1), array;
  }
  /**
   * Get a new position with the current transformation applied.
   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
   * @param pos - The origin
   * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {PIXI.Point} The new point, transformed through this matrix
   */
  apply(pos, newPos) {
    newPos = newPos || new Point2();
    const x3 = pos.x, y2 = pos.y;
    return newPos.x = this.a * x3 + this.c * y2 + this.tx, newPos.y = this.b * x3 + this.d * y2 + this.ty, newPos;
  }
  /**
   * Get a new position with the inverse of the current transformation applied.
   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
   * @param pos - The origin
   * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
   * @returns {PIXI.Point} The new point, inverse-transformed through this matrix
   */
  applyInverse(pos, newPos) {
    newPos = newPos || new Point2();
    const id = 1 / (this.a * this.d + this.c * -this.b), x3 = pos.x, y2 = pos.y;
    return newPos.x = this.d * id * x3 + -this.c * id * y2 + (this.ty * this.c - this.tx * this.d) * id, newPos.y = this.a * id * y2 + -this.b * id * x3 + (-this.ty * this.a + this.tx * this.b) * id, newPos;
  }
  /**
   * Translates the matrix on the x and y.
   * @param x - How much to translate x by
   * @param y - How much to translate y by
   * @returns This matrix. Good for chaining method calls.
   */
  translate(x3, y2) {
    return this.tx += x3, this.ty += y2, this;
  }
  /**
   * Applies a scale transformation to the matrix.
   * @param x - The amount to scale horizontally
   * @param y - The amount to scale vertically
   * @returns This matrix. Good for chaining method calls.
   */
  scale(x3, y2) {
    return this.a *= x3, this.d *= y2, this.c *= x3, this.b *= y2, this.tx *= x3, this.ty *= y2, this;
  }
  /**
   * Applies a rotation transformation to the matrix.
   * @param angle - The angle in radians.
   * @returns This matrix. Good for chaining method calls.
   */
  rotate(angle) {
    const cos = Math.cos(angle), sin = Math.sin(angle), a1 = this.a, c1 = this.c, tx1 = this.tx;
    return this.a = a1 * cos - this.b * sin, this.b = a1 * sin + this.b * cos, this.c = c1 * cos - this.d * sin, this.d = c1 * sin + this.d * cos, this.tx = tx1 * cos - this.ty * sin, this.ty = tx1 * sin + this.ty * cos, this;
  }
  /**
   * Appends the given Matrix to this Matrix.
   * @param matrix - The matrix to append.
   * @returns This matrix. Good for chaining method calls.
   */
  append(matrix) {
    const a1 = this.a, b1 = this.b, c1 = this.c, d1 = this.d;
    return this.a = matrix.a * a1 + matrix.b * c1, this.b = matrix.a * b1 + matrix.b * d1, this.c = matrix.c * a1 + matrix.d * c1, this.d = matrix.c * b1 + matrix.d * d1, this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx, this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty, this;
  }
  /**
   * Sets the matrix based on all the available properties
   * @param x - Position on the x axis
   * @param y - Position on the y axis
   * @param pivotX - Pivot on the x axis
   * @param pivotY - Pivot on the y axis
   * @param scaleX - Scale on the x axis
   * @param scaleY - Scale on the y axis
   * @param rotation - Rotation in radians
   * @param skewX - Skew on the x axis
   * @param skewY - Skew on the y axis
   * @returns This matrix. Good for chaining method calls.
   */
  setTransform(x3, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
    return this.a = Math.cos(rotation + skewY) * scaleX, this.b = Math.sin(rotation + skewY) * scaleX, this.c = -Math.sin(rotation - skewX) * scaleY, this.d = Math.cos(rotation - skewX) * scaleY, this.tx = x3 - (pivotX * this.a + pivotY * this.c), this.ty = y2 - (pivotX * this.b + pivotY * this.d), this;
  }
  /**
   * Prepends the given Matrix to this Matrix.
   * @param matrix - The matrix to prepend
   * @returns This matrix. Good for chaining method calls.
   */
  prepend(matrix) {
    const tx1 = this.tx;
    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
      const a1 = this.a, c1 = this.c;
      this.a = a1 * matrix.a + this.b * matrix.c, this.b = a1 * matrix.b + this.b * matrix.d, this.c = c1 * matrix.a + this.d * matrix.c, this.d = c1 * matrix.b + this.d * matrix.d;
    }
    return this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx, this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty, this;
  }
  /**
   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
   * @param transform - The transform to apply the properties to.
   * @returns The transform with the newly applied properties
   */
  decompose(transform) {
    const a2 = this.a, b2 = this.b, c2 = this.c, d3 = this.d, pivot = transform.pivot, skewX = -Math.atan2(-c2, d3), skewY = Math.atan2(b2, a2), delta = Math.abs(skewX + skewY);
    return delta < 1e-5 || Math.abs(PI_22 - delta) < 1e-5 ? (transform.rotation = skewY, transform.skew.x = transform.skew.y = 0) : (transform.rotation = 0, transform.skew.x = skewX, transform.skew.y = skewY), transform.scale.x = Math.sqrt(a2 * a2 + b2 * b2), transform.scale.y = Math.sqrt(c2 * c2 + d3 * d3), transform.position.x = this.tx + (pivot.x * a2 + pivot.y * c2), transform.position.y = this.ty + (pivot.x * b2 + pivot.y * d3), transform;
  }
  /**
   * Inverts this matrix
   * @returns This matrix. Good for chaining method calls.
   */
  invert() {
    const a1 = this.a, b1 = this.b, c1 = this.c, d1 = this.d, tx1 = this.tx, n2 = a1 * d1 - b1 * c1;
    return this.a = d1 / n2, this.b = -b1 / n2, this.c = -c1 / n2, this.d = a1 / n2, this.tx = (c1 * this.ty - d1 * tx1) / n2, this.ty = -(a1 * this.ty - b1 * tx1) / n2, this;
  }
  /**
   * Resets this Matrix to an identity (default) matrix.
   * @returns This matrix. Good for chaining method calls.
   */
  identity() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
  }
  /**
   * Creates a new Matrix object with the same values as this one.
   * @returns A copy of this matrix. Good for chaining method calls.
   */
  clone() {
    const matrix = new _Matrix();
    return matrix.a = this.a, matrix.b = this.b, matrix.c = this.c, matrix.d = this.d, matrix.tx = this.tx, matrix.ty = this.ty, matrix;
  }
  /**
   * Changes the values of the given matrix to be the same as the ones in this matrix
   * @param matrix - The matrix to copy to.
   * @returns The matrix given in parameter with its values updated.
   */
  copyTo(matrix) {
    return matrix.a = this.a, matrix.b = this.b, matrix.c = this.c, matrix.d = this.d, matrix.tx = this.tx, matrix.ty = this.ty, matrix;
  }
  /**
   * Changes the values of the matrix to be the same as the ones in given matrix
   * @param {PIXI.Matrix} matrix - The matrix to copy from.
   * @returns {PIXI.Matrix} this
   */
  copyFrom(matrix) {
    return this.a = matrix.a, this.b = matrix.b, this.c = matrix.c, this.d = matrix.d, this.tx = matrix.tx, this.ty = matrix.ty, this;
  }
  /**
   * A default (identity) matrix
   * @readonly
   */
  static get IDENTITY() {
    return new _Matrix();
  }
  /**
   * A temp matrix
   * @readonly
   */
  static get TEMP_MATRIX() {
    return new _Matrix();
  }
};
Matrix2.prototype.toString = function() {
  return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
};

// ../../node_modules/.pnpm/@pixi+math@7.3.1/node_modules/@pixi/math/lib/groupD8.mjs
var ux2 = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
var uy2 = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
var vx2 = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
var vy2 = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
var rotationCayley2 = [];
var rotationMatrices2 = [];
var signum2 = Math.sign;
function init2() {
  for (let i3 = 0; i3 < 16; i3++) {
    const row = [];
    rotationCayley2.push(row);
    for (let j3 = 0; j3 < 16; j3++) {
      const _ux = signum2(ux2[i3] * ux2[j3] + vx2[i3] * uy2[j3]), _uy = signum2(uy2[i3] * ux2[j3] + vy2[i3] * uy2[j3]), _vx = signum2(ux2[i3] * vx2[j3] + vx2[i3] * vy2[j3]), _vy = signum2(uy2[i3] * vx2[j3] + vy2[i3] * vy2[j3]);
      for (let k3 = 0; k3 < 16; k3++)
        if (ux2[k3] === _ux && uy2[k3] === _uy && vx2[k3] === _vx && vy2[k3] === _vy) {
          row.push(k3);
          break;
        }
    }
  }
  for (let i3 = 0; i3 < 16; i3++) {
    const mat = new Matrix2();
    mat.set(ux2[i3], uy2[i3], vx2[i3], vy2[i3], 0, 0), rotationMatrices2.push(mat);
  }
}
init2();
var groupD82 = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0°       | East      |
   * @readonly
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45°↻     | Southeast |
   * @readonly
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90°↻     | South     |
   * @readonly
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135°↻    | Southwest |
   * @readonly
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180°     | West      |
   * @readonly
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135°/225°↻ | Northwest    |
   * @readonly
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90°/270°↻  | North        |
   * @readonly
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45°/315°↻  | Northeast    |
   * @readonly
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   * @readonly
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   * @readonly
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   * @readonly
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   * @readonly
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: (ind) => ux2[ind],
  /**
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: (ind) => uy2[ind],
  /**
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: (ind) => vx2[ind],
  /**
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: (ind) => vy2[ind],
  /**
   * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: (rotation) => rotation & 8 ? rotation & 15 : -rotation & 7,
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {PIXI.GD8Symmetry} Composed operation
   */
  add: (rotationSecond, rotationFirst) => rotationCayley2[rotationSecond][rotationFirst],
  /**
   * Reverse of `add`.
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation
   * @returns {PIXI.GD8Symmetry} Result
   */
  sub: (rotationSecond, rotationFirst) => rotationCayley2[rotationSecond][groupD82.inv(rotationFirst)],
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: (rotation) => rotation ^ 4,
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @param {PIXI.GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: (rotation) => (rotation & 3) === 2,
  // rotation % 4 === 2
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {PIXI.GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: (dx, dy) => Math.abs(dx) * 2 <= Math.abs(dy) ? dy >= 0 ? groupD82.S : groupD82.N : Math.abs(dy) * 2 <= Math.abs(dx) ? dx > 0 ? groupD82.E : groupD82.W : dy > 0 ? dx > 0 ? groupD82.SE : groupD82.SW : dx > 0 ? groupD82.NE : groupD82.NW,
  /**
   * Helps sprite to compensate texture packer rotation.
   * @param {PIXI.Matrix} matrix - sprite world matrix
   * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
    const mat = rotationMatrices2[groupD82.inv(rotation)];
    mat.tx = tx, mat.ty = ty, matrix.append(mat);
  }
};

// ../../node_modules/.pnpm/@pixi+math@7.3.1/node_modules/@pixi/math/lib/ObservablePoint.mjs
var ObservablePoint2 = class _ObservablePoint {
  /**
   * Creates a new `ObservablePoint`
   * @param cb - callback function triggered when `x` and/or `y` are changed
   * @param scope - owner of callback
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(cb2, scope, x3 = 0, y2 = 0) {
    this._x = x3, this._y = y2, this.cb = cb2, this.scope = scope;
  }
  /**
   * Creates a clone of this point.
   * The callback and scope params can be overridden otherwise they will default
   * to the clone object's values.
   * @override
   * @param cb - The callback function triggered when `x` and/or `y` are changed
   * @param scope - The owner of the callback
   * @returns a copy of this observable point
   */
  clone(cb2 = this.cb, scope = this.scope) {
    return new _ObservablePoint(cb2, scope, this._x, this._y);
  }
  /**
   * Sets the point to a new `x` and `y` position.
   * If `y` is omitted, both `x` and `y` will be set to `x`.
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=x] - position of the point on the y axis
   * @returns The observable point instance itself
   */
  set(x3 = 0, y2 = x3) {
    return (this._x !== x3 || this._y !== y2) && (this._x = x3, this._y = y2, this.cb.call(this.scope)), this;
  }
  /**
   * Copies x and y from the given point (`p`)
   * @param p - The point to copy from. Can be any of type that is or extends `IPointData`
   * @returns The observable point instance itself
   */
  copyFrom(p3) {
    return (this._x !== p3.x || this._y !== p3.y) && (this._x = p3.x, this._y = p3.y, this.cb.call(this.scope)), this;
  }
  /**
   * Copies this point's x and y into that of the given point (`p`)
   * @param p - The point to copy to. Can be any of type that is or extends `IPointData`
   * @returns The point (`p`) with values updated
   */
  copyTo(p3) {
    return p3.set(this._x, this._y), p3;
  }
  /**
   * Accepts another point (`p`) and returns `true` if the given point is equal to this point
   * @param p - The point to check
   * @returns Returns `true` if both `x` and `y` are equal
   */
  equals(p3) {
    return p3.x === this._x && p3.y === this._y;
  }
  /** Position of the observable point on the x axis. */
  get x() {
    return this._x;
  }
  set x(value) {
    this._x !== value && (this._x = value, this.cb.call(this.scope));
  }
  /** Position of the observable point on the y axis. */
  get y() {
    return this._y;
  }
  set y(value) {
    this._y !== value && (this._y = value, this.cb.call(this.scope));
  }
};
ObservablePoint2.prototype.toString = function() {
  return `[@pixi/math:ObservablePoint x=${this.x} y=${this.y} scope=${this.scope}]`;
};

// ../../node_modules/.pnpm/@pixi+math@7.3.1/node_modules/@pixi/math/lib/Transform.mjs
var _Transform = class {
  constructor() {
    this.worldTransform = new Matrix2(), this.localTransform = new Matrix2(), this.position = new ObservablePoint2(this.onChange, this, 0, 0), this.scale = new ObservablePoint2(this.onChange, this, 1, 1), this.pivot = new ObservablePoint2(this.onChange, this, 0, 0), this.skew = new ObservablePoint2(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;
  }
  /** Called when a value changes. */
  onChange() {
    this._localID++;
  }
  /** Called when the skew or the rotation changes. */
  updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;
  }
  /** Updates the local transformation matrix. */
  updateLocalTransform() {
    const lt = this.localTransform;
    this._localID !== this._currentLocalID && (lt.a = this._cx * this.scale.x, lt.b = this._sx * this.scale.x, lt.c = this._cy * this.scale.y, lt.d = this._sy * this.scale.y, lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c), lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d), this._currentLocalID = this._localID, this._parentID = -1);
  }
  /**
   * Updates the local and the world transformation matrices.
   * @param parentTransform - The parent transform
   */
  updateTransform(parentTransform) {
    const lt = this.localTransform;
    if (this._localID !== this._currentLocalID && (lt.a = this._cx * this.scale.x, lt.b = this._sx * this.scale.x, lt.c = this._cy * this.scale.y, lt.d = this._sy * this.scale.y, lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c), lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== parentTransform._worldID) {
      const pt = parentTransform.worldTransform, wt = this.worldTransform;
      wt.a = lt.a * pt.a + lt.b * pt.c, wt.b = lt.a * pt.b + lt.b * pt.d, wt.c = lt.c * pt.a + lt.d * pt.c, wt.d = lt.c * pt.b + lt.d * pt.d, wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx, wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty, this._parentID = parentTransform._worldID, this._worldID++;
    }
  }
  /**
   * Decomposes a matrix and sets the transforms properties based on it.
   * @param matrix - The matrix to decompose
   */
  setFromMatrix(matrix) {
    matrix.decompose(this), this._localID++;
  }
  /** The rotation of the object in radians. */
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    this._rotation !== value && (this._rotation = value, this.updateSkew());
  }
};
_Transform.IDENTITY = new _Transform();
var Transform2 = _Transform;
Transform2.prototype.toString = function() {
  return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/defaultProgram.frag.mjs
var defaultFragment = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`;

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/defaultProgram.vert.mjs
var defaultVertex = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`;

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/utils/compileShader.mjs
function compileShader2(gl, type2, src) {
  const shader = gl.createShader(type2);
  return gl.shaderSource(shader, src), gl.compileShader(shader), shader;
}

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/utils/defaultValue.mjs
function booleanArray2(size3) {
  const array = new Array(size3);
  for (let i3 = 0; i3 < array.length; i3++)
    array[i3] = false;
  return array;
}
function defaultValue2(type2, size3) {
  switch (type2) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size3);
    case "vec3":
      return new Float32Array(3 * size3);
    case "vec4":
      return new Float32Array(4 * size3);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size3);
    case "ivec3":
      return new Int32Array(3 * size3);
    case "ivec4":
      return new Int32Array(4 * size3);
    case "uvec2":
      return new Uint32Array(2 * size3);
    case "uvec3":
      return new Uint32Array(3 * size3);
    case "uvec4":
      return new Uint32Array(4 * size3);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray2(2 * size3);
    case "bvec3":
      return booleanArray2(3 * size3);
    case "bvec4":
      return booleanArray2(4 * size3);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/utils/uniformParsers.mjs
var uniformParsers2 = [
  // a float cache layer
  {
    test: (data) => data.type === "float" && data.size === 1 && !data.isArray,
    code: (name) => `
            if(uv["${name}"] !== ud["${name}"].value)
            {
                ud["${name}"].value = uv["${name}"]
                gl.uniform1f(ud["${name}"].location, uv["${name}"])
            }
            `
  },
  // handling samplers
  {
    test: (data, uniform) => (
      // eslint-disable-next-line max-len,no-eq-null,eqeqeq
      (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform.castToBaseTexture !== void 0)
    ),
    code: (name) => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${name}"], t);

            if(ud["${name}"].value !== t)
            {
                ud["${name}"].value = t;
                gl.uniform1i(ud["${name}"].location, t);
; // eslint-disable-line max-len
            }`
  },
  // uploading pixi matrix object to mat3
  {
    test: (data, uniform) => data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== void 0,
    code: (name) => (
      // TODO and some smart caching dirty ids here!
      `
            gl.uniformMatrix3fv(ud["${name}"].location, false, uv["${name}"].toArray(true));
            `
    ),
    codeUbo: (name) => `
                var ${name}_matrix = uv.${name}.toArray(true);

                data[offset] = ${name}_matrix[0];
                data[offset+1] = ${name}_matrix[1];
                data[offset+2] = ${name}_matrix[2];
        
                data[offset + 4] = ${name}_matrix[3];
                data[offset + 5] = ${name}_matrix[4];
                data[offset + 6] = ${name}_matrix[5];
        
                data[offset + 8] = ${name}_matrix[6];
                data[offset + 9] = ${name}_matrix[7];
                data[offset + 10] = ${name}_matrix[8];
            `
  },
  // uploading a pixi point as a vec2 with caching layer
  {
    test: (data, uniform) => data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${name}"].location, v.x, v.y);
                }`,
    codeUbo: (name) => `
                v = uv.${name};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `
  },
  // caching layer for a vec2
  {
    test: (data) => data.type === "vec2" && data.size === 1 && !data.isArray,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${name}"].location, v[0], v[1]);
                }
            `
  },
  // upload a pixi rectangle as a vec4 with caching layer
  {
    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${name}"].location, v.x, v.y, v.width, v.height)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `
  },
  // upload a pixi color as vec4 with caching layer
  {
    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.red !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${name}"].location, v.red, v.green, v.blue, v.alpha)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                    data[offset+3] = v.alpha;
                `
  },
  // upload a pixi color as a vec3 with caching layer
  {
    test: (data, uniform) => data.type === "vec3" && data.size === 1 && !data.isArray && uniform.red !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
    
                    gl.uniform3f(ud["${name}"].location, v.red, v.green, v.blue)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                `
  },
  // a caching layer for vec4 uploading
  {
    test: (data) => data.type === "vec4" && data.size === 1 && !data.isArray,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${name}"].location, v[0], v[1], v[2], v[3])
                }`
  }
];

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.mjs
var GLSL_TO_SINGLE_SETTERS_CACHED2 = {
  float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
  vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
  vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
  vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
  int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
  uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
  uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
  uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
  bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
  bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
};
var GLSL_TO_ARRAY_SETTERS2 = {
  float: "gl.uniform1fv(location, v)",
  vec2: "gl.uniform2fv(location, v)",
  vec3: "gl.uniform3fv(location, v)",
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function generateUniformsSync2(group, uniformData) {
  const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
  for (const i3 in group.uniforms) {
    const data = uniformData[i3];
    if (!data) {
      group.uniforms[i3]?.group === true && (group.uniforms[i3].ubo ? funcFragments.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${i3}, '${i3}');
                    `) : funcFragments.push(`
                        renderer.shader.syncUniformGroup(uv.${i3}, syncData);
                    `));
      continue;
    }
    const uniform = group.uniforms[i3];
    let parsed = false;
    for (let j3 = 0; j3 < uniformParsers2.length; j3++)
      if (uniformParsers2[j3].test(data, uniform)) {
        funcFragments.push(uniformParsers2[j3].code(i3, uniform)), parsed = true;
        break;
      }
    if (!parsed) {
      const template = (data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED2 : GLSL_TO_ARRAY_SETTERS2)[data.type].replace("location", `ud["${i3}"].location`);
      funcFragments.push(`
            cu = ud["${i3}"];
            cv = cu.value;
            v = uv["${i3}"];
            ${template};`);
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join(`
`));
}

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/utils/getTestContext.mjs
var unknownContext2 = {};
var context2 = unknownContext2;
function getTestContext2() {
  if (context2 === unknownContext2 || context2?.isContextLost()) {
    const canvas3 = settings2.ADAPTER.createCanvas();
    let gl;
    settings2.PREFER_ENV >= ENV.WEBGL2 && (gl = canvas3.getContext("webgl2", {})), gl || (gl = canvas3.getContext("webgl", {}) || canvas3.getContext("experimental-webgl", {}), gl ? gl.getExtension("WEBGL_draw_buffers") : gl = null), context2 = gl;
  }
  return context2;
}

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.mjs
var maxFragmentPrecision2;
function getMaxFragmentPrecision2() {
  if (!maxFragmentPrecision2) {
    maxFragmentPrecision2 = PRECISION.MEDIUM;
    const gl = getTestContext2();
    gl && gl.getShaderPrecisionFormat && (maxFragmentPrecision2 = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision ? PRECISION.HIGH : PRECISION.MEDIUM);
  }
  return maxFragmentPrecision2;
}

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/utils/logProgramError.mjs
function logPrettyShaderError2(gl, shader) {
  const shaderSrc = gl.getShaderSource(shader).split(`
`).map((line, index) => `${index}: ${line}`), shaderLog = gl.getShaderInfoLog(shader), splitShader = shaderLog.split(`
`), dedupe = {}, lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n2) => n2 && !dedupe[n2] ? (dedupe[n2] = true, true) : false), logArgs = [""];
  lineNumbers.forEach((number) => {
    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`, logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  const fragmentSourceToLog = shaderSrc.join(`
`);
  logArgs[0] = fragmentSourceToLog, console.error(shaderLog), console.groupCollapsed("click to view full shader code"), console.warn(...logArgs), console.groupEnd();
}
function logProgramError2(gl, program, vertexShader, fragmentShader) {
  gl.getProgramParameter(program, gl.LINK_STATUS) || (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) || logPrettyShaderError2(gl, vertexShader), gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) || logPrettyShaderError2(gl, fragmentShader), console.error("PixiJS Error: Could not initialize shader."), gl.getProgramInfoLog(program) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program)));
}

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/utils/mapSize.mjs
var GLSL_TO_SIZE2 = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize2(type2) {
  return GLSL_TO_SIZE2[type2];
}

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/utils/mapType.mjs
var GL_TABLE2 = null;
var GL_TO_GLSL_TYPES2 = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function mapType2(gl, type2) {
  if (!GL_TABLE2) {
    const typeNames = Object.keys(GL_TO_GLSL_TYPES2);
    GL_TABLE2 = {};
    for (let i3 = 0; i3 < typeNames.length; ++i3) {
      const tn = typeNames[i3];
      GL_TABLE2[gl[tn]] = GL_TO_GLSL_TYPES2[tn];
    }
  }
  return GL_TABLE2[type2];
}

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/utils/setPrecision.mjs
function setPrecision(src, requestedPrecision, maxSupportedPrecision) {
  if (src.substring(0, 9) !== "precision") {
    let precision = requestedPrecision;
    return requestedPrecision === PRECISION.HIGH && maxSupportedPrecision !== PRECISION.HIGH && (precision = PRECISION.MEDIUM), `precision ${precision} float;
${src}`;
  } else if (maxSupportedPrecision !== PRECISION.HIGH && src.substring(0, 15) === "precision highp")
    return src.replace("precision highp", "precision mediump");
  return src;
}

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.mjs
var unsafeEval2;
function unsafeEvalSupported2() {
  if (typeof unsafeEval2 == "boolean")
    return unsafeEval2;
  try {
    unsafeEval2 = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({ a: "b" }, "a", "b") === true;
  } catch {
    unsafeEval2 = false;
  }
  return unsafeEval2;
}

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/Program.mjs
var UID3 = 0;
var nameCache = {};
var _Program = class _Program2 {
  /**
   * @param vertexSrc - The source of the vertex shader.
   * @param fragmentSrc - The source of the fragment shader.
   * @param name - Name for shader
   * @param extra - Extra data for shader
   */
  constructor(vertexSrc, fragmentSrc, name = "pixi-shader", extra = {}) {
    this.extra = {}, this.id = UID3++, this.vertexSrc = vertexSrc || _Program2.defaultVertexSrc, this.fragmentSrc = fragmentSrc || _Program2.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.extra = extra, this.vertexSrc.substring(0, 8) !== "#version" && (name = name.replace(/\s+/g, "-"), nameCache[name] ? (nameCache[name]++, name += `-${nameCache[name]}`) : nameCache[name] = 1, this.vertexSrc = `#define SHADER_NAME ${name}
${this.vertexSrc}`, this.fragmentSrc = `#define SHADER_NAME ${name}
${this.fragmentSrc}`, this.vertexSrc = setPrecision(
      this.vertexSrc,
      _Program2.defaultVertexPrecision,
      PRECISION.HIGH
    ), this.fragmentSrc = setPrecision(
      this.fragmentSrc,
      _Program2.defaultFragmentPrecision,
      getMaxFragmentPrecision2()
    )), this.glPrograms = {}, this.syncUniforms = null;
  }
  /**
   * The default vertex shader source.
   * @readonly
   */
  static get defaultVertexSrc() {
    return defaultVertex;
  }
  /**
   * The default fragment shader source.
   * @readonly
   */
  static get defaultFragmentSrc() {
    return defaultFragment;
  }
  /**
   * A short hand function to create a program based of a vertex and fragment shader.
   *
   * This method will also check to see if there is a cached program.
   * @param vertexSrc - The source of the vertex shader.
   * @param fragmentSrc - The source of the fragment shader.
   * @param name - Name for shader
   * @returns A shiny new PixiJS shader program!
   */
  static from(vertexSrc, fragmentSrc, name) {
    const key2 = vertexSrc + fragmentSrc;
    let program = ProgramCache[key2];
    return program || (ProgramCache[key2] = program = new _Program2(vertexSrc, fragmentSrc, name)), program;
  }
};
_Program.defaultVertexPrecision = PRECISION.HIGH, /**
* Default specify float precision in fragment shader.
* iOS is best set at highp due to https://github.com/pixijs/pixijs/issues/3742
* @static
* @type {PIXI.PRECISION}
* @default PIXI.PRECISION.MEDIUM
*/
_Program.defaultFragmentPrecision = isMobile3.apple.device ? PRECISION.HIGH : PRECISION.MEDIUM;
var Program = _Program;

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/UniformGroup.mjs
var UID4 = 0;
var UniformGroup2 = class _UniformGroup3 {
  /**
   * @param {object | Buffer} [uniforms] - Custom uniforms to use to augment the built-in ones. Or a pixi buffer.
   * @param isStatic - Uniforms wont be changed after creation.
   * @param isUbo - If true, will treat this uniform group as a uniform buffer object.
   */
  constructor(uniforms, isStatic, isUbo) {
    this.group = true, this.syncUniforms = {}, this.dirtyId = 0, this.id = UID4++, this.static = !!isStatic, this.ubo = !!isUbo, uniforms instanceof Buffer3 ? (this.buffer = uniforms, this.buffer.type = BUFFER_TYPE2.UNIFORM_BUFFER, this.autoManage = false, this.ubo = true) : (this.uniforms = uniforms, this.ubo && (this.buffer = new Buffer3(new Float32Array(1)), this.buffer.type = BUFFER_TYPE2.UNIFORM_BUFFER, this.autoManage = true));
  }
  update() {
    this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();
  }
  add(name, uniforms, _static) {
    if (!this.ubo)
      this.uniforms[name] = new _UniformGroup3(uniforms, _static);
    else
      throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
  }
  static from(uniforms, _static, _ubo) {
    return new _UniformGroup3(uniforms, _static, _ubo);
  }
  /**
   * A short hand function for creating a static UBO UniformGroup.
   * @param uniforms - the ubo item
   * @param _static - should this be updated each time it is used? defaults to true here!
   */
  static uboFrom(uniforms, _static) {
    return new _UniformGroup3(uniforms, _static ?? true, true);
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/Shader.mjs
var Shader2 = class _Shader {
  /**
   * @param program - The program the shader will use.
   * @param uniforms - Custom uniforms to use to augment the built-in ones.
   */
  constructor(program, uniforms) {
    this.uniformBindCount = 0, this.program = program, uniforms ? uniforms instanceof UniformGroup2 ? this.uniformGroup = uniforms : this.uniformGroup = new UniformGroup2(uniforms) : this.uniformGroup = new UniformGroup2({}), this.disposeRunner = new Runner("disposeShader");
  }
  // TODO move to shader system..
  checkUniformExists(name, group) {
    if (group.uniforms[name])
      return true;
    for (const i3 in group.uniforms) {
      const uniform = group.uniforms[i3];
      if (uniform.group === true && this.checkUniformExists(name, uniform))
        return true;
    }
    return false;
  }
  destroy() {
    this.uniformGroup = null, this.disposeRunner.emit(this), this.disposeRunner.destroy();
  }
  /**
   * Shader uniform values, shortcut for `uniformGroup.uniforms`.
   * @readonly
   */
  get uniforms() {
    return this.uniformGroup.uniforms;
  }
  /**
   * A short hand function to create a shader based of a vertex and fragment shader.
   * @param vertexSrc - The source of the vertex shader.
   * @param fragmentSrc - The source of the fragment shader.
   * @param uniforms - Custom uniforms to use to augment the built-in ones.
   * @returns A shiny new PixiJS shader!
   */
  static from(vertexSrc, fragmentSrc, uniforms) {
    const program = Program.from(vertexSrc, fragmentSrc);
    return new _Shader(program, uniforms);
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/batch/BatchShaderGenerator.mjs
var BatchShaderGenerator = class {
  /**
   * @param vertexSrc - Vertex shader
   * @param fragTemplate - Fragment shader template
   */
  constructor(vertexSrc, fragTemplate2) {
    if (this.vertexSrc = vertexSrc, this.fragTemplate = fragTemplate2, this.programCache = {}, this.defaultGroupCache = {}, !fragTemplate2.includes("%count%"))
      throw new Error('Fragment template must contain "%count%".');
    if (!fragTemplate2.includes("%forloop%"))
      throw new Error('Fragment template must contain "%forloop%".');
  }
  generateShader(maxTextures) {
    if (!this.programCache[maxTextures]) {
      const sampleValues2 = new Int32Array(maxTextures);
      for (let i3 = 0; i3 < maxTextures; i3++)
        sampleValues2[i3] = i3;
      this.defaultGroupCache[maxTextures] = UniformGroup2.from({ uSamplers: sampleValues2 }, true);
      let fragmentSrc = this.fragTemplate;
      fragmentSrc = fragmentSrc.replace(/%count%/gi, `${maxTextures}`), fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures)), this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);
    }
    const uniforms = {
      tint: new Float32Array([1, 1, 1, 1]),
      translationMatrix: new Matrix2(),
      default: this.defaultGroupCache[maxTextures]
    };
    return new Shader2(this.programCache[maxTextures], uniforms);
  }
  generateSampleSrc(maxTextures) {
    let src = "";
    src += `
`, src += `
`;
    for (let i3 = 0; i3 < maxTextures; i3++)
      i3 > 0 && (src += `
else `), i3 < maxTextures - 1 && (src += `if(vTextureId < ${i3}.5)`), src += `
{`, src += `
	color = texture2D(uSamplers[${i3}], vTextureCoord);`, src += `
}`;
    return src += `
`, src += `
`, src;
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/batch/BatchTextureArray.mjs
var BatchTextureArray2 = class {
  constructor() {
    this.elements = [], this.ids = [], this.count = 0;
  }
  clear() {
    for (let i3 = 0; i3 < this.count; i3++)
      this.elements[i3] = null;
    this.count = 0;
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/batch/canUploadSameBuffer.mjs
function canUploadSameBuffer() {
  return !isMobile3.apple.device;
}

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/batch/maxRecommendedTextures.mjs
function maxRecommendedTextures(max) {
  let allowMax = true;
  const navigator2 = settings2.ADAPTER.getNavigator();
  if (isMobile3.tablet || isMobile3.phone) {
    if (isMobile3.apple.device) {
      const match = navigator2.userAgent.match(/OS (\d+)_(\d+)?/);
      match && parseInt(match[1], 10) < 11 && (allowMax = false);
    }
    if (isMobile3.android.device) {
      const match = navigator2.userAgent.match(/Android\s([0-9.]*)/);
      match && parseInt(match[1], 10) < 7 && (allowMax = false);
    }
  }
  return allowMax ? max : 4;
}

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/batch/ObjectRenderer.mjs
var ObjectRenderer = class {
  /**
   * @param renderer - The renderer this manager works for.
   */
  constructor(renderer) {
    this.renderer = renderer;
  }
  /** Stub method that should be used to empty the current batch by rendering objects now. */
  flush() {
  }
  /** Generic destruction method that frees all resources. This should be called by subclasses. */
  destroy() {
    this.renderer = null;
  }
  /**
   * Stub method that initializes any state required before
   * rendering starts. It is different from the `prerender`
   * signal, which occurs every frame, in that it is called
   * whenever an object requests _this_ renderer specifically.
   */
  start() {
  }
  /** Stops the renderer. It should free up any state and become dormant. */
  stop() {
    this.flush();
  }
  /**
   * Keeps the object to render. It doesn't have to be
   * rendered immediately.
   * @param {PIXI.DisplayObject} _object - The object to render.
   */
  render(_object) {
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/batch/texture.frag.mjs
var defaultFragment2 = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`;

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/batch/texture.vert.mjs
var defaultVertex2 = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`;

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/batch/BatchRenderer.mjs
var _BatchRenderer = class _BatchRenderer2 extends ObjectRenderer {
  /**
   * This will hook onto the renderer's `contextChange`
   * and `prerender` signals.
   * @param {PIXI.Renderer} renderer - The renderer this works for.
   */
  constructor(renderer) {
    super(renderer), this.setShaderGenerator(), this.geometryClass = BatchGeometry2, this.vertexSize = 6, this.state = State2.for2d(), this.size = _BatchRenderer2.defaultBatchSize * 4, this._vertexCount = 0, this._indexCount = 0, this._bufferedElements = [], this._bufferedTextures = [], this._bufferSize = 0, this._shader = null, this._packedGeometries = [], this._packedGeometryPoolSize = 2, this._flushId = 0, this._aBuffers = {}, this._iBuffers = {}, this.maxTextures = 1, this.renderer.on("prerender", this.onPrerender, this), renderer.runners.contextChange.add(this), this._dcIndex = 0, this._aIndex = 0, this._iIndex = 0, this._attributeBuffer = null, this._indexBuffer = null, this._tempBoundTextures = [];
  }
  /**
   * The maximum textures that this device supports.
   * @static
   * @default 32
   */
  static get defaultMaxTextures() {
    return this._defaultMaxTextures = this._defaultMaxTextures ?? maxRecommendedTextures(32), this._defaultMaxTextures;
  }
  static set defaultMaxTextures(value) {
    this._defaultMaxTextures = value;
  }
  /**
   * Can we upload the same buffer in a single frame?
   * @static
   */
  static get canUploadSameBuffer() {
    return this._canUploadSameBuffer = this._canUploadSameBuffer ?? canUploadSameBuffer(), this._canUploadSameBuffer;
  }
  static set canUploadSameBuffer(value) {
    this._canUploadSameBuffer = value;
  }
  /**
   * @see PIXI.BatchRenderer#maxTextures
   * @deprecated since 7.1.0
   * @readonly
   */
  get MAX_TEXTURES() {
    return deprecation2("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures"), this.maxTextures;
  }
  /**
   * The default vertex shader source
   * @readonly
   */
  static get defaultVertexSrc() {
    return defaultVertex2;
  }
  /**
   * The default fragment shader source
   * @readonly
   */
  static get defaultFragmentTemplate() {
    return defaultFragment2;
  }
  /**
   * Set the shader generator.
   * @param {object} [options]
   * @param {string} [options.vertex=PIXI.BatchRenderer.defaultVertexSrc] - Vertex shader source
   * @param {string} [options.fragment=PIXI.BatchRenderer.defaultFragmentTemplate] - Fragment shader template
   */
  setShaderGenerator({
    vertex: vertex3 = _BatchRenderer2.defaultVertexSrc,
    fragment: fragment3 = _BatchRenderer2.defaultFragmentTemplate
  } = {}) {
    this.shaderGenerator = new BatchShaderGenerator(vertex3, fragment3);
  }
  /**
   * Handles the `contextChange` signal.
   *
   * It calculates `this.maxTextures` and allocating the packed-geometry object pool.
   */
  contextChange() {
    const gl = this.renderer.gl;
    settings2.PREFER_ENV === ENV.WEBGL_LEGACY ? this.maxTextures = 1 : (this.maxTextures = Math.min(
      gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),
      _BatchRenderer2.defaultMaxTextures
    ), this.maxTextures = checkMaxIfStatementsInShader(
      this.maxTextures,
      gl
    )), this._shader = this.shaderGenerator.generateShader(this.maxTextures);
    for (let i3 = 0; i3 < this._packedGeometryPoolSize; i3++)
      this._packedGeometries[i3] = new this.geometryClass();
    this.initFlushBuffers();
  }
  /** Makes sure that static and dynamic flush pooled objects have correct dimensions. */
  initFlushBuffers() {
    const {
      _drawCallPool,
      _textureArrayPool
    } = _BatchRenderer2, MAX_SPRITES = this.size / 4, MAX_TA = Math.floor(MAX_SPRITES / this.maxTextures) + 1;
    for (; _drawCallPool.length < MAX_SPRITES; )
      _drawCallPool.push(new BatchDrawCall());
    for (; _textureArrayPool.length < MAX_TA; )
      _textureArrayPool.push(new BatchTextureArray2());
    for (let i3 = 0; i3 < this.maxTextures; i3++)
      this._tempBoundTextures[i3] = null;
  }
  /** Handles the `prerender` signal. It ensures that flushes start from the first geometry object again. */
  onPrerender() {
    this._flushId = 0;
  }
  /**
   * Buffers the "batchable" object. It need not be rendered immediately.
   * @param {PIXI.DisplayObject} element - the element to render when
   *    using this renderer
   */
  render(element) {
    element._texture.valid && (this._vertexCount + element.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += element.vertexData.length / 2, this._indexCount += element.indices.length, this._bufferedTextures[this._bufferSize] = element._texture.baseTexture, this._bufferedElements[this._bufferSize++] = element);
  }
  buildTexturesAndDrawCalls() {
    const {
      _bufferedTextures: textures,
      maxTextures
    } = this, textureArrays = _BatchRenderer2._textureArrayPool, batch = this.renderer.batch, boundTextures = this._tempBoundTextures, touch = this.renderer.textureGC.count;
    let TICK = ++BaseTexture._globalBatch, countTexArrays = 0, texArray = textureArrays[0], start = 0;
    batch.copyBoundTextures(boundTextures, maxTextures);
    for (let i3 = 0; i3 < this._bufferSize; ++i3) {
      const tex = textures[i3];
      textures[i3] = null, tex._batchEnabled !== TICK && (texArray.count >= maxTextures && (batch.boundArray(texArray, boundTextures, TICK, maxTextures), this.buildDrawCalls(texArray, start, i3), start = i3, texArray = textureArrays[++countTexArrays], ++TICK), tex._batchEnabled = TICK, tex.touched = touch, texArray.elements[texArray.count++] = tex);
    }
    texArray.count > 0 && (batch.boundArray(texArray, boundTextures, TICK, maxTextures), this.buildDrawCalls(texArray, start, this._bufferSize), ++countTexArrays, ++TICK);
    for (let i3 = 0; i3 < boundTextures.length; i3++)
      boundTextures[i3] = null;
    BaseTexture._globalBatch = TICK;
  }
  /**
   * Populating drawcalls for rendering
   * @param texArray
   * @param start
   * @param finish
   */
  buildDrawCalls(texArray, start, finish) {
    const {
      _bufferedElements: elements,
      _attributeBuffer,
      _indexBuffer,
      vertexSize
    } = this, drawCalls = _BatchRenderer2._drawCallPool;
    let dcIndex = this._dcIndex, aIndex = this._aIndex, iIndex = this._iIndex, drawCall = drawCalls[dcIndex];
    drawCall.start = this._iIndex, drawCall.texArray = texArray;
    for (let i3 = start; i3 < finish; ++i3) {
      const sprite = elements[i3], tex = sprite._texture.baseTexture, spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
      elements[i3] = null, start < i3 && drawCall.blend !== spriteBlendMode && (drawCall.size = iIndex - drawCall.start, start = i3, drawCall = drawCalls[++dcIndex], drawCall.texArray = texArray, drawCall.start = iIndex), this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex), aIndex += sprite.vertexData.length / 2 * vertexSize, iIndex += sprite.indices.length, drawCall.blend = spriteBlendMode;
    }
    start < finish && (drawCall.size = iIndex - drawCall.start, ++dcIndex), this._dcIndex = dcIndex, this._aIndex = aIndex, this._iIndex = iIndex;
  }
  /**
   * Bind textures for current rendering
   * @param texArray
   */
  bindAndClearTexArray(texArray) {
    const textureSystem = this.renderer.texture;
    for (let j3 = 0; j3 < texArray.count; j3++)
      textureSystem.bind(texArray.elements[j3], texArray.ids[j3]), texArray.elements[j3] = null;
    texArray.count = 0;
  }
  updateGeometry() {
    const {
      _packedGeometries: packedGeometries,
      _attributeBuffer: attributeBuffer,
      _indexBuffer: indexBuffer
    } = this;
    _BatchRenderer2.canUploadSameBuffer ? (packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData), packedGeometries[this._flushId]._indexBuffer.update(indexBuffer), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, packedGeometries[this._flushId] = new this.geometryClass()), packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData), packedGeometries[this._flushId]._indexBuffer.update(indexBuffer), this.renderer.geometry.bind(packedGeometries[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);
  }
  drawBatches() {
    const dcCount = this._dcIndex, { gl, state: stateSystem } = this.renderer, drawCalls = _BatchRenderer2._drawCallPool;
    let curTexArray = null;
    for (let i3 = 0; i3 < dcCount; i3++) {
      const { texArray, type: type2, size: size3, start, blend } = drawCalls[i3];
      curTexArray !== texArray && (curTexArray = texArray, this.bindAndClearTexArray(texArray)), this.state.blendMode = blend, stateSystem.set(this.state), gl.drawElements(type2, size3, gl.UNSIGNED_SHORT, start * 2);
    }
  }
  /** Renders the content _now_ and empties the current batch. */
  flush() {
    this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);
  }
  /** Starts a new sprite batch. */
  start() {
    this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.maxTextures), this.renderer.shader.bind(this._shader), _BatchRenderer2.canUploadSameBuffer && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
  }
  /** Stops and flushes the current batch. */
  stop() {
    this.flush();
  }
  /** Destroys this `BatchRenderer`. It cannot be used again. */
  destroy() {
    for (let i3 = 0; i3 < this._packedGeometryPoolSize; i3++)
      this._packedGeometries[i3] && this._packedGeometries[i3].destroy();
    this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), super.destroy();
  }
  /**
   * Fetches an attribute buffer from `this._aBuffers` that can hold atleast `size` floats.
   * @param size - minimum capacity required
   * @returns - buffer than can hold atleast `size` floats
   */
  getAttributeBuffer(size3) {
    const roundedP2 = nextPow22(Math.ceil(size3 / 8)), roundedSizeIndex = log2(roundedP2), roundedSize = roundedP2 * 8;
    this._aBuffers.length <= roundedSizeIndex && (this._iBuffers.length = roundedSizeIndex + 1);
    let buffer2 = this._aBuffers[roundedSize];
    return buffer2 || (this._aBuffers[roundedSize] = buffer2 = new ViewableBuffer2(roundedSize * this.vertexSize * 4)), buffer2;
  }
  /**
   * Fetches an index buffer from `this._iBuffers` that can
   * have at least `size` capacity.
   * @param size - minimum required capacity
   * @returns - buffer that can fit `size` indices.
   */
  getIndexBuffer(size3) {
    const roundedP2 = nextPow22(Math.ceil(size3 / 12)), roundedSizeIndex = log2(roundedP2), roundedSize = roundedP2 * 12;
    this._iBuffers.length <= roundedSizeIndex && (this._iBuffers.length = roundedSizeIndex + 1);
    let buffer2 = this._iBuffers[roundedSizeIndex];
    return buffer2 || (this._iBuffers[roundedSizeIndex] = buffer2 = new Uint16Array(roundedSize)), buffer2;
  }
  /**
   * Takes the four batching parameters of `element`, interleaves
   * and pushes them into the batching attribute/index buffers given.
   *
   * It uses these properties: `vertexData` `uvs`, `textureId` and
   * `indicies`. It also uses the "tint" of the base-texture, if
   * present.
   * @param {PIXI.DisplayObject} element - element being rendered
   * @param attributeBuffer - attribute buffer.
   * @param indexBuffer - index buffer
   * @param aIndex - number of floats already in the attribute buffer
   * @param iIndex - number of indices already in `indexBuffer`
   */
  packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
    const {
      uint32View,
      float32View
    } = attributeBuffer, packedVertices = aIndex / this.vertexSize, uvs = element.uvs, indicies = element.indices, vertexData = element.vertexData, textureId = element._texture.baseTexture._batchLocation, alpha = Math.min(element.worldAlpha, 1), argb = Color2.shared.setValue(element._tintRGB).toPremultiplied(alpha, element._texture.baseTexture.alphaMode > 0);
    for (let i3 = 0; i3 < vertexData.length; i3 += 2)
      float32View[aIndex++] = vertexData[i3], float32View[aIndex++] = vertexData[i3 + 1], float32View[aIndex++] = uvs[i3], float32View[aIndex++] = uvs[i3 + 1], uint32View[aIndex++] = argb, float32View[aIndex++] = textureId;
    for (let i3 = 0; i3 < indicies.length; i3++)
      indexBuffer[iIndex++] = packedVertices + indicies[i3];
  }
};
_BatchRenderer.defaultBatchSize = 4096, /** @ignore */
_BatchRenderer.extension = {
  name: "batch",
  type: ExtensionType2.RendererPlugin
}, /**
* Pool of `BatchDrawCall` objects that `flush` used
* to create "batches" of the objects being rendered.
*
* These are never re-allocated again.
* Shared between all batch renderers because it can be only one "flush" working at the moment.
* @member {PIXI.BatchDrawCall[]}
*/
_BatchRenderer._drawCallPool = [], /**
* Pool of `BatchDrawCall` objects that `flush` used
* to create "batches" of the objects being rendered.
*
* These are never re-allocated again.
* Shared between all batch renderers because it can be only one "flush" working at the moment.
* @member {PIXI.BatchTextureArray[]}
*/
_BatchRenderer._textureArrayPool = [];
var BatchRenderer = _BatchRenderer;
extensions2.add(BatchRenderer);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/filters/defaultFilter.frag.mjs
var defaultFragment3 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`;

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/filters/defaultFilter.vert.mjs
var defaultVertex3 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/filters/Filter.mjs
var _Filter2 = class _Filter22 extends Shader2 {
  /**
   * @param vertexSrc - The source of the vertex shader.
   * @param fragmentSrc - The source of the fragment shader.
   * @param uniforms - Custom uniforms to use to augment the built-in ones.
   */
  constructor(vertexSrc, fragmentSrc, uniforms) {
    const program = Program.from(
      vertexSrc || _Filter22.defaultVertexSrc,
      fragmentSrc || _Filter22.defaultFragmentSrc
    );
    super(program, uniforms), this.padding = 0, this.resolution = _Filter22.defaultResolution, this.multisample = _Filter22.defaultMultisample, this.enabled = true, this.autoFit = true, this.state = new State2();
  }
  /**
   * Applies the filter
   * @param {PIXI.FilterSystem} filterManager - The renderer to retrieve the filter from
   * @param {PIXI.RenderTexture} input - The input render target.
   * @param {PIXI.RenderTexture} output - The target to output to.
   * @param {PIXI.CLEAR_MODES} [clearMode] - Should the output be cleared before rendering to it.
   * @param {object} [_currentState] - It's current state of filter.
   *        There are some useful properties in the currentState :
   *        target, filters, sourceFrame, destinationFrame, renderTarget, resolution
   */
  apply(filterManager, input, output, clearMode, _currentState) {
    filterManager.applyFilter(this, input, output, clearMode);
  }
  /**
   * Sets the blend mode of the filter.
   * @default PIXI.BLEND_MODES.NORMAL
   */
  get blendMode() {
    return this.state.blendMode;
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  /**
   * The resolution of the filter. Setting this to be lower will lower the quality but
   * increase the performance of the filter.
   * If set to `null` or `0`, the resolution of the current render target is used.
   * @default PIXI.Filter.defaultResolution
   */
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._resolution = value;
  }
  /**
   * The default vertex shader source
   * @readonly
   */
  static get defaultVertexSrc() {
    return defaultVertex3;
  }
  /**
   * The default fragment shader source
   * @readonly
   */
  static get defaultFragmentSrc() {
    return defaultFragment3;
  }
};
_Filter2.defaultResolution = 1, /**
* Default filter samples for any filter.
* @static
* @type {PIXI.MSAA_QUALITY|null}
* @default PIXI.MSAA_QUALITY.NONE
*/
_Filter2.defaultMultisample = MSAA_QUALITY.NONE;
var Filter2 = _Filter2;

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/background/BackgroundSystem.mjs
var BackgroundSystem2 = class {
  constructor() {
    this.clearBeforeRender = true, this._backgroundColor = new Color2(0), this.alpha = 1;
  }
  /**
   * initiates the background system
   * @param {PIXI.IRendererOptions} options - the options for the background colors
   */
  init(options) {
    this.clearBeforeRender = options.clearBeforeRender;
    const { backgroundColor, background, backgroundAlpha } = options, color = background ?? backgroundColor;
    color !== void 0 && (this.color = color), this.alpha = backgroundAlpha;
  }
  /**
   * The background color to fill if not transparent.
   * @member {PIXI.ColorSource}
   */
  get color() {
    return this._backgroundColor.value;
  }
  set color(value) {
    this._backgroundColor.setValue(value);
  }
  /**
   * The background color alpha. Setting this to 0 will make the canvas transparent.
   * @member {number}
   */
  get alpha() {
    return this._backgroundColor.alpha;
  }
  set alpha(value) {
    this._backgroundColor.setAlpha(value);
  }
  /** The background color object. */
  get backgroundColor() {
    return this._backgroundColor;
  }
  destroy() {
  }
};
BackgroundSystem2.defaultOptions = {
  /**
   * {@link PIXI.IRendererOptions.backgroundAlpha}
   * @default 1
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  backgroundAlpha: 1,
  /**
   * {@link PIXI.IRendererOptions.backgroundColor}
   * @default 0x000000
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  backgroundColor: 0,
  /**
   * {@link PIXI.IRendererOptions.clearBeforeRender}
   * @default true
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  clearBeforeRender: true
}, /** @ignore */
BackgroundSystem2.extension = {
  type: [
    ExtensionType2.RendererSystem,
    ExtensionType2.CanvasRendererSystem
  ],
  name: "background"
};
extensions2.add(BackgroundSystem2);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/batch/BatchSystem.mjs
var BatchSystem = class {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.emptyRenderer = new ObjectRenderer(renderer), this.currentRenderer = this.emptyRenderer;
  }
  /**
   * Changes the current renderer to the one given in parameter
   * @param objectRenderer - The object renderer to use.
   */
  setObjectRenderer(objectRenderer) {
    this.currentRenderer !== objectRenderer && (this.currentRenderer.stop(), this.currentRenderer = objectRenderer, this.currentRenderer.start());
  }
  /**
   * This should be called if you wish to do some custom rendering
   * It will basically render anything that may be batched up such as sprites
   */
  flush() {
    this.setObjectRenderer(this.emptyRenderer);
  }
  /** Reset the system to an empty renderer */
  reset() {
    this.setObjectRenderer(this.emptyRenderer);
  }
  /**
   * Handy function for batch renderers: copies bound textures in first maxTextures locations to array
   * sets actual _batchLocation for them
   * @param arr - arr copy destination
   * @param maxTextures - number of copied elements
   */
  copyBoundTextures(arr, maxTextures) {
    const { boundTextures } = this.renderer.texture;
    for (let i3 = maxTextures - 1; i3 >= 0; --i3)
      arr[i3] = boundTextures[i3] || null, arr[i3] && (arr[i3]._batchLocation = i3);
  }
  /**
   * Assigns batch locations to textures in array based on boundTextures state.
   * All textures in texArray should have `_batchEnabled = _batchId`,
   * and their count should be less than `maxTextures`.
   * @param texArray - textures to bound
   * @param boundTextures - current state of bound textures
   * @param batchId - marker for _batchEnabled param of textures in texArray
   * @param maxTextures - number of texture locations to manipulate
   */
  boundArray(texArray, boundTextures, batchId, maxTextures) {
    const { elements, ids, count: count2 } = texArray;
    let j3 = 0;
    for (let i3 = 0; i3 < count2; i3++) {
      const tex = elements[i3], loc = tex._batchLocation;
      if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
        ids[i3] = loc;
        continue;
      }
      for (; j3 < maxTextures; ) {
        const bound = boundTextures[j3];
        if (bound && bound._batchEnabled === batchId && bound._batchLocation === j3) {
          j3++;
          continue;
        }
        ids[i3] = j3, tex._batchLocation = j3, boundTextures[j3] = tex;
        break;
      }
    }
  }
  /**
   * @ignore
   */
  destroy() {
    this.renderer = null;
  }
};
BatchSystem.extension = {
  type: ExtensionType2.RendererSystem,
  name: "batch"
};
extensions2.add(BatchSystem);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/context/ContextSystem.mjs
var CONTEXT_UID_COUNTER = 0;
var ContextSystem = class {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    this.renderer = renderer, this.webGLVersion = 1, this.extensions = {}, this.supports = {
      uint32Indices: false
    }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this);
  }
  /**
   * `true` if the context is lost
   * @readonly
   */
  get isLost() {
    return !this.gl || this.gl.isContextLost();
  }
  /**
   * Handles the context change event.
   * @param {WebGLRenderingContext} gl - New WebGL context.
   */
  contextChange(gl) {
    this.gl = gl, this.renderer.gl = gl, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
  }
  init(options) {
    if (options.context)
      this.initFromContext(options.context);
    else {
      const alpha = this.renderer.background.alpha < 1, premultipliedAlpha = options.premultipliedAlpha;
      this.preserveDrawingBuffer = options.preserveDrawingBuffer, this.useContextAlpha = options.useContextAlpha, this.powerPreference = options.powerPreference, this.initFromOptions({
        alpha,
        premultipliedAlpha,
        antialias: options.antialias,
        stencil: true,
        preserveDrawingBuffer: options.preserveDrawingBuffer,
        powerPreference: options.powerPreference
      });
    }
  }
  /**
   * Initializes the context.
   * @protected
   * @param {WebGLRenderingContext} gl - WebGL context
   */
  initFromContext(gl) {
    this.gl = gl, this.validateContext(gl), this.renderer.gl = gl, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++, this.renderer.runners.contextChange.emit(gl);
    const view = this.renderer.view;
    view.addEventListener !== void 0 && (view.addEventListener("webglcontextlost", this.handleContextLost, false), view.addEventListener("webglcontextrestored", this.handleContextRestored, false));
  }
  /**
   * Initialize from context options
   * @protected
   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
   * @param {object} options - context attributes
   */
  initFromOptions(options) {
    const gl = this.createContext(this.renderer.view, options);
    this.initFromContext(gl);
  }
  /**
   * Helper class to create a WebGL Context
   * @param canvas - the canvas element that we will get the context from
   * @param options - An options object that gets passed in to the canvas element containing the
   *    context attributes
   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
   * @returns {WebGLRenderingContext} the WebGL context
   */
  createContext(canvas3, options) {
    let gl;
    if (settings2.PREFER_ENV >= ENV.WEBGL2 && (gl = canvas3.getContext("webgl2", options)), gl)
      this.webGLVersion = 2;
    else if (this.webGLVersion = 1, gl = canvas3.getContext("webgl", options) || canvas3.getContext("experimental-webgl", options), !gl)
      throw new Error("This browser does not support WebGL. Try using the canvas renderer");
    return this.gl = gl, this.getExtensions(), this.gl;
  }
  /** Auto-populate the {@link PIXI.ContextSystem.extensions extensions}. */
  getExtensions() {
    const { gl } = this, common = {
      loseContext: gl.getExtension("WEBGL_lose_context"),
      anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
      s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      // eslint-disable-line camelcase
      etc: gl.getExtension("WEBGL_compressed_texture_etc"),
      etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: gl.getExtension("WEBGL_compressed_texture_atc"),
      astc: gl.getExtension("WEBGL_compressed_texture_astc")
    };
    this.webGLVersion === 1 ? Object.assign(this.extensions, common, {
      drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
      depthTexture: gl.getExtension("WEBGL_depth_texture"),
      vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
      uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
      // Floats and half-floats
      floatTexture: gl.getExtension("OES_texture_float"),
      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
      textureHalfFloat: gl.getExtension("OES_texture_half_float"),
      textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
    }) : this.webGLVersion === 2 && Object.assign(this.extensions, common, {
      // Floats and half-floats
      colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
    });
  }
  /**
   * Handles a lost webgl context
   * @param {WebGLContextEvent} event - The context lost event.
   */
  handleContextLost(event) {
    event.preventDefault(), setTimeout(() => {
      this.gl.isContextLost() && this.extensions.loseContext && this.extensions.loseContext.restoreContext();
    }, 0);
  }
  /** Handles a restored webgl context. */
  handleContextRestored() {
    this.renderer.runners.contextChange.emit(this.gl);
  }
  destroy() {
    const view = this.renderer.view;
    this.renderer = null, view.removeEventListener !== void 0 && (view.removeEventListener("webglcontextlost", this.handleContextLost), view.removeEventListener("webglcontextrestored", this.handleContextRestored)), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();
  }
  /** Handle the post-render runner event. */
  postrender() {
    this.renderer.objectRenderer.renderingToScreen && this.gl.flush();
  }
  /**
   * Validate context.
   * @param {WebGLRenderingContext} gl - Render context.
   */
  validateContext(gl) {
    const attributes = gl.getContextAttributes(), isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
    isWebGl2 && (this.webGLVersion = 2), attributes && !attributes.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
    const hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
    this.supports.uint32Indices = hasuint32, hasuint32 || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
  }
};
ContextSystem.defaultOptions = {
  /**
   * {@link PIXI.IRendererOptions.context}
   * @default null
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  context: null,
  /**
   * {@link PIXI.IRendererOptions.antialias}
   * @default false
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  antialias: false,
  /**
   * {@link PIXI.IRendererOptions.premultipliedAlpha}
   * @default true
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  premultipliedAlpha: true,
  /**
   * {@link PIXI.IRendererOptions.preserveDrawingBuffer}
   * @default false
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  preserveDrawingBuffer: false,
  /**
   * {@link PIXI.IRendererOptions.powerPreference}
   * @default default
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  powerPreference: "default"
}, /** @ignore */
ContextSystem.extension = {
  type: ExtensionType2.RendererSystem,
  name: "context"
};
extensions2.add(ContextSystem);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/framebuffer/Framebuffer.mjs
var Framebuffer = class {
  /**
   * @param width - Width of the frame buffer
   * @param height - Height of the frame buffer
   */
  constructor(width, height) {
    if (this.width = Math.round(width), this.height = Math.round(height), !this.width || !this.height)
      throw new Error("Framebuffer width or height is zero");
    this.stencil = false, this.depth = false, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new Runner("disposeFramebuffer"), this.multisample = MSAA_QUALITY.NONE;
  }
  /**
   * Reference to the colorTexture.
   * @readonly
   */
  get colorTexture() {
    return this.colorTextures[0];
  }
  /**
   * Add texture to the colorTexture array.
   * @param index - Index of the array to add the texture to
   * @param texture - Texture to add to the array
   */
  addColorTexture(index = 0, texture) {
    return this.colorTextures[index] = texture || new BaseTexture(null, {
      scaleMode: SCALE_MODES.NEAREST,
      resolution: 1,
      mipmap: MIPMAP_MODES.OFF,
      width: this.width,
      height: this.height
    }), this.dirtyId++, this.dirtyFormat++, this;
  }
  /**
   * Add a depth texture to the frame buffer.
   * @param texture - Texture to add.
   */
  addDepthTexture(texture) {
    return this.depthTexture = texture || new BaseTexture(null, {
      scaleMode: SCALE_MODES.NEAREST,
      resolution: 1,
      width: this.width,
      height: this.height,
      mipmap: MIPMAP_MODES.OFF,
      format: FORMATS.DEPTH_COMPONENT,
      type: TYPES.UNSIGNED_SHORT
    }), this.dirtyId++, this.dirtyFormat++, this;
  }
  /** Enable depth on the frame buffer. */
  enableDepth() {
    return this.depth = true, this.dirtyId++, this.dirtyFormat++, this;
  }
  /** Enable stencil on the frame buffer. */
  enableStencil() {
    return this.stencil = true, this.dirtyId++, this.dirtyFormat++, this;
  }
  /**
   * Resize the frame buffer
   * @param width - Width of the frame buffer to resize to
   * @param height - Height of the frame buffer to resize to
   */
  resize(width, height) {
    if (width = Math.round(width), height = Math.round(height), !width || !height)
      throw new Error("Framebuffer width and height must not be zero");
    if (!(width === this.width && height === this.height)) {
      this.width = width, this.height = height, this.dirtyId++, this.dirtySize++;
      for (let i3 = 0; i3 < this.colorTextures.length; i3++) {
        const texture = this.colorTextures[i3], resolution = texture.resolution;
        texture.setSize(width / resolution, height / resolution);
      }
      if (this.depthTexture) {
        const resolution = this.depthTexture.resolution;
        this.depthTexture.setSize(width / resolution, height / resolution);
      }
    }
  }
  /** Disposes WebGL resources that are connected to this geometry. */
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  /** Destroys and removes the depth texture added to this framebuffer. */
  destroyDepthTexture() {
    this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.mjs
var BaseRenderTexture = class extends BaseTexture {
  /**
   * @param options
   * @param {number} [options.width=100] - The width of the base render texture.
   * @param {number} [options.height=100] - The height of the base render texture.
   * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.BaseTexture.defaultOptions.scaleMode] - See {@link PIXI.SCALE_MODES}
   *   for possible values.
   * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio
   *   of the texture being generated.
   * @param {PIXI.MSAA_QUALITY} [options.multisample=PIXI.MSAA_QUALITY.NONE] - The number of samples of the frame buffer.
   */
  constructor(options = {}) {
    if (typeof options == "number") {
      const width = arguments[0], height = arguments[1], scaleMode = arguments[2], resolution = arguments[3];
      options = { width, height, scaleMode, resolution };
    }
    options.width = options.width ?? 100, options.height = options.height ?? 100, options.multisample ?? (options.multisample = MSAA_QUALITY.NONE), super(null, options), this.mipmap = MIPMAP_MODES.OFF, this.valid = true, this._clear = new Color2([0, 0, 0, 0]), this.framebuffer = new Framebuffer(this.realWidth, this.realHeight).addColorTexture(0, this), this.framebuffer.multisample = options.multisample, this.maskStack = [], this.filterStack = [{}];
  }
  /** Color when clearning the texture. */
  set clearColor(value) {
    this._clear.setValue(value);
  }
  get clearColor() {
    return this._clear.value;
  }
  /**
   * Color object when clearning the texture.
   * @readonly
   * @since 7.2.0
   */
  get clear() {
    return this._clear;
  }
  /**
   * Shortcut to `this.framebuffer.multisample`.
   * @default PIXI.MSAA_QUALITY.NONE
   */
  get multisample() {
    return this.framebuffer.multisample;
  }
  set multisample(value) {
    this.framebuffer.multisample = value;
  }
  /**
   * Resizes the BaseRenderTexture.
   * @param desiredWidth - The desired width to resize to.
   * @param desiredHeight - The desired height to resize to.
   */
  resize(desiredWidth, desiredHeight) {
    this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);
  }
  /**
   * Frees the texture and framebuffer from WebGL memory without destroying this texture object.
   * This means you can still use the texture later which will upload it to GPU
   * memory again.
   * @fires PIXI.BaseTexture#dispose
   */
  dispose() {
    this.framebuffer.dispose(), super.dispose();
  }
  /** Destroys this texture. */
  destroy() {
    super.destroy(), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/textures/resources/BaseImageResource.mjs
var BaseImageResource = class extends Resource2 {
  /**
   * @param {HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas} source
   */
  constructor(source3) {
    const sourceAny = source3, width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width, height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
    super(width, height), this.source = source3, this.noSubImage = false;
  }
  /**
   * Set cross origin based detecting the url and the crossorigin
   * @param element - Element to apply crossOrigin
   * @param url - URL to check
   * @param crossorigin - Cross origin value to use
   */
  static crossOrigin(element, url2, crossorigin) {
    crossorigin === void 0 && !url2.startsWith("data:") ? element.crossOrigin = determineCrossOrigin2(url2) : crossorigin !== false && (element.crossOrigin = typeof crossorigin == "string" ? crossorigin : "anonymous");
  }
  /**
   * Upload the texture to the GPU.
   * @param renderer - Upload to the renderer
   * @param baseTexture - Reference to parent texture
   * @param glTexture
   * @param {HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas} [source] - (optional)
   * @returns - true is success
   */
  upload(renderer, baseTexture, glTexture, source3) {
    const gl = renderer.gl, width = baseTexture.realWidth, height = baseTexture.realHeight;
    if (source3 = source3 || this.source, typeof HTMLImageElement < "u" && source3 instanceof HTMLImageElement) {
      if (!source3.complete || source3.naturalWidth === 0)
        return false;
    } else if (typeof HTMLVideoElement < "u" && source3 instanceof HTMLVideoElement && source3.readyState <= 1)
      return false;
    return gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK), !this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height ? gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source3) : (glTexture.width = width, glTexture.height = height, gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source3)), true;
  }
  /**
   * Checks if source width/height was changed, resize can cause extra baseTexture update.
   * Triggers one update in any case.
   */
  update() {
    if (this.destroyed)
      return;
    const source3 = this.source, width = source3.naturalWidth || source3.videoWidth || source3.width, height = source3.naturalHeight || source3.videoHeight || source3.height;
    this.resize(width, height), super.update();
  }
  /** Destroy this {@link PIXI.BaseImageResource} */
  dispose() {
    this.source = null;
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/textures/resources/ImageResource.mjs
var ImageResource = class extends BaseImageResource {
  /**
   * @param source - image source or URL
   * @param options
   * @param {boolean} [options.autoLoad=true] - start loading process
   * @param {boolean} [options.createBitmap=PIXI.settings.CREATE_IMAGE_BITMAP] - whether its required to create
   *        a bitmap before upload
   * @param {boolean} [options.crossorigin=true] - Load image using cross origin
   * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.UNPACK] - Premultiply image alpha in bitmap
   */
  constructor(source3, options) {
    if (options = options || {}, typeof source3 == "string") {
      const imageElement = new Image();
      BaseImageResource.crossOrigin(imageElement, source3, options.crossorigin), imageElement.src = source3, source3 = imageElement;
    }
    super(source3), !source3.complete && this._width && this._height && (this._width = 0, this._height = 0), this.url = source3.src, this._process = null, this.preserveBitmap = false, this.createBitmap = (options.createBitmap ?? settings2.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, this.alphaMode = typeof options.alphaMode == "number" ? options.alphaMode : null, this.bitmap = null, this._load = null, options.autoLoad !== false && this.load();
  }
  /**
   * Returns a promise when image will be loaded and processed.
   * @param createBitmap - whether process image into bitmap
   */
  load(createBitmap) {
    return this._load ? this._load : (createBitmap !== void 0 && (this.createBitmap = createBitmap), this._load = new Promise((resolve2, reject) => {
      const source3 = this.source;
      this.url = source3.src;
      const completed = () => {
        this.destroyed || (source3.onload = null, source3.onerror = null, this.update(), this._load = null, this.createBitmap ? resolve2(this.process()) : resolve2(this));
      };
      source3.complete && source3.src ? completed() : (source3.onload = completed, source3.onerror = (event) => {
        reject(event), this.onError.emit(event);
      });
    }), this._load);
  }
  /**
   * Called when we need to convert image into BitmapImage.
   * Can be called multiple times, real promise is cached inside.
   * @returns - Cached promise to fill that bitmap
   */
  process() {
    const source3 = this.source;
    if (this._process !== null)
      return this._process;
    if (this.bitmap !== null || !globalThis.createImageBitmap)
      return Promise.resolve(this);
    const createImageBitmap2 = globalThis.createImageBitmap, cors = !source3.crossOrigin || source3.crossOrigin === "anonymous";
    return this._process = fetch(
      source3.src,
      {
        mode: cors ? "cors" : "no-cors"
      }
    ).then((r2) => r2.blob()).then((blob) => createImageBitmap2(
      blob,
      0,
      0,
      source3.width,
      source3.height,
      {
        premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
      }
    )).then((bitmap) => this.destroyed ? Promise.reject() : (this.bitmap = bitmap, this.update(), this._process = null, Promise.resolve(this))), this._process;
  }
  /**
   * Upload the image resource to GPU.
   * @param renderer - Renderer to upload to
   * @param baseTexture - BaseTexture for this resource
   * @param glTexture - GLTexture to use
   * @returns {boolean} true is success
   */
  upload(renderer, baseTexture, glTexture) {
    if (typeof this.alphaMode == "number" && (baseTexture.alphaMode = this.alphaMode), !this.createBitmap)
      return super.upload(renderer, baseTexture, glTexture);
    if (!this.bitmap && (this.process(), !this.bitmap))
      return false;
    if (super.upload(renderer, baseTexture, glTexture, this.bitmap), !this.preserveBitmap) {
      let flag = true;
      const glTextures = baseTexture._glTextures;
      for (const key2 in glTextures) {
        const otherTex = glTextures[key2];
        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
          flag = false;
          break;
        }
      }
      flag && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);
    }
    return true;
  }
  /** Destroys this resource. */
  dispose() {
    this.source.onload = null, this.source.onerror = null, super.dispose(), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;
  }
  /**
   * Used to auto-detect the type of resource.
   * @param {*} source - The source object
   * @returns {boolean} `true` if current environment support HTMLImageElement, and source is string or HTMLImageElement
   */
  static test(source3) {
    return typeof HTMLImageElement < "u" && (typeof source3 == "string" || source3 instanceof HTMLImageElement);
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/textures/TextureUvs.mjs
var TextureUvs = class {
  constructor() {
    this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);
  }
  /**
   * Sets the texture Uvs based on the given frame information.
   * @protected
   * @param frame - The frame of the texture
   * @param baseFrame - The base frame of the texture
   * @param rotate - Rotation of frame, see {@link PIXI.groupD8}
   */
  set(frame, baseFrame, rotate) {
    const tw = baseFrame.width, th = baseFrame.height;
    if (rotate) {
      const w2 = frame.width / 2 / tw, h2 = frame.height / 2 / th, cX = frame.x / tw + w2, cY = frame.y / th + h2;
      rotate = groupD82.add(rotate, groupD82.NW), this.x0 = cX + w2 * groupD82.uX(rotate), this.y0 = cY + h2 * groupD82.uY(rotate), rotate = groupD82.add(rotate, 2), this.x1 = cX + w2 * groupD82.uX(rotate), this.y1 = cY + h2 * groupD82.uY(rotate), rotate = groupD82.add(rotate, 2), this.x2 = cX + w2 * groupD82.uX(rotate), this.y2 = cY + h2 * groupD82.uY(rotate), rotate = groupD82.add(rotate, 2), this.x3 = cX + w2 * groupD82.uX(rotate), this.y3 = cY + h2 * groupD82.uY(rotate);
    } else
      this.x0 = frame.x / tw, this.y0 = frame.y / th, this.x1 = (frame.x + frame.width) / tw, this.y1 = frame.y / th, this.x2 = (frame.x + frame.width) / tw, this.y2 = (frame.y + frame.height) / th, this.x3 = frame.x / tw, this.y3 = (frame.y + frame.height) / th;
    this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;
  }
};
TextureUvs.prototype.toString = function() {
  return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/textures/Texture.mjs
var DEFAULT_UVS = new TextureUvs();
function removeAllHandlers(tex) {
  tex.destroy = function() {
  }, tex.on = function() {
  }, tex.once = function() {
  }, tex.emit = function() {
  };
}
var Texture3 = class _Texture extends import_eventemitter317.default {
  /**
   * @param baseTexture - The base texture source to create the texture from
   * @param frame - The rectangle frame of the texture to show
   * @param orig - The area of original texture
   * @param trim - Trimmed rectangle of original texture
   * @param rotate - indicates how the texture was rotated by texture packer. See {@link PIXI.groupD8}
   * @param anchor - Default anchor point used for sprite placement / rotation
   * @param borders - Default borders used for 9-slice scaling. See {@link PIXI.NineSlicePlane}
   */
  constructor(baseTexture, frame, orig, trim, rotate, anchor, borders) {
    if (super(), this.noFrame = false, frame || (this.noFrame = true, frame = new Rectangle2(0, 0, 1, 1)), baseTexture instanceof _Texture && (baseTexture = baseTexture.baseTexture), this.baseTexture = baseTexture, this._frame = frame, this.trim = trim, this.valid = false, this.destroyed = false, this._uvs = DEFAULT_UVS, this.uvMatrix = null, this.orig = orig || frame, this._rotate = Number(rotate || 0), rotate === true)
      this._rotate = 2;
    else if (this._rotate % 2 !== 0)
      throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
    this.defaultAnchor = anchor ? new Point2(anchor.x, anchor.y) : new Point2(0, 0), this.defaultBorders = borders, this._updateID = 0, this.textureCacheIds = [], baseTexture.valid ? this.noFrame ? baseTexture.valid && this.onBaseTextureUpdated(baseTexture) : this.frame = frame : baseTexture.once("loaded", this.onBaseTextureUpdated, this), this.noFrame && baseTexture.on("update", this.onBaseTextureUpdated, this);
  }
  /**
   * Updates this texture on the gpu.
   *
   * Calls the TextureResource update.
   *
   * If you adjusted `frame` manually, please call `updateUvs()` instead.
   */
  update() {
    this.baseTexture.resource && this.baseTexture.resource.update();
  }
  /**
   * Called when the base texture is updated
   * @protected
   * @param baseTexture - The base texture.
   */
  onBaseTextureUpdated(baseTexture) {
    if (this.noFrame) {
      if (!this.baseTexture.valid)
        return;
      this._frame.width = baseTexture.width, this._frame.height = baseTexture.height, this.valid = true, this.updateUvs();
    } else
      this.frame = this._frame;
    this.emit("update", this);
  }
  /**
   * Destroys this texture
   * @param [destroyBase=false] - Whether to destroy the base texture as well
   * @fires PIXI.Texture#destroyed
   */
  destroy(destroyBase) {
    if (this.baseTexture) {
      if (destroyBase) {
        const { resource } = this.baseTexture;
        resource?.url && TextureCache[resource.url] && _Texture.removeFromCache(resource.url), this.baseTexture.destroy();
      }
      this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null;
    }
    this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = false, _Texture.removeFromCache(this), this.textureCacheIds = null, this.destroyed = true, this.emit("destroyed", this), this.removeAllListeners();
  }
  /**
   * Creates a new texture object that acts the same as this one.
   * @returns - The new texture
   */
  clone() {
    const clonedFrame = this._frame.clone(), clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone(), clonedTexture = new _Texture(
      this.baseTexture,
      !this.noFrame && clonedFrame,
      clonedOrig,
      this.trim?.clone(),
      this.rotate,
      this.defaultAnchor,
      this.defaultBorders
    );
    return this.noFrame && (clonedTexture._frame = clonedFrame), clonedTexture;
  }
  /**
   * Updates the internal WebGL UV cache. Use it after you change `frame` or `trim` of the texture.
   * Call it after changing the frame
   */
  updateUvs() {
    this._uvs === DEFAULT_UVS && (this._uvs = new TextureUvs()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;
  }
  /**
   * Helper function that creates a new Texture based on the source you provide.
   * The source can be - frame id, image url, video url, canvas element, video element, base texture
   * @param {string|PIXI.BaseTexture|HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas} source -
   *        Source or array of sources to create texture from
   * @param options - See {@link PIXI.BaseTexture}'s constructor for options.
   * @param {string} [options.pixiIdPrefix=pixiid] - If a source has no id, this is the prefix of the generated id
   * @param {boolean} [strict] - Enforce strict-mode, see {@link PIXI.settings.STRICT_TEXTURE_CACHE}.
   * @returns {PIXI.Texture} The newly created texture
   */
  static from(source3, options = {}, strict = settings2.STRICT_TEXTURE_CACHE) {
    const isFrame = typeof source3 == "string";
    let cacheId = null;
    if (isFrame)
      cacheId = source3;
    else if (source3 instanceof BaseTexture) {
      if (!source3.cacheId) {
        const prefix2 = options?.pixiIdPrefix || "pixiid";
        source3.cacheId = `${prefix2}-${uid2()}`, BaseTexture.addToCache(source3, source3.cacheId);
      }
      cacheId = source3.cacheId;
    } else {
      if (!source3._pixiId) {
        const prefix2 = options?.pixiIdPrefix || "pixiid";
        source3._pixiId = `${prefix2}_${uid2()}`;
      }
      cacheId = source3._pixiId;
    }
    let texture = TextureCache[cacheId];
    if (isFrame && strict && !texture)
      throw new Error(`The cacheId "${cacheId}" does not exist in TextureCache.`);
    return !texture && !(source3 instanceof BaseTexture) ? (options.resolution || (options.resolution = getResolutionOfUrl2(source3)), texture = new _Texture(new BaseTexture(source3, options)), texture.baseTexture.cacheId = cacheId, BaseTexture.addToCache(texture.baseTexture, cacheId), _Texture.addToCache(texture, cacheId)) : !texture && source3 instanceof BaseTexture && (texture = new _Texture(source3), _Texture.addToCache(texture, cacheId)), texture;
  }
  /**
   * Useful for loading textures via URLs. Use instead of `Texture.from` because
   * it does a better job of handling failed URLs more effectively. This also ignores
   * `PIXI.settings.STRICT_TEXTURE_CACHE`. Works for Videos, SVGs, Images.
   * @param url - The remote URL or array of URLs to load.
   * @param options - Optional options to include
   * @returns - A Promise that resolves to a Texture.
   */
  static fromURL(url2, options) {
    const resourceOptions = Object.assign({ autoLoad: false }, options?.resourceOptions), texture = _Texture.from(url2, Object.assign({ resourceOptions }, options), false), resource = texture.baseTexture.resource;
    return texture.baseTexture.valid ? Promise.resolve(texture) : resource.load().then(() => Promise.resolve(texture));
  }
  /**
   * Create a new Texture with a BufferResource from a typed array.
   * @param buffer - The optional array to use. If no data is provided, a new Float32Array is created.
   * @param width - Width of the resource
   * @param height - Height of the resource
   * @param options - See {@link PIXI.BaseTexture}'s constructor for options.
   *        Default properties are different from the constructor's defaults.
   * @param {PIXI.FORMATS} [options.format] - The format is not given, the type is inferred from the
   *        type of the buffer: `RGBA` if Float32Array, Int8Array, Uint8Array, or Uint8ClampedArray,
   *        otherwise `RGBA_INTEGER`.
   * @param {PIXI.TYPES} [options.type] - The type is not given, the type is inferred from the
   *        type of the buffer. Maps Float32Array to `FLOAT`, Int32Array to `INT`, Uint32Array to
   *        `UNSIGNED_INT`, Int16Array to `SHORT`, Uint16Array to `UNSIGNED_SHORT`, Int8Array to `BYTE`,
   *        Uint8Array/Uint8ClampedArray to `UNSIGNED_BYTE`.
   * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.NPM]
   * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.SCALE_MODES.NEAREST]
   * @returns - The resulting new BaseTexture
   */
  static fromBuffer(buffer2, width, height, options) {
    return new _Texture(BaseTexture.fromBuffer(buffer2, width, height, options));
  }
  /**
   * Create a texture from a source and add to the cache.
   * @param {HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas|string} source - The input source.
   * @param imageUrl - File name of texture, for cache and resolving resolution.
   * @param name - Human readable name for the texture cache. If no name is
   *        specified, only `imageUrl` will be used as the cache ID.
   * @param options
   * @returns - Output texture
   */
  static fromLoader(source3, imageUrl, name, options) {
    const baseTexture = new BaseTexture(source3, Object.assign({
      scaleMode: BaseTexture.defaultOptions.scaleMode,
      resolution: getResolutionOfUrl2(imageUrl)
    }, options)), { resource } = baseTexture;
    resource instanceof ImageResource && (resource.url = imageUrl);
    const texture = new _Texture(baseTexture);
    return name || (name = imageUrl), BaseTexture.addToCache(texture.baseTexture, name), _Texture.addToCache(texture, name), name !== imageUrl && (BaseTexture.addToCache(texture.baseTexture, imageUrl), _Texture.addToCache(texture, imageUrl)), texture.baseTexture.valid ? Promise.resolve(texture) : new Promise((resolve2) => {
      texture.baseTexture.once("loaded", () => resolve2(texture));
    });
  }
  /**
   * Adds a Texture to the global TextureCache. This cache is shared across the whole PIXI object.
   * @param texture - The Texture to add to the cache.
   * @param id - The id that the Texture will be stored against.
   */
  static addToCache(texture, id) {
    id && (texture.textureCacheIds.includes(id) || texture.textureCacheIds.push(id), TextureCache[id] && TextureCache[id] !== texture && console.warn(`Texture added to the cache with an id [${id}] that already had an entry`), TextureCache[id] = texture);
  }
  /**
   * Remove a Texture from the global TextureCache.
   * @param texture - id of a Texture to be removed, or a Texture instance itself
   * @returns - The Texture that was removed
   */
  static removeFromCache(texture) {
    if (typeof texture == "string") {
      const textureFromCache = TextureCache[texture];
      if (textureFromCache) {
        const index = textureFromCache.textureCacheIds.indexOf(texture);
        return index > -1 && textureFromCache.textureCacheIds.splice(index, 1), delete TextureCache[texture], textureFromCache;
      }
    } else if (texture?.textureCacheIds) {
      for (let i3 = 0; i3 < texture.textureCacheIds.length; ++i3)
        TextureCache[texture.textureCacheIds[i3]] === texture && delete TextureCache[texture.textureCacheIds[i3]];
      return texture.textureCacheIds.length = 0, texture;
    }
    return null;
  }
  /**
   * Returns resolution of baseTexture
   * @readonly
   */
  get resolution() {
    return this.baseTexture.resolution;
  }
  /**
   * The frame specifies the region of the base texture that this texture uses.
   * Please call `updateUvs()` after you change coordinates of `frame` manually.
   */
  get frame() {
    return this._frame;
  }
  set frame(frame) {
    this._frame = frame, this.noFrame = false;
    const { x: x3, y: y2, width, height } = frame, xNotFit = x3 + width > this.baseTexture.width, yNotFit = y2 + height > this.baseTexture.height;
    if (xNotFit || yNotFit) {
      const relationship = xNotFit && yNotFit ? "and" : "or", errorX = `X: ${x3} + ${width} = ${x3 + width} > ${this.baseTexture.width}`, errorY = `Y: ${y2} + ${height} = ${y2 + height} > ${this.baseTexture.height}`;
      throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${errorX} ${relationship} ${errorY}`);
    }
    this.valid = width && height && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = frame), this.valid && this.updateUvs();
  }
  /**
   * Indicates whether the texture is rotated inside the atlas
   * set to 2 to compensate for texture packer rotation
   * set to 6 to compensate for spine packer rotation
   * can be used to rotate or mirror sprites
   * See {@link PIXI.groupD8} for explanation
   */
  get rotate() {
    return this._rotate;
  }
  set rotate(rotate) {
    this._rotate = rotate, this.valid && this.updateUvs();
  }
  /** The width of the Texture in pixels. */
  get width() {
    return this.orig.width;
  }
  /** The height of the Texture in pixels. */
  get height() {
    return this.orig.height;
  }
  /** Utility function for BaseTexture|Texture cast. */
  castToBaseTexture() {
    return this.baseTexture;
  }
  /** An empty texture, used often to not have to create multiple empty textures. Can not be destroyed. */
  static get EMPTY() {
    return _Texture._EMPTY || (_Texture._EMPTY = new _Texture(new BaseTexture()), removeAllHandlers(_Texture._EMPTY), removeAllHandlers(_Texture._EMPTY.baseTexture)), _Texture._EMPTY;
  }
  /** A white texture of 16x16 size, used for graphics and other things Can not be destroyed. */
  static get WHITE() {
    if (!_Texture._WHITE) {
      const canvas3 = settings2.ADAPTER.createCanvas(16, 16), context4 = canvas3.getContext("2d");
      canvas3.width = 16, canvas3.height = 16, context4.fillStyle = "white", context4.fillRect(0, 0, 16, 16), _Texture._WHITE = new _Texture(BaseTexture.from(canvas3)), removeAllHandlers(_Texture._WHITE), removeAllHandlers(_Texture._WHITE.baseTexture);
    }
    return _Texture._WHITE;
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/renderTexture/RenderTexture.mjs
var RenderTexture2 = class _RenderTexture extends Texture3 {
  /**
   * @param baseRenderTexture - The base texture object that this texture uses.
   * @param frame - The rectangle frame of the texture to show.
   */
  constructor(baseRenderTexture, frame) {
    super(baseRenderTexture, frame), this.valid = true, this.filterFrame = null, this.filterPoolKey = null, this.updateUvs();
  }
  /**
   * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.
   * @readonly
   */
  get framebuffer() {
    return this.baseTexture.framebuffer;
  }
  /**
   * Shortcut to `this.framebuffer.multisample`.
   * @default PIXI.MSAA_QUALITY.NONE
   */
  get multisample() {
    return this.framebuffer.multisample;
  }
  set multisample(value) {
    this.framebuffer.multisample = value;
  }
  /**
   * Resizes the RenderTexture.
   * @param desiredWidth - The desired width to resize to.
   * @param desiredHeight - The desired height to resize to.
   * @param resizeBaseTexture - Should the baseTexture.width and height values be resized as well?
   */
  resize(desiredWidth, desiredHeight, resizeBaseTexture = true) {
    const resolution = this.baseTexture.resolution, width = Math.round(desiredWidth * resolution) / resolution, height = Math.round(desiredHeight * resolution) / resolution;
    this.valid = width > 0 && height > 0, this._frame.width = this.orig.width = width, this._frame.height = this.orig.height = height, resizeBaseTexture && this.baseTexture.resize(width, height), this.updateUvs();
  }
  /**
   * Changes the resolution of baseTexture, but does not change framebuffer size.
   * @param resolution - The new resolution to apply to RenderTexture
   */
  setResolution(resolution) {
    const { baseTexture } = this;
    baseTexture.resolution !== resolution && (baseTexture.setResolution(resolution), this.resize(baseTexture.width, baseTexture.height, false));
  }
  /**
   * A short hand way of creating a render texture.
   * @param options - Options
   * @param {number} [options.width=100] - The width of the render texture
   * @param {number} [options.height=100] - The height of the render texture
   * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.BaseTexture.defaultOptions.scaleMode] - See {@link PIXI.SCALE_MODES}
   *    for possible values
   * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio of the texture
   *    being generated
   * @param {PIXI.MSAA_QUALITY} [options.multisample=PIXI.MSAA_QUALITY.NONE] - The number of samples of the frame buffer
   * @returns The new render texture
   */
  static create(options) {
    return new _RenderTexture(new BaseRenderTexture(options));
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.mjs
var RenderTexturePool = class {
  /**
   * @param textureOptions - options that will be passed to BaseRenderTexture constructor
   * @param {PIXI.SCALE_MODES} [textureOptions.scaleMode] - See {@link PIXI.SCALE_MODES} for possible values.
   */
  constructor(textureOptions) {
    this.texturePool = {}, this.textureOptions = textureOptions || {}, this.enableFullScreen = false, this._pixelsWidth = 0, this._pixelsHeight = 0;
  }
  /**
   * Creates texture with params that were specified in pool constructor.
   * @param realWidth - Width of texture in pixels.
   * @param realHeight - Height of texture in pixels.
   * @param multisample - Number of samples of the framebuffer.
   */
  createTexture(realWidth, realHeight, multisample = MSAA_QUALITY.NONE) {
    const baseRenderTexture = new BaseRenderTexture(Object.assign({
      width: realWidth,
      height: realHeight,
      resolution: 1,
      multisample
    }, this.textureOptions));
    return new RenderTexture2(baseRenderTexture);
  }
  /**
   * Gets a Power-of-Two render texture or fullScreen texture
   * @param minWidth - The minimum width of the render texture.
   * @param minHeight - The minimum height of the render texture.
   * @param resolution - The resolution of the render texture.
   * @param multisample - Number of samples of the render texture.
   * @returns The new render texture.
   */
  getOptimalTexture(minWidth, minHeight, resolution = 1, multisample = MSAA_QUALITY.NONE) {
    let key2;
    minWidth = Math.max(Math.ceil(minWidth * resolution - 1e-6), 1), minHeight = Math.max(Math.ceil(minHeight * resolution - 1e-6), 1), !this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight ? (minWidth = nextPow22(minWidth), minHeight = nextPow22(minHeight), key2 = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0, multisample > 1 && (key2 += multisample * 4294967296)) : key2 = multisample > 1 ? -multisample : -1, this.texturePool[key2] || (this.texturePool[key2] = []);
    let renderTexture = this.texturePool[key2].pop();
    return renderTexture || (renderTexture = this.createTexture(minWidth, minHeight, multisample)), renderTexture.filterPoolKey = key2, renderTexture.setResolution(resolution), renderTexture;
  }
  /**
   * Gets extra texture of the same size as input renderTexture
   *
   * `getFilterTexture(input, 0.5)` or `getFilterTexture(0.5, input)`
   * @param input - renderTexture from which size and resolution will be copied
   * @param resolution - override resolution of the renderTexture
   *  It overrides, it does not multiply
   * @param multisample - number of samples of the renderTexture
   */
  getFilterTexture(input, resolution, multisample) {
    const filterTexture = this.getOptimalTexture(
      input.width,
      input.height,
      resolution || input.resolution,
      multisample || MSAA_QUALITY.NONE
    );
    return filterTexture.filterFrame = input.filterFrame, filterTexture;
  }
  /**
   * Place a render texture back into the pool.
   * @param renderTexture - The renderTexture to free
   */
  returnTexture(renderTexture) {
    const key2 = renderTexture.filterPoolKey;
    renderTexture.filterFrame = null, this.texturePool[key2].push(renderTexture);
  }
  /**
   * Alias for returnTexture, to be compliant with FilterSystem interface.
   * @param renderTexture - The renderTexture to free
   */
  returnFilterTexture(renderTexture) {
    this.returnTexture(renderTexture);
  }
  /**
   * Clears the pool.
   * @param destroyTextures - Destroy all stored textures.
   */
  clear(destroyTextures) {
    if (destroyTextures = destroyTextures !== false, destroyTextures)
      for (const i3 in this.texturePool) {
        const textures = this.texturePool[i3];
        if (textures)
          for (let j3 = 0; j3 < textures.length; j3++)
            textures[j3].destroy(true);
      }
    this.texturePool = {};
  }
  /**
   * If screen size was changed, drops all screen-sized textures,
   * sets new screen size, sets `enableFullScreen` to true
   *
   * Size is measured in pixels, `renderer.view` can be passed here, not `renderer.screen`
   * @param size - Initial size of screen.
   */
  setScreenSize(size3) {
    if (!(size3.width === this._pixelsWidth && size3.height === this._pixelsHeight)) {
      this.enableFullScreen = size3.width > 0 && size3.height > 0;
      for (const i3 in this.texturePool) {
        if (!(Number(i3) < 0))
          continue;
        const textures = this.texturePool[i3];
        if (textures)
          for (let j3 = 0; j3 < textures.length; j3++)
            textures[j3].destroy(true);
        this.texturePool[i3] = [];
      }
      this._pixelsWidth = size3.width, this._pixelsHeight = size3.height;
    }
  }
};
RenderTexturePool.SCREEN_KEY = -1;

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/utils/Quad.mjs
var Quad = class extends Geometry2 {
  constructor() {
    super(), this.addAttribute("aVertexPosition", new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ])).addIndex([0, 1, 3, 2]);
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/utils/QuadUv.mjs
var QuadUv = class extends Geometry2 {
  constructor() {
    super(), this.vertices = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1
    ]), this.uvs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ]), this.vertexBuffer = new Buffer3(this.vertices), this.uvBuffer = new Buffer3(this.uvs), this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
  }
  /**
   * Maps two Rectangle to the quad.
   * @param targetTextureFrame - The first rectangle
   * @param destinationFrame - The second rectangle
   * @returns - Returns itself.
   */
  map(targetTextureFrame, destinationFrame) {
    let x3 = 0, y2 = 0;
    return this.uvs[0] = x3, this.uvs[1] = y2, this.uvs[2] = x3 + destinationFrame.width / targetTextureFrame.width, this.uvs[3] = y2, this.uvs[4] = x3 + destinationFrame.width / targetTextureFrame.width, this.uvs[5] = y2 + destinationFrame.height / targetTextureFrame.height, this.uvs[6] = x3, this.uvs[7] = y2 + destinationFrame.height / targetTextureFrame.height, x3 = destinationFrame.x, y2 = destinationFrame.y, this.vertices[0] = x3, this.vertices[1] = y2, this.vertices[2] = x3 + destinationFrame.width, this.vertices[3] = y2, this.vertices[4] = x3 + destinationFrame.width, this.vertices[5] = y2 + destinationFrame.height, this.vertices[6] = x3, this.vertices[7] = y2 + destinationFrame.height, this.invalidate(), this;
  }
  /**
   * Legacy upload method, just marks buffers dirty.
   * @returns - Returns itself.
   */
  invalidate() {
    return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/filters/FilterState.mjs
var FilterState = class {
  constructor() {
    this.renderTexture = null, this.target = null, this.legacy = false, this.resolution = 1, this.multisample = MSAA_QUALITY.NONE, this.sourceFrame = new Rectangle2(), this.destinationFrame = new Rectangle2(), this.bindingSourceFrame = new Rectangle2(), this.bindingDestinationFrame = new Rectangle2(), this.filters = [], this.transform = null;
  }
  /** Clears the state */
  clear() {
    this.target = null, this.filters = null, this.renderTexture = null;
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/filters/FilterSystem.mjs
var tempPoints3 = [new Point2(), new Point2(), new Point2(), new Point2()];
var tempMatrix4 = new Matrix2();
var FilterSystem2 = class {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.defaultFilterStack = [{}], this.texturePool = new RenderTexturePool(), this.statePool = [], this.quad = new Quad(), this.quadUv = new QuadUv(), this.tempRect = new Rectangle2(), this.activeState = {}, this.globalUniforms = new UniformGroup2({
      outputFrame: new Rectangle2(),
      inputSize: new Float32Array(4),
      inputPixel: new Float32Array(4),
      inputClamp: new Float32Array(4),
      resolution: 1,
      // legacy variables
      filterArea: new Float32Array(4),
      filterClamp: new Float32Array(4)
    }, true), this.forceClear = false, this.useMaxPadding = false;
  }
  init() {
    this.texturePool.setScreenSize(this.renderer.view);
  }
  /**
   * Pushes a set of filters to be applied later to the system. This will redirect further rendering into an
   * input render-texture for the rest of the filtering pipeline.
   * @param {PIXI.DisplayObject} target - The target of the filter to render.
   * @param filters - The filters to apply.
   */
  push(target, filters) {
    const renderer = this.renderer, filterStack = this.defaultFilterStack, state = this.statePool.pop() || new FilterState(), renderTextureSystem = renderer.renderTexture;
    let currentResolution, currentMultisample;
    if (renderTextureSystem.current) {
      const renderTexture = renderTextureSystem.current;
      currentResolution = renderTexture.resolution, currentMultisample = renderTexture.multisample;
    } else
      currentResolution = renderer.resolution, currentMultisample = renderer.multisample;
    let resolution = filters[0].resolution || currentResolution, multisample = filters[0].multisample ?? currentMultisample, padding = filters[0].padding, autoFit = filters[0].autoFit, legacy = filters[0].legacy ?? true;
    for (let i3 = 1; i3 < filters.length; i3++) {
      const filter = filters[i3];
      resolution = Math.min(resolution, filter.resolution || currentResolution), multisample = Math.min(multisample, filter.multisample ?? currentMultisample), padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding, autoFit = autoFit && filter.autoFit, legacy = legacy || (filter.legacy ?? true);
    }
    filterStack.length === 1 && (this.defaultFilterStack[0].renderTexture = renderTextureSystem.current), filterStack.push(state), state.resolution = resolution, state.multisample = multisample, state.legacy = legacy, state.target = target, state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true)), state.sourceFrame.pad(padding);
    const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
    renderer.projection.transform && this.transformAABB(
      tempMatrix4.copyFrom(renderer.projection.transform).invert(),
      sourceFrameProjected
    ), autoFit ? (state.sourceFrame.fit(sourceFrameProjected), (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) && (state.sourceFrame.width = 0, state.sourceFrame.height = 0)) : state.sourceFrame.intersects(sourceFrameProjected) || (state.sourceFrame.width = 0, state.sourceFrame.height = 0), this.roundFrame(
      state.sourceFrame,
      renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,
      renderTextureSystem.sourceFrame,
      renderTextureSystem.destinationFrame,
      renderer.projection.transform
    ), state.renderTexture = this.getOptimalFilterTexture(
      state.sourceFrame.width,
      state.sourceFrame.height,
      resolution,
      multisample
    ), state.filters = filters, state.destinationFrame.width = state.renderTexture.width, state.destinationFrame.height = state.renderTexture.height;
    const destinationFrame = this.tempRect;
    destinationFrame.x = 0, destinationFrame.y = 0, destinationFrame.width = state.sourceFrame.width, destinationFrame.height = state.sourceFrame.height, state.renderTexture.filterFrame = state.sourceFrame, state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame), state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame), state.transform = renderer.projection.transform, renderer.projection.transform = null, renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame), renderer.framebuffer.clear(0, 0, 0, 0);
  }
  /** Pops off the filter and applies it. */
  pop() {
    const filterStack = this.defaultFilterStack, state = filterStack.pop(), filters = state.filters;
    this.activeState = state;
    const globalUniforms = this.globalUniforms.uniforms;
    globalUniforms.outputFrame = state.sourceFrame, globalUniforms.resolution = state.resolution;
    const inputSize = globalUniforms.inputSize, inputPixel = globalUniforms.inputPixel, inputClamp = globalUniforms.inputClamp;
    if (inputSize[0] = state.destinationFrame.width, inputSize[1] = state.destinationFrame.height, inputSize[2] = 1 / inputSize[0], inputSize[3] = 1 / inputSize[1], inputPixel[0] = Math.round(inputSize[0] * state.resolution), inputPixel[1] = Math.round(inputSize[1] * state.resolution), inputPixel[2] = 1 / inputPixel[0], inputPixel[3] = 1 / inputPixel[1], inputClamp[0] = 0.5 * inputPixel[2], inputClamp[1] = 0.5 * inputPixel[3], inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2], inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3], state.legacy) {
      const filterArea = globalUniforms.filterArea;
      filterArea[0] = state.destinationFrame.width, filterArea[1] = state.destinationFrame.height, filterArea[2] = state.sourceFrame.x, filterArea[3] = state.sourceFrame.y, globalUniforms.filterClamp = globalUniforms.inputClamp;
    }
    this.globalUniforms.update();
    const lastState = filterStack[filterStack.length - 1];
    if (this.renderer.framebuffer.blit(), filters.length === 1)
      filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state), this.returnFilterTexture(state.renderTexture);
    else {
      let flip = state.renderTexture, flop = this.getOptimalFilterTexture(
        flip.width,
        flip.height,
        state.resolution
      );
      flop.filterFrame = flip.filterFrame;
      let i3 = 0;
      for (i3 = 0; i3 < filters.length - 1; ++i3) {
        i3 === 1 && state.multisample > 1 && (flop = this.getOptimalFilterTexture(
          flip.width,
          flip.height,
          state.resolution
        ), flop.filterFrame = flip.filterFrame), filters[i3].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);
        const t2 = flip;
        flip = flop, flop = t2;
      }
      filters[i3].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state), i3 > 1 && state.multisample > 1 && this.returnFilterTexture(state.renderTexture), this.returnFilterTexture(flip), this.returnFilterTexture(flop);
    }
    state.clear(), this.statePool.push(state);
  }
  /**
   * Binds a renderTexture with corresponding `filterFrame`, clears it if mode corresponds.
   * @param filterTexture - renderTexture to bind, should belong to filter pool or filter stack
   * @param clearMode - clearMode, by default its CLEAR/YES. See {@link PIXI.CLEAR_MODES}
   */
  bindAndClear(filterTexture, clearMode = CLEAR_MODES.CLEAR) {
    const {
      renderTexture: renderTextureSystem,
      state: stateSystem
    } = this.renderer;
    if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, filterTexture?.filterFrame) {
      const destinationFrame = this.tempRect;
      destinationFrame.x = 0, destinationFrame.y = 0, destinationFrame.width = filterTexture.filterFrame.width, destinationFrame.height = filterTexture.filterFrame.height, renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
    } else
      filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? renderTextureSystem.bind(filterTexture) : this.renderer.renderTexture.bind(
        filterTexture,
        this.activeState.bindingSourceFrame,
        this.activeState.bindingDestinationFrame
      );
    const autoClear = stateSystem.stateId & 1 || this.forceClear;
    (clearMode === CLEAR_MODES.CLEAR || clearMode === CLEAR_MODES.BLIT && autoClear) && this.renderer.framebuffer.clear(0, 0, 0, 0);
  }
  /**
   * Draws a filter using the default rendering process.
   *
   * This should be called only by {@link PIXI.Filter#apply}.
   * @param filter - The filter to draw.
   * @param input - The input render target.
   * @param output - The target to output to.
   * @param clearMode - Should the output be cleared before rendering to it
   */
  applyFilter(filter, input, output, clearMode) {
    const renderer = this.renderer;
    renderer.state.set(filter.state), this.bindAndClear(output, clearMode), filter.uniforms.uSampler = input, filter.uniforms.filterGlobals = this.globalUniforms, renderer.shader.bind(filter), filter.legacy = !!filter.program.attributeData.aTextureCoord, filter.legacy ? (this.quadUv.map(input._frame, input.filterFrame), renderer.geometry.bind(this.quadUv), renderer.geometry.draw(DRAW_MODES.TRIANGLES)) : (renderer.geometry.bind(this.quad), renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP));
  }
  /**
   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.
   *
   * Use `outputMatrix * vTextureCoord` in the shader.
   * @param outputMatrix - The matrix to output to.
   * @param {PIXI.Sprite} sprite - The sprite to map to.
   * @returns The mapped matrix.
   */
  calculateSpriteMatrix(outputMatrix, sprite) {
    const { sourceFrame, destinationFrame } = this.activeState, { orig } = sprite._texture, mappedMatrix = outputMatrix.set(
      destinationFrame.width,
      0,
      0,
      destinationFrame.height,
      sourceFrame.x,
      sourceFrame.y
    ), worldTransform = sprite.worldTransform.copyTo(Matrix2.TEMP_MATRIX);
    return worldTransform.invert(), mappedMatrix.prepend(worldTransform), mappedMatrix.scale(1 / orig.width, 1 / orig.height), mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y), mappedMatrix;
  }
  /** Destroys this Filter System. */
  destroy() {
    this.renderer = null, this.texturePool.clear(false);
  }
  /**
   * Gets a Power-of-Two render texture or fullScreen texture
   * @param minWidth - The minimum width of the render texture in real pixels.
   * @param minHeight - The minimum height of the render texture in real pixels.
   * @param resolution - The resolution of the render texture.
   * @param multisample - Number of samples of the render texture.
   * @returns - The new render texture.
   */
  getOptimalFilterTexture(minWidth, minHeight, resolution = 1, multisample = MSAA_QUALITY.NONE) {
    return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);
  }
  /**
   * Gets extra render texture to use inside current filter
   * To be compliant with older filters, you can use params in any order
   * @param input - renderTexture from which size and resolution will be copied
   * @param resolution - override resolution of the renderTexture
   * @param multisample - number of samples of the renderTexture
   */
  getFilterTexture(input, resolution, multisample) {
    if (typeof input == "number") {
      const swap = input;
      input = resolution, resolution = swap;
    }
    input = input || this.activeState.renderTexture;
    const filterTexture = this.texturePool.getOptimalTexture(
      input.width,
      input.height,
      resolution || input.resolution,
      multisample || MSAA_QUALITY.NONE
    );
    return filterTexture.filterFrame = input.filterFrame, filterTexture;
  }
  /**
   * Frees a render texture back into the pool.
   * @param renderTexture - The renderTarget to free
   */
  returnFilterTexture(renderTexture) {
    this.texturePool.returnTexture(renderTexture);
  }
  /** Empties the texture pool. */
  emptyPool() {
    this.texturePool.clear(true);
  }
  /** Calls `texturePool.resize()`, affects fullScreen renderTextures. */
  resize() {
    this.texturePool.setScreenSize(this.renderer.view);
  }
  /**
   * @param matrix - first param
   * @param rect - second param
   */
  transformAABB(matrix, rect) {
    const lt = tempPoints3[0], lb = tempPoints3[1], rt = tempPoints3[2], rb = tempPoints3[3];
    lt.set(rect.left, rect.top), lb.set(rect.left, rect.bottom), rt.set(rect.right, rect.top), rb.set(rect.right, rect.bottom), matrix.apply(lt, lt), matrix.apply(lb, lb), matrix.apply(rt, rt), matrix.apply(rb, rb);
    const x0 = Math.min(lt.x, lb.x, rt.x, rb.x), y0 = Math.min(lt.y, lb.y, rt.y, rb.y), x1 = Math.max(lt.x, lb.x, rt.x, rb.x), y1 = Math.max(lt.y, lb.y, rt.y, rb.y);
    rect.x = x0, rect.y = y0, rect.width = x1 - x0, rect.height = y1 - y0;
  }
  roundFrame(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (!(frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0)) {
      if (transform) {
        const { a: a2, b: b2, c: c2, d: d3 } = transform;
        if ((Math.abs(b2) > 1e-4 || Math.abs(c2) > 1e-4) && (Math.abs(a2) > 1e-4 || Math.abs(d3) > 1e-4))
          return;
      }
      transform = transform ? tempMatrix4.copyFrom(transform) : tempMatrix4.identity(), transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(
        bindingDestinationFrame.width / bindingSourceFrame.width,
        bindingDestinationFrame.height / bindingSourceFrame.height
      ).translate(bindingDestinationFrame.x, bindingDestinationFrame.y), this.transformAABB(transform, frame), frame.ceil(resolution), this.transformAABB(transform.invert(), frame);
    }
  }
};
FilterSystem2.extension = {
  type: ExtensionType2.RendererSystem,
  name: "filter"
};
extensions2.add(FilterSystem2);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.mjs
var GLFramebuffer = class {
  constructor(framebuffer) {
    this.framebuffer = framebuffer, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = MSAA_QUALITY.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.mjs
var tempRectangle2 = new Rectangle2();
var FramebufferSystem = class {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.managedFramebuffers = [], this.unknownFramebuffer = new Framebuffer(10, 10), this.msaaSamples = null;
  }
  /** Sets up the renderer context and necessary buffers. */
  contextChange() {
    this.disposeAll(true);
    const gl = this.gl = this.renderer.gl;
    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new Rectangle2(), this.hasMRT = true, this.writeDepthTexture = true, this.renderer.context.webGLVersion === 1) {
      let nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers, nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
      settings2.PREFER_ENV === ENV.WEBGL_LEGACY && (nativeDrawBuffersExtension = null, nativeDepthTextureExtension = null), nativeDrawBuffersExtension ? gl.drawBuffers = (activeTextures) => nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures) : (this.hasMRT = false, gl.drawBuffers = () => {
      }), nativeDepthTextureExtension || (this.writeDepthTexture = false);
    } else
      this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
  }
  /**
   * Bind a framebuffer.
   * @param framebuffer
   * @param frame - frame, default is framebuffer size
   * @param mipLevel - optional mip level to set on the framebuffer - defaults to 0
   */
  bind(framebuffer, frame, mipLevel = 0) {
    const { gl } = this;
    if (framebuffer) {
      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
      this.current !== framebuffer && (this.current = framebuffer, gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer)), fbo.mipLevel !== mipLevel && (framebuffer.dirtyId++, framebuffer.dirtyFormat++, fbo.mipLevel = mipLevel), fbo.dirtyId !== framebuffer.dirtyId && (fbo.dirtyId = framebuffer.dirtyId, fbo.dirtyFormat !== framebuffer.dirtyFormat ? (fbo.dirtyFormat = framebuffer.dirtyFormat, fbo.dirtySize = framebuffer.dirtySize, this.updateFramebuffer(framebuffer, mipLevel)) : fbo.dirtySize !== framebuffer.dirtySize && (fbo.dirtySize = framebuffer.dirtySize, this.resizeFramebuffer(framebuffer)));
      for (let i3 = 0; i3 < framebuffer.colorTextures.length; i3++) {
        const tex = framebuffer.colorTextures[i3];
        this.renderer.texture.unbind(tex.parentTextureArray || tex);
      }
      if (framebuffer.depthTexture && this.renderer.texture.unbind(framebuffer.depthTexture), frame) {
        const mipWidth = frame.width >> mipLevel, mipHeight = frame.height >> mipLevel, scale3 = mipWidth / frame.width;
        this.setViewport(
          frame.x * scale3,
          frame.y * scale3,
          mipWidth,
          mipHeight
        );
      } else {
        const mipWidth = framebuffer.width >> mipLevel, mipHeight = framebuffer.height >> mipLevel;
        this.setViewport(0, 0, mipWidth, mipHeight);
      }
    } else
      this.current && (this.current = null, gl.bindFramebuffer(gl.FRAMEBUFFER, null)), frame ? this.setViewport(frame.x, frame.y, frame.width, frame.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);
  }
  /**
   * Set the WebGLRenderingContext's viewport.
   * @param x - X position of viewport
   * @param y - Y position of viewport
   * @param width - Width of viewport
   * @param height - Height of viewport
   */
  setViewport(x3, y2, width, height) {
    const v3 = this.viewport;
    x3 = Math.round(x3), y2 = Math.round(y2), width = Math.round(width), height = Math.round(height), (v3.width !== width || v3.height !== height || v3.x !== x3 || v3.y !== y2) && (v3.x = x3, v3.y = y2, v3.width = width, v3.height = height, this.gl.viewport(x3, y2, width, height));
  }
  /**
   * Get the size of the current width and height. Returns object with `width` and `height` values.
   * @readonly
   */
  get size() {
    return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
  }
  /**
   * Clear the color of the context
   * @param r - Red value from 0 to 1
   * @param g - Green value from 0 to 1
   * @param b - Blue value from 0 to 1
   * @param a - Alpha value from 0 to 1
   * @param {PIXI.BUFFER_BITS} [mask=BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH] - Bitwise OR of masks
   *  that indicate the buffers to be cleared, by default COLOR and DEPTH buffers.
   */
  clear(r2, g2, b2, a2, mask2 = BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH) {
    const { gl } = this;
    gl.clearColor(r2, g2, b2, a2), gl.clear(mask2);
  }
  /**
   * Initialize framebuffer for this context
   * @protected
   * @param framebuffer
   * @returns - created GLFramebuffer
   */
  initFramebuffer(framebuffer) {
    const { gl } = this, fbo = new GLFramebuffer(gl.createFramebuffer());
    return fbo.multisample = this.detectSamples(framebuffer.multisample), framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo, this.managedFramebuffers.push(framebuffer), framebuffer.disposeRunner.add(this), fbo;
  }
  /**
   * Resize the framebuffer
   * @param framebuffer
   * @protected
   */
  resizeFramebuffer(framebuffer) {
    const { gl } = this, fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (fbo.stencil) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      let stencilFormat;
      this.renderer.context.webGLVersion === 1 ? stencilFormat = gl.DEPTH_STENCIL : framebuffer.depth && framebuffer.stencil ? stencilFormat = gl.DEPTH24_STENCIL8 : framebuffer.depth ? stencilFormat = gl.DEPTH_COMPONENT24 : stencilFormat = gl.STENCIL_INDEX8, fbo.msaaBuffer ? gl.renderbufferStorageMultisample(
        gl.RENDERBUFFER,
        fbo.multisample,
        stencilFormat,
        framebuffer.width,
        framebuffer.height
      ) : gl.renderbufferStorage(gl.RENDERBUFFER, stencilFormat, framebuffer.width, framebuffer.height);
    }
    const colorTextures = framebuffer.colorTextures;
    let count2 = colorTextures.length;
    gl.drawBuffers || (count2 = Math.min(count2, 1));
    for (let i3 = 0; i3 < count2; i3++) {
      const texture = colorTextures[i3], parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0), i3 === 0 && fbo.msaaBuffer && (gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer), gl.renderbufferStorageMultisample(
        gl.RENDERBUFFER,
        fbo.multisample,
        parentTexture._glTextures[this.CONTEXT_UID].internalFormat,
        framebuffer.width,
        framebuffer.height
      ));
    }
    framebuffer.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(framebuffer.depthTexture, 0);
  }
  /**
   * Update the framebuffer
   * @param framebuffer
   * @param mipLevel
   * @protected
   */
  updateFramebuffer(framebuffer, mipLevel) {
    const { gl } = this, fbo = framebuffer.glFramebuffers[this.CONTEXT_UID], colorTextures = framebuffer.colorTextures;
    let count2 = colorTextures.length;
    gl.drawBuffers || (count2 = Math.min(count2, 1)), fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer) ? fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer() : fbo.msaaBuffer && (gl.deleteRenderbuffer(fbo.msaaBuffer), fbo.msaaBuffer = null, fbo.blitFramebuffer && (fbo.blitFramebuffer.dispose(), fbo.blitFramebuffer = null));
    const activeTextures = [];
    for (let i3 = 0; i3 < count2; i3++) {
      const texture = colorTextures[i3], parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0), i3 === 0 && fbo.msaaBuffer ? (gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer), gl.renderbufferStorageMultisample(
        gl.RENDERBUFFER,
        fbo.multisample,
        parentTexture._glTextures[this.CONTEXT_UID].internalFormat,
        framebuffer.width,
        framebuffer.height
      ), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer)) : (gl.framebufferTexture2D(
        gl.FRAMEBUFFER,
        gl.COLOR_ATTACHMENT0 + i3,
        texture.target,
        parentTexture._glTextures[this.CONTEXT_UID].texture,
        mipLevel
      ), activeTextures.push(gl.COLOR_ATTACHMENT0 + i3));
    }
    if (activeTextures.length > 1 && gl.drawBuffers(activeTextures), framebuffer.depthTexture && this.writeDepthTexture) {
      const depthTexture = framebuffer.depthTexture;
      this.renderer.texture.bind(depthTexture, 0), gl.framebufferTexture2D(
        gl.FRAMEBUFFER,
        gl.DEPTH_ATTACHMENT,
        gl.TEXTURE_2D,
        depthTexture._glTextures[this.CONTEXT_UID].texture,
        mipLevel
      );
    }
    if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {
      fbo.stencil = fbo.stencil || gl.createRenderbuffer();
      let stencilAttachment, stencilFormat;
      this.renderer.context.webGLVersion === 1 ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH_STENCIL) : framebuffer.depth && framebuffer.stencil ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH24_STENCIL8) : framebuffer.depth ? (stencilAttachment = gl.DEPTH_ATTACHMENT, stencilFormat = gl.DEPTH_COMPONENT24) : (stencilAttachment = gl.STENCIL_ATTACHMENT, stencilFormat = gl.STENCIL_INDEX8), gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil), fbo.msaaBuffer ? gl.renderbufferStorageMultisample(
        gl.RENDERBUFFER,
        fbo.multisample,
        stencilFormat,
        framebuffer.width,
        framebuffer.height
      ) : gl.renderbufferStorage(gl.RENDERBUFFER, stencilFormat, framebuffer.width, framebuffer.height), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, stencilAttachment, gl.RENDERBUFFER, fbo.stencil);
    } else
      fbo.stencil && (gl.deleteRenderbuffer(fbo.stencil), fbo.stencil = null);
  }
  /**
   * Returns true if the frame buffer can be multisampled.
   * @param framebuffer
   */
  canMultisampleFramebuffer(framebuffer) {
    return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;
  }
  /**
   * Detects number of samples that is not more than a param but as close to it as possible
   * @param samples - number of samples
   * @returns - recommended number of samples
   */
  detectSamples(samples) {
    const { msaaSamples } = this;
    let res = MSAA_QUALITY.NONE;
    if (samples <= 1 || msaaSamples === null)
      return res;
    for (let i3 = 0; i3 < msaaSamples.length; i3++)
      if (msaaSamples[i3] <= samples) {
        res = msaaSamples[i3];
        break;
      }
    return res === 1 && (res = MSAA_QUALITY.NONE), res;
  }
  /**
   * Only works with WebGL2
   *
   * blits framebuffer to another of the same or bigger size
   * after that target framebuffer is bound
   *
   * Fails with WebGL warning if blits multisample framebuffer to different size
   * @param framebuffer - by default it blits "into itself", from renderBuffer to texture.
   * @param sourcePixels - source rectangle in pixels
   * @param destPixels - dest rectangle in pixels, assumed to be the same as sourcePixels
   */
  blit(framebuffer, sourcePixels, destPixels) {
    const { current, renderer, gl, CONTEXT_UID } = this;
    if (renderer.context.webGLVersion !== 2 || !current)
      return;
    const fbo = current.glFramebuffers[CONTEXT_UID];
    if (!fbo)
      return;
    if (!framebuffer) {
      if (!fbo.msaaBuffer)
        return;
      const colorTexture = current.colorTextures[0];
      if (!colorTexture)
        return;
      fbo.blitFramebuffer || (fbo.blitFramebuffer = new Framebuffer(current.width, current.height), fbo.blitFramebuffer.addColorTexture(0, colorTexture)), framebuffer = fbo.blitFramebuffer, framebuffer.colorTextures[0] !== colorTexture && (framebuffer.colorTextures[0] = colorTexture, framebuffer.dirtyId++, framebuffer.dirtyFormat++), (framebuffer.width !== current.width || framebuffer.height !== current.height) && (framebuffer.width = current.width, framebuffer.height = current.height, framebuffer.dirtyId++, framebuffer.dirtySize++);
    }
    sourcePixels || (sourcePixels = tempRectangle2, sourcePixels.width = current.width, sourcePixels.height = current.height), destPixels || (destPixels = sourcePixels);
    const sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
    this.bind(framebuffer), gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer), gl.blitFramebuffer(
      sourcePixels.left,
      sourcePixels.top,
      sourcePixels.right,
      sourcePixels.bottom,
      destPixels.left,
      destPixels.top,
      destPixels.right,
      destPixels.bottom,
      gl.COLOR_BUFFER_BIT,
      sameSize ? gl.NEAREST : gl.LINEAR
    ), gl.bindFramebuffer(gl.READ_FRAMEBUFFER, framebuffer.glFramebuffers[this.CONTEXT_UID].framebuffer);
  }
  /**
   * Disposes framebuffer.
   * @param framebuffer - framebuffer that has to be disposed of
   * @param contextLost - If context was lost, we suppress all delete function calls
   */
  disposeFramebuffer(framebuffer, contextLost) {
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID], gl = this.gl;
    if (!fbo)
      return;
    delete framebuffer.glFramebuffers[this.CONTEXT_UID];
    const index = this.managedFramebuffers.indexOf(framebuffer);
    index >= 0 && this.managedFramebuffers.splice(index, 1), framebuffer.disposeRunner.remove(this), contextLost || (gl.deleteFramebuffer(fbo.framebuffer), fbo.msaaBuffer && gl.deleteRenderbuffer(fbo.msaaBuffer), fbo.stencil && gl.deleteRenderbuffer(fbo.stencil)), fbo.blitFramebuffer && this.disposeFramebuffer(fbo.blitFramebuffer, contextLost);
  }
  /**
   * Disposes all framebuffers, but not textures bound to them.
   * @param [contextLost=false] - If context was lost, we suppress all delete function calls
   */
  disposeAll(contextLost) {
    const list = this.managedFramebuffers;
    this.managedFramebuffers = [];
    for (let i3 = 0; i3 < list.length; i3++)
      this.disposeFramebuffer(list[i3], contextLost);
  }
  /**
   * Forcing creation of stencil buffer for current framebuffer, if it wasn't done before.
   * Used by MaskSystem, when its time to use stencil mask for Graphics element.
   *
   * Its an alternative for public lazy `framebuffer.enableStencil`, in case we need stencil without rebind.
   * @private
   */
  forceStencil() {
    const framebuffer = this.current;
    if (!framebuffer)
      return;
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (!fbo || fbo.stencil && framebuffer.stencil)
      return;
    framebuffer.stencil = true;
    const w2 = framebuffer.width, h2 = framebuffer.height, gl = this.gl, stencil = fbo.stencil = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
    let stencilAttachment, stencilFormat;
    this.renderer.context.webGLVersion === 1 ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH_STENCIL) : framebuffer.depth ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH24_STENCIL8) : (stencilAttachment = gl.STENCIL_ATTACHMENT, stencilFormat = gl.STENCIL_INDEX8), fbo.msaaBuffer ? gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, stencilFormat, w2, h2) : gl.renderbufferStorage(gl.RENDERBUFFER, stencilFormat, w2, h2), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, stencilAttachment, gl.RENDERBUFFER, stencil);
  }
  /** Resets framebuffer stored state, binds screen framebuffer. Should be called before renderTexture reset(). */
  reset() {
    this.current = this.unknownFramebuffer, this.viewport = new Rectangle2();
  }
  destroy() {
    this.renderer = null;
  }
};
FramebufferSystem.extension = {
  type: ExtensionType2.RendererSystem,
  name: "framebuffer"
};
extensions2.add(FramebufferSystem);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/geometry/GeometrySystem.mjs
var byteSizeMap3 = { 5126: 4, 5123: 2, 5121: 1 };
var GeometrySystem = class {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    this.renderer = renderer, this._activeGeometry = null, this._activeVao = null, this.hasVao = true, this.hasInstance = true, this.canUseUInt32ElementIndex = false, this.managedGeometries = {};
  }
  /** Sets up the renderer context and necessary buffers. */
  contextChange() {
    this.disposeAll(true);
    const gl = this.gl = this.renderer.gl, context4 = this.renderer.context;
    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, context4.webGLVersion !== 2) {
      let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;
      settings2.PREFER_ENV === ENV.WEBGL_LEGACY && (nativeVaoExtension = null), nativeVaoExtension ? (gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES(), gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao), gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao)) : (this.hasVao = false, gl.createVertexArray = () => null, gl.bindVertexArray = () => null, gl.deleteVertexArray = () => null);
    }
    if (context4.webGLVersion !== 2) {
      const instanceExt = gl.getExtension("ANGLE_instanced_arrays");
      instanceExt ? (gl.vertexAttribDivisor = (a2, b2) => instanceExt.vertexAttribDivisorANGLE(a2, b2), gl.drawElementsInstanced = (a2, b2, c2, d3, e3) => instanceExt.drawElementsInstancedANGLE(a2, b2, c2, d3, e3), gl.drawArraysInstanced = (a2, b2, c2, d3) => instanceExt.drawArraysInstancedANGLE(a2, b2, c2, d3)) : this.hasInstance = false;
    }
    this.canUseUInt32ElementIndex = context4.webGLVersion === 2 || !!context4.extensions.uint32ElementIndex;
  }
  /**
   * Binds geometry so that is can be drawn. Creating a Vao if required
   * @param geometry - Instance of geometry to bind.
   * @param shader - Instance of shader to use vao for.
   */
  bind(geometry, shader) {
    shader = shader || this.renderer.shader.shader;
    const { gl } = this;
    let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID], incRefCount = false;
    vaos || (this.managedGeometries[geometry.id] = geometry, geometry.disposeRunner.add(this), geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {}, incRefCount = true);
    const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);
    this._activeGeometry = geometry, this._activeVao !== vao && (this._activeVao = vao, this.hasVao ? gl.bindVertexArray(vao) : this.activateVao(geometry, shader.program)), this.updateBuffers();
  }
  /** Reset and unbind any active VAO and geometry. */
  reset() {
    this.unbind();
  }
  /** Update buffers of the currently bound geometry. */
  updateBuffers() {
    const geometry = this._activeGeometry, bufferSystem = this.renderer.buffer;
    for (let i3 = 0; i3 < geometry.buffers.length; i3++) {
      const buffer2 = geometry.buffers[i3];
      bufferSystem.update(buffer2);
    }
  }
  /**
   * Check compatibility between a geometry and a program
   * @param geometry - Geometry instance.
   * @param program - Program instance.
   */
  checkCompatibility(geometry, program) {
    const geometryAttributes = geometry.attributes, shaderAttributes = program.attributeData;
    for (const j3 in shaderAttributes)
      if (!geometryAttributes[j3])
        throw new Error(`shader and geometry incompatible, geometry missing the "${j3}" attribute`);
  }
  /**
   * Takes a geometry and program and generates a unique signature for them.
   * @param geometry - To get signature from.
   * @param program - To test geometry against.
   * @returns - Unique signature of the geometry and program
   */
  getSignature(geometry, program) {
    const attribs = geometry.attributes, shaderAttributes = program.attributeData, strings = ["g", geometry.id];
    for (const i3 in attribs)
      shaderAttributes[i3] && strings.push(i3, shaderAttributes[i3].location);
    return strings.join("-");
  }
  /**
   * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
   * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the
   * attribute locations.
   * @param geometry - Instance of geometry to to generate Vao for.
   * @param shader - Instance of the shader.
   * @param incRefCount - Increment refCount of all geometry buffers.
   */
  initGeometryVao(geometry, shader, incRefCount = true) {
    const gl = this.gl, CONTEXT_UID = this.CONTEXT_UID, bufferSystem = this.renderer.buffer, program = shader.program;
    program.glPrograms[CONTEXT_UID] || this.renderer.shader.generateProgram(shader), this.checkCompatibility(geometry, program);
    const signature = this.getSignature(geometry, program), vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    let vao = vaoObjectHash[signature];
    if (vao)
      return vaoObjectHash[program.id] = vao, vao;
    const buffers = geometry.buffers, attributes = geometry.attributes, tempStride = {}, tempStart = {};
    for (const j3 in buffers)
      tempStride[j3] = 0, tempStart[j3] = 0;
    for (const j3 in attributes)
      !attributes[j3].size && program.attributeData[j3] ? attributes[j3].size = program.attributeData[j3].size : attributes[j3].size || console.warn(`PIXI Geometry attribute '${j3}' size cannot be determined (likely the bound shader does not have the attribute)`), tempStride[attributes[j3].buffer] += attributes[j3].size * byteSizeMap3[attributes[j3].type];
    for (const j3 in attributes) {
      const attribute = attributes[j3], attribSize = attribute.size;
      attribute.stride === void 0 && (tempStride[attribute.buffer] === attribSize * byteSizeMap3[attribute.type] ? attribute.stride = 0 : attribute.stride = tempStride[attribute.buffer]), attribute.start === void 0 && (attribute.start = tempStart[attribute.buffer], tempStart[attribute.buffer] += attribSize * byteSizeMap3[attribute.type]);
    }
    vao = gl.createVertexArray(), gl.bindVertexArray(vao);
    for (let i3 = 0; i3 < buffers.length; i3++) {
      const buffer2 = buffers[i3];
      bufferSystem.bind(buffer2), incRefCount && buffer2._glBuffers[CONTEXT_UID].refCount++;
    }
    return this.activateVao(geometry, program), vaoObjectHash[program.id] = vao, vaoObjectHash[signature] = vao, gl.bindVertexArray(null), bufferSystem.unbind(BUFFER_TYPE2.ARRAY_BUFFER), vao;
  }
  /**
   * Disposes geometry.
   * @param geometry - Geometry with buffers. Only VAO will be disposed
   * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray
   */
  disposeGeometry(geometry, contextLost) {
    if (!this.managedGeometries[geometry.id])
      return;
    delete this.managedGeometries[geometry.id];
    const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID], gl = this.gl, buffers = geometry.buffers, bufferSystem = this.renderer?.buffer;
    if (geometry.disposeRunner.remove(this), !!vaos) {
      if (bufferSystem)
        for (let i3 = 0; i3 < buffers.length; i3++) {
          const buf = buffers[i3]._glBuffers[this.CONTEXT_UID];
          buf && (buf.refCount--, buf.refCount === 0 && !contextLost && bufferSystem.dispose(buffers[i3], contextLost));
        }
      if (!contextLost) {
        for (const vaoId in vaos)
          if (vaoId[0] === "g") {
            const vao = vaos[vaoId];
            this._activeVao === vao && this.unbind(), gl.deleteVertexArray(vao);
          }
      }
      delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
    }
  }
  /**
   * Dispose all WebGL resources of all managed geometries.
   * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls
   */
  disposeAll(contextLost) {
    const all = Object.keys(this.managedGeometries);
    for (let i3 = 0; i3 < all.length; i3++)
      this.disposeGeometry(this.managedGeometries[all[i3]], contextLost);
  }
  /**
   * Activate vertex array object.
   * @param geometry - Geometry instance.
   * @param program - Shader program instance.
   */
  activateVao(geometry, program) {
    const gl = this.gl, CONTEXT_UID = this.CONTEXT_UID, bufferSystem = this.renderer.buffer, buffers = geometry.buffers, attributes = geometry.attributes;
    geometry.indexBuffer && bufferSystem.bind(geometry.indexBuffer);
    let lastBuffer = null;
    for (const j3 in attributes) {
      const attribute = attributes[j3], buffer2 = buffers[attribute.buffer], glBuffer = buffer2._glBuffers[CONTEXT_UID];
      if (program.attributeData[j3]) {
        lastBuffer !== glBuffer && (bufferSystem.bind(buffer2), lastBuffer = glBuffer);
        const location = program.attributeData[j3].location;
        if (gl.enableVertexAttribArray(location), gl.vertexAttribPointer(
          location,
          attribute.size,
          attribute.type || gl.FLOAT,
          attribute.normalized,
          attribute.stride,
          attribute.start
        ), attribute.instance)
          if (this.hasInstance)
            gl.vertexAttribDivisor(location, attribute.divisor);
          else
            throw new Error("geometry error, GPU Instancing is not supported on this device");
      }
    }
  }
  /**
   * Draws the currently bound geometry.
   * @param type - The type primitive to render.
   * @param size - The number of elements to be rendered. If not specified, all vertices after the
   *  starting vertex will be drawn.
   * @param start - The starting vertex in the geometry to start drawing from. If not specified,
   *  drawing will start from the first vertex.
   * @param instanceCount - The number of instances of the set of elements to execute. If not specified,
   *  all instances will be drawn.
   */
  draw(type2, size3, start, instanceCount) {
    const { gl } = this, geometry = this._activeGeometry;
    if (geometry.indexBuffer) {
      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT, glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
      byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex ? geometry.instanced ? gl.drawElementsInstanced(type2, size3 || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1) : gl.drawElements(type2, size3 || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize) : console.warn("unsupported index buffer type: uint32");
    } else
      geometry.instanced ? gl.drawArraysInstanced(type2, start, size3 || geometry.getSize(), instanceCount || 1) : gl.drawArrays(type2, start, size3 || geometry.getSize());
    return this;
  }
  /** Unbind/reset everything. */
  unbind() {
    this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
  }
  destroy() {
    this.renderer = null;
  }
};
GeometrySystem.extension = {
  type: ExtensionType2.RendererSystem,
  name: "geometry"
};
extensions2.add(GeometrySystem);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/textures/TextureMatrix.mjs
var tempMat2 = new Matrix2();
var TextureMatrix2 = class {
  /**
   * @param texture - observed texture
   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
   */
  constructor(texture, clampMargin) {
    this._texture = texture, this.mapCoord = new Matrix2(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof clampMargin > "u" ? 0.5 : clampMargin, this.isSimple = false;
  }
  /** Texture property. */
  get texture() {
    return this._texture;
  }
  set texture(value) {
    this._texture = value, this._textureID = -1;
  }
  /**
   * Multiplies uvs array to transform
   * @param uvs - mesh uvs
   * @param [out=uvs] - output
   * @returns - output
   */
  multiplyUvs(uvs, out3) {
    out3 === void 0 && (out3 = uvs);
    const mat = this.mapCoord;
    for (let i3 = 0; i3 < uvs.length; i3 += 2) {
      const x3 = uvs[i3], y2 = uvs[i3 + 1];
      out3[i3] = x3 * mat.a + y2 * mat.c + mat.tx, out3[i3 + 1] = x3 * mat.b + y2 * mat.d + mat.ty;
    }
    return out3;
  }
  /**
   * Updates matrices if texture was changed.
   * @param [forceUpdate=false] - if true, matrices will be updated any case
   * @returns - Whether or not it was updated
   */
  update(forceUpdate) {
    const tex = this._texture;
    if (!tex || !tex.valid || !forceUpdate && this._textureID === tex._updateID)
      return false;
    this._textureID = tex._updateID, this._updateID++;
    const uvs = tex._uvs;
    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
    const orig = tex.orig, trim = tex.trim;
    trim && (tempMat2.set(
      orig.width / trim.width,
      0,
      0,
      orig.height / trim.height,
      -trim.x / trim.width,
      -trim.y / trim.height
    ), this.mapCoord.append(tempMat2));
    const texBase = tex.baseTexture, frame = this.uClampFrame, margin = this.clampMargin / texBase.resolution, offset = this.clampOffset;
    return frame[0] = (tex._frame.x + margin + offset) / texBase.width, frame[1] = (tex._frame.y + margin + offset) / texBase.height, frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width, frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height, this.uClampOffset[0] = offset / texBase.realWidth, this.uClampOffset[1] = offset / texBase.realHeight, this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0, true;
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter.frag.mjs
var fragment2 = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`;

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter.vert.mjs
var vertex2 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`;

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.mjs
var SpriteMaskFilter = class extends Filter2 {
  /** @ignore */
  constructor(vertexSrc, fragmentSrc, uniforms) {
    let sprite = null;
    typeof vertexSrc != "string" && fragmentSrc === void 0 && uniforms === void 0 && (sprite = vertexSrc, vertexSrc = void 0, fragmentSrc = void 0, uniforms = void 0), super(vertexSrc || vertex2, fragmentSrc || fragment2, uniforms), this.maskSprite = sprite, this.maskMatrix = new Matrix2();
  }
  /**
   * Sprite mask
   * @type {PIXI.DisplayObject}
   */
  get maskSprite() {
    return this._maskSprite;
  }
  set maskSprite(value) {
    this._maskSprite = value, this._maskSprite && (this._maskSprite.renderable = false);
  }
  /**
   * Applies the filter
   * @param filterManager - The renderer to retrieve the filter from
   * @param input - The input render target.
   * @param output - The target to output to.
   * @param clearMode - Should the output be cleared before rendering to it.
   */
  apply(filterManager, input, output, clearMode) {
    const maskSprite = this._maskSprite, tex = maskSprite._texture;
    tex.valid && (tex.uvMatrix || (tex.uvMatrix = new TextureMatrix2(tex, 0)), tex.uvMatrix.update(), this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = tex, this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord), this.uniforms.alpha = maskSprite.worldAlpha, this.uniforms.maskClamp = tex.uvMatrix.uClampFrame, filterManager.applyFilter(this, input, output, clearMode));
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/mask/MaskData.mjs
var MaskData = class {
  /**
   * Create MaskData
   * @param {PIXI.DisplayObject} [maskObject=null] - object that describes the mask
   */
  constructor(maskObject = null) {
    this.type = MASK_TYPES.NONE, this.autoDetect = true, this.maskObject = maskObject || null, this.pooled = false, this.isMaskData = true, this.resolution = null, this.multisample = Filter2.defaultMultisample, this.enabled = true, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null;
  }
  /**
   * The sprite mask filter.
   * If set to `null`, the default sprite mask filter is used.
   * @default null
   */
  get filter() {
    return this._filters ? this._filters[0] : null;
  }
  set filter(value) {
    value ? this._filters ? this._filters[0] = value : this._filters = [value] : this._filters = null;
  }
  /** Resets the mask data after popMask(). */
  reset() {
    this.pooled && (this.maskObject = null, this.type = MASK_TYPES.NONE, this.autoDetect = true), this._target = null, this._scissorRectLocal = null;
  }
  /**
   * Copies counters from maskData above, called from pushMask().
   * @param maskAbove
   */
  copyCountersOrReset(maskAbove) {
    maskAbove ? (this._stencilCounter = maskAbove._stencilCounter, this._scissorCounter = maskAbove._scissorCounter, this._scissorRect = maskAbove._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/mask/MaskSystem.mjs
var MaskSystem = class {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.enableScissor = true, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;
  }
  /**
   * Changes the mask stack that is used by this System.
   * @param maskStack - The mask stack
   */
  setMaskStack(maskStack) {
    this.maskStack = maskStack, this.renderer.scissor.setMaskStack(maskStack), this.renderer.stencil.setMaskStack(maskStack);
  }
  /**
   * Enables the mask and appends it to the current mask stack.
   *
   * NOTE: The batch renderer should be flushed beforehand to prevent pending renders from being masked.
   * @param {PIXI.DisplayObject} target - Display Object to push the mask to
   * @param {PIXI.MaskData|PIXI.Sprite|PIXI.Graphics|PIXI.DisplayObject} maskDataOrTarget - The masking data.
   */
  push(target, maskDataOrTarget) {
    let maskData = maskDataOrTarget;
    if (!maskData.isMaskData) {
      const d3 = this.maskDataPool.pop() || new MaskData();
      d3.pooled = true, d3.maskObject = maskDataOrTarget, maskData = d3;
    }
    const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
    if (maskData.copyCountersOrReset(maskAbove), maskData._colorMask = maskAbove ? maskAbove._colorMask : 15, maskData.autoDetect && this.detect(maskData), maskData._target = target, maskData.type !== MASK_TYPES.SPRITE && this.maskStack.push(maskData), maskData.enabled)
      switch (maskData.type) {
        case MASK_TYPES.SCISSOR:
          this.renderer.scissor.push(maskData);
          break;
        case MASK_TYPES.STENCIL:
          this.renderer.stencil.push(maskData);
          break;
        case MASK_TYPES.SPRITE:
          maskData.copyCountersOrReset(null), this.pushSpriteMask(maskData);
          break;
        case MASK_TYPES.COLOR:
          this.pushColorMask(maskData);
          break;
        default:
          break;
      }
    maskData.type === MASK_TYPES.SPRITE && this.maskStack.push(maskData);
  }
  /**
   * Removes the last mask from the mask stack and doesn't return it.
   *
   * NOTE: The batch renderer should be flushed beforehand to render the masked contents before the mask is removed.
   * @param {PIXI.IMaskTarget} target - Display Object to pop the mask from
   */
  pop(target) {
    const maskData = this.maskStack.pop();
    if (!(!maskData || maskData._target !== target)) {
      if (maskData.enabled)
        switch (maskData.type) {
          case MASK_TYPES.SCISSOR:
            this.renderer.scissor.pop(maskData);
            break;
          case MASK_TYPES.STENCIL:
            this.renderer.stencil.pop(maskData.maskObject);
            break;
          case MASK_TYPES.SPRITE:
            this.popSpriteMask(maskData);
            break;
          case MASK_TYPES.COLOR:
            this.popColorMask(maskData);
            break;
          default:
            break;
        }
      if (maskData.reset(), maskData.pooled && this.maskDataPool.push(maskData), this.maskStack.length !== 0) {
        const maskCurrent = this.maskStack[this.maskStack.length - 1];
        maskCurrent.type === MASK_TYPES.SPRITE && maskCurrent._filters && (maskCurrent._filters[0].maskSprite = maskCurrent.maskObject);
      }
    }
  }
  /**
   * Sets type of MaskData based on its maskObject.
   * @param maskData
   */
  detect(maskData) {
    const maskObject = maskData.maskObject;
    maskObject ? maskObject.isSprite ? maskData.type = MASK_TYPES.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(maskData) ? maskData.type = MASK_TYPES.SCISSOR : maskData.type = MASK_TYPES.STENCIL : maskData.type = MASK_TYPES.COLOR;
  }
  /**
   * Applies the Mask and adds it to the current filter stack.
   * @param maskData - Sprite to be used as the mask.
   */
  pushSpriteMask(maskData) {
    const { maskObject } = maskData, target = maskData._target;
    let alphaMaskFilter = maskData._filters;
    alphaMaskFilter || (alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex], alphaMaskFilter || (alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()])), alphaMaskFilter[0].resolution = maskData.resolution, alphaMaskFilter[0].multisample = maskData.multisample, alphaMaskFilter[0].maskSprite = maskObject;
    const stashFilterArea = target.filterArea;
    target.filterArea = maskObject.getBounds(true), this.renderer.filter.push(target, alphaMaskFilter), target.filterArea = stashFilterArea, maskData._filters || this.alphaMaskIndex++;
  }
  /**
   * Removes the last filter from the filter stack and doesn't return it.
   * @param maskData - Sprite to be used as the mask.
   */
  popSpriteMask(maskData) {
    this.renderer.filter.pop(), maskData._filters ? maskData._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);
  }
  /**
   * Pushes the color mask.
   * @param maskData - The mask data
   */
  pushColorMask(maskData) {
    const currColorMask = maskData._colorMask, nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;
    nextColorMask !== currColorMask && this.renderer.gl.colorMask(
      (nextColorMask & 1) !== 0,
      (nextColorMask & 2) !== 0,
      (nextColorMask & 4) !== 0,
      (nextColorMask & 8) !== 0
    );
  }
  /**
   * Pops the color mask.
   * @param maskData - The mask data
   */
  popColorMask(maskData) {
    const currColorMask = maskData._colorMask, nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
    nextColorMask !== currColorMask && this.renderer.gl.colorMask(
      (nextColorMask & 1) !== 0,
      (nextColorMask & 2) !== 0,
      (nextColorMask & 4) !== 0,
      (nextColorMask & 8) !== 0
    );
  }
  destroy() {
    this.renderer = null;
  }
};
MaskSystem.extension = {
  type: ExtensionType2.RendererSystem,
  name: "mask"
};
extensions2.add(MaskSystem);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/mask/AbstractMaskSystem.mjs
var AbstractMaskSystem = class {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.maskStack = [], this.glConst = 0;
  }
  /** Gets count of masks of certain type. */
  getStackLength() {
    return this.maskStack.length;
  }
  /**
   * Changes the mask stack that is used by this System.
   * @param {PIXI.MaskData[]} maskStack - The mask stack
   */
  setMaskStack(maskStack) {
    const { gl } = this.renderer, curStackLen = this.getStackLength();
    this.maskStack = maskStack;
    const newStackLen = this.getStackLength();
    newStackLen !== curStackLen && (newStackLen === 0 ? gl.disable(this.glConst) : (gl.enable(this.glConst), this._useCurrent()));
  }
  /**
   * Setup renderer to use the current mask data.
   * @private
   */
  _useCurrent() {
  }
  /** Destroys the mask stack. */
  destroy() {
    this.renderer = null, this.maskStack = null;
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/mask/ScissorSystem.mjs
var tempMatrix5 = new Matrix2();
var rectPool = [];
var _ScissorSystem = class _ScissorSystem2 extends AbstractMaskSystem {
  /**
   * @param {PIXI.Renderer} renderer - The renderer this System works for.
   */
  constructor(renderer) {
    super(renderer), this.glConst = settings2.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;
  }
  getStackLength() {
    const maskData = this.maskStack[this.maskStack.length - 1];
    return maskData ? maskData._scissorCounter : 0;
  }
  /**
   * evaluates _boundsTransformed, _scissorRect for MaskData
   * @param maskData
   */
  calcScissorRect(maskData) {
    if (maskData._scissorRectLocal)
      return;
    const prevData = maskData._scissorRect, { maskObject } = maskData, { renderer } = this, renderTextureSystem = renderer.renderTexture, rect = maskObject.getBounds(true, rectPool.pop() ?? new Rectangle2());
    this.roundFrameToPixels(
      rect,
      renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,
      renderTextureSystem.sourceFrame,
      renderTextureSystem.destinationFrame,
      renderer.projection.transform
    ), prevData && rect.fit(prevData), maskData._scissorRectLocal = rect;
  }
  static isMatrixRotated(matrix) {
    if (!matrix)
      return false;
    const { a: a2, b: b2, c: c2, d: d3 } = matrix;
    return (Math.abs(b2) > 1e-4 || Math.abs(c2) > 1e-4) && (Math.abs(a2) > 1e-4 || Math.abs(d3) > 1e-4);
  }
  /**
   * Test, whether the object can be scissor mask with current renderer projection.
   * Calls "calcScissorRect()" if its true.
   * @param maskData - mask data
   * @returns whether Whether the object can be scissor mask
   */
  testScissor(maskData) {
    const { maskObject } = maskData;
    if (!maskObject.isFastRect || !maskObject.isFastRect() || _ScissorSystem2.isMatrixRotated(maskObject.worldTransform) || _ScissorSystem2.isMatrixRotated(this.renderer.projection.transform))
      return false;
    this.calcScissorRect(maskData);
    const rect = maskData._scissorRectLocal;
    return rect.width > 0 && rect.height > 0;
  }
  roundFrameToPixels(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    _ScissorSystem2.isMatrixRotated(transform) || (transform = transform ? tempMatrix5.copyFrom(transform) : tempMatrix5.identity(), transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(
      bindingDestinationFrame.width / bindingSourceFrame.width,
      bindingDestinationFrame.height / bindingSourceFrame.height
    ).translate(bindingDestinationFrame.x, bindingDestinationFrame.y), this.renderer.filter.transformAABB(transform, frame), frame.fit(bindingDestinationFrame), frame.x = Math.round(frame.x * resolution), frame.y = Math.round(frame.y * resolution), frame.width = Math.round(frame.width * resolution), frame.height = Math.round(frame.height * resolution));
  }
  /**
   * Applies the Mask and adds it to the current stencil stack.
   * @author alvin
   * @param maskData - The mask data.
   */
  push(maskData) {
    maskData._scissorRectLocal || this.calcScissorRect(maskData);
    const { gl } = this.renderer;
    maskData._scissorRect || gl.enable(gl.SCISSOR_TEST), maskData._scissorCounter++, maskData._scissorRect = maskData._scissorRectLocal, this._useCurrent();
  }
  /**
   * This should be called after a mask is popped off the mask stack. It will rebind the scissor box to be latest with the
   * last mask in the stack.
   *
   * This can also be called when you directly modify the scissor box and want to restore PixiJS state.
   * @param maskData - The mask data.
   */
  pop(maskData) {
    const { gl } = this.renderer;
    maskData && rectPool.push(maskData._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : gl.disable(gl.SCISSOR_TEST);
  }
  /**
   * Setup renderer to use the current scissor data.
   * @private
   */
  _useCurrent() {
    const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
    let y2;
    this.renderer.renderTexture.current ? y2 = rect.y : y2 = this.renderer.height - rect.height - rect.y, this.renderer.gl.scissor(rect.x, y2, rect.width, rect.height);
  }
};
_ScissorSystem.extension = {
  type: ExtensionType2.RendererSystem,
  name: "scissor"
};
var ScissorSystem = _ScissorSystem;
extensions2.add(ScissorSystem);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/mask/StencilSystem.mjs
var StencilSystem = class extends AbstractMaskSystem {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    super(renderer), this.glConst = settings2.ADAPTER.getWebGLRenderingContext().STENCIL_TEST;
  }
  getStackLength() {
    const maskData = this.maskStack[this.maskStack.length - 1];
    return maskData ? maskData._stencilCounter : 0;
  }
  /**
   * Applies the Mask and adds it to the current stencil stack.
   * @param maskData - The mask data
   */
  push(maskData) {
    const maskObject = maskData.maskObject, { gl } = this.renderer, prevMaskCount = maskData._stencilCounter;
    prevMaskCount === 0 && (this.renderer.framebuffer.forceStencil(), gl.clearStencil(0), gl.clear(gl.STENCIL_BUFFER_BIT), gl.enable(gl.STENCIL_TEST)), maskData._stencilCounter++;
    const colorMask = maskData._colorMask;
    colorMask !== 0 && (maskData._colorMask = 0, gl.colorMask(false, false, false, false)), gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295), gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR), maskObject.renderable = true, maskObject.render(this.renderer), this.renderer.batch.flush(), maskObject.renderable = false, colorMask !== 0 && (maskData._colorMask = colorMask, gl.colorMask(
      (colorMask & 1) !== 0,
      (colorMask & 2) !== 0,
      (colorMask & 4) !== 0,
      (colorMask & 8) !== 0
    )), this._useCurrent();
  }
  /**
   * Pops stencil mask. MaskData is already removed from stack
   * @param {PIXI.DisplayObject} maskObject - object of popped mask data
   */
  pop(maskObject) {
    const gl = this.renderer.gl;
    if (this.getStackLength() === 0)
      gl.disable(gl.STENCIL_TEST);
    else {
      const maskData = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null, colorMask = maskData ? maskData._colorMask : 15;
      colorMask !== 0 && (maskData._colorMask = 0, gl.colorMask(false, false, false, false)), gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR), maskObject.renderable = true, maskObject.render(this.renderer), this.renderer.batch.flush(), maskObject.renderable = false, colorMask !== 0 && (maskData._colorMask = colorMask, gl.colorMask(
        (colorMask & 1) !== 0,
        (colorMask & 2) !== 0,
        (colorMask & 4) !== 0,
        (colorMask & 8) !== 0
      )), this._useCurrent();
    }
  }
  /**
   * Setup renderer to use the current stencil data.
   * @private
   */
  _useCurrent() {
    const gl = this.renderer.gl;
    gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295), gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
  }
};
StencilSystem.extension = {
  type: ExtensionType2.RendererSystem,
  name: "stencil"
};
extensions2.add(StencilSystem);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/plugin/PluginSystem.mjs
var PluginSystem = class {
  constructor(renderer) {
    this.renderer = renderer, this.plugins = {}, Object.defineProperties(this.plugins, {
      extract: {
        enumerable: false,
        get() {
          return deprecation2("7.0.0", "renderer.plugins.extract has moved to renderer.extract"), renderer.extract;
        }
      },
      prepare: {
        enumerable: false,
        get() {
          return deprecation2("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare"), renderer.prepare;
        }
      },
      interaction: {
        enumerable: false,
        get() {
          return deprecation2("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events"), renderer.events;
        }
      }
    });
  }
  /**
   * Initialize the plugins.
   * @protected
   */
  init() {
    const staticMap = this.rendererPlugins;
    for (const o2 in staticMap)
      this.plugins[o2] = new staticMap[o2](this.renderer);
  }
  destroy() {
    for (const o2 in this.plugins)
      this.plugins[o2].destroy(), this.plugins[o2] = null;
  }
};
PluginSystem.extension = {
  type: [
    ExtensionType2.RendererSystem,
    ExtensionType2.CanvasRendererSystem
  ],
  name: "_plugin"
};
extensions2.add(PluginSystem);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/projection/ProjectionSystem.mjs
var ProjectionSystem = class {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    this.renderer = renderer, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new Matrix2(), this.transform = null;
  }
  /**
   * Updates the projection-matrix based on the sourceFrame → destinationFrame mapping provided.
   *
   * NOTE: It is expected you call `renderer.framebuffer.setViewport(destinationFrame)` after this. This is because
   * the framebuffer viewport converts shader vertex output in normalized device coordinates to window coordinates.
   *
   * NOTE-2: {@link PIXI.RenderTextureSystem#bind} updates the projection-matrix when you bind a render-texture.
   * It is expected
   * that you dirty the current bindings when calling this manually.
   * @param destinationFrame - The rectangle in the render-target to render the contents into. If rendering to the canvas,
   *  the origin is on the top-left; if rendering to a render-texture, the origin is on the bottom-left.
   * @param sourceFrame - The rectangle in world space that contains the contents being rendered.
   * @param resolution - The resolution of the render-target, which is the ratio of
   *  world-space (or CSS) pixels to physical pixels.
   * @param root - Whether the render-target is the screen. This is required because rendering to textures
   *  is y-flipped (i.e. upside down relative to the screen).
   */
  update(destinationFrame, sourceFrame, resolution, root) {
    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame, this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame, this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root), this.transform && this.projectionMatrix.append(this.transform);
    const renderer = this.renderer;
    renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, renderer.globalUniforms.update(), renderer.shader.shader && renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
  }
  /**
   * Calculates the `projectionMatrix` to map points inside `sourceFrame` to inside `destinationFrame`.
   * @param _destinationFrame - The destination frame in the render-target.
   * @param sourceFrame - The source frame in world space.
   * @param _resolution - The render-target's resolution, i.e. ratio of CSS to physical pixels.
   * @param root - Whether rendering into the screen. Otherwise, if rendering to a framebuffer, the projection
   *  is y-flipped.
   */
  calculateProjection(_destinationFrame, sourceFrame, _resolution, root) {
    const pm = this.projectionMatrix, sign2 = root ? -1 : 1;
    pm.identity(), pm.a = 1 / sourceFrame.width * 2, pm.d = sign2 * (1 / sourceFrame.height * 2), pm.tx = -1 - sourceFrame.x * pm.a, pm.ty = -sign2 - sourceFrame.y * pm.d;
  }
  /**
   * Sets the transform of the active render target to the given matrix.
   * @param _matrix - The transformation matrix
   */
  setTransform(_matrix) {
  }
  destroy() {
    this.renderer = null;
  }
};
ProjectionSystem.extension = {
  type: ExtensionType2.RendererSystem,
  name: "projection"
};
extensions2.add(ProjectionSystem);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.mjs
var tempTransform = new Transform2();
var tempRect3 = new Rectangle2();
var GenerateTextureSystem2 = class {
  constructor(renderer) {
    this.renderer = renderer, this._tempMatrix = new Matrix2();
  }
  /**
   * A Useful function that returns a texture of the display object that can then be used to create sprites
   * This can be quite useful if your displayObject is complicated and needs to be reused multiple times.
   * @param displayObject - The displayObject the object will be generated from.
   * @param {IGenerateTextureOptions} options - Generate texture options.
   * @param {PIXI.Rectangle} options.region - The region of the displayObject, that shall be rendered,
   *        if no region is specified, defaults to the local bounds of the displayObject.
   * @param {number} [options.resolution] - If not given, the renderer's resolution is used.
   * @param {PIXI.MSAA_QUALITY} [options.multisample] - If not given, the renderer's multisample is used.
   * @returns a shiny new texture of the display object passed in
   */
  generateTexture(displayObject, options) {
    const { region: manualRegion, ...textureOptions } = options || {}, region = manualRegion?.copyTo(tempRect3) || displayObject.getLocalBounds(tempRect3, true), resolution = textureOptions.resolution || this.renderer.resolution;
    region.width = Math.max(region.width, 1 / resolution), region.height = Math.max(region.height, 1 / resolution), textureOptions.width = region.width, textureOptions.height = region.height, textureOptions.resolution = resolution, textureOptions.multisample ?? (textureOptions.multisample = this.renderer.multisample);
    const renderTexture = RenderTexture2.create(textureOptions);
    this._tempMatrix.tx = -region.x, this._tempMatrix.ty = -region.y;
    const transform = displayObject.transform;
    return displayObject.transform = tempTransform, this.renderer.render(displayObject, {
      renderTexture,
      transform: this._tempMatrix,
      skipUpdateTransform: !!displayObject.parent,
      blit: true
    }), displayObject.transform = transform, renderTexture;
  }
  destroy() {
  }
};
GenerateTextureSystem2.extension = {
  type: [
    ExtensionType2.RendererSystem,
    ExtensionType2.CanvasRendererSystem
  ],
  name: "textureGenerator"
};
extensions2.add(GenerateTextureSystem2);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.mjs
var tempRect4 = new Rectangle2();
var tempRect22 = new Rectangle2();
var RenderTextureSystem = class {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new Rectangle2(), this.destinationFrame = new Rectangle2(), this.viewportFrame = new Rectangle2();
  }
  contextChange() {
    const attributes = this.renderer?.gl.getContextAttributes();
    this._rendererPremultipliedAlpha = !!(attributes && attributes.alpha && attributes.premultipliedAlpha);
  }
  /**
   * Bind the current render texture.
   * @param renderTexture - RenderTexture to bind, by default its `null` - the screen.
   * @param sourceFrame - Part of world that is mapped to the renderTexture.
   * @param destinationFrame - Part of renderTexture, by default it has the same size as sourceFrame.
   */
  bind(renderTexture = null, sourceFrame, destinationFrame) {
    const renderer = this.renderer;
    this.current = renderTexture;
    let baseTexture, framebuffer, resolution;
    renderTexture ? (baseTexture = renderTexture.baseTexture, resolution = baseTexture.resolution, sourceFrame || (tempRect4.width = renderTexture.frame.width, tempRect4.height = renderTexture.frame.height, sourceFrame = tempRect4), destinationFrame || (tempRect22.x = renderTexture.frame.x, tempRect22.y = renderTexture.frame.y, tempRect22.width = sourceFrame.width, tempRect22.height = sourceFrame.height, destinationFrame = tempRect22), framebuffer = baseTexture.framebuffer) : (resolution = renderer.resolution, sourceFrame || (tempRect4.width = renderer._view.screen.width, tempRect4.height = renderer._view.screen.height, sourceFrame = tempRect4), destinationFrame || (destinationFrame = tempRect4, destinationFrame.width = sourceFrame.width, destinationFrame.height = sourceFrame.height));
    const viewportFrame = this.viewportFrame;
    viewportFrame.x = destinationFrame.x * resolution, viewportFrame.y = destinationFrame.y * resolution, viewportFrame.width = destinationFrame.width * resolution, viewportFrame.height = destinationFrame.height * resolution, renderTexture || (viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height)), viewportFrame.ceil(), this.renderer.framebuffer.bind(framebuffer, viewportFrame), this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer), renderTexture ? this.renderer.mask.setMaskStack(baseTexture.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(sourceFrame), this.destinationFrame.copyFrom(destinationFrame);
  }
  /**
   * Erases the render texture and fills the drawing area with a colour.
   * @param clearColor - The color as rgba, default to use the renderer backgroundColor
   * @param [mask=BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH] - Bitwise OR of masks
   *  that indicate the buffers to be cleared, by default COLOR and DEPTH buffers.
   */
  clear(clearColor, mask2) {
    const fallbackColor = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor, color = Color2.shared.setValue(clearColor || fallbackColor);
    (this.current && this.current.baseTexture.alphaMode > 0 || !this.current && this._rendererPremultipliedAlpha) && color.premultiply(color.alpha);
    const destinationFrame = this.destinationFrame, baseFrame = this.current ? this.current.baseTexture : this.renderer._view.screen, clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;
    if (clearMask) {
      let { x: x3, y: y2, width, height } = this.viewportFrame;
      x3 = Math.round(x3), y2 = Math.round(y2), width = Math.round(width), height = Math.round(height), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(x3, y2, width, height);
    }
    this.renderer.framebuffer.clear(color.red, color.green, color.blue, color.alpha, mask2), clearMask && this.renderer.scissor.pop();
  }
  resize() {
    this.bind(null);
  }
  /** Resets render-texture state. */
  reset() {
    this.bind(null);
  }
  destroy() {
    this.renderer = null;
  }
};
RenderTextureSystem.extension = {
  type: ExtensionType2.RendererSystem,
  name: "renderTexture"
};
extensions2.add(RenderTextureSystem);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/GLProgram.mjs
var GLProgram = class {
  /**
   * Makes a new Pixi program.
   * @param program - webgl program
   * @param uniformData - uniforms
   */
  constructor(program, uniformData) {
    this.program = program, this.uniformData = uniformData, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};
  }
  /** Destroys this program. */
  destroy() {
    this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/utils/getAttributeData.mjs
function getAttributeData2(program, gl) {
  const attributes = {}, totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i3 = 0; i3 < totalAttributes; i3++) {
    const attribData = gl.getActiveAttrib(program, i3);
    if (attribData.name.startsWith("gl_"))
      continue;
    const type2 = mapType2(gl, attribData.type), data = {
      type: type2,
      name: attribData.name,
      size: mapSize2(type2),
      location: gl.getAttribLocation(program, attribData.name)
    };
    attributes[attribData.name] = data;
  }
  return attributes;
}

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/utils/getUniformData.mjs
function getUniformData2(program, gl) {
  const uniforms = {}, totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i3 = 0; i3 < totalUniforms; i3++) {
    const uniformData = gl.getActiveUniform(program, i3), name = uniformData.name.replace(/\[.*?\]$/, ""), isArray = !!uniformData.name.match(/\[.*?\]$/), type2 = mapType2(gl, uniformData.type);
    uniforms[name] = {
      name,
      index: i3,
      type: type2,
      size: uniformData.size,
      isArray,
      value: defaultValue2(type2, uniformData.size)
    };
  }
  return uniforms;
}

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/utils/generateProgram.mjs
function generateProgram2(gl, program) {
  const glVertShader = compileShader2(gl, gl.VERTEX_SHADER, program.vertexSrc), glFragShader = compileShader2(gl, gl.FRAGMENT_SHADER, program.fragmentSrc), webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader), gl.attachShader(webGLProgram, glFragShader);
  const transformFeedbackVaryings = program.extra?.transformFeedbackVaryings;
  if (transformFeedbackVaryings && (typeof gl.transformFeedbackVaryings != "function" ? console.warn("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : gl.transformFeedbackVaryings(
    webGLProgram,
    transformFeedbackVaryings.names,
    transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS
  )), gl.linkProgram(webGLProgram), gl.getProgramParameter(webGLProgram, gl.LINK_STATUS) || logProgramError2(gl, webGLProgram, glVertShader, glFragShader), program.attributeData = getAttributeData2(webGLProgram, gl), program.uniformData = getUniformData2(webGLProgram, gl), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)) {
    const keys = Object.keys(program.attributeData);
    keys.sort((a2, b2) => a2 > b2 ? 1 : -1);
    for (let i3 = 0; i3 < keys.length; i3++)
      program.attributeData[keys[i3]].location = i3, gl.bindAttribLocation(webGLProgram, i3, keys[i3]);
    gl.linkProgram(webGLProgram);
  }
  gl.deleteShader(glVertShader), gl.deleteShader(glFragShader);
  const uniformData = {};
  for (const i3 in program.uniformData) {
    const data = program.uniformData[i3];
    uniformData[i3] = {
      location: gl.getUniformLocation(webGLProgram, i3),
      value: defaultValue2(data.type, data.size)
    };
  }
  return new GLProgram(webGLProgram, uniformData);
}

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.mjs
function uboUpdate(_ud, _uv, _renderer, _syncData, buffer2) {
  _renderer.buffer.update(buffer2);
}
var UBO_TO_SINGLE_SETTERS2 = {
  float: `
        data[offset] = v;
    `,
  vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
  vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
  vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
  mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
  mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
  mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
};
var GLSL_TO_STD40_SIZE = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function createUBOElements2(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    dataLen: 0,
    dirty: 0
  }));
  let size3 = 0, chunkSize = 0, offset = 0;
  for (let i3 = 0; i3 < uboElements.length; i3++) {
    const uboElement = uboElements[i3];
    if (size3 = GLSL_TO_STD40_SIZE[uboElement.data.type], uboElement.data.size > 1 && (size3 = Math.max(size3, 16) * uboElement.data.size), uboElement.dataLen = size3, chunkSize % size3 !== 0 && chunkSize < 16) {
      const lineUpValue = chunkSize % size3 % 16;
      chunkSize += lineUpValue, offset += lineUpValue;
    }
    chunkSize + size3 > 16 ? (offset = Math.ceil(offset / 16) * 16, uboElement.offset = offset, offset += size3, chunkSize = size3) : (uboElement.offset = offset, chunkSize += size3, offset += size3);
  }
  return offset = Math.ceil(offset / 16) * 16, { uboElements, size: offset };
}
function getUBOData(uniforms, uniformData) {
  const usedUniformDatas = [];
  for (const i3 in uniforms)
    uniformData[i3] && usedUniformDatas.push(uniformData[i3]);
  return usedUniformDatas.sort((a2, b2) => a2.index - b2.index), usedUniformDatas;
}
function generateUniformBufferSync2(group, uniformData) {
  if (!group.autoManage)
    return { size: 0, syncFunc: uboUpdate };
  const usedUniformDatas = getUBOData(group.uniforms, uniformData), { uboElements, size: size3 } = createUBOElements2(usedUniformDatas), funcFragments = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `];
  for (let i3 = 0; i3 < uboElements.length; i3++) {
    const uboElement = uboElements[i3], uniform = group.uniforms[uboElement.data.name], name = uboElement.data.name;
    let parsed = false;
    for (let j3 = 0; j3 < uniformParsers2.length; j3++) {
      const uniformParser = uniformParsers2[j3];
      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {
        funcFragments.push(
          `offset = ${uboElement.offset / 4};`,
          uniformParsers2[j3].codeUbo(uboElement.data.name, uniform)
        ), parsed = true;
        break;
      }
    }
    if (!parsed)
      if (uboElement.data.size > 1) {
        const size22 = mapSize2(uboElement.data.type), rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1), elementSize = size22 / rowSize, remainder = (4 - elementSize % 4) % 4;
        funcFragments.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};

                t = 0;

                for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
                {
                    for(var j = 0; j < ${elementSize}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${remainder};
                }

                `);
      } else {
        const template = UBO_TO_SINGLE_SETTERS2[uboElement.data.type];
        funcFragments.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};
                ${template};
                `);
      }
  }
  return funcFragments.push(`
       renderer.buffer.update(buffer);
    `), {
    size: size3,
    // eslint-disable-next-line no-new-func
    syncFunc: new Function(
      "ud",
      "uv",
      "renderer",
      "syncData",
      "buffer",
      funcFragments.join(`
`)
    )
  };
}

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/shader/ShaderSystem.mjs
var UID5 = 0;
var defaultSyncData2 = { textureCount: 0, uboCount: 0 };
var ShaderSystem = class {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    this.destroyed = false, this.renderer = renderer, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = UID5++;
  }
  /**
   * Overrideable function by `@pixi/unsafe-eval` to silence
   * throwing an error if platform doesn't support unsafe-evals.
   * @private
   */
  systemCheck() {
    if (!unsafeEvalSupported2())
      throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
  }
  contextChange(gl) {
    this.gl = gl, this.reset();
  }
  /**
   * Changes the current shader to the one given in parameter.
   * @param shader - the new shader
   * @param dontSync - false if the shader should automatically sync its uniforms.
   * @returns the glProgram that belongs to the shader.
   */
  bind(shader, dontSync) {
    shader.disposeRunner.add(this), shader.uniforms.globals = this.renderer.globalUniforms;
    const program = shader.program, glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);
    return this.shader = shader, this.program !== program && (this.program = program, this.gl.useProgram(glProgram.program)), dontSync || (defaultSyncData2.textureCount = 0, defaultSyncData2.uboCount = 0, this.syncUniformGroup(shader.uniformGroup, defaultSyncData2)), glProgram;
  }
  /**
   * Uploads the uniforms values to the currently bound shader.
   * @param uniforms - the uniforms values that be applied to the current shader
   */
  setUniforms(uniforms) {
    const shader = this.shader.program, glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
    shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
  }
  /* eslint-disable @typescript-eslint/explicit-module-boundary-types */
  /**
   * Syncs uniforms on the group
   * @param group - the uniform group to sync
   * @param syncData - this is data that is passed to the sync function and any nested sync functions
   */
  syncUniformGroup(group, syncData) {
    const glProgram = this.getGlProgram();
    (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) && (glProgram.uniformDirtyGroups[group.id] = group.dirtyId, this.syncUniforms(group, glProgram, syncData));
  }
  /**
   * Overrideable by the @pixi/unsafe-eval package to use static syncUniforms instead.
   * @param group
   * @param glProgram
   * @param syncData
   */
  syncUniforms(group, glProgram, syncData) {
    (group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group))(glProgram.uniformData, group.uniforms, this.renderer, syncData);
  }
  createSyncGroups(group) {
    const id = this.getSignature(group, this.shader.program.uniformData, "u");
    return this.cache[id] || (this.cache[id] = generateUniformsSync2(group, this.shader.program.uniformData)), group.syncUniforms[this.shader.program.id] = this.cache[id], group.syncUniforms[this.shader.program.id];
  }
  /**
   * Syncs uniform buffers
   * @param group - the uniform buffer group to sync
   * @param name - the name of the uniform buffer
   */
  syncUniformBufferGroup(group, name) {
    const glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {
      group.dirtyId = 0;
      const syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);
      group.buffer.update(), syncFunc(
        glProgram.uniformData,
        group.uniforms,
        this.renderer,
        defaultSyncData2,
        group.buffer
      );
    }
    this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);
  }
  /**
   * Will create a function that uploads a uniform buffer using the STD140 standard.
   * The upload function will then be cached for future calls
   * If a group is manually managed, then a simple upload function is generated
   * @param group - the uniform buffer group to sync
   * @param glProgram - the gl program to attach the uniform bindings to
   * @param name - the name of the uniform buffer (must exist on the shader)
   */
  createSyncBufferGroup(group, glProgram, name) {
    const { gl } = this.renderer;
    this.renderer.buffer.bind(group.buffer);
    const uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);
    glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount, gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount), this.shader.uniformBindCount++;
    const id = this.getSignature(group, this.shader.program.uniformData, "ubo");
    let uboData = this._uboCache[id];
    if (uboData || (uboData = this._uboCache[id] = generateUniformBufferSync2(group, this.shader.program.uniformData)), group.autoManage) {
      const data = new Float32Array(uboData.size / 4);
      group.buffer.update(data);
    }
    return glProgram.uniformGroups[group.id] = uboData.syncFunc, glProgram.uniformGroups[group.id];
  }
  /**
   * Takes a uniform group and data and generates a unique signature for them.
   * @param group - The uniform group to get signature of
   * @param group.uniforms
   * @param uniformData - Uniform information generated by the shader
   * @param preFix
   * @returns Unique signature of the uniform group
   */
  getSignature(group, uniformData, preFix) {
    const uniforms = group.uniforms, strings = [`${preFix}-`];
    for (const i3 in uniforms)
      strings.push(i3), uniformData[i3] && strings.push(uniformData[i3].type);
    return strings.join("-");
  }
  /**
   * Returns the underlying GLShade rof the currently bound shader.
   *
   * This can be handy for when you to have a little more control over the setting of your uniforms.
   * @returns The glProgram for the currently bound Shader for this context
   */
  getGlProgram() {
    return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;
  }
  /**
   * Generates a glProgram version of the Shader provided.
   * @param shader - The shader that the glProgram will be based on.
   * @returns A shiny new glProgram!
   */
  generateProgram(shader) {
    const gl = this.gl, program = shader.program, glProgram = generateProgram2(gl, program);
    return program.glPrograms[this.renderer.CONTEXT_UID] = glProgram, glProgram;
  }
  /** Resets ShaderSystem state, does not affect WebGL state. */
  reset() {
    this.program = null, this.shader = null;
  }
  /**
   * Disposes shader.
   * If disposing one equals with current shader, set current as null.
   * @param shader - Shader object
   */
  disposeShader(shader) {
    this.shader === shader && (this.shader = null);
  }
  /** Destroys this System and removes all its textures. */
  destroy() {
    this.renderer = null, this.destroyed = true;
  }
};
ShaderSystem.extension = {
  type: ExtensionType2.RendererSystem,
  name: "shader"
};
extensions2.add(ShaderSystem);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/startup/StartupSystem.mjs
var StartupSystem = class {
  constructor(renderer) {
    this.renderer = renderer;
  }
  /**
   * It all starts here! This initiates every system, passing in the options for any system by name.
   * @param options - the config for the renderer and all its systems
   */
  run(options) {
    const { renderer } = this;
    renderer.runners.init.emit(renderer.options), options.hello && console.log(`PixiJS 7.3.1 - ${renderer.rendererLogId} - https://pixijs.com`), renderer.resize(renderer.screen.width, renderer.screen.height);
  }
  destroy() {
  }
};
StartupSystem.defaultOptions = {
  /**
   * {@link PIXI.IRendererOptions.hello}
   * @default false
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  hello: false
}, /** @ignore */
StartupSystem.extension = {
  type: [
    ExtensionType2.RendererSystem,
    ExtensionType2.CanvasRendererSystem
  ],
  name: "startup"
};
extensions2.add(StartupSystem);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/state/utils/mapWebGLBlendModesToPixi.mjs
function mapWebGLBlendModesToPixi2(gl, array = []) {
  return array[BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.ADD] = [gl.ONE, gl.ONE], array[BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.NONE] = [0, 0], array[BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE], array[BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO], array[BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO], array[BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE], array[BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA], array[BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA], array[BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD], array;
}

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/state/StateSystem.mjs
var BLEND4 = 0;
var OFFSET4 = 1;
var CULLING4 = 2;
var DEPTH_TEST4 = 3;
var WINDING4 = 4;
var DEPTH_MASK4 = 5;
var _StateSystem = class _StateSystem2 {
  constructor() {
    this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = BLEND_MODES.NONE, this._blendEq = false, this.map = [], this.map[BLEND4] = this.setBlend, this.map[OFFSET4] = this.setOffset, this.map[CULLING4] = this.setCullFace, this.map[DEPTH_TEST4] = this.setDepthTest, this.map[WINDING4] = this.setFrontFace, this.map[DEPTH_MASK4] = this.setDepthMask, this.checks = [], this.defaultState = new State2(), this.defaultState.blend = true;
  }
  contextChange(gl) {
    this.gl = gl, this.blendModes = mapWebGLBlendModesToPixi2(gl), this.set(this.defaultState), this.reset();
  }
  /**
   * Sets the current state
   * @param {*} state - The state to set.
   */
  set(state) {
    if (state = state || this.defaultState, this.stateId !== state.data) {
      let diff = this.stateId ^ state.data, i3 = 0;
      for (; diff; )
        diff & 1 && this.map[i3].call(this, !!(state.data & 1 << i3)), diff = diff >> 1, i3++;
      this.stateId = state.data;
    }
    for (let i3 = 0; i3 < this.checks.length; i3++)
      this.checks[i3](this, state);
  }
  /**
   * Sets the state, when previous state is unknown.
   * @param {*} state - The state to set
   */
  forceState(state) {
    state = state || this.defaultState;
    for (let i3 = 0; i3 < this.map.length; i3++)
      this.map[i3].call(this, !!(state.data & 1 << i3));
    for (let i3 = 0; i3 < this.checks.length; i3++)
      this.checks[i3](this, state);
    this.stateId = state.data;
  }
  /**
   * Sets whether to enable or disable blending.
   * @param value - Turn on or off WebGl blending.
   */
  setBlend(value) {
    this.updateCheck(_StateSystem2.checkBlendMode, value), this.gl[value ? "enable" : "disable"](this.gl.BLEND);
  }
  /**
   * Sets whether to enable or disable polygon offset fill.
   * @param value - Turn on or off webgl polygon offset testing.
   */
  setOffset(value) {
    this.updateCheck(_StateSystem2.checkPolygonOffset, value), this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
  }
  /**
   * Sets whether to enable or disable depth test.
   * @param value - Turn on or off webgl depth testing.
   */
  setDepthTest(value) {
    this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
  }
  /**
   * Sets whether to enable or disable depth mask.
   * @param value - Turn on or off webgl depth mask.
   */
  setDepthMask(value) {
    this.gl.depthMask(value);
  }
  /**
   * Sets whether to enable or disable cull face.
   * @param {boolean} value - Turn on or off webgl cull face.
   */
  setCullFace(value) {
    this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
  }
  /**
   * Sets the gl front face.
   * @param {boolean} value - true is clockwise and false is counter-clockwise
   */
  setFrontFace(value) {
    this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
  }
  /**
   * Sets the blend mode.
   * @param {number} value - The blend mode to set to.
   */
  setBlendMode(value) {
    if (value === this.blendMode)
      return;
    this.blendMode = value;
    const mode = this.blendModes[value], gl = this.gl;
    mode.length === 2 ? gl.blendFunc(mode[0], mode[1]) : gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]), mode.length === 6 ? (this._blendEq = true, gl.blendEquationSeparate(mode[4], mode[5])) : this._blendEq && (this._blendEq = false, gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD));
  }
  /**
   * Sets the polygon offset.
   * @param {number} value - the polygon offset
   * @param {number} scale - the polygon offset scale
   */
  setPolygonOffset(value, scale3) {
    this.gl.polygonOffset(value, scale3);
  }
  // used
  /** Resets all the logic and disables the VAOs. */
  reset() {
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false), this.forceState(this.defaultState), this._blendEq = true, this.blendMode = -1, this.setBlendMode(0);
  }
  /**
   * Checks to see which updates should be checked based on which settings have been activated.
   *
   * For example, if blend is enabled then we should check the blend modes each time the state is changed
   * or if polygon fill is activated then we need to check if the polygon offset changes.
   * The idea is that we only check what we have too.
   * @param func - the checking function to add or remove
   * @param value - should the check function be added or removed.
   */
  updateCheck(func2, value) {
    const index = this.checks.indexOf(func2);
    value && index === -1 ? this.checks.push(func2) : !value && index !== -1 && this.checks.splice(index, 1);
  }
  /**
   * A private little wrapper function that we call to check the blend mode.
   * @param system - the System to perform the state check on
   * @param state - the state that the blendMode will pulled from
   */
  static checkBlendMode(system, state) {
    system.setBlendMode(state.blendMode);
  }
  /**
   * A private little wrapper function that we call to check the polygon offset.
   * @param system - the System to perform the state check on
   * @param state - the state that the blendMode will pulled from
   */
  static checkPolygonOffset(system, state) {
    system.setPolygonOffset(1, state.polygonOffset);
  }
  /**
   * @ignore
   */
  destroy() {
    this.gl = null;
  }
};
_StateSystem.extension = {
  type: ExtensionType2.RendererSystem,
  name: "state"
};
var StateSystem = _StateSystem;
extensions2.add(StateSystem);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/system/SystemManager.mjs
var SystemManager = class extends import_eventemitter317.default {
  constructor() {
    super(...arguments), this.runners = {}, this._systemsHash = {};
  }
  /**
   * Set up a system with a collection of SystemClasses and runners.
   * Systems are attached dynamically to this class when added.
   * @param config - the config for the system manager
   */
  setup(config) {
    this.addRunners(...config.runners);
    const priority = (config.priority ?? []).filter((key2) => config.systems[key2]), orderByPriority = [
      ...priority,
      ...Object.keys(config.systems).filter((key2) => !priority.includes(key2))
    ];
    for (const i3 of orderByPriority)
      this.addSystem(config.systems[i3], i3);
  }
  /**
   * Create a bunch of runners based of a collection of ids
   * @param runnerIds - the runner ids to add
   */
  addRunners(...runnerIds) {
    runnerIds.forEach((runnerId) => {
      this.runners[runnerId] = new Runner(runnerId);
    });
  }
  /**
   * Add a new system to the renderer.
   * @param ClassRef - Class reference
   * @param name - Property name for system, if not specified
   *        will use a static `name` property on the class itself. This
   *        name will be assigned as s property on the Renderer so make
   *        sure it doesn't collide with properties on Renderer.
   * @returns Return instance of renderer
   */
  addSystem(ClassRef, name) {
    const system = new ClassRef(this);
    if (this[name])
      throw new Error(`Whoops! The name "${name}" is already in use`);
    this[name] = system, this._systemsHash[name] = system;
    for (const i3 in this.runners)
      this.runners[i3].add(system);
    return this;
  }
  /**
   * A function that will run a runner and call the runners function but pass in different options
   * to each system based on there name.
   *
   * E.g. If you have two systems added called `systemA` and `systemB` you could call do the following:
   *
   * ```js
   * system.emitWithCustomOptions(init, {
   *     systemA: {...optionsForA},
   *     systemB: {...optionsForB},
   * });
   * ```
   *
   * `init` would be called on system A passing `optionsForA` and on system B passing `optionsForB`.
   * @param runner - the runner to target
   * @param options - key value options for each system
   */
  emitWithCustomOptions(runner, options) {
    const systemHashKeys = Object.keys(this._systemsHash);
    runner.items.forEach((system) => {
      const systemName = systemHashKeys.find((systemId) => this._systemsHash[systemId] === system);
      system[runner.name](options[systemName]);
    });
  }
  /** destroy the all runners and systems. Its apps job to */
  destroy() {
    Object.values(this.runners).forEach((runner) => {
      runner.destroy();
    }), this._systemsHash = {};
  }
  // TODO implement!
  // removeSystem(ClassRef: ISystemConstructor, name: string): void
  // {
  // }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/textures/TextureGCSystem.mjs
var _TextureGCSystem2 = class _TextureGCSystem22 {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    this.renderer = renderer, this.count = 0, this.checkCount = 0, this.maxIdle = _TextureGCSystem22.defaultMaxIdle, this.checkCountMax = _TextureGCSystem22.defaultCheckCountMax, this.mode = _TextureGCSystem22.defaultMode;
  }
  /**
   * Checks to see when the last time a texture was used.
   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
   */
  postrender() {
    this.renderer.objectRenderer.renderingToScreen && (this.count++, this.mode !== GC_MODES.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
  }
  /**
   * Checks to see when the last time a texture was used.
   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
   */
  run() {
    const tm = this.renderer.texture, managedTextures = tm.managedTextures;
    let wasRemoved = false;
    for (let i3 = 0; i3 < managedTextures.length; i3++) {
      const texture = managedTextures[i3];
      texture.resource && this.count - texture.touched > this.maxIdle && (tm.destroyTexture(texture, true), managedTextures[i3] = null, wasRemoved = true);
    }
    if (wasRemoved) {
      let j3 = 0;
      for (let i3 = 0; i3 < managedTextures.length; i3++)
        managedTextures[i3] !== null && (managedTextures[j3++] = managedTextures[i3]);
      managedTextures.length = j3;
    }
  }
  /**
   * Removes all the textures within the specified displayObject and its children from the GPU.
   * @param {PIXI.DisplayObject} displayObject - the displayObject to remove the textures from.
   */
  unload(displayObject) {
    const tm = this.renderer.texture, texture = displayObject._texture;
    texture && !texture.framebuffer && tm.destroyTexture(texture);
    for (let i3 = displayObject.children.length - 1; i3 >= 0; i3--)
      this.unload(displayObject.children[i3]);
  }
  destroy() {
    this.renderer = null;
  }
};
_TextureGCSystem2.defaultMode = GC_MODES.AUTO, /**
* Default maximum idle frames before a texture is destroyed by garbage collection.
* @static
* @default 3600
* @see PIXI.TextureGCSystem#maxIdle
*/
_TextureGCSystem2.defaultMaxIdle = 60 * 60, /**
* Default frames between two garbage collections.
* @static
* @default 600
* @see PIXI.TextureGCSystem#checkCountMax
*/
_TextureGCSystem2.defaultCheckCountMax = 60 * 10, /** @ignore */
_TextureGCSystem2.extension = {
  type: ExtensionType2.RendererSystem,
  name: "textureGC"
};
var TextureGCSystem2 = _TextureGCSystem2;
extensions2.add(TextureGCSystem2);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/textures/GLTexture.mjs
var GLTexture = class {
  constructor(texture) {
    this.texture = texture, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = false, this.wrapMode = 33071, this.type = TYPES.UNSIGNED_BYTE, this.internalFormat = FORMATS.RGBA, this.samplerType = 0;
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/textures/utils/mapInternalFormatToSamplerType.mjs
function mapInternalFormatToSamplerType(gl) {
  let table;
  return "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext ? table = {
    [gl.RGB]: SAMPLER_TYPES.FLOAT,
    [gl.RGBA]: SAMPLER_TYPES.FLOAT,
    [gl.ALPHA]: SAMPLER_TYPES.FLOAT,
    [gl.LUMINANCE]: SAMPLER_TYPES.FLOAT,
    [gl.LUMINANCE_ALPHA]: SAMPLER_TYPES.FLOAT,
    [gl.R8]: SAMPLER_TYPES.FLOAT,
    [gl.R8_SNORM]: SAMPLER_TYPES.FLOAT,
    [gl.RG8]: SAMPLER_TYPES.FLOAT,
    [gl.RG8_SNORM]: SAMPLER_TYPES.FLOAT,
    [gl.RGB8]: SAMPLER_TYPES.FLOAT,
    [gl.RGB8_SNORM]: SAMPLER_TYPES.FLOAT,
    [gl.RGB565]: SAMPLER_TYPES.FLOAT,
    [gl.RGBA4]: SAMPLER_TYPES.FLOAT,
    [gl.RGB5_A1]: SAMPLER_TYPES.FLOAT,
    [gl.RGBA8]: SAMPLER_TYPES.FLOAT,
    [gl.RGBA8_SNORM]: SAMPLER_TYPES.FLOAT,
    [gl.RGB10_A2]: SAMPLER_TYPES.FLOAT,
    [gl.RGB10_A2UI]: SAMPLER_TYPES.FLOAT,
    [gl.SRGB8]: SAMPLER_TYPES.FLOAT,
    [gl.SRGB8_ALPHA8]: SAMPLER_TYPES.FLOAT,
    [gl.R16F]: SAMPLER_TYPES.FLOAT,
    [gl.RG16F]: SAMPLER_TYPES.FLOAT,
    [gl.RGB16F]: SAMPLER_TYPES.FLOAT,
    [gl.RGBA16F]: SAMPLER_TYPES.FLOAT,
    [gl.R32F]: SAMPLER_TYPES.FLOAT,
    [gl.RG32F]: SAMPLER_TYPES.FLOAT,
    [gl.RGB32F]: SAMPLER_TYPES.FLOAT,
    [gl.RGBA32F]: SAMPLER_TYPES.FLOAT,
    [gl.R11F_G11F_B10F]: SAMPLER_TYPES.FLOAT,
    [gl.RGB9_E5]: SAMPLER_TYPES.FLOAT,
    [gl.R8I]: SAMPLER_TYPES.INT,
    [gl.R8UI]: SAMPLER_TYPES.UINT,
    [gl.R16I]: SAMPLER_TYPES.INT,
    [gl.R16UI]: SAMPLER_TYPES.UINT,
    [gl.R32I]: SAMPLER_TYPES.INT,
    [gl.R32UI]: SAMPLER_TYPES.UINT,
    [gl.RG8I]: SAMPLER_TYPES.INT,
    [gl.RG8UI]: SAMPLER_TYPES.UINT,
    [gl.RG16I]: SAMPLER_TYPES.INT,
    [gl.RG16UI]: SAMPLER_TYPES.UINT,
    [gl.RG32I]: SAMPLER_TYPES.INT,
    [gl.RG32UI]: SAMPLER_TYPES.UINT,
    [gl.RGB8I]: SAMPLER_TYPES.INT,
    [gl.RGB8UI]: SAMPLER_TYPES.UINT,
    [gl.RGB16I]: SAMPLER_TYPES.INT,
    [gl.RGB16UI]: SAMPLER_TYPES.UINT,
    [gl.RGB32I]: SAMPLER_TYPES.INT,
    [gl.RGB32UI]: SAMPLER_TYPES.UINT,
    [gl.RGBA8I]: SAMPLER_TYPES.INT,
    [gl.RGBA8UI]: SAMPLER_TYPES.UINT,
    [gl.RGBA16I]: SAMPLER_TYPES.INT,
    [gl.RGBA16UI]: SAMPLER_TYPES.UINT,
    [gl.RGBA32I]: SAMPLER_TYPES.INT,
    [gl.RGBA32UI]: SAMPLER_TYPES.UINT,
    [gl.DEPTH_COMPONENT16]: SAMPLER_TYPES.FLOAT,
    [gl.DEPTH_COMPONENT24]: SAMPLER_TYPES.FLOAT,
    [gl.DEPTH_COMPONENT32F]: SAMPLER_TYPES.FLOAT,
    [gl.DEPTH_STENCIL]: SAMPLER_TYPES.FLOAT,
    [gl.DEPTH24_STENCIL8]: SAMPLER_TYPES.FLOAT,
    [gl.DEPTH32F_STENCIL8]: SAMPLER_TYPES.FLOAT
  } : table = {
    [gl.RGB]: SAMPLER_TYPES.FLOAT,
    [gl.RGBA]: SAMPLER_TYPES.FLOAT,
    [gl.ALPHA]: SAMPLER_TYPES.FLOAT,
    [gl.LUMINANCE]: SAMPLER_TYPES.FLOAT,
    [gl.LUMINANCE_ALPHA]: SAMPLER_TYPES.FLOAT,
    [gl.DEPTH_STENCIL]: SAMPLER_TYPES.FLOAT
  }, table;
}

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/textures/utils/mapTypeAndFormatToInternalFormat.mjs
function mapTypeAndFormatToInternalFormat(gl) {
  let table;
  return "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext ? table = {
    [TYPES.UNSIGNED_BYTE]: {
      [FORMATS.RGBA]: gl.RGBA8,
      [FORMATS.RGB]: gl.RGB8,
      [FORMATS.RG]: gl.RG8,
      [FORMATS.RED]: gl.R8,
      [FORMATS.RGBA_INTEGER]: gl.RGBA8UI,
      [FORMATS.RGB_INTEGER]: gl.RGB8UI,
      [FORMATS.RG_INTEGER]: gl.RG8UI,
      [FORMATS.RED_INTEGER]: gl.R8UI,
      [FORMATS.ALPHA]: gl.ALPHA,
      [FORMATS.LUMINANCE]: gl.LUMINANCE,
      [FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
    },
    [TYPES.BYTE]: {
      [FORMATS.RGBA]: gl.RGBA8_SNORM,
      [FORMATS.RGB]: gl.RGB8_SNORM,
      [FORMATS.RG]: gl.RG8_SNORM,
      [FORMATS.RED]: gl.R8_SNORM,
      [FORMATS.RGBA_INTEGER]: gl.RGBA8I,
      [FORMATS.RGB_INTEGER]: gl.RGB8I,
      [FORMATS.RG_INTEGER]: gl.RG8I,
      [FORMATS.RED_INTEGER]: gl.R8I
    },
    [TYPES.UNSIGNED_SHORT]: {
      [FORMATS.RGBA_INTEGER]: gl.RGBA16UI,
      [FORMATS.RGB_INTEGER]: gl.RGB16UI,
      [FORMATS.RG_INTEGER]: gl.RG16UI,
      [FORMATS.RED_INTEGER]: gl.R16UI,
      [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT16
    },
    [TYPES.SHORT]: {
      [FORMATS.RGBA_INTEGER]: gl.RGBA16I,
      [FORMATS.RGB_INTEGER]: gl.RGB16I,
      [FORMATS.RG_INTEGER]: gl.RG16I,
      [FORMATS.RED_INTEGER]: gl.R16I
    },
    [TYPES.UNSIGNED_INT]: {
      [FORMATS.RGBA_INTEGER]: gl.RGBA32UI,
      [FORMATS.RGB_INTEGER]: gl.RGB32UI,
      [FORMATS.RG_INTEGER]: gl.RG32UI,
      [FORMATS.RED_INTEGER]: gl.R32UI,
      [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT24
    },
    [TYPES.INT]: {
      [FORMATS.RGBA_INTEGER]: gl.RGBA32I,
      [FORMATS.RGB_INTEGER]: gl.RGB32I,
      [FORMATS.RG_INTEGER]: gl.RG32I,
      [FORMATS.RED_INTEGER]: gl.R32I
    },
    [TYPES.FLOAT]: {
      [FORMATS.RGBA]: gl.RGBA32F,
      [FORMATS.RGB]: gl.RGB32F,
      [FORMATS.RG]: gl.RG32F,
      [FORMATS.RED]: gl.R32F,
      [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT32F
    },
    [TYPES.HALF_FLOAT]: {
      [FORMATS.RGBA]: gl.RGBA16F,
      [FORMATS.RGB]: gl.RGB16F,
      [FORMATS.RG]: gl.RG16F,
      [FORMATS.RED]: gl.R16F
    },
    [TYPES.UNSIGNED_SHORT_5_6_5]: {
      [FORMATS.RGB]: gl.RGB565
    },
    [TYPES.UNSIGNED_SHORT_4_4_4_4]: {
      [FORMATS.RGBA]: gl.RGBA4
    },
    [TYPES.UNSIGNED_SHORT_5_5_5_1]: {
      [FORMATS.RGBA]: gl.RGB5_A1
    },
    [TYPES.UNSIGNED_INT_2_10_10_10_REV]: {
      [FORMATS.RGBA]: gl.RGB10_A2,
      [FORMATS.RGBA_INTEGER]: gl.RGB10_A2UI
    },
    [TYPES.UNSIGNED_INT_10F_11F_11F_REV]: {
      [FORMATS.RGB]: gl.R11F_G11F_B10F
    },
    [TYPES.UNSIGNED_INT_5_9_9_9_REV]: {
      [FORMATS.RGB]: gl.RGB9_E5
    },
    [TYPES.UNSIGNED_INT_24_8]: {
      [FORMATS.DEPTH_STENCIL]: gl.DEPTH24_STENCIL8
    },
    [TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
      [FORMATS.DEPTH_STENCIL]: gl.DEPTH32F_STENCIL8
    }
  } : table = {
    [TYPES.UNSIGNED_BYTE]: {
      [FORMATS.RGBA]: gl.RGBA,
      [FORMATS.RGB]: gl.RGB,
      [FORMATS.ALPHA]: gl.ALPHA,
      [FORMATS.LUMINANCE]: gl.LUMINANCE,
      [FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
    },
    [TYPES.UNSIGNED_SHORT_5_6_5]: {
      [FORMATS.RGB]: gl.RGB
    },
    [TYPES.UNSIGNED_SHORT_4_4_4_4]: {
      [FORMATS.RGBA]: gl.RGBA
    },
    [TYPES.UNSIGNED_SHORT_5_5_5_1]: {
      [FORMATS.RGBA]: gl.RGBA
    }
  }, table;
}

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/textures/TextureSystem.mjs
var TextureSystem = class {
  /**
   * @param renderer - The renderer this system works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = false, this.unknownTexture = new BaseTexture(), this.hasIntegerTextures = false;
  }
  /** Sets up the renderer context and necessary buffers. */
  contextChange() {
    const gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = mapTypeAndFormatToInternalFormat(gl), this.samplerTypes = mapInternalFormatToSamplerType(gl);
    const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this.boundTextures.length = maxTextures;
    for (let i3 = 0; i3 < maxTextures; i3++)
      this.boundTextures[i3] = null;
    this.emptyTextures = {};
    const emptyTexture2D = new GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D, this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture()), gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
    for (let i3 = 0; i3 < 6; i3++)
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i3, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR), gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    for (let i3 = 0; i3 < this.boundTextures.length; i3++)
      this.bind(null, i3);
  }
  /**
   * Bind a texture to a specific location
   *
   * If you want to unbind something, please use `unbind(texture)` instead of `bind(null, textureLocation)`
   * @param texture - Texture to bind
   * @param [location=0] - Location to bind at
   */
  bind(texture, location = 0) {
    const { gl } = this;
    if (texture = texture?.castToBaseTexture(), texture?.valid && !texture.parentTextureArray) {
      texture.touched = this.renderer.textureGC.count;
      const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
      this.boundTextures[location] !== texture && (this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), gl.bindTexture(texture.target, glTexture.texture)), glTexture.dirtyId !== texture.dirtyId ? (this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), this.updateTexture(texture)) : glTexture.dirtyStyleId !== texture.dirtyStyleId && this.updateTextureStyle(texture), this.boundTextures[location] = texture;
    } else
      this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture), this.boundTextures[location] = null;
  }
  /** Resets texture location and bound textures Actual `bind(null, i)` calls will be performed at next `unbind()` call */
  reset() {
    this._unknownBoundTextures = true, this.hasIntegerTextures = false, this.currentLocation = -1;
    for (let i3 = 0; i3 < this.boundTextures.length; i3++)
      this.boundTextures[i3] = this.unknownTexture;
  }
  /**
   * Unbind a texture.
   * @param texture - Texture to bind
   */
  unbind(texture) {
    const { gl, boundTextures } = this;
    if (this._unknownBoundTextures) {
      this._unknownBoundTextures = false;
      for (let i3 = 0; i3 < boundTextures.length; i3++)
        boundTextures[i3] === this.unknownTexture && this.bind(null, i3);
    }
    for (let i3 = 0; i3 < boundTextures.length; i3++)
      boundTextures[i3] === texture && (this.currentLocation !== i3 && (gl.activeTexture(gl.TEXTURE0 + i3), this.currentLocation = i3), gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture), boundTextures[i3] = null);
  }
  /**
   * Ensures that current boundTextures all have FLOAT sampler type,
   * see {@link PIXI.SAMPLER_TYPES} for explanation.
   * @param maxTextures - number of locations to check
   */
  ensureSamplerType(maxTextures) {
    const { boundTextures, hasIntegerTextures, CONTEXT_UID } = this;
    if (hasIntegerTextures)
      for (let i3 = maxTextures - 1; i3 >= 0; --i3) {
        const tex = boundTextures[i3];
        tex && tex._glTextures[CONTEXT_UID].samplerType !== SAMPLER_TYPES.FLOAT && this.renderer.texture.unbind(tex);
      }
  }
  /**
   * Initialize a texture
   * @private
   * @param texture - Texture to initialize
   */
  initTexture(texture) {
    const glTexture = new GLTexture(this.gl.createTexture());
    return glTexture.dirtyId = -1, texture._glTextures[this.CONTEXT_UID] = glTexture, this.managedTextures.push(texture), texture.on("dispose", this.destroyTexture, this), glTexture;
  }
  initTextureType(texture, glTexture) {
    glTexture.internalFormat = this.internalFormats[texture.type]?.[texture.format] ?? texture.format, glTexture.samplerType = this.samplerTypes[glTexture.internalFormat] ?? SAMPLER_TYPES.FLOAT, this.webGLVersion === 2 && texture.type === TYPES.HALF_FLOAT ? glTexture.type = this.gl.HALF_FLOAT : glTexture.type = texture.type;
  }
  /**
   * Update a texture
   * @private
   * @param {PIXI.BaseTexture} texture - Texture to initialize
   */
  updateTexture(texture) {
    const glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture)
      return;
    const renderer = this.renderer;
    if (this.initTextureType(texture, glTexture), texture.resource?.upload(renderer, texture, glTexture))
      glTexture.samplerType !== SAMPLER_TYPES.FLOAT && (this.hasIntegerTextures = true);
    else {
      const width = texture.realWidth, height = texture.realHeight, gl = renderer.gl;
      (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) && (glTexture.width = width, glTexture.height = height, gl.texImage2D(
        texture.target,
        0,
        glTexture.internalFormat,
        width,
        height,
        0,
        texture.format,
        glTexture.type,
        null
      ));
    }
    texture.dirtyStyleId !== glTexture.dirtyStyleId && this.updateTextureStyle(texture), glTexture.dirtyId = texture.dirtyId;
  }
  /**
   * Deletes the texture from WebGL
   * @private
   * @param texture - the texture to destroy
   * @param [skipRemove=false] - Whether to skip removing the texture from the TextureManager.
   */
  destroyTexture(texture, skipRemove) {
    const { gl } = this;
    if (texture = texture.castToBaseTexture(), texture._glTextures[this.CONTEXT_UID] && (this.unbind(texture), gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture), texture.off("dispose", this.destroyTexture, this), delete texture._glTextures[this.CONTEXT_UID], !skipRemove)) {
      const i3 = this.managedTextures.indexOf(texture);
      i3 !== -1 && removeItems2(this.managedTextures, i3, 1);
    }
  }
  /**
   * Update texture style such as mipmap flag
   * @private
   * @param {PIXI.BaseTexture} texture - Texture to update
   */
  updateTextureStyle(texture) {
    const glTexture = texture._glTextures[this.CONTEXT_UID];
    glTexture && ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo ? glTexture.mipmap = false : glTexture.mipmap = texture.mipmap >= 1, this.webGLVersion !== 2 && !texture.isPowerOfTwo ? glTexture.wrapMode = WRAP_MODES.CLAMP : glTexture.wrapMode = texture.wrapMode, texture.resource?.style(this.renderer, texture, glTexture) || this.setStyle(texture, glTexture), glTexture.dirtyStyleId = texture.dirtyStyleId);
  }
  /**
   * Set style for texture
   * @private
   * @param texture - Texture to update
   * @param glTexture
   */
  setStyle(texture, glTexture) {
    const gl = this.gl;
    if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES.ON_MANUAL && gl.generateMipmap(texture.target), gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode), gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode), glTexture.mipmap) {
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
      const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
      if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR) {
        const level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
        gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
      }
    } else
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
    gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
  }
  destroy() {
    this.renderer = null;
  }
};
TextureSystem.extension = {
  type: ExtensionType2.RendererSystem,
  name: "texture"
};
extensions2.add(TextureSystem);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.mjs
var TransformFeedbackSystem = class {
  /**
   * @param renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer;
  }
  /** Sets up the renderer context and necessary buffers. */
  contextChange() {
    this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }
  /**
   * Bind TransformFeedback and buffers
   * @param transformFeedback - TransformFeedback to bind
   */
  bind(transformFeedback) {
    const { gl, CONTEXT_UID } = this, glTransformFeedback = transformFeedback._glTransformFeedbacks[CONTEXT_UID] || this.createGLTransformFeedback(transformFeedback);
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
  }
  /** Unbind TransformFeedback */
  unbind() {
    const { gl } = this;
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
  }
  /**
   * Begin TransformFeedback
   * @param drawMode - DrawMode for TransformFeedback
   * @param shader - A Shader used by TransformFeedback. Current bound shader will be used if not provided.
   */
  beginTransformFeedback(drawMode, shader) {
    const { gl, renderer } = this;
    shader && renderer.shader.bind(shader), gl.beginTransformFeedback(drawMode);
  }
  /** End TransformFeedback */
  endTransformFeedback() {
    const { gl } = this;
    gl.endTransformFeedback();
  }
  /**
   * Create TransformFeedback and bind buffers
   * @param tf - TransformFeedback
   * @returns WebGLTransformFeedback
   */
  createGLTransformFeedback(tf) {
    const { gl, renderer, CONTEXT_UID } = this, glTransformFeedback = gl.createTransformFeedback();
    tf._glTransformFeedbacks[CONTEXT_UID] = glTransformFeedback, gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
    for (let i3 = 0; i3 < tf.buffers.length; i3++) {
      const buffer2 = tf.buffers[i3];
      buffer2 && (renderer.buffer.update(buffer2), buffer2._glBuffers[CONTEXT_UID].refCount++, gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i3, buffer2._glBuffers[CONTEXT_UID].buffer || null));
    }
    return gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null), tf.disposeRunner.add(this), glTransformFeedback;
  }
  /**
   * Disposes TransfromFeedback
   * @param {PIXI.TransformFeedback} tf - TransformFeedback
   * @param {boolean} [contextLost=false] - If context was lost, we suppress delete TransformFeedback
   */
  disposeTransformFeedback(tf, contextLost) {
    const glTF = tf._glTransformFeedbacks[this.CONTEXT_UID], gl = this.gl;
    tf.disposeRunner.remove(this);
    const bufferSystem = this.renderer.buffer;
    if (bufferSystem)
      for (let i3 = 0; i3 < tf.buffers.length; i3++) {
        const buffer2 = tf.buffers[i3];
        if (!buffer2)
          continue;
        const buf = buffer2._glBuffers[this.CONTEXT_UID];
        buf && (buf.refCount--, buf.refCount === 0 && !contextLost && bufferSystem.dispose(buffer2, contextLost));
      }
    glTF && (contextLost || gl.deleteTransformFeedback(glTF), delete tf._glTransformFeedbacks[this.CONTEXT_UID]);
  }
  destroy() {
    this.renderer = null;
  }
};
TransformFeedbackSystem.extension = {
  type: ExtensionType2.RendererSystem,
  name: "transformFeedback"
};
extensions2.add(TransformFeedbackSystem);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/view/ViewSystem.mjs
var ViewSystem2 = class {
  constructor(renderer) {
    this.renderer = renderer;
  }
  /**
   * initiates the view system
   * @param {PIXI.ViewOptions} options - the options for the view
   */
  init(options) {
    this.screen = new Rectangle2(0, 0, options.width, options.height), this.element = options.view || settings2.ADAPTER.createCanvas(), this.resolution = options.resolution || settings2.RESOLUTION, this.autoDensity = !!options.autoDensity;
  }
  /**
   * Resizes the screen and canvas to the specified dimensions.
   * @param desiredScreenWidth - The new width of the screen.
   * @param desiredScreenHeight - The new height of the screen.
   */
  resizeView(desiredScreenWidth, desiredScreenHeight) {
    this.element.width = Math.round(desiredScreenWidth * this.resolution), this.element.height = Math.round(desiredScreenHeight * this.resolution);
    const screenWidth = this.element.width / this.resolution, screenHeight = this.element.height / this.resolution;
    this.screen.width = screenWidth, this.screen.height = screenHeight, this.autoDensity && (this.element.style.width = `${screenWidth}px`, this.element.style.height = `${screenHeight}px`), this.renderer.emit("resize", screenWidth, screenHeight), this.renderer.runners.resize.emit(this.screen.width, this.screen.height);
  }
  /**
   * Destroys this System and optionally removes the canvas from the dom.
   * @param {boolean} [removeView=false] - Whether to remove the canvas from the DOM.
   */
  destroy(removeView) {
    removeView && this.element.parentNode?.removeChild(this.element), this.renderer = null, this.element = null, this.screen = null;
  }
};
ViewSystem2.defaultOptions = {
  /**
   * {@link PIXI.IRendererOptions.width}
   * @default 800
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  width: 800,
  /**
   * {@link PIXI.IRendererOptions.height}
   * @default 600
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  height: 600,
  /**
   * {@link PIXI.IRendererOptions.resolution}
   * @type {number}
   * @default PIXI.settings.RESOLUTION
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  resolution: void 0,
  /**
   * {@link PIXI.IRendererOptions.autoDensity}
   * @default false
   * @memberof PIXI.settings.RENDER_OPTIONS
   */
  autoDensity: false
}, /** @ignore */
ViewSystem2.extension = {
  type: [
    ExtensionType2.RendererSystem,
    ExtensionType2.CanvasRendererSystem
  ],
  name: "_view"
};
extensions2.add(ViewSystem2);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/settings.mjs
settings2.PREFER_ENV = ENV.WEBGL2;
settings2.STRICT_TEXTURE_CACHE = false;
settings2.RENDER_OPTIONS = {
  ...ContextSystem.defaultOptions,
  ...BackgroundSystem2.defaultOptions,
  ...ViewSystem2.defaultOptions,
  ...StartupSystem.defaultOptions
};
Object.defineProperties(settings2, {
  /**
   * @static
   * @name WRAP_MODE
   * @memberof PIXI.settings
   * @type {PIXI.WRAP_MODES}
   * @deprecated since 7.1.0
   * @see PIXI.BaseTexture.defaultOptions.wrapMode
   */
  WRAP_MODE: {
    get() {
      return BaseTexture.defaultOptions.wrapMode;
    },
    set(value) {
      deprecation2("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode"), BaseTexture.defaultOptions.wrapMode = value;
    }
  },
  /**
   * @static
   * @name SCALE_MODE
   * @memberof PIXI.settings
   * @type {PIXI.SCALE_MODES}
   * @deprecated since 7.1.0
   * @see PIXI.BaseTexture.defaultOptions.scaleMode
   */
  SCALE_MODE: {
    get() {
      return BaseTexture.defaultOptions.scaleMode;
    },
    set(value) {
      deprecation2("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode"), BaseTexture.defaultOptions.scaleMode = value;
    }
  },
  /**
   * @static
   * @name MIPMAP_TEXTURES
   * @memberof PIXI.settings
   * @type {PIXI.MIPMAP_MODES}
   * @deprecated since 7.1.0
   * @see PIXI.BaseTexture.defaultOptions.mipmap
   */
  MIPMAP_TEXTURES: {
    get() {
      return BaseTexture.defaultOptions.mipmap;
    },
    set(value) {
      deprecation2("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap"), BaseTexture.defaultOptions.mipmap = value;
    }
    // MIPMAP_MODES.POW2,
  },
  /**
   * @static
   * @name ANISOTROPIC_LEVEL
   * @memberof PIXI.settings
   * @type {number}
   * @deprecated since 7.1.0
   * @see PIXI.BaseTexture.defaultOptions.anisotropicLevel
   */
  ANISOTROPIC_LEVEL: {
    get() {
      return BaseTexture.defaultOptions.anisotropicLevel;
    },
    set(value) {
      deprecation2(
        "7.1.0",
        "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel"
      ), BaseTexture.defaultOptions.anisotropicLevel = value;
    }
  },
  /**
   * Default filter resolution.
   * @static
   * @name FILTER_RESOLUTION
   * @memberof PIXI.settings
   * @deprecated since 7.1.0
   * @type {number|null}
   * @see PIXI.Filter.defaultResolution
   */
  FILTER_RESOLUTION: {
    get() {
      return deprecation2("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution"), Filter2.defaultResolution;
    },
    set(value) {
      Filter2.defaultResolution = value;
    }
  },
  /**
   * Default filter samples.
   * @static
   * @name FILTER_MULTISAMPLE
   * @memberof PIXI.settings
   * @deprecated since 7.1.0
   * @type {PIXI.MSAA_QUALITY}
   * @see PIXI.Filter.defaultMultisample
   */
  FILTER_MULTISAMPLE: {
    get() {
      return deprecation2("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample"), Filter2.defaultMultisample;
    },
    set(value) {
      Filter2.defaultMultisample = value;
    }
  },
  /**
   * The maximum textures that this device supports.
   * @static
   * @name SPRITE_MAX_TEXTURES
   * @memberof PIXI.settings
   * @deprecated since 7.1.0
   * @see PIXI.BatchRenderer.defaultMaxTextures
   * @type {number}
   */
  SPRITE_MAX_TEXTURES: {
    get() {
      return BatchRenderer.defaultMaxTextures;
    },
    set(value) {
      deprecation2("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures"), BatchRenderer.defaultMaxTextures = value;
    }
  },
  /**
   * The default sprite batch size.
   *
   * The default aims to balance desktop and mobile devices.
   * @static
   * @name SPRITE_BATCH_SIZE
   * @memberof PIXI.settings
   * @see PIXI.BatchRenderer.defaultBatchSize
   * @deprecated since 7.1.0
   * @type {number}
   */
  SPRITE_BATCH_SIZE: {
    get() {
      return BatchRenderer.defaultBatchSize;
    },
    set(value) {
      deprecation2("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize"), BatchRenderer.defaultBatchSize = value;
    }
  },
  /**
   * Can we upload the same buffer in a single frame?
   * @static
   * @name CAN_UPLOAD_SAME_BUFFER
   * @memberof PIXI.settings
   * @see PIXI.BatchRenderer.canUploadSameBuffer
   * @deprecated since 7.1.0
   * @type {boolean}
   */
  CAN_UPLOAD_SAME_BUFFER: {
    get() {
      return BatchRenderer.canUploadSameBuffer;
    },
    set(value) {
      deprecation2("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer"), BatchRenderer.canUploadSameBuffer = value;
    }
  },
  /**
   * Default Garbage Collection mode.
   * @static
   * @name GC_MODE
   * @memberof PIXI.settings
   * @type {PIXI.GC_MODES}
   * @deprecated since 7.1.0
   * @see PIXI.TextureGCSystem.defaultMode
   */
  GC_MODE: {
    get() {
      return TextureGCSystem2.defaultMode;
    },
    set(value) {
      deprecation2("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode"), TextureGCSystem2.defaultMode = value;
    }
  },
  /**
   * Default Garbage Collection max idle.
   * @static
   * @name GC_MAX_IDLE
   * @memberof PIXI.settings
   * @type {number}
   * @deprecated since 7.1.0
   * @see PIXI.TextureGCSystem.defaultMaxIdle
   */
  GC_MAX_IDLE: {
    get() {
      return TextureGCSystem2.defaultMaxIdle;
    },
    set(value) {
      deprecation2("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle"), TextureGCSystem2.defaultMaxIdle = value;
    }
  },
  /**
   * Default Garbage Collection maximum check count.
   * @static
   * @name GC_MAX_CHECK_COUNT
   * @memberof PIXI.settings
   * @type {number}
   * @deprecated since 7.1.0
   * @see PIXI.TextureGCSystem.defaultCheckCountMax
   */
  GC_MAX_CHECK_COUNT: {
    get() {
      return TextureGCSystem2.defaultCheckCountMax;
    },
    set(value) {
      deprecation2("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax"), TextureGCSystem2.defaultCheckCountMax = value;
    }
  },
  /**
   * Default specify float precision in vertex shader.
   * @static
   * @name PRECISION_VERTEX
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @deprecated since 7.1.0
   * @see PIXI.Program.defaultVertexPrecision
   */
  PRECISION_VERTEX: {
    get() {
      return Program.defaultVertexPrecision;
    },
    set(value) {
      deprecation2("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision"), Program.defaultVertexPrecision = value;
    }
  },
  /**
   * Default specify float precision in fragment shader.
   * @static
   * @name PRECISION_FRAGMENT
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @deprecated since 7.1.0
   * @see PIXI.Program.defaultFragmentPrecision
   */
  PRECISION_FRAGMENT: {
    get() {
      return Program.defaultFragmentPrecision;
    },
    set(value) {
      deprecation2("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision"), Program.defaultFragmentPrecision = value;
    }
  }
});

// ../../node_modules/.pnpm/@pixi+ticker@7.3.1/node_modules/@pixi/ticker/lib/const.mjs
var UPDATE_PRIORITY2 = /* @__PURE__ */ ((UPDATE_PRIORITY22) => (UPDATE_PRIORITY22[UPDATE_PRIORITY22.INTERACTION = 50] = "INTERACTION", UPDATE_PRIORITY22[UPDATE_PRIORITY22.HIGH = 25] = "HIGH", UPDATE_PRIORITY22[UPDATE_PRIORITY22.NORMAL = 0] = "NORMAL", UPDATE_PRIORITY22[UPDATE_PRIORITY22.LOW = -25] = "LOW", UPDATE_PRIORITY22[UPDATE_PRIORITY22.UTILITY = -50] = "UTILITY", UPDATE_PRIORITY22))(UPDATE_PRIORITY2 || {});

// ../../node_modules/.pnpm/@pixi+ticker@7.3.1/node_modules/@pixi/ticker/lib/TickerListener.mjs
var TickerListener2 = class {
  /**
   * Constructor
   * @private
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param priority - The priority for emitting
   * @param once - If the handler should fire once
   */
  constructor(fn, context4 = null, priority = 0, once = false) {
    this.next = null, this.previous = null, this._destroyed = false, this.fn = fn, this.context = context4, this.priority = priority, this.once = once;
  }
  /**
   * Simple compare function to figure out if a function and context match.
   * @private
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @returns `true` if the listener match the arguments
   */
  match(fn, context4 = null) {
    return this.fn === fn && this.context === context4;
  }
  /**
   * Emit by calling the current function.
   * @private
   * @param deltaTime - time since the last emit.
   * @returns Next ticker
   */
  emit(deltaTime) {
    this.fn && (this.context ? this.fn.call(this.context, deltaTime) : this.fn(deltaTime));
    const redirect = this.next;
    return this.once && this.destroy(true), this._destroyed && (this.next = null), redirect;
  }
  /**
   * Connect to the list.
   * @private
   * @param previous - Input node, previous listener
   */
  connect(previous) {
    this.previous = previous, previous.next && (previous.next.previous = this), this.next = previous.next, previous.next = this;
  }
  /**
   * Destroy and don't use after this.
   * @private
   * @param hard - `true` to remove the `next` reference, this
   *        is considered a hard destroy. Soft destroy maintains the next reference.
   * @returns The listener to redirect while emitting or removing.
   */
  destroy(hard = false) {
    this._destroyed = true, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
    const redirect = this.next;
    return this.next = hard ? null : redirect, this.previous = null, redirect;
  }
};

// ../../node_modules/.pnpm/@pixi+ticker@7.3.1/node_modules/@pixi/ticker/lib/Ticker.mjs
var _Ticker2 = class _Ticker22 {
  constructor() {
    this.autoStart = false, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = false, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = false, this._lastFrame = -1, this._head = new TickerListener2(null, null, 1 / 0), this.deltaMS = 1 / _Ticker22.targetFPMS, this.elapsedMS = 1 / _Ticker22.targetFPMS, this._tick = (time) => {
      this._requestId = null, this.started && (this.update(time), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));
    };
  }
  /**
   * Conditionally requests a new animation frame.
   * If a frame has not already been requested, and if the internal
   * emitter has listeners, a new frame is requested.
   * @private
   */
  _requestIfNeeded() {
    this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
  }
  /**
   * Conditionally cancels a pending animation frame.
   * @private
   */
  _cancelIfNeeded() {
    this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
  }
  /**
   * Conditionally requests a new animation frame.
   * If the ticker has been started it checks if a frame has not already
   * been requested, and if the internal emitter has listeners. If these
   * conditions are met, a new frame is requested. If the ticker has not
   * been started, but autoStart is `true`, then the ticker starts now,
   * and continues with the previous conditions to request a new frame.
   * @private
   */
  _startIfPossible() {
    this.started ? this._requestIfNeeded() : this.autoStart && this.start();
  }
  /**
   * Register a handler for tick events. Calls continuously unless
   * it is removed or the ticker is stopped.
   * @param fn - The listener function to be added for updates
   * @param context - The listener context
   * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
   * @returns This instance of a ticker
   */
  add(fn, context4, priority = UPDATE_PRIORITY2.NORMAL) {
    return this._addListener(new TickerListener2(fn, context4, priority));
  }
  /**
   * Add a handler for the tick event which is only execute once.
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
   * @returns This instance of a ticker
   */
  addOnce(fn, context4, priority = UPDATE_PRIORITY2.NORMAL) {
    return this._addListener(new TickerListener2(fn, context4, priority, true));
  }
  /**
   * Internally adds the event handler so that it can be sorted by priority.
   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
   * before the rendering.
   * @private
   * @param listener - Current listener being added.
   * @returns This instance of a ticker
   */
  _addListener(listener) {
    let current = this._head.next, previous = this._head;
    if (!current)
      listener.connect(previous);
    else {
      for (; current; ) {
        if (listener.priority > current.priority) {
          listener.connect(previous);
          break;
        }
        previous = current, current = current.next;
      }
      listener.previous || listener.connect(previous);
    }
    return this._startIfPossible(), this;
  }
  /**
   * Removes any handlers matching the function and context parameters.
   * If no handlers are left after removing, then it cancels the animation frame.
   * @param fn - The listener function to be removed
   * @param context - The listener context to be removed
   * @returns This instance of a ticker
   */
  remove(fn, context4) {
    let listener = this._head.next;
    for (; listener; )
      listener.match(fn, context4) ? listener = listener.destroy() : listener = listener.next;
    return this._head.next || this._cancelIfNeeded(), this;
  }
  /**
   * The number of listeners on this ticker, calculated by walking through linked list
   * @readonly
   * @member {number}
   */
  get count() {
    if (!this._head)
      return 0;
    let count2 = 0, current = this._head;
    for (; current = current.next; )
      count2++;
    return count2;
  }
  /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */
  start() {
    this.started || (this.started = true, this._requestIfNeeded());
  }
  /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */
  stop() {
    this.started && (this.started = false, this._cancelIfNeeded());
  }
  /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */
  destroy() {
    if (!this._protected) {
      this.stop();
      let listener = this._head.next;
      for (; listener; )
        listener = listener.destroy(true);
      this._head.destroy(), this._head = null;
    }
  }
  /**
   * Triggers an update. An update entails setting the
   * current {@link PIXI.Ticker#elapsedMS},
   * the current {@link PIXI.Ticker#deltaTime},
   * invoking all listeners with current deltaTime,
   * and then finally setting {@link PIXI.Ticker#lastTime}
   * with the value of currentTime that was provided.
   * This method will be called automatically by animation
   * frame callbacks if the ticker instance has been started
   * and listeners are added.
   * @param {number} [currentTime=performance.now()] - the current time of execution
   */
  update(currentTime = performance.now()) {
    let elapsedMS;
    if (currentTime > this.lastTime) {
      if (elapsedMS = this.elapsedMS = currentTime - this.lastTime, elapsedMS > this._maxElapsedMS && (elapsedMS = this._maxElapsedMS), elapsedMS *= this.speed, this._minElapsedMS) {
        const delta = currentTime - this._lastFrame | 0;
        if (delta < this._minElapsedMS)
          return;
        this._lastFrame = currentTime - delta % this._minElapsedMS;
      }
      this.deltaMS = elapsedMS, this.deltaTime = this.deltaMS * _Ticker22.targetFPMS;
      const head = this._head;
      let listener = head.next;
      for (; listener; )
        listener = listener.emit(this.deltaTime);
      head.next || this._cancelIfNeeded();
    } else
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    this.lastTime = currentTime;
  }
  /**
   * The frames per second at which this ticker is running.
   * The default is approximately 60 in most modern browsers.
   * **Note:** This does not factor in the value of
   * {@link PIXI.Ticker#speed}, which is specific
   * to scaling {@link PIXI.Ticker#deltaTime}.
   * @member {number}
   * @readonly
   */
  get FPS() {
    return 1e3 / this.elapsedMS;
  }
  /**
   * Manages the maximum amount of milliseconds allowed to
   * elapse between invoking {@link PIXI.Ticker#update}.
   * This value is used to cap {@link PIXI.Ticker#deltaTime},
   * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
   * When setting this property it is clamped to a value between
   * `0` and `Ticker.targetFPMS * 1000`.
   * @member {number}
   * @default 10
   */
  get minFPS() {
    return 1e3 / this._maxElapsedMS;
  }
  set minFPS(fps2) {
    const minFPS = Math.min(this.maxFPS, fps2), minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker22.targetFPMS);
    this._maxElapsedMS = 1 / minFPMS;
  }
  /**
   * Manages the minimum amount of milliseconds required to
   * elapse between invoking {@link PIXI.Ticker#update}.
   * This will effect the measured value of {@link PIXI.Ticker#FPS}.
   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
   * Otherwise it will be at least `minFPS`
   * @member {number}
   * @default 0
   */
  get maxFPS() {
    return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
  }
  set maxFPS(fps2) {
    if (fps2 === 0)
      this._minElapsedMS = 0;
    else {
      const maxFPS = Math.max(this.minFPS, fps2);
      this._minElapsedMS = 1 / (maxFPS / 1e3);
    }
  }
  /**
   * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
   * {@link PIXI.VideoResource} to update animation frames / video textures.
   *
   * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
   *
   * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
   * @example
   * import { Ticker } from 'pixi.js';
   *
   * const ticker = Ticker.shared;
   * // Set this to prevent starting this ticker when listeners are added.
   * // By default this is true only for the PIXI.Ticker.shared instance.
   * ticker.autoStart = false;
   *
   * // FYI, call this to ensure the ticker is stopped. It should be stopped
   * // if you have not attempted to render anything yet.
   * ticker.stop();
   *
   * // Call this when you are ready for a running shared ticker.
   * ticker.start();
   * @example
   * import { autoDetectRenderer, Container } from 'pixi.js';
   *
   * // You may use the shared ticker to render...
   * const renderer = autoDetectRenderer();
   * const stage = new Container();
   * document.body.appendChild(renderer.view);
   * ticker.add((time) => renderer.render(stage));
   *
   * // Or you can just update it manually.
   * ticker.autoStart = false;
   * ticker.stop();
   * const animate = (time) => {
   *     ticker.update(time);
   *     renderer.render(stage);
   *     requestAnimationFrame(animate);
   * };
   * animate(performance.now());
   * @member {PIXI.Ticker}
   * @static
   */
  static get shared() {
    if (!_Ticker22._shared) {
      const shared = _Ticker22._shared = new _Ticker22();
      shared.autoStart = true, shared._protected = true;
    }
    return _Ticker22._shared;
  }
  /**
   * The system ticker instance used by {@link PIXI.BasePrepare} for core timing
   * functionality that shouldn't usually need to be paused, unlike the `shared`
   * ticker which drives visual animations and rendering which may want to be paused.
   *
   * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
   * @member {PIXI.Ticker}
   * @static
   */
  static get system() {
    if (!_Ticker22._system) {
      const system = _Ticker22._system = new _Ticker22();
      system.autoStart = true, system._protected = true;
    }
    return _Ticker22._system;
  }
};
_Ticker2.targetFPMS = 0.06;
var Ticker2 = _Ticker2;

// ../../node_modules/.pnpm/@pixi+ticker@7.3.1/node_modules/@pixi/ticker/lib/settings.mjs
Object.defineProperties(settings2, {
  /**
   * Target frames per millisecond.
   * @static
   * @name TARGET_FPMS
   * @memberof PIXI.settings
   * @type {number}
   * @deprecated since 7.1.0
   * @see PIXI.Ticker.targetFPMS
   */
  TARGET_FPMS: {
    get() {
      return Ticker2.targetFPMS;
    },
    set(value) {
      deprecation2("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS"), Ticker2.targetFPMS = value;
    }
  }
});

// ../../node_modules/.pnpm/@pixi+ticker@7.3.1/node_modules/@pixi/ticker/lib/TickerPlugin.mjs
var TickerPlugin2 = class {
  /**
   * Initialize the plugin with scope of application instance
   * @static
   * @private
   * @param {object} [options] - See application options
   */
  static init(options) {
    options = Object.assign({
      autoStart: true,
      sharedTicker: false
    }, options), Object.defineProperty(
      this,
      "ticker",
      {
        set(ticker) {
          this._ticker && this._ticker.remove(this.render, this), this._ticker = ticker, ticker && ticker.add(this.render, this, UPDATE_PRIORITY2.LOW);
        },
        get() {
          return this._ticker;
        }
      }
    ), this.stop = () => {
      this._ticker.stop();
    }, this.start = () => {
      this._ticker.start();
    }, this._ticker = null, this.ticker = options.sharedTicker ? Ticker2.shared : new Ticker2(), options.autoStart && this.start();
  }
  /**
   * Clean up the ticker, scoped to application.
   * @static
   * @private
   */
  static destroy() {
    if (this._ticker) {
      const oldTicker = this._ticker;
      this.ticker = null, oldTicker.destroy();
    }
  }
};
TickerPlugin2.extension = ExtensionType2.Application;
extensions2.add(TickerPlugin2);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/autoDetectRenderer.mjs
var renderers = [];
extensions2.handleByList(ExtensionType2.Renderer, renderers);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/framebuffer/MultisampleSystem.mjs
var MultisampleSystem = class {
  constructor(renderer) {
    this.renderer = renderer;
  }
  contextChange(gl) {
    let samples;
    if (this.renderer.context.webGLVersion === 1) {
      const framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null), samples = gl.getParameter(gl.SAMPLES), gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    } else {
      const framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null), samples = gl.getParameter(gl.SAMPLES), gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);
    }
    samples >= MSAA_QUALITY.HIGH ? this.multisample = MSAA_QUALITY.HIGH : samples >= MSAA_QUALITY.MEDIUM ? this.multisample = MSAA_QUALITY.MEDIUM : samples >= MSAA_QUALITY.LOW ? this.multisample = MSAA_QUALITY.LOW : this.multisample = MSAA_QUALITY.NONE;
  }
  destroy() {
  }
};
MultisampleSystem.extension = {
  type: ExtensionType2.RendererSystem,
  name: "_multisample"
};
extensions2.add(MultisampleSystem);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/geometry/GLBuffer.mjs
var GLBuffer = class {
  constructor(buffer2) {
    this.buffer = buffer2 || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/geometry/BufferSystem.mjs
var BufferSystem2 = class {
  /**
   * @param {PIXI.Renderer} renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this.renderer = renderer, this.managedBuffers = {}, this.boundBufferBases = {};
  }
  /**
   * @ignore
   */
  destroy() {
    this.renderer = null;
  }
  /** Sets up the renderer context and necessary buffers. */
  contextChange() {
    this.disposeAll(true), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }
  /**
   * This binds specified buffer. On first run, it will create the webGL buffers for the context too
   * @param buffer - the buffer to bind to the renderer
   */
  bind(buffer2) {
    const { gl, CONTEXT_UID } = this, glBuffer = buffer2._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer2);
    gl.bindBuffer(buffer2.type, glBuffer.buffer);
  }
  unbind(type2) {
    const { gl } = this;
    gl.bindBuffer(type2, null);
  }
  /**
   * Binds an uniform buffer to at the given index.
   *
   * A cache is used so a buffer will not be bound again if already bound.
   * @param buffer - the buffer to bind
   * @param index - the base index to bind it to.
   */
  bindBufferBase(buffer2, index) {
    const { gl, CONTEXT_UID } = this;
    if (this.boundBufferBases[index] !== buffer2) {
      const glBuffer = buffer2._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer2);
      this.boundBufferBases[index] = buffer2, gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
    }
  }
  /**
   * Binds a buffer whilst also binding its range.
   * This will make the buffer start from the offset supplied rather than 0 when it is read.
   * @param buffer - the buffer to bind
   * @param index - the base index to bind at, defaults to 0
   * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc
   */
  bindBufferRange(buffer2, index, offset) {
    const { gl, CONTEXT_UID } = this;
    offset = offset || 0;
    const glBuffer = buffer2._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer2);
    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);
  }
  /**
   * Will ensure the data in the buffer is uploaded to the GPU.
   * @param {PIXI.Buffer} buffer - the buffer to update
   */
  update(buffer2) {
    const { gl, CONTEXT_UID } = this, glBuffer = buffer2._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer2);
    if (buffer2._updateID !== glBuffer.updateID)
      if (glBuffer.updateID = buffer2._updateID, gl.bindBuffer(buffer2.type, glBuffer.buffer), glBuffer.byteLength >= buffer2.data.byteLength)
        gl.bufferSubData(buffer2.type, 0, buffer2.data);
      else {
        const drawType = buffer2.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
        glBuffer.byteLength = buffer2.data.byteLength, gl.bufferData(buffer2.type, buffer2.data, drawType);
      }
  }
  /**
   * Disposes buffer
   * @param {PIXI.Buffer} buffer - buffer with data
   * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray
   */
  dispose(buffer2, contextLost) {
    if (!this.managedBuffers[buffer2.id])
      return;
    delete this.managedBuffers[buffer2.id];
    const glBuffer = buffer2._glBuffers[this.CONTEXT_UID], gl = this.gl;
    buffer2.disposeRunner.remove(this), glBuffer && (contextLost || gl.deleteBuffer(glBuffer.buffer), delete buffer2._glBuffers[this.CONTEXT_UID]);
  }
  /**
   * dispose all WebGL resources of all managed buffers
   * @param {boolean} [contextLost=false] - If context was lost, we suppress `gl.delete` calls
   */
  disposeAll(contextLost) {
    const all = Object.keys(this.managedBuffers);
    for (let i3 = 0; i3 < all.length; i3++)
      this.dispose(this.managedBuffers[all[i3]], contextLost);
  }
  /**
   * creates and attaches a GLBuffer object tied to the current context.
   * @param buffer
   * @protected
   */
  createGLBuffer(buffer2) {
    const { CONTEXT_UID, gl } = this;
    return buffer2._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer()), this.managedBuffers[buffer2.id] = buffer2, buffer2.disposeRunner.add(this), buffer2._glBuffers[CONTEXT_UID];
  }
};
BufferSystem2.extension = {
  type: ExtensionType2.RendererSystem,
  name: "buffer"
};
extensions2.add(BufferSystem2);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/render/ObjectRendererSystem.mjs
var ObjectRendererSystem = class {
  // renderers scene graph!
  constructor(renderer) {
    this.renderer = renderer;
  }
  /**
   * Renders the object to its WebGL view.
   * @param displayObject - The object to be rendered.
   * @param options - the options to be passed to the renderer
   */
  render(displayObject, options) {
    const renderer = this.renderer;
    let renderTexture, clear, transform, skipUpdateTransform;
    if (options && (renderTexture = options.renderTexture, clear = options.clear, transform = options.transform, skipUpdateTransform = options.skipUpdateTransform), this.renderingToScreen = !renderTexture, renderer.runners.prerender.emit(), renderer.emit("prerender"), renderer.projection.transform = transform, !renderer.context.isLost) {
      if (renderTexture || (this.lastObjectRendered = displayObject), !skipUpdateTransform) {
        const cacheParent = displayObject.enableTempParent();
        displayObject.updateTransform(), displayObject.disableTempParent(cacheParent);
      }
      renderer.renderTexture.bind(renderTexture), renderer.batch.currentRenderer.start(), (clear ?? renderer.background.clearBeforeRender) && renderer.renderTexture.clear(), displayObject.render(renderer), renderer.batch.currentRenderer.flush(), renderTexture && (options.blit && renderer.framebuffer.blit(), renderTexture.baseTexture.update()), renderer.runners.postrender.emit(), renderer.projection.transform = null, renderer.emit("postrender");
    }
  }
  destroy() {
    this.renderer = null, this.lastObjectRendered = null;
  }
};
ObjectRendererSystem.extension = {
  type: ExtensionType2.RendererSystem,
  name: "objectRenderer"
};
extensions2.add(ObjectRendererSystem);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/Renderer.mjs
var _Renderer = class _Renderer2 extends SystemManager {
  /**
   * @param {PIXI.IRendererOptions} [options] - See {@link PIXI.settings.RENDER_OPTIONS} for defaults.
   */
  constructor(options) {
    super(), this.type = RENDERER_TYPE.WEBGL, options = Object.assign({}, settings2.RENDER_OPTIONS, options), this.gl = null, this.CONTEXT_UID = 0, this.globalUniforms = new UniformGroup2({
      projectionMatrix: new Matrix2()
    }, true);
    const systemConfig = {
      runners: [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "reset",
        "update",
        "postrender",
        "prerender",
        "resize"
      ],
      systems: _Renderer2.__systems,
      priority: [
        "_view",
        "textureGenerator",
        "background",
        "_plugin",
        "startup",
        // low level WebGL systems
        "context",
        "state",
        "texture",
        "buffer",
        "geometry",
        "framebuffer",
        "transformFeedback",
        // high level pixi specific rendering
        "mask",
        "scissor",
        "stencil",
        "projection",
        "textureGC",
        "filter",
        "renderTexture",
        "batch",
        "objectRenderer",
        "_multisample"
      ]
    };
    this.setup(systemConfig), "useContextAlpha" in options && (deprecation2("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead"), options.premultipliedAlpha = options.useContextAlpha && options.useContextAlpha !== "notMultiplied", options.backgroundAlpha = options.useContextAlpha === false ? 1 : options.backgroundAlpha), this._plugin.rendererPlugins = _Renderer2.__plugins, this.options = options, this.startup.run(this.options);
  }
  /**
   * Create renderer if WebGL is available. Overrideable
   * by the **@pixi/canvas-renderer** package to allow fallback.
   * throws error if WebGL is not available.
   * @param options
   * @private
   */
  static test(options) {
    return options?.forceCanvas ? false : isWebGLSupported2();
  }
  /**
   * Renders the object to its WebGL view.
   * @param displayObject - The object to be rendered.
   * @param {object} [options] - Object to use for render options.
   * @param {PIXI.RenderTexture} [options.renderTexture] - The render texture to render to.
   * @param {boolean} [options.clear=true] - Should the canvas be cleared before the new render.
   * @param {PIXI.Matrix} [options.transform] - A transform to apply to the render texture before rendering.
   * @param {boolean} [options.skipUpdateTransform=false] - Should we skip the update transform pass?
   */
  render(displayObject, options) {
    this.objectRenderer.render(displayObject, options);
  }
  /**
   * Resizes the WebGL view to the specified width and height.
   * @param desiredScreenWidth - The desired width of the screen.
   * @param desiredScreenHeight - The desired height of the screen.
   */
  resize(desiredScreenWidth, desiredScreenHeight) {
    this._view.resizeView(desiredScreenWidth, desiredScreenHeight);
  }
  /**
   * Resets the WebGL state so you can render things however you fancy!
   * @returns Returns itself.
   */
  reset() {
    return this.runners.reset.emit(), this;
  }
  /** Clear the frame buffer. */
  clear() {
    this.renderTexture.bind(), this.renderTexture.clear();
  }
  /**
   * Removes everything from the renderer (event listeners, spritebatch, etc...)
   * @param [removeView=false] - Removes the Canvas element from the DOM.
   *  See: https://github.com/pixijs/pixijs/issues/2233
   */
  destroy(removeView = false) {
    this.runners.destroy.items.reverse(), this.emitWithCustomOptions(this.runners.destroy, {
      _view: removeView
    }), super.destroy();
  }
  /** Collection of plugins */
  get plugins() {
    return this._plugin.plugins;
  }
  /** The number of msaa samples of the canvas. */
  get multisample() {
    return this._multisample.multisample;
  }
  /**
   * Same as view.width, actual number of pixels in the canvas by horizontal.
   * @member {number}
   * @readonly
   * @default 800
   */
  get width() {
    return this._view.element.width;
  }
  /**
   * Same as view.height, actual number of pixels in the canvas by vertical.
   * @default 600
   */
  get height() {
    return this._view.element.height;
  }
  /** The resolution / device pixel ratio of the renderer. */
  get resolution() {
    return this._view.resolution;
  }
  set resolution(value) {
    this._view.resolution = value, this.runners.resolutionChange.emit(value);
  }
  /** Whether CSS dimensions of canvas view should be resized to screen dimensions automatically. */
  get autoDensity() {
    return this._view.autoDensity;
  }
  /** The canvas element that everything is drawn to.*/
  get view() {
    return this._view.element;
  }
  /**
   * Measurements of the screen. (0, 0, screenWidth, screenHeight).
   *
   * Its safe to use as filterArea or hitArea for the whole stage.
   * @member {PIXI.Rectangle}
   */
  get screen() {
    return this._view.screen;
  }
  /** the last object rendered by the renderer. Useful for other plugins like interaction managers */
  get lastObjectRendered() {
    return this.objectRenderer.lastObjectRendered;
  }
  /** Flag if we are rendering to the screen vs renderTexture */
  get renderingToScreen() {
    return this.objectRenderer.renderingToScreen;
  }
  /** When logging Pixi to the console, this is the name we will show */
  get rendererLogId() {
    return `WebGL ${this.context.webGLVersion}`;
  }
  /**
   * This sets weather the screen is totally cleared between each frame withthe background color and alpha
   * @deprecated since 7.0.0
   */
  get clearBeforeRender() {
    return deprecation2("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead."), this.background.clearBeforeRender;
  }
  /**
   * Pass-thru setting for the canvas' context `alpha` property. This is typically
   * not something you need to fiddle with. If you want transparency, use `backgroundAlpha`.
   * @deprecated since 7.0.0
   * @member {boolean}
   */
  get useContextAlpha() {
    return deprecation2("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead."), this.context.useContextAlpha;
  }
  /**
   * readonly drawing buffer preservation
   * we can only know this if Pixi created the context
   * @deprecated since 7.0.0
   */
  get preserveDrawingBuffer() {
    return deprecation2("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context"), this.context.preserveDrawingBuffer;
  }
  /**
   * The background color to fill if not transparent
   * @member {number}
   * @deprecated since 7.0.0
   */
  get backgroundColor() {
    return deprecation2("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color;
  }
  set backgroundColor(value) {
    deprecation2("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color = value;
  }
  /**
   * The background color alpha. Setting this to 0 will make the canvas transparent.
   * @member {number}
   * @deprecated since 7.0.0
   */
  get backgroundAlpha() {
    return deprecation2("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.alpha;
  }
  /**
   * @deprecated since 7.0.0
   */
  set backgroundAlpha(value) {
    deprecation2("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.alpha = value;
  }
  /**
   * @deprecated since 7.0.0
   */
  get powerPreference() {
    return deprecation2("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context"), this.context.powerPreference;
  }
  /**
   * Useful function that returns a texture of the display object that can then be used to create sprites
   * This can be quite useful if your displayObject is complicated and needs to be reused multiple times.
   * @param displayObject - The displayObject the object will be generated from.
   * @param {IGenerateTextureOptions} options - Generate texture options.
   * @param {PIXI.Rectangle} options.region - The region of the displayObject, that shall be rendered,
   *        if no region is specified, defaults to the local bounds of the displayObject.
   * @param {number} [options.resolution] - If not given, the renderer's resolution is used.
   * @param {PIXI.MSAA_QUALITY} [options.multisample] - If not given, the renderer's multisample is used.
   * @returns A texture of the graphics object.
   */
  generateTexture(displayObject, options) {
    return this.textureGenerator.generateTexture(displayObject, options);
  }
};
_Renderer.extension = {
  type: ExtensionType2.Renderer,
  priority: 1
}, /**
* Collection of installed plugins. These are included by default in PIXI, but can be excluded
* by creating a custom build. Consult the README for more information about creating custom
* builds and excluding plugins.
* @private
*/
_Renderer.__plugins = {}, /**
* The collection of installed systems.
* @private
*/
_Renderer.__systems = {};
var Renderer = _Renderer;
extensions2.handleByMap(ExtensionType2.RendererPlugin, Renderer.__plugins);
extensions2.handleByMap(ExtensionType2.RendererSystem, Renderer.__systems);
extensions2.add(Renderer);

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.mjs
var AbstractMultiResource = class extends Resource2 {
  /**
   * @param length
   * @param options - Options to for Resource constructor
   * @param {number} [options.width] - Width of the resource
   * @param {number} [options.height] - Height of the resource
   */
  constructor(length, options) {
    const { width, height } = options || {};
    super(width, height), this.items = [], this.itemDirtyIds = [];
    for (let i3 = 0; i3 < length; i3++) {
      const partTexture = new BaseTexture();
      this.items.push(partTexture), this.itemDirtyIds.push(-2);
    }
    this.length = length, this._load = null, this.baseTexture = null;
  }
  /**
   * Used from ArrayResource and CubeResource constructors.
   * @param resources - Can be resources, image elements, canvas, etc. ,
   *  length should be same as constructor length
   * @param options - Detect options for resources
   */
  initFromArray(resources, options) {
    for (let i3 = 0; i3 < this.length; i3++)
      resources[i3] && (resources[i3].castToBaseTexture ? this.addBaseTextureAt(resources[i3].castToBaseTexture(), i3) : resources[i3] instanceof Resource2 ? this.addResourceAt(resources[i3], i3) : this.addResourceAt(autoDetectResource(resources[i3], options), i3));
  }
  /** Destroy this BaseImageResource. */
  dispose() {
    for (let i3 = 0, len = this.length; i3 < len; i3++)
      this.items[i3].destroy();
    this.items = null, this.itemDirtyIds = null, this._load = null;
  }
  /**
   * Set a resource by ID
   * @param resource
   * @param index - Zero-based index of resource to set
   * @returns - Instance for chaining
   */
  addResourceAt(resource, index) {
    if (!this.items[index])
      throw new Error(`Index ${index} is out of bounds`);
    return resource.valid && !this.valid && this.resize(resource.width, resource.height), this.items[index].setResource(resource), this;
  }
  /**
   * Set the parent base texture.
   * @param baseTexture
   */
  bind(baseTexture) {
    if (this.baseTexture !== null)
      throw new Error("Only one base texture per TextureArray is allowed");
    super.bind(baseTexture);
    for (let i3 = 0; i3 < this.length; i3++)
      this.items[i3].parentTextureArray = baseTexture, this.items[i3].on("update", baseTexture.update, baseTexture);
  }
  /**
   * Unset the parent base texture.
   * @param baseTexture
   */
  unbind(baseTexture) {
    super.unbind(baseTexture);
    for (let i3 = 0; i3 < this.length; i3++)
      this.items[i3].parentTextureArray = null, this.items[i3].off("update", baseTexture.update, baseTexture);
  }
  /**
   * Load all the resources simultaneously
   * @returns - When load is resolved
   */
  load() {
    if (this._load)
      return this._load;
    const promises = this.items.map((item) => item.resource).filter((item) => item).map((item) => item.load());
    return this._load = Promise.all(promises).then(
      () => {
        const { realWidth, realHeight } = this.items[0];
        return this.resize(realWidth, realHeight), this.update(), Promise.resolve(this);
      }
    ), this._load;
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/textures/resources/ArrayResource.mjs
var ArrayResource = class extends AbstractMultiResource {
  /**
   * @param source - Number of items in array or the collection
   *        of image URLs to use. Can also be resources, image elements, canvas, etc.
   * @param options - Options to apply to {@link PIXI.autoDetectResource}
   * @param {number} [options.width] - Width of the resource
   * @param {number} [options.height] - Height of the resource
   */
  constructor(source3, options) {
    const { width, height } = options || {};
    let urls, length;
    Array.isArray(source3) ? (urls = source3, length = source3.length) : length = source3, super(length, { width, height }), urls && this.initFromArray(urls, options);
  }
  /**
   * Set a baseTexture by ID,
   * ArrayResource just takes resource from it, nothing more
   * @param baseTexture
   * @param index - Zero-based index of resource to set
   * @returns - Instance for chaining
   */
  addBaseTextureAt(baseTexture, index) {
    if (baseTexture.resource)
      this.addResourceAt(baseTexture.resource, index);
    else
      throw new Error("ArrayResource does not support RenderTexture");
    return this;
  }
  /**
   * Add binding
   * @param baseTexture
   */
  bind(baseTexture) {
    super.bind(baseTexture), baseTexture.target = TARGETS.TEXTURE_2D_ARRAY;
  }
  /**
   * Upload the resources to the GPU.
   * @param renderer
   * @param texture
   * @param glTexture
   * @returns - whether texture was uploaded
   */
  upload(renderer, texture, glTexture) {
    const { length, itemDirtyIds, items } = this, { gl } = renderer;
    glTexture.dirtyId < 0 && gl.texImage3D(
      gl.TEXTURE_2D_ARRAY,
      0,
      glTexture.internalFormat,
      this._width,
      this._height,
      length,
      0,
      texture.format,
      glTexture.type,
      null
    );
    for (let i3 = 0; i3 < length; i3++) {
      const item = items[i3];
      itemDirtyIds[i3] < item.dirtyId && (itemDirtyIds[i3] = item.dirtyId, item.valid && gl.texSubImage3D(
        gl.TEXTURE_2D_ARRAY,
        0,
        0,
        // xoffset
        0,
        // yoffset
        i3,
        // zoffset
        item.resource.width,
        item.resource.height,
        1,
        texture.format,
        glTexture.type,
        item.resource.source
      ));
    }
    return true;
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/textures/resources/CanvasResource.mjs
var CanvasResource = class extends BaseImageResource {
  /**
   * @param source - Canvas element to use
   */
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor(source3) {
    super(source3);
  }
  /**
   * Used to auto-detect the type of resource.
   * @param {*} source - The source object
   * @returns {boolean} `true` if source is HTMLCanvasElement or OffscreenCanvas
   */
  static test(source3) {
    const { OffscreenCanvas: OffscreenCanvas2 } = globalThis;
    return OffscreenCanvas2 && source3 instanceof OffscreenCanvas2 ? true : globalThis.HTMLCanvasElement && source3 instanceof HTMLCanvasElement;
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/textures/resources/CubeResource.mjs
var _CubeResource = class _CubeResource2 extends AbstractMultiResource {
  /**
   * @param {Array<string|PIXI.Resource>} [source] - Collection of URLs or resources
   *        to use as the sides of the cube.
   * @param options - ImageResource options
   * @param {number} [options.width] - Width of resource
   * @param {number} [options.height] - Height of resource
   * @param {number} [options.autoLoad=true] - Whether to auto-load resources
   * @param {number} [options.linkBaseTexture=true] - In case BaseTextures are supplied,
   *   whether to copy them or use
   */
  constructor(source3, options) {
    const { width, height, autoLoad, linkBaseTexture } = options || {};
    if (source3 && source3.length !== _CubeResource2.SIDES)
      throw new Error(`Invalid length. Got ${source3.length}, expected 6`);
    super(6, { width, height });
    for (let i3 = 0; i3 < _CubeResource2.SIDES; i3++)
      this.items[i3].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i3;
    this.linkBaseTexture = linkBaseTexture !== false, source3 && this.initFromArray(source3, options), autoLoad !== false && this.load();
  }
  /**
   * Add binding.
   * @param baseTexture - parent base texture
   */
  bind(baseTexture) {
    super.bind(baseTexture), baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;
  }
  addBaseTextureAt(baseTexture, index, linkBaseTexture) {
    if (linkBaseTexture === void 0 && (linkBaseTexture = this.linkBaseTexture), !this.items[index])
      throw new Error(`Index ${index} is out of bounds`);
    if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0)
      if (baseTexture.resource)
        this.addResourceAt(baseTexture.resource, index);
      else
        throw new Error("CubeResource does not support copying of renderTexture.");
    else
      baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index, baseTexture.parentTextureArray = this.baseTexture, this.items[index] = baseTexture;
    return baseTexture.valid && !this.valid && this.resize(baseTexture.realWidth, baseTexture.realHeight), this.items[index] = baseTexture, this;
  }
  /**
   * Upload the resource
   * @param renderer
   * @param _baseTexture
   * @param glTexture
   * @returns {boolean} true is success
   */
  upload(renderer, _baseTexture, glTexture) {
    const dirty = this.itemDirtyIds;
    for (let i3 = 0; i3 < _CubeResource2.SIDES; i3++) {
      const side = this.items[i3];
      (dirty[i3] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) && (side.valid && side.resource ? (side.resource.upload(renderer, side, glTexture), dirty[i3] = side.dirtyId) : dirty[i3] < -1 && (renderer.gl.texImage2D(
        side.target,
        0,
        glTexture.internalFormat,
        _baseTexture.realWidth,
        _baseTexture.realHeight,
        0,
        _baseTexture.format,
        glTexture.type,
        null
      ), dirty[i3] = -1));
    }
    return true;
  }
  /**
   * Used to auto-detect the type of resource.
   * @param {*} source - The source object
   * @returns {boolean} `true` if source is an array of 6 elements
   */
  static test(source3) {
    return Array.isArray(source3) && source3.length === _CubeResource2.SIDES;
  }
};
_CubeResource.SIDES = 6;
var CubeResource = _CubeResource;

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.mjs
var ImageBitmapResource = class _ImageBitmapResource extends BaseImageResource {
  /**
   * @param source - ImageBitmap or URL to use.
   * @param options - Options to use.
   */
  constructor(source3, options) {
    options = options || {};
    let baseSource, url2, ownsImageBitmap;
    typeof source3 == "string" ? (baseSource = _ImageBitmapResource.EMPTY, url2 = source3, ownsImageBitmap = true) : (baseSource = source3, url2 = null, ownsImageBitmap = false), super(baseSource), this.url = url2, this.crossOrigin = options.crossOrigin ?? true, this.alphaMode = typeof options.alphaMode == "number" ? options.alphaMode : null, this.ownsImageBitmap = options.ownsImageBitmap ?? ownsImageBitmap, this._load = null, options.autoLoad !== false && this.load();
  }
  load() {
    return this._load ? this._load : (this._load = new Promise(async (resolve2, reject) => {
      if (this.url === null) {
        resolve2(this);
        return;
      }
      try {
        const response = await settings2.ADAPTER.fetch(this.url, {
          mode: this.crossOrigin ? "cors" : "no-cors"
        });
        if (this.destroyed)
          return;
        const imageBlob = await response.blob();
        if (this.destroyed)
          return;
        const imageBitmap = await createImageBitmap(imageBlob, {
          premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
        });
        if (this.destroyed) {
          imageBitmap.close();
          return;
        }
        this.source = imageBitmap, this.update(), resolve2(this);
      } catch (e3) {
        if (this.destroyed)
          return;
        reject(e3), this.onError.emit(e3);
      }
    }), this._load);
  }
  /**
   * Upload the image bitmap resource to GPU.
   * @param renderer - Renderer to upload to
   * @param baseTexture - BaseTexture for this resource
   * @param glTexture - GLTexture to use
   * @returns {boolean} true is success
   */
  upload(renderer, baseTexture, glTexture) {
    return this.source instanceof ImageBitmap ? (typeof this.alphaMode == "number" && (baseTexture.alphaMode = this.alphaMode), super.upload(renderer, baseTexture, glTexture)) : (this.load(), false);
  }
  /** Destroys this resource. */
  dispose() {
    this.ownsImageBitmap && this.source instanceof ImageBitmap && this.source.close(), super.dispose(), this._load = null;
  }
  /**
   * Used to auto-detect the type of resource.
   * @param {*} source - The source object
   * @returns {boolean} `true` if current environment support ImageBitmap, and source is string or ImageBitmap
   */
  static test(source3) {
    return !!globalThis.createImageBitmap && typeof ImageBitmap < "u" && (typeof source3 == "string" || source3 instanceof ImageBitmap);
  }
  /**
   * ImageBitmap cannot be created synchronously, so a empty placeholder canvas is needed when loading from URLs.
   * Only for internal usage.
   * @returns The cached placeholder canvas.
   */
  static get EMPTY() {
    return _ImageBitmapResource._EMPTY = _ImageBitmapResource._EMPTY ?? settings2.ADAPTER.createCanvas(0, 0), _ImageBitmapResource._EMPTY;
  }
};

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/textures/resources/SVGResource.mjs
var _SVGResource = class _SVGResource2 extends BaseImageResource {
  /**
   * @param sourceBase64 - Base64 encoded SVG element or URL for SVG file.
   * @param {object} [options] - Options to use
   * @param {number} [options.scale=1] - Scale to apply to SVG. Overridden by...
   * @param {number} [options.width] - Rasterize SVG this wide. Aspect ratio preserved if height not specified.
   * @param {number} [options.height] - Rasterize SVG this high. Aspect ratio preserved if width not specified.
   * @param {boolean} [options.autoLoad=true] - Start loading right away.
   */
  constructor(sourceBase64, options) {
    options = options || {}, super(settings2.ADAPTER.createCanvas()), this._width = 0, this._height = 0, this.svg = sourceBase64, this.scale = options.scale || 1, this._overrideWidth = options.width, this._overrideHeight = options.height, this._resolve = null, this._crossorigin = options.crossorigin, this._load = null, options.autoLoad !== false && this.load();
  }
  load() {
    return this._load ? this._load : (this._load = new Promise((resolve2) => {
      if (this._resolve = () => {
        this.update(), resolve2(this);
      }, _SVGResource2.SVG_XML.test(this.svg.trim())) {
        if (!btoa)
          throw new Error("Your browser doesn't support base64 conversions.");
        this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;
      }
      this._loadSvg();
    }), this._load);
  }
  /** Loads an SVG image from `imageUrl` or `data URL`. */
  _loadSvg() {
    const tempImage = new Image();
    BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin), tempImage.src = this.svg, tempImage.onerror = (event) => {
      this._resolve && (tempImage.onerror = null, this.onError.emit(event));
    }, tempImage.onload = () => {
      if (!this._resolve)
        return;
      const svgWidth = tempImage.width, svgHeight = tempImage.height;
      if (!svgWidth || !svgHeight)
        throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
      let width = svgWidth * this.scale, height = svgHeight * this.scale;
      (this._overrideWidth || this._overrideHeight) && (width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth, height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight), width = Math.round(width), height = Math.round(height);
      const canvas3 = this.source;
      canvas3.width = width, canvas3.height = height, canvas3._pixiId = `canvas_${uid2()}`, canvas3.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height), this._resolve(), this._resolve = null;
    };
  }
  /**
   * Get size from an svg string using a regular expression.
   * @param svgString - a serialized svg element
   * @returns - image extension
   */
  static getSize(svgString) {
    const sizeMatch = _SVGResource2.SVG_SIZE.exec(svgString), size3 = {};
    return sizeMatch && (size3[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3])), size3[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]))), size3;
  }
  /** Destroys this texture. */
  dispose() {
    super.dispose(), this._resolve = null, this._crossorigin = null;
  }
  /**
   * Used to auto-detect the type of resource.
   * @param {*} source - The source object
   * @param {string} extension - The extension of source, if set
   * @returns {boolean} - If the source is a SVG source or data file
   */
  static test(source3, extension) {
    return extension === "svg" || typeof source3 == "string" && source3.startsWith("data:image/svg+xml") || typeof source3 == "string" && _SVGResource2.SVG_XML.test(source3);
  }
  // eslint-disable-line max-len
};
_SVGResource.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, /**
* Regular expression for SVG size.
* @example &lt;svg width="100" height="100"&gt;&lt;/svg&gt;
* @readonly
*/
_SVGResource.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
var SVGResource = _SVGResource;

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/textures/resources/VideoResource.mjs
var _VideoResource = class _VideoResource2 extends BaseImageResource {
  /**
   * @param {HTMLVideoElement|object|string|Array<string|object>} source - Video element to use.
   * @param {object} [options] - Options to use
   * @param {boolean} [options.autoLoad=true] - Start loading the video immediately
   * @param {boolean} [options.autoPlay=true] - Start playing video immediately
   * @param {number} [options.updateFPS=0] - How many times a second to update the texture from the video.
   * Leave at 0 to update at every render.
   * @param {boolean} [options.crossorigin=true] - Load image using cross origin
   * @param {boolean} [options.loop=false] - Loops the video
   * @param {boolean} [options.muted=false] - Mutes the video audio, useful for autoplay
   * @param {boolean} [options.playsinline=true] - Prevents opening the video on mobile devices
   */
  constructor(source3, options) {
    if (options = options || {}, !(source3 instanceof HTMLVideoElement)) {
      const videoElement = document.createElement("video");
      options.autoLoad !== false && videoElement.setAttribute("preload", "auto"), options.playsinline !== false && (videoElement.setAttribute("webkit-playsinline", ""), videoElement.setAttribute("playsinline", "")), options.muted === true && (videoElement.setAttribute("muted", ""), videoElement.muted = true), options.loop === true && videoElement.setAttribute("loop", ""), options.autoPlay !== false && videoElement.setAttribute("autoplay", ""), typeof source3 == "string" && (source3 = [source3]);
      const firstSrc = source3[0].src || source3[0];
      BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
      for (let i3 = 0; i3 < source3.length; ++i3) {
        const sourceElement = document.createElement("source");
        let { src, mime } = source3[i3];
        if (src = src || source3[i3], src.startsWith("data:"))
          mime = src.slice(5, src.indexOf(";"));
        else if (!src.startsWith("blob:")) {
          const baseSrc = src.split("?").shift().toLowerCase(), ext = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);
          mime = mime || _VideoResource2.MIME_TYPES[ext] || `video/${ext}`;
        }
        sourceElement.src = src, mime && (sourceElement.type = mime), videoElement.appendChild(sourceElement);
      }
      source3 = videoElement;
    }
    super(source3), this.noSubImage = true, this._autoUpdate = true, this._isConnectedToTicker = false, this._updateFPS = options.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = options.autoPlay !== false, this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), options.autoLoad !== false && this.load();
  }
  /**
   * Trigger updating of the texture.
   * @param _deltaTime - time delta since last tick
   */
  update(_deltaTime = 0) {
    if (!this.destroyed) {
      if (this._updateFPS) {
        const elapsedMS = Ticker2.shared.elapsedMS * this.source.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
      }
      (!this._updateFPS || this._msToNextUpdate <= 0) && (super.update(
        /* deltaTime*/
      ), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);
    }
  }
  _videoFrameRequestCallback() {
    this.update(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(
      this._videoFrameRequestCallback
    );
  }
  /**
   * Start preloading the video resource.
   * @returns {Promise<void>} Handle the validate event
   */
  load() {
    if (this._load)
      return this._load;
    const source3 = this.source;
    return (source3.readyState === source3.HAVE_ENOUGH_DATA || source3.readyState === source3.HAVE_FUTURE_DATA) && source3.width && source3.height && (source3.complete = true), source3.addEventListener("play", this._onPlayStart), source3.addEventListener("pause", this._onPlayStop), source3.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._onCanPlay() : (source3.addEventListener("canplay", this._onCanPlay), source3.addEventListener("canplaythrough", this._onCanPlay), source3.addEventListener("error", this._onError, true)), this._load = new Promise((resolve2, reject) => {
      this.valid ? resolve2(this) : (this._resolve = resolve2, this._reject = reject, source3.load());
    }), this._load;
  }
  /**
   * Handle video error events.
   * @param event
   */
  _onError(event) {
    this.source.removeEventListener("error", this._onError, true), this.onError.emit(event), this._reject && (this._reject(event), this._reject = null, this._resolve = null);
  }
  /**
   * Returns true if the underlying source is playing.
   * @returns - True if playing.
   */
  _isSourcePlaying() {
    const source3 = this.source;
    return !source3.paused && !source3.ended && this._isSourceReady();
  }
  /**
   * Returns true if the underlying source is ready for playing.
   * @returns - True if ready.
   */
  _isSourceReady() {
    return this.source.readyState > 2;
  }
  /** Runs the update loop when the video is ready to play. */
  _onPlayStart() {
    this.valid || this._onCanPlay(), this._configureAutoUpdate();
  }
  /** Fired when a pause event is triggered, stops the update loop. */
  _onPlayStop() {
    this._configureAutoUpdate();
  }
  /** Fired when the video is completed seeking to the current playback position. */
  _onSeeked() {
    this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.update(), this._msToNextUpdate = 0);
  }
  /** Fired when the video is loaded and ready to play. */
  _onCanPlay() {
    const source3 = this.source;
    source3.removeEventListener("canplay", this._onCanPlay), source3.removeEventListener("canplaythrough", this._onCanPlay);
    const valid = this.valid;
    this._msToNextUpdate = 0, this.update(), this._msToNextUpdate = 0, !valid && this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && source3.play();
  }
  /** Destroys this texture. */
  dispose() {
    this._configureAutoUpdate();
    const source3 = this.source;
    source3 && (source3.removeEventListener("play", this._onPlayStart), source3.removeEventListener("pause", this._onPlayStop), source3.removeEventListener("seeked", this._onSeeked), source3.removeEventListener("canplay", this._onCanPlay), source3.removeEventListener("canplaythrough", this._onCanPlay), source3.removeEventListener("error", this._onError, true), source3.pause(), source3.src = "", source3.load()), super.dispose();
  }
  /** Should the base texture automatically update itself, set to true by default. */
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    value !== this._autoUpdate && (this._autoUpdate = value, this._configureAutoUpdate());
  }
  /**
   * How many times a second to update the texture from the video. Leave at 0 to update at every render.
   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
   */
  get updateFPS() {
    return this._updateFPS;
  }
  set updateFPS(value) {
    value !== this._updateFPS && (this._updateFPS = value, this._configureAutoUpdate());
  }
  _configureAutoUpdate() {
    this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.source.requestVideoFrameCallback ? (this._isConnectedToTicker && (Ticker2.shared.remove(this.update, this), this._isConnectedToTicker = false, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(
      this._videoFrameRequestCallback
    ))) : (this._videoFrameRequestCallbackHandle !== null && (this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (Ticker2.shared.add(this.update, this), this._isConnectedToTicker = true, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (Ticker2.shared.remove(this.update, this), this._isConnectedToTicker = false, this._msToNextUpdate = 0));
  }
  /**
   * Used to auto-detect the type of resource.
   * @param {*} source - The source object
   * @param {string} extension - The extension of source, if set
   * @returns {boolean} `true` if video source
   */
  static test(source3, extension) {
    return globalThis.HTMLVideoElement && source3 instanceof HTMLVideoElement || _VideoResource2.TYPES.includes(extension);
  }
};
_VideoResource.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], /**
* Map of video MIME types that can't be directly derived from file extensions.
* @readonly
*/
_VideoResource.MIME_TYPES = {
  ogv: "video/ogg",
  mov: "video/quicktime",
  m4v: "video/mp4"
};
var VideoResource = _VideoResource;

// ../../node_modules/.pnpm/@pixi+core@7.3.1/node_modules/@pixi/core/lib/textures/resources/index.mjs
INSTALLED.push(
  ImageBitmapResource,
  ImageResource,
  CanvasResource,
  VideoResource,
  SVGResource,
  BufferResource2,
  CubeResource,
  ArrayResource
);

// ../../node_modules/.pnpm/@pixi+filter-glow@5.2.1_@pixi+core@7.3.1/node_modules/@pixi/filter-glow/dist/filter-glow.mjs
var f2 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`;
var p2 = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

uniform float outerStrength;
uniform float innerStrength;

uniform vec4 glowColor;

uniform vec4 filterArea;
uniform vec4 filterClamp;
uniform bool knockout;
uniform float alpha;

const float PI = 3.14159265358979323846264;

const float DIST = __DIST__;
const float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.0);
const float ANGLE_STEP_NUM = ceil(PI * 2.0 / ANGLE_STEP_SIZE);

const float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.0) / 2.0;

void main(void) {
    vec2 px = vec2(1.0 / filterArea.x, 1.0 / filterArea.y);

    float totalAlpha = 0.0;

    vec2 direction;
    vec2 displaced;
    vec4 curColor;

    for (float angle = 0.0; angle < PI * 2.0; angle += ANGLE_STEP_SIZE) {
       direction = vec2(cos(angle), sin(angle)) * px;

       for (float curDistance = 0.0; curDistance < DIST; curDistance++) {
           displaced = clamp(vTextureCoord + direction * 
                   (curDistance + 1.0), filterClamp.xy, filterClamp.zw);

           curColor = texture2D(uSampler, displaced);

           totalAlpha += (DIST - curDistance) * curColor.a;
       }
    }
    
    curColor = texture2D(uSampler, vTextureCoord);

    float alphaRatio = (totalAlpha / MAX_TOTAL_ALPHA);

    float innerGlowAlpha = (1.0 - alphaRatio) * innerStrength * curColor.a;
    float innerGlowStrength = min(1.0, innerGlowAlpha);
    
    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);

    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a);
    float outerGlowStrength = min(1.0 - innerColor.a, outerGlowAlpha);

    if (knockout) {
      float resultAlpha = (outerGlowAlpha + innerGlowAlpha) * alpha;
      gl_FragColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);
    }
    else {
      vec4 outerGlowColor = outerGlowStrength * glowColor.rgba * alpha;
      gl_FragColor = innerColor + outerGlowColor;
    }
}
`;
var e2 = class extends Filter2 {
  constructor(n2) {
    const r2 = Object.assign({}, e2.defaults, n2), { outerStrength: a2, innerStrength: i3, color: u3, knockout: c2, quality: s2, alpha: h2 } = r2, o2 = Math.round(r2.distance);
    super(f2, p2.replace(/__ANGLE_STEP_SIZE__/gi, `${(1 / s2 / o2).toFixed(7)}`).replace(/__DIST__/gi, `${o2.toFixed(0)}.0`)), this.uniforms.glowColor = new Float32Array([0, 0, 0, 1]), this.uniforms.alpha = 1, Object.assign(this, { color: u3, outerStrength: a2, innerStrength: i3, padding: o2, knockout: c2, alpha: h2 });
  }
  get color() {
    return lib_exports.rgb2hex(this.uniforms.glowColor);
  }
  set color(n2) {
    lib_exports.hex2rgb(n2, this.uniforms.glowColor);
  }
  get outerStrength() {
    return this.uniforms.outerStrength;
  }
  set outerStrength(n2) {
    this.uniforms.outerStrength = n2;
  }
  get innerStrength() {
    return this.uniforms.innerStrength;
  }
  set innerStrength(n2) {
    this.uniforms.innerStrength = n2;
  }
  get knockout() {
    return this.uniforms.knockout;
  }
  set knockout(n2) {
    this.uniforms.knockout = n2;
  }
  get alpha() {
    return this.uniforms.alpha;
  }
  set alpha(n2) {
    this.uniforms.alpha = n2;
  }
};
var l2 = e2;
l2.defaults = { distance: 10, outerStrength: 4, innerStrength: 0, color: 16777215, quality: 0.1, knockout: false, alpha: 1 };

// src/frontend/game/game-state.ts
var GameState = {
  agent: {
    symbol: "",
    credits: 0
  },
  currentView: "universe",
  currentSystem: void 0,
  selected: void 0,
  systemShips: {},
  shipData: {},
  waypoints: {},
  systems: {},
  universeShips: {},
  displayedMarket: void 0,
  systemData: {},
  waypointData: {}
};

// src/frontend/game/base-elements/base-button.ts
var BaseButton = class extends NineSlicePlane {
  constructor(text, baseButtonProperties, clickAction) {
    super(loadedAssets.buttonsheet.textures["button#default"], 3, 3, 3, 3);
    this.clickAction = clickAction;
    const textSize = baseButtonProperties.textSize ?? 16;
    this.bitmapText = new BitmapText2(text, {
      fontName: "buttontext_white",
      fontSize: textSize,
      tint: 65280,
      align: "center"
    });
    this.interactive = true;
    this.width = baseButtonProperties?.width ?? 200;
    this.height = baseButtonProperties?.height ?? 40;
    this.cursor = "pointer";
    this.on("mouseover", () => {
      if (!this.isDisabled) {
        this.texture = loadedAssets.buttonsheet.textures["button#hover"];
      }
    });
    this.on("mouseout", () => {
      if (!this.isDisabled) {
        this.texture = loadedAssets.buttonsheet.textures["button#default"];
      }
    });
    this.on("mousedown", () => {
      if (!this.isDisabled) {
        this.texture = loadedAssets.buttonsheet.textures["button#down"];
      }
    });
    this.on("mouseup", () => {
      if (!this.isDisabled) {
        this.texture = loadedAssets.buttonsheet.textures["button#hover"];
      }
    });
    this.on("mouseupoutside", () => {
      if (!this.isDisabled) {
        this.texture = loadedAssets.buttonsheet.textures["button#default"];
      }
    });
    if (this.clickAction) {
      this.on("click", this.clickAction);
    }
    this.addChild(this.bitmapText);
  }
  isDisabled = false;
  bitmapText;
  set width(value) {
    this.bitmapText.x = (value - this.bitmapText.getBounds().width) / 2;
    super.width = value;
  }
  set height(value) {
    this.bitmapText.y = (value - this.bitmapText.getBounds().height) / 2;
    super.height = value;
  }
  set disabled(disabled) {
    if (disabled && !this.isDisabled) {
      console.log("flip disabled");
      this.texture = loadedAssets.buttonsheet.textures["button#disabled"];
      this.cursor = "default";
      this.bitmapText.tint = 11184810;
      this.isDisabled = true;
      this.off("click");
    } else if (!disabled && this.isDisabled) {
      console.log("flip enabled");
      this.texture = loadedAssets.buttonsheet.textures["button#default"];
      this.cursor = "pointer";
      this.bitmapText.tint = 65280;
      this.isDisabled = false;
      if (this.clickAction) {
        this.on("click", this.clickAction);
      }
    }
  }
  get disabled() {
    return this.isDisabled;
  }
};

// src/frontend/game/makeInteractiveAndSelectable.ts
var deselectListeners = new eventemitter3_default();
function makeInteractiveAndSelectable(item, options) {
  item.interactive = true;
  item.cursor = "pointer";
  item.on("mouseover", () => {
    item.filters = [new l2()];
    options?.onMouseOver?.();
  });
  const removeGlow = () => {
    item.filters = [];
  };
  item.on("mouseout", removeGlow);
  item.on("mouseout", () => {
    options?.onMouseOut?.();
  });
  if (options?.onOrder) {
    item.on("rightclick", async (event) => {
      event.stopPropagation();
      const allCommands = typeof options.onOrder == "function" ? await options.onOrder() : options.onOrder;
      const filteredCommands = allCommands.filter((c2) => {
        if (c2.withSelection && (!GameState.selected || GameState.selected.type !== c2.withSelection)) {
          return false;
        }
        return true;
      });
      const isCommandAvailable = await Promise.all(filteredCommands.map((c2) => {
        return c2.isAvailable ? c2.isAvailable() : true;
      }));
      const validCommands = filteredCommands.filter((c2, index) => {
        return isCommandAvailable[index];
      });
      if (validCommands.length == 0) {
      } else if (filteredCommands.length === 1) {
        filteredCommands[0].action(GameState.selected.symbol);
      } else {
        const background = new NineSlicePlane(loadedAssets.statsBlock);
        background.height = filteredCommands.length * 40;
        background.width = 180;
        filteredCommands.forEach((comm, index) => {
          const button = new BaseButton(comm.name, {
            width: 160,
            height: 30,
            textSize: 16
          }, (event2) => {
            event2.stopPropagation();
            comm.action(GameState.selected.symbol);
            item.removeChild(background);
          });
          button.x = 10;
          button.y = 10 + index * 35;
          button.disabled = !isCommandAvailable[index];
          background.addChild(button);
        });
        item.addChild(background);
        deselectListeners.once("deselect", () => {
          item.removeChild(background);
        });
      }
    });
  }
  if (options?.onSelect) {
    item.on("click", (event) => {
      deselectListeners.emit("deselect");
      event.stopPropagation();
      deselectListeners.once("deselect", () => {
        removeGlow();
        GameState.selected = false;
        item.on("mouseout", removeGlow);
      });
      item.off("mouseout", removeGlow);
      GameState.selected = options.onSelect;
    });
  }
}

// src/frontend/game/consts.ts
var totalSize = 5e5;
var systemScale = 12;
var universeCoordinates = {
  minX: 0,
  minY: 0,
  maxX: 0,
  maxY: 0
};
var systemCoordinates = {
  minX: 0,
  minY: 0
};
var scale = {
  universe: 1
};
var gameWidth = window.innerWidth ?? 1920;
var gameHeight = window.innerHeight ?? 1080;

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/index.mjs
init_init7();
init_all2();
init_init8();
init_init9();
init_init10();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs
init_GlProgram2();
init_GpuProgram2();
init_UniformGroup2();
init_Texture2();
init_Filter2();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/blend-template2.mjs
var blendTemplateFrag2 = "\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 fragColor;\n\nuniform float uBlend;\n\nuniform sampler2D uSampler;\nuniform sampler2D backTexture;\n\n{FUNCTIONS}\n\nvoid main()\n{ \n    vec4 back = texture(backTexture, vTextureCoord);\n    vec4 front = texture(uSampler, vTextureCoord);\n\n    {MAIN}\n}\n";

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/blend-template3.mjs
var blendTemplateVert2 = "in vec2 aPosition;\nout vec2 vTextureCoord;\nout vec2 backgroundUv;\n\nuniform globalUniforms {\n  mat3 projectionMatrix;\n  mat3 worldTransformMatrix;\n  float worldAlpha;\n};\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nuniform vec4 backgroundFrame;\nuniform vec4 outputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * outputFrame.zw + outputFrame.xy;\n    \n    position.x = position.x * (2.0 / outputTexture.x) - 1.0;\n    position.y = position.y * (2.0*outputTexture.z / outputTexture.y) - outputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/blend-template.mjs
var blendTemplate2 = "struct GlobalUniforms {\n  projectionMatrix:mat3x3<f32>,\n  worldTransformMatrix:mat3x3<f32>,\n  worldAlpha: f32\n}\n\nstruct GlobalFilterUniforms {\n  inputSize:vec4<f32>,\n  inputPixel:vec4<f32>,\n  inputClamp:vec4<f32>,\n  outputFrame:vec4<f32>,\n  globalFrame:vec4<f32>,\n  outputTexture:vec4<f32>,\n};\n\nstruct BlendUniforms {\n  uBlend:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uSampler: texture_2d<f32>;\n@group(0) @binding(2) var mySampler : sampler;\n@group(0) @binding(3) var backTexture: texture_2d<f32>;\n\n@group(1) @binding(0) var<uniform> blendUniforms : BlendUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.outputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.outputTexture.z / gfu.outputTexture.y) - gfu.outputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  \n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n{FUNCTIONS}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>\n) -> @location(0) vec4<f32> {\n\n\n   var back =  textureSample(backTexture, mySampler, uv);\n   var front = textureSample(uSampler, mySampler, uv);\n   \n   var out = vec4<f32>(0.0,0.0,0.0,0.0);\n\n   {MAIN}\n\n   return out;\n}";

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs
var BlendModeFilter2 = class extends Filter3 {
  constructor(options) {
    const gpuOptions = options.gpu;
    const gpuSource = compileBlendModeShader2({ source: blendTemplate2, ...gpuOptions });
    const gpuProgram = new GpuProgram2({
      vertex: {
        source: gpuSource,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: gpuSource,
        entryPoint: "mainFragment"
      }
    });
    const glOptions = options.gl;
    const glSource = compileBlendModeShader2({ source: blendTemplateFrag2, ...glOptions });
    const glProgram = new GlProgram2({
      vertex: blendTemplateVert2,
      fragment: glSource
    });
    const uniformGroup = new UniformGroup3({
      uBlend: {
        value: 1,
        type: "f32"
      }
    });
    super({
      gpuProgram,
      glProgram,
      blendRequired: true,
      resources: {
        blendUniforms: uniformGroup,
        backTexture: Texture4.EMPTY
      }
    });
  }
};
function compileBlendModeShader2(options) {
  const { source: source3, functions, main } = options;
  return source3.replace("{FUNCTIONS}", functions).replace("{MAIN}", main);
}

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.mjs
var hslgl2 = `
	float getLuminosity(vec3 c) {
		return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;
	}

	vec3 setLuminosity(vec3 c, float lum) {
		float modLum = lum - getLuminosity(c);
		vec3 color = c.rgb + vec3(modLum);

		// clip back into legal range
		modLum = getLuminosity(color);
		vec3 modLumVec = vec3(modLum);

		float cMin = min(color.r, min(color.g, color.b));
		float cMax = max(color.r, max(color.g, color.b));

		if(cMin < 0.0) {
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0) {
			color = mix(modLumVec, color, (1.0 - modLum) / (cMax - modLum));
		}

		return color;
	}

	float getSaturation(vec3 c) {
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	vec3 setSaturationMinMidMax(vec3 cSorted, float s) {
		vec3 colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x) {
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else {
			colorSorted.y = 0.0;
			colorSorted.z = 0.0;
		}

		colorSorted.x = 0.0;

		return colorSorted;
	}

	vec3 setSaturation(vec3 c, float s) {
		vec3 color = c;

		if(color.r <= color.g && color.r <= color.b) {
			if(color.g <= color.b) {
				color = setSaturationMinMidMax(color.rgb, s).rgb;
			}
			else {
				color = setSaturationMinMidMax(color.rbg, s).rbg;
			}
		}
		else if(color.g <= color.r && color.g <= color.b) {
			if(color.r <= color.b) {
				color = setSaturationMinMidMax(color.grb, s).grb;
			}
			else {
				color = setSaturationMinMidMax(color.gbr, s).gbr;
			}
		}
		else {
			// Using bgr for both fixes part of hue
			if(color.r <= color.g) {
				color = setSaturationMinMidMax(color.brg, s).brg;
			}
			else {
				color = setSaturationMinMidMax(color.bgr, s).bgr;
			}
		}

		return color;
	}
    `;

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.mjs
var hslgpu2 = `
	fn getLuminosity(c: vec3<f32>) -> f32
	{
		return 0.3*c.r + 0.59*c.g + 0.11*c.b;
	}

	fn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32>
	{
		var modLum: f32 = lum - getLuminosity(c);
		var color: vec3<f32> = c.rgb + modLum;

		// clip back into legal range
		modLum = getLuminosity(color);
		let modLumVec = vec3<f32>(modLum);

		let cMin: f32 = min(color.r, min(color.g, color.b));
		let cMax: f32 = max(color.r, max(color.g, color.b));

		if(cMin < 0.0)
		{
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0)
		{
			color = mix(modLumVec, color, (1 - modLum) / (cMax - modLum));
		}

		return color;
	}

	fn getSaturation(c: vec3<f32>) -> f32
	{
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	fn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32>
	{
		var colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x)
		{
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else
		{
			colorSorted.y = 0;
			colorSorted.z = 0;
		}

		colorSorted.x = 0;

		return colorSorted;
	}

	fn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32>
	{
		var color = c;

		if (color.r <= color.g && color.r <= color.b)
		{
			if (color.g <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rgb, s)).rgb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rbg, s)).rbg;
			}
		}
		else if (color.g <= color.r && color.g <= color.b)
		{
			if (color.r <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.grb, s)).grb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.gbr, s)).gbr;
			}
		}
		else
		{
			// Using bgr for both fixes part of hue
			if (color.r <= color.g)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.brg, s)).brg;
			}
			else
			{
				color  = vec3<f32>(setSaturationMinMidMax(color.bgr, s)).bgr;
			}
		}

		return color;
	}
	`;

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/init.mjs
init_Extensions2();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/ColorBlend.mjs
init_Extensions2();
var ColorBlend2 = class extends BlendModeFilter2 {
  constructor() {
    super({
      gl: {
        functions: `
                ${hslgl2}

                vec3 blendColor(vec3 base, vec3 blend,  float opacity)
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendColor(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                ${hslgpu2}

                fn blendColorOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendColorOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
      }
    });
  }
};
ColorBlend2.extension = {
  name: "color",
  type: ExtensionType3.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/ColorBurnBlend.mjs
init_Extensions2();
var ColorBurnBlend2 = class extends BlendModeFilter2 {
  constructor() {
    super({
      gl: {
        functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0 - ((1.0 - base) / blend)), 0.0);
                }

                vec3 blendColorBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                fragColor = vec4(blendColorBurn(back.rgb, front.rgb, front.a), uBlend);
            `
      },
      gpu: {
        functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn blendColorBurn(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendColorBurn(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
      }
    });
  }
};
ColorBurnBlend2.extension = {
  name: "color-burn",
  type: ExtensionType3.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/ColorDodgeBlend.mjs
init_Extensions2();
var ColorDodgeBlend2 = class extends BlendModeFilter2 {
  constructor() {
    super({
      gl: {
        functions: `
                float colorDodge(float base, float blend)
                {
                    return base / (1.0 - blend);
                }

                vec3 blendColorDodge(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendColorDodge(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return base / (1.0 - blend);
                }

                fn blendColorDodge(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                    out = vec4<f32>(blendColorDodge(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
      }
    });
  }
};
ColorDodgeBlend2.extension = {
  name: "color-dodge",
  type: ExtensionType3.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/DarkenBlend.mjs
init_Extensions2();
var DarkenBlend2 = class extends BlendModeFilter2 {
  constructor() {
    super({
      gl: {
        functions: `
                vec3 blendDarken(vec3 base, vec3 blend, float opacity)
                {
                    return (min(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendDarken(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn blendDarken(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (min(blend,base) * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendDarken(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
      }
    });
  }
};
DarkenBlend2.extension = {
  name: "darken",
  type: ExtensionType3.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/DifferenceBlend.mjs
init_Extensions2();
var DifferenceBlend2 = class extends BlendModeFilter2 {
  constructor() {
    super({
      gl: {
        functions: `
                vec3 blendDifference(vec3 base, vec3 blend,  float opacity)
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                fragColor = vec4(blendDifference(back.rgb, front.rgb, front.a), uBlend);
            `
      },
      gpu: {
        functions: `
                fn blendDifference(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendDifference(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
      }
    });
  }
};
DifferenceBlend2.extension = {
  name: "difference",
  type: ExtensionType3.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/DivideBlend.mjs
init_Extensions2();
var DivideBlend2 = class extends BlendModeFilter2 {
  constructor() {
    super({
      gl: {
        functions: `
                float divide(float base, float blend)
                {
                    return (blend > 0.0) ? clamp(base / blend, 0.0, 1.0) : 1.0;
                }

                vec3 blendDivide(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendDivide(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn divide(base: f32, blend: f32) -> f32
                {
                    return select(1.0, clamp(base / blend, 0.0, 1.0), blend > 0.0);
                }

                fn blendDivide(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendDivide(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
      }
    });
  }
};
DivideBlend2.extension = {
  name: "divide",
  type: ExtensionType3.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/ExclusionBlend.mjs
init_Extensions2();
var ExclusionBlend2 = class extends BlendModeFilter2 {
  constructor() {
    super({
      gl: {
        functions: `
                vec3 exclusion(vec3 base, vec3 blend)
                {
                    return base + blend - 2.0 * base * blend;
                }

                vec3 blendExclusion(vec3 base, vec3 blend, float opacity)
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendExclusion(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn exclusion(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return base+blend-2.0*base*blend;
                }

                fn blendExclusion(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendExclusion(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
      }
    });
  }
};
ExclusionBlend2.extension = {
  name: "exclusion",
  type: ExtensionType3.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/HardLightBlend.mjs
init_Extensions2();
var HardLightBlend2 = class extends BlendModeFilter2 {
  constructor() {
    super({
      gl: {
        functions: `
                float hardLight(float base, float blend)
                {
                    return (blend < 0.5) ? 2.0 * base * blend : 1.0 - 2.0 * (1.0 - base) * (1.0 - blend);
                }

                vec3 blendHardLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                fragColor = vec4(blendHardLight(back.rgb, front.rgb, front.a), uBlend);
            `
      },
      gpu: {
        functions: `
                fn hardLight(base: f32, blend: f32) -> f32
                {
                    return select(1.0 - 2.0 * (1.0 - base) * (1.0 - blend), 2.0 * base * blend, blend < 0.5);
                }

                fn blendHardLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendHardLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
      }
    });
  }
};
HardLightBlend2.extension = {
  name: "hard-light",
  type: ExtensionType3.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/HardMixBlend.mjs
init_Extensions2();
var HardMixBlend2 = class extends BlendModeFilter2 {
  constructor() {
    super({
      gl: {
        functions: `
                float hardMix(float base, float blend)
                {
                    return (base + blend >= 1.0) ? 1.0 : 0.0;
                }

                vec3 blendHardMix(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blended = vec3(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                fragColor = vec4(blendHardMix(back.rgb, front.rgb, front.a), uBlend);
            `
      },
      gpu: {
        functions: `
                fn hardMix(base: f32, blend: f32) -> f32
                {
                    return select(0.0, 1.0, base + blend >= 1.0);
                }

                fn blendHardMix(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendHardMix(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
      }
    });
  }
};
HardMixBlend2.extension = {
  name: "hard-mix",
  type: ExtensionType3.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/LightenBlend.mjs
init_Extensions2();
var LightenBlend2 = class extends BlendModeFilter2 {
  constructor() {
    super({
      gl: {
        functions: `
                vec3 blendLighten(vec3 base, vec3 blend, float opacity)
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendLighten(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn blendLighten(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendLighten(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
      }
    });
  }
};
LightenBlend2.extension = {
  name: "lighten",
  type: ExtensionType3.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/LinearBurnBlend.mjs
init_Extensions2();
var LinearBurnBlend2 = class extends BlendModeFilter2 {
  constructor() {
    super({
      gl: {
        functions: `
                float linearBurn(float base, float blend)
                {
                    return max(0.0, base + blend - 1.0);
                }

                vec3 blendLinearBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendLinearBurn(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn blendLinearBurn(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendLinearBurn(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
      }
    });
  }
};
LinearBurnBlend2.extension = {
  name: "linear-burn",
  type: ExtensionType3.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/LinearDodgeBlend.mjs
init_Extensions2();
var LinearDodgeBlend2 = class extends BlendModeFilter2 {
  constructor() {
    super({
      gl: {
        functions: `
                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                vec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendLinearDodge(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1, base + blend);
                }

                fn blendLinearDodge(base:vec3<f32>, blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendLinearDodge(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
      }
    });
  }
};
LinearDodgeBlend2.extension = {
  name: "linear-dodge",
  type: ExtensionType3.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/LinearLightBlend.mjs
init_Extensions2();
var LinearLightBlend2 = class extends BlendModeFilter2 {
  constructor() {
    super({
      gl: {
        functions: `
                float linearBurn(float base, float blend) {
                    return max(0.0, base + blend - 1.0);
                }

                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                float linearLight(float base, float blend) {
                    return (blend <= 0.5) ? linearBurn(base,2.0*blend) : linearBurn(base,2.0*(blend-0.5));
                }

                vec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                fragColor = vec4(blendLinearLight(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base + blend);
                }

                fn linearLight(base: f32, blend: f32) -> f32
                {
                    return select(linearBurn(base,2.0*(blend-0.5)), linearBurn(base,2.0*blend), blend <= 0.5);
                }

                fn blendLinearLightOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendLinearLightOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
      }
    });
  }
};
LinearLightBlend2.extension = {
  name: "linear-light",
  type: ExtensionType3.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/LuminosityBlend.mjs
init_Extensions2();
var LuminosityBlend2 = class extends BlendModeFilter2 {
  constructor() {
    super({
      gl: {
        functions: `
                ${hslgl2}

                vec3 blendLuminosity(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendLuminosity = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendLuminosity(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                ${hslgpu2}

                fn blendLuminosity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendLuminosity: vec3<f32> = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendLuminosity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
      }
    });
  }
};
LuminosityBlend2.extension = {
  name: "luminosity",
  type: ExtensionType3.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/NegationBlend.mjs
init_Extensions2();
var NegationBlend2 = class extends BlendModeFilter2 {
  constructor() {
    super({
      gl: {
        functions: `
                vec3 negation(vec3 base, vec3 blend)
                {
                    return 1.0-abs(1.0-base-blend);
                }

                vec3 blendNegation(vec3 base, vec3 blend, float opacity)
                {
                    return (negation(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendNegation(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn blendNegation(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return 1.0-abs(1.0-base-blend);
                }

                fn blendNegationOpacity(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (blendNegation(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendNegationOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
      }
    });
  }
};
NegationBlend2.extension = {
  name: "negation",
  type: ExtensionType3.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/OverlayBlend.mjs
init_Extensions2();
var OverlayBlend2 = class extends BlendModeFilter2 {
  constructor() {
    super({
      gl: {
        functions: `
                float overlay(float base, float blend)
                {
                    return (blend < 0.5) ? (2.0*base*blend) : (1.0-2.0*(1.0-base)*(1.0-blend));
                }

                vec3 blendOverlay(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendOverlay(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn overlay(base: f32, blend: f32) -> f32
                {
                    return select((1.0-2.0*(1.0-base)*(1.0-blend)), (2.0*base*blend), base < 0.5);
                }

                fn blendOverlay(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendOverlay(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
      }
    });
  }
};
OverlayBlend2.extension = {
  name: "overlay",
  type: ExtensionType3.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/PinLightBlend.mjs
init_Extensions2();
var PinLightBlend2 = class extends BlendModeFilter2 {
  constructor() {
    super({
      gl: {
        functions: `
                float pinLight(float base, float blend)
                {
                    return (blend <= 0.5) ? min(base, 2.0 * blend) : max(base, 2.0 * (blend - 0.5));
                }

                vec3 blendPinLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                fragColor = vec4(blendPinLight(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn pinLight(base: f32, blend: f32) -> f32
                {
                    return select(max(base,2.0*(blend-0.5)), min(base,2.0*blend), blend <= 0.5);
                }

                fn blendPinLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendPinLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
      }
    });
  }
};
PinLightBlend2.extension = {
  name: "pin-light",
  type: ExtensionType3.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/SaturationBlend.mjs
init_Extensions2();
var SaturationBlend2 = class extends BlendModeFilter2 {
  constructor() {
    super({
      gl: {
        functions: `
                ${hslgl2}

                vec3 blendSaturation(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                fragColor = vec4(blendSaturation(back.rgb, front.rgb, front.a), uBlend);
            `
      },
      gpu: {
        functions: `
                ${hslgpu2}

                fn blendSaturation(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendSaturation(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
      }
    });
  }
};
SaturationBlend2.extension = {
  name: "saturation",
  type: ExtensionType3.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/SoftLightBlend.mjs
init_Extensions2();
var SoftLightBlend2 = class extends BlendModeFilter2 {
  constructor() {
    super({
      gl: {
        functions: `
                float softLight(float base, float blend)
                {
                    return (blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));
                }

                vec3 blendSoftLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendSoftLight(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn softLight(base: f32, blend: f32) -> f32
                {
                    return select(2.0 * base * blend + base * base * (1.0 - 2.0 * blend), sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend), blend < 0.5);
                }

                fn blendSoftLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendSoftLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
      }
    });
  }
};
SoftLightBlend2.extension = {
  name: "soft-light",
  type: ExtensionType3.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/SubtractBlend.mjs
init_Extensions2();
var SubtractBlend2 = class extends BlendModeFilter2 {
  constructor() {
    super({
      gl: {
        functions: `
                float subtract(float base, float blend)
                {
                    return max(0.0, base - blend);
                }

                vec3 blendSubtract(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendSubtract(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn subtract(base: f32, blend: f32) -> f32
                {
                    return max(0, base - blend);
                }

                fn blendSubtract(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendSubtract(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
      }
    });
  }
};
SubtractBlend2.extension = {
  name: "subtract",
  type: ExtensionType3.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/VividLightBlend.mjs
init_Extensions2();
var VividLightBlend2 = class extends BlendModeFilter2 {
  constructor() {
    super({
      gl: {
        functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                float colorDodge(float base, float blend)
                {
                    return min(1.0, base / (1.0-blend));
                }

                float vividLight(float base, float blend)
                {
                    return (blend < 0.5) ? colorBurn(base,(2.0*blend)) : colorDodge(base,(2.0*(blend-0.5)));
                }

                vec3 blendVividLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                fragColor = vec4(blendVividLight(back.rgb, front.rgb, front.a), uBlend);
            `
      },
      gpu: {
        functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base / (1.0-blend));
                }

                fn vividLight(base: f32, blend: f32) -> f32
                {
                    return select(colorDodge(base,(2.0*(blend-0.5))), colorBurn(base,(2.0*blend)), blend<0.5);
                }

                fn blendVividLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendVividLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
      }
    });
  }
};
VividLightBlend2.extension = {
  name: "vivid-light",
  type: ExtensionType3.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/init.mjs
extensions3.add(
  ColorBlend2,
  ColorBurnBlend2,
  ColorDodgeBlend2,
  DarkenBlend2,
  DifferenceBlend2,
  DivideBlend2,
  ExclusionBlend2,
  HardLightBlend2,
  HardMixBlend2,
  LightenBlend2,
  LinearBurnBlend2,
  LinearLightBlend2,
  LinearDodgeBlend2,
  LuminosityBlend2,
  NegationBlend2,
  OverlayBlend2,
  PinLightBlend2,
  SaturationBlend2,
  SoftLightBlend2,
  SubtractBlend2,
  VividLightBlend2
);

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/index.mjs
init_Point2();
init_Rectangle2();
init_init12();
init_Container2();
init_init11();
init_Ticker2();
init_eventemitter3();
var import_earcut4 = __toESM(require_earcut(), 1);

// ../pixi-viewport/dist/pixi_viewport.js
var u2 = class {
  /** @param {Viewport} parent */
  constructor(t2) {
    this.parent = t2, this.paused = false;
  }
  /** Called when plugin is removed */
  destroy() {
  }
  /** Handler for pointerdown PIXI event */
  down(t2) {
    return false;
  }
  /** Handler for pointermove PIXI event */
  move(t2) {
    return false;
  }
  /** Handler for pointerup PIXI event */
  up(t2) {
    return false;
  }
  /** Handler for wheel event on div */
  wheel(t2) {
    return false;
  }
  /**
   * Called on each tick
   * @param {number} elapsed time in millisecond since last update
   */
  update(t2) {
  }
  /** Called when the viewport is resized */
  resize() {
  }
  /** Called when the viewport is manually moved */
  reset() {
  }
  /** Pause the plugin */
  pause() {
    this.paused = true;
  }
  /** Un-pause the plugin */
  resume() {
    this.paused = false;
  }
};
var S2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function M2(l3) {
  return l3 && l3.__esModule && Object.prototype.hasOwnProperty.call(l3, "default") ? l3.default : l3;
}
var W = { exports: {} };
(function(l3, t2) {
  (function() {
    var e3, n2;
    n2 = function(i3) {
      return l3.exports = i3;
    }, e3 = {
      linear: function(i3, s2, h2, o2) {
        return h2 * i3 / o2 + s2;
      },
      easeInQuad: function(i3, s2, h2, o2) {
        return h2 * (i3 /= o2) * i3 + s2;
      },
      easeOutQuad: function(i3, s2, h2, o2) {
        return -h2 * (i3 /= o2) * (i3 - 2) + s2;
      },
      easeInOutQuad: function(i3, s2, h2, o2) {
        return (i3 /= o2 / 2) < 1 ? h2 / 2 * i3 * i3 + s2 : -h2 / 2 * (--i3 * (i3 - 2) - 1) + s2;
      },
      easeInCubic: function(i3, s2, h2, o2) {
        return h2 * (i3 /= o2) * i3 * i3 + s2;
      },
      easeOutCubic: function(i3, s2, h2, o2) {
        return h2 * ((i3 = i3 / o2 - 1) * i3 * i3 + 1) + s2;
      },
      easeInOutCubic: function(i3, s2, h2, o2) {
        return (i3 /= o2 / 2) < 1 ? h2 / 2 * i3 * i3 * i3 + s2 : h2 / 2 * ((i3 -= 2) * i3 * i3 + 2) + s2;
      },
      easeInQuart: function(i3, s2, h2, o2) {
        return h2 * (i3 /= o2) * i3 * i3 * i3 + s2;
      },
      easeOutQuart: function(i3, s2, h2, o2) {
        return -h2 * ((i3 = i3 / o2 - 1) * i3 * i3 * i3 - 1) + s2;
      },
      easeInOutQuart: function(i3, s2, h2, o2) {
        return (i3 /= o2 / 2) < 1 ? h2 / 2 * i3 * i3 * i3 * i3 + s2 : -h2 / 2 * ((i3 -= 2) * i3 * i3 * i3 - 2) + s2;
      },
      easeInQuint: function(i3, s2, h2, o2) {
        return h2 * (i3 /= o2) * i3 * i3 * i3 * i3 + s2;
      },
      easeOutQuint: function(i3, s2, h2, o2) {
        return h2 * ((i3 = i3 / o2 - 1) * i3 * i3 * i3 * i3 + 1) + s2;
      },
      easeInOutQuint: function(i3, s2, h2, o2) {
        return (i3 /= o2 / 2) < 1 ? h2 / 2 * i3 * i3 * i3 * i3 * i3 + s2 : h2 / 2 * ((i3 -= 2) * i3 * i3 * i3 * i3 + 2) + s2;
      },
      easeInSine: function(i3, s2, h2, o2) {
        return -h2 * Math.cos(i3 / o2 * (Math.PI / 2)) + h2 + s2;
      },
      easeOutSine: function(i3, s2, h2, o2) {
        return h2 * Math.sin(i3 / o2 * (Math.PI / 2)) + s2;
      },
      easeInOutSine: function(i3, s2, h2, o2) {
        return -h2 / 2 * (Math.cos(Math.PI * i3 / o2) - 1) + s2;
      },
      easeInExpo: function(i3, s2, h2, o2) {
        return i3 === 0 ? s2 : h2 * Math.pow(2, 10 * (i3 / o2 - 1)) + s2;
      },
      easeOutExpo: function(i3, s2, h2, o2) {
        return i3 === o2 ? s2 + h2 : h2 * (-Math.pow(2, -10 * i3 / o2) + 1) + s2;
      },
      easeInOutExpo: function(i3, s2, h2, o2) {
        return (i3 /= o2 / 2) < 1 ? h2 / 2 * Math.pow(2, 10 * (i3 - 1)) + s2 : h2 / 2 * (-Math.pow(2, -10 * --i3) + 2) + s2;
      },
      easeInCirc: function(i3, s2, h2, o2) {
        return -h2 * (Math.sqrt(1 - (i3 /= o2) * i3) - 1) + s2;
      },
      easeOutCirc: function(i3, s2, h2, o2) {
        return h2 * Math.sqrt(1 - (i3 = i3 / o2 - 1) * i3) + s2;
      },
      easeInOutCirc: function(i3, s2, h2, o2) {
        return (i3 /= o2 / 2) < 1 ? -h2 / 2 * (Math.sqrt(1 - i3 * i3) - 1) + s2 : h2 / 2 * (Math.sqrt(1 - (i3 -= 2) * i3) + 1) + s2;
      },
      easeInElastic: function(i3, s2, h2, o2) {
        var r2, a2, p3;
        return p3 = 1.70158, a2 = 0, r2 = h2, i3 === 0 || (i3 /= o2), a2 || (a2 = o2 * 0.3), r2 < Math.abs(h2) ? (r2 = h2, p3 = a2 / 4) : p3 = a2 / (2 * Math.PI) * Math.asin(h2 / r2), -(r2 * Math.pow(2, 10 * (i3 -= 1)) * Math.sin((i3 * o2 - p3) * (2 * Math.PI) / a2)) + s2;
      },
      easeOutElastic: function(i3, s2, h2, o2) {
        var r2, a2, p3;
        return p3 = 1.70158, a2 = 0, r2 = h2, i3 === 0 || (i3 /= o2), a2 || (a2 = o2 * 0.3), r2 < Math.abs(h2) ? (r2 = h2, p3 = a2 / 4) : p3 = a2 / (2 * Math.PI) * Math.asin(h2 / r2), r2 * Math.pow(2, -10 * i3) * Math.sin((i3 * o2 - p3) * (2 * Math.PI) / a2) + h2 + s2;
      },
      easeInOutElastic: function(i3, s2, h2, o2) {
        var r2, a2, p3;
        return p3 = 1.70158, a2 = 0, r2 = h2, i3 === 0 || (i3 /= o2 / 2), a2 || (a2 = o2 * (0.3 * 1.5)), r2 < Math.abs(h2) ? (r2 = h2, p3 = a2 / 4) : p3 = a2 / (2 * Math.PI) * Math.asin(h2 / r2), i3 < 1 ? -0.5 * (r2 * Math.pow(2, 10 * (i3 -= 1)) * Math.sin((i3 * o2 - p3) * (2 * Math.PI) / a2)) + s2 : r2 * Math.pow(2, -10 * (i3 -= 1)) * Math.sin((i3 * o2 - p3) * (2 * Math.PI) / a2) * 0.5 + h2 + s2;
      },
      easeInBack: function(i3, s2, h2, o2, r2) {
        return r2 === void 0 && (r2 = 1.70158), h2 * (i3 /= o2) * i3 * ((r2 + 1) * i3 - r2) + s2;
      },
      easeOutBack: function(i3, s2, h2, o2, r2) {
        return r2 === void 0 && (r2 = 1.70158), h2 * ((i3 = i3 / o2 - 1) * i3 * ((r2 + 1) * i3 + r2) + 1) + s2;
      },
      easeInOutBack: function(i3, s2, h2, o2, r2) {
        return r2 === void 0 && (r2 = 1.70158), (i3 /= o2 / 2) < 1 ? h2 / 2 * (i3 * i3 * (((r2 *= 1.525) + 1) * i3 - r2)) + s2 : h2 / 2 * ((i3 -= 2) * i3 * (((r2 *= 1.525) + 1) * i3 + r2) + 2) + s2;
      },
      easeInBounce: function(i3, s2, h2, o2) {
        var r2;
        return r2 = e3.easeOutBounce(o2 - i3, 0, h2, o2), h2 - r2 + s2;
      },
      easeOutBounce: function(i3, s2, h2, o2) {
        return (i3 /= o2) < 1 / 2.75 ? h2 * (7.5625 * i3 * i3) + s2 : i3 < 2 / 2.75 ? h2 * (7.5625 * (i3 -= 1.5 / 2.75) * i3 + 0.75) + s2 : i3 < 2.5 / 2.75 ? h2 * (7.5625 * (i3 -= 2.25 / 2.75) * i3 + 0.9375) + s2 : h2 * (7.5625 * (i3 -= 2.625 / 2.75) * i3 + 0.984375) + s2;
      },
      easeInOutBounce: function(i3, s2, h2, o2) {
        var r2;
        return i3 < o2 / 2 ? (r2 = e3.easeInBounce(i3 * 2, 0, h2, o2), r2 * 0.5 + s2) : (r2 = e3.easeOutBounce(i3 * 2 - o2, 0, h2, o2), r2 * 0.5 + h2 * 0.5 + s2);
      }
    }, n2(e3);
  }).call(S2);
})(W);
var O = W.exports;
var v2 = /* @__PURE__ */ M2(O);
function x2(l3, t2) {
  if (l3) {
    if (typeof l3 == "function")
      return l3;
    if (typeof l3 == "string")
      return v2[l3];
  } else
    return v2[t2];
}
var P = {
  removeOnInterrupt: false,
  ease: "linear",
  time: 1e3
};
var C = class extends u2 {
  /**
   * This is called by {@link Viewport.animate}.
   *
   * @param parent
   * @param options
   */
  constructor(t2, e3 = {}) {
    super(t2), this.startWidth = null, this.startHeight = null, this.deltaWidth = null, this.deltaHeight = null, this.width = null, this.height = null, this.time = 0, this.options = Object.assign({}, P, e3), this.options.ease = x2(this.options.ease), this.setupPosition(), this.setupZoom(), this.time = 0;
  }
  /**
   * Setup `startX`, `startY`, `deltaX`, `deltaY`, `keepCenter`.
   *
   * This is called during construction.
   */
  setupPosition() {
    typeof this.options.position < "u" ? (this.startX = this.parent.center.x, this.startY = this.parent.center.y, this.deltaX = this.options.position.x - this.parent.center.x, this.deltaY = this.options.position.y - this.parent.center.y, this.keepCenter = false) : this.keepCenter = true;
  }
  /**
   * Setup `startWidth, `startHeight`, `deltaWidth, `deltaHeight, `width`, `height`.
   *
   * This is called during construction.
   */
  setupZoom() {
    this.width = null, this.height = null, typeof this.options.scale < "u" ? this.width = this.parent.screenWidth / this.options.scale : typeof this.options.scaleX < "u" || typeof this.options.scaleY < "u" ? (typeof this.options.scaleX < "u" && (this.width = this.parent.screenWidth / this.options.scaleX), typeof this.options.scaleY < "u" && (this.height = this.parent.screenHeight / this.options.scaleY)) : (typeof this.options.width < "u" && (this.width = this.options.width), typeof this.options.height < "u" && (this.height = this.options.height)), this.width !== null && (this.startWidth = this.parent.screenWidthInWorldPixels, this.deltaWidth = this.width - this.startWidth), this.height !== null && (this.startHeight = this.parent.screenHeightInWorldPixels, this.deltaHeight = this.height - this.startHeight);
  }
  down() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("animate"), false;
  }
  complete() {
    this.parent.plugins.remove("animate"), this.width !== null && this.parent.fitWidth(this.width, this.keepCenter, this.height === null), this.height !== null && this.parent.fitHeight(this.height, this.keepCenter, this.width === null), !this.keepCenter && this.options.position && this.parent.moveCenter(this.options.position), this.parent.emit("animate-end", this.parent), this.options.callbackOnComplete && this.options.callbackOnComplete(this.parent);
  }
  update(t2) {
    if (this.paused)
      return;
    this.time += t2;
    const e3 = new Point3(this.parent.scale.x, this.parent.scale.y);
    if (this.time >= this.options.time) {
      const n2 = this.parent.width, i3 = this.parent.height;
      this.complete(), (n2 !== this.parent.width || i3 !== this.parent.height) && this.parent.emit("zoomed", { viewport: this.parent, original: e3, type: "animate" });
    } else {
      const n2 = this.options.ease(this.time, 0, 1, this.options.time);
      if (this.width !== null) {
        const i3 = this.startWidth, s2 = this.deltaWidth;
        this.parent.fitWidth(
          i3 + s2 * n2,
          this.keepCenter,
          this.height === null
        );
      }
      if (this.height !== null) {
        const i3 = this.startHeight, s2 = this.deltaHeight;
        this.parent.fitHeight(
          i3 + s2 * n2,
          this.keepCenter,
          this.width === null
        );
      }
      if (this.width === null ? this.parent.scale.x = this.parent.scale.y : this.height === null && (this.parent.scale.y = this.parent.scale.x), !this.keepCenter) {
        const i3 = this.startX, s2 = this.startY, h2 = this.deltaX, o2 = this.deltaY, r2 = new Point3(this.parent.x, this.parent.y);
        this.parent.moveCenter(i3 + h2 * n2, s2 + o2 * n2), this.parent.emit("moved", { viewport: this.parent, original: r2, type: "animate" });
      }
      (this.width || this.height) && this.parent.emit("zoomed", { viewport: this.parent, original: e3, type: "animate" });
    }
  }
};
var I = {
  sides: "all",
  friction: 0.5,
  time: 150,
  ease: "easeInOutSine",
  underflow: "center",
  bounceBox: null
};
var k2 = class extends u2 {
  /**
   * This is called by {@link Viewport.bounce}.
   */
  constructor(t2, e3 = {}) {
    super(t2), this.options = Object.assign({}, I, e3), this.ease = x2(this.options.ease, "easeInOutSine"), this.options.sides ? this.options.sides === "all" ? this.top = this.bottom = this.left = this.right = true : this.options.sides === "horizontal" ? (this.right = this.left = true, this.top = this.bottom = false) : this.options.sides === "vertical" ? (this.left = this.right = false, this.top = this.bottom = true) : (this.top = this.options.sides.indexOf("top") !== -1, this.bottom = this.options.sides.indexOf("bottom") !== -1, this.left = this.options.sides.indexOf("left") !== -1, this.right = this.options.sides.indexOf("right") !== -1) : this.left = this.top = this.right = this.bottom = false;
    const n2 = this.options.underflow.toLowerCase();
    n2 === "center" ? (this.underflowX = 0, this.underflowY = 0) : (this.underflowX = n2.indexOf("left") !== -1 ? -1 : n2.indexOf("right") !== -1 ? 1 : 0, this.underflowY = n2.indexOf("top") !== -1 ? -1 : n2.indexOf("bottom") !== -1 ? 1 : 0), this.reset();
  }
  isActive() {
    return this.toX !== null || this.toY !== null;
  }
  down() {
    return this.toX = this.toY = null, false;
  }
  up() {
    return this.bounce(), false;
  }
  update(t2) {
    if (!this.paused) {
      if (this.bounce(), this.toX) {
        const e3 = this.toX;
        e3.time += t2, this.parent.emit("moved", { viewport: this.parent, type: "bounce-x" }), e3.time >= this.options.time ? (this.parent.x = e3.end, this.toX = null, this.parent.emit("bounce-x-end", this.parent)) : this.parent.x = this.ease(e3.time, e3.start, e3.delta, this.options.time);
      }
      if (this.toY) {
        const e3 = this.toY;
        e3.time += t2, this.parent.emit("moved", { viewport: this.parent, type: "bounce-y" }), e3.time >= this.options.time ? (this.parent.y = e3.end, this.toY = null, this.parent.emit("bounce-y-end", this.parent)) : this.parent.y = this.ease(e3.time, e3.start, e3.delta, this.options.time);
      }
    }
  }
  /** @internal */
  calcUnderflowX() {
    let t2;
    switch (this.underflowX) {
      case -1:
        t2 = 0;
        break;
      case 1:
        t2 = this.parent.screenWidth - this.parent.screenWorldWidth;
        break;
      default:
        t2 = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
    }
    return t2;
  }
  /** @internal */
  calcUnderflowY() {
    let t2;
    switch (this.underflowY) {
      case -1:
        t2 = 0;
        break;
      case 1:
        t2 = this.parent.screenHeight - this.parent.screenWorldHeight;
        break;
      default:
        t2 = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
    }
    return t2;
  }
  oob() {
    const t2 = this.options.bounceBox;
    if (t2) {
      const e3 = typeof t2.x > "u" ? 0 : t2.x, n2 = typeof t2.y > "u" ? 0 : t2.y, i3 = typeof t2.width > "u" ? this.parent.worldWidth : t2.width, s2 = typeof t2.height > "u" ? this.parent.worldHeight : t2.height;
      return {
        left: this.parent.left < e3,
        right: this.parent.right > i3,
        top: this.parent.top < n2,
        bottom: this.parent.bottom > s2,
        topLeft: new Point3(
          e3 * this.parent.scale.x,
          n2 * this.parent.scale.y
        ),
        bottomRight: new Point3(
          i3 * this.parent.scale.x - this.parent.screenWidth,
          s2 * this.parent.scale.y - this.parent.screenHeight
        )
      };
    }
    return {
      left: this.parent.left < 0,
      right: this.parent.right > this.parent.worldWidth,
      top: this.parent.top < 0,
      bottom: this.parent.bottom > this.parent.worldHeight,
      topLeft: new Point3(0, 0),
      bottomRight: new Point3(
        this.parent.worldWidth * this.parent.scale.x - this.parent.screenWidth,
        this.parent.worldHeight * this.parent.scale.y - this.parent.screenHeight
      )
    };
  }
  bounce() {
    var s2, h2;
    if (this.paused)
      return;
    let t2, e3 = this.parent.plugins.get("decelerate", true);
    e3 && (e3.x || e3.y) && (e3.x && e3.percentChangeX === ((s2 = e3.options) == null ? void 0 : s2.friction) || e3.y && e3.percentChangeY === ((h2 = e3.options) == null ? void 0 : h2.friction)) && (t2 = this.oob(), (t2.left && this.left || t2.right && this.right) && (e3.percentChangeX = this.options.friction), (t2.top && this.top || t2.bottom && this.bottom) && (e3.percentChangeY = this.options.friction));
    const n2 = this.parent.plugins.get("drag", true) || {}, i3 = this.parent.plugins.get("pinch", true) || {};
    if (e3 = e3 || {}, !(n2 != null && n2.active) && !(i3 != null && i3.active) && (!this.toX || !this.toY) && (!e3.x || !e3.y)) {
      t2 = t2 || this.oob();
      const o2 = t2.topLeft, r2 = t2.bottomRight;
      if (!this.toX && !e3.x) {
        let a2 = null;
        t2.left && this.left ? a2 = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -o2.x : t2.right && this.right && (a2 = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -r2.x), a2 !== null && this.parent.x !== a2 && (this.toX = { time: 0, start: this.parent.x, delta: a2 - this.parent.x, end: a2 }, this.parent.emit("bounce-x-start", this.parent));
      }
      if (!this.toY && !e3.y) {
        let a2 = null;
        t2.top && this.top ? a2 = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -o2.y : t2.bottom && this.bottom && (a2 = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -r2.y), a2 !== null && this.parent.y !== a2 && (this.toY = { time: 0, start: this.parent.y, delta: a2 - this.parent.y, end: a2 }, this.parent.emit("bounce-y-start", this.parent));
      }
    }
  }
  reset() {
    this.toX = this.toY = null, this.bounce();
  }
};
var Y = {
  left: false,
  right: false,
  top: false,
  bottom: false,
  direction: null,
  underflow: "center"
};
var X = class extends u2 {
  /**
   * This is called by {@link Viewport.clamp}.
   */
  constructor(t2, e3 = {}) {
    super(t2), this.options = Object.assign({}, Y, e3), this.options.direction && (this.options.left = this.options.direction === "x" || this.options.direction === "all" ? true : null, this.options.right = this.options.direction === "x" || this.options.direction === "all" ? true : null, this.options.top = this.options.direction === "y" || this.options.direction === "all" ? true : null, this.options.bottom = this.options.direction === "y" || this.options.direction === "all" ? true : null), this.parseUnderflow(), this.last = { x: null, y: null, scaleX: null, scaleY: null }, this.update();
  }
  parseUnderflow() {
    const t2 = this.options.underflow.toLowerCase();
    t2 === "none" ? this.noUnderflow = true : t2 === "center" ? (this.underflowX = this.underflowY = 0, this.noUnderflow = false) : (this.underflowX = t2.indexOf("left") !== -1 ? -1 : t2.indexOf("right") !== -1 ? 1 : 0, this.underflowY = t2.indexOf("top") !== -1 ? -1 : t2.indexOf("bottom") !== -1 ? 1 : 0, this.noUnderflow = false);
  }
  move() {
    return this.update(), false;
  }
  update() {
    if (this.paused || this.parent.x === this.last.x && this.parent.y === this.last.y && this.parent.scale.x === this.last.scaleX && this.parent.scale.y === this.last.scaleY)
      return;
    const t2 = new Point3(this.parent.x, this.parent.y), e3 = this.parent.plugins.decelerate || {};
    if (this.options.left !== null || this.options.right !== null) {
      let n2 = false;
      if (!this.noUnderflow && this.parent.screenWorldWidth < this.parent.screenWidth)
        switch (this.underflowX) {
          case -1:
            this.parent.x !== 0 && (this.parent.x = 0, n2 = true);
            break;
          case 1:
            this.parent.x !== this.parent.screenWidth - this.parent.screenWorldWidth && (this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth, n2 = true);
            break;
          default:
            this.parent.x !== (this.parent.screenWidth - this.parent.screenWorldWidth) / 2 && (this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2, n2 = true);
        }
      else
        this.options.left !== null && this.parent.left < (this.options.left === true ? 0 : this.options.left) && (this.parent.x = -(this.options.left === true ? 0 : this.options.left) * this.parent.scale.x, e3.x = 0, n2 = true), this.options.right !== null && this.parent.right > (this.options.right === true ? this.parent.worldWidth : this.options.right) && (this.parent.x = -(this.options.right === true ? this.parent.worldWidth : this.options.right) * this.parent.scale.x + this.parent.screenWidth, e3.x = 0, n2 = true);
      n2 && this.parent.emit("moved", { viewport: this.parent, original: t2, type: "clamp-x" });
    }
    if (this.options.top !== null || this.options.bottom !== null) {
      let n2 = false;
      if (!this.noUnderflow && this.parent.screenWorldHeight < this.parent.screenHeight)
        switch (this.underflowY) {
          case -1:
            this.parent.y !== 0 && (this.parent.y = 0, n2 = true);
            break;
          case 1:
            this.parent.y !== this.parent.screenHeight - this.parent.screenWorldHeight && (this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight, n2 = true);
            break;
          default:
            this.parent.y !== (this.parent.screenHeight - this.parent.screenWorldHeight) / 2 && (this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2, n2 = true);
        }
      else
        this.options.top !== null && this.parent.top < (this.options.top === true ? 0 : this.options.top) && (this.parent.y = -(this.options.top === true ? 0 : this.options.top) * this.parent.scale.y, e3.y = 0, n2 = true), this.options.bottom !== null && this.parent.bottom > (this.options.bottom === true ? this.parent.worldHeight : this.options.bottom) && (this.parent.y = -(this.options.bottom === true ? this.parent.worldHeight : this.options.bottom) * this.parent.scale.y + this.parent.screenHeight, e3.y = 0, n2 = true);
      n2 && this.parent.emit("moved", { viewport: this.parent, original: t2, type: "clamp-y" });
    }
    this.last.x = this.parent.x, this.last.y = this.parent.y, this.last.scaleX = this.parent.scale.x, this.last.scaleY = this.parent.scale.y;
  }
  reset() {
    this.update();
  }
};
var z = {
  minWidth: null,
  minHeight: null,
  maxWidth: null,
  maxHeight: null,
  minScale: null,
  maxScale: null
};
var A = class extends u2 {
  /**
   * This is called by {@link Viewport.clampZoom}.
   */
  constructor(t2, e3 = {}) {
    super(t2), this.options = Object.assign({}, z, e3), this.clamp();
  }
  resize() {
    this.clamp();
  }
  /** Clamp the viewport scale zoom) */
  clamp() {
    if (!this.paused) {
      if (this.options.minWidth || this.options.minHeight || this.options.maxWidth || this.options.maxHeight) {
        let t2 = this.parent.worldScreenWidth, e3 = this.parent.worldScreenHeight;
        if (this.options.minWidth !== null && t2 < this.options.minWidth) {
          const n2 = this.parent.scale.x;
          this.parent.fitWidth(this.options.minWidth, false, false, true), this.parent.scale.y *= this.parent.scale.x / n2, t2 = this.parent.worldScreenWidth, e3 = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.maxWidth !== null && t2 > this.options.maxWidth) {
          const n2 = this.parent.scale.x;
          this.parent.fitWidth(this.options.maxWidth, false, false, true), this.parent.scale.y *= this.parent.scale.x / n2, t2 = this.parent.worldScreenWidth, e3 = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.minHeight !== null && e3 < this.options.minHeight) {
          const n2 = this.parent.scale.y;
          this.parent.fitHeight(this.options.minHeight, false, false, true), this.parent.scale.x *= this.parent.scale.y / n2, t2 = this.parent.worldScreenWidth, e3 = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.maxHeight !== null && e3 > this.options.maxHeight) {
          const n2 = this.parent.scale.y;
          this.parent.fitHeight(this.options.maxHeight, false, false, true), this.parent.scale.x *= this.parent.scale.y / n2, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
      } else if (this.options.minScale || this.options.maxScale) {
        const t2 = { x: null, y: null }, e3 = { x: null, y: null };
        if (typeof this.options.minScale == "number")
          t2.x = this.options.minScale, t2.y = this.options.minScale;
        else if (this.options.minScale !== null) {
          const s2 = this.options.minScale;
          t2.x = typeof s2.x > "u" ? null : s2.x, t2.y = typeof s2.y > "u" ? null : s2.y;
        }
        if (typeof this.options.maxScale == "number")
          e3.x = this.options.maxScale, e3.y = this.options.maxScale;
        else if (this.options.maxScale !== null) {
          const s2 = this.options.maxScale;
          e3.x = typeof s2.x > "u" ? null : s2.x, e3.y = typeof s2.y > "u" ? null : s2.y;
        }
        let n2 = this.parent.scale.x, i3 = this.parent.scale.y;
        t2.x !== null && n2 < t2.x && (n2 = t2.x), e3.x !== null && n2 > e3.x && (n2 = e3.x), t2.y !== null && i3 < t2.y && (i3 = t2.y), e3.y !== null && i3 > e3.y && (i3 = e3.y), (n2 !== this.parent.scale.x || i3 !== this.parent.scale.y) && (this.parent.scale.set(n2, i3), this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" }));
      }
    }
  }
  reset() {
    this.clamp();
  }
};
var _ = {
  friction: 0.98,
  bounce: 0.8,
  minSpeed: 0.01
};
var d2 = 16;
var T = class extends u2 {
  /**
   * This is called by {@link Viewport.decelerate}.
   */
  constructor(t2, e3 = {}) {
    super(t2), this.options = Object.assign({}, _, e3), this.saved = [], this.timeSinceRelease = 0, this.reset(), this.parent.on("moved", (n2) => this.handleMoved(n2));
  }
  down() {
    return this.saved = [], this.x = this.y = null, false;
  }
  isActive() {
    return !!(this.x || this.y);
  }
  move() {
    if (this.paused)
      return false;
    const t2 = this.parent.input.count();
    return (t2 === 1 || t2 > 1 && !this.parent.plugins.get("pinch", true)) && (this.saved.push({ x: this.parent.x, y: this.parent.y, time: performance.now() }), this.saved.length > 60 && this.saved.splice(0, 30)), false;
  }
  /** Listener to viewport's "moved" event. */
  handleMoved(t2) {
    if (this.saved.length) {
      const e3 = this.saved[this.saved.length - 1];
      t2.type === "clamp-x" && t2.original ? e3.x === t2.original.x && (e3.x = this.parent.x) : t2.type === "clamp-y" && t2.original && e3.y === t2.original.y && (e3.y = this.parent.y);
    }
  }
  up() {
    if (this.parent.input.count() === 0 && this.saved.length) {
      const t2 = performance.now();
      for (const e3 of this.saved)
        if (e3.time >= t2 - 100) {
          const n2 = t2 - e3.time;
          this.x = (this.parent.x - e3.x) / n2, this.y = (this.parent.y - e3.y) / n2, this.percentChangeX = this.percentChangeY = this.options.friction, this.timeSinceRelease = 0;
          break;
        }
    }
    return false;
  }
  /**
   * Manually activate deceleration, starting from the (x, y) velocity components passed in the options.
   *
   * @param {object} options
   * @param {number} [options.x] - Specify x-component of initial velocity.
   * @param {number} [options.y] - Specify y-component of initial velocity.
   */
  activate(t2) {
    t2 = t2 || {}, typeof t2.x < "u" && (this.x = t2.x, this.percentChangeX = this.options.friction), typeof t2.y < "u" && (this.y = t2.y, this.percentChangeY = this.options.friction);
  }
  update(t2) {
    if (this.paused)
      return;
    const e3 = this.x || this.y, n2 = this.timeSinceRelease, i3 = this.timeSinceRelease + t2;
    if (this.x) {
      const s2 = this.percentChangeX, h2 = Math.log(s2);
      this.parent.x += this.x * d2 / h2 * (Math.pow(s2, i3 / d2) - Math.pow(s2, n2 / d2)), this.x *= Math.pow(this.percentChangeX, t2 / d2);
    }
    if (this.y) {
      const s2 = this.percentChangeY, h2 = Math.log(s2);
      this.parent.y += this.y * d2 / h2 * (Math.pow(s2, i3 / d2) - Math.pow(s2, n2 / d2)), this.y *= Math.pow(this.percentChangeY, t2 / d2);
    }
    this.timeSinceRelease += t2, this.x && this.y ? Math.abs(this.x) < this.options.minSpeed && Math.abs(this.y) < this.options.minSpeed && (this.x = 0, this.y = 0) : (Math.abs(this.x || 0) < this.options.minSpeed && (this.x = 0), Math.abs(this.y || 0) < this.options.minSpeed && (this.y = 0)), e3 && this.parent.emit("moved", { viewport: this.parent, type: "decelerate" });
  }
  reset() {
    this.x = this.y = null;
  }
};
var E = {
  direction: "all",
  pressDrag: true,
  wheel: true,
  wheelScroll: 1,
  reverse: false,
  clampWheel: false,
  underflow: "center",
  factor: 1,
  mouseButtons: "all",
  keyToPress: null,
  ignoreKeyToPressOnTouch: false,
  lineHeight: 20,
  wheelSwapAxes: false
};
var D = class extends u2 {
  /**
   * This is called by {@link Viewport.drag}.
   */
  constructor(t2, e3 = {}) {
    super(t2), this.windowEventHandlers = [], this.options = Object.assign({}, E, e3), this.moved = false, this.reverse = this.options.reverse ? 1 : -1, this.xDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "x", this.yDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "y", this.keyIsPressed = false, this.parseUnderflow(), this.mouseButtons(this.options.mouseButtons), this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress);
  }
  /**
   * Handles keypress events and set the keyIsPressed boolean accordingly
   *
   * @param {array} codes - key codes that can be used to trigger drag event
   */
  handleKeyPresses(t2) {
    const e3 = (i3) => {
      t2.includes(i3.code) && (this.keyIsPressed = true);
    }, n2 = (i3) => {
      t2.includes(i3.code) && (this.keyIsPressed = false);
    };
    this.addWindowEventHandler("keyup", n2), this.addWindowEventHandler("keydown", e3);
  }
  addWindowEventHandler(t2, e3) {
    typeof window > "u" || (window.addEventListener(t2, e3), this.windowEventHandlers.push({ event: t2, handler: e3 }));
  }
  destroy() {
    typeof window > "u" || this.windowEventHandlers.forEach(({ event: t2, handler: e3 }) => {
      window.removeEventListener(t2, e3);
    });
  }
  /**
   * initialize mousebuttons array
   * @param {string} buttons
   */
  mouseButtons(t2) {
    !t2 || t2 === "all" ? this.mouse = [true, true, true] : this.mouse = [
      t2.indexOf("left") !== -1,
      t2.indexOf("middle") !== -1,
      t2.indexOf("right") !== -1
    ];
  }
  parseUnderflow() {
    const t2 = this.options.underflow.toLowerCase();
    t2 === "center" ? (this.underflowX = 0, this.underflowY = 0) : (t2.includes("left") ? this.underflowX = -1 : t2.includes("right") ? this.underflowX = 1 : this.underflowX = 0, t2.includes("top") ? this.underflowY = -1 : t2.includes("bottom") ? this.underflowY = 1 : this.underflowY = 0);
  }
  /**
   * @param {PIXI.FederatedPointerEvent} event
   * @returns {boolean}
   */
  checkButtons(t2) {
    const e3 = t2.pointerType === "mouse", n2 = this.parent.input.count();
    return !!((n2 === 1 || n2 > 1 && !this.parent.plugins.get("pinch", true)) && (!e3 || this.mouse[t2.button]));
  }
  /**
   * @param {PIXI.FederatedPointerEvent} event
   * @returns {boolean}
   */
  checkKeyPress(t2) {
    return !this.options.keyToPress || this.keyIsPressed || this.options.ignoreKeyToPressOnTouch && t2.data.pointerType === "touch";
  }
  down(t2) {
    return this.paused || !this.options.pressDrag ? false : this.checkButtons(t2) && this.checkKeyPress(t2) ? (this.last = { x: t2.global.x, y: t2.global.y }, this.current = t2.pointerId, true) : (this.last = null, false);
  }
  get active() {
    return this.moved;
  }
  move(t2) {
    if (this.paused || !this.options.pressDrag)
      return false;
    if (this.last && this.current === t2.data.pointerId) {
      const e3 = t2.global.x, n2 = t2.global.y, i3 = this.parent.input.count();
      if (i3 === 1 || i3 > 1 && !this.parent.plugins.get("pinch", true)) {
        const s2 = e3 - this.last.x, h2 = n2 - this.last.y;
        if (this.moved || this.xDirection && this.parent.input.checkThreshold(s2) || this.yDirection && this.parent.input.checkThreshold(h2)) {
          const o2 = { x: e3, y: n2 };
          return this.xDirection && (this.parent.x += (o2.x - this.last.x) * this.options.factor), this.yDirection && (this.parent.y += (o2.y - this.last.y) * this.options.factor), this.last = o2, this.moved || this.parent.emit("drag-start", {
            event: t2,
            screen: new Point3(this.last.x, this.last.y),
            world: this.parent.toWorld(new Point3(this.last.x, this.last.y)),
            viewport: this.parent
          }), this.moved = true, this.parent.emit("moved", { viewport: this.parent, type: "drag" }), true;
        }
      } else
        this.moved = false;
    }
    return false;
  }
  up(t2) {
    if (this.paused)
      return false;
    const e3 = this.parent.input.touches;
    if (e3.length === 1) {
      const n2 = e3[0];
      return n2.last && (this.last = { x: n2.last.x, y: n2.last.y }, this.current = n2.id), this.moved = false, true;
    } else if (this.last && this.moved) {
      const n2 = new Point3(this.last.x, this.last.y);
      return this.parent.emit("drag-end", {
        event: t2,
        screen: n2,
        world: this.parent.toWorld(n2),
        viewport: this.parent
      }), this.last = null, this.moved = false, true;
    }
    return false;
  }
  wheel(t2) {
    if (this.paused)
      return false;
    if (this.options.wheel) {
      const e3 = this.parent.plugins.get("wheel", true);
      if (!e3 || !e3.options.wheelZoom && !t2.ctrlKey) {
        const n2 = t2.deltaMode ? this.options.lineHeight : 1, i3 = [t2.deltaX, t2.deltaY], [s2, h2] = this.options.wheelSwapAxes ? i3.reverse() : i3;
        return this.xDirection && (this.parent.x += s2 * n2 * this.options.wheelScroll * this.reverse), this.yDirection && (this.parent.y += h2 * n2 * this.options.wheelScroll * this.reverse), this.options.clampWheel && this.clamp(), this.parent.emit("wheel-scroll", this.parent), this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.options.passiveWheel || t2.preventDefault(), this.parent.options.stopPropagation && t2.stopPropagation(), true;
      }
    }
    return false;
  }
  resume() {
    this.last = null, this.paused = false;
  }
  clamp() {
    const t2 = this.parent.plugins.get("decelerate", true) || {};
    if (this.options.clampWheel !== "y")
      if (this.parent.screenWorldWidth < this.parent.screenWidth)
        switch (this.underflowX) {
          case -1:
            this.parent.x = 0;
            break;
          case 1:
            this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth;
            break;
          default:
            this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
        }
      else
        this.parent.left < 0 ? (this.parent.x = 0, t2.x = 0) : this.parent.right > this.parent.worldWidth && (this.parent.x = -this.parent.worldWidth * this.parent.scale.x + this.parent.screenWidth, t2.x = 0);
    if (this.options.clampWheel !== "x")
      if (this.parent.screenWorldHeight < this.parent.screenHeight)
        switch (this.underflowY) {
          case -1:
            this.parent.y = 0;
            break;
          case 1:
            this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight;
            break;
          default:
            this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
        }
      else
        this.parent.top < 0 && (this.parent.y = 0, t2.y = 0), this.parent.bottom > this.parent.worldHeight && (this.parent.y = -this.parent.worldHeight * this.parent.scale.y + this.parent.screenHeight, t2.y = 0);
  }
};
var L = {
  speed: 0,
  acceleration: null,
  radius: null
};
var U = class extends u2 {
  /**
   * This is called by {@link Viewport.follow}.
   *
   * @param parent
   * @param target - target to follow
   * @param options
   */
  constructor(t2, e3, n2 = {}) {
    super(t2), this.target = e3, this.options = Object.assign({}, L, n2), this.velocity = { x: 0, y: 0 };
  }
  update(t2) {
    if (this.paused)
      return;
    const e3 = this.parent.center;
    let n2 = this.target.x, i3 = this.target.y;
    if (this.options.radius)
      if (Math.sqrt(Math.pow(this.target.y - e3.y, 2) + Math.pow(this.target.x - e3.x, 2)) > this.options.radius) {
        const r2 = Math.atan2(this.target.y - e3.y, this.target.x - e3.x);
        n2 = this.target.x - Math.cos(r2) * this.options.radius, i3 = this.target.y - Math.sin(r2) * this.options.radius;
      } else
        return;
    const s2 = n2 - e3.x, h2 = i3 - e3.y;
    if (s2 || h2)
      if (this.options.speed)
        if (this.options.acceleration) {
          const o2 = Math.atan2(i3 - e3.y, n2 - e3.x), r2 = Math.sqrt(Math.pow(s2, 2) + Math.pow(h2, 2));
          if (r2) {
            const a2 = (Math.pow(this.velocity.x, 2) + Math.pow(this.velocity.y, 2)) / (2 * this.options.acceleration);
            r2 > a2 ? this.velocity = {
              x: Math.min(this.velocity.x + (this.options.acceleration * t2, this.options.speed)),
              y: Math.min(this.velocity.y + (this.options.acceleration * t2, this.options.speed))
            } : this.velocity = {
              x: Math.max(this.velocity.x - this.options.acceleration * this.options.speed, 0),
              y: Math.max(this.velocity.y - this.options.acceleration * this.options.speed, 0)
            };
            const p3 = Math.cos(o2) * this.velocity.x, f3 = Math.sin(o2) * this.velocity.y, g2 = Math.abs(p3) > Math.abs(s2) ? n2 : e3.x + p3, w2 = Math.abs(f3) > Math.abs(h2) ? i3 : e3.y + f3;
            this.parent.moveCenter(g2, w2), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
          }
        } else {
          const o2 = Math.atan2(i3 - e3.y, n2 - e3.x), r2 = Math.cos(o2) * this.options.speed, a2 = Math.sin(o2) * this.options.speed, p3 = Math.abs(r2) > Math.abs(s2) ? n2 : e3.x + r2, f3 = Math.abs(a2) > Math.abs(h2) ? i3 : e3.y + a2;
          this.parent.moveCenter(p3, f3), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
        }
      else
        this.parent.moveCenter(n2, i3), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
  }
};
var F = {
  radius: null,
  distance: null,
  top: null,
  bottom: null,
  left: null,
  right: null,
  speed: 8,
  reverse: false,
  noDecelerate: false,
  linear: false,
  allowButtons: false
};
var B = class extends u2 {
  /**
   * This is called by {@link Viewport.mouseEdges}.
   */
  constructor(t2, e3 = {}) {
    super(t2), this.options = Object.assign({}, F, e3), this.reverse = this.options.reverse ? 1 : -1, this.radiusSquared = typeof this.options.radius == "number" ? Math.pow(this.options.radius, 2) : null, this.resize();
  }
  resize() {
    const t2 = this.options.distance;
    t2 !== null ? (this.left = t2, this.top = t2, this.right = this.parent.screenWidth - t2, this.bottom = this.parent.screenHeight - t2) : this.options.radius || (this.left = this.options.left, this.top = this.options.top, this.right = this.options.right === null ? null : this.parent.screenWidth - this.options.right, this.bottom = this.options.bottom === null ? null : this.parent.screenHeight - this.options.bottom);
  }
  down() {
    return this.paused || this.options.allowButtons || (this.horizontal = this.vertical = null), false;
  }
  move(t2) {
    if (this.paused || t2.pointerType !== "mouse" && t2.pointerId !== 1 || !this.options.allowButtons && t2.buttons !== 0)
      return false;
    const e3 = t2.global.x, n2 = t2.global.y;
    if (this.radiusSquared) {
      const i3 = this.parent.toScreen(this.parent.center);
      if (Math.pow(i3.x - e3, 2) + Math.pow(i3.y - n2, 2) >= this.radiusSquared) {
        const h2 = Math.atan2(i3.y - n2, i3.x - e3);
        this.options.linear ? (this.horizontal = Math.round(Math.cos(h2)) * this.options.speed * this.reverse * (60 / 1e3), this.vertical = Math.round(Math.sin(h2)) * this.options.speed * this.reverse * (60 / 1e3)) : (this.horizontal = Math.cos(h2) * this.options.speed * this.reverse * (60 / 1e3), this.vertical = Math.sin(h2) * this.options.speed * this.reverse * (60 / 1e3));
      } else
        this.horizontal && this.decelerateHorizontal(), this.vertical && this.decelerateVertical(), this.horizontal = this.vertical = 0;
    } else
      this.left !== null && e3 < this.left ? this.horizontal = Number(this.reverse) * this.options.speed * (60 / 1e3) : this.right !== null && e3 > this.right ? this.horizontal = -1 * this.reverse * this.options.speed * (60 / 1e3) : (this.decelerateHorizontal(), this.horizontal = 0), this.top !== null && n2 < this.top ? this.vertical = Number(this.reverse) * this.options.speed * (60 / 1e3) : this.bottom !== null && n2 > this.bottom ? this.vertical = -1 * this.reverse * this.options.speed * (60 / 1e3) : (this.decelerateVertical(), this.vertical = 0);
    return false;
  }
  decelerateHorizontal() {
    const t2 = this.parent.plugins.get("decelerate", true);
    this.horizontal && t2 && !this.options.noDecelerate && t2.activate({ x: this.horizontal * this.options.speed * this.reverse / (1e3 / 60) });
  }
  decelerateVertical() {
    const t2 = this.parent.plugins.get("decelerate", true);
    this.vertical && t2 && !this.options.noDecelerate && t2.activate({ y: this.vertical * this.options.speed * this.reverse / (1e3 / 60) });
  }
  up() {
    return this.paused || (this.horizontal && this.decelerateHorizontal(), this.vertical && this.decelerateVertical(), this.horizontal = this.vertical = null), false;
  }
  update() {
    if (!this.paused && (this.horizontal || this.vertical)) {
      const t2 = this.parent.center;
      this.horizontal && (t2.x += this.horizontal * this.options.speed), this.vertical && (t2.y += this.vertical * this.options.speed), this.parent.moveCenter(t2), this.parent.emit("moved", { viewport: this.parent, type: "mouse-edges" });
    }
  }
};
var V = {
  noDrag: false,
  percent: 1,
  center: null,
  factor: 1,
  axis: "all"
};
var N2 = class extends u2 {
  /**
   * This is called by {@link Viewport.pinch}.
   */
  constructor(t2, e3 = {}) {
    super(t2), this.active = false, this.pinching = false, this.moved = false, this.options = Object.assign({}, V, e3);
  }
  down() {
    return this.parent.input.count() >= 2 ? (this.active = true, true) : false;
  }
  isAxisX() {
    return ["all", "x"].includes(this.options.axis);
  }
  isAxisY() {
    return ["all", "y"].includes(this.options.axis);
  }
  move(t2) {
    if (this.paused || !this.active)
      return false;
    const e3 = t2.global.x, n2 = t2.global.y, i3 = this.parent.input.touches;
    if (i3.length >= 2) {
      const s2 = i3[0], h2 = i3[1], o2 = s2.last && h2.last ? Math.sqrt(Math.pow(h2.last.x - s2.last.x, 2) + Math.pow(h2.last.y - s2.last.y, 2)) : null;
      if (s2.id === t2.pointerId ? s2.last = { x: e3, y: n2, data: t2 } : h2.id === t2.pointerId && (h2.last = { x: e3, y: n2, data: t2 }), o2) {
        let r2;
        const a2 = new Point3(
          s2.last.x + (h2.last.x - s2.last.x) / 2,
          s2.last.y + (h2.last.y - s2.last.y) / 2
        );
        this.options.center || (r2 = this.parent.toLocal(a2));
        let p3 = Math.sqrt(Math.pow(
          h2.last.x - s2.last.x,
          2
        ) + Math.pow(h2.last.y - s2.last.y, 2));
        p3 = p3 === 0 ? p3 = 1e-10 : p3;
        const f3 = (1 - o2 / p3) * this.options.percent * (this.isAxisX() ? this.parent.scale.x : this.parent.scale.y);
        this.isAxisX() && (this.parent.scale.x += f3), this.isAxisY() && (this.parent.scale.y += f3), this.parent.emit("zoomed", { viewport: this.parent, type: "pinch", center: a2 });
        const g2 = this.parent.plugins.get("clamp-zoom", true);
        if (g2 && g2.clamp(), this.options.center)
          this.parent.moveCenter(this.options.center);
        else {
          const w2 = this.parent.toGlobal(r2);
          this.parent.x += (a2.x - w2.x) * this.options.factor, this.parent.y += (a2.y - w2.y) * this.options.factor, this.parent.emit("moved", { viewport: this.parent, type: "pinch" });
        }
        !this.options.noDrag && this.lastCenter && (this.parent.x += (a2.x - this.lastCenter.x) * this.options.factor, this.parent.y += (a2.y - this.lastCenter.y) * this.options.factor, this.parent.emit("moved", { viewport: this.parent, type: "pinch" })), this.lastCenter = a2, this.moved = true;
      } else
        this.pinching || (this.parent.emit("pinch-start", this.parent), this.pinching = true);
      return true;
    }
    return false;
  }
  up() {
    return this.pinching && this.parent.input.touches.length <= 1 ? (this.active = false, this.lastCenter = null, this.pinching = false, this.moved = false, this.parent.emit("pinch-end", this.parent), true) : false;
  }
};
var Z = {
  topLeft: false,
  friction: 0.8,
  time: 1e3,
  ease: "easeInOutSine",
  interrupt: true,
  removeOnComplete: false,
  removeOnInterrupt: false,
  forceStart: false
};
var j2 = class extends u2 {
  /**
   * This is called by {@link Viewport.snap}.
   */
  constructor(t2, e3, n2, i3 = {}) {
    super(t2), this.options = Object.assign({}, Z, i3), this.ease = x2(i3.ease, "easeInOutSine"), this.x = e3, this.y = n2, this.options.forceStart && this.snapStart();
  }
  snapStart() {
    this.percent = 0, this.snapping = { time: 0 };
    const t2 = this.options.topLeft ? this.parent.corner : this.parent.center;
    this.deltaX = this.x - t2.x, this.deltaY = this.y - t2.y, this.startX = t2.x, this.startY = t2.y, this.parent.emit("snap-start", this.parent);
  }
  wheel() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("snap"), false;
  }
  down() {
    return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap") : this.options.interrupt && (this.snapping = null), false;
  }
  up() {
    if (this.parent.input.count() === 0) {
      const t2 = this.parent.plugins.get("decelerate", true);
      t2 && (t2.x || t2.y) && (t2.percentChangeX = t2.percentChangeY = this.options.friction);
    }
    return false;
  }
  update(t2) {
    if (!this.paused && !(this.options.interrupt && this.parent.input.count() !== 0))
      if (this.snapping) {
        const e3 = this.snapping;
        e3.time += t2;
        let n2, i3, s2;
        const h2 = this.startX, o2 = this.startY, r2 = this.deltaX, a2 = this.deltaY;
        if (e3.time > this.options.time)
          n2 = true, i3 = h2 + r2, s2 = o2 + a2;
        else {
          const p3 = this.ease(e3.time, 0, 1, this.options.time);
          i3 = h2 + r2 * p3, s2 = o2 + a2 * p3;
        }
        this.options.topLeft ? this.parent.moveCorner(i3, s2) : this.parent.moveCenter(i3, s2), this.parent.emit("moved", { viewport: this.parent, type: "snap" }), n2 && (this.options.removeOnComplete && this.parent.plugins.remove("snap"), this.parent.emit("snap-end", this.parent), this.snapping = null);
      } else {
        const e3 = this.options.topLeft ? this.parent.corner : this.parent.center;
        (e3.x !== this.x || e3.y !== this.y) && this.snapStart();
      }
  }
};
var R = {
  width: 0,
  height: 0,
  time: 1e3,
  ease: "easeInOutSine",
  center: null,
  interrupt: true,
  removeOnComplete: false,
  removeOnInterrupt: false,
  forceStart: false,
  noMove: false
};
var K = class extends u2 {
  /**
   * This is called by {@link Viewport.snapZoom}.
   */
  constructor(t2, e3 = {}) {
    super(t2), this.options = Object.assign({}, R, e3), this.ease = x2(this.options.ease), this.xIndependent = false, this.yIndependent = false, this.xScale = 0, this.yScale = 0, this.options.width > 0 && (this.xScale = t2.screenWidth / this.options.width, this.xIndependent = true), this.options.height > 0 && (this.yScale = t2.screenHeight / this.options.height, this.yIndependent = true), this.xScale = this.xIndependent ? this.xScale : this.yScale, this.yScale = this.yIndependent ? this.yScale : this.xScale, this.options.time === 0 ? (t2.container.scale.x = this.xScale, t2.container.scale.y = this.yScale, this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom")) : e3.forceStart && this.createSnapping();
  }
  createSnapping() {
    const t2 = this.parent.worldScreenWidth, e3 = this.parent.worldScreenHeight, n2 = this.parent.screenWidth / this.xScale, i3 = this.parent.screenHeight / this.yScale;
    this.snapping = {
      time: 0,
      startX: t2,
      startY: e3,
      deltaX: n2 - t2,
      deltaY: i3 - e3
    }, this.parent.emit("snap-zoom-start", this.parent);
  }
  resize() {
    this.snapping = null, this.options.width > 0 && (this.xScale = this.parent.screenWidth / this.options.width), this.options.height > 0 && (this.yScale = this.parent.screenHeight / this.options.height), this.xScale = this.xIndependent ? this.xScale : this.yScale, this.yScale = this.yIndependent ? this.yScale : this.xScale;
  }
  wheel() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("snap-zoom"), false;
  }
  down() {
    return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap-zoom") : this.options.interrupt && (this.snapping = null), false;
  }
  update(t2) {
    if (this.paused || this.options.interrupt && this.parent.input.count() !== 0)
      return;
    let e3;
    if (!this.options.center && !this.options.noMove && (e3 = this.parent.center), !this.snapping)
      (this.parent.scale.x !== this.xScale || this.parent.scale.y !== this.yScale) && this.createSnapping();
    else if (this.snapping) {
      const n2 = this.snapping;
      if (n2.time += t2, n2.time >= this.options.time)
        this.parent.scale.set(this.xScale, this.yScale), this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom"), this.parent.emit("snap-zoom-end", this.parent), this.snapping = null;
      else {
        const s2 = this.snapping, h2 = this.ease(s2.time, s2.startX, s2.deltaX, this.options.time), o2 = this.ease(s2.time, s2.startY, s2.deltaY, this.options.time);
        this.parent.scale.x = this.parent.screenWidth / h2, this.parent.scale.y = this.parent.screenHeight / o2;
      }
      const i3 = this.parent.plugins.get("clamp-zoom", true);
      i3 && i3.clamp(), this.options.noMove || (this.options.center ? this.parent.moveCenter(this.options.center) : this.parent.moveCenter(e3));
    }
  }
  resume() {
    this.snapping = null, super.resume();
  }
};
var q = {
  percent: 0.1,
  smooth: false,
  interrupt: true,
  reverse: false,
  center: null,
  lineHeight: 20,
  axis: "all",
  keyToPress: null,
  trackpadPinch: false,
  wheelZoom: true
};
var G = class extends u2 {
  /**
   * This is called by {@link Viewport.wheel}.
   */
  constructor(t2, e3 = {}) {
    super(t2), this.options = Object.assign({}, q, e3), this.keyIsPressed = false, this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress);
  }
  /**
   * Handles keypress events and set the keyIsPressed boolean accordingly
   *
   * @param {array} codes - key codes that can be used to trigger zoom event
   */
  handleKeyPresses(t2) {
    typeof window > "u" || (window.addEventListener("keydown", (e3) => {
      t2.includes(e3.code) && (this.keyIsPressed = true);
    }), window.addEventListener("keyup", (e3) => {
      t2.includes(e3.code) && (this.keyIsPressed = false);
    }));
  }
  checkKeyPress() {
    return !this.options.keyToPress || this.keyIsPressed;
  }
  down() {
    return this.options.interrupt && (this.smoothing = null), false;
  }
  isAxisX() {
    return ["all", "x"].includes(this.options.axis);
  }
  isAxisY() {
    return ["all", "y"].includes(this.options.axis);
  }
  update() {
    if (this.smoothing) {
      const t2 = this.smoothingCenter, e3 = this.smoothing;
      let n2;
      this.options.center || (n2 = this.parent.toLocal(t2)), this.isAxisX() && (this.parent.scale.x += e3.x), this.isAxisY() && (this.parent.scale.y += e3.y), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
      const i3 = this.parent.plugins.get("clamp-zoom", true);
      if (i3 && i3.clamp(), this.options.center)
        this.parent.moveCenter(this.options.center);
      else {
        const s2 = this.parent.toGlobal(n2);
        this.parent.x += t2.x - s2.x, this.parent.y += t2.y - s2.y;
      }
      this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.smoothingCount++, this.smoothingCount >= this.options.smooth && (this.smoothing = null);
    }
  }
  pinch(t2) {
    if (this.paused)
      return;
    const e3 = this.parent.input.getPointerPosition(t2), n2 = -t2.deltaY * (t2.deltaMode ? this.options.lineHeight : 1) / 200, i3 = Math.pow(2, (1 + this.options.percent) * n2);
    let s2;
    this.options.center || (s2 = this.parent.toLocal(e3)), this.isAxisX() && (this.parent.scale.x *= i3), this.isAxisY() && (this.parent.scale.y *= i3), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
    const h2 = this.parent.plugins.get("clamp-zoom", true);
    if (h2 && h2.clamp(), this.options.center)
      this.parent.moveCenter(this.options.center);
    else {
      const o2 = this.parent.toGlobal(s2);
      this.parent.x += e3.x - o2.x, this.parent.y += e3.y - o2.y;
    }
    this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.emit(
      "wheel-start",
      { event: t2, viewport: this.parent }
    );
  }
  wheel(t2) {
    if (this.paused || !this.checkKeyPress())
      return false;
    if (t2.ctrlKey && this.options.trackpadPinch)
      this.pinch(t2);
    else if (this.options.wheelZoom) {
      const e3 = this.parent.input.getPointerPosition(t2), i3 = (this.options.reverse ? -1 : 1) * -t2.deltaY * (t2.deltaMode ? this.options.lineHeight : 1) / 500, s2 = Math.pow(2, (1 + this.options.percent) * i3);
      if (this.options.smooth) {
        const h2 = {
          x: this.smoothing ? this.smoothing.x * (this.options.smooth - this.smoothingCount) : 0,
          y: this.smoothing ? this.smoothing.y * (this.options.smooth - this.smoothingCount) : 0
        };
        this.smoothing = {
          x: ((this.parent.scale.x + h2.x) * s2 - this.parent.scale.x) / this.options.smooth,
          y: ((this.parent.scale.y + h2.y) * s2 - this.parent.scale.y) / this.options.smooth
        }, this.smoothingCount = 0, this.smoothingCenter = e3;
      } else {
        let h2;
        this.options.center || (h2 = this.parent.toLocal(e3)), this.isAxisX() && (this.parent.scale.x *= s2), this.isAxisY() && (this.parent.scale.y *= s2), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
        const o2 = this.parent.plugins.get("clamp-zoom", true);
        if (o2 && o2.clamp(), this.options.center)
          this.parent.moveCenter(this.options.center);
        else {
          const r2 = this.parent.toGlobal(h2);
          this.parent.x += e3.x - r2.x, this.parent.y += e3.y - r2.y;
        }
      }
      this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.emit(
        "wheel-start",
        { event: t2, viewport: this.parent }
      );
    }
    return !this.parent.options.passiveWheel;
  }
};
var Q = class {
  constructor(t2) {
    this.viewport = t2, this.touches = [], this.addListeners();
  }
  /** Add input listeners */
  addListeners() {
    this.viewport.forceHitArea || (this.viewport.hitArea = new Rectangle3(0, 0, this.viewport.worldWidth, this.viewport.worldHeight)), this.viewport.on("pointerdown", this.down, this), this.viewport.options.allowPreserveDragOutside ? this.viewport.on("globalpointermove", this.move, this) : this.viewport.on("pointermove", this.move, this), this.viewport.on("pointerup", this.up, this), this.viewport.on("pointerupoutside", this.up, this), this.viewport.on("pointercancel", this.up, this), this.viewport.options.allowPreserveDragOutside || this.viewport.on("pointerleave", this.up, this), this.wheelFunction = (t2) => this.handleWheel(t2), this.viewport.options.events.domElement.addEventListener(
      "wheel",
      this.wheelFunction,
      { passive: this.viewport.options.passiveWheel }
    ), this.isMouseDown = false;
  }
  /**
   * Removes all event listeners from viewport
   * (useful for cleanup of wheel when removing viewport)
   */
  destroy() {
    this.viewport.options.events.domElement.removeEventListener("wheel", this.wheelFunction);
  }
  /**
   * handle down events for viewport
   *
   * @param {PIXI.FederatedPointerEvent} event
   */
  down(t2) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    if (t2.pointerType === "mouse" ? this.isMouseDown = true : this.get(t2.pointerId) || this.touches.push({ id: t2.pointerId, last: null }), this.count() === 1) {
      this.last = t2.global.clone();
      const n2 = this.viewport.plugins.get("decelerate", true), i3 = this.viewport.plugins.get("bounce", true);
      (!n2 || !n2.isActive()) && (!i3 || !i3.isActive()) ? this.clickedAvailable = true : this.clickedAvailable = false;
    } else
      this.clickedAvailable = false;
    this.viewport.plugins.down(t2) && this.viewport.options.stopPropagation && t2.stopPropagation();
  }
  /** Clears all pointer events */
  clear() {
    this.isMouseDown = false, this.touches = [], this.last = null;
  }
  /**
   * @param {number} change
   * @returns whether change exceeds threshold
   */
  checkThreshold(t2) {
    return Math.abs(t2) >= this.viewport.threshold;
  }
  /** Handle move events for viewport */
  move(t2) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    const e3 = this.viewport.plugins.move(t2);
    if (this.clickedAvailable && this.last) {
      const n2 = t2.global.x - this.last.x, i3 = t2.global.y - this.last.y;
      (this.checkThreshold(n2) || this.checkThreshold(i3)) && (this.clickedAvailable = false);
    }
    e3 && this.viewport.options.stopPropagation && t2.stopPropagation();
  }
  /** Handle up events for viewport */
  up(t2) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    t2.pointerType === "mouse" && (this.isMouseDown = false), t2.pointerType !== "mouse" && this.remove(t2.pointerId);
    const e3 = this.viewport.plugins.up(t2);
    this.clickedAvailable && this.count() === 0 && this.last && (this.viewport.emit("clicked", {
      event: t2,
      screen: this.last,
      world: this.viewport.toWorld(this.last),
      viewport: this.viewport
    }), this.clickedAvailable = false), e3 && this.viewport.options.stopPropagation && t2.stopPropagation();
  }
  /** Gets pointer position if this.interaction is set */
  getPointerPosition(t2) {
    const e3 = new Point3();
    return this.viewport.options.events.mapPositionToPoint(e3, t2.clientX, t2.clientY), e3;
  }
  /** Handle wheel events */
  handleWheel(t2) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    const e3 = this.viewport.toLocal(this.getPointerPosition(t2));
    this.viewport.left <= e3.x && e3.x <= this.viewport.right && this.viewport.top <= e3.y && e3.y <= this.viewport.bottom && this.viewport.plugins.wheel(t2) && !this.viewport.options.passiveWheel && t2.preventDefault();
  }
  pause() {
    this.touches = [], this.isMouseDown = false;
  }
  /** Get touch by id */
  get(t2) {
    for (const e3 of this.touches)
      if (e3.id === t2)
        return e3;
    return null;
  }
  /** Remove touch by number */
  remove(t2) {
    for (let e3 = 0; e3 < this.touches.length; e3++)
      if (this.touches[e3].id === t2) {
        this.touches.splice(e3, 1);
        return;
      }
  }
  /**
   * @returns {number} count of mouse/touch pointers that are down on the viewport
   */
  count() {
    return (this.isMouseDown ? 1 : 0) + this.touches.length;
  }
};
var m2 = [
  "drag",
  "pinch",
  "wheel",
  "follow",
  "mouse-edges",
  "decelerate",
  "animate",
  "bounce",
  "snap-zoom",
  "clamp-zoom",
  "snap",
  "clamp"
];
var J = class {
  /** This is called by {@link Viewport} to initialize the {@link Viewport.plugins plugins}. */
  constructor(t2) {
    this.viewport = t2, this.list = [], this.plugins = {};
  }
  /**
   * Inserts a named plugin or a user plugin into the viewport
   * default plugin order: 'drag', 'pinch', 'wheel', 'follow', 'mouse-edges', 'decelerate', 'bounce',
   * 'snap-zoom', 'clamp-zoom', 'snap', 'clamp'
   *
   * @param {string} name of plugin
   * @param {Plugin} plugin - instantiated Plugin class
   * @param {number} index to insert userPlugin (otherwise inserts it at the end)
   */
  add(t2, e3, n2 = m2.length) {
    const i3 = this.plugins[t2];
    i3 && i3.destroy(), this.plugins[t2] = e3;
    const s2 = m2.indexOf(t2);
    s2 !== -1 && m2.splice(s2, 1), m2.splice(n2, 0, t2), this.sort();
  }
  /**
   * Get plugin
   *
   * @param {string} name of plugin
   * @param {boolean} [ignorePaused] return null if plugin is paused
   */
  get(t2, e3) {
    var n2;
    return e3 && (n2 = this.plugins[t2]) != null && n2.paused ? null : this.plugins[t2];
  }
  /**
   * Update all active plugins
   *
   * @internal
   * @ignore
   * @param {number} elapsed type in milliseconds since last update
   */
  update(t2) {
    for (const e3 of this.list)
      e3.update(t2);
  }
  /**
   * Resize all active plugins
   *
   * @internal
   * @ignore
   */
  resize() {
    for (const t2 of this.list)
      t2.resize();
  }
  /** Clamps and resets bounce and decelerate (as needed) after manually moving viewport */
  reset() {
    for (const t2 of this.list)
      t2.reset();
  }
  /** removes all installed plugins */
  removeAll() {
    this.list.forEach((t2) => {
      t2.destroy();
    }), this.plugins = {}, this.sort();
  }
  /**
   * Removes installed plugin
   *
   * @param {string} name of plugin (e.g., 'drag', 'pinch')
   */
  remove(t2) {
    var e3;
    this.plugins[t2] && ((e3 = this.plugins[t2]) == null || e3.destroy(), delete this.plugins[t2], this.viewport.emit("plugin-remove", t2), this.sort());
  }
  /**
   * Pause plugin
   *
   * @param {string} name of plugin (e.g., 'drag', 'pinch')
   */
  pause(t2) {
    var e3;
    (e3 = this.plugins[t2]) == null || e3.pause();
  }
  /**
   * Resume plugin
   *
   * @param {string} name of plugin (e.g., 'drag', 'pinch')
   */
  resume(t2) {
    var e3;
    (e3 = this.plugins[t2]) == null || e3.resume();
  }
  /**
   * Sort plugins according to PLUGIN_ORDER
   *
   * @internal
   * @ignore
   */
  sort() {
    this.list = [];
    for (const t2 of m2)
      this.plugins[t2] && this.list.push(this.plugins[t2]);
  }
  /**
   * Handle down for all plugins
   *
   * @internal
   * @ignore
   */
  down(t2) {
    let e3 = false;
    for (const n2 of this.list)
      n2.down(t2) && (e3 = true);
    return e3;
  }
  /**
   * Handle move for all plugins
   *
   * @internal
   * @ignore
   */
  move(t2) {
    let e3 = false;
    for (const n2 of this.viewport.plugins.list)
      n2.move(t2) && (e3 = true);
    return e3;
  }
  /**
   * Handle up for all plugins
   *
   * @internal
   * @ignore
   */
  up(t2) {
    let e3 = false;
    for (const n2 of this.list)
      n2.up(t2) && (e3 = true);
    return e3;
  }
  /**
   * Handle wheel event for all plugins
   *
   * @internal
   * @ignore
   */
  wheel(t2) {
    let e3 = false;
    for (const n2 of this.list)
      n2.wheel(t2) && (e3 = true);
    return e3;
  }
};
var $2 = {
  screenWidth: typeof window > "u" ? 0 : window.innerWidth,
  screenHeight: typeof window > "u" ? 0 : window.innerHeight,
  worldWidth: null,
  worldHeight: null,
  threshold: 5,
  passiveWheel: true,
  stopPropagation: false,
  forceHitArea: null,
  noTicker: false,
  disableOnContextMenu: false,
  ticker: Ticker3.shared,
  allowPreserveDragOutside: false
};
var et = class extends Container4 {
  /**
   * @param {IViewportOptions} ViewportOptions
   * @param {number} [options.screenWidth=window.innerWidth]
   * @param {number} [options.screenHeight=window.innerHeight]
   * @param {number} [options.worldWidth=this.width]
   * @param {number} [options.worldHeight=this.height]
   * @param {number} [options.threshold=5] number of pixels to move to trigger an input event (e.g., drag, pinch)
   * or disable a clicked event
   * @param {boolean} [options.passiveWheel=true] whether the 'wheel' event is set to passive (note: if false,
   * e.preventDefault() will be called when wheel is used over the viewport)
   * @param {boolean} [options.stopPropagation=false] whether to stopPropagation of events that impact the viewport
   * (except wheel events, see options.passiveWheel)
   * @param {HitArea} [options.forceHitArea] change the default hitArea from world size to a new value
   * @param {boolean} [options.noTicker] set this if you want to manually call update() function on each frame
   * @param {PIXI.Ticker} [options.ticker=PIXI.Ticker.shared] use this PIXI.ticker for updates
   * @param {PIXI.EventSystem} [options.events] EventSystem available from app.events or added manually and passed here
   * location on screen
   * @param {boolean} [options.disableOnContextMenu] remove oncontextmenu=() => {} from the pixi's events.domElement
   */
  constructor(t2) {
    super(), this._disableOnContextMenu = (e3) => e3.preventDefault(), this.options = {
      ...$2,
      ...t2
    }, this.screenWidth = this.options.screenWidth, this.screenHeight = this.options.screenHeight, this._worldWidth = this.options.worldWidth, this._worldHeight = this.options.worldHeight, this.forceHitArea = this.options.forceHitArea, this.threshold = this.options.threshold, this.options.disableOnContextMenu && this.options.events.domElement.addEventListener("contextmenu", this._disableOnContextMenu), this.options.noTicker || (this.tickerFunction = () => this.update(this.options.ticker.elapsedMS), this.options.ticker.add(this.tickerFunction)), this.input = new Q(this), this.plugins = new J(this);
  }
  /** Overrides PIXI.Container's destroy to also remove the 'wheel' and PIXI.Ticker listeners */
  destroy(t2) {
    !this.options.noTicker && this.tickerFunction && this.options.ticker.remove(this.tickerFunction), this.options.disableOnContextMenu && this.options.events.domElement.removeEventListener("contextmenu", this._disableOnContextMenu), this.input.destroy(), super.destroy(t2);
  }
  /**
   * Update viewport on each frame.
   *
   * By default, you do not need to call this unless you set `options.noTicker=true`.
   *
   * @param {number} elapsed time in milliseconds since last update
   */
  update(t2) {
    this.pause || (this.plugins.update(t2), this.lastViewport && (this.lastViewport.x !== this.x || this.lastViewport.y !== this.y ? this.moving = true : this.moving && (this.emit("moved-end", this), this.moving = false), this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y ? this.zooming = true : this.zooming && (this.emit("zoomed-end", this), this.zooming = false)), this.forceHitArea || (this._hitAreaDefault = new Rectangle3(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight), this.hitArea = this._hitAreaDefault), this._dirty = this._dirty || !this.lastViewport || this.lastViewport.x !== this.x || this.lastViewport.y !== this.y || this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y, this.lastViewport = {
      x: this.x,
      y: this.y,
      scaleX: this.scale.x,
      scaleY: this.scale.y
    }, this.emit("frame-end", this));
  }
  /**
   * Use this to set screen and world sizes, needed for pinch/wheel/clamp/bounce.
   * @param {number} screenWidth=window.innerWidth
   * @param {number} screenHeight=window.innerHeight
   * @param {number} [worldWidth]
   * @param {number} [worldHeight]
   */
  resize(t2 = typeof window > "u" ? 0 : window.innerWidth, e3 = typeof window > "u" ? 0 : window.innerHeight, n2, i3) {
    this.screenWidth = t2, this.screenHeight = e3, typeof n2 < "u" && (this._worldWidth = n2), typeof i3 < "u" && (this._worldHeight = i3), this.plugins.resize(), this.dirty = true;
  }
  /** World width, in pixels */
  get worldWidth() {
    return this._worldWidth ? this._worldWidth : this.width / this.scale.x;
  }
  set worldWidth(t2) {
    this._worldWidth = t2, this.plugins.resize();
  }
  /** World height, in pixels */
  get worldHeight() {
    return this._worldHeight ? this._worldHeight : this.height / this.scale.y;
  }
  set worldHeight(t2) {
    this._worldHeight = t2, this.plugins.resize();
  }
  /** Get visible world bounds of viewport */
  getVisibleBounds() {
    return new Rectangle3(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight);
  }
  /**
   * Changes coordinate from screen to world
   * @param {number|PIXI.Point} x
   * @param {number} y
   * @returns {PIXI.Point}
   */
  toWorld(t2, e3) {
    return arguments.length === 2 ? this.toLocal(new Point3(t2, e3)) : this.toLocal(t2);
  }
  /**
   * Changes coordinate from world to screen
   * @param {number|PIXI.Point} x
   * @param {number} y
   * @returns {PIXI.Point}
   */
  toScreen(t2, e3) {
    return arguments.length === 2 ? this.toGlobal(new Point3(t2, e3)) : this.toGlobal(t2);
  }
  /** Screen width in world coordinates */
  get worldScreenWidth() {
    return this.screenWidth / this.scale.x;
  }
  /** Screen height in world coordinates */
  get worldScreenHeight() {
    return this.screenHeight / this.scale.y;
  }
  /** World width in screen coordinates */
  get screenWorldWidth() {
    return this.worldWidth * this.scale.x;
  }
  /** World height in screen coordinates */
  get screenWorldHeight() {
    return this.worldHeight * this.scale.y;
  }
  /** Center of screen in world coordinates */
  get center() {
    return new Point3(
      this.worldScreenWidth / 2 - this.x / this.scale.x,
      this.worldScreenHeight / 2 - this.y / this.scale.y
    );
  }
  set center(t2) {
    this.moveCenter(t2);
  }
  /**
   * Move center of viewport to (x, y)
   * @param {number|PIXI.Point} x
   * @param {number} [y]
   * @return {Viewport}
   */
  moveCenter(...t2) {
    let e3, n2;
    typeof t2[0] == "number" ? (e3 = t2[0], n2 = t2[1]) : (e3 = t2[0].x, n2 = t2[0].y);
    const i3 = (this.worldScreenWidth / 2 - e3) * this.scale.x, s2 = (this.worldScreenHeight / 2 - n2) * this.scale.y;
    return (this.x !== i3 || this.y !== s2) && (this.position.set(i3, s2), this.plugins.reset(), this.dirty = true), this;
  }
  /** Top-left corner of Viewport */
  get corner() {
    return new Point3(-this.x / this.scale.x, -this.y / this.scale.y);
  }
  set corner(t2) {
    this.moveCorner(t2);
  }
  /**
   * MoveCorner
   * @param {number|PIXI.Point} x
   * @param {number} [y]
   * @returns {Viewport}
   */
  moveCorner(...t2) {
    let e3, n2;
    return t2.length === 1 ? (e3 = -t2[0].x * this.scale.x, n2 = -t2[0].y * this.scale.y) : (e3 = -t2[0] * this.scale.x, n2 = -t2[1] * this.scale.y), (e3 !== this.x || n2 !== this.y) && (this.position.set(e3, n2), this.plugins.reset(), this.dirty = true), this;
  }
  /** Get how many world pixels fit in screen's width */
  get screenWidthInWorldPixels() {
    return this.screenWidth / this.scale.x;
  }
  /** Get how many world pixels fit on screen's height */
  get screenHeightInWorldPixels() {
    return this.screenHeight / this.scale.y;
  }
  /**
   * Find the scale value that fits a world width on the screen
   * does not change the viewport (use fit... to change)
   *
   * @param width - Width in world pixels
   * @return - scale
   */
  findFitWidth(t2) {
    return this.screenWidth / t2;
  }
  /**
   * Finds the scale value that fits a world height on the screens
   * does not change the viewport (use fit... to change)
   *
   * @param height - Height in world pixels
   * @return - scale
   */
  findFitHeight(t2) {
    return this.screenHeight / t2;
  }
  /**
   * Finds the scale value that fits the smaller of a world width and world height on the screen
   * does not change the viewport (use fit... to change)
   *
   * @param {number} width in world pixels
   * @param {number} height in world pixels
   * @returns {number} scale
   */
  findFit(t2, e3) {
    const n2 = this.screenWidth / t2, i3 = this.screenHeight / e3;
    return Math.min(n2, i3);
  }
  /**
   * Finds the scale value that fits the larger of a world width and world height on the screen
   * does not change the viewport (use fit... to change)
   *
   * @param {number} width in world pixels
   * @param {number} height in world pixels
   * @returns {number} scale
   */
  findCover(t2, e3) {
    const n2 = this.screenWidth / t2, i3 = this.screenHeight / e3;
    return Math.max(n2, i3);
  }
  /**
   * Change zoom so the width fits in the viewport
   *
   * @param width - width in world coordinates
   * @param center - maintain the same center
   * @param scaleY - whether to set scaleY=scaleX
   * @param noClamp - whether to disable clamp-zoom
   * @returns {Viewport} this
   */
  fitWidth(t2 = this.worldWidth, e3, n2 = true, i3) {
    let s2;
    e3 && (s2 = this.center), this.scale.x = this.screenWidth / t2, n2 && (this.scale.y = this.scale.x);
    const h2 = this.plugins.get("clamp-zoom", true);
    return !i3 && h2 && h2.clamp(), e3 && s2 && this.moveCenter(s2), this;
  }
  /**
   * Change zoom so the height fits in the viewport
   *
   * @param {number} [height=this.worldHeight] in world coordinates
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @param {boolean} [scaleX=true] whether to set scaleX = scaleY
   * @param {boolean} [noClamp] whether to disable clamp-zoom
   * @returns {Viewport} this
   */
  fitHeight(t2 = this.worldHeight, e3, n2 = true, i3) {
    let s2;
    e3 && (s2 = this.center), this.scale.y = this.screenHeight / t2, n2 && (this.scale.x = this.scale.y);
    const h2 = this.plugins.get("clamp-zoom", true);
    return !i3 && h2 && h2.clamp(), e3 && s2 && this.moveCenter(s2), this;
  }
  /**
   * Change zoom so it fits the entire world in the viewport
   *
   * @param {boolean} center maintain the same center of the screen after zoom
   * @returns {Viewport} this
   */
  fitWorld(t2) {
    let e3;
    t2 && (e3 = this.center), this.scale.x = this.screenWidth / this.worldWidth, this.scale.y = this.screenHeight / this.worldHeight, this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y;
    const n2 = this.plugins.get("clamp-zoom", true);
    return n2 && n2.clamp(), t2 && e3 && this.moveCenter(e3), this;
  }
  /**
   * Change zoom so it fits the size or the entire world in the viewport
   *
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @param {number} [width=this.worldWidth] desired width
   * @param {number} [height=this.worldHeight] desired height
   * @returns {Viewport} this
   */
  fit(t2, e3 = this.worldWidth, n2 = this.worldHeight) {
    let i3;
    t2 && (i3 = this.center), this.scale.x = this.screenWidth / e3, this.scale.y = this.screenHeight / n2, this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y;
    const s2 = this.plugins.get("clamp-zoom", true);
    return s2 && s2.clamp(), t2 && i3 && this.moveCenter(i3), this;
  }
  /**
   * Zoom viewport to specific value.
   *
   * @param {number} scale value (e.g., 1 would be 100%, 0.25 would be 25%)
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @return {Viewport} this
   */
  setZoom(t2, e3) {
    let n2;
    e3 && (n2 = this.center), this.scale.set(t2);
    const i3 = this.plugins.get("clamp-zoom", true);
    return i3 && i3.clamp(), e3 && n2 && this.moveCenter(n2), this;
  }
  /**
   * Zoom viewport by a certain percent (in both x and y direction).
   *
   * @param {number} percent change (e.g., 0.25 would increase a starting scale of 1.0 to 1.25)
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @return {Viewport} this
   */
  zoomPercent(t2, e3) {
    return this.setZoom(this.scale.x + this.scale.x * t2, e3);
  }
  /**
   * Zoom viewport by increasing/decreasing width by a certain number of pixels.
   *
   * @param {number} change in pixels
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @return {Viewport} this
   */
  zoom(t2, e3) {
    return this.fitWidth(t2 + this.worldScreenWidth, e3), this;
  }
  /** Changes scale of viewport and maintains center of viewport */
  get scaled() {
    return this.scale.x;
  }
  set scaled(t2) {
    this.setZoom(t2, true);
  }
  /**
   * Returns zoom to the desired scale
   *
   * @param {ISnapZoomOptions} options
   * @param {number} [options.width=0] - the desired width to snap (to maintain aspect ratio, choose width or height)
   * @param {number} [options.height=0] - the desired height to snap (to maintain aspect ratio, choose width or height)
   * @param {number} [options.time=1000] - time for snapping in ms
   * @param {(string|function)} [options.ease=easeInOutSine] ease function or name (see http://easings.net/
   *   for supported names)
   * @param {PIXI.Point} [options.center] - place this point at center during zoom instead of center of the viewport
   * @param {boolean} [options.interrupt=true] - pause snapping with any user input on the viewport
   * @param {boolean} [options.removeOnComplete] - removes this plugin after snapping is complete
   * @param {boolean} [options.removeOnInterrupt] - removes this plugin if interrupted by any user input
   * @param {boolean} [options.forceStart] - starts the snap immediately regardless of whether the viewport is at the
   *   desired zoom
   * @param {boolean} [options.noMove] - zoom but do not move
   */
  snapZoom(t2) {
    return this.plugins.add("snap-zoom", new K(this, t2)), this;
  }
  /** Is container out of world bounds */
  OOB() {
    return {
      left: this.left < 0,
      right: this.right > this.worldWidth,
      top: this.top < 0,
      bottom: this.bottom > this.worldHeight,
      cornerPoint: new Point3(
        this.worldWidth * this.scale.x - this.screenWidth,
        this.worldHeight * this.scale.y - this.screenHeight
      )
    };
  }
  /** World coordinates of the right edge of the screen */
  get right() {
    return -this.x / this.scale.x + this.worldScreenWidth;
  }
  set right(t2) {
    this.x = -t2 * this.scale.x + this.screenWidth, this.plugins.reset();
  }
  /** World coordinates of the left edge of the screen */
  get left() {
    return -this.x / this.scale.x;
  }
  set left(t2) {
    this.x = -t2 * this.scale.x, this.plugins.reset();
  }
  /** World coordinates of the top edge of the screen */
  get top() {
    return -this.y / this.scale.y;
  }
  set top(t2) {
    this.y = -t2 * this.scale.y, this.plugins.reset();
  }
  /** World coordinates of the bottom edge of the screen */
  get bottom() {
    return -this.y / this.scale.y + this.worldScreenHeight;
  }
  set bottom(t2) {
    this.y = -t2 * this.scale.y + this.screenHeight, this.plugins.reset();
  }
  /**
   * Determines whether the viewport is dirty (i.e., needs to be rendered to the screen because of a change)
   */
  get dirty() {
    return !!this._dirty;
  }
  set dirty(t2) {
    this._dirty = t2;
  }
  /**
   * Permanently changes the Viewport's hitArea
   *
   * NOTE: if not set then hitArea = PIXI.Rectangle(Viewport.left, Viewport.top, Viewport.worldScreenWidth,
   * Viewport.worldScreenHeight)
   */
  get forceHitArea() {
    return this._forceHitArea;
  }
  set forceHitArea(t2) {
    t2 ? (this._forceHitArea = t2, this.hitArea = t2) : (this._forceHitArea = null, this.hitArea = new Rectangle3(0, 0, this.worldWidth, this.worldHeight));
  }
  /**
   * Enable one-finger touch to drag
   *
   * NOTE: if you expect users to use right-click dragging, you should enable `viewport.options.disableOnContextMenu`
   * to avoid the context menu popping up on each right-click drag.
   *
   * @param {IDragOptions} [options]
   * @param {string} [options.direction=all] direction to drag
   * @param {boolean} [options.pressDrag=true] whether click to drag is active
   * @param {boolean} [options.wheel=true] use wheel to scroll in direction (unless wheel plugin is active)
   * @param {number} [options.wheelScroll=1] number of pixels to scroll with each wheel spin
   * @param {boolean} [options.reverse] reverse the direction of the wheel scroll
   * @param {(boolean|string)} [options.clampWheel=false] clamp wheel(to avoid weird bounce with mouse wheel)
   * @param {string} [options.underflow=center] where to place world if too small for screen
   * @param {number} [options.factor=1] factor to multiply drag to increase the speed of movement
   * @param {string} [options.mouseButtons=all] changes which mouse buttons trigger drag, use: 'all', 'left',
   *  'right' 'middle', or some combination, like, 'middle-right'; you may want to set
   *   viewport.options.disableOnContextMenu if you want to use right-click dragging
   * @param {string[]} [options.keyToPress=null] - array containing
   *  {@link key|https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code} codes of keys that can be
   *  pressed for the drag to be triggered, e.g.: ['ShiftLeft', 'ShiftRight'}.
   * @param {boolean} [options.ignoreKeyToPressOnTouch=false] - ignore keyToPress for touch events
   * @param {number} [options.lineHeight=20] - scaling factor for non-DOM_DELTA_PIXEL scrolling events
   * @returns {Viewport} this
   */
  drag(t2) {
    return this.plugins.add("drag", new D(this, t2)), this;
  }
  /**
   * Clamp to world boundaries or other provided boundaries
   * There are three ways to clamp:
   * 1. direction: 'all' = the world is clamped to its world boundaries, ie, you cannot drag any part of offscreen
   *    direction: 'x' | 'y' = only the x or y direction is clamped to its world boundary
   * 2. left, right, top, bottom = true | number = the world is clamped to the world's pixel location for each side;
   *    if any of these are set to true, then the location is set to the boundary
   *    [0, viewport.worldWidth/viewport.worldHeight], eg: to allow the world to be completely dragged offscreen,
   *    set [-viewport.worldWidth, -viewport.worldHeight, viewport.worldWidth * 2, viewport.worldHeight * 2]
   *
   * Underflow determines what happens when the world is smaller than the viewport
   * 1. none = the world is clamped but there is no special behavior
   * 2. center = the world is centered on the viewport
   * 3. combination of top/bottom/center and left/right/center (case insensitive) = the world is stuck to the
   *     appropriate boundaries
   *
   * NOTES:
   *   clamp is disabled if called with no options; use { direction: 'all' } for all edge clamping
   *   screenWidth, screenHeight, worldWidth, and worldHeight needs to be set for this to work properly
   *
   * @param {object} [options]
   * @param {(number|boolean)} [options.left=false] - clamp left; true = 0
   * @param {(number|boolean)} [options.right=false] - clamp right; true = viewport.worldWidth
   * @param {(number|boolean)} [options.top=false] - clamp top; true = 0
   * @param {(number|boolean)} [options.bottom=false] - clamp bottom; true = viewport.worldHeight
   * @param {string} [direction] - (all, x, or y) using clamps of [0, viewport.worldWidth/viewport.worldHeight];
   *  replaces left/right/top/bottom if set
   * @param {string} [underflow=center] - where to place world if too small for screen (e.g., top-right, center,
   *  none, bottomLeft)     * @returns {Viewport} this
   */
  clamp(t2) {
    return this.plugins.add("clamp", new X(this, t2)), this;
  }
  /**
   * Decelerate after a move
   *
   * NOTE: this fires 'moved' event during deceleration
   *
   * @param {IDecelerateOptions} [options]
   * @param {number} [options.friction=0.95] - percent to decelerate after movement
   * @param {number} [options.bounce=0.8] - percent to decelerate when past boundaries (only applicable when
   *   viewport.bounce() is active)
   * @param {number} [options.minSpeed=0.01] - minimum velocity before stopping/reversing acceleration
   * @return {Viewport} this
   */
  decelerate(t2) {
    return this.plugins.add("decelerate", new T(this, t2)), this;
  }
  /**
   * Bounce on borders
   * NOTES:
   *    screenWidth, screenHeight, worldWidth, and worldHeight needs to be set for this to work properly
   *    fires 'moved', 'bounce-x-start', 'bounce-y-start', 'bounce-x-end', and 'bounce-y-end' events
   * @param {object} [options]
   * @param {string} [options.sides=all] - all, horizontal, vertical, or combination of top, bottom, right, left
   *  (e.g., 'top-bottom-right')
   * @param {number} [options.friction=0.5] - friction to apply to decelerate if active
   * @param {number} [options.time=150] - time in ms to finish bounce
   * @param {object} [options.bounceBox] - use this bounceBox instead of (0, 0, viewport.worldWidth, viewport.worldHeight)
   * @param {number} [options.bounceBox.x=0]
   * @param {number} [options.bounceBox.y=0]
   * @param {number} [options.bounceBox.width=viewport.worldWidth]
   * @param {number} [options.bounceBox.height=viewport.worldHeight]
   * @param {string|function} [options.ease=easeInOutSine] - ease function or name
   *  (see http://easings.net/ for supported names)
   * @param {string} [options.underflow=center] - (top/bottom/center and left/right/center, or center)
   *  where to place world if too small for screen
   * @return {Viewport} this
   */
  bounce(t2) {
    return this.plugins.add("bounce", new k2(this, t2)), this;
  }
  /**
   * Enable pinch to zoom and two-finger touch to drag
   *
   * @param {PinchOptions} [options]
   * @param {boolean} [options.noDrag] - disable two-finger dragging
   * @param {number} [options.percent=1] - percent to modify pinch speed
   * @param {number} [options.factor=1] - factor to multiply two-finger drag to increase the speed of movement
   * @param {PIXI.Point} [options.center] - place this point at center during zoom instead of center of two fingers
   * @param {('all'|'x'|'y')} [options.axis=all] - axis to zoom
   * @return {Viewport} this
   */
  pinch(t2) {
    return this.plugins.add("pinch", new N2(this, t2)), this;
  }
  /**
   * Snap to a point
   *
   * @param {number} x
   * @param {number} y
   * @param {ISnapOptions} [options]
   * @param {boolean} [options.topLeft] - snap to the top-left of viewport instead of center
   * @param {number} [options.friction=0.8] - friction/frame to apply if decelerate is active
   * @param {number} [options.time=1000] - time in ms to snap
   * @param {string|function} [options.ease=easeInOutSine] - ease function or name (see http://easings.net/
   *   for supported names)
   * @param {boolean} [options.interrupt=true] - pause snapping with any user input on the viewport
   * @param {boolean} [options.removeOnComplete] - removes this plugin after snapping is complete
   * @param {boolean} [options.removeOnInterrupt] - removes this plugin if interrupted by any user input
   * @param {boolean} [options.forceStart] - starts the snap immediately regardless of whether the viewport is at
   *   the desired location
   * @return {Viewport} this
   */
  snap(t2, e3, n2) {
    return this.plugins.add("snap", new j2(this, t2, e3, n2)), this;
  }
  /**
   * Follow a target
   *
   * NOTES:
   *    uses the (x, y) as the center to follow; for PIXI.Sprite to work properly, use sprite.anchor.set(0.5)
   *    options.acceleration is not perfect as it doesn't know the velocity of the target. It adds acceleration
   *    to the start of movement and deceleration to the end of movement when the target is stopped.
   *    To cancel the follow, use: `viewport.plugins.remove('follow')`
   *
   * @fires 'moved' event
   *
   * @param {PIXI.DisplayObject} target to follow
   * @param {IFollowOptions} [options]
   * @param {number} [options.speed=0] - to follow in pixels/frame (0=teleport to location)
   * @param {number} [options.acceleration] - set acceleration to accelerate and decelerate at this rate; speed
   *   cannot be 0 to use acceleration
   * @param {number} [options.radius] - radius (in world coordinates) of center circle where movement is allowed
   *   without moving the viewport     * @returns {Viewport} this
   * @returns {Viewport} this
   */
  follow(t2, e3) {
    return this.plugins.add("follow", new U(this, t2, e3)), this;
  }
  /**
   * Zoom using mouse wheel
   *
   * NOTE: the default event listener for 'wheel' event is the options.events.domElement.
   *
   * @param {IWheelOptions} [options]
   * @param {number} [options.percent=0.1] - percent to scroll with each spin
   * @param {number} [options.smooth] - smooth the zooming by providing the number of frames to zoom between wheel spins
   * @param {boolean} [options.interrupt=true] - stop smoothing with any user input on the viewport
   * @param {boolean} [options.reverse] - reverse the direction of the scroll
   * @param {PIXI.Point} [options.center] - place this point at center during zoom instead of current mouse position
   * @param {number} [options.lineHeight=20] - scaling factor for non-DOM_DELTA_PIXEL scrolling events
   * @param {('all'|'x'|'y')} [options.axis=all] - axis to zoom
   * @return {Viewport} this
   */
  wheel(t2) {
    return this.plugins.add("wheel", new G(this, t2)), this;
  }
  /**
   * Animate the position and/or scale of the viewport
   * To set the zoom level, use: (1) scale, (2) scaleX and scaleY, or (3) width and/or height
   * @param {object} options
   * @param {number} [options.time=1000] - time to animate
   * @param {PIXI.Point} [options.position=viewport.center] - position to move viewport
   * @param {number} [options.width] - desired viewport width in world pixels (use instead of scale;
   *  aspect ratio is maintained if height is not provided)
   * @param {number} [options.height] - desired viewport height in world pixels (use instead of scale;
   *  aspect ratio is maintained if width is not provided)
   * @param {number} [options.scale] - scale to change zoom (scale.x = scale.y)
   * @param {number} [options.scaleX] - independently change zoom in x-direction
   * @param {number} [options.scaleY] - independently change zoom in y-direction
   * @param {(function|string)} [options.ease=linear] - easing function to use
   * @param {function} [options.callbackOnComplete]
   * @param {boolean} [options.removeOnInterrupt] removes this plugin if interrupted by any user input
   * @returns {Viewport} this
   */
  animate(t2) {
    return this.plugins.add("animate", new C(this, t2)), this;
  }
  /**
   * Enable clamping of zoom to constraints
   *
   * The minWidth/Height settings are how small the world can get (as it would appear on the screen)
   * before clamping. The maxWidth/maxHeight is how larger the world can scale (as it would appear on
   * the screen) before clamping.
   *
   * For example, if you have a world size of 1000 x 1000 and a screen size of 100 x 100, if you set
   * minWidth/Height = 100 then the world will not be able to zoom smaller than the screen size (ie,
   * zooming out so it appears smaller than the screen). Similarly, if you set maxWidth/Height = 100
   * the world will not be able to zoom larger than the screen size (ie, zooming in so it appears
   * larger than the screen).
   *
   * @param {object} [options]
   * @param {number} [options.minWidth] - minimum width
   * @param {number} [options.minHeight] - minimum height
   * @param {number} [options.maxWidth] - maximum width
   * @param {number} [options.maxHeight] - maximum height
   * @param {number} [options.minScale] - minimum scale
   * @param {number} [options.maxScale] - minimum scale
   * @return {Viewport} this
   */
  clampZoom(t2) {
    return this.plugins.add("clamp-zoom", new A(this, t2)), this;
  }
  /**
   * Scroll viewport when mouse hovers near one of the edges or radius-distance from center of screen.
   *
   * NOTES: fires 'moved' event; there's a known bug where the mouseEdges does not work properly with "windowed" viewports
   *
   * @param {IMouseEdgesOptions} [options]
   * @param {number} [options.radius] - distance from center of screen in screen pixels
   * @param {number} [options.distance] - distance from all sides in screen pixels
   * @param {number} [options.top] - alternatively, set top distance (leave unset for no top scroll)
   * @param {number} [options.bottom] - alternatively, set bottom distance (leave unset for no top scroll)
   * @param {number} [options.left] - alternatively, set left distance (leave unset for no top scroll)
   * @param {number} [options.right] - alternatively, set right distance (leave unset for no top scroll)
   * @param {number} [options.speed=8] - speed in pixels/frame to scroll viewport
   * @param {boolean} [options.reverse] - reverse direction of scroll
   * @param {boolean} [options.noDecelerate] - don't use decelerate plugin even if it's installed
   * @param {boolean} [options.linear] - if using radius, use linear movement (+/- 1, +/- 1) instead of angled
   *   movement (Math.cos(angle from center), Math.sin(angle from center))
   * @param {boolean} [options.allowButtons] allows plugin to continue working even when there's a mousedown event
   */
  mouseEdges(t2) {
    return this.plugins.add("mouse-edges", new B(this, t2)), this;
  }
  /** Pause viewport (including animation updates such as decelerate) */
  get pause() {
    return !!this._pause;
  }
  set pause(t2) {
    this._pause = t2, this.lastViewport = null, this.moving = false, this.zooming = false, t2 && this.input.pause();
  }
  /**
   * Move the viewport so the bounding box is visible
   *
   * @param x - left
   * @param y - top
   * @param width
   * @param height
   * @param resizeToFit - Resize the viewport so the box fits within the viewport
   */
  ensureVisible(t2, e3, n2, i3, s2) {
    s2 && (n2 > this.worldScreenWidth || i3 > this.worldScreenHeight) && (this.fit(true, n2, i3), this.emit("zoomed", { viewport: this, type: "ensureVisible" }));
    let h2 = false;
    t2 < this.left ? (this.left = t2, h2 = true) : t2 + n2 > this.right && (this.right = t2 + n2, h2 = true), e3 < this.top ? (this.top = e3, h2 = true) : e3 + i3 > this.bottom && (this.bottom = e3 + i3, h2 = true), h2 && this.emit("moved", { viewport: this, type: "ensureVisible" });
  }
};

// ../../node_modules/.pnpm/pixi-cull@2.2.0_pixi.js@8.0.0-beta.3/node_modules/pixi-cull/dist/pixi-cull.es.js
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
      s2 = arguments[i3];
      for (var p3 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p3))
          t2[p3] = s2[p3];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var defaultSimpleOptions = {
  visible: "visible",
  dirtyTest: false
};
var Simple = (
  /** @class */
  function() {
    function Simple2(options) {
      if (options === void 0) {
        options = {};
      }
      options = __assign(__assign({}, defaultSimpleOptions), options);
      this.dirtyTest = typeof options.dirtyTest !== "undefined" ? options.dirtyTest : true;
      this.lists = [[]];
    }
    Simple2.prototype.addList = function(array, staticObject) {
      this.lists.push(array);
      if (staticObject) {
        array.staticObject = true;
      }
      var length = array.length;
      for (var i3 = 0; i3 < length; i3++) {
        this.updateObject(array[i3]);
      }
      return array;
    };
    Simple2.prototype.removeList = function(array) {
      var index = this.lists.indexOf(array);
      if (index === -1) {
        return array;
      }
      this.lists.splice(index, 1);
      return array;
    };
    Simple2.prototype.add = function(object, staticObject) {
      if (staticObject) {
        object.staticObject = true;
      }
      if (this.dirtyTest || staticObject) {
        this.updateObject(object);
      }
      this.lists[0].push(object);
      return object;
    };
    Simple2.prototype.remove = function(object) {
      var index = this.lists[0].indexOf(object);
      if (index === -1) {
        return object;
      }
      this.lists[0].splice(index, 1);
      return object;
    };
    Simple2.prototype.cull = function(bounds, skipUpdate) {
      if (!skipUpdate) {
        this.updateObjects();
      }
      for (var _i = 0, _a2 = this.lists; _i < _a2.length; _i++) {
        var list = _a2[_i];
        var length_1 = list.length;
        for (var i3 = 0; i3 < length_1; i3++) {
          var object = list[i3];
          var box = object.AABB;
          object.visible = box.x + box.width > bounds.x && box.x < bounds.x + bounds.width && box.y + box.height > bounds.y && box.y < bounds.y + bounds.height;
        }
      }
    };
    Simple2.prototype.updateObjects = function() {
      if (this.dirtyTest) {
        for (var _i = 0, _a2 = this.lists; _i < _a2.length; _i++) {
          var list = _a2[_i];
          if (!list.staticObject) {
            var length_2 = list.length;
            for (var i3 = 0; i3 < length_2; i3++) {
              var object = list[i3];
              if (!object.staticObject && object.dirty) {
                this.updateObject(object);
                object.dirty = false;
              }
            }
          }
        }
      } else {
        for (var _b = 0, _c = this.lists; _b < _c.length; _b++) {
          var list = _c[_b];
          if (!list.staticObject) {
            var length_3 = list.length;
            for (var i3 = 0; i3 < length_3; i3++) {
              var object = list[i3];
              if (!object.staticObject) {
                this.updateObject(object);
              }
            }
          }
        }
      }
    };
    Simple2.prototype.updateObject = function(object) {
      var box = object.getLocalBounds();
      object.AABB = object.AABB || { x: 0, y: 0, width: 0, height: 0 };
      object.AABB.x = object.x + (box.x - object.pivot.x) * Math.abs(object.scale.x);
      object.AABB.y = object.y + (box.y - object.pivot.y) * Math.abs(object.scale.y);
      object.AABB.width = box.width * Math.abs(object.scale.x);
      object.AABB.height = box.height * Math.abs(object.scale.y);
    };
    Simple2.prototype.query = function(bounds) {
      var results = [];
      for (var _i = 0, _a2 = this.lists; _i < _a2.length; _i++) {
        var list = _a2[_i];
        for (var _b = 0, list_1 = list; _b < list_1.length; _b++) {
          var object = list_1[_b];
          var box = object.AABB;
          if (box && box.x + box.width > bounds.x && box.x - box.width < bounds.x + bounds.width && box.y + box.height > bounds.y && box.y - box.height < bounds.y + bounds.height) {
            results.push(object);
          }
        }
      }
      return results;
    };
    Simple2.prototype.queryCallback = function(bounds, callback) {
      for (var _i = 0, _a2 = this.lists; _i < _a2.length; _i++) {
        var list = _a2[_i];
        for (var _b = 0, list_2 = list; _b < list_2.length; _b++) {
          var object = list_2[_b];
          var box = object.AABB;
          if (box && box.x + box.width > bounds.x && box.x - box.width < bounds.x + bounds.width && box.y + box.height > bounds.y && box.y - box.height < bounds.y + bounds.height) {
            if (callback(object)) {
              return true;
            }
          }
        }
      }
      return false;
    };
    Simple2.prototype.stats = function() {
      var visible = 0, count2 = 0;
      for (var _i = 0, _a2 = this.lists; _i < _a2.length; _i++) {
        var list = _a2[_i];
        list.forEach(function(object) {
          visible += object.visible ? 1 : 0;
          count2++;
        });
      }
      return { total: count2, visible, culled: count2 - visible };
    };
    return Simple2;
  }()
);
var SpatialHashDefaultOptions = {
  xSize: 1e3,
  ySize: 1e3,
  simpleTest: true,
  dirtyTest: true
};
var SpatialHash = (
  /** @class */
  function() {
    function SpatialHash3(options) {
      this.xSize = 1e3;
      this.ySize = 1e3;
      this.simpleTest = true;
      this.dirtyTest = true;
      options = __assign(__assign({}, SpatialHashDefaultOptions), options);
      if (options && typeof options.size !== "undefined") {
        this.xSize = this.ySize = options.size;
      } else {
        this.xSize = options.xSize;
        this.ySize = options.ySize;
      }
      this.simpleTest = options.simpleTest;
      this.dirtyTest = options.dirtyTest;
      this.width = this.height = 0;
      this.hash = {};
      this.containers = [];
      this.elements = [];
    }
    SpatialHash3.prototype.add = function(object, staticObject) {
      object.spatial = { hashes: [] };
      if (this.dirtyTest) {
        object.dirty = true;
      }
      if (staticObject) {
        object.staticObject = true;
      }
      this.updateObject(object);
      this.elements.push(object);
      return object;
    };
    SpatialHash3.prototype.remove = function(object) {
      this.elements.splice(this.elements.indexOf(object), 1);
      this.removeFromHash(object);
      return object;
    };
    SpatialHash3.prototype.addContainer = function(container, staticObject) {
      var _this = this;
      var added = function(object2) {
        object2.spatial = { hashes: [] };
        _this.updateObject(object2);
      };
      var removed = function(object2) {
        _this.removeFromHash(object2);
      };
      var length = container.children.length;
      for (var i3 = 0; i3 < length; i3++) {
        var object = container.children[i3];
        object.spatial = { hashes: [] };
        this.updateObject(object);
      }
      container.cull = {};
      this.containers.push(container);
      container.on("childAdded", added);
      container.on("childRemoved", removed);
      container.cull.added = added;
      container.cull.removed = removed;
      if (staticObject) {
        container.cull.static = true;
      }
    };
    SpatialHash3.prototype.removeContainer = function(container) {
      var _this = this;
      this.containers.splice(this.containers.indexOf(container), 1);
      container.children.forEach(function(object) {
        return _this.removeFromHash(object);
      });
      container.off("childAdded", container.cull.added);
      container.off("removedFrom", container.cull.removed);
      delete container.cull;
      return container;
    };
    SpatialHash3.prototype.cull = function(AABB, skipUpdate, callback) {
      if (!skipUpdate) {
        this.updateObjects();
      }
      this.invisible();
      var objects;
      if (callback) {
        objects = this.queryCallbackAll(AABB, this.simpleTest, callback);
      } else {
        objects = this.query(AABB, this.simpleTest);
      }
      objects.forEach(function(object) {
        return object.visible = true;
      });
      return this.lastBuckets;
    };
    SpatialHash3.prototype.invisible = function() {
      var length = this.elements.length;
      for (var i3 = 0; i3 < length; i3++) {
        this.elements[i3].visible = false;
      }
      for (var _i = 0, _a2 = this.containers; _i < _a2.length; _i++) {
        var container = _a2[_i];
        var length_1 = container.children.length;
        for (var i3 = 0; i3 < length_1; i3++) {
          container.children[i3].visible = false;
        }
      }
    };
    SpatialHash3.prototype.updateObjects = function() {
      if (this.dirtyTest) {
        var length_2 = this.elements.length;
        for (var i3 = 0; i3 < length_2; i3++) {
          var object = this.elements[i3];
          if (object.dirty) {
            this.updateObject(object);
            object.dirty = false;
          }
        }
        for (var _i = 0, _a2 = this.containers; _i < _a2.length; _i++) {
          var container = _a2[_i];
          if (!container.cull.static) {
            var length_3 = container.children.length;
            for (var i3 = 0; i3 < length_3; i3++) {
              var object = container.children[i3];
              if (object.dirty) {
                this.updateObject(object);
                object.dirty = false;
              }
            }
          }
        }
      } else {
        var length_4 = this.elements.length;
        for (var i3 = 0; i3 < length_4; i3++) {
          var object = this.elements[i3];
          if (!object.staticObject) {
            this.updateObject(object);
          }
        }
        for (var _b = 0, _c = this.containers; _b < _c.length; _b++) {
          var container = _c[_b];
          if (!container.cull.static) {
            var length_5 = container.children.length;
            for (var i3 = 0; i3 < length_5; i3++) {
              this.updateObject(container.children[i3]);
            }
          }
        }
      }
    };
    SpatialHash3.prototype.updateObject = function(object) {
      var AABB;
      var box = object.getLocalBounds();
      AABB = object.AABB = {
        x: object.x + (box.x - object.pivot.x) * object.scale.x,
        y: object.y + (box.y - object.pivot.y) * object.scale.y,
        width: box.width * object.scale.x,
        height: box.height * object.scale.y
      };
      var spatial = object.spatial;
      if (!spatial) {
        spatial = object.spatial = { hashes: [] };
      }
      var _a2 = this.getBounds(AABB), xStart = _a2.xStart, yStart = _a2.yStart, xEnd = _a2.xEnd, yEnd = _a2.yEnd;
      if (spatial.xStart !== xStart || spatial.yStart !== yStart || spatial.xEnd !== xEnd || spatial.yEnd !== yEnd) {
        if (spatial.hashes.length) {
          this.removeFromHash(object);
        }
        for (var y2 = yStart; y2 <= yEnd; y2++) {
          for (var x3 = xStart; x3 <= xEnd; x3++) {
            var key2 = x3 + "," + y2;
            this.insert(object, key2);
            spatial.hashes.push(key2);
          }
        }
        spatial.xStart = xStart;
        spatial.yStart = yStart;
        spatial.xEnd = xEnd;
        spatial.yEnd = yEnd;
      }
    };
    SpatialHash3.prototype.getBuckets = function(minimum) {
      if (minimum === void 0) {
        minimum = 1;
      }
      var hashes = [];
      for (var key2 in this.hash) {
        var hash = this.hash[key2];
        if (hash.length >= minimum) {
          hashes.push(hash);
        }
      }
      return hashes;
    };
    SpatialHash3.prototype.getBounds = function(AABB) {
      var xStart = Math.floor(AABB.x / this.xSize);
      var yStart = Math.floor(AABB.y / this.ySize);
      var xEnd = Math.floor((AABB.x + AABB.width) / this.xSize);
      var yEnd = Math.floor((AABB.y + AABB.height) / this.ySize);
      return { xStart, yStart, xEnd, yEnd };
    };
    SpatialHash3.prototype.insert = function(object, key2) {
      if (!this.hash[key2]) {
        this.hash[key2] = [object];
      } else {
        this.hash[key2].push(object);
      }
    };
    SpatialHash3.prototype.removeFromHash = function(object) {
      var spatial = object.spatial;
      while (spatial.hashes.length) {
        var key2 = spatial.hashes.pop();
        var list = this.hash[key2];
        list.splice(list.indexOf(object), 1);
      }
    };
    SpatialHash3.prototype.neighbors = function(object) {
      var _this = this;
      var results = [];
      object.spatial.hashes.forEach(function(key2) {
        return results = results.concat(_this.hash[key2]);
      });
      return results;
    };
    SpatialHash3.prototype.query = function(AABB, simpleTest) {
      if (simpleTest === void 0) {
        simpleTest = true;
      }
      var buckets = 0;
      var results = [];
      var _a2 = this.getBounds(AABB), xStart = _a2.xStart, yStart = _a2.yStart, xEnd = _a2.xEnd, yEnd = _a2.yEnd;
      for (var y2 = yStart; y2 <= yEnd; y2++) {
        for (var x3 = xStart; x3 <= xEnd; x3++) {
          var entry = this.hash[x3 + "," + y2];
          if (entry) {
            if (simpleTest) {
              var length_6 = entry.length;
              for (var i3 = 0; i3 < length_6; i3++) {
                var object = entry[i3];
                var box = object.AABB;
                if (box.x + box.width > AABB.x && box.x < AABB.x + AABB.width && box.y + box.height > AABB.y && box.y < AABB.y + AABB.height) {
                  results.push(object);
                }
              }
            } else {
              results = results.concat(entry);
            }
            buckets++;
          }
        }
      }
      this.lastBuckets = buckets;
      return results;
    };
    SpatialHash3.prototype.queryCallbackAll = function(AABB, simpleTest, callback) {
      if (simpleTest === void 0) {
        simpleTest = true;
      }
      var buckets = 0;
      var results = [];
      var _a2 = this.getBounds(AABB), xStart = _a2.xStart, yStart = _a2.yStart, xEnd = _a2.xEnd, yEnd = _a2.yEnd;
      for (var y2 = yStart; y2 <= yEnd; y2++) {
        for (var x3 = xStart; x3 <= xEnd; x3++) {
          var entry = this.hash[x3 + "," + y2];
          if (entry) {
            if (simpleTest) {
              var length_7 = entry.length;
              for (var i3 = 0; i3 < length_7; i3++) {
                var object = entry[i3];
                var box = object.AABB;
                if (box.x + box.width > AABB.x && box.x < AABB.x + AABB.width && box.y + box.height > AABB.y && box.y < AABB.y + AABB.height) {
                  results.push(object);
                  callback(object);
                }
              }
            } else {
              results = results.concat(entry);
              for (var _i = 0, entry_1 = entry; _i < entry_1.length; _i++) {
                var object = entry_1[_i];
                callback(object);
              }
            }
            buckets++;
          }
        }
      }
      this.lastBuckets = buckets;
      return results;
    };
    SpatialHash3.prototype.queryCallback = function(AABB, callback, simpleTest) {
      if (simpleTest === void 0) {
        simpleTest = true;
      }
      var _a2 = this.getBounds(AABB), xStart = _a2.xStart, yStart = _a2.yStart, xEnd = _a2.xEnd, yEnd = _a2.yEnd;
      for (var y2 = yStart; y2 <= yEnd; y2++) {
        for (var x3 = xStart; x3 <= xEnd; x3++) {
          var entry = this.hash[x3 + "," + y2];
          if (entry) {
            for (var i3 = 0; i3 < entry.length; i3++) {
              var object = entry[i3];
              if (simpleTest) {
                var AABB_1 = object.AABB;
                if (AABB_1.x + AABB_1.width > AABB_1.x && AABB_1.x < AABB_1.x + AABB_1.width && AABB_1.y + AABB_1.height > AABB_1.y && AABB_1.y < AABB_1.y + AABB_1.height) {
                  if (callback(object)) {
                    return true;
                  }
                }
              } else {
                if (callback(object)) {
                  return true;
                }
              }
            }
          }
        }
      }
      return false;
    };
    SpatialHash3.prototype.stats = function() {
      var visible = 0, count2 = 0;
      var length = this.elements.length;
      for (var i3 = 0; i3 < length; i3++) {
        var object = this.elements[i3];
        visible += object.visible ? 1 : 0;
        count2++;
      }
      for (var _i = 0, _a2 = this.containers; _i < _a2.length; _i++) {
        var list = _a2[_i];
        var length_8 = list.children.length;
        for (var i3 = 0; i3 < length_8; i3++) {
          var object = list.children[i3];
          visible += object.visible ? 1 : 0;
          count2++;
        }
      }
      return {
        buckets: this.lastBuckets,
        total: count2,
        visible,
        culled: count2 - visible
      };
    };
    SpatialHash3.prototype.getNumberOfBuckets = function() {
      return Object.keys(this.hash).length;
    };
    SpatialHash3.prototype.getAverageSize = function() {
      var total = 0;
      for (var key2 in this.hash) {
        total += this.hash[key2].length;
      }
      return total / this.getBuckets().length;
    };
    SpatialHash3.prototype.getLargest = function() {
      var largest = 0;
      for (var key2 in this.hash) {
        if (this.hash[key2].length > largest) {
          largest = this.hash[key2].length;
        }
      }
      return largest;
    };
    SpatialHash3.prototype.getWorldBounds = function() {
      var xStart = Infinity, yStart = Infinity, xEnd = 0, yEnd = 0;
      for (var key2 in this.hash) {
        var split = key2.split(",");
        var x3 = parseInt(split[0]);
        var y2 = parseInt(split[1]);
        xStart = x3 < xStart ? x3 : xStart;
        yStart = y2 < yStart ? y2 : yStart;
        xEnd = x3 > xEnd ? x3 : xEnd;
        yEnd = y2 > yEnd ? y2 : yEnd;
      }
      return { xStart, yStart, xEnd, yEnd };
    };
    SpatialHash3.prototype.getSparseness = function(AABB) {
      var count2 = 0, total = 0;
      var _a2 = AABB ? this.getBounds(AABB) : this.getWorldBounds(), xStart = _a2.xStart, yStart = _a2.yStart, xEnd = _a2.xEnd, yEnd = _a2.yEnd;
      for (var y2 = yStart; y2 < yEnd; y2++) {
        for (var x3 = xStart; x3 < xEnd; x3++) {
          count2 += this.hash[x3 + "," + y2] ? 1 : 0;
          total++;
        }
      }
      return count2 / total;
    };
    return SpatialHash3;
  }()
);

// src/frontend/game/Flex.ts
var import_yoga_layout_prebuilt = __toESM(require_entry_browser());
var Flex = class {
  constructor(displayObject) {
    this.displayObject = displayObject;
    this.node = import_yoga_layout_prebuilt.Node.create();
  }
  node;
  children = [];
  updateLayout() {
    this.node.calculateLayout();
    this.updateDisplayObject();
  }
  updateDisplayObject() {
    const computedLayout = this.node.getComputedLayout();
    console.log(computedLayout);
    this.displayObject.height = computedLayout.height;
    this.displayObject.width = computedLayout.width;
    this.displayObject.x = computedLayout.left;
    this.displayObject.y = computedLayout.top;
    this.children.forEach((child) => {
      child.updateDisplayObject();
    });
  }
  removeChildren() {
    const count2 = this.node.getChildCount();
    const removeList = [];
    for (let i3 = 0; i3 < count2; i3++) {
      removeList.push(this.node.getChild(i3));
    }
    removeList.forEach((child) => {
      this.node.removeChild(child);
    });
    this.displayObject.removeChildren();
    this.children = [];
  }
  addChild(child) {
    this.node.insertChild(child.node, this.node.getChildCount());
    this.displayObject.addChild(child.displayObject);
    this.children.push(child);
  }
  set height(value) {
    if (typeof value === "string") {
      this.node.setHeightPercent(parseInt(value.substring(0, value.length - 1)));
    } else {
      this.node.setHeight(value);
    }
  }
  set position(value) {
    this.node.setPositionType(value);
  }
  set minHeight(value) {
    if (typeof value === "string") {
      this.node.setMinHeightPercent(parseInt(value.substring(0, value.length - 1)));
    } else {
      this.node.setMinHeight(value);
    }
  }
  set maxHeight(value) {
    if (typeof value === "string") {
      this.node.setMaxHeightPercent(parseInt(value.substring(0, value.length - 1)));
    } else {
      this.node.setMaxHeight(value);
    }
  }
  set minWidth(value) {
    if (typeof value === "string") {
      this.node.setMinWidthPercent(parseInt(value.substring(0, value.length - 1)));
    } else {
      this.node.setMinWidth(value);
    }
  }
  set maxWidth(value) {
    if (typeof value === "string") {
      this.node.setMaxWidthPercent(parseInt(value.substring(0, value.length - 1)));
    } else {
      this.node.setMaxWidth(value);
    }
  }
  set flex(value) {
    this.node.setFlex(value);
  }
  set wrap(value) {
    this.node.setFlexWrap(value);
  }
  set gap(value) {
  }
  set padding(value) {
    this.node.setPadding(8 /* ALL */, value);
  }
  set margin(value) {
    this.node.setMargin(8 /* ALL */, value);
  }
  set marginVertical(value) {
    this.node.setMargin(7 /* VERTICAL */, value);
  }
  set marginHorizontal(value) {
    this.node.setMargin(6 /* HORIZONTAL */, value);
  }
  set marginBottom(value) {
    this.node.setMargin(3 /* BOTTOM */, value);
  }
  set paddingHorizontal(value) {
    this.node.setPadding(6 /* HORIZONTAL */, value);
  }
  set paddingVertical(value) {
    this.node.setPadding(7 /* VERTICAL */, value);
  }
  set width(value) {
    if (typeof value === "string") {
      this.node.setWidthPercent(parseInt(value.substring(0, value.length - 1)));
    } else {
      this.node.setWidth(value);
    }
  }
  set justifyContent(value) {
    this.node.setJustifyContent(value);
  }
  set alignItems(value) {
    this.node.setAlignItems(value);
  }
  set alignContent(value) {
    this.node.setAlignContent(value);
  }
  set flexDirection(value) {
    this.node.setFlexDirection(value);
  }
};

// src/frontend/game/base-elements/centered-bitmap-text.ts
var CenteredBitmapText = class extends Container {
  constructor(name, properties) {
    super();
    this.properties = properties;
    this.bitmapText = new BitmapText2(name, properties.font);
    this.bounds = this.bitmapText.getBounds();
    this.addChild(this.bitmapText);
  }
  bitmapText;
  bounds;
  set width(value) {
    if (this.properties.align === "left") {
      this.bitmapText.x = 8;
    } else if (this.properties.align === "right") {
      this.bitmapText.x = value - this.bounds.width - 8;
    } else {
      this.bitmapText.x = (value - this.bounds.width) / 2;
    }
  }
  set height(value) {
    this.bitmapText.y = (value - this.bounds.height) / 2;
  }
};

// src/frontend/game/ui-elements/text.ts
var Text2 = class extends Flex {
  constructor(text, properties) {
    super(new CenteredBitmapText(text, properties));
  }
};

// src/frontend/game/ui-elements/container.ts
var Container5 = class extends Flex {
  constructor(properties) {
    let innerComponent;
    if (properties?.variant === "custom") {
      innerComponent = new NineSliceSprite({
        texture: properties.texture,
        leftWidth: properties.xBand ?? 10,
        topHeight: properties.yBand ?? 10,
        rightWidth: properties.xBand ?? 10,
        bottomHeight: properties.yBand ?? 10
      });
    } else {
      innerComponent = new NineSliceSprite({
        texture: properties?.variant === "invisible" ? loadedAssets.panelInvisible : loadedAssets.panel2
      });
    }
    super(innerComponent);
  }
};

// src/frontend/game/MarketWindow.ts
var MarketWindow = class {
  container;
  flexColumns;
  nextColumn = 0;
  constructor() {
    this.container = new Container5();
    this.container.width = gameWidth - 400;
    this.container.height = 300;
    const names = ["IMPORT", "EXPORT", "EXCHANGE"];
    const columnHeaders = new Container5();
    columnHeaders.width = "100%";
    columnHeaders.height = 30;
    columnHeaders.flexDirection = 2 /* ROW */;
    names.forEach((name) => {
      const columnHead = new Text2(name, { align: "center", font: {
        fontName: "buttontext_white",
        fontSize: 12
      } });
      columnHead.flex = 1;
      columnHeaders.addChild(columnHead);
    });
    this.container.addChild(columnHeaders);
    const dataColumns = new Container5();
    dataColumns.flex = 1;
    dataColumns.flexDirection = 2 /* ROW */;
    this.flexColumns = {
      IMPORT: new Container5(),
      EXPORT: new Container5(),
      EXCHANGE: new Container5()
    };
    names.forEach((name) => {
      this.flexColumns[name].flex = 1;
      this.flexColumns[name].flexDirection = 0 /* COLUMN */;
      dataColumns.addChild(this.flexColumns[name]);
    });
    this.container.addChild(dataColumns);
  }
  setGoods(goods) {
    goods.forEach((ship) => {
      this.addGood(ship);
    });
    this.container.updateLayout();
  }
  clearGoods() {
    this.nextColumn = 0;
    this.flexColumns.IMPORT.removeChildren();
    this.flexColumns.EXPORT.removeChildren();
    this.flexColumns.EXCHANGE.removeChildren();
  }
  addGood(good) {
    const flexRow = new Container5();
    flexRow.displayObject.tint = good.kind === "EXPORT" ? 65280 : good.kind === "IMPORT" ? 16711680 : 16777215;
    flexRow.flexDirection = 2 /* ROW */;
    flexRow.height = 30;
    flexRow.width = "100%";
    const fontStyle = {
      fontName: "buttontext_white",
      fontSize: 12
    };
    const firstText = new Text2(good.tradeGoodSymbol, { align: "left", font: fontStyle });
    firstText.flex = 1;
    firstText.width = "25%";
    flexRow.addChild(firstText);
    const fourText = new Text2(good.kind.toString(), { align: "left", font: fontStyle });
    fourText.width = "15%";
    flexRow.addChild(fourText);
    const sixText = new Text2(good.supply.toString(), { align: "left", font: fontStyle });
    sixText.width = "15%";
    flexRow.addChild(sixText);
    const fiveText = new Text2(good.tradeVolume.toString(), { align: "left", font: fontStyle });
    fiveText.width = "15%";
    flexRow.addChild(fiveText);
    const secondText = new Text2(good.purchasePrice.toString() + " P", { align: "right", font: fontStyle });
    secondText.width = "15%";
    flexRow.addChild(secondText);
    const thirdText = new Text2(good.sellPrice.toString() + " S", { align: "right", font: fontStyle });
    thirdText.width = "15%";
    flexRow.addChild(thirdText);
    const columns = ["IMPORT", "EXPORT", "EXCHANGE"];
    this.flexColumns[columns[this.nextColumn]].addChild(flexRow);
    this.nextColumn++;
    if (this.nextColumn >= columns.length)
      this.nextColumn = 0;
  }
};

// src/frontend/game/ui-elements/button.ts
var Button = class extends Flex {
  constructor(text, properties, clickAction) {
    super(new BaseButton(text, properties, clickAction));
    this.clickAction = clickAction;
  }
  set disabled(value) {
    this.displayObject.disabled = value;
  }
};

// src/frontend/game/switch.ts
var Switch = class extends Container5 {
  constructor(options, dimensions, clickAction) {
    super({
      variant: "invisible"
    });
    this.clickAction = clickAction;
    this.width = "100%";
    this.height = 41;
    this.flexDirection = 2 /* ROW */;
    this.selectedValue = dimensions.defaultSelected;
    options.forEach((option, index) => {
      this.optionSprites[option] = new Container5({
        variant: "custom",
        texture: option === this.selectedValue ? loadedAssets.select : loadedAssets.selectInactive,
        xBand: 15,
        yBand: 5
      });
      this.optionSprites[option].displayObject.interactive = true;
      this.optionSprites[option].flex = 1;
      this.addChild(this.optionSprites[option]);
      this.optionSprites[option].displayObject.cursor = "pointer";
      this.optionSprites[option].displayObject.on("mouseover", () => {
        this.optionSprites[option].displayObject.texture = loadedAssets.select;
      });
      this.optionSprites[option].displayObject.on("mouseout", () => {
        if (this.selectedValue !== option) {
          this.optionSprites[option].displayObject.texture = loadedAssets.selectInactive;
        }
      });
      this.optionSprites[option].displayObject.on("click", (event) => {
        event.stopPropagation();
        this.switchHighlight(option);
        if (this.clickAction) {
          this.clickAction(event, option);
        }
      });
      const textSize = dimensions.textSize ?? 20;
      const text = new Text2(option, {
        font: {
          fontName: "buttontext_white",
          fontSize: textSize,
          tint: 16777215
        },
        align: "center"
      });
      text.flex = 1;
      this.optionSprites[option].addChild(text);
    });
  }
  optionSprites = {};
  selectedValue;
  switchHighlight(value) {
    if (this.selectedValue) {
      this.optionSprites[this.selectedValue].displayObject.texture = loadedAssets.selectInactive;
    }
    this.selectedValue = value;
    this.optionSprites[this.selectedValue].displayObject.texture = loadedAssets.select;
  }
  setSelectedValue(value) {
    this.switchHighlight(value);
  }
};

// src/frontend/game/BehaviorWindow.ts
var BehaviorWindow = class {
  container;
  selectedRange = 1500;
  homeSystem = "";
  switchRange;
  homeSystemText;
  constructor() {
    this.container = new Container5();
    this.container.width = gameWidth - 400;
    this.container.height = 600;
    this.container.flexDirection = 0 /* COLUMN */;
    this.container.padding = 10;
    this.container.updateLayout();
  }
  setHome(homeSystem) {
    this.homeSystem = homeSystem;
    this.homeSystemText.displayObject.bitmapText.text = `Home: ${homeSystem}`;
  }
  setBehaviors(behaviors) {
    const header = new Container5();
    header.width = "100%";
    header.height = 140;
    header.flexDirection = 0 /* COLUMN */;
    this.container.addChild(header);
    this.homeSystemText = new Text2("Home", {
      align: "left",
      font: {
        fontName: "buttontext_white",
        fontSize: 24
      }
    });
    this.homeSystemText.marginVertical = 10;
    this.homeSystemText.width = "100%";
    this.homeSystemText.height = 30;
    this.homeSystemText.paddingVertical = 6;
    header.addChild(this.homeSystemText);
    const headerText = new Text2("Range", {
      align: "left",
      font: {
        fontName: "buttontext_white",
        fontSize: 16
      }
    });
    headerText.width = "100%";
    headerText.height = 20;
    header.addChild(headerText);
    this.switchRange = new Switch(["1500", "2500", "3500", "5000"], {
      width: 100,
      defaultSelected: "1500"
    }, (event, value) => {
      this.selectedRange = parseInt(value);
    });
    header.addChild(this.switchRange);
    const behaviorsContainer = new Container5();
    behaviorsContainer.flex = 1;
    this.container.addChild(behaviorsContainer);
    behaviors.forEach((behavior) => {
      const row2 = new Container5();
      row2.flex = 1;
      row2.flexDirection = 2 /* ROW */;
      const texts = [behavior.symbol, behavior.name, behavior.description];
      texts.forEach((textString) => {
        const text = new Text2(textString, {
          align: "left",
          font: {
            fontName: "buttontext_white",
            fontSize: 16
          }
        });
        text.flex = 1;
        row2.addChild(text);
      });
      const button2 = new Button("Activate", {
        textSize: 16
      }, () => {
        trpc.startBehaviorForShip.mutate({ shipSymbol: GameState.selected.symbol, behavior: behavior.symbol, parameters: {
          systemSymbol: this.homeSystem,
          range: this.selectedRange
        } }).then(() => {
          alert("Behavior started");
          this.hide();
        });
      });
      button2.flex = 1;
      row2.addChild(button2);
      behaviorsContainer.addChild(row2);
    });
    const row = new Container5();
    row.flex = 1;
    row.flexDirection = 2 /* ROW */;
    const button = new Button("Cancel", {
      textSize: 16
    }, () => {
      trpc.cancelBehaviorForShip.mutate({ shipSymbol: GameState.selected.symbol }).then(() => {
        alert("Behavior canceled");
      });
      this.hide();
    });
    button.flex = 1;
    row.addChild(button);
    behaviorsContainer.addChild(row);
    this.container.updateLayout();
  }
  show() {
    this.selectedRange = 1500;
    this.switchRange.selectedValue = "1500";
    this.container.displayObject.visible = true;
    this.container.displayObject.x = 200;
    this.container.displayObject.y = 200;
  }
  hide() {
    this.container.displayObject.visible = false;
  }
};

// src/frontend/game/positionShips.ts
var waypointShips = {};
function resetShipWaypoints() {
  waypointShips = {};
}
var planetOrbitSpeed = 2e4;
function positionWaypoint(waypoint, timeElapsed) {
  let x3, y2;
  if (waypoint.orbitsSymbol) {
    const orbitData = GameState.waypointData[waypoint.orbitsSymbol];
    const orbitDistance = Math.sqrt(Math.pow(waypoint.x, 2) + Math.pow(waypoint.y, 2));
    const orbitalPeriod = orbitDistance * planetOrbitSpeed;
    const currentAngle = (timeElapsed % orbitalPeriod / orbitalPeriod + orbitData.offset) * Math.PI * 2;
    x3 = (Math.abs(systemCoordinates.minX) + Math.cos(currentAngle) * orbitDistance) * systemScale;
    y2 = (Math.abs(systemCoordinates.minY) + Math.sin(currentAngle) * orbitDistance) * systemScale;
    const ownOrbitalPeriod = 60 * 500;
    const ownAngle = (timeElapsed % ownOrbitalPeriod / ownOrbitalPeriod + waypoint.offset) * Math.PI * 2;
    const offsetX = Math.cos(ownAngle) * 60;
    const offsetY = Math.sin(ownAngle) * 60;
    x3 += offsetX;
    y2 += offsetY;
  } else {
    const orbitDistance = Math.sqrt(Math.pow(waypoint.x, 2) + Math.pow(waypoint.y, 2));
    const orbitalPeriod = orbitDistance * planetOrbitSpeed;
    const currentAngle = (timeElapsed % orbitalPeriod / orbitalPeriod + waypoint.offset) * Math.PI * 2;
    x3 = (Math.abs(systemCoordinates.minX) + Math.cos(currentAngle) * orbitDistance) * systemScale;
    y2 = (Math.abs(systemCoordinates.minY) + Math.sin(currentAngle) * orbitDistance) * systemScale;
  }
  return {
    x: x3,
    y: y2
  };
}
function positionShip(ship) {
  let serverX, serverY, navRot, xOffset = 0, yOffset = 0;
  const arrivalOn = new Date(ship.arrivalOn);
  const departureOn = new Date(ship.departureOn);
  if (ship.destinationWaypoint.symbol !== ship.departureWaypoint.symbol && Date.now() < arrivalOn.getTime()) {
    const positionAlongPath = (Date.now() - departureOn.getTime()) / (arrivalOn.getTime() - departureOn.getTime());
    try {
      const from = GameState.waypoints[ship.departureWaypoint.symbol];
      const to = GameState.waypoints[ship.destinationWaypoint.symbol];
      serverX = from.x + (to.x - from.x) * positionAlongPath;
      serverY = from.y + (to.y - from.y) * positionAlongPath;
      navRot = Math.atan2(to.y - from.y, to.x - from.x) + Math.PI / 2;
    } catch (e3) {
      serverX = 0;
      serverY = 0;
      navRot = 0;
    }
  } else {
    const orbitSymbol = ship.currentWaypoint.orbitsSymbol ? ship.currentWaypoint.orbitsSymbol : ship.currentWaypoint.symbol;
    if (waypointShips[orbitSymbol] === void 0) {
      waypointShips[orbitSymbol] = 0;
    } else {
      waypointShips[orbitSymbol]++;
    }
    const curr = GameState.waypoints[ship.currentWaypoint.symbol];
    if (curr) {
      serverX = curr.x;
      serverY = curr.y;
      xOffset = 32 * waypointShips[orbitSymbol];
      yOffset = 80;
    } else {
      serverX = 0;
      serverY = 0;
      navRot = 0;
    }
  }
  const x3 = serverX + xOffset;
  const y2 = serverY + yOffset;
  return {
    x: x3,
    y: y2,
    navRot
  };
}
function positionUniverseShip(ship) {
  let serverX, serverY, navRot, xOffset = 0, yOffset = 0;
  const arrivalOn = new Date(ship.arrivalOn);
  const departureOn = new Date(ship.departureOn);
  const sizeMultiplier = universeView.worldScreenWidth / universeView.screenWidth;
  if (ship.destinationWaypoint.systemSymbol !== ship.departureWaypoint.systemSymbol && Date.now() < arrivalOn.getTime()) {
    const positionAlongPath = (Date.now() - departureOn.getTime()) / (arrivalOn.getTime() - departureOn.getTime());
    const departureSystem = GameState.systems[ship.departureWaypoint.systemSymbol];
    const destinationSystem = GameState.systems[ship.destinationWaypoint.systemSymbol];
    serverX = departureSystem.x + (destinationSystem.x - departureSystem.x) * positionAlongPath;
    serverY = departureSystem.y + (destinationSystem.y - departureSystem.y) * positionAlongPath;
    navRot = Math.atan2(destinationSystem.y - departureSystem.y, destinationSystem.x - departureSystem.x) + Math.PI / 2;
  } else {
    if (waypointShips[ship.currentWaypoint.systemSymbol] === void 0) {
      waypointShips[ship.currentWaypoint.systemSymbol] = 0;
    } else {
      waypointShips[ship.currentWaypoint.systemSymbol]++;
    }
    const currentSystem = GameState.systems[ship.currentWaypoint.systemSymbol];
    serverX = currentSystem.x;
    serverY = currentSystem.y;
    xOffset = 32 * waypointShips[ship.currentWaypoint.systemSymbol] * sizeMultiplier;
    yOffset = 80 * Math.min(sizeMultiplier, 8);
  }
  const x3 = serverX + xOffset;
  const y2 = serverY + yOffset;
  return {
    x: x3,
    y: y2,
    navRot
  };
}

// src/frontend/game/loadSystem.ts
function createShipContainer(ship) {
  const shipGroup = new Container();
  const itemSprite = new Sprite(loadedAssets.spaceshipTextures[ship.frameSymbol] ? loadedAssets.spaceshipTextures[ship.frameSymbol] : loadedAssets.spaceshipTexture);
  itemSprite.name = "ship";
  itemSprite.pivot = {
    x: 32,
    y: 32
  };
  const navSprite = new Sprite(loadedAssets.navArrow);
  navSprite.pivot = {
    x: navSprite.width / 2,
    y: navSprite.height / 2
  };
  navSprite.name = "nav";
  navSprite.visible = false;
  shipGroup.addChild(navSprite);
  itemSprite.scale = { x: 0.5, y: 0.5 };
  const shipPosition = positionShip(ship);
  shipGroup.x = shipPosition.x;
  shipGroup.y = shipPosition.y;
  if (ship.agent !== GameState.agent.symbol) {
    itemSprite.tint = 14522777;
  }
  shipGroup.addChild(itemSprite);
  const text = new BitmapText2(ship.symbol + " - " + ship.role, {
    fontName: "sans-serif",
    fontSize: 16,
    align: "right"
  });
  text.visible = false;
  text.x = 0;
  text.y = 32;
  shipGroup.addChild(text);
  makeInteractiveAndSelectable(shipGroup, {
    onMouseOver: () => {
      text.visible = true;
    },
    onMouseOut: () => {
      text.visible = false;
    },
    onSelect: {
      type: "ship",
      symbol: ship.symbol
    }
  });
  return shipGroup;
}
function createOrbitGraphics(item) {
  const orbit = new Graphics();
  orbit.lineStyle({
    width: 2,
    color: 4473924
  });
  orbit.drawCircle(Math.abs(systemCoordinates.minX) * systemScale, Math.abs(systemCoordinates.minY) * systemScale, Math.sqrt(Math.pow(item.x * systemScale, 2) + Math.pow(item.y * systemScale, 2)));
  return orbit;
}
function addTraitIcons(item, container) {
  let xOffset = 0;
  item.traits.forEach((trait) => {
    if (trait.symbol === "MARKETPLACE") {
      const sprite = new Sprite(loadedAssets.market);
      sprite.pivot = {
        x: 32,
        y: 32
      };
      sprite.scale = { x: 0.25, y: 0.25 };
      sprite.x = xOffset - 16;
      sprite.y = 24;
      container.addChild(sprite);
      xOffset += 16;
    }
    if (trait.symbol === "SHIPYARD") {
      const sprite = new Sprite(loadedAssets.shipyard);
      sprite.pivot = {
        x: 32,
        y: 32
      };
      sprite.scale = { x: 0.25, y: 0.24 };
      sprite.x = xOffset - 16;
      sprite.y = 24;
      container.addChild(sprite);
      xOffset += 16;
    }
  });
}
function createSystemItem(data, scale3 = 1, index = 0) {
  const orbitingGroup = new Container();
  let orbitingSprite;
  if (data.waypoint.type === "PLANET") {
    orbitingSprite = new AnimatedSprite(loadedAssets.planet.animations["planet/tile/planet.png_spin"], true);
    if (orbitingSprite instanceof AnimatedSprite) {
      orbitingSprite.animationSpeed = 1 / 20;
      orbitingSprite.play();
    }
  } else {
    orbitingSprite = new Sprite(loadedAssets.planetsheet.textures[`planets/tile/${data.waypoint.type}.png`]);
  }
  orbitingSprite.pivot = {
    x: 32,
    y: 32
  };
  orbitingSprite.scale = { x: scale3, y: scale3 };
  if (data.parent) {
    orbitingGroup.x = data.parent.x * systemScale + 32 + Math.abs(systemCoordinates.minX) * systemScale;
    orbitingGroup.y = data.parent.y * systemScale + 48 + 64 * index + Math.abs(systemCoordinates.minY) * systemScale;
  } else {
    orbitingGroup.x = (data.waypoint.x + Math.abs(systemCoordinates.minX)) * systemScale;
    orbitingGroup.y = (data.waypoint.y + Math.abs(systemCoordinates.minY)) * systemScale;
  }
  orbitingGroup.addChild(orbitingSprite);
  const orbitingText = new BitmapText2(data.waypoint.symbol + " - " + data.waypoint.type, {
    fontName: "sans-serif",
    fontSize: 16,
    align: "right"
  });
  orbitingText.x = 24;
  orbitingText.y = -8;
  orbitingText.visible = false;
  orbitingGroup.addChild(orbitingText);
  makeInteractiveAndSelectable(orbitingGroup, {
    onMouseOver: () => {
      console.log("hovered", data.waypoint);
      GameState.hoveredWaypoint = data.waypoint;
      orbitingText.visible = true;
    },
    onMouseOut: () => {
      GameState.hoveredWaypoint = void 0;
      orbitingText.visible = false;
    },
    onSelect: {
      type: "waypoint",
      symbol: data.waypoint.symbol
    },
    onOrder: [
      {
        name: "navigate",
        withSelection: "ship",
        action: async (selectedSymbol) => {
          const res = await trpc.instructNavigate.mutate({
            shipSymbol: selectedSymbol,
            waypointSymbol: data.waypoint.symbol
          });
          GameState.shipData[res.symbol] = res;
          console.log("updated state for ship " + res.symbol);
        }
      }
    ]
  });
  addTraitIcons(data.waypoint, orbitingGroup);
  return orbitingGroup;
}
function clearSystem() {
  systemView.removeChildren();
  systemView.addChild(systemGraphics);
  systemView.addChild(systemGraphicsText);
}
function showSystemView() {
  universeView.visible = false;
  systemView.visible = true;
  GameState.currentView = "system";
}
async function loadSystem(systemSymbol, resetCamera = true) {
  Promise.all([
    trpc.shipsForSystem.query({
      system: systemSymbol
    }),
    trpc.waypointsForSystem.query({
      system: systemSymbol
    })
  ]).then(([ships, waypoints]) => {
    const starData = GameState.systemData[systemSymbol];
    ships.forEach((ship) => {
      GameState.shipData[ship.symbol] = ship;
    });
    waypoints.forEach((waypoint) => {
      GameState.waypointData[waypoint.symbol] = {
        ...waypoint,
        offset: Math.random()
      };
    });
    clearSystem();
    showSystemView();
    GameState.currentSystem = systemSymbol;
    backButton.disabled = false;
    systemCoordinates.minX = 0;
    systemCoordinates.minY = 0;
    waypoints.filter((item) => !item.orbitsSymbol).forEach((item) => {
      if (item.x < systemCoordinates.minX) {
        systemCoordinates.minX = item.x;
      }
      if (item.y < systemCoordinates.minY) {
        systemCoordinates.minY = item.y;
      }
    });
    let texture = loadedAssets.sheet.textures[`planets/tile/${starData.type}.png`];
    const star = new Sprite(texture);
    star.x = Math.abs(systemCoordinates.minX) * systemScale;
    star.y = Math.abs(systemCoordinates.minY) * systemScale;
    star.pivot = {
      x: 32,
      y: 32
    };
    systemView.addChild(star);
    resetShipWaypoints();
    GameState.systemShips = {};
    GameState.waypoints = {};
    Object.values(GameState.shipData).filter((ship) => ship.currentWaypoint.systemSymbol === starData.symbol).forEach((data) => {
      const ship = data;
      const shipGroup = createShipContainer(ship);
      systemView.addChild(shipGroup);
      GameState.systemShips[ship.symbol] = shipGroup;
    });
    waypoints.filter((item) => !item.orbitsSymbol && item.type !== "MOON" && item.type !== "ORBITAL_STATION").forEach((item) => {
      systemView.addChild(createOrbitGraphics(item));
      const itemGroup = createSystemItem({
        waypoint: item
      });
      waypoints.filter((orbitingThing) => orbitingThing.orbitsSymbol === item.symbol || orbitingThing.symbol !== item.symbol && orbitingThing.x == item.x && orbitingThing.y == item.y).forEach((orbitingThing, index) => {
        const orbitingGroup = createSystemItem({
          waypoint: orbitingThing,
          parent: item
        }, 0.5, index);
        GameState.waypoints[orbitingThing.symbol] = orbitingGroup;
        systemView.addChild(orbitingGroup);
      });
      GameState.waypoints[item.symbol] = itemGroup;
      systemView.addChild(itemGroup);
    });
    if (resetCamera) {
      systemView.moveCenter({
        x: Math.abs(systemCoordinates.minX) * systemScale,
        y: Math.abs(systemCoordinates.minY) * systemScale
      });
    }
  });
}

// src/frontend/game/loadPlayerData.ts
async function loadPlayerData() {
  await trpc.updateAgentInfo.mutate();
  const ships = await trpc.getMyShips.query();
  console.log("my ships", ships);
  ships.forEach((ship) => {
    GameState.shipData[ship.symbol] = ship;
  });
  await updateCredits();
  const factions = await trpc.getFactions.query();
  GameState.factions = {};
  factions.forEach((faction) => {
    GameState.factions[faction.symbol] = faction;
  });
}
async function updateCredits() {
  const agent = await trpc.getAgentInfo.query();
  GameState.agent = agent;
}

// src/frontend/game/ShipyardWindow.ts
var ShipyardWindow = class {
  constructor(ships, readonly = false) {
    this.readonly = readonly;
    this.container = new Container5();
    this.container.width = 1e3;
    this.container.height = 600;
    ships.forEach((ship) => {
      this.addGood(ship);
    });
    this.container.updateLayout();
  }
  container;
  addGood(ship) {
    const flexRow = new Container5();
    flexRow.flexDirection = 0 /* COLUMN */;
    flexRow.height = 80;
    flexRow.width = "100%";
    const firstRow = new Container5({ variant: "invisible" });
    firstRow.height = 40;
    firstRow.width = "100%";
    firstRow.flexDirection = 2 /* ROW */;
    const secondRow = new Container5({ variant: "invisible" });
    secondRow.height = 40;
    secondRow.width = "100%";
    secondRow.flexDirection = 2 /* ROW */;
    const fontStyle = {
      fontName: "buttontext_white",
      fontSize: 12
    };
    const displayFields = ["name", "frameSymbol", "engineSymbol", "reactorSymbol"];
    displayFields.forEach((field) => {
      const name = ship.shipConfiguration[field].includes("_") ? ship.shipConfiguration[field].split("_").slice(1).join("_") : ship.shipConfiguration[field];
      const firstText = new Text2(name, {
        align: "left",
        font: fontStyle
      });
      firstText.flex = 1;
      firstRow.addChild(firstText);
    });
    const thirdText = new Text2(ship.price ? ship.price.toString() : "???", {
      align: "right",
      font: fontStyle
    });
    thirdText.flex = 1;
    firstRow.addChild(thirdText);
    const buyButton = new Button("Buy", {}, async (event) => {
      event.stopPropagation();
      await trpc.instructBuyShip.mutate({
        waypointSymbol: ship.waypointSymbol,
        shipConfigurationSymbol: ship.shipConfigurationSymbol
      });
      await updateCredits();
      loadSystem(GameState.currentSystem, false);
    });
    buyButton.disabled = this.readonly;
    buyButton.flex = 1;
    firstRow.addChild(buyButton);
    const counts = {};
    ship.shipConfiguration.shipConfigurationModule.forEach((module2) => {
      if (!counts[module2.moduleSymbol]) {
        counts[module2.moduleSymbol] = 1;
      } else {
        counts[module2.moduleSymbol]++;
      }
    });
    const secondRowText = new Text2(Object.keys(counts).map((moduleKey) => `${moduleKey.replace("MODULE_", "")} x${counts[moduleKey]}`).join(", "), {
      align: "left",
      font: fontStyle
    });
    secondRowText.flex = 1;
    secondRow.addChild(secondRowText);
    flexRow.addChild(firstRow);
    flexRow.addChild(secondRow);
    this.container.addChild(flexRow);
  }
};

// src/frontend/game/availableActions.ts
var availableActions = [{
  name: "Refuel",
  action: async (event) => {
    event.stopPropagation();
    if (GameState.selected) {
      const refuel = await trpc.instructRefuel.mutate({
        shipSymbol: GameState.selected.symbol
      });
      GameState.shipData[refuel.symbol] = refuel;
      await updateCredits();
    }
  },
  isAvailable: () => {
    if (GameState.selected?.type === "ship") {
      const selectedShip = GameState.shipData[GameState.selected.symbol];
      return selectedShip.fuelAvailable < selectedShip.fuelCapacity && selectedShip.navStatus === "DOCKED";
    }
    return false;
  }
}, {
  name: "Dock",
  action: async (event) => {
    event.stopPropagation();
    if (GameState.selected) {
      const dock = await trpc.instructDock.mutate({
        shipSymbol: GameState.selected.symbol
      });
      console.log("dockresult", dock);
      GameState.shipData[dock.symbol] = dock;
    }
  },
  isAvailable: () => {
    if (GameState.selected?.type === "ship") {
      const selectedShip = GameState.shipData[GameState.selected.symbol];
      return selectedShip.navStatus === "IN_ORBIT" || selectedShip.navStatus === "IN_TRANSIT" && new Date(selectedShip.arrivalOn).getTime() < Date.now();
    }
    return false;
  }
}, {
  name: "Orbit",
  action: async (event) => {
    event.stopPropagation();
    if (GameState.selected) {
      const orbit = await trpc.instructOrbit.mutate({
        shipSymbol: GameState.selected.symbol
      });
      GameState.shipData[orbit.symbol] = orbit;
    }
  },
  isAvailable: () => {
    if (GameState.selected?.type === "ship") {
      const selectedShip = GameState.shipData[GameState.selected.symbol];
      return selectedShip.navStatus === "DOCKED";
    }
    return false;
  }
}, {
  name: "Extract",
  action: async (event) => {
    event.stopPropagation();
    if (GameState.selected) {
      const shipInfo = await trpc.instructExtract.mutate({
        shipSymbol: GameState.selected.symbol
      });
      GameState.shipData[shipInfo.symbol] = shipInfo;
    }
  },
  isAvailable: () => {
    if (GameState.selected?.type === "ship" && GameState.waypointData) {
      const selectedShip = GameState.shipData[GameState.selected.symbol];
      if (GameState.waypointData[selectedShip.currentWaypoint.symbol]) {
        return selectedShip.navStatus === "IN_ORBIT" && GameState.waypointData[selectedShip.currentWaypoint.symbol].traits.filter((t2) => t2.symbol === "COMMON_METAL_DEPOSITS" || t2.symbol === "MINERAL_DEPOSITS" || t2.symbol === "PRECIOUS_METAL_DEPOSITS").length > 0 && Date.now() > new Date(selectedShip.reactorCooldownOn).getTime();
      }
    }
    return false;
  }
}, {
  name: "Sell All",
  action: async (event) => {
    event.stopPropagation();
    if (GameState.selected) {
      const shipInfo = await trpc.instructSellCargo.mutate({
        shipSymbol: GameState.selected.symbol
      });
      GameState.shipData[shipInfo.symbol] = shipInfo;
      await updateCredits();
    }
  },
  isAvailable: () => {
    if (GameState.selected?.type === "ship" && GameState.waypointData) {
      const selectedShip = GameState.shipData[GameState.selected.symbol];
      if (GameState.waypointData[selectedShip.currentWaypoint.symbol]) {
        return selectedShip.navStatus === "DOCKED" && selectedShip.cargoUsed > 0;
      }
    }
    return false;
  }
}, {
  name: "Chart",
  action: async (event) => {
    event.stopPropagation();
    if (GameState.selected) {
      const chartResult = await trpc.instructChart.mutate({
        shipSymbol: GameState.selected.symbol
      });
      GameState.shipData[chartResult.ship.symbol] = chartResult.ship;
      GameState.waypointData[chartResult.waypoint.symbol] = chartResult.waypoint;
    }
  },
  isAvailable: () => {
    if (GameState.selected?.type === "ship" && GameState.waypointData) {
      const selectedShip = GameState.shipData[GameState.selected.symbol];
      if (GameState.waypointData[selectedShip.currentWaypoint.symbol]) {
        return selectedShip.navStatus === "IN_ORBIT" && !GameState.waypointData[selectedShip.currentWaypoint.symbol].chartSubmittedBy;
      }
    }
    return false;
  }
}, {
  name: "Scan Wpt",
  action: async (event) => {
    event.stopPropagation();
    if (GameState.selected && GameState.currentSystem) {
      const waypoints = await trpc.instructScanWaypoints.mutate({
        shipSymbol: GameState.selected.symbol
      });
      GameState.shipData[waypoints.symbol] = waypoints;
      await loadSystem(GameState.currentSystem);
    }
  },
  isAvailable: () => {
    if (GameState.selected?.type === "ship") {
      const selectedShip = GameState.shipData[GameState.selected.symbol];
      return selectedShip.navStatus === "IN_ORBIT" && Date.now() > new Date(selectedShip.reactorCooldownOn).getTime();
    }
    return false;
  }
}, {
  name: "Scan Shp",
  action: async (event) => {
    event.stopPropagation();
    if (GameState.selected && GameState.currentSystem) {
      const waypoints = await trpc.instructScanShips.mutate({
        shipSymbol: GameState.selected.symbol
      });
      GameState.shipData[waypoints.symbol] = waypoints;
      await loadSystem(GameState.currentSystem);
    }
  },
  isAvailable: () => {
    if (GameState.selected?.type === "ship") {
      const selectedShip = GameState.shipData[GameState.selected.symbol];
      return selectedShip.navStatus === "IN_ORBIT" && Date.now() > new Date(selectedShip.reactorCooldownOn).getTime() && selectedShip.mounts.filter((m3) => m3.effectName === "SENSOR_ARRAY").length > 0;
    }
    return false;
  }
}, {
  name: "Market",
  action: async (event) => {
    event.stopPropagation();
    if (GameState.selected && GameState.currentSystem) {
      const market = await trpc.instructMarket.mutate({
        shipSymbol: GameState.selected.symbol,
        systemSymbol: GameState.currentSystem,
        waypointSymbol: GameState.shipData[GameState.selected.symbol].currentWaypoint.symbol
      });
      console.log(market);
    }
  },
  isAvailable: () => {
    if (GameState.selected?.type === "ship" && GameState.waypointData) {
      const selectedShip = GameState.shipData[GameState.selected.symbol];
      if (GameState.waypointData[selectedShip.currentWaypoint.symbol]) {
        return selectedShip.navStatus === "DOCKED" && GameState.waypointData[selectedShip.currentWaypoint.symbol].traits.filter((t2) => t2.symbol === "MARKETPLACE").length > 0;
      }
    }
    return false;
  }
}, {
  name: "Shipyard",
  action: async (event) => {
    event.stopPropagation();
    console.log("click  shy");
    if (GameState.selected && GameState.currentSystem) {
      const waypointSymbol = GameState.selected?.type === "waypoint" ? GameState.selected.symbol : GameState.shipData[GameState.selected.symbol].currentWaypoint.symbol;
      const market = await trpc.instructShipyard.mutate({
        shipSymbol: GameState.selected.symbol,
        systemSymbol: GameState.currentSystem,
        waypointSymbol
      });
      console.log(market);
      const shipyardData = await trpc.getShipyard.query({
        waypointSymbol
      });
      const shipyardWindow = new ShipyardWindow(shipyardData, GameState.selected.type === "waypoint");
      uiOverlay.addChild(shipyardWindow.container.displayObject);
      shipyardWindow.container.displayObject.x = (window.innerWidth - 1e3) / 2;
      shipyardWindow.container.displayObject.y = (window.innerHeight - 600) / 2;
      deselectListeners.once("deselect", () => {
        uiOverlay.removeChild(shipyardWindow.container.displayObject);
      });
    }
  },
  isAvailable: () => {
    if (GameState.selected?.type === "waypoint" && GameState.waypointData) {
      if (GameState.waypointData[GameState.selected.symbol]) {
        return GameState.waypointData[GameState.selected.symbol].traits.filter((t2) => t2.symbol === "SHIPYARD").length > 0;
      }
    }
    if (GameState.selected?.type === "ship" && GameState.waypointData) {
      const selectedShip = GameState.shipData[GameState.selected.symbol];
      if (GameState.waypointData[selectedShip.currentWaypoint.symbol]) {
        return selectedShip.navStatus === "DOCKED" && GameState.waypointData[selectedShip.currentWaypoint.symbol].traits.filter((t2) => t2.symbol === "SHIPYARD").length > 0;
      }
    }
    return false;
  }
}, {
  name: "Jumpgate",
  action: async (event) => {
    event.stopPropagation();
    if (GameState.selected && GameState.currentSystem) {
      let waypointSymbol;
      if (GameState.selected.type == "ship") {
        waypointSymbol = GameState.shipData[GameState.selected.symbol].currentWaypoint.symbol;
      } else {
        waypointSymbol = GameState.selected.symbol;
      }
      const jumpgateInfo = await trpc.instructJumpGate.mutate({
        shipSymbol: GameState.selected.symbol,
        systemSymbol: GameState.currentSystem,
        waypointSymbol
      });
      console.log(jumpgateInfo);
    }
  },
  isAvailable: () => {
    if (GameState.selected?.type === "waypoint") {
      return GameState.waypointData[GameState.selected.symbol].type === "JUMP_GATE";
    }
    if (GameState.selected?.type === "ship" && GameState.waypointData) {
      const selectedShip = GameState.shipData[GameState.selected.symbol];
      if (GameState.waypointData[selectedShip.currentWaypoint.symbol]) {
        return GameState.waypointData[selectedShip.currentWaypoint.symbol].type === "JUMP_GATE";
      }
    }
    return false;
  }
}, {
  name: "Behavior",
  action: async (event) => {
    event.stopPropagation();
    behaviorWindow.show();
    behaviorWindow.setHome(GameState.shipData[GameState.selected.symbol].currentSystemSymbol);
    deselectListeners.once("deselect", () => {
      behaviorWindow.hide();
    });
  },
  isAvailable: () => {
    return GameState.selected?.type === "ship";
  }
}];

// src/frontend/game/application.ts
var app = new Application();
app.init();

// src/frontend/game/util.ts
var convertToDisplayCoordinates = (position) => {
  return {
    x: (position.x + Math.abs(universeCoordinates.minX)) / (universeCoordinates.maxX - universeCoordinates.minX) * totalSize,
    y: (position.y + Math.abs(universeCoordinates.minY)) / (universeCoordinates.maxY - universeCoordinates.minY) * totalSize
  };
};

// src/frontend/game/highlightmodes.ts
var stringToColour = function(str) {
  var hash = 0;
  for (var i3 = 0; i3 < str.length; i3++) {
    hash = str.charCodeAt(i3) + ((hash << 5) - hash);
  }
  var colour = "#";
  for (var i3 = 0; i3 < 3; i3++) {
    var value = hash >> i3 * 8 & 255;
    colour += ("00" + value.toString(16)).substr(-2);
  }
  return colour;
};
var highlightmodes = {
  Factions: (graphics) => {
    for (const starData of Object.values(GameState.systemData)) {
      if (starData.majorityFaction) {
        const isHeadquarters = GameState.factions[starData.majorityFaction].headquartersSymbol.includes(starData.symbol);
        const displayCoords = convertToDisplayCoordinates(starData);
        graphics.beginFill(stringToColour(starData.majorityFaction));
        graphics.drawCircle(displayCoords.x, displayCoords.y, isHeadquarters ? 4500 : 1500);
      }
    }
    const colorMatrix = new AlphaFilter();
    colorMatrix.alpha = 0.1;
    graphics.filters = [colorMatrix];
  },
  Shipyards: (graphics) => {
    for (const starData of Object.values(GameState.systemData)) {
      if (starData.hasShipyard) {
        const displayCoords = convertToDisplayCoordinates(starData);
        graphics.beginFill(255);
        graphics.drawCircle(displayCoords.x, displayCoords.y, 1500);
      }
    }
    const colorMatrix = new AlphaFilter();
    colorMatrix.alpha = 0.1;
    graphics.filters = [colorMatrix];
  },
  "Market Update": (graphics) => {
    for (const shipData of Object.values(GameState.shipData)) {
      if (shipData.currentBehavior === "EXPLORE_MARKETS" || shipData.currentBehavior === "UPDATE_MARKETS") {
        const homeSystem = GameState.systemData[shipData.homeSystemSymbol];
        const displayCoords = convertToDisplayCoordinates(homeSystem);
        const range = shipData.behaviorRange * scale.universe;
        graphics.beginFill(6750054);
        graphics.drawRect(displayCoords.x - range, displayCoords.y - range, range * 2, range * 2);
      }
    }
    const colorMatrix = new AlphaFilter();
    colorMatrix.alpha = 0.1;
    graphics.filters = [colorMatrix];
  }
};

// src/frontend/game/ui/action-buttons.ts
var actionPanelHeight = Math.ceil(availableActions.length / 2) * 48;
var actionPanelY = window.innerHeight - 16 - actionPanelHeight;
var createActionButtons = () => {
  const flex = new Container5();
  flex.maxWidth = "100%";
  flex.position = 0 /* RELATIVE */;
  flex.wrap = 1 /* WRAP_WRAP */;
  flex.flexDirection = 2 /* ROW */;
  availableActions.forEach((action, index) => {
    const button = new Button(action.name, {}, action.action);
    button.width = "50%";
    button.height = 36;
    app.ticker.add(() => {
      const isAvailable = action.isAvailable();
      button.disabled = !isAvailable;
    });
    button.disabled = true;
    flex.addChild(button);
  });
  return flex;
};
var createHighlightButtons = () => {
  const flex = new Container5();
  flex.maxWidth = "100%";
  flex.padding = 2;
  flex.wrap = 1 /* WRAP_WRAP */;
  flex.flexDirection = 2 /* ROW */;
  Object.keys(highlightmodes).forEach((action) => {
    const drawFunction = highlightmodes[action];
    const button = new Button(action, {}, () => {
      const highlight = universeView.getChildByName("highlight");
      highlight.clear();
      drawFunction(highlight);
    });
    button.width = "50%";
    button.height = 36;
    flex.addChild(button);
  });
  return flex;
};

// src/frontend/game/createSidebar.ts
var credits;
var cruiseModeSelect;
var entityInfo;
var backButton;
var createSidebar = () => {
  const sidebarContainer = new Container5();
  sidebarContainer.height = gameHeight;
  sidebarContainer.width = 400;
  sidebarContainer.displayObject.x = 0;
  sidebarContainer.displayObject.y = 0;
  sidebarContainer.padding = 10;
  backButton = new Button("Back", {
    height: 64,
    width: 368
  }, (event) => {
    event.stopPropagation();
    universeView.visible = true;
    systemView.visible = false;
    GameState.currentView = "universe";
    systemView.removeChildren();
    backButton.disabled = true;
  });
  backButton.minHeight = 60;
  backButton.disabled = true;
  sidebarContainer.addChild(backButton);
  const creditsBackground = new Container5({
    variant: "custom",
    texture: loadedAssets.statsBlock
  });
  creditsBackground.width = "100%";
  creditsBackground.minHeight = 100;
  creditsBackground.padding = 8;
  sidebarContainer.addChild(creditsBackground);
  const creditsLabel = new Text2("Credits", {
    font: {
      fontName: "buttontext_white",
      tint: 65280,
      fontSize: 16
    },
    align: "left"
  });
  creditsLabel.height = 40;
  creditsBackground.addChild(creditsLabel);
  credits = new Text2("0", {
    font: {
      fontName: "segment",
      fontSize: 36,
      tint: 65280
    },
    align: "left"
  });
  creditsBackground.addChild(credits);
  const cruiseModeButtons = ["CRUISE", "DRIFT", "BURN", "STEALTH"];
  cruiseModeSelect = new Switch(cruiseModeButtons, {
    width: 368,
    textSize: 14,
    defaultSelected: "CRUISE"
  }, async (event, selectedOption) => {
    if (GameState.selected?.type === "ship") {
      const newShip = await trpc.instructPatchNavigate.mutate({
        shipSymbol: GameState.selected?.symbol,
        navMode: selectedOption
      });
      console.log("new state", newShip);
      GameState.shipData[GameState.selected.symbol] = newShip;
    }
  });
  sidebarContainer.addChild(cruiseModeSelect);
  const actionButtons = createActionButtons();
  sidebarContainer.addChild(actionButtons);
  const statsBlock = new Container5({
    variant: "custom",
    texture: loadedAssets.statsBlock
  });
  statsBlock.paddingVertical = 24;
  statsBlock.paddingHorizontal = 8;
  statsBlock.width = "100%";
  statsBlock.height = 200;
  sidebarContainer.addChild(statsBlock);
  entityInfo = new Text2("Entity Information", {
    font: {
      fontName: "buttontext_white",
      fontSize: 16,
      align: "left",
      maxWidth: 368,
      tint: 52224
    },
    align: "left"
  });
  statsBlock.addChild(entityInfo);
  const cargo = new Container5({
    variant: "default"
  });
  cargo.padding = 16;
  cargo.height = 100;
  const cargoInfo = new Text2("Cargo", {
    font: {
      fontName: "buttontext_white",
      fontSize: 16,
      align: "left",
      maxWidth: 368,
      tint: 52224
    },
    align: "left"
  });
  cargo.addChild(cargoInfo);
  app.ticker.add(() => {
    if (GameState.selected && GameState.selected.type === "ship") {
      const shipData = GameState.shipData[GameState.selected.symbol];
      if (shipData.cargo) {
        cargoInfo.displayObject.bitmapText.text = `Cargo:
${shipData.cargo.map((cargo2) => `- ${cargo2.tradeGoodSymbol} ${cargo2.units}`).join("\n")}`;
      } else {
        cargoInfo.displayObject.bitmapText.text = `Cargo: No data
`;
      }
    } else {
      cargoInfo.displayObject.bitmapText.text = `Cargo:
`;
    }
  });
  sidebarContainer.addChild(cargo);
  const highlightButtons = createHighlightButtons();
  sidebarContainer.addChild(highlightButtons);
  sidebarContainer.updateLayout();
  return sidebarContainer;
};

// src/frontend/game/UIElements.ts
var universeView;
var systemView;
var uiOverlay;
var currentCoordinate;
var fps;
var universeCuller;
var universeGraphics;
var universeGraphicsText;
var systemGraphics;
var systemGraphicsText;
var marketWindow;
var behaviorWindow;
var createUIElements = (app2) => {
  let pointerDownPlace;
  systemView = new et({
    screenWidth: window.innerWidth,
    screenHeight: window.innerHeight,
    worldWidth: 2e3,
    worldHeight: 2e3,
    events: app2.renderer.events
    // the interaction module is important for wheel to work properly when renderer.view is placed or scaled
  });
  systemView.on("pointerdown", (event) => {
    console.log("pointerdown");
    pointerDownPlace = new Point(event.globalX, event.globalY);
  });
  systemView.on("click", (event) => {
    console.log("click");
    if (pointerDownPlace) {
      const distance = Math.abs(pointerDownPlace.x - event.globalX) + Math.abs(pointerDownPlace.y - event.globalY);
      if (distance > 2) {
        console.log("cancelling drag event");
        event.stopPropagation();
      }
    }
  });
  systemGraphics = new Graphics();
  systemView.addChild(systemGraphics);
  systemGraphicsText = new BitmapText("", {
    fontFamily: "sans-serif",
    fontSize: 16,
    //tint: 0x0000FF,
    align: "right"
  });
  systemView.addChild(systemGraphicsText);
  systemView.drag().pinch().wheel().decelerate();
  systemView.visible = false;
  systemView.moveCenter(1e3, 1e3);
  universeView = new et({
    screenWidth: window.innerWidth,
    screenHeight: window.innerHeight,
    worldWidth: totalSize,
    worldHeight: totalSize,
    events: app2.renderer.events
    // the interaction module is important for wheel to work properly when renderer.view is placed or scaled
  });
  universeView.on("pointerdown", (event) => {
    console.log("pointerdown");
    pointerDownPlace = new Point(event.globalX, event.globalY);
  });
  universeView.on("click", (event) => {
    console.log("click");
    if (pointerDownPlace) {
      const distance = Math.abs(pointerDownPlace.x - event.globalX) + Math.abs(pointerDownPlace.y - event.globalY);
      if (distance > 2) {
        console.log("cancelling drag event");
        event.stopPropagation();
      }
    }
  });
  universeView.drag().pinch().wheel().decelerate();
  universeView.moveCenter(totalSize / 2, totalSize / 2);
  const starContainer = new Container();
  starContainer.name = "stars";
  universeView.addChild(starContainer);
  universeCuller = new Simple();
  universeCuller.cull(universeView.getVisibleBounds());
  universeGraphics = new Graphics();
  universeView.addChild(universeGraphics);
  universeGraphicsText = new BitmapText("", {
    fontName: "sans-serif",
    fontSize: 16,
    //tint: 0x0000FF,
    align: "right"
  });
  universeView.addChild(universeGraphicsText);
  uiOverlay = new Container();
  const popupOverlay = new Container();
  const sidebar = createSidebar();
  uiOverlay.addChild(sidebar.displayObject);
  behaviorWindow = new BehaviorWindow();
  trpc.availableBehaviors.query().then((behaviors) => {
    behaviorWindow.setBehaviors(behaviors);
  });
  behaviorWindow.hide();
  marketWindow = new MarketWindow();
  marketWindow.container.displayObject.visible = false;
  uiOverlay.addChild(marketWindow.container.displayObject);
  popupOverlay.addChild(behaviorWindow.container.displayObject);
  currentCoordinate = new BitmapText("0, 0", {
    fontName: "sans-serif",
    fontSize: 18,
    align: "right"
  });
  currentCoordinate.x = gameWidth - 166;
  currentCoordinate.y = 16;
  currentCoordinate.maxWidth = 150;
  uiOverlay.addChild(currentCoordinate);
  fps = new BitmapText("FPS: 60", {
    fontName: "sans-serif",
    fontSize: 18,
    align: "right"
  });
  fps.x = gameWidth - 166;
  fps.y = 40;
  fps.maxWidth = 150;
  uiOverlay.addChild(fps);
  const bgContainer = new TilingSprite(loadedAssets.bgTexture, 4096, 4096);
  app2.stage.addChild(bgContainer);
  app2.stage.addChild(universeView);
  app2.stage.addChild(systemView);
  app2.stage.addChild(uiOverlay);
  app2.stage.addChild(popupOverlay);
};

// src/common/lib/getDistance.ts
var getDistance = (pos1, pos2) => {
  return Math.sqrt(Math.pow(pos1.x - pos2.x, 2) + Math.pow(pos1.y - pos2.y, 2));
};

// src/frontend/game/loadUniverse.ts
var addTraitIcons2 = (item, container) => {
  let xOffset = 0;
  if (item.hasMarket) {
    const sprite = new Sprite(loadedAssets.market);
    sprite.pivot = {
      x: 32,
      y: 32
    };
    sprite.scale = { x: 0.25, y: 0.25 };
    sprite.x = xOffset - 16;
    sprite.y = 24;
    container.addChild(sprite);
    xOffset += 16;
  }
  if (item.hasShipyard) {
    const sprite = new Sprite(loadedAssets.shipyard);
    sprite.pivot = {
      x: 32,
      y: 32
    };
    sprite.scale = { x: 0.25, y: 0.24 };
    sprite.x = xOffset - 16;
    sprite.y = 24;
    container.addChild(sprite);
    xOffset += 16;
  }
  if (item.hasBelt) {
    const sprite = new Sprite(loadedAssets.asteroidBelt);
    sprite.pivot = {
      x: 32,
      y: 32
    };
    sprite.scale = { x: 0.25, y: 0.24 };
    sprite.x = xOffset - 16;
    sprite.y = 24;
    container.addChild(sprite);
    xOffset += 16;
  }
  if (item.hasJumpGate) {
    const sprite = new Sprite(loadedAssets.jumpgate);
    sprite.pivot = {
      x: 32,
      y: 32
    };
    sprite.scale = { x: 0.25, y: 0.24 };
    sprite.x = xOffset - 16;
    sprite.y = 24;
    container.addChild(sprite);
    xOffset += 16;
  }
  if (item.hasStation && !item.hasShipyard) {
    const sprite = new Sprite(loadedAssets.station);
    sprite.pivot = {
      x: 32,
      y: 32
    };
    sprite.scale = { x: 0.25, y: 0.24 };
    sprite.x = xOffset - 16;
    sprite.y = 24;
    container.addChild(sprite);
    xOffset += 16;
  }
  if (item.hasUncharted) {
    const sprite = new Sprite(loadedAssets.treasure);
    sprite.pivot = {
      x: 32,
      y: 32
    };
    sprite.scale = { x: 0.25, y: 0.24 };
    sprite.x = xOffset - 16;
    sprite.y = 24;
    container.addChild(sprite);
    xOffset += 16;
  }
};
function createStar(starData) {
  let texture = loadedAssets.sheet.textures[`planets/tile/${starData.type}.png`];
  const star = new Sprite(texture);
  star.pivot = {
    x: 32,
    y: 32
  };
  const text = new BitmapText2(starData.name + "\n(" + starData.symbol + ")", {
    fontFamily: "sans-serif",
    fontSize: 18,
    align: "left"
  });
  text.name = "label";
  text.x = 0;
  text.y = 40;
  const starContainer = new Container();
  starContainer.addChild(star);
  starContainer.addChild(text);
  addTraitIcons2(starData, starContainer);
  makeInteractiveAndSelectable(starContainer, {
    onMouseOut: () => {
      GameState.hoveredSystem = void 0;
    },
    onMouseOver: () => {
      GameState.hoveredSystem = starData;
    },
    onOrder: [
      {
        name: "Travel",
        withSelection: "ship",
        isAvailable: async () => {
          return true;
        },
        action: async () => {
          await trpc.orderTravel.mutate({
            shipSymbol: GameState.selected.symbol,
            systemSymbol: starData.symbol
          });
        }
      },
      {
        name: "Warp",
        withSelection: "ship",
        isAvailable: async () => {
          const shipData = GameState.shipData[GameState.selected.symbol];
          const warpRange = shipData.modules.find((m3) => m3.effectName === "WARP_DRIVE")?.value;
          const currentSystem = GameState.systemData[shipData.currentWaypoint.systemSymbol];
          return getDistance(currentSystem, GameState.hoveredSystem) < warpRange;
        },
        action: async () => {
          const waypoints = await trpc.waypointsForSystem.query({
            system: starData.symbol
          });
          console.log("waypoints", waypoints);
          const bestWaypoint = waypoints.find((w2) => w2.traits.find((t2) => t2.symbol === "MARKETPLACE"))?.symbol ?? waypoints[0].symbol;
          if (bestWaypoint) {
            console.log("warping to ", bestWaypoint);
            const res = await trpc.instructWarp.mutate({
              shipSymbol: GameState.selected.symbol,
              waypointSymbol: bestWaypoint
            });
            GameState.shipData[res.symbol] = res;
          } else {
            alert("Cannot warp to system without waypoints, nothing to target");
          }
        }
      },
      {
        name: "Jump using gate",
        withSelection: "ship",
        isAvailable: async () => {
          const shipData = GameState.shipData[GameState.selected.symbol];
          const currentSystemWaypoints = await trpc.waypointsForSystem.query({
            system: shipData.currentWaypoint.systemSymbol
          });
          const jumpGate = currentSystemWaypoints.find((wp) => wp.type === "JUMP_GATE" && wp.symbol === shipData.currentWaypoint.symbol);
          console.log("deve", { currentSystemWaypoints, jumpGate });
          return !!jumpGate;
        },
        action: async () => {
          const res = await trpc.instructJump.mutate({
            shipSymbol: GameState.selected.symbol,
            systemSymbol: starData.symbol
          });
          GameState.shipData[res.symbol] = res;
        }
      },
      {
        name: "Jump",
        withSelection: "ship",
        isAvailable: async () => {
          const shipData = GameState.shipData[GameState.selected.symbol];
          const jumpRange = shipData.modules.find((m3) => m3.effectName === "JUMP_DRIVE")?.value;
          const currentSystem = GameState.systemData[shipData.currentWaypoint.systemSymbol];
          return !!GameState.selected?.symbol && getDistance(currentSystem, GameState.hoveredSystem) < jumpRange;
        },
        action: async () => {
          const res = await trpc.instructJump.mutate({
            shipSymbol: GameState.selected.symbol,
            systemSymbol: starData.symbol
          });
          GameState.shipData[res.symbol] = res;
        }
      },
      {
        name: "Set behavior",
        withSelection: "ship",
        isAvailable: async () => {
          return true;
        },
        action: async (selectedSymbol) => {
          behaviorWindow.show();
          behaviorWindow.setHome(starData.symbol);
          deselectListeners.once("deselect", () => {
            behaviorWindow.hide();
          });
        }
      }
    ]
  });
  starContainer.on("click", () => {
    loadSystem(starData.symbol);
  });
  const displayCoords = convertToDisplayCoordinates(starData);
  starContainer.x = displayCoords.x;
  starContainer.y = displayCoords.y;
  return starContainer;
}
var loadUniverse = async () => {
  const references = {};
  const systems3 = await trpc.getSystems.query();
  for (const starData of systems3) {
    GameState.systemData[starData.symbol] = starData;
    if (starData.x < universeCoordinates.minX)
      universeCoordinates.minX = starData.x;
    if (starData.x > universeCoordinates.maxX)
      universeCoordinates.maxX = starData.x;
    if (starData.y < universeCoordinates.minY)
      universeCoordinates.minY = starData.y;
    if (starData.y > universeCoordinates.maxY)
      universeCoordinates.maxY = starData.y;
  }
  GameState.systems = {};
  scale.universe = totalSize / (universeCoordinates.maxX - universeCoordinates.minX);
  const influenceGraphics = new Graphics();
  highlightmodes.Factions(influenceGraphics);
  influenceGraphics.name = "highlight";
  universeView.addChild(influenceGraphics);
  const jumpGraphics = new Graphics();
  for (const starData of systems3) {
    const jumpGate = starData.hasJumpGate;
    if (jumpGate && starData.jumpgateRange) {
      const validJumpTargets = systems3.filter((s2) => getDistance(s2, starData) <= starData.jumpgateRange && s2.hasJumpGate && s2.symbol !== starData.symbol);
      validJumpTargets.forEach((jumpTarget) => {
        const displayCoords = convertToDisplayCoordinates(starData);
        const targetCoords = convertToDisplayCoordinates(jumpTarget);
        jumpGraphics.stroke({
          width: starData.jumpgateRange / 250,
          color: 10066227,
          alpha: 0.1
        });
        jumpGraphics.moveTo(displayCoords.x, displayCoords.y);
        jumpGraphics.lineTo(targetCoords.x, targetCoords.y);
        jumpGraphics.closePath();
      });
    }
  }
  universeView.addChild(jumpGraphics);
  const routeGraphics = new Graphics();
  routeGraphics.name = "route";
  universeView.addChild(routeGraphics);
  const homeSystemGraphics = new Graphics();
  homeSystemGraphics.name = "homeSystem";
  universeView.addChild(homeSystemGraphics);
  const starsCont = new Container();
  for (const starData of systems3) {
    const starContainer = createStar(starData);
    GameState.systems[starData.symbol] = starContainer;
    starsCont.addChild(starContainer);
    references[starData.symbol] = starContainer;
  }
  universeView.addChild(starsCont);
  universeCuller.addList(starsCont.children);
  resetShipWaypoints();
  GameState.universeShips = {};
  Object.values(GameState.shipData).forEach((ship) => {
    const shipGroup = new Container();
    const itemSprite = new Sprite(loadedAssets.spaceshipTextures[ship.frameSymbol] ? loadedAssets.spaceshipTextures[ship.frameSymbol] : loadedAssets.spaceshipTexture);
    itemSprite.name = "ship";
    itemSprite.pivot = {
      x: 32,
      y: 32
    };
    const navSprite = new Sprite(loadedAssets.navArrow);
    navSprite.pivot = {
      x: navSprite.width / 2,
      y: navSprite.height / 2
    };
    navSprite.name = "nav";
    navSprite.visible = false;
    shipGroup.addChild(navSprite);
    itemSprite.scale = { x: 0.5, y: 0.5 };
    const shipPosition = positionUniverseShip(ship);
    shipGroup.x = shipPosition.x;
    shipGroup.y = shipPosition.y;
    shipGroup.addChild(itemSprite);
    const text = new BitmapText2(ship.symbol + " - " + ship.role, {
      fontName: "sans-serif",
      fontSize: 16,
      align: "right"
    });
    text.visible = false;
    text.x = 0;
    text.y = 32;
    shipGroup.addChild(text);
    makeInteractiveAndSelectable(shipGroup, {
      onMouseOver: () => {
        text.visible = true;
      },
      onMouseOut: () => {
        text.visible = false;
      },
      onSelect: {
        type: "ship",
        symbol: ship.symbol
      }
    });
    universeView.addChild(shipGroup);
    GameState.universeShips[ship.symbol] = shipGroup;
  });
  const graphics = new Graphics();
  graphics.lineStyle({
    width: 15,
    color: 30719
  });
  const multiFactor = 5e3 / (universeCoordinates.maxX - universeCoordinates.minX) * totalSize;
  const commandShip = Object.values(GameState.shipData).find((ship) => ship.role === "COMMAND");
  const commandShipLocation = commandShip?.currentWaypoint.systemSymbol;
  universeView.addChild(graphics);
  if (commandShipLocation) {
    universeView.moveCenter(references[commandShipLocation].x, references[commandShipLocation].y);
  }
  return {
    systems: references
  };
};

// src/frontend/game/worldCoordinateToOriginal.ts
var worldCoordinateToOriginal = (point) => {
  const multiFactor = (universeCoordinates.maxX - universeCoordinates.minX) / totalSize;
  return {
    x: Math.round(universeCoordinates.minX + point.x * multiFactor),
    y: Math.round(universeCoordinates.minY + point.y * multiFactor)
  };
};
var systemCoordinateToOriginal = (point) => {
  return {
    x: Math.round(systemCoordinates.minX + point.x / systemScale),
    y: Math.round(systemCoordinates.minY + point.y / systemScale)
  };
};

// src/frontend/game/targetingLine.ts
var clearGraphics = () => {
  universeGraphics.clear();
  systemGraphics.clear();
  universeGraphicsText.text = "";
  systemGraphicsText.text = "";
};
var warpColor = 4491229;
var jumpColor = 10066227;
var universeTargetingLine = (sizeMultiplier) => {
  if (GameState.hoveredSystem && GameState.currentView == "universe" && GameState.selected?.type === "ship") {
    const selectedShip = GameState.shipData[GameState.selected?.symbol];
    const warpRange = selectedShip.modules.find((m3) => m3.effectName === "WARP_DRIVE")?.value;
    const jumpRange = selectedShip.modules.find((m3) => m3.effectName === "JUMP_DRIVE")?.value;
    const jumpGateRange = GameState.waypointData[selectedShip.currentWaypoint.symbol]?.jumpgate?.range;
    const currentSystemSymbol = GameState.shipData[GameState.selected.symbol].currentWaypoint.systemSymbol;
    const hoveredSystemSymbol = GameState.hoveredSystem.symbol;
    const fromContainer = GameState.systems[currentSystemSymbol];
    const toContainer = GameState.systems[hoveredSystemSymbol];
    if (!fromContainer || !toContainer)
      return;
    const fromData = GameState.systemData[currentSystemSymbol];
    const toData = GameState.systemData[hoveredSystemSymbol];
    const distance = Math.round(Math.sqrt(Math.pow(fromData.x - toData.x, 2) + Math.pow(fromData.y - toData.y, 2)));
    if (jumpRange && distance < (jumpGateRange ?? jumpRange)) {
      universeGraphics.stroke({
        color: jumpColor,
        width: sizeMultiplier
      });
    } else if (warpRange && distance < warpRange) {
      universeGraphics.stroke({
        color: warpColor,
        width: sizeMultiplier
      });
    } else {
      universeGraphics.stroke({
        color: 16711680,
        width: sizeMultiplier
      });
    }
    universeGraphics.moveTo(fromContainer.x, fromContainer.y);
    universeGraphics.lineTo(toContainer.x, toContainer.y);
    universeGraphicsText.x = (fromContainer.x + toContainer.x) / 2;
    universeGraphicsText.y = (fromContainer.y + toContainer.y) / 2 + 120;
    universeGraphicsText.text = `Distance ${distance}`;
    universeGraphicsText.scale = { x: sizeMultiplier, y: sizeMultiplier };
  }
  if (GameState.currentView === "universe" && GameState.selected?.type === "ship") {
    const currentSystemSymbol = GameState.shipData[GameState.selected.symbol].currentWaypoint.systemSymbol;
    const fromContainer = GameState.systems[currentSystemSymbol];
    const selectedShip = GameState.shipData[GameState.selected?.symbol];
    const warpRange = selectedShip.modules.find((m3) => m3.effectName === "WARP_DRIVE")?.value;
    const jumpRange = selectedShip.modules.find((m3) => m3.effectName === "JUMP_DRIVE")?.value;
    const jumpGateRange = GameState.waypointData[selectedShip.currentWaypoint.symbol]?.jumpgate?.range;
    console.log("jumpgate range", jumpGateRange);
    if (warpRange) {
      universeGraphics.stroke({
        color: warpColor,
        width: sizeMultiplier
      });
      universeGraphics.circle(fromContainer.x, fromContainer.y, warpRange * scale.universe);
    }
    if (jumpRange || jumpGateRange) {
      universeGraphics.stroke({
        color: jumpColor,
        width: sizeMultiplier
      });
      universeGraphics.circle(fromContainer.x, fromContainer.y, (jumpGateRange ?? jumpRange) * scale.universe);
    }
  }
};
var systemTargetingLine = () => {
  if (GameState.hoveredWaypoint && GameState.selected?.type === "ship" && GameState.hoveredWaypoint.symbol !== GameState.shipData[GameState.selected.symbol].currentWaypoint.symbol) {
    console.log("shiptargeting");
    systemGraphics.clear();
    systemGraphics.stroke({
      color: 5583871,
      width: 10
    });
    const currentWaypointSymbol = GameState.shipData[GameState.selected.symbol].currentWaypoint.symbol;
    const hoveredWaypointSymbol = GameState.hoveredWaypoint.symbol;
    const fromContainer = GameState.waypoints[currentWaypointSymbol];
    const toContainer = GameState.waypoints[hoveredWaypointSymbol];
    if (!fromContainer || !toContainer)
      return;
    systemGraphics.moveTo(fromContainer.x, fromContainer.y);
    systemGraphics.lineTo(toContainer.x, toContainer.y);
    const fromData = GameState.waypointData[currentWaypointSymbol];
    const toData = GameState.waypointData[hoveredWaypointSymbol];
    systemGraphicsText.x = (toContainer.x - fromContainer.x) / 2;
    systemGraphicsText.y = (toContainer.y - fromContainer.y) / 2 + 120;
    systemGraphicsText.text = `Distance ${Math.round(Math.sqrt(Math.pow(fromData.x - toData.x, 2) + Math.pow(fromData.y - toData.y, 2)))}`;
  }
};

// src/frontend/index.ts
if (!localStorage.getItem("agent-token")) {
  const agentToken = prompt("Please enter your agent token");
  localStorage.setItem("agent-token", agentToken);
}
document.body.appendChild(app.view);
app.view.addEventListener("contextmenu", (e3) => {
  e3.preventDefault();
});
app.stage.interactive = true;
app.stage.hitArea = app.screen;
app.stage.on("click", (event) => {
  console.log(event);
  deselectListeners.emit("deselect");
  GameState.selected = void 0;
});
await loadAssets();
await createUIElements(app);
await loadPlayerData();
var loadedUniverse = await loadUniverse();
var format2 = Intl.NumberFormat("en");
var lastRefresh = Date.now();
var hidingLabels = false;
var currentRoute;
trpc.event.subscribe(void 0, {
  onData: (data) => {
    console.log("event", data);
    if (data.type == "NAVIGATE") {
      GameState.shipData[data.data.symbol] = data.data;
    }
  }
});
app.ticker.add((dt) => {
  const sizeMultiplier = Math.min(universeView.worldScreenWidth / universeView.screenWidth, 20);
  const shipSizeMultiplier = universeView.worldScreenWidth / universeView.screenWidth;
  credits.displayObject.bitmapText.text = `${format2.format(GameState.agent.credits)}`;
  if (GameState.currentView == "universe") {
    Object.values(loadedUniverse.systems).forEach((ref) => {
      ref.scale = { x: sizeMultiplier, y: sizeMultiplier };
    });
    if (!hidingLabels && shipSizeMultiplier > 15) {
      hidingLabels = true;
      Object.values(loadedUniverse.systems).forEach((ref) => {
        ref.getChildByName("label").visible = false;
        ref.interactive = false;
      });
    } else if (hidingLabels && shipSizeMultiplier < 15) {
      hidingLabels = false;
      Object.values(loadedUniverse.systems).forEach((ref) => {
        ref.getChildByName("label").visible = true;
        ref.interactive = true;
      });
    }
    const worldCoordinates = worldCoordinateToOriginal(universeView.toWorld(app.renderer.plugins.interaction.rootPointerEvent.offset));
    currentCoordinate.text = worldCoordinates.x + ", " + worldCoordinates.y;
    resetShipWaypoints();
    Object.keys(GameState.universeShips).forEach((shipKey) => {
      const shipData = GameState.shipData[shipKey];
      const shipContainer = GameState.universeShips[shipKey];
      shipContainer.scale = { x: shipSizeMultiplier, y: shipSizeMultiplier };
      const shipPosition = positionUniverseShip(shipData);
      shipContainer.x = shipPosition.x;
      shipContainer.y = shipPosition.y;
      const nav = shipContainer.getChildByName("nav");
      if (nav) {
        if (shipPosition.navRot) {
          nav.visible = true;
          shipContainer.getChildByName("ship").rotation = shipPosition.navRot;
          shipContainer.getChildByName("nav").rotation = shipPosition.navRot;
        } else {
          nav.visible = false;
          shipContainer.getChildByName("ship").rotation = 0;
          shipContainer.getChildByName("nav").rotation = 0;
        }
      }
      if (shipData.navStatus === "IN_TRANSIT" && new Date(shipData.arrivalOn).getTime() < Date.now()) {
        shipData.navStatus = "IN_ORBIT";
      }
    });
  } else {
    const systemCoordinate = systemCoordinateToOriginal(systemView.toWorld(app.renderer.plugins.interaction.rootPointerEvent.offset));
    currentCoordinate.text = systemCoordinate.x + ", " + systemCoordinate.y;
    Object.keys(GameState.waypoints).forEach((waypointSymbol) => {
      const waypointItem = GameState.waypoints[waypointSymbol];
      const waypointData = GameState.waypointData[waypointSymbol];
      const newPosition = positionWaypoint(waypointData, Date.now());
      waypointItem.x = newPosition.x;
      waypointItem.y = newPosition.y;
    });
    resetShipWaypoints();
    Object.keys(GameState.systemShips).forEach((shipKey) => {
      const shipData = GameState.shipData[shipKey];
      const shipContainer = GameState.systemShips[shipKey];
      const shipPosition = positionShip(shipData);
      shipContainer.x = shipPosition.x;
      shipContainer.y = shipPosition.y;
      const nav = shipContainer.getChildByName("nav");
      if (nav) {
        if (shipPosition.navRot) {
          nav.visible = true;
          shipContainer.getChildByName("ship").rotation = shipPosition.navRot;
          shipContainer.getChildByName("nav").rotation = shipPosition.navRot;
        } else {
          nav.visible = false;
          shipContainer.getChildByName("ship").rotation = 0;
          shipContainer.getChildByName("nav").rotation = 0;
        }
      }
      if (shipData.navStatus === "IN_TRANSIT" && new Date(shipData.arrivalOn).getTime() < Date.now()) {
        shipData.navStatus = "IN_ORBIT";
      }
    });
  }
  clearGraphics();
  universeTargetingLine(sizeMultiplier);
  systemTargetingLine();
  const homeGraphics = universeView.getChildByName("homeSystem");
  if (GameState.selected) {
    if (GameState.selected.type === "ship") {
      const shipInfo = GameState.shipData[GameState.selected.symbol];
      cruiseModeSelect.displayObject.visible = true;
      if (shipInfo.flightMode && cruiseModeSelect.selectedValue !== shipInfo.flightMode) {
        cruiseModeSelect.setSelectedValue(shipInfo.flightMode);
      }
      const cooldownTime = new Date(shipInfo.reactorCooldownOn).getTime();
      const cooldownValue = cooldownTime > Date.now() ? Math.round((cooldownTime - Date.now()) / 1e3) + "s" : "Ready";
      const navTime = new Date(shipInfo.arrivalOn).getTime();
      const arrivalValue = navTime > Date.now() ? Math.round((navTime - Date.now()) / 1e3) + "s" : "Ready";
      if (GameState.agent.symbol === shipInfo.agent) {
        entityInfo.displayObject.bitmapText.text = `Entity Information
Symbol: ${shipInfo.symbol}
Location: ${shipInfo.currentWaypoint.symbol}
Fuel: ${shipInfo.fuelAvailable}/${shipInfo.fuelCapacity}
Cargo: ${shipInfo.cargoUsed}/${shipInfo.cargoCapacity}
Nav Status: ${shipInfo.navStatus} ${arrivalValue}
Reactor Cooldown: ${cooldownValue}
Action: ${shipInfo.overalGoal}`;
      } else {
        entityInfo.displayObject.bitmapText.text = `Entity Information
Symbol: ${shipInfo.symbol}
Location: ${shipInfo.currentWaypoint.symbol}
Owner: ${shipInfo.agent}
Nav Status: ${shipInfo.navStatus} ${arrivalValue}
Last update: ${Math.round((Date.now() - new Date(shipInfo.updatedAt).getTime()) / 1e3)}s ago`;
      }
      if (GameState.hoveredSystem) {
        if (currentRoute != GameState.hoveredSystem + GameState.selected.symbol) {
          currentRoute = GameState.hoveredSystem + GameState.selected.symbol;
          const route = trpc.getRoute.query({
            fromSystemSymbol: shipInfo.currentSystemSymbol,
            toSystemSymbol: GameState.hoveredSystem.symbol
          }).then((data) => {
            const graphics = universeView.getChildByName("route");
            graphics.clear();
            data.finalPath.forEach((item) => {
              const fromSystem = GameState.systemData[item.source];
              const toSystem = GameState.systemData[item.target];
              const displayCoords = convertToDisplayCoordinates(fromSystem);
              const targetCoords = convertToDisplayCoordinates(toSystem);
              graphics.lineStyle({
                width: 10,
                color: 65280,
                alpha: 0.25
              });
              graphics.moveTo(displayCoords.x, displayCoords.y);
              graphics.lineTo(targetCoords.x, targetCoords.y);
              graphics.closePath();
            });
          });
        }
      } else {
        currentRoute = "";
        const graphics = universeView.getChildByName("route");
        graphics.clear();
      }
      if (GameState.currentView == "universe" && shipInfo.currentBehavior) {
        homeGraphics.clear();
        const homeSystem = GameState.systemData[shipInfo.homeSystemSymbol];
        const shipCoordinates = GameState.universeShips[shipInfo.symbol].position;
        const displayCoordinates = convertToDisplayCoordinates(homeSystem);
        homeGraphics.lineStyle({
          width: 10 * sizeMultiplier,
          color: 65280,
          alpha: 0.5
        });
        homeGraphics.moveTo(shipCoordinates.x, shipCoordinates.y);
        homeGraphics.lineTo(displayCoordinates.x, displayCoordinates.y);
        homeGraphics.closePath();
        homeGraphics.lineStyle({
          width: 10 * sizeMultiplier,
          color: 16777215,
          alpha: 0.5
        });
        const range = shipInfo.behaviorRange * scale.universe;
        homeGraphics.drawRect(displayCoordinates.x - range, displayCoordinates.y - range, range * 2, range * 2);
        homeGraphics.closePath();
      } else {
        homeGraphics.clear();
      }
    } else if (GameState.selected.type === "waypoint") {
      const waypointInfo = GameState.waypointData[GameState.selected.symbol];
      entityInfo.displayObject.bitmapText.text = `Entity Information
Symbol: ${GameState.selected.symbol}
Kind: ${waypointInfo.type}
Traits: ${waypointInfo.traits.length == 0 ? "UNKNOWN" : waypointInfo.traits.map((t2) => t2.name).join(", ")}
Faction: ${waypointInfo.factionSymbol}
Chart: ${waypointInfo.chartSubmittedBy ? `${waypointInfo.chartSubmittedBy} at ${waypointInfo.chartSubmittedOn}` : "None"}`;
      if (waypointInfo.traits.find((t2) => t2.symbol === "MARKETPLACE") && GameState.displayedMarket !== GameState.selected.symbol) {
        GameState.displayedMarket = GameState.selected.symbol;
        trpc.getMarketInfo.query({
          waypoint: GameState.selected.symbol
        }).then((data) => {
          console.log("marketinfo", data);
          marketWindow.clearGoods();
          marketWindow.setGoods(data);
          marketWindow.container.displayObject.x = 400;
          marketWindow.container.displayObject.y = gameHeight - 300;
          marketWindow.container.displayObject.visible = true;
        });
      }
    }
  } else {
    currentRoute = "";
    const graphics = universeView.getChildByName("route");
    graphics.clear();
    homeGraphics.clear();
    GameState.displayedMarket = void 0;
    marketWindow.container.displayObject.visible = false;
    cruiseModeSelect.displayObject.visible = false;
    entityInfo.displayObject.bitmapText.text = `Entity Information`;
  }
  if (universeView.dirty) {
    universeCuller.cull(universeView.getVisibleBounds());
    universeView.dirty = false;
  }
  fps.text = `FPS: ${Math.round(app.ticker.FPS)}`;
});
/*! Bundled license information:

punycode/punycode.js:
  (*! https://mths.be/punycode v1.4.1 by @mathias *)

@trpc/client/dist/httpUtils-0cb58db4.mjs:
  (* istanbul ignore if -- @preserve *)

@trpc/client/dist/links/wsLink.mjs:
  (* istanbul ignore next -- @preserve *)

@pixi/filter-glow/dist/filter-glow.mjs:
  (*!
   * @pixi/filter-glow - v5.2.1
   * Compiled Fri, 24 Mar 2023 22:12:11 UTC
   *
   * @pixi/filter-glow is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

pixi-cull/dist/pixi-cull.es.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
