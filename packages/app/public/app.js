var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/extensions/Extensions.mjs
var ExtensionType, normalizeExtension, normalizeExtensionPriority, extensions;
var init_Extensions = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/extensions/Extensions.mjs"() {
    ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
      ExtensionType2["Renderer"] = "renderer";
      ExtensionType2["Application"] = "application";
      ExtensionType2["WebGLPipes"] = "webgl-pipes";
      ExtensionType2["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";
      ExtensionType2["WebGLSystem"] = "webgl-system";
      ExtensionType2["WebGPUPipes"] = "webgpu-pipes";
      ExtensionType2["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";
      ExtensionType2["WebGPUSystem"] = "webgpu-system";
      ExtensionType2["CanvasSystem"] = "canvas-system";
      ExtensionType2["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";
      ExtensionType2["CanvasPipes"] = "canvas-pipes";
      ExtensionType2["Asset"] = "asset";
      ExtensionType2["LoadParser"] = "load-parser";
      ExtensionType2["ResolveParser"] = "resolve-parser";
      ExtensionType2["CacheParser"] = "cache-parser";
      ExtensionType2["DetectionParser"] = "detection-parser";
      ExtensionType2["MaskEffect"] = "mask-effect";
      return ExtensionType2;
    })(ExtensionType || {});
    normalizeExtension = (ext) => {
      if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
        if (!ext.extension) {
          throw new Error("Extension class must have an extension object");
        }
        const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
        ext = { ...metadata, ref: ext };
      }
      if (typeof ext === "object") {
        ext = { ...ext };
      } else {
        throw new Error("Invalid extension type");
      }
      if (typeof ext.type === "string") {
        ext.type = [ext.type];
      }
      return ext;
    };
    normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;
    extensions = {
      /** @ignore */
      _addHandlers: {},
      /** @ignore */
      _removeHandlers: {},
      /** @ignore */
      _queue: {},
      /**
       * Remove extensions from PixiJS.
       * @param extensions - Extensions to be removed.
       * @returns {PIXI.extensions} For chaining.
       */
      remove(...extensions2) {
        extensions2.map(normalizeExtension).forEach((ext) => {
          ext.type.forEach((type) => this._removeHandlers[type]?.(ext));
        });
        return this;
      },
      /**
       * Register new extensions with PixiJS.
       * @param extensions - The spread of extensions to add to PixiJS.
       * @returns {PIXI.extensions} For chaining.
       */
      add(...extensions2) {
        extensions2.map(normalizeExtension).forEach((ext) => {
          ext.type.forEach((type) => {
            const handlers = this._addHandlers;
            const queue = this._queue;
            if (!handlers[type]) {
              queue[type] = queue[type] || [];
              queue[type].push(ext);
            } else {
              handlers[type](ext);
            }
          });
        });
        return this;
      },
      /**
       * Internal method to handle extensions by name.
       * @param type - The extension type.
       * @param onAdd  - Function for handling when extensions are added/registered passes {@link PIXI.ExtensionFormat}.
       * @param onRemove  - Function for handling when extensions are removed/unregistered passes {@link PIXI.ExtensionFormat}.
       * @returns {PIXI.extensions} For chaining.
       */
      handle(type, onAdd, onRemove) {
        const addHandlers = this._addHandlers;
        const removeHandlers = this._removeHandlers;
        if (addHandlers[type] || removeHandlers[type]) {
          throw new Error(`Extension type ${type} already has a handler`);
        }
        addHandlers[type] = onAdd;
        removeHandlers[type] = onRemove;
        const queue = this._queue;
        if (queue[type]) {
          queue[type].forEach((ext) => onAdd(ext));
          delete queue[type];
        }
        return this;
      },
      /**
       * Handle a type, but using a map by `name` property.
       * @param type - Type of extension to handle.
       * @param map - The object map of named extensions.
       * @returns {PIXI.extensions} For chaining.
       */
      handleByMap(type, map2) {
        return this.handle(
          type,
          (extension) => {
            map2[extension.name] = extension.ref;
          },
          (extension) => {
            delete map2[extension.name];
          }
        );
      },
      /**
       * Handle a type, but using a list of extensions with a `name` property.
       * @param type - Type of extension to handle.
       * @param map - The array of named extensions.
       * @param defaultPriority - Fallback priority if none is defined.
       * @returns {PIXI.extensions} For chaining.
       */
      handleByNamedList(type, map2, defaultPriority = -1) {
        return this.handle(
          type,
          (extension) => {
            const index = map2.findIndex((item) => item.name === extension.name);
            if (index >= 0)
              return;
            map2.push({ name: extension.name, value: extension.ref });
            map2.sort((a, b) => normalizeExtensionPriority(b.value, defaultPriority) - normalizeExtensionPriority(a.value, defaultPriority));
          },
          (extension) => {
            const index = map2.findIndex((item) => item.name === extension.name);
            if (index !== -1) {
              map2.splice(index, 1);
            }
          }
        );
      },
      /**
       * Handle a type, but using a list of extensions.
       * @param type - Type of extension to handle.
       * @param list - The list of extensions.
       * @param defaultPriority - The default priority to use if none is specified.
       * @returns {PIXI.extensions} For chaining.
       */
      handleByList(type, list, defaultPriority = -1) {
        return this.handle(
          type,
          (extension) => {
            if (list.includes(extension.ref)) {
              return;
            }
            list.push(extension.ref);
            list.sort((a, b) => normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));
          },
          (extension) => {
            const index = list.indexOf(extension.ref);
            if (index !== -1) {
              list.splice(index, 1);
            }
          }
        );
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/ticker/const.mjs
var UPDATE_PRIORITY;
var init_const = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/ticker/const.mjs"() {
    UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
      return UPDATE_PRIORITY2;
    })(UPDATE_PRIORITY || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/ticker/TickerListener.mjs
var TickerListener;
var init_TickerListener = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/ticker/TickerListener.mjs"() {
    TickerListener = class {
      /**
       * Constructor
       * @private
       * @param fn - The listener function to be added for one update
       * @param context - The listener context
       * @param priority - The priority for emitting
       * @param once - If the handler should fire once
       */
      constructor(fn, context = null, priority = 0, once = false) {
        this.next = null;
        this.previous = null;
        this._destroyed = false;
        this.fn = fn;
        this.context = context;
        this.priority = priority;
        this.once = once;
      }
      /**
       * Simple compare function to figure out if a function and context match.
       * @private
       * @param fn - The listener function to be added for one update
       * @param context - The listener context
       * @returns `true` if the listener match the arguments
       */
      match(fn, context = null) {
        return this.fn === fn && this.context === context;
      }
      /**
       * Emit by calling the current function.
       * @private
       * @param ticker - The ticker emitting.
       * @returns Next ticker
       */
      emit(ticker) {
        if (this.fn) {
          if (this.context) {
            this.fn.call(this.context, ticker);
          } else {
            this.fn(ticker);
          }
        }
        const redirect = this.next;
        if (this.once) {
          this.destroy(true);
        }
        if (this._destroyed) {
          this.next = null;
        }
        return redirect;
      }
      /**
       * Connect to the list.
       * @private
       * @param previous - Input node, previous listener
       */
      connect(previous) {
        this.previous = previous;
        if (previous.next) {
          previous.next.previous = this;
        }
        this.next = previous.next;
        previous.next = this;
      }
      /**
       * Destroy and don't use after this.
       * @private
       * @param hard - `true` to remove the `next` reference, this
       *        is considered a hard destroy. Soft destroy maintains the next reference.
       * @returns The listener to redirect while emitting or removing.
       */
      destroy(hard = false) {
        this._destroyed = true;
        this.fn = null;
        this.context = null;
        if (this.previous) {
          this.previous.next = this.next;
        }
        if (this.next) {
          this.next.previous = this.previous;
        }
        const redirect = this.next;
        this.next = hard ? null : redirect;
        this.previous = null;
        return redirect;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/ticker/Ticker.mjs
var _Ticker, Ticker;
var init_Ticker = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/ticker/Ticker.mjs"() {
    init_const();
    init_TickerListener();
    _Ticker = class {
      constructor() {
        this.autoStart = false;
        this.deltaTime = 1;
        this.lastTime = -1;
        this.speed = 1;
        this.started = false;
        this._requestId = null;
        this._maxElapsedMS = 100;
        this._minElapsedMS = 0;
        this._protected = false;
        this._lastFrame = -1;
        this._head = new TickerListener(null, null, Infinity);
        this.deltaMS = 1 / _Ticker.targetFPMS;
        this.elapsedMS = 1 / _Ticker.targetFPMS;
        this._tick = (time) => {
          this._requestId = null;
          if (this.started) {
            this.update(time);
            if (this.started && this._requestId === null && this._head.next) {
              this._requestId = requestAnimationFrame(this._tick);
            }
          }
        };
      }
      /**
       * Conditionally requests a new animation frame.
       * If a frame has not already been requested, and if the internal
       * emitter has listeners, a new frame is requested.
       * @private
       */
      _requestIfNeeded() {
        if (this._requestId === null && this._head.next) {
          this.lastTime = performance.now();
          this._lastFrame = this.lastTime;
          this._requestId = requestAnimationFrame(this._tick);
        }
      }
      /**
       * Conditionally cancels a pending animation frame.
       * @private
       */
      _cancelIfNeeded() {
        if (this._requestId !== null) {
          cancelAnimationFrame(this._requestId);
          this._requestId = null;
        }
      }
      /**
       * Conditionally requests a new animation frame.
       * If the ticker has been started it checks if a frame has not already
       * been requested, and if the internal emitter has listeners. If these
       * conditions are met, a new frame is requested. If the ticker has not
       * been started, but autoStart is `true`, then the ticker starts now,
       * and continues with the previous conditions to request a new frame.
       * @private
       */
      _startIfPossible() {
        if (this.started) {
          this._requestIfNeeded();
        } else if (this.autoStart) {
          this.start();
        }
      }
      /**
       * Register a handler for tick events. Calls continuously unless
       * it is removed or the ticker is stopped.
       * @param fn - The listener function to be added for updates
       * @param context - The listener context
       * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
       * @returns This instance of a ticker
       */
      add(fn, context, priority = UPDATE_PRIORITY.NORMAL) {
        return this._addListener(new TickerListener(fn, context, priority));
      }
      /**
       * Add a handler for the tick event which is only execute once.
       * @param fn - The listener function to be added for one update
       * @param context - The listener context
       * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
       * @returns This instance of a ticker
       */
      addOnce(fn, context, priority = UPDATE_PRIORITY.NORMAL) {
        return this._addListener(new TickerListener(fn, context, priority, true));
      }
      /**
       * Internally adds the event handler so that it can be sorted by priority.
       * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
       * before the rendering.
       * @private
       * @param listener - Current listener being added.
       * @returns This instance of a ticker
       */
      _addListener(listener) {
        let current = this._head.next;
        let previous = this._head;
        if (!current) {
          listener.connect(previous);
        } else {
          while (current) {
            if (listener.priority > current.priority) {
              listener.connect(previous);
              break;
            }
            previous = current;
            current = current.next;
          }
          if (!listener.previous) {
            listener.connect(previous);
          }
        }
        this._startIfPossible();
        return this;
      }
      /**
       * Removes any handlers matching the function and context parameters.
       * If no handlers are left after removing, then it cancels the animation frame.
       * @param fn - The listener function to be removed
       * @param context - The listener context to be removed
       * @returns This instance of a ticker
       */
      remove(fn, context) {
        let listener = this._head.next;
        while (listener) {
          if (listener.match(fn, context)) {
            listener = listener.destroy();
          } else {
            listener = listener.next;
          }
        }
        if (!this._head.next) {
          this._cancelIfNeeded();
        }
        return this;
      }
      /**
       * The number of listeners on this ticker, calculated by walking through linked list
       * @readonly
       * @member {number}
       */
      get count() {
        if (!this._head) {
          return 0;
        }
        let count2 = 0;
        let current = this._head;
        while (current = current.next) {
          count2++;
        }
        return count2;
      }
      /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */
      start() {
        if (!this.started) {
          this.started = true;
          this._requestIfNeeded();
        }
      }
      /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */
      stop() {
        if (this.started) {
          this.started = false;
          this._cancelIfNeeded();
        }
      }
      /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */
      destroy() {
        if (!this._protected) {
          this.stop();
          let listener = this._head.next;
          while (listener) {
            listener = listener.destroy(true);
          }
          this._head.destroy();
          this._head = null;
        }
      }
      /**
       * Triggers an update. An update entails setting the
       * current {@link PIXI.Ticker#elapsedMS},
       * the current {@link PIXI.Ticker#deltaTime},
       * invoking all listeners with current deltaTime,
       * and then finally setting {@link PIXI.Ticker#lastTime}
       * with the value of currentTime that was provided.
       * This method will be called automatically by animation
       * frame callbacks if the ticker instance has been started
       * and listeners are added.
       * @param {number} [currentTime=performance.now()] - the current time of execution
       */
      update(currentTime = performance.now()) {
        let elapsedMS;
        if (currentTime > this.lastTime) {
          elapsedMS = this.elapsedMS = currentTime - this.lastTime;
          if (elapsedMS > this._maxElapsedMS) {
            elapsedMS = this._maxElapsedMS;
          }
          elapsedMS *= this.speed;
          if (this._minElapsedMS) {
            const delta = currentTime - this._lastFrame | 0;
            if (delta < this._minElapsedMS) {
              return;
            }
            this._lastFrame = currentTime - delta % this._minElapsedMS;
          }
          this.deltaMS = elapsedMS;
          this.deltaTime = this.deltaMS * _Ticker.targetFPMS;
          const head = this._head;
          let listener = head.next;
          while (listener) {
            listener = listener.emit(this);
          }
          if (!head.next) {
            this._cancelIfNeeded();
          }
        } else {
          this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        }
        this.lastTime = currentTime;
      }
      /**
       * The frames per second at which this ticker is running.
       * The default is approximately 60 in most modern browsers.
       * **Note:** This does not factor in the value of
       * {@link PIXI.Ticker#speed}, which is specific
       * to scaling {@link PIXI.Ticker#deltaTime}.
       * @member {number}
       * @readonly
       */
      get FPS() {
        return 1e3 / this.elapsedMS;
      }
      /**
       * Manages the maximum amount of milliseconds allowed to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This value is used to cap {@link PIXI.Ticker#deltaTime},
       * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
       * When setting this property it is clamped to a value between
       * `0` and `Ticker.targetFPMS * 1000`.
       * @member {number}
       * @default 10
       */
      get minFPS() {
        return 1e3 / this._maxElapsedMS;
      }
      set minFPS(fps2) {
        const minFPS = Math.min(this.maxFPS, fps2);
        const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);
        this._maxElapsedMS = 1 / minFPMS;
      }
      /**
       * Manages the minimum amount of milliseconds required to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This will effect the measured value of {@link PIXI.Ticker#FPS}.
       * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
       * Otherwise it will be at least `minFPS`
       * @member {number}
       * @default 0
       */
      get maxFPS() {
        if (this._minElapsedMS) {
          return Math.round(1e3 / this._minElapsedMS);
        }
        return 0;
      }
      set maxFPS(fps2) {
        if (fps2 === 0) {
          this._minElapsedMS = 0;
        } else {
          const maxFPS = Math.max(this.minFPS, fps2);
          this._minElapsedMS = 1 / (maxFPS / 1e3);
        }
      }
      /**
       * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
       * {@link PIXI.VideoResource} to update animation frames / video textures.
       *
       * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
       * @example
       * import { Ticker } from 'pixi.js';
       *
       * const ticker = Ticker.shared;
       * // Set this to prevent starting this ticker when listeners are added.
       * // By default this is true only for the PIXI.Ticker.shared instance.
       * ticker.autoStart = false;
       *
       * // FYI, call this to ensure the ticker is stopped. It should be stopped
       * // if you have not attempted to render anything yet.
       * ticker.stop();
       *
       * // Call this when you are ready for a running shared ticker.
       * ticker.start();
       * @example
       * import { autoDetectRenderer, Container } from 'pixi.js';
       *
       * // You may use the shared ticker to render...
       * const renderer = autoDetectRenderer();
       * const stage = new Container();
       * document.body.appendChild(renderer.view);
       * ticker.add((time) => renderer.render(stage));
       *
       * // Or you can just update it manually.
       * ticker.autoStart = false;
       * ticker.stop();
       * const animate = (time) => {
       *     ticker.update(time);
       *     renderer.render(stage);
       *     requestAnimationFrame(animate);
       * };
       * animate(performance.now());
       * @member {PIXI.Ticker}
       * @static
       */
      static get shared() {
        if (!_Ticker._shared) {
          const shared = _Ticker._shared = new _Ticker();
          shared.autoStart = true;
          shared._protected = true;
        }
        return _Ticker._shared;
      }
      /**
       * The system ticker instance used by {@link PIXI.BasePrepare} for core timing
       * functionality that shouldn't usually need to be paused, unlike the `shared`
       * ticker which drives visual animations and rendering which may want to be paused.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       * @member {PIXI.Ticker}
       * @static
       */
      static get system() {
        if (!_Ticker._system) {
          const system = _Ticker._system = new _Ticker();
          system.autoStart = true;
          system._protected = true;
        }
        return _Ticker._system;
      }
    };
    Ticker = _Ticker;
    Ticker.targetFPMS = 0.06;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/ticker/TickerPlugin.mjs
var TickerPlugin;
var init_TickerPlugin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/ticker/TickerPlugin.mjs"() {
    init_Extensions();
    init_const();
    init_Ticker();
    TickerPlugin = class {
      /**
       * Initialize the plugin with scope of application instance
       * @static
       * @private
       * @param {object} [options] - See application options
       */
      static init(options) {
        options = Object.assign({
          autoStart: true,
          sharedTicker: false
        }, options);
        Object.defineProperty(
          this,
          "ticker",
          {
            set(ticker) {
              if (this._ticker) {
                this._ticker.remove(this.render, this);
              }
              this._ticker = ticker;
              if (ticker) {
                ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
              }
            },
            get() {
              return this._ticker;
            }
          }
        );
        this.stop = () => {
          this._ticker.stop();
        };
        this.start = () => {
          this._ticker.start();
        };
        this._ticker = null;
        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
        if (options.autoStart) {
          this.start();
        }
      }
      /**
       * Clean up the ticker, scoped to application.
       * @static
       * @private
       */
      static destroy() {
        if (this._ticker) {
          const oldTicker = this._ticker;
          this.ticker = null;
          oldTicker.destroy();
        }
      }
    };
    TickerPlugin.extension = ExtensionType.Application;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/app/ResizePlugin.mjs
var ResizePlugin;
var init_ResizePlugin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/app/ResizePlugin.mjs"() {
    init_Extensions();
    ResizePlugin = class {
      /**
       * Initialize the plugin with scope of application instance
       * @static
       * @private
       * @param {object} [options] - See application options
       */
      static init(options) {
        Object.defineProperty(
          this,
          "resizeTo",
          /**
           * The HTML element or window to automatically resize the
           * renderer's view element to match width and height.
           * @member {Window|HTMLElement}
           * @name resizeTo
           * @memberof PIXI.Application#
           */
          {
            set(dom) {
              globalThis.removeEventListener("resize", this.queueResize);
              this._resizeTo = dom;
              if (dom) {
                globalThis.addEventListener("resize", this.queueResize);
                this.resize();
              }
            },
            get() {
              return this._resizeTo;
            }
          }
        );
        this.queueResize = () => {
          if (!this._resizeTo) {
            return;
          }
          this.cancelResize();
          this._resizeId = requestAnimationFrame(() => this.resize());
        };
        this.cancelResize = () => {
          if (this._resizeId) {
            cancelAnimationFrame(this._resizeId);
            this._resizeId = null;
          }
        };
        this.resize = () => {
          if (!this._resizeTo) {
            return;
          }
          this.cancelResize();
          let width;
          let height;
          if (this._resizeTo === globalThis.window) {
            width = globalThis.innerWidth;
            height = globalThis.innerHeight;
          } else {
            const { clientWidth, clientHeight } = this._resizeTo;
            width = clientWidth;
            height = clientHeight;
          }
          this.renderer.resize(width, height);
          this.render();
        };
        this._resizeId = null;
        this._resizeTo = null;
        this.resizeTo = options.resizeTo || null;
      }
      /**
       * Clean up the ticker, scoped to application
       * @static
       * @private
       */
      static destroy() {
        globalThis.removeEventListener("resize", this.queueResize);
        this.cancelResize();
        this.cancelResize = null;
        this.queueResize = null;
        this.resizeTo = null;
        this.resize = null;
      }
    };
    ResizePlugin.extension = ExtensionType.Application;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/app/init.mjs
var init_init = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/app/init.mjs"() {
    init_Extensions();
    init_TickerPlugin();
    init_ResizePlugin();
    extensions.add(ResizePlugin);
    extensions.add(TickerPlugin);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs
var LoaderParserPriority;
var init_LoaderParser = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs"() {
    LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
      LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
      LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
      LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
      return LoaderParserPriority2;
    })(LoaderParserPriority || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs
var copySearchParams;
var init_copySearchParams = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs"() {
    copySearchParams = (targetUrl, sourceUrl) => {
      const searchParams = sourceUrl.split("?")[1];
      if (searchParams) {
        targetUrl += `?${searchParams}`;
      }
      return targetUrl;
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/settings/adapter/adapter.mjs
var BrowserAdapter;
var init_adapter = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/settings/adapter/adapter.mjs"() {
    BrowserAdapter = {
      /**
       * Creates a canvas element of the given size.
       * This canvas is created using the browser's native canvas element.
       * @param width - width of the canvas
       * @param height - height of the canvas
       */
      createCanvas: (width, height) => {
        const canvas2 = document.createElement("canvas");
        canvas2.width = width;
        canvas2.height = height;
        return canvas2;
      },
      getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
      getWebGLRenderingContext: () => WebGLRenderingContext,
      getNavigator: () => navigator,
      getBaseUrl: () => document.baseURI ?? window.location.href,
      getFontFaceSet: () => document.fonts,
      fetch: (url, options) => fetch(url, options),
      parseXML: (xml) => {
        const parser = new DOMParser();
        return parser.parseFromString(xml, "text/xml");
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/settings/settings.mjs
var settings;
var init_settings = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/settings/settings.mjs"() {
    init_adapter();
    settings = {
      /**
       * This adapter is used to call methods that are platform dependent.
       * For example `document.createElement` only runs on the web but fails in node environments.
       * This allows us to support more platforms by abstracting away specific implementations per platform.
       *
       * By default the adapter is set to work in the browser. However you can create your own
       * by implementing the `IAdapter` interface. See `IAdapter` for more information.
       * @name ADAPTER
       * @memberof PIXI.settings
       * @type {PIXI.Adapter}
       * @default PIXI.BrowserAdapter
       */
      ADAPTER: BrowserAdapter,
      /**
       * The prefix that denotes a URL is for a retina asset.
       * @static
       * @name RETINA_PREFIX
       * @memberof PIXI.settings
       * @type {RegExp}
       * @default /@([0-9\.]+)x/
       * @example `@2x`
       */
      RETINA_PREFIX: /@([0-9\.]+)x/,
      /**
       * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported` function.
       * If set to true, a WebGL renderer can fail to be created if the browser thinks there could be performance issues when
       * using WebGL.
       *
       * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many scenarios as possible.
       * However, some users may have a poor experience, for example, if a user has a gpu or driver version blacklisted by the
       * browser.
       *
       * If your application requires high performance rendering, you may wish to set this to false.
       * We recommend one of two options if you decide to set this flag to false:
       *
       * 1: Use the `pixi.js-legacy` package, which includes a Canvas renderer as a fallback in case high performance WebGL is
       *    not supported.
       *
       * 2: Call `isWebGLSupported` (which if found in the PIXI.utils package) in your code before attempting to create a
       *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their
       *    device & browser combination does not support high performance WebGL.
       *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.
       * @static
       * @name FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
       * @memberof PIXI.settings
       * @type {boolean}
       * @default false
       */
      FAIL_IF_MAJOR_PERFORMANCE_CAVEAT: false,
      /**
       * Default resolution / device pixel ratio of the renderer.
       * @static
       * @name RESOLUTION
       * @memberof PIXI.settings
       * @type {number}
       * @default 1
       */
      RESOLUTION: 2
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/path.mjs
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
  }
}
function removeUrlParams(url) {
  const re = url.split("?")[0];
  return re.split("#")[0];
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll(str, find, replace) {
  return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
}
function normalizeStringPosix(path2, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = -1;
  for (let i = 0; i <= path2.length; ++i) {
    if (i < path2.length) {
      code = path2.charCodeAt(i);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path2.slice(lastSlash + 1, i)}`;
        } else {
          res = path2.slice(lastSlash + 1, i);
        }
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
var path;
var init_path = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/path.mjs"() {
    init_settings();
    path = {
      /**
       * Converts a path to posix format.
       * @param path - The path to convert to posix
       */
      toPosix(path2) {
        return replaceAll(path2, "\\", "/");
      },
      /**
       * Checks if the path is a URL
       * @param path - The path to check
       */
      isUrl(path2) {
        return /^https?:/.test(this.toPosix(path2));
      },
      /**
       * Checks if the path is a data URL
       * @param path - The path to check
       */
      isDataUrl(path2) {
        return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
      },
      /**
       * Checks if the path has a protocol e.g. http://
       * This will return true for windows file paths
       * @param path - The path to check
       */
      hasProtocol(path2) {
        return /^[^/:]+:\//.test(this.toPosix(path2));
      },
      /**
       * Returns the protocol of the path e.g. http://, C:/, file:///
       * @param path - The path to get the protocol from
       */
      getProtocol(path2) {
        assertPath(path2);
        path2 = this.toPosix(path2);
        let protocol = "";
        const isFile = /^file:\/\/\//.exec(path2);
        const isHttp = /^[^/:]+:\/\//.exec(path2);
        const isWindows = /^[^/:]+:\//.exec(path2);
        if (isFile || isHttp || isWindows) {
          const arr = isFile?.[0] || isHttp?.[0] || isWindows?.[0];
          protocol = arr;
          path2 = path2.slice(arr.length);
        }
        return protocol;
      },
      /**
       * Converts URL to an absolute path.
       * When loading from a Web Worker, we must use absolute paths.
       * If the URL is already absolute we return it as is
       * If it's not, we convert it
       * @param url - The URL to test
       * @param customBaseUrl - The base URL to use
       * @param customRootUrl - The root URL to use
       */
      toAbsolute(url, customBaseUrl, customRootUrl) {
        if (this.isDataUrl(url))
          return url;
        const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? settings.ADAPTER.getBaseUrl()));
        const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
        assertPath(url);
        url = this.toPosix(url);
        if (url.startsWith("/")) {
          return path.join(rootUrl, url.slice(1));
        }
        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);
        return absolutePath;
      },
      /**
       * Normalizes the given path, resolving '..' and '.' segments
       * @param path - The path to normalize
       */
      normalize(path2) {
        path2 = this.toPosix(path2);
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        let protocol = "";
        const isAbsolute = path2.startsWith("/");
        if (this.hasProtocol(path2)) {
          protocol = this.rootname(path2);
          path2 = path2.slice(protocol.length);
        }
        const trailingSeparator = path2.endsWith("/");
        path2 = normalizeStringPosix(path2, false);
        if (path2.length > 0 && trailingSeparator)
          path2 += "/";
        if (isAbsolute)
          return `/${path2}`;
        return protocol + path2;
      },
      /**
       * Determines if path is an absolute path.
       * Absolute paths can be urls, data urls, or paths on disk
       * @param path - The path to test
       */
      isAbsolute(path2) {
        assertPath(path2);
        path2 = this.toPosix(path2);
        if (this.hasProtocol(path2))
          return true;
        return path2.startsWith("/");
      },
      /**
       * Joins all given path segments together using the platform-specific separator as a delimiter,
       * then normalizes the resulting path
       * @param segments - The segments of the path to join
       */
      join(...segments) {
        if (segments.length === 0) {
          return ".";
        }
        let joined;
        for (let i = 0; i < segments.length; ++i) {
          const arg = segments[i];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else {
              const prevArg = segments[i - 1] ?? "";
              if (this.extname(prevArg)) {
                joined += `/../${arg}`;
              } else {
                joined += `/${arg}`;
              }
            }
          }
        }
        if (joined === void 0) {
          return ".";
        }
        return this.normalize(joined);
      },
      /**
       * Returns the directory name of a path
       * @param path - The path to parse
       */
      dirname(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        path2 = this.toPosix(path2);
        let code = path2.charCodeAt(0);
        const hasRoot = code === 47;
        let end = -1;
        let matchedSlash = true;
        const proto = this.getProtocol(path2);
        const origpath = path2;
        path2 = path2.slice(proto.length);
        for (let i = path2.length - 1; i >= 1; --i) {
          code = path2.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
        if (hasRoot && end === 1)
          return "//";
        return proto + path2.slice(0, end);
      },
      /**
       * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
       * @param path - The path to parse
       */
      rootname(path2) {
        assertPath(path2);
        path2 = this.toPosix(path2);
        let root = "";
        if (path2.startsWith("/"))
          root = "/";
        else {
          root = this.getProtocol(path2);
        }
        if (this.isUrl(path2)) {
          const index = path2.indexOf("/", root.length);
          if (index !== -1) {
            root = path2.slice(0, index);
          } else
            root = path2;
          if (!root.endsWith("/"))
            root += "/";
        }
        return root;
      },
      /**
       * Returns the last portion of a path
       * @param path - The path to test
       * @param ext - Optional extension to remove
       */
      basename(path2, ext) {
        assertPath(path2);
        if (ext)
          assertPath(ext);
        path2 = removeUrlParams(this.toPosix(path2));
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
          if (ext.length === path2.length && ext === path2)
            return "";
          let extIdx = ext.length - 1;
          let firstNonSlashEnd = -1;
          for (i = path2.length - 1; i >= 0; --i) {
            const code = path2.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path2.length;
          return path2.slice(start, end);
        }
        for (i = path2.length - 1; i >= 0; --i) {
          if (path2.charCodeAt(i) === 47) {
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
        }
        if (end === -1)
          return "";
        return path2.slice(start, end);
      },
      /**
       * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
       * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
       * the first character of the basename of path, an empty string is returned.
       * @param path - The path to parse
       */
      extname(path2) {
        assertPath(path2);
        path2 = removeUrlParams(this.toPosix(path2));
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        for (let i = path2.length - 1; i >= 0; --i) {
          const code = path2.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path2.slice(startDot, end);
      },
      /**
       * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
       * @param path - The path to parse
       */
      parse(path2) {
        assertPath(path2);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path2.length === 0)
          return ret;
        path2 = removeUrlParams(this.toPosix(path2));
        let code = path2.charCodeAt(0);
        const isAbsolute = this.isAbsolute(path2);
        let start;
        const protocol = "";
        ret.root = this.rootname(path2);
        if (isAbsolute || this.hasProtocol(path2)) {
          start = 1;
        } else {
          start = 0;
        }
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let i = path2.length - 1;
        let preDotState = 0;
        for (; i >= start; --i) {
          code = path2.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute)
              ret.base = ret.name = path2.slice(1, end);
            else
              ret.base = ret.name = path2.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path2.slice(1, startDot);
            ret.base = path2.slice(1, end);
          } else {
            ret.name = path2.slice(startPart, startDot);
            ret.base = path2.slice(startPart, end);
          }
          ret.ext = path2.slice(startDot, end);
        }
        ret.dir = this.dirname(path2);
        if (protocol)
          ret.dir = protocol + ret.dir;
        return ret;
      },
      sep: "/",
      delimiter: ":"
    };
  }
});

// ../../node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "../../node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter3.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter3.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j2;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                  args[j2 - 1] = arguments[j2];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter3.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter3;
    }
  }
});

// ../../node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.mjs
var import_index, eventemitter3_default;
var init_eventemitter3 = __esm({
  "../../node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.mjs"() {
    import_index = __toESM(require_eventemitter3(), 1);
    eventemitter3_default = import_index.default;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/maths/Point.mjs
var Point, tempPoint;
var init_Point = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/maths/Point.mjs"() {
    Point = class _Point {
      /**
       * Creates a new `Point`
       * @param {number} [x=0] - position of the point on the x axis
       * @param {number} [y=0] - position of the point on the y axis
       */
      constructor(x2 = 0, y = 0) {
        this.x = 0;
        this.y = 0;
        this.x = x2;
        this.y = y;
      }
      /**
       * Creates a clone of this point
       * @returns A clone of this point
       */
      clone() {
        return new _Point(this.x, this.y);
      }
      /**
       * Copies `x` and `y` from the given point into this point
       * @param p - The point to copy from
       * @returns The point instance itself
       */
      copyFrom(p) {
        this.set(p.x, p.y);
        return this;
      }
      /**
       * Copies this point's x and y into the given point (`p`).
       * @param p - The point to copy to. Can be any of type that is or extends `PointData`
       * @returns The point (`p`) with values updated
       */
      copyTo(p) {
        p.set(this.x, this.y);
        return p;
      }
      /**
       * Accepts another point (`p`) and returns `true` if the given point is equal to this point
       * @param p - The point to check
       * @returns Returns `true` if both `x` and `y` are equal
       */
      equals(p) {
        return p.x === this.x && p.y === this.y;
      }
      /**
       * Sets the point to a new `x` and `y` position.
       * If `y` is omitted, both `x` and `y` will be set to `x`.
       * @param {number} [x=0] - position of the point on the `x` axis
       * @param {number} [y=x] - position of the point on the `y` axis
       * @returns The point instance itself
       */
      set(x2 = 0, y = x2) {
        this.x = x2;
        this.y = y;
        return this;
      }
      toString() {
        return `[@pixi/math:Point x=${this.x} y=${this.y}]`;
      }
      static get shared() {
        tempPoint.x = 0;
        tempPoint.y = 0;
        return tempPoint;
      }
    };
    tempPoint = new Point();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs
var tempPoints, Rectangle;
var init_Rectangle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs"() {
    init_Point();
    tempPoints = [new Point(), new Point(), new Point(), new Point()];
    Rectangle = class _Rectangle {
      /**
       * @param x - The X coordinate of the upper-left corner of the rectangle
       * @param y - The Y coordinate of the upper-left corner of the rectangle
       * @param width - The overall width of the rectangle
       * @param height - The overall height of the rectangle
       */
      constructor(x2 = 0, y = 0, width = 0, height = 0) {
        this.type = "rectangle";
        this.x = Number(x2);
        this.y = Number(y);
        this.width = Number(width);
        this.height = Number(height);
      }
      /** Returns the left edge of the rectangle. */
      get left() {
        return this.x;
      }
      /** Returns the right edge of the rectangle. */
      get right() {
        return this.x + this.width;
      }
      /** Returns the top edge of the rectangle. */
      get top() {
        return this.y;
      }
      /** Returns the bottom edge of the rectangle. */
      get bottom() {
        return this.y + this.height;
      }
      /** A constant empty rectangle. */
      static get EMPTY() {
        return new _Rectangle(0, 0, 0, 0);
      }
      /**
       * Creates a clone of this Rectangle
       * @returns a copy of the rectangle
       */
      clone() {
        return new _Rectangle(this.x, this.y, this.width, this.height);
      }
      /**
       * Copies another rectangle to this one.
       * @param rectangle - The rectangle to copy from.
       * @returns Returns itself.
       */
      copyFrom(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
      }
      /**
       * Copies this rectangle to another one.
       * @param rectangle - The rectangle to copy to.
       * @returns Returns given parameter.
       */
      copyTo(rectangle) {
        rectangle.copyFrom(this);
        return rectangle;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this Rectangle
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coordinates are within this Rectangle
       */
      contains(x2, y) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x2 >= this.x && x2 < this.x + this.width) {
          if (y >= this.y && y < this.y + this.height) {
            return true;
          }
        }
        return false;
      }
      /**
       * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
       * Returns true only if the area of the intersection is >0, this means that Rectangles
       * sharing a side are not overlapping. Another side effect is that an arealess rectangle
       * (width or height equal to zero) can't intersect any other rectangle.
       * @param {Rectangle} other - The Rectangle to intersect with `this`.
       * @param {Matrix} transform - The transformation matrix of `other`.
       * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
       */
      intersects(other, transform) {
        if (!transform) {
          const x02 = this.x < other.x ? other.x : this.x;
          const x12 = this.right > other.right ? other.right : this.right;
          if (x12 <= x02) {
            return false;
          }
          const y02 = this.y < other.y ? other.y : this.y;
          const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
          return y12 > y02;
        }
        const x0 = this.left;
        const x1 = this.right;
        const y0 = this.top;
        const y1 = this.bottom;
        if (x1 <= x0 || y1 <= y0) {
          return false;
        }
        const lt = tempPoints[0].set(other.left, other.top);
        const lb = tempPoints[1].set(other.left, other.bottom);
        const rt = tempPoints[2].set(other.right, other.top);
        const rb = tempPoints[3].set(other.right, other.bottom);
        if (rt.x <= lt.x || lb.y <= lt.y) {
          return false;
        }
        const s = Math.sign(transform.a * transform.d - transform.b * transform.c);
        if (s === 0) {
          return false;
        }
        transform.apply(lt, lt);
        transform.apply(lb, lb);
        transform.apply(rt, rt);
        transform.apply(rb, rb);
        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
          return false;
        }
        const nx = s * (lb.y - lt.y);
        const ny = s * (lt.x - lb.x);
        const n00 = nx * x0 + ny * y0;
        const n10 = nx * x1 + ny * y0;
        const n01 = nx * x0 + ny * y1;
        const n11 = nx * x1 + ny * y1;
        if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
          return false;
        }
        const mx = s * (lt.y - rt.y);
        const my = s * (rt.x - lt.x);
        const m00 = mx * x0 + my * y0;
        const m10 = mx * x1 + my * y0;
        const m01 = mx * x0 + my * y1;
        const m11 = mx * x1 + my * y1;
        if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
          return false;
        }
        return true;
      }
      /**
       * Pads the rectangle making it grow in all directions.
       * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
       * @param paddingX - The horizontal padding amount.
       * @param paddingY - The vertical padding amount.
       * @returns Returns itself.
       */
      pad(paddingX = 0, paddingY = paddingX) {
        this.x -= paddingX;
        this.y -= paddingY;
        this.width += paddingX * 2;
        this.height += paddingY * 2;
        return this;
      }
      /**
       * Fits this rectangle around the passed one.
       * @param rectangle - The rectangle to fit.
       * @returns Returns itself.
       */
      fit(rectangle) {
        const x1 = Math.max(this.x, rectangle.x);
        const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
        const y1 = Math.max(this.y, rectangle.y);
        const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = Math.max(x2 - x1, 0);
        this.y = y1;
        this.height = Math.max(y2 - y1, 0);
        return this;
      }
      /**
       * Enlarges rectangle that way its corners lie on grid
       * @param resolution - resolution
       * @param eps - precision
       * @returns Returns itself.
       */
      ceil(resolution = 1, eps = 1e-3) {
        const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
        const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
        this.x = Math.floor((this.x + eps) * resolution) / resolution;
        this.y = Math.floor((this.y + eps) * resolution) / resolution;
        this.width = x2 - this.x;
        this.height = y2 - this.y;
        return this;
      }
      /**
       * Enlarges this rectangle to include the passed rectangle.
       * @param rectangle - The rectangle to include.
       * @returns Returns itself.
       */
      enlarge(rectangle) {
        const x1 = Math.min(this.x, rectangle.x);
        const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
        const y1 = Math.min(this.y, rectangle.y);
        const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = x2 - x1;
        this.y = y1;
        this.height = y2 - y1;
        return this;
      }
      /**
       * Returns the framing rectangle of the rectangle as a Rectangle object
       * @param out - optional rectangle to store the result
       * @returns The framing rectangle
       */
      getBounds(out2) {
        out2 = out2 || new _Rectangle();
        out2.copyFrom(this);
        return out2;
      }
      toString() {
        return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/utils/convertToList.mjs
var convertToList;
var init_convertToList = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/utils/convertToList.mjs"() {
    convertToList = (input, transform) => {
      if (!Array.isArray(input)) {
        input = [input];
      }
      if (!transform) {
        return input;
      }
      return input.map((item) => {
        if (typeof item === "string") {
          return transform(item);
        }
        return item;
      });
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/cache/Cache.mjs
var CacheClass, Cache;
var init_Cache = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/cache/Cache.mjs"() {
    init_convertToList();
    CacheClass = class {
      constructor() {
        this._parsers = [];
        this._cache = /* @__PURE__ */ new Map();
        this._cacheMap = /* @__PURE__ */ new Map();
      }
      /** Clear all entries. */
      reset() {
        this._cacheMap.clear();
        this._cache.clear();
      }
      /**
       * Check if the key exists
       * @param key - The key to check
       */
      has(key) {
        return this._cache.has(key);
      }
      /**
       * Fetch entry by key
       * @param key - The key of the entry to get
       */
      get(key) {
        const result = this._cache.get(key);
        if (!result) {
          console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
        }
        return result;
      }
      /**
       * Set a value by key or keys name
       * @param key - The key or keys to set
       * @param value - The value to store in the cache or from which cacheable assets will be derived.
       */
      set(key, value) {
        const keys = convertToList(key);
        let cacheableAssets;
        for (let i = 0; i < this.parsers.length; i++) {
          const parser = this.parsers[i];
          if (parser.test(value)) {
            cacheableAssets = parser.getCacheableAssets(keys, value);
            break;
          }
        }
        if (!cacheableAssets) {
          cacheableAssets = {};
          keys.forEach((key2) => {
            cacheableAssets[key2] = value;
          });
        }
        const cacheKeys = Object.keys(cacheableAssets);
        const cachedAssets = {
          cacheKeys,
          keys
        };
        keys.forEach((key2) => {
          this._cacheMap.set(key2, cachedAssets);
        });
        cacheKeys.forEach((key2) => {
          if (this._cache.has(key2) && this._cache.get(key2) !== value) {
            console.warn("[Cache] already has key:", key2);
          }
          this._cache.set(key2, cacheableAssets[key2]);
        });
      }
      /**
       * Remove entry by key
       *
       * This function will also remove any associated alias from the cache also.
       * @param key - The key of the entry to remove
       */
      remove(key) {
        this._cacheMap.get(key);
        if (!this._cacheMap.has(key)) {
          console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
          return;
        }
        const cacheMap = this._cacheMap.get(key);
        const cacheKeys = cacheMap.cacheKeys;
        cacheKeys.forEach((key2) => {
          this._cache.delete(key2);
        });
        cacheMap.keys.forEach((key2) => {
          this._cacheMap.delete(key2);
        });
      }
      /** All loader parsers registered */
      get parsers() {
        return this._parsers;
      }
    };
    Cache = new CacheClass();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/NOOP.mjs
var NOOP;
var init_NOOP = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/NOOP.mjs"() {
    NOOP = () => {
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/createIdFromString.mjs
function createIdFromString(value, groupId) {
  let id = idHash[value];
  if (id === void 0) {
    if (idCounts[groupId] === void 0) {
      idCounts[groupId] = 1;
    }
    idHash[value] = id = idCounts[groupId]++;
  }
  return id;
}
var idCounts, idHash;
var init_createIdFromString = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/createIdFromString.mjs"() {
    idCounts = {};
    idHash = {};
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs
var UID, _TextureStyle, TextureStyle;
var init_TextureStyle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs"() {
    init_eventemitter3();
    init_createIdFromString();
    UID = 0;
    _TextureStyle = class extends eventemitter3_default {
      constructor(options = {}) {
        super();
        this.resourceType = "textureSampler";
        this.uid = UID++;
        this._maxAnisotropy = 1;
        options = { ..._TextureStyle.DEFAULT, ...options };
        this.addressMode = options.addressMode;
        this.addressModeU = options.addressModeU ?? this.addressModeU;
        this.addressModeV = options.addressModeV ?? this.addressModeV;
        this.addressModeW = options.addressModeW ?? this.addressModeW;
        this.scaleMode = options.scaleMode;
        this.magFilter = options.magFilter ?? this.magFilter;
        this.minFilter = options.minFilter ?? this.minFilter;
        this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;
        this.lodMinClamp = options.lodMinClamp;
        this.lodMaxClamp = options.lodMaxClamp;
        this.compare = options.compare;
        this.maxAnisotropy = options.maxAnisotropy ?? 1;
      }
      set addressMode(value) {
        this.addressModeU = value;
        this.addressModeV = value;
        this.addressModeW = value;
      }
      get addressMode() {
        return this.addressModeU;
      }
      set scaleMode(value) {
        this.magFilter = value;
        this.minFilter = value;
        this.mipmapFilter = value;
      }
      get scaleMode() {
        return this.magFilter;
      }
      set maxAnisotropy(value) {
        this._maxAnisotropy = Math.min(value, 16);
        if (this._maxAnisotropy > 1) {
          this.scaleMode = "linear";
        }
      }
      get maxAnisotropy() {
        return this._maxAnisotropy;
      }
      // TODO - move this to WebGL?
      get resourceId() {
        return this._resourceId || this.generateResourceId();
      }
      update() {
        this.emit("change", this);
        this._resourceId = null;
      }
      generateResourceId() {
        const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
        this._resourceId = createIdFromString(bigKey, "sampler");
        return this._resourceId;
      }
      /** Destroys the style */
      destroy() {
        this.emit("destroy", this);
        this.removeAllListeners();
      }
    };
    TextureStyle = _TextureStyle;
    TextureStyle.DEFAULT = {
      addressMode: "clamp-to-edge",
      scaleMode: "nearest"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs
var UID2, RESOURCE_ID, TextureSource;
var init_TextureSource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs"() {
    init_eventemitter3();
    init_TextureStyle();
    UID2 = 0;
    RESOURCE_ID = 0;
    TextureSource = class extends eventemitter3_default {
      constructor(options = {}) {
        super();
        this.uid = UID2++;
        this.resourceType = "textureSource";
        this.resourceId = RESOURCE_ID++;
        this.type = "unknown";
        this._resolution = 1;
        this.pixelWidth = 1;
        this.pixelHeight = 1;
        this.width = 1;
        this.height = 1;
        this.sampleCount = 1;
        this.mipLevelCount = 1;
        this.autoGenerateMipmaps = false;
        this.format = "rgba8unorm-srgb";
        this.viewDimensions = "2d";
        this.dimension = "2d";
        this.antialias = false;
        this.depthStencil = true;
        this.resource = options.resource;
        this._resolution = options.resolution ?? 1;
        if (options.width) {
          this.pixelWidth = options.width * this._resolution;
        } else {
          this.pixelWidth = options.resource?.width ?? 1;
        }
        if (options.height) {
          this.pixelHeight = options.height * this._resolution;
        } else {
          this.pixelHeight = options.resource?.height ?? 1;
        }
        this.width = this.pixelWidth / this._resolution;
        this.height = this.pixelHeight / this._resolution;
        this.format = options.format ?? "bgra8unorm";
        this.viewDimensions = options.view ?? "2d";
        this.dimension = options.dimensions ?? "2d";
        this.mipLevelCount = options.mipLevelCount ?? 1;
        this.autoGenerateMipmaps = options.autoGenerateMipmaps ?? false;
        this.sampleCount = options.sampleCount ?? 1;
        this.antialias = options.antialias ?? false;
        const style = options.style ?? {};
        this.style = style instanceof TextureStyle ? style : new TextureStyle(style);
        this.style.on("change", this.onStyleUpdate, this);
        this.styleSourceKey = (this.style.resourceId << 24) + this.uid;
      }
      get source() {
        return this;
      }
      update() {
        this.emit("update", this);
      }
      onStyleUpdate() {
        this.styleSourceKey = (this.style.resourceId << 24) + this.uid;
      }
      /** Destroys this texture source */
      destroy() {
        this.emit("destroy", this);
        if (this.style) {
          this.style.destroy();
          this.style = null;
        }
        this.type = null;
        this.resource = null;
        this.removeAllListeners();
      }
      get resolution() {
        return this._resolution;
      }
      set resolution(resolution) {
        if (this._resolution === resolution)
          return;
        this._resolution = resolution;
        this.width = this.pixelWidth / resolution;
        this.height = this.pixelHeight / resolution;
      }
      resize(width, height, resolution) {
        resolution = resolution || this._resolution;
        width = width || this.width;
        height = height || this.height;
        const newPixelWidth = Math.round(width * resolution);
        const newPixelHeight = Math.round(height * resolution);
        this.width = newPixelWidth / resolution;
        this.height = newPixelHeight / resolution;
        this._resolution = resolution;
        if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {
          return;
        }
        this.pixelWidth = newPixelWidth;
        this.pixelHeight = newPixelHeight;
        this.emit("resize", this);
        this.resourceId++;
        this.emit("change", this);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/maths/const.mjs
var PI_2, RAD_TO_DEG, DEG_TO_RAD;
var init_const2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/maths/const.mjs"() {
    PI_2 = Math.PI * 2;
    RAD_TO_DEG = 180 / Math.PI;
    DEG_TO_RAD = Math.PI / 180;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/maths/Matrix.mjs
var Matrix, tempMatrix, identityMatrix;
var init_Matrix = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/maths/Matrix.mjs"() {
    init_const2();
    init_Point();
    Matrix = class _Matrix {
      /**
       * @param a - x scale
       * @param b - y skew
       * @param c - x skew
       * @param d - y scale
       * @param tx - x translation
       * @param ty - y translation
       */
      constructor(a = 1, b = 0, c = 0, d2 = 1, tx = 0, ty = 0) {
        this.array = null;
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d2;
        this.tx = tx;
        this.ty = ty;
      }
      /**
       * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
       *
       * a = array[0]
       * b = array[1]
       * c = array[3]
       * d = array[4]
       * tx = array[2]
       * ty = array[5]
       * @param array - The array that the matrix will be populated from.
       */
      fromArray(array) {
        this.a = array[0];
        this.b = array[1];
        this.c = array[3];
        this.d = array[4];
        this.tx = array[2];
        this.ty = array[5];
      }
      /**
       * Sets the matrix properties.
       * @param a - Matrix component
       * @param b - Matrix component
       * @param c - Matrix component
       * @param d - Matrix component
       * @param tx - Matrix component
       * @param ty - Matrix component
       * @returns This matrix. Good for chaining method calls.
       */
      set(a, b, c, d2, tx, ty) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d2;
        this.tx = tx;
        this.ty = ty;
        return this;
      }
      /**
       * Creates an array from the current Matrix object.
       * @param transpose - Whether we need to transpose the matrix or not
       * @param [out=new Float32Array(9)] - If provided the array will be assigned to out
       * @returns The newly created array which contains the matrix
       */
      toArray(transpose, out2) {
        if (!this.array) {
          this.array = new Float32Array(9);
        }
        const array = out2 || this.array;
        if (transpose) {
          array[0] = this.a;
          array[1] = this.b;
          array[2] = 0;
          array[3] = this.c;
          array[4] = this.d;
          array[5] = 0;
          array[6] = this.tx;
          array[7] = this.ty;
          array[8] = 1;
        } else {
          array[0] = this.a;
          array[1] = this.c;
          array[2] = this.tx;
          array[3] = this.b;
          array[4] = this.d;
          array[5] = this.ty;
          array[6] = 0;
          array[7] = 0;
          array[8] = 1;
        }
        return array;
      }
      /**
       * Get a new position with the current transformation applied.
       * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
       * @param pos - The origin
       * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
       * @returns {PIXI.Point} The new point, transformed through this matrix
       */
      apply(pos, newPos) {
        newPos = newPos || new Point();
        const x2 = pos.x;
        const y = pos.y;
        newPos.x = this.a * x2 + this.c * y + this.tx;
        newPos.y = this.b * x2 + this.d * y + this.ty;
        return newPos;
      }
      /**
       * Get a new position with the inverse of the current transformation applied.
       * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
       * @param pos - The origin
       * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
       * @returns {PIXI.Point} The new point, inverse-transformed through this matrix
       */
      applyInverse(pos, newPos) {
        newPos = newPos || new Point();
        const a = this.a;
        const b = this.b;
        const c = this.c;
        const d2 = this.d;
        const tx = this.tx;
        const ty = this.ty;
        const id = 1 / (a * d2 + c * -b);
        const x2 = pos.x;
        const y = pos.y;
        newPos.x = d2 * id * x2 + -c * id * y + (ty * c - tx * d2) * id;
        newPos.y = a * id * y + -b * id * x2 + (-ty * a + tx * b) * id;
        return newPos;
      }
      /**
       * Translates the matrix on the x and y.
       * @param x - How much to translate x by
       * @param y - How much to translate y by
       * @returns This matrix. Good for chaining method calls.
       */
      translate(x2, y) {
        this.tx += x2;
        this.ty += y;
        return this;
      }
      /**
       * Applies a scale transformation to the matrix.
       * @param x - The amount to scale horizontally
       * @param y - The amount to scale vertically
       * @returns This matrix. Good for chaining method calls.
       */
      scale(x2, y) {
        this.a *= x2;
        this.d *= y;
        this.c *= x2;
        this.b *= y;
        this.tx *= x2;
        this.ty *= y;
        return this;
      }
      /**
       * Applies a rotation transformation to the matrix.
       * @param angle - The angle in radians.
       * @returns This matrix. Good for chaining method calls.
       */
      rotate(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const a1 = this.a;
        const c1 = this.c;
        const tx1 = this.tx;
        this.a = a1 * cos - this.b * sin;
        this.b = a1 * sin + this.b * cos;
        this.c = c1 * cos - this.d * sin;
        this.d = c1 * sin + this.d * cos;
        this.tx = tx1 * cos - this.ty * sin;
        this.ty = tx1 * sin + this.ty * cos;
        return this;
      }
      /**
       * Appends the given Matrix to this Matrix.
       * @param matrix - The matrix to append.
       * @returns This matrix. Good for chaining method calls.
       */
      append(matrix) {
        const a1 = this.a;
        const b1 = this.b;
        const c1 = this.c;
        const d1 = this.d;
        this.a = matrix.a * a1 + matrix.b * c1;
        this.b = matrix.a * b1 + matrix.b * d1;
        this.c = matrix.c * a1 + matrix.d * c1;
        this.d = matrix.c * b1 + matrix.d * d1;
        this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
        this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
        return this;
      }
      /**
       * Appends two matrix's and sets the result to this matrix. AB = A * B
       * @param a - The matrix to append.
       * @param b - The matrix to append.
       * @returns This matrix. Good for chaining method calls.
       */
      appendFrom(a, b) {
        const a1 = a.a;
        const b1 = a.b;
        const c1 = a.c;
        const d1 = a.d;
        const tx = a.tx;
        const ty = a.ty;
        const a2 = b.a;
        const b2 = b.b;
        const c2 = b.c;
        const d2 = b.d;
        this.a = a1 * a2 + b1 * c2;
        this.b = a1 * b2 + b1 * d2;
        this.c = c1 * a2 + d1 * c2;
        this.d = c1 * b2 + d1 * d2;
        this.tx = tx * a2 + ty * c2 + b.tx;
        this.ty = tx * b2 + ty * d2 + b.ty;
        return this;
      }
      /**
       * Sets the matrix based on all the available properties
       * @param x - Position on the x axis
       * @param y - Position on the y axis
       * @param pivotX - Pivot on the x axis
       * @param pivotY - Pivot on the y axis
       * @param scaleX - Scale on the x axis
       * @param scaleY - Scale on the y axis
       * @param rotation - Rotation in radians
       * @param skewX - Skew on the x axis
       * @param skewY - Skew on the y axis
       * @returns This matrix. Good for chaining method calls.
       */
      setTransform(x2, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
        this.a = Math.cos(rotation + skewY) * scaleX;
        this.b = Math.sin(rotation + skewY) * scaleX;
        this.c = -Math.sin(rotation - skewX) * scaleY;
        this.d = Math.cos(rotation - skewX) * scaleY;
        this.tx = x2 - (pivotX * this.a + pivotY * this.c);
        this.ty = y - (pivotX * this.b + pivotY * this.d);
        return this;
      }
      /**
       * Prepends the given Matrix to this Matrix.
       * @param matrix - The matrix to prepend
       * @returns This matrix. Good for chaining method calls.
       */
      prepend(matrix) {
        const tx1 = this.tx;
        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
          const a1 = this.a;
          const c1 = this.c;
          this.a = a1 * matrix.a + this.b * matrix.c;
          this.b = a1 * matrix.b + this.b * matrix.d;
          this.c = c1 * matrix.a + this.d * matrix.c;
          this.d = c1 * matrix.b + this.d * matrix.d;
        }
        this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
        this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
        return this;
      }
      /**
       * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
       * @param transform - The transform to apply the properties to.
       * @returns The transform with the newly applied properties
       */
      decompose(transform) {
        const a = this.a;
        const b = this.b;
        const c = this.c;
        const d2 = this.d;
        const pivot = transform.pivot;
        const skewX = -Math.atan2(-c, d2);
        const skewY = Math.atan2(b, a);
        const delta = Math.abs(skewX + skewY);
        if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
          transform.rotation = skewY;
          transform.skew.x = transform.skew.y = 0;
        } else {
          transform.rotation = 0;
          transform.skew.x = skewX;
          transform.skew.y = skewY;
        }
        transform.scale.x = Math.sqrt(a * a + b * b);
        transform.scale.y = Math.sqrt(c * c + d2 * d2);
        transform.position.x = this.tx + (pivot.x * a + pivot.y * c);
        transform.position.y = this.ty + (pivot.x * b + pivot.y * d2);
        return transform;
      }
      /**
       * Inverts this matrix
       * @returns This matrix. Good for chaining method calls.
       */
      invert() {
        const a1 = this.a;
        const b1 = this.b;
        const c1 = this.c;
        const d1 = this.d;
        const tx1 = this.tx;
        const n = a1 * d1 - b1 * c1;
        this.a = d1 / n;
        this.b = -b1 / n;
        this.c = -c1 / n;
        this.d = a1 / n;
        this.tx = (c1 * this.ty - d1 * tx1) / n;
        this.ty = -(a1 * this.ty - b1 * tx1) / n;
        return this;
      }
      /** Checks if this matrix is an identity matrix */
      isIdentity() {
        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
      }
      /**
       * Resets this Matrix to an identity (default) matrix.
       * @returns This matrix. Good for chaining method calls.
       */
      identity() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
        return this;
      }
      /**
       * Creates a new Matrix object with the same values as this one.
       * @returns A copy of this matrix. Good for chaining method calls.
       */
      clone() {
        const matrix = new _Matrix();
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      }
      /**
       * Changes the values of the given matrix to be the same as the ones in this matrix
       * @param matrix - The matrix to copy to.
       * @returns The matrix given in parameter with its values updated.
       */
      copyTo(matrix) {
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      }
      /**
       * Changes the values of the matrix to be the same as the ones in given matrix
       * @param matrix - The matrix to copy from.
       * @returns this
       */
      copyFrom(matrix) {
        this.a = matrix.a;
        this.b = matrix.b;
        this.c = matrix.c;
        this.d = matrix.d;
        this.tx = matrix.tx;
        this.ty = matrix.ty;
        return this;
      }
      toString() {
        return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
      }
      /**
       * A default (identity) matrix
       * @readonly
       */
      static get IDENTITY() {
        return identityMatrix.identity();
      }
      /**
       * A temp matrix
       * @readonly
       */
      static get shared() {
        return tempMatrix.identity();
      }
    };
    tempMatrix = new Matrix();
    identityMatrix = new Matrix();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/maths/groupD8.mjs
function init() {
  for (let i = 0; i < 16; i++) {
    const row = [];
    rotationCayley.push(row);
    for (let j2 = 0; j2 < 16; j2++) {
      const _ux = signum(ux[i] * ux[j2] + vx[i] * uy[j2]);
      const _uy = signum(uy[i] * ux[j2] + vy[i] * uy[j2]);
      const _vx = signum(ux[i] * vx[j2] + vx[i] * vy[j2]);
      const _vy = signum(uy[i] * vx[j2] + vy[i] * vy[j2]);
      for (let k2 = 0; k2 < 16; k2++) {
        if (ux[k2] === _ux && uy[k2] === _uy && vx[k2] === _vx && vy[k2] === _vy) {
          row.push(k2);
          break;
        }
      }
    }
  }
  for (let i = 0; i < 16; i++) {
    const mat = new Matrix();
    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);
    rotationMatrices.push(mat);
  }
}
var ux, uy, vx, vy, rotationCayley, rotationMatrices, signum, groupD8;
var init_groupD8 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/maths/groupD8.mjs"() {
    init_Matrix();
    ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
    uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
    vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
    vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
    rotationCayley = [];
    rotationMatrices = [];
    signum = Math.sign;
    init();
    groupD8 = {
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 0       | East      |
       * @memberof PIXI.groupD8
       * @constant {PIXI.GD8Symmetry}
       */
      E: 0,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 45     | Southeast |
       * @memberof PIXI.groupD8
       * @constant {PIXI.GD8Symmetry}
       */
      SE: 1,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 90     | South     |
       * @memberof PIXI.groupD8
       * @constant {PIXI.GD8Symmetry}
       */
      S: 2,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 135    | Southwest |
       * @memberof PIXI.groupD8
       * @constant {PIXI.GD8Symmetry}
       */
      SW: 3,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 180     | West      |
       * @memberof PIXI.groupD8
       * @constant {PIXI.GD8Symmetry}
       */
      W: 4,
      /**
       * | Rotation    | Direction    |
       * |-------------|--------------|
       * | -135/225 | Northwest    |
       * @memberof PIXI.groupD8
       * @constant {PIXI.GD8Symmetry}
       */
      NW: 5,
      /**
       * | Rotation    | Direction    |
       * |-------------|--------------|
       * | -90/270  | North        |
       * @memberof PIXI.groupD8
       * @constant {PIXI.GD8Symmetry}
       */
      N: 6,
      /**
       * | Rotation    | Direction    |
       * |-------------|--------------|
       * | -45/315  | Northeast    |
       * @memberof PIXI.groupD8
       * @constant {PIXI.GD8Symmetry}
       */
      NE: 7,
      /**
       * Reflection about Y-axis.
       * @memberof PIXI.groupD8
       * @constant {PIXI.GD8Symmetry}
       */
      MIRROR_VERTICAL: 8,
      /**
       * Reflection about the main diagonal.
       * @memberof PIXI.groupD8
       * @constant {PIXI.GD8Symmetry}
       */
      MAIN_DIAGONAL: 10,
      /**
       * Reflection about X-axis.
       * @memberof PIXI.groupD8
       * @constant {PIXI.GD8Symmetry}
       */
      MIRROR_HORIZONTAL: 12,
      /**
       * Reflection about reverse diagonal.
       * @memberof PIXI.groupD8
       * @constant {PIXI.GD8Symmetry}
       */
      REVERSE_DIAGONAL: 14,
      /**
       * @memberof PIXI.groupD8
       * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
       * @returns {PIXI.GD8Symmetry} The X-component of the U-axis
       *    after rotating the axes.
       */
      uX: (ind) => ux[ind],
      /**
       * @memberof PIXI.groupD8
       * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
       * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis
       *    after rotating the axes.
       */
      uY: (ind) => uy[ind],
      /**
       * @memberof PIXI.groupD8
       * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
       * @returns {PIXI.GD8Symmetry} The X-component of the V-axis
       *    after rotating the axes.
       */
      vX: (ind) => vx[ind],
      /**
       * @memberof PIXI.groupD8
       * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
       * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis
       *    after rotating the axes.
       */
      vY: (ind) => vy[ind],
      /**
       * @memberof PIXI.groupD8
       * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite
       *   is needed. Only rotations have opposite symmetries while
       *   reflections don't.
       * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`
       */
      inv: (rotation) => {
        if (rotation & 8) {
          return rotation & 15;
        }
        return -rotation & 7;
      },
      /**
       * Composes the two D8 operations.
       *
       * Taking `^` as reflection:
       *
       * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
       * |-------|-----|-----|-----|-----|------|-------|-------|-------|
       * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
       * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
       * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
       * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
       * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
       * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
       * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
       * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
       *
       * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
       * @memberof PIXI.groupD8
       * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which
       *   is the row in the above cayley table.
       * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which
       *   is the column in the above cayley table.
       * @returns {PIXI.GD8Symmetry} Composed operation
       */
      add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
      /**
       * Reverse of `add`.
       * @memberof PIXI.groupD8
       * @param {PIXI.GD8Symmetry} rotationSecond - Second operation
       * @param {PIXI.GD8Symmetry} rotationFirst - First operation
       * @returns {PIXI.GD8Symmetry} Result
       */
      sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
      /**
       * Adds 180 degrees to rotation, which is a commutative
       * operation.
       * @memberof PIXI.groupD8
       * @param {number} rotation - The number to rotate.
       * @returns {number} Rotated number
       */
      rotate180: (rotation) => rotation ^ 4,
      /**
       * Checks if the rotation angle is vertical, i.e. south
       * or north. It doesn't work for reflections.
       * @memberof PIXI.groupD8
       * @param {PIXI.GD8Symmetry} rotation - The number to check.
       * @returns {boolean} Whether or not the direction is vertical
       */
      isVertical: (rotation) => (rotation & 3) === 2,
      // rotation % 4 === 2
      /**
       * Approximates the vector `V(dx,dy)` into one of the
       * eight directions provided by `groupD8`.
       * @memberof PIXI.groupD8
       * @param {number} dx - X-component of the vector
       * @param {number} dy - Y-component of the vector
       * @returns {PIXI.GD8Symmetry} Approximation of the vector into
       *  one of the eight symmetries.
       */
      byDirection: (dx, dy) => {
        if (Math.abs(dx) * 2 <= Math.abs(dy)) {
          if (dy >= 0) {
            return groupD8.S;
          }
          return groupD8.N;
        } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
          if (dx > 0) {
            return groupD8.E;
          }
          return groupD8.W;
        } else if (dy > 0) {
          if (dx > 0) {
            return groupD8.SE;
          }
          return groupD8.SW;
        } else if (dx > 0) {
          return groupD8.NE;
        }
        return groupD8.NW;
      },
      /**
       * Helps sprite to compensate texture packer rotation.
       * @memberof PIXI.groupD8
       * @param {PIXI.Matrix} matrix - sprite world matrix
       * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.
       * @param {number} tx - sprite anchoring
       * @param {number} ty - sprite anchoring
       */
      matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
        const mat = rotationMatrices[groupD8.inv(rotation)];
        mat.tx = tx;
        mat.ty = ty;
        matrix.append(mat);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureLayout.mjs
var TextureLayout;
var init_TextureLayout = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureLayout.mjs"() {
    init_eventemitter3();
    init_groupD8();
    init_Rectangle();
    TextureLayout = class extends eventemitter3_default {
      constructor(options = {}) {
        super();
        this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };
        this.frame = options.frame || new Rectangle(0, 0, 1, 1);
        this.orig = options.orig || this.frame;
        this.rotate = options.rotate ?? 0;
        this.trim = options.trim;
        this.defaultAnchor = options.defaultAnchor;
        this.updateUvs();
      }
      updateUvs() {
        const uvs = this.uvs;
        const frame = this.frame;
        let rotate = this.rotate;
        if (rotate) {
          const w2 = frame.width / 2;
          const h2 = frame.height / 2;
          const cX = frame.x + w2;
          const cY = frame.y + h2;
          rotate = groupD8.add(rotate, groupD8.NW);
          uvs.x0 = cX + w2 * groupD8.uX(rotate);
          uvs.y0 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          uvs.x1 = cX + w2 * groupD8.uX(rotate);
          uvs.y1 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          uvs.x2 = cX + w2 * groupD8.uX(rotate);
          uvs.y2 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          uvs.x3 = cX + w2 * groupD8.uX(rotate);
          uvs.y3 = cY + h2 * groupD8.uY(rotate);
        } else {
          uvs.x0 = frame.x;
          uvs.y0 = frame.y;
          uvs.x1 = frame.x + frame.width;
          uvs.y1 = frame.y;
          uvs.x2 = frame.x + frame.width;
          uvs.y2 = frame.y + frame.height;
          uvs.x3 = frame.x;
          uvs.y3 = frame.y + frame.height;
        }
      }
      update() {
        this.updateUvs();
        this.emit("update", this);
      }
      /** Destroys this TextureLayout */
      destroy() {
        this.emit("destroy", this);
        this.removeAllListeners();
        this.frame = null;
        this.orig = null;
        this.trim = null;
        this.defaultAnchor = null;
        this.uvs = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs
var tempMat, TextureMatrix;
var init_TextureMatrix = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs"() {
    init_Matrix();
    tempMat = new Matrix();
    TextureMatrix = class {
      /**
       * @param texture - observed texture
       * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
       */
      constructor(texture, clampMargin) {
        this.mapCoord = new Matrix();
        this.uClampFrame = new Float32Array(4);
        this.uClampOffset = new Float32Array(2);
        this._textureID = -1;
        this._updateID = 0;
        this.clampOffset = 0;
        this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
        this.isSimple = false;
        this.texture = texture;
      }
      /** Texture property. */
      get texture() {
        return this._texture;
      }
      set texture(value) {
        if (this.texture === value)
          return;
        this._texture?.removeListener("update", this.update, this);
        this._texture = value;
        this._texture.addListener("update", this.update, this);
        this.update();
      }
      /**
       * Multiplies uvs array to transform
       * @param uvs - mesh uvs
       * @param [out=uvs] - output
       * @returns - output
       */
      multiplyUvs(uvs, out2) {
        if (out2 === void 0) {
          out2 = uvs;
        }
        const mat = this.mapCoord;
        for (let i = 0; i < uvs.length; i += 2) {
          const x2 = uvs[i];
          const y = uvs[i + 1];
          out2[i] = x2 * mat.a + y * mat.c + mat.tx;
          out2[i + 1] = x2 * mat.b + y * mat.d + mat.ty;
        }
        return out2;
      }
      update() {
        const tex = this._texture;
        this._updateID++;
        const uvs = tex.layout.uvs;
        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
        const orig = tex.layout.orig;
        const trim = tex.layout.trim;
        if (trim) {
          tempMat.set(
            orig.width / trim.width,
            0,
            0,
            orig.height / trim.height,
            -trim.x / trim.width,
            -trim.y / trim.height
          );
          this.mapCoord.append(tempMat);
        }
        const texBase = tex.source;
        const frame = this.uClampFrame;
        const margin = this.clampMargin / texBase._resolution;
        const offset = this.clampOffset;
        frame[0] = (tex.frameX + margin + offset) / texBase.width;
        frame[1] = (tex.frameY + margin + offset) / texBase.height;
        frame[2] = (tex.frameX + tex.frameWidth - margin + offset) / texBase.width;
        frame[3] = (tex.frameY + tex.frameHeight - margin + offset) / texBase.height;
        this.uClampOffset[0] = offset / texBase.pixelWidth;
        this.uClampOffset[1] = offset / texBase.pixelHeight;
        this.isSimple = tex.frameWidth === texBase.width && tex.frameHeight === texBase.height && tex.layout.rotate === 0;
        return true;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs
var UID3, Texture;
var init_Texture = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"() {
    init_eventemitter3();
    init_Cache();
    init_NOOP();
    init_TextureSource();
    init_TextureLayout();
    init_TextureMatrix();
    init_TextureStyle();
    UID3 = 0;
    Texture = class extends eventemitter3_default {
      constructor({ source: source3, style, layout, label } = {}) {
        super();
        this.id = UID3++;
        this.styleSourceKey = 0;
        this.label = label;
        this.source = source3?.source ?? new TextureSource();
        this.layout = layout instanceof TextureLayout ? layout : new TextureLayout(layout);
        if (style) {
          this._style = style instanceof TextureStyle ? style : new TextureStyle(style);
        }
        this.styleSourceKey = (this.style.resourceId << 24) + this._source.uid;
      }
      static from(id) {
        return Cache.get(id);
      }
      set source(value) {
        if (this._source) {
          this._source.off("update", this.onStyleSourceUpdate, this);
          this._source.off("resize", this.onUpdate, this);
        }
        this._source = value;
        value.on("update", this.onStyleSourceUpdate, this);
        value.on("resize", this.onUpdate, this);
        this.styleSourceKey = (this.style.resourceId << 24) + this._source.uid;
        this.emit("update", this);
      }
      get source() {
        return this._source;
      }
      get style() {
        return this._style || this.source.style;
      }
      set style(value) {
        this._style?.off("change", this.onStyleSourceUpdate, this);
        this._style = value;
        this._style?.on("change", this.onStyleSourceUpdate, this);
      }
      get layout() {
        return this._layout;
      }
      set layout(value) {
        this._layout?.off("update", this.onUpdate, this);
        this._layout = value;
        value.on("update", this.onUpdate, this);
        this.emit("update", this);
      }
      get textureMatrix() {
        if (!this._textureMatrix) {
          this._textureMatrix = new TextureMatrix(this);
        }
        return this._textureMatrix;
      }
      set frameWidth(value) {
        this._layout.frame.width = value / this._source.width;
      }
      get frameWidth() {
        return this._source.pixelWidth / this._source._resolution * this._layout.frame.width;
      }
      set frameHeight(value) {
        this._layout.frame.height = value / this._source.height;
      }
      get frameHeight() {
        return this._source.pixelHeight / this._source._resolution * this._layout.frame.height;
      }
      set frameX(value) {
        if (value === 0) {
          this._layout.frame.x = 0;
          return;
        }
        this._layout.frame.x = this._source.width / value;
      }
      get frameX() {
        return this._source.width * this._layout.frame.x;
      }
      set frameY(value) {
        if (value === 0) {
          this._layout.frame.y = 0;
          return;
        }
        this._layout.frame.y = this._source.height / value;
      }
      get frameY() {
        return this._source.height * this._layout.frame.y;
      }
      /** The width of the Texture in pixels. */
      get width() {
        return this._source.width * this._layout.orig.width;
      }
      /** The height of the Texture in pixels. */
      get height() {
        return this._source.height * this._layout.orig.height;
      }
      /**
       * Destroys this texture
       * @param destroySource - Destroy the source when the texture is destroyed.
       */
      destroy(destroySource = false) {
        if (this._style) {
          this._style.destroy();
          this._style = null;
        }
        if (this._layout) {
          this._layout.destroy();
          this._layout = null;
        }
        if (this._source) {
          if (destroySource) {
            this._source.destroy();
            this._source = null;
          }
        }
        this._textureMatrix = null;
        this.removeAllListeners();
      }
      /**
       * @internal
       */
      onStyleSourceUpdate() {
        this.styleSourceKey = (this.style.resourceId << 24) + this._source.uid;
        this.emit("update", this);
      }
      /**
       * @internal
       */
      onUpdate() {
        this.emit("update", this);
      }
    };
    Texture.EMPTY = new Texture({});
    Texture.EMPTY.label = "EMPTY";
    Texture.EMPTY.destroy = NOOP;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/bitmap/BitmapFont.mjs
var BitmapFont;
var init_BitmapFont = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/bitmap/BitmapFont.mjs"() {
    init_eventemitter3();
    init_Rectangle();
    init_Texture();
    BitmapFont = class extends eventemitter3_default {
      constructor(options) {
        super();
        this.baseRenderedFontSize = 100;
        this.baseMeasurementFontSize = 100;
        this.pages = [];
        this.chars = {};
        this.lineHeight = 0;
        this.baseLineOffset = 0;
        this.pages = [];
        const { textures, data } = options;
        Object.keys(data.pages).forEach((key) => {
          const pageData = data.pages[parseInt(key, 10)];
          const texture = textures[pageData.id];
          this.pages.push({ texture });
        });
        Object.keys(data.chars).forEach((key) => {
          const charData = data.chars[key];
          const textureSource = textures[charData.page].source;
          const frame = new Rectangle(
            charData.x / textureSource.width,
            charData.y / textureSource.height,
            charData.width / textureSource.width,
            charData.height / textureSource.height
          );
          const texture = new Texture({
            source: textureSource,
            layout: {
              frame
            }
          });
          this.chars[key] = {
            id: key.codePointAt(0),
            xOffset: charData.xOffset,
            yOffset: charData.yOffset,
            // - 31, // + 61 - 87,
            xAdvance: charData.xAdvance,
            kerning: charData.kerning ?? {},
            texture
          };
        });
        this.fontMetrics = {
          ascent: 0,
          descent: 0,
          fontSize: data.fontSize
        };
        this.baseLineOffset = data.baseLineOffset;
        this.lineHeight = data.lineHeight;
        this.fontName = data.fontName;
        this.baseMeasurementFontSize = data.fontSize;
        this.baseRenderedFontSize = data.fontSize;
        this.distanceField = data.distanceField ?? {
          fieldType: "none",
          distanceRange: 0
        };
      }
      destroy() {
        this.emit("destroy", this);
        this.removeAllListeners();
        for (const i in this.chars) {
          this.chars[i].texture.destroy();
        }
        this.chars = null;
        for (let i = 0; i < this.pages.length; i++) {
          const { texture } = this.pages[i];
          texture.destroy(true);
        }
        this.pages = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/bitmap/asset/textFormat.mjs
var TextFormat;
var init_textFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/bitmap/asset/textFormat.mjs"() {
    TextFormat = {
      test(data) {
        return typeof data === "string" && data.startsWith("info face=");
      },
      parse(txt) {
        const items = txt.match(/^[a-z]+\s+.+$/gm);
        const rawData = {
          info: [],
          common: [],
          page: [],
          char: [],
          chars: [],
          kerning: [],
          kernings: [],
          distanceField: []
        };
        for (const i in items) {
          const name = items[i].match(/^[a-z]+/gm)[0];
          const attributeList = items[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
          const itemData = {};
          for (const i2 in attributeList) {
            const split = attributeList[i2].split("=");
            const key = split[0];
            const strValue = split[1].replace(/"/gm, "");
            const floatValue = parseFloat(strValue);
            const value = isNaN(floatValue) ? strValue : floatValue;
            itemData[key] = value;
          }
          rawData[name].push(itemData);
        }
        const font = {
          chars: {},
          pages: [],
          lineHeight: 0,
          fontSize: 0,
          fontName: "",
          distanceField: null,
          baseLineOffset: 0
        };
        const [info] = rawData.info;
        const [common] = rawData.common;
        const [distanceField] = rawData.distanceField ?? [];
        if (distanceField) {
          font.distanceField = {
            distanceRange: parseInt(distanceField.distanceRange, 10),
            fieldType: distanceField.fieldType
          };
        }
        font.fontSize = parseInt(info.size, 10);
        font.fontName = info.face;
        font.lineHeight = parseInt(common.lineHeight, 10);
        const page = rawData.page;
        for (let i = 0; i < page.length; i++) {
          font.pages.push({
            id: parseInt(page[i].id, 10) || 0,
            file: page[i].file
          });
        }
        const map2 = {};
        font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);
        const char = rawData.char;
        for (let i = 0; i < char.length; i++) {
          const charNode = char[i];
          const id = parseInt(charNode.id, 10);
          let letter = charNode.letter ?? charNode.char;
          if (letter === "space")
            letter = " ";
          map2[id] = letter;
          font.chars[letter] = {
            id,
            // texture deets..
            page: parseInt(charNode.page, 10) || 0,
            x: parseInt(charNode.x, 10),
            y: parseInt(charNode.y, 10),
            width: parseInt(charNode.width, 10),
            height: parseInt(charNode.height, 10),
            xOffset: parseInt(charNode.xoffset, 10),
            yOffset: parseInt(charNode.yoffset, 10),
            xAdvance: parseInt(charNode.xadvance, 10),
            kerning: {}
          };
        }
        const kerning = rawData.kerning || [];
        for (let i = 0; i < kerning.length; i++) {
          const first = parseInt(kerning[i].first, 10);
          const second = parseInt(kerning[i].second, 10);
          const amount = parseInt(kerning[i].amount, 10);
          font.chars[map2[second]].kerning[map2[first]] = amount;
        }
        return font;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/bitmap/asset/xmlFormat.mjs
var XMLFormat;
var init_xmlFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/bitmap/asset/xmlFormat.mjs"() {
    XMLFormat = {
      test(data) {
        const xml = data;
        return "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
      },
      parse(xml) {
        const data = {
          chars: {},
          pages: [],
          lineHeight: 0,
          fontSize: 0,
          fontName: "",
          distanceField: null,
          baseLineOffset: 0
        };
        const info = xml.getElementsByTagName("info")[0];
        const common = xml.getElementsByTagName("common")[0];
        const distanceField = xml.getElementsByTagName("distanceField")[0];
        if (distanceField) {
          data.distanceField = {
            fieldType: distanceField.getAttribute("fieldType"),
            distanceRange: parseInt(distanceField.getAttribute("distanceRange"), 10)
          };
        }
        const page = xml.getElementsByTagName("page");
        const char = xml.getElementsByTagName("char");
        const kerning = xml.getElementsByTagName("kerning");
        data.fontSize = parseInt(info.getAttribute("size"), 10);
        data.fontName = info.getAttribute("face");
        data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10);
        for (let i = 0; i < page.length; i++) {
          data.pages.push({
            id: parseInt(page[i].getAttribute("id"), 10) || 0,
            file: page[i].getAttribute("file")
          });
        }
        const map2 = {};
        data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute("base"), 10);
        for (let i = 0; i < char.length; i++) {
          const charNode = char[i];
          const id = parseInt(charNode.getAttribute("id"), 10);
          let letter = charNode.getAttribute("letter") ?? charNode.getAttribute("char");
          if (letter === "space")
            letter = " ";
          map2[id] = letter;
          data.chars[letter] = {
            id,
            // texture deets..
            page: parseInt(charNode.getAttribute("page"), 10) || 0,
            x: parseInt(charNode.getAttribute("x"), 10),
            y: parseInt(charNode.getAttribute("y"), 10),
            width: parseInt(charNode.getAttribute("width"), 10),
            height: parseInt(charNode.getAttribute("height"), 10),
            // render deets..
            xOffset: parseInt(charNode.getAttribute("xoffset"), 10),
            yOffset: parseInt(charNode.getAttribute("yoffset"), 10),
            // + baseLineOffset,
            xAdvance: parseInt(charNode.getAttribute("xadvance"), 10),
            kerning: {}
          };
        }
        for (let i = 0; i < kerning.length; i++) {
          const first = parseInt(kerning[i].getAttribute("first"), 10);
          const second = parseInt(kerning[i].getAttribute("second"), 10);
          const amount = parseInt(kerning[i].getAttribute("amount"), 10);
          data.chars[map2[second]].kerning[map2[first]] = amount;
        }
        return data;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/bitmap/asset/xmlStringFormat.mjs
var XMLStringFormat;
var init_xmlStringFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/bitmap/asset/xmlStringFormat.mjs"() {
    init_settings();
    init_xmlFormat();
    XMLStringFormat = {
      test(data) {
        if (typeof data === "string" && data.includes("<font>")) {
          return XMLFormat.test(settings.ADAPTER.parseXML(data));
        }
        return false;
      },
      parse(data) {
        return XMLFormat.parse(settings.ADAPTER.parseXML(data));
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/bitmap/asset/loadBitmapFont.mjs
var validExtensions, bitmapFontCachePlugin, xmlBitmapFontLoader;
var init_loadBitmapFont = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/bitmap/asset/loadBitmapFont.mjs"() {
    init_LoaderParser();
    init_copySearchParams();
    init_Extensions();
    init_settings();
    init_path();
    init_BitmapFont();
    init_textFormat();
    init_xmlStringFormat();
    validExtensions = [".xml", ".fnt"];
    bitmapFontCachePlugin = {
      extension: ExtensionType.CacheParser,
      test: (asset) => asset instanceof BitmapFont,
      getCacheableAssets(keys, asset) {
        const out2 = {};
        keys.forEach((key) => {
          out2[key] = asset;
        });
        out2[asset.fontName] = asset;
        return out2;
      }
    };
    xmlBitmapFontLoader = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Normal
      },
      test(url) {
        return validExtensions.includes(path.extname(url).toLowerCase());
      },
      async testParse(data) {
        return TextFormat.test(data) || XMLStringFormat.test(data);
      },
      async parse(asset, data, loader) {
        const bitmapFontData = TextFormat.test(asset) ? TextFormat.parse(asset) : XMLStringFormat.parse(asset);
        const { src } = data;
        const { pages } = bitmapFontData;
        const textureUrls = [];
        for (let i = 0; i < pages.length; ++i) {
          const pageFile = pages[i].file;
          let imagePath = path.join(path.dirname(src), pageFile);
          imagePath = copySearchParams(imagePath, src);
          textureUrls.push(imagePath);
        }
        const loadedTextures = await loader.load(textureUrls);
        const textures = textureUrls.map((url) => loadedTextures[url]);
        const bitmapFont = new BitmapFont({
          data: bitmapFontData,
          textures
        });
        return bitmapFont;
      },
      async load(url, _options) {
        const response = await settings.ADAPTER.fetch(url);
        return await response.text();
      },
      unload(bitmapFont) {
        bitmapFont.destroy();
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs
var cacheTextureArray;
var init_cacheTextureArray = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs"() {
    init_Extensions();
    init_Texture();
    cacheTextureArray = {
      extension: ExtensionType.CacheParser,
      test: (asset) => Array.isArray(asset) && asset.every((t) => t instanceof Texture),
      getCacheableAssets: (keys, asset) => {
        const out2 = {};
        keys.forEach((key) => {
          asset.forEach((item, i) => {
            out2[key + (i === 0 ? "" : i + 1)] = item;
          });
        });
        return out2;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs
var detectAvif;
var init_detectAvif = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs"() {
    init_Extensions();
    init_settings();
    detectAvif = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 1
      },
      test: async () => {
        if (!globalThis.createImageBitmap)
          return false;
        const avifData = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=";
        const blob = await settings.ADAPTER.fetch(avifData).then((r) => r.blob());
        return createImageBitmap(blob).then(() => true, () => false);
      },
      add: async (formats) => [...formats, "avif"],
      remove: async (formats) => formats.filter((f) => f !== "avif")
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs
var imageFormats, detectDefaults;
var init_detectDefaults = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs"() {
    init_Extensions();
    imageFormats = ["png", "jpg", "jpeg"];
    detectDefaults = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: -1
      },
      test: () => Promise.resolve(true),
      add: async (formats) => [...formats, ...imageFormats],
      remove: async (formats) => formats.filter((f) => !imageFormats.includes(f))
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs
function testVideoFormat(mimeType) {
  if (inWorker) {
    return false;
  }
  const video = document.createElement("video");
  return video.canPlayType(mimeType) !== "";
}
var inWorker;
var init_testVideoFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs"() {
    inWorker = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs
var detectMp4;
var init_detectMp4 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs"() {
    init_Extensions();
    init_testVideoFormat();
    detectMp4 = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 0
      },
      test: async () => testVideoFormat("video/mp4"),
      add: async (formats) => [...formats, "mp4", "m4v"],
      remove: async (formats) => formats.filter((f) => f !== "mp4" && f !== "m4v")
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs
var detectOgv;
var init_detectOgv = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs"() {
    init_Extensions();
    init_testVideoFormat();
    detectOgv = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 0
      },
      test: async () => testVideoFormat("video/ogg"),
      add: async (formats) => [...formats, "ogv"],
      remove: async (formats) => formats.filter((f) => f !== "ogv")
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs
var detectWebm;
var init_detectWebm = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs"() {
    init_Extensions();
    init_testVideoFormat();
    detectWebm = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 0
      },
      test: async () => testVideoFormat("video/webm"),
      add: async (formats) => [...formats, "webm"],
      remove: async (formats) => formats.filter((f) => f !== "webm")
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs
var detectWebp;
var init_detectWebp = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs"() {
    init_Extensions();
    init_settings();
    detectWebp = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 0
      },
      test: async () => {
        if (!globalThis.createImageBitmap)
          return false;
        const webpData = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=";
        const blob = await settings.ADAPTER.fetch(webpData).then((r) => r.blob());
        return createImageBitmap(blob).then(() => true, () => false);
      },
      add: async (formats) => [...formats, "webp"],
      remove: async (formats) => formats.filter((f) => f !== "webp")
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs
function checkDataUrl(url, mimes) {
  if (Array.isArray(mimes)) {
    for (const mime of mimes) {
      if (url.startsWith(`data:${mime}`))
        return true;
    }
    return false;
  }
  return url.startsWith(`data:${mimes}`);
}
var init_checkDataUrl = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/utils/checkExtension.mjs
function checkExtension(url, extension) {
  const tempURL = url.split("?")[0];
  const ext = path.extname(tempURL).toLowerCase();
  if (Array.isArray(extension)) {
    return extension.includes(ext);
  }
  return ext === extension;
}
var init_checkExtension = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/utils/checkExtension.mjs"() {
    init_path();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs
var validJSONExtension, validJSONMIME, loadJson;
var init_loadJson = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs"() {
    init_Extensions();
    init_settings();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    validJSONExtension = ".json";
    validJSONMIME = "application/json";
    loadJson = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Low
      },
      name: "loadJson",
      test(url) {
        return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);
      },
      async load(url) {
        const response = await settings.ADAPTER.fetch(url);
        const json = await response.json();
        return json;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs
var validTXTExtension, validTXTMIME, loadTxt;
var init_loadTxt = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs"() {
    init_Extensions();
    init_settings();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    validTXTExtension = ".txt";
    validTXTMIME = "text/plain";
    loadTxt = {
      name: "loadTxt",
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Low
      },
      test(url) {
        return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);
      },
      async load(url) {
        const response = await settings.ADAPTER.fetch(url);
        const txt = await response.text();
        return txt;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs
function getFontFamilyName(url) {
  const ext = path.extname(url);
  const name = path.basename(url, ext);
  const nameWithSpaces = name.replace(/(-|_)/g, " ");
  const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
  let valid = nameTokens.length > 0;
  for (const token of nameTokens) {
    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
      valid = false;
      break;
    }
  }
  let fontFamilyName = nameTokens.join(" ");
  if (!valid) {
    fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`;
  }
  return fontFamilyName;
}
var validWeights, validFontExtensions, validFontMIMEs, CSS_IDENT_TOKEN_REGEX, loadWebFont;
var init_loadWebFont = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs"() {
    init_Extensions();
    init_settings();
    init_path();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    validWeights = [
      "normal",
      "bold",
      "100",
      "200",
      "300",
      "400",
      "500",
      "600",
      "700",
      "800",
      "900"
    ];
    validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];
    validFontMIMEs = [
      "font/ttf",
      "font/otf",
      "font/woff",
      "font/woff2"
    ];
    CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
    loadWebFont = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Low
      },
      name: "loadWebFont",
      test(url) {
        return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);
      },
      async load(url, options) {
        const fonts = settings.ADAPTER.getFontFaceSet();
        if (fonts) {
          const fontFaces = [];
          const name = options.data?.family ?? getFontFamilyName(url);
          const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"];
          const data = options.data ?? {};
          for (let i = 0; i < weights.length; i++) {
            const weight = weights[i];
            const font = new FontFace(name, `url(${encodeURI(url)})`, {
              ...data,
              weight
            });
            await font.load();
            fonts.add(font);
            fontFaces.push(font);
          }
          return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
        }
        console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font");
        return null;
      },
      unload(font) {
        (Array.isArray(font) ? font : [font]).forEach((t) => settings.ADAPTER.getFontFaceSet().delete(t));
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/color/ColorNames.mjs
var ColorNames;
var init_ColorNames = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/color/ColorNames.mjs"() {
    ColorNames = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/color/convertColorToNumber.mjs
function convertColorToNumber(color) {
  if (typeof color === "number") {
    return color;
  }
  if (typeof color === "string") {
    if (ColorNames[color] !== void 0) {
      return ColorNames[color];
    } else if (color[0] === "#") {
      if (color.length === 4) {
        const r = parseInt(color[1] + color[1], 16);
        const g = parseInt(color[2] + color[2], 16);
        const b = parseInt(color[3] + color[3], 16);
        return (r << 16) + (g << 8) + b;
      }
      return parseInt(color.substring(1), 16);
    }
    console.warn(`[pixi.js] Invalid color: ${color}`);
  }
  return 0;
}
var init_convertColorToNumber = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/color/convertColorToNumber.mjs"() {
    init_ColorNames();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/bounds/Bounds.mjs
var Bounds;
var init_Bounds = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/bounds/Bounds.mjs"() {
    init_Matrix();
    init_Rectangle();
    Bounds = class _Bounds {
      constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
        this.matrixStack = [];
        this.matrix = new Matrix();
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      }
      get rectangle() {
        if (!this._rectangle) {
          this._rectangle = new Rectangle();
        }
        const rectangle = this._rectangle;
        if (this.minX > this.maxX || this.minY > this.maxY) {
          rectangle.x = 0;
          rectangle.y = 0;
          rectangle.width = 0;
          rectangle.height = 0;
        } else {
          rectangle.x = this.minX;
          rectangle.y = this.minY;
          rectangle.width = this.maxX - this.minX;
          rectangle.height = this.maxY - this.minY;
        }
        return rectangle;
      }
      clear() {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
        this.matrixStack.length = 0;
        this.matrix.identity();
      }
      pushMatrix(matrix) {
        this.matrixStack.push(matrix);
        if (this.matrixStack.length > 1) {
          this.matrix.copyFrom(this.matrixStack[this.matrixStack.length - 2]);
          this.matrix.append(matrix);
        } else {
          this.matrix.copyFrom(matrix);
        }
      }
      popMatrix() {
        this.matrixStack.pop();
        if (this.matrixStack.length > 1) {
          this.matrix.copyFrom(this.matrixStack[this.matrixStack.length - 2]);
          this.matrix.append(this.matrixStack[this.matrixStack.length - 1]);
        } else if (this.matrixStack.length === 1) {
          this.matrix.copyFrom(this.matrixStack[0]);
        } else {
          this.matrix.identity();
        }
      }
      setMatrix(matrix) {
        this.matrix.copyFrom(matrix);
      }
      set(x0, y0, x1, y1) {
        this.minX = x0;
        this.minY = y0;
        this.maxX = x1;
        this.maxY = y1;
      }
      /**
       * Adds sprite frame
       * @param x0 - left X of frame
       * @param y0 - top Y of frame
       * @param x1 - right X of frame
       * @param y1 - bottom Y of frame
       */
      addFrame(x0, y0, x1, y1) {
        const matrix = this.matrix;
        const a = matrix.a;
        const b = matrix.b;
        const c = matrix.c;
        const d2 = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        let minX = this.minX;
        let minY = this.minY;
        let maxX = this.maxX;
        let maxY = this.maxY;
        let x2 = a * x0 + c * y0 + tx;
        let y = b * x0 + d2 * y0 + ty;
        minX = x2 < minX ? x2 : minX;
        minY = y < minY ? y : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y > maxY ? y : maxY;
        x2 = a * x1 + c * y0 + tx;
        y = b * x1 + d2 * y0 + ty;
        minX = x2 < minX ? x2 : minX;
        minY = y < minY ? y : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y > maxY ? y : maxY;
        x2 = a * x0 + c * y1 + tx;
        y = b * x0 + d2 * y1 + ty;
        minX = x2 < minX ? x2 : minX;
        minY = y < minY ? y : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y > maxY ? y : maxY;
        x2 = a * x1 + c * y1 + tx;
        y = b * x1 + d2 * y1 + ty;
        minX = x2 < minX ? x2 : minX;
        minY = y < minY ? y : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y > maxY ? y : maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      }
      addRect(rect) {
        this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height);
      }
      addBounds(bounds) {
        this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
      }
      addBoundsMask(mask) {
        this.minX = this.minX > mask.minX ? this.minX : mask.minX;
        this.minY = this.minY > mask.minY ? this.minY : mask.minY;
        this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;
        this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;
      }
      applyMatrix(matrix) {
        const minX = this.minX;
        const minY = this.minY;
        const maxX = this.maxX;
        const maxY = this.maxY;
        const { a, b, c, d: d2, tx, ty } = matrix;
        let x2 = a * minX + c * minY + tx;
        let y = b * minX + d2 * minY + ty;
        this.minX = x2;
        this.minY = y;
        this.maxX = x2;
        this.maxY = y;
        x2 = a * maxX + c * minY + tx;
        y = b * maxX + d2 * minY + ty;
        this.minX = x2 < this.minX ? x2 : this.minX;
        this.minY = y < this.minY ? y : this.minY;
        this.maxX = x2 > this.maxX ? x2 : this.maxX;
        this.maxY = y > this.maxY ? y : this.maxY;
        x2 = a * minX + c * maxY + tx;
        y = b * minX + d2 * maxY + ty;
        this.minX = x2 < this.minX ? x2 : this.minX;
        this.minY = y < this.minY ? y : this.minY;
        this.maxX = x2 > this.maxX ? x2 : this.maxX;
        this.maxY = y > this.maxY ? y : this.maxY;
        x2 = a * maxX + c * maxY + tx;
        y = b * maxX + d2 * maxY + ty;
        this.minX = x2 < this.minX ? x2 : this.minX;
        this.minY = y < this.minY ? y : this.minY;
        this.maxX = x2 > this.maxX ? x2 : this.maxX;
        this.maxY = y > this.maxY ? y : this.maxY;
      }
      fit(rect) {
        if (this.minX < rect.left)
          this.minX = rect.left;
        if (this.maxX > rect.right)
          this.maxX = rect.right;
        if (this.minY < rect.top)
          this.minY = rect.top;
        if (this.maxY > rect.bottom)
          this.maxY = rect.bottom;
        return this;
      }
      pad(paddingX, paddingY = paddingX) {
        this.minX -= paddingX;
        this.maxX += paddingX;
        this.minY -= paddingY;
        this.maxY += paddingY;
        return this;
      }
      ceil() {
        this.minX = Math.floor(this.minX);
        this.minY = Math.floor(this.minY);
        this.maxX = Math.ceil(this.maxX);
        this.maxY = Math.ceil(this.maxY);
        return this;
      }
      clone() {
        return new _Bounds(this.minX, this.minY, this.maxX, this.maxY);
      }
      scale(x2, y = x2) {
        this.minX *= x2;
        this.minY *= y;
        this.maxX *= x2;
        this.maxY *= y;
        return this;
      }
      get x() {
        return this.minX;
      }
      get y() {
        return this.minY;
      }
      get width() {
        return this.maxX - this.minX;
      }
      get height() {
        return this.maxY - this.minY;
      }
      get isPositive() {
        return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
      }
      get isValid() {
        return this.minX + this.minY !== Infinity;
      }
      /**
       * Adds screen vertices from array
       * @param vertexData - calculated vertices
       * @param beginOffset - begin offset
       * @param endOffset - end offset, excluded
       */
      addVertexData(vertexData, beginOffset, endOffset) {
        let minX = this.minX;
        let minY = this.minY;
        let maxX = this.maxX;
        let maxY = this.maxY;
        const matrix = this.matrix;
        const a = matrix.a;
        const b = matrix.b;
        const c = matrix.c;
        const d2 = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        for (let i = beginOffset; i < endOffset; i += 2) {
          const localX = vertexData[i];
          const localY = vertexData[i + 1];
          const x2 = a * localX + c * localY + tx;
          const y = b * localX + d2 * localY + ty;
          minX = x2 < minX ? x2 : minX;
          minY = y < minY ? y : minY;
          maxX = x2 > maxX ? x2 : maxX;
          maxY = y > maxY ? y : maxY;
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      }
      toString() {
        return `[@pixi:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/color/convertNumberToHex.mjs
function convertNumberToHex(color) {
  if (typeof color === "string") {
    return color;
  }
  let hexString = (color | 0).toString(16);
  hexString = "000000".substring(0, 6 - hexString.length) + hexString;
  return `#${hexString}`;
}
var init_convertNumberToHex = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/color/convertNumberToHex.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs
var ImageSource, canvas, size, ctx;
var init_ImageSource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs"() {
    init_settings();
    init_NOOP();
    init_Texture();
    init_TextureSource();
    ImageSource = class extends TextureSource {
      constructor(options) {
        super(options);
        this.type = "image";
        this.alphaMode = options.alphaMode ?? 0;
      }
    };
    canvas = settings.ADAPTER.createCanvas();
    size = 1;
    canvas.width = size;
    canvas.height = size;
    ctx = canvas.getContext("2d");
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, size, size);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(size, 0);
    ctx.lineTo(size, size);
    ctx.closePath();
    ctx.fillStyle = "#ffffff";
    ctx.fill();
    Texture.WHITE = new Texture({
      source: new ImageSource({
        resource: canvas
      })
    });
    Texture.WHITE.label = "WHITE";
    Texture.WHITE.destroy = NOOP;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/fill/FillGradient.mjs
var UID4, _FillGradient, FillGradient;
var init_FillGradient = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/fill/FillGradient.mjs"() {
    init_Matrix();
    init_settings();
    init_convertNumberToHex();
    init_ImageSource();
    init_Texture();
    UID4 = 0;
    _FillGradient = class {
      constructor(x0, y0, x1, y1) {
        this.uid = UID4++;
        this.type = "linear";
        this.gradientStops = [];
        this.x0 = x0;
        this.y0 = y0;
        this.x1 = x1;
        this.y1 = y1;
      }
      addColorStop(offset, color) {
        color = convertNumberToHex(color);
        this.gradientStops.push({ offset, color });
        return this;
      }
      // TODO move to the system!
      buildLinearGradient() {
        const defaultSize = _FillGradient.defaultTextureSize;
        const { gradientStops } = this;
        const canvas2 = settings.ADAPTER.createCanvas();
        canvas2.width = defaultSize;
        canvas2.height = defaultSize;
        const ctx2 = canvas2.getContext("2d");
        const gradient = ctx2.createLinearGradient(0, 0, _FillGradient.defaultTextureSize, 1);
        for (let i = 0; i < gradientStops.length; i++) {
          const stop = gradientStops[i];
          gradient.addColorStop(stop.offset, stop.color);
        }
        ctx2.fillStyle = gradient;
        ctx2.fillRect(0, 0, defaultSize, defaultSize);
        this.texture = new Texture({
          source: new ImageSource({
            resource: canvas2
          }),
          style: {
            addressModeU: "clamp-to-edge",
            addressModeV: "repeat"
          }
        });
        const { x0, y0, x1, y1 } = this;
        const m2 = new Matrix();
        const dx = x1 - x0;
        const dy = y1 - y0;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        m2.translate(-x0, -y0);
        m2.scale(1 / defaultSize, 1 / defaultSize);
        m2.rotate(-angle);
        m2.scale(256 / dist, 1);
        this.transform = m2;
      }
    };
    FillGradient = _FillGradient;
    FillGradient.defaultTextureSize = 256;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/fill/FillPattern.mjs
var repetitionMap, UID5, FillPattern;
var init_FillPattern = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/fill/FillPattern.mjs"() {
    init_Matrix();
    repetitionMap = {
      repeat: {
        addressModeU: "repeat",
        addressModeV: "repeat"
      },
      "repeat-x": {
        addressModeU: "repeat",
        addressModeV: "clamp-to-edge"
      },
      "repeat-y": {
        addressModeU: "clamp-to-edge",
        addressModeV: "repeat"
      },
      "no-repeat": {
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      }
    };
    UID5 = 0;
    FillPattern = class {
      constructor(texture, repetition) {
        this.uid = UID5++;
        this.transform = new Matrix();
        this.texture = texture;
        this.repetition = repetition;
        this.transform.scale(
          1 / texture.frameWidth,
          1 / texture.frameHeight
        );
        if (repetition) {
          texture.style.addressModeU = repetitionMap[repetition].addressModeU;
          texture.style.addressModeV = repetitionMap[repetition].addressModeV;
        }
      }
      setTransform(transform) {
        const texture = this.texture;
        this.transform.copyFrom(transform);
        this.transform.invert();
        this.transform.scale(
          1 / texture.frameWidth,
          1 / texture.frameHeight
        );
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/svg/SVGToGraphicsPath.mjs
function SVGToGraphicsPath(svgPath, path2) {
  const commands = svgPath.match(/[a-df-z][^a-df-z]*/gi);
  const data = svgPath.match(/[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/g)?.map(parseFloat);
  const betterCommands = [];
  commands.forEach((command) => {
    const data2 = command.match(/[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/g)?.map(parseFloat);
    const type = command[0];
    let totalInstructions = 1;
    if (data2) {
      totalInstructions = data2.length / commandSizeMap[type.toLowerCase()];
    }
    for (let i = 0; i < totalInstructions; i++) {
      betterCommands.push(type);
    }
  });
  let dataIndex = 0;
  let lastX = 0;
  let lastY = 0;
  for (let i = 0; i < betterCommands.length; i++) {
    const type = betterCommands[i];
    switch (type) {
      case "M":
        lastX = data[dataIndex++];
        lastY = data[dataIndex++];
        path2.moveTo(lastX, lastY);
        break;
      case "m":
        lastX += data[dataIndex++];
        lastY += data[dataIndex++];
        path2.moveTo(lastX, lastY);
        break;
      case "H":
        lastX = data[dataIndex++];
        path2.lineTo(lastX, lastY);
        break;
      case "h":
        lastX += data[dataIndex++];
        path2.lineTo(lastX, lastY);
        break;
      case "V":
        lastY = data[dataIndex++];
        path2.lineTo(lastX, lastY);
        break;
      case "v":
        lastY += data[dataIndex++];
        path2.lineTo(lastX, lastY);
        break;
      case "L":
        lastX = data[dataIndex++];
        lastY = data[dataIndex++];
        path2.lineTo(lastX, lastY);
        break;
      case "l":
        lastX += data[dataIndex++];
        lastY += data[dataIndex++];
        path2.lineTo(lastX, lastY);
        break;
      case "C":
        lastX = data[dataIndex + 4];
        lastY = data[dataIndex + 5];
        path2.bezierCurveTo(
          data[dataIndex],
          data[dataIndex + 1],
          data[dataIndex + 2],
          data[dataIndex + 3],
          lastX,
          lastY
        );
        dataIndex += 6;
        break;
      case "c":
        path2.bezierCurveTo(
          lastX + data[dataIndex],
          lastY + data[dataIndex + 1],
          lastX + data[dataIndex + 2],
          lastY + data[dataIndex + 3],
          lastX + data[dataIndex + 4],
          lastY + data[dataIndex + 5]
        );
        lastX += data[dataIndex + 4];
        lastY += data[dataIndex + 5];
        dataIndex += 6;
        break;
      case "S":
        lastX = data[dataIndex + 2];
        lastY = data[dataIndex + 3];
        path2.bezierCurveToShort(
          data[dataIndex],
          data[dataIndex + 1],
          lastX,
          lastY
        );
        dataIndex += 4;
        break;
      case "s":
        path2.bezierCurveToShort(
          lastX + data[dataIndex],
          lastY + data[dataIndex + 1],
          lastX + data[dataIndex + 2],
          lastY + data[dataIndex + 3]
        );
        lastX += data[dataIndex + 2];
        lastY += data[dataIndex + 3];
        dataIndex += 4;
        break;
      case "Q":
        lastX = data[dataIndex + 2];
        lastY = data[dataIndex + 3];
        path2.quadraticCurveTo(
          data[dataIndex],
          data[dataIndex + 1],
          lastX,
          lastY
        );
        dataIndex += 4;
        break;
      case "q":
        path2.quadraticCurveTo(
          lastX + data[dataIndex],
          lastY + data[dataIndex + 1],
          lastX + data[dataIndex + 2],
          lastY + data[dataIndex + 3]
        );
        lastX += data[dataIndex + 2];
        lastY += data[dataIndex + 3];
        dataIndex += 4;
        break;
      case "T":
        lastX = data[dataIndex++];
        lastY = data[dataIndex++];
        path2.quadraticCurveToShort(
          lastX,
          lastY
        );
        break;
      case "t":
        lastX += data[dataIndex++];
        lastY += data[dataIndex++];
        path2.quadraticCurveToShort(
          lastX,
          lastY
        );
        break;
      case "A":
        lastX = data[dataIndex + 5];
        lastY = data[dataIndex + 6];
        path2.arcToSvg(
          data[dataIndex],
          data[dataIndex + 1],
          data[dataIndex + 2],
          data[dataIndex + 3],
          data[dataIndex + 4],
          lastX,
          lastY
        );
        dataIndex += 7;
        break;
      case "a":
        lastX += data[dataIndex + 5];
        lastY += data[dataIndex + 6];
        path2.arcToSvg(
          data[dataIndex],
          data[dataIndex + 1],
          data[dataIndex + 2],
          data[dataIndex + 3],
          data[dataIndex + 4],
          lastX,
          lastY
        );
        dataIndex += 7;
        break;
      case "Z":
      case "z":
        path2.closePath();
        break;
      default:
        console.warn(`Unknown SVG path command: ${type}`);
    }
  }
  return path2;
}
var commandSizeMap;
var init_SVGToGraphicsPath = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/svg/SVGToGraphicsPath.mjs"() {
    commandSizeMap = {
      a: 7,
      c: 6,
      h: 1,
      l: 2,
      m: 2,
      q: 4,
      s: 4,
      t: 2,
      v: 1,
      z: 0
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/maths/shapes/Circle.mjs
var Circle;
var init_Circle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/maths/shapes/Circle.mjs"() {
    init_Rectangle();
    Circle = class _Circle {
      /**
       * @param x - The X coordinate of the center of this circle
       * @param y - The Y coordinate of the center of this circle
       * @param radius - The radius of the circle
       */
      constructor(x2 = 0, y = 0, radius = 0) {
        this.type = "circle";
        this.x = x2;
        this.y = y;
        this.radius = radius;
      }
      /**
       * Creates a clone of this Circle instance
       * @returns A copy of the Circle
       */
      clone() {
        return new _Circle(this.x, this.y, this.radius);
      }
      /**
       * Checks whether the x and y coordinates given are contained within this circle
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coordinates are within this Circle
       */
      contains(x2, y) {
        if (this.radius <= 0) {
          return false;
        }
        const r2 = this.radius * this.radius;
        let dx = this.x - x2;
        let dy = this.y - y;
        dx *= dx;
        dy *= dy;
        return dx + dy <= r2;
      }
      /**
       * Returns the framing rectangle of the circle as a Rectangle object
       * @param out
       * @returns The framing rectangle
       */
      getBounds(out2) {
        out2 = out2 || new Rectangle();
        out2.x = this.x - this.radius;
        out2.y = this.y - this.radius;
        out2.width = this.radius * 2;
        out2.height = this.radius * 2;
        return out2;
      }
      /**
       * Copies another circle to this one.
       * @param circle - The circle to copy from.
       * @returns Returns itself.
       */
      copyFrom(circle) {
        this.x = circle.x;
        this.y = circle.y;
        this.radius = circle.radius;
        return this;
      }
      /**
       * Copies this circle to another one.
       * @param circle - The circle to copy to.
       * @returns Returns given parameter.
       */
      copyTo(circle) {
        circle.copyFrom(this);
        return circle;
      }
      toString() {
        return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs
var Ellipse;
var init_Ellipse = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs"() {
    init_Rectangle();
    Ellipse = class _Ellipse {
      /**
       * @param x - The X coordinate of the center of this ellipse
       * @param y - The Y coordinate of the center of this ellipse
       * @param halfWidth - The half width of this ellipse
       * @param halfHeight - The half height of this ellipse
       */
      constructor(x2 = 0, y = 0, halfWidth = 0, halfHeight = 0) {
        this.type = "ellipse";
        this.x = x2;
        this.y = y;
        this.halfWidth = halfWidth;
        this.halfHeight = halfHeight;
      }
      /**
       * Creates a clone of this Ellipse instance
       * @returns {PIXI.Ellipse} A copy of the ellipse
       */
      clone() {
        return new _Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);
      }
      /**
       * Checks whether the x and y coordinates given are contained within this ellipse
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coords are within this ellipse
       */
      contains(x2, y) {
        if (this.halfWidth <= 0 || this.halfHeight <= 0) {
          return false;
        }
        let normx = (x2 - this.x) / this.halfWidth;
        let normy = (y - this.y) / this.halfHeight;
        normx *= normx;
        normy *= normy;
        return normx + normy <= 1;
      }
      /**
       * Returns the framing rectangle of the ellipse as a Rectangle object
       * @returns The framing rectangle
       */
      getBounds() {
        return new Rectangle(this.x - this.halfWidth, this.y - this.halfHeight, this.halfWidth * 2, this.halfHeight * 2);
      }
      /**
       * Copies another ellipse to this one.
       * @param ellipse - The ellipse to copy from.
       * @returns Returns itself.
       */
      copyFrom(ellipse) {
        this.x = ellipse.x;
        this.y = ellipse.y;
        this.halfWidth = ellipse.halfWidth;
        this.halfHeight = ellipse.halfHeight;
        return this;
      }
      /**
       * Copies this ellipse to another one.
       * @param ellipse - The ellipse to copy to.
       * @returns Returns given parameter.
       */
      copyTo(ellipse) {
        ellipse.copyFrom(this);
        return ellipse;
      }
      toString() {
        return `[@pixi/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/maths/shapes/Polygon.mjs
var Polygon;
var init_Polygon = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/maths/shapes/Polygon.mjs"() {
    init_Rectangle();
    Polygon = class _Polygon {
      /**
       * @param {PIXI.PointData[]|number[]} points - This can be an array of Points
       *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
       *  the arguments passed can be all the points of the polygon e.g.
       *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
       *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
       */
      constructor(...points) {
        this.type = "polygon";
        let flat = Array.isArray(points[0]) ? points[0] : points;
        if (typeof flat[0] !== "number") {
          const p = [];
          for (let i = 0, il = flat.length; i < il; i++) {
            p.push(flat[i].x, flat[i].y);
          }
          flat = p;
        }
        this.points = flat;
        this.closePath = true;
      }
      /**
       * Creates a clone of this polygon.
       * @returns - A copy of the polygon.
       */
      clone() {
        const points = this.points.slice();
        const polygon = new _Polygon(points);
        polygon.closePath = this.closePath;
        return polygon;
      }
      /**
       * Checks whether the x and y coordinates passed to this function are contained within this polygon.
       * @param x - The X coordinate of the point to test.
       * @param y - The Y coordinate of the point to test.
       * @returns - Whether the x/y coordinates are within this polygon.
       */
      contains(x2, y) {
        let inside = false;
        const length = this.points.length / 2;
        for (let i = 0, j2 = length - 1; i < length; j2 = i++) {
          const xi = this.points[i * 2];
          const yi = this.points[i * 2 + 1];
          const xj = this.points[j2 * 2];
          const yj = this.points[j2 * 2 + 1];
          const intersect = yi > y !== yj > y && x2 < (xj - xi) * ((y - yi) / (yj - yi)) + xi;
          if (intersect) {
            inside = !inside;
          }
        }
        return inside;
      }
      /**
       * Returns the framing rectangle of the polygon as a Rectangle object
       * @param out - optional rectangle to store the result
       * @returns The framing rectangle
       */
      getBounds(out2) {
        out2 = out2 || new Rectangle();
        const points = this.points;
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        for (let i = 0, n = points.length; i < n; i += 2) {
          const x2 = points[i];
          const y = points[i + 1];
          minX = x2 < minX ? x2 : minX;
          maxX = x2 > maxX ? x2 : maxX;
          minY = y < minY ? y : minY;
          maxY = y > maxY ? y : maxY;
        }
        out2.x = minX;
        out2.width = maxX - minX;
        out2.y = minY;
        out2.height = maxY - minY;
        return out2;
      }
      /**
       * Copies another polygon to this one.
       * @param polygon - The polygon to copy from.
       * @returns Returns itself.
       */
      copyFrom(polygon) {
        this.points = polygon.points.slice();
        this.closePath = polygon.closePath;
        return this;
      }
      /**
       * Copies this polygon to another one.
       * @param polygon - The polygon to copy to.
       * @returns Returns given parameter.
       */
      copyTo(polygon) {
        polygon.copyFrom(this);
        return polygon;
      }
      toString() {
        return `[@pixi/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
      }
      /**
       * Get the last X coordinate of the polygon
       * @readonly
       */
      get lastX() {
        return this.points[this.points.length - 2];
      }
      /**
       * Get the last Y coordinate of the polygon
       * @readonly
       */
      get lastY() {
        return this.points[this.points.length - 1];
      }
      /**
       * Get the first X coordinate of the polygon
       * @readonly
       */
      get x() {
        return this.points[this.points.length - 2];
      }
      /**
       * Get the first Y coordinate of the polygon
       * @readonly
       */
      get y() {
        return this.points[this.points.length - 1];
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs
var RoundedRectangle;
var init_RoundedRectangle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs"() {
    init_Rectangle();
    RoundedRectangle = class _RoundedRectangle {
      /**
       * @param x - The X coordinate of the upper-left corner of the rounded rectangle
       * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
       * @param width - The overall width of this rounded rectangle
       * @param height - The overall height of this rounded rectangle
       * @param radius - Controls the radius of the rounded corners
       */
      constructor(x2 = 0, y = 0, width = 0, height = 0, radius = 20) {
        this.type = "roundedRectangle";
        this.x = x2;
        this.y = y;
        this.width = width;
        this.height = height;
        this.radius = radius;
      }
      /**
       * Returns the framing rectangle of the rounded rectangle as a Rectangle object
       * @param out - optional rectangle to store the result
       * @returns The framing rectangle
       */
      getBounds(out2) {
        out2 = out2 || new Rectangle();
        out2.x = this.x;
        out2.y = this.y;
        out2.width = this.width;
        out2.height = this.height;
        return out2;
      }
      /**
       * Creates a clone of this Rounded Rectangle.
       * @returns - A copy of the rounded rectangle.
       */
      clone() {
        return new _RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
      }
      /**
       * Copies another rectangle to this one.
       * @param rectangle - The rectangle to copy from.
       * @returns Returns itself.
       */
      copyFrom(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
      }
      /**
       * Copies this rectangle to another one.
       * @param rectangle - The rectangle to copy to.
       * @returns Returns given parameter.
       */
      copyTo(rectangle) {
        rectangle.copyFrom(this);
        return rectangle;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
       * @param x - The X coordinate of the point to test.
       * @param y - The Y coordinate of the point to test.
       * @returns - Whether the x/y coordinates are within this Rounded Rectangle.
       */
      contains(x2, y) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x2 >= this.x && x2 <= this.x + this.width) {
          if (y >= this.y && y <= this.y + this.height) {
            const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
            if (y >= this.y + radius && y <= this.y + this.height - radius || x2 >= this.x + radius && x2 <= this.x + this.width - radius) {
              return true;
            }
            let dx = x2 - (this.x + radius);
            let dy = y - (this.y + radius);
            const radius2 = radius * radius;
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dx = x2 - (this.x + this.width - radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dy = y - (this.y + this.height - radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dx = x2 - (this.x + radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
          }
        }
        return false;
      }
      toString() {
        return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/buildCommands/buildAdaptiveBezier.mjs
function buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY) {
  const scale3 = 1;
  let distanceTolerance = PATH_DISTANCE_EPSILON / scale3;
  distanceTolerance *= distanceTolerance;
  begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);
  return points;
}
function begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {
  recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);
  points.push(eX, eY);
}
function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
  if (level > RECURSION_LIMIT) {
    return;
  }
  const pi = Math.PI;
  const x12 = (x1 + x2) / 2;
  const y12 = (y1 + y2) / 2;
  const x23 = (x2 + x3) / 2;
  const y23 = (y2 + y3) / 2;
  const x34 = (x3 + x4) / 2;
  const y34 = (y3 + y4) / 2;
  const x123 = (x12 + x23) / 2;
  const y123 = (y12 + y23) / 2;
  const x234 = (x23 + x34) / 2;
  const y234 = (y23 + y34) / 2;
  const x1234 = (x123 + x234) / 2;
  const y1234 = (y123 + y234) / 2;
  if (level > 0) {
    let dx = x4 - x1;
    let dy = y4 - y1;
    const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);
    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);
    let da1;
    let da2;
    if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
      if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        const a23 = Math.atan2(y3 - y2, x3 - x2);
        da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));
        da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da2 >= pi)
          da2 = 2 * pi - da2;
        if (da1 + da2 < mAngleTolerance) {
          points.push(x1234, y1234);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x2, y2);
            return;
          }
          if (da2 > mCuspLimit) {
            points.push(x3, y3);
            return;
          }
        }
      }
    } else if (d2 > FLT_EPSILON) {
      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da1 < mAngleTolerance) {
          points.push(x2, y2);
          points.push(x3, y3);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x2, y2);
            return;
          }
        }
      }
    } else if (d3 > FLT_EPSILON) {
      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da1 < mAngleTolerance) {
          points.push(x2, y2);
          points.push(x3, y3);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x3, y3);
            return;
          }
        }
      }
    } else {
      dx = x1234 - (x1 + x4) / 2;
      dy = y1234 - (y1 + y4) / 2;
      if (dx * dx + dy * dy <= distanceTolerance) {
        points.push(x1234, y1234);
        return;
      }
    }
  }
  recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);
  recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);
}
var RECURSION_LIMIT, FLT_EPSILON, PATH_DISTANCE_EPSILON, curveAngleToleranceEpsilon, mAngleTolerance, mCuspLimit;
var init_buildAdaptiveBezier = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/buildCommands/buildAdaptiveBezier.mjs"() {
    RECURSION_LIMIT = 8;
    FLT_EPSILON = 11920929e-14;
    PATH_DISTANCE_EPSILON = 1;
    curveAngleToleranceEpsilon = 0.01;
    mAngleTolerance = 0;
    mCuspLimit = 0;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs
function buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY) {
  const scale3 = 1;
  let distanceTolerance = PATH_DISTANCE_EPSILON2 / scale3;
  distanceTolerance *= distanceTolerance;
  begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);
  return points;
}
function begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {
  recursive2(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);
  points.push(eX, eY);
}
function recursive2(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {
  if (level > RECURSION_LIMIT2) {
    return;
  }
  const pi = Math.PI;
  const x12 = (x1 + x2) / 2;
  const y12 = (y1 + y2) / 2;
  const x23 = (x2 + x3) / 2;
  const y23 = (y2 + y3) / 2;
  const x123 = (x12 + x23) / 2;
  const y123 = (y12 + y23) / 2;
  let dx = x3 - x1;
  let dy = y3 - y1;
  const d2 = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);
  if (d2 > FLT_EPSILON2) {
    if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
      if (mAngleTolerance2 < curveAngleToleranceEpsilon2) {
        points.push(x123, y123);
        return;
      }
      let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
      if (da >= pi)
        da = 2 * pi - da;
      if (da < mAngleTolerance2) {
        points.push(x123, y123);
        return;
      }
    }
  } else {
    dx = x123 - (x1 + x3) / 2;
    dy = y123 - (y1 + y3) / 2;
    if (dx * dx + dy * dy <= distanceTolerance) {
      points.push(x123, y123);
      return;
    }
  }
  recursive2(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);
  recursive2(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);
}
var RECURSION_LIMIT2, FLT_EPSILON2, PATH_DISTANCE_EPSILON2, curveAngleToleranceEpsilon2, mAngleTolerance2;
var init_buildAdaptiveQuadratic = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs"() {
    RECURSION_LIMIT2 = 8;
    FLT_EPSILON2 = 11920929e-14;
    PATH_DISTANCE_EPSILON2 = 1;
    curveAngleToleranceEpsilon2 = 0.01;
    mAngleTolerance2 = 0;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/buildCommands/buildArc.mjs
function buildArc(points, x2, y, radius, start, end, clockwise, steps) {
  let dist = Math.abs(start - end);
  if (!clockwise && start > end) {
    dist = 2 * Math.PI - dist;
  } else if (clockwise && end > start) {
    dist = 2 * Math.PI - dist;
  }
  steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI)));
  steps = Math.max(steps, 3);
  let f = dist / steps;
  let t = start;
  f *= clockwise ? -1 : 1;
  for (let i = 0; i < steps + 1; i++) {
    const cs = Math.cos(t);
    const sn = Math.sin(t);
    const nx = x2 + cs * radius;
    const ny = y + sn * radius;
    points.push(nx, ny);
    t += f;
  }
}
var init_buildArc = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/buildCommands/buildArc.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/buildCommands/buildArcTo.mjs
function buildArcTo(points, x1, y1, x2, y2, radius) {
  const fromX = points[points.length - 2];
  const fromY = points[points.length - 1];
  const a1 = fromY - y1;
  const b1 = fromX - x1;
  const a2 = y2 - y1;
  const b2 = x2 - x1;
  const mm = Math.abs(a1 * b2 - b1 * a2);
  if (mm < 1e-8 || radius === 0) {
    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
      points.push(x1, y1);
    }
    return;
  }
  const dd = a1 * a1 + b1 * b1;
  const cc = a2 * a2 + b2 * b2;
  const tt = a1 * a2 + b1 * b2;
  const k1 = radius * Math.sqrt(dd) / mm;
  const k2 = radius * Math.sqrt(cc) / mm;
  const j1 = k1 * tt / dd;
  const j2 = k2 * tt / cc;
  const cx = k1 * b2 + k2 * b1;
  const cy = k1 * a2 + k2 * a1;
  const px = b1 * (k2 + j1);
  const py = a1 * (k2 + j1);
  const qx = b2 * (k1 + j2);
  const qy = a2 * (k1 + j2);
  const startAngle = Math.atan2(py - cy, px - cx);
  const endAngle = Math.atan2(qy - cy, qx - cx);
  buildArc(
    points,
    cx + x1,
    cy + y1,
    radius,
    startAngle,
    endAngle,
    b1 * a2 > b2 * a1
  );
}
var init_buildArcTo = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/buildCommands/buildArcTo.mjs"() {
    init_buildArc();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/buildCommands/buildArcToSvg.mjs
function approxUnitArc(ang1, ang2) {
  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;
  const x1 = Math.cos(ang1);
  const y1 = Math.sin(ang1);
  const x2 = Math.cos(ang1 + ang2);
  const y2 = Math.sin(ang1 + ang2);
  return [
    {
      x: x1 - y1 * a,
      y: y1 + x1 * a
    },
    {
      x: x2 + y2 * a,
      y: y2 - x2 * a
    },
    {
      x: x2,
      y: y2
    }
  ];
}
function buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {
  if (rx === 0 || ry === 0) {
    return;
  }
  const sinPhi = Math.sin(xAxisRotation * TAU / 360);
  const cosPhi = Math.cos(xAxisRotation * TAU / 360);
  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;
  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;
  if (pxp === 0 && pyp === 0) {
    return;
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  getArcCenter(
    px,
    py,
    cx,
    cy,
    rx,
    ry,
    largeArcFlag,
    sweepFlag,
    sinPhi,
    cosPhi,
    pxp,
    pyp,
    out
  );
  let { ang1, ang2 } = out;
  const { centerX, centerY } = out;
  let ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  const segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  let lastX = points[points.length - 2];
  let lastY = points[points.length - 1];
  const outCurvePoint = { x: 0, y: 0 };
  for (let i = 0; i < segments; i++) {
    const curve = approxUnitArc(ang1, ang2);
    const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    const { x: x3, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    buildAdaptiveBezier(
      points,
      lastX,
      lastY,
      x1,
      y1,
      x2,
      y2,
      x3,
      y
    );
    lastX = x3;
    lastY = y;
    ang1 += ang2;
  }
}
var TAU, out, mapToEllipse, vectorAngle, getArcCenter;
var init_buildArcToSvg = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/buildCommands/buildArcToSvg.mjs"() {
    init_buildAdaptiveBezier();
    TAU = Math.PI * 2;
    out = {
      centerX: 0,
      centerY: 0,
      ang1: 0,
      ang2: 0
    };
    mapToEllipse = ({ x: x2, y }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {
      x2 *= rx;
      y *= ry;
      const xp = cosPhi * x2 - sinPhi * y;
      const yp = sinPhi * x2 + cosPhi * y;
      out2.x = xp + centerX;
      out2.y = yp + centerY;
      return out2;
    };
    vectorAngle = (ux2, uy2, vx2, vy2) => {
      const sign = ux2 * vy2 - uy2 * vx2 < 0 ? -1 : 1;
      let dot = ux2 * vx2 + uy2 * vy2;
      if (dot > 1) {
        dot = 1;
      }
      if (dot < -1) {
        dot = -1;
      }
      return sign * Math.acos(dot);
    };
    getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {
      const rxSq = Math.pow(rx, 2);
      const rySq = Math.pow(ry, 2);
      const pxpSq = Math.pow(pxp, 2);
      const pypSq = Math.pow(pyp, 2);
      let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;
      if (radicant < 0) {
        radicant = 0;
      }
      radicant /= rxSq * pypSq + rySq * pxpSq;
      radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
      const centerXp = radicant * rx / ry * pyp;
      const centerYp = radicant * -ry / rx * pxp;
      const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;
      const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;
      const vx1 = (pxp - centerXp) / rx;
      const vy1 = (pyp - centerYp) / ry;
      const vx2 = (-pxp - centerXp) / rx;
      const vy2 = (-pyp - centerYp) / ry;
      const ang1 = vectorAngle(1, 0, vx1, vy1);
      let ang2 = vectorAngle(vx1, vy1, vx2, vy2);
      if (sweepFlag === 0 && ang2 > 0) {
        ang2 -= TAU;
      }
      if (sweepFlag === 1 && ang2 < 0) {
        ang2 += TAU;
      }
      out2.centerX = centerX;
      out2.centerY = centerY;
      out2.ang1 = ang1;
      out2.ang2 = ang2;
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/path/ShapePath.mjs
var tempRectangle, ShapePath;
var init_ShapePath = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/path/ShapePath.mjs"() {
    init_Circle();
    init_Ellipse();
    init_Polygon();
    init_Rectangle();
    init_RoundedRectangle();
    init_Bounds();
    init_buildAdaptiveBezier();
    init_buildAdaptiveQuadratic();
    init_buildArc();
    init_buildArcTo();
    init_buildArcToSvg();
    tempRectangle = new Rectangle();
    ShapePath = class {
      constructor(graphicsPath2D) {
        this.shapePrimitives = [];
        this.currentPoly = null;
        this._bounds = new Bounds();
        this.graphicsPath2D = graphicsPath2D;
      }
      moveTo(x2, y) {
        this.startPoly(x2, y);
        return this;
      }
      lineTo(x2, y) {
        this._ensurePoly();
        const points = this.currentPoly.points;
        const fromX = points[points.length - 2];
        const fromY = points[points.length - 1];
        if (fromX !== x2 || fromY !== y) {
          points.push(x2, y);
        }
        return this;
      }
      arc(x2, y, radius, startAngle, endAngle, anticlockwise) {
        this._ensurePoly(false);
        const points = this.currentPoly.points;
        buildArc(points, x2, y, radius, startAngle, endAngle, anticlockwise);
        return this;
      }
      arcTo(x1, y1, x2, y2, radius) {
        this._ensurePoly();
        const points = this.currentPoly.points;
        buildArcTo(points, x1, y1, x2, y2, radius);
        return this;
      }
      arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y) {
        const points = this.currentPoly.points;
        buildArcToSvg(
          points,
          this.currentPoly.lastX,
          this.currentPoly.lastY,
          x2,
          y,
          rx,
          ry,
          xAxisRotation,
          largeArcFlag,
          sweepFlag
        );
        return this;
      }
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y) {
        this._ensurePoly();
        const currentPoly = this.currentPoly;
        buildAdaptiveBezier(
          this.currentPoly.points,
          currentPoly.lastX,
          currentPoly.lastY,
          cp1x,
          cp1y,
          cp2x,
          cp2y,
          x2,
          y
        );
        return this;
      }
      quadraticCurveTo(cp1x, cp1y, x2, y) {
        this._ensurePoly();
        const currentPoly = this.currentPoly;
        buildAdaptiveQuadratic(
          this.currentPoly.points,
          currentPoly.lastX,
          currentPoly.lastY,
          cp1x,
          cp1y,
          x2,
          y
        );
        return this;
      }
      closePath() {
        this.endPoly(true);
        return this;
      }
      addPath(path2, transform) {
        this.endPoly();
        if (transform && !transform.isIdentity()) {
          path2 = path2.clone(true);
          path2.transform(transform);
        }
        for (let i = 0; i < path2.instructions.length; i++) {
          const instruction = path2.instructions[i];
          this[instruction.action](...instruction.data);
        }
        return this;
      }
      finish(closePath = false) {
        this.endPoly(closePath);
      }
      rect(x2, y, w, h, transform) {
        this.drawShape(new Rectangle(x2, y, w, h), transform);
        return this;
      }
      circle(x2, y, radius, transform) {
        this.drawShape(new Circle(x2, y, radius), transform);
        return this;
      }
      poly(points, close, transform) {
        const polygon = new Polygon(points);
        polygon.closePath = close;
        this.drawShape(polygon, transform);
      }
      ellipse(x2, y, radiusX, radiusY, transform) {
        this.drawShape(new Ellipse(x2, y, radiusX, radiusY), transform);
        return this;
      }
      roundRect(x2, y, w, h, radii, transform) {
        this.drawShape(new RoundedRectangle(x2, y, w, h, radii), transform);
        return this;
      }
      drawShape(shape, matrix) {
        this.endPoly();
        this.shapePrimitives.push({ shape, transform: matrix });
        return this;
      }
      startPoly(x2, y) {
        let currentPoly = this.currentPoly;
        if (currentPoly) {
          this.endPoly();
        }
        currentPoly = new Polygon();
        currentPoly.points.push(x2, y);
        this.currentPoly = currentPoly;
        return this;
      }
      endPoly(closePath = false) {
        const shape = this.currentPoly;
        if (shape && shape.points.length > 2) {
          shape.closePath = closePath;
          this.shapePrimitives.push({ shape });
        }
        this.currentPoly = null;
        return this;
      }
      _ensurePoly(start = true) {
        if (this.currentPoly)
          return;
        this.currentPoly = new Polygon();
        if (start) {
          const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];
          if (lastShape) {
            let lx = lastShape.shape.x;
            let ly = lastShape.shape.y;
            if (lastShape.transform.isIdentity()) {
              const t = lastShape.transform;
              const tempX = lx;
              lx = t.a * lx + t.c * ly + t.tx;
              ly = t.b * tempX + t.d * ly + t.ty;
            }
            this.currentPoly.points.push(lx, lx);
          } else {
            this.currentPoly.points.push(0, 0);
          }
        }
      }
      buildPath() {
        const path2 = this.graphicsPath2D;
        this.shapePrimitives.length = 0;
        this.currentPoly = null;
        for (let i = 0; i < path2.instructions.length; i++) {
          const instruction = path2.instructions[i];
          this[instruction.action](...instruction.data);
        }
        this.finish();
      }
      isPointInPath(x2, y) {
        const shapePrimitives = this.shapePrimitives;
        for (let i = 0; i < shapePrimitives.length; i++) {
          const shapePrimitive = shapePrimitives[i];
          if (shapePrimitive.shape.contains(x2, y)) {
            return true;
          }
        }
        return false;
      }
      get bounds() {
        const bounds = this._bounds;
        bounds.clear();
        const shapePrimitives = this.shapePrimitives;
        for (let i = 0; i < shapePrimitives.length; i++) {
          const shapePrimitive = shapePrimitives[i];
          const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);
          if (shapePrimitive.transform) {
            bounds.pushMatrix(shapePrimitive.transform);
            bounds.addRect(boundsRect);
            bounds.popMatrix();
          } else {
            bounds.addRect(boundsRect);
          }
        }
        return bounds;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/path/GraphicsPath.mjs
function adjustTransform(currentMatrix, transform) {
  if (currentMatrix) {
    return currentMatrix.prepend(transform);
  }
  return transform.clone();
}
var UID6, GraphicsPath;
var init_GraphicsPath = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/path/GraphicsPath.mjs"() {
    init_Point();
    init_SVGToGraphicsPath();
    init_ShapePath();
    UID6 = 0;
    GraphicsPath = class _GraphicsPath {
      constructor(instructions) {
        this.instructions = [];
        this.uid = UID6++;
        this.dirty = true;
        if (typeof instructions === "string") {
          SVGToGraphicsPath(instructions, this);
        } else {
          this.instructions = instructions?.slice() ?? [];
        }
      }
      get shapePath() {
        if (!this._shapePath) {
          this._shapePath = new ShapePath(this);
        }
        if (this.dirty) {
          this.dirty = false;
          this._shapePath.buildPath();
        }
        return this._shapePath;
      }
      addPath(path2, transform) {
        path2 = path2.clone();
        this.instructions.push({ action: "addPath", data: [path2, transform] });
        this.dirty = true;
        return this;
      }
      arc(...args) {
        this.instructions.push({ action: "arc", data: args });
        this.dirty = true;
        return this;
      }
      arcTo(...args) {
        this.instructions.push({ action: "arcTo", data: args });
        this.dirty = true;
        return this;
      }
      arcToSvg(...args) {
        this.instructions.push({ action: "arcToSvg", data: args });
        this.dirty = true;
        return this;
      }
      bezierCurveTo(...args) {
        this.instructions.push({ action: "bezierCurveTo", data: args });
        this.dirty = true;
        return this;
      }
      bezierCurveToShort(cp2x, cp2y, x2, y) {
        const last = this.instructions[this.instructions.length - 1];
        const lastPoint = this.getLastPoint(Point.shared);
        let cp1x = 0;
        let cp1y = 0;
        if (!last || last.action !== "bezierCurveTo") {
          cp1x = lastPoint.x;
          cp1y = lastPoint.y;
        } else {
          cp1x = last.data[2];
          cp1y = last.data[3];
          const currentX = lastPoint.x;
          const currentY = lastPoint.y;
          cp1x = currentX + (currentX - cp1x);
          cp1y = currentY + (currentY - cp1y);
        }
        this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x2, y] });
        this.dirty = true;
        return this;
      }
      closePath() {
        this.instructions.push({ action: "closePath", data: [] });
        this.dirty = true;
        return this;
      }
      ellipse(...args) {
        this.instructions.push({ action: "ellipse", data: args });
        this.dirty = true;
        return this;
      }
      lineTo(...args) {
        this.instructions.push({ action: "lineTo", data: args });
        this.dirty = true;
        return this;
      }
      moveTo(...args) {
        this.instructions.push({ action: "moveTo", data: args });
        return this;
      }
      quadraticCurveTo(...args) {
        this.instructions.push({ action: "quadraticCurveTo", data: args });
        this.dirty = true;
        return this;
      }
      quadraticCurveToShort(x2, y) {
        const last = this.instructions[this.instructions.length - 1];
        const lastPoint = this.getLastPoint(Point.shared);
        let cpx1 = 0;
        let cpy1 = 0;
        if (!last || last.action !== "quadraticCurveTo") {
          cpx1 = lastPoint.x;
          cpy1 = lastPoint.y;
        } else {
          cpx1 = last.data[0];
          cpy1 = last.data[1];
          const currentX = lastPoint.x;
          const currentY = lastPoint.y;
          cpx1 = currentX + (currentX - cpx1);
          cpy1 = currentY + (currentY - cpy1);
        }
        this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x2, y] });
        this.dirty = true;
        return this;
      }
      rect(x2, y, w, h, transform) {
        this.instructions.push({ action: "rect", data: [x2, y, w, h, transform] });
        this.dirty = true;
        return this;
      }
      circle(x2, y, radius, transform) {
        this.instructions.push({ action: "circle", data: [x2, y, radius, transform] });
        this.dirty = true;
        return this;
      }
      roundRect(...args) {
        this.instructions.push({ action: "roundRect", data: args });
        this.dirty = true;
        return this;
      }
      poly(...args) {
        this.instructions.push({ action: "poly", data: args });
        this.dirty = true;
        return this;
      }
      star(x2, y, points, radius, innerRadius, rotation = 0, transform) {
        innerRadius = innerRadius || radius / 2;
        const startAngle = -1 * Math.PI / 2 + rotation;
        const len = points * 2;
        const delta = Math.PI * 2 / len;
        const polygon = [];
        for (let i = 0; i < len; i++) {
          const r = i % 2 ? innerRadius : radius;
          const angle = i * delta + startAngle;
          polygon.push(
            x2 + r * Math.cos(angle),
            y + r * Math.sin(angle)
          );
        }
        this.poly(polygon, true, transform);
        return this;
      }
      clone(deep = false) {
        const newGraphicsPath2D = new _GraphicsPath();
        if (!deep) {
          newGraphicsPath2D.instructions = this.instructions.slice();
        } else {
          for (let i = 0; i < this.instructions.length; i++) {
            const instruction = this.instructions[i];
            newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });
          }
        }
        return newGraphicsPath2D;
      }
      getLastPoint(out2) {
        let index = this.instructions.length - 1;
        let lastInstruction = this.instructions[index];
        if (!lastInstruction) {
          out2.x = 0;
          out2.y = 0;
          return out2;
        }
        while (lastInstruction.action === "closePath") {
          index--;
          if (index < 0) {
            out2.x = 0;
            out2.y = 0;
            return out2;
          }
          lastInstruction = this.instructions[index];
        }
        let x2;
        let y;
        let transform;
        switch (lastInstruction.action) {
          case "moveTo":
          case "lineTo":
            out2.x = lastInstruction.data[0];
            out2.y = lastInstruction.data[1];
            break;
          case "quadraticCurveTo":
            out2.x = lastInstruction.data[2];
            out2.y = lastInstruction.data[3];
            break;
          case "bezierCurveTo":
            out2.x = lastInstruction.data[4];
            out2.y = lastInstruction.data[5];
            break;
          case "arc":
          case "arcToSvg":
            out2.x = lastInstruction.data[5];
            out2.y = lastInstruction.data[6];
            break;
          case "addPath":
            out2.x = lastInstruction.data[0].lastX;
            out2.y = lastInstruction.data[2].lastY;
            break;
          case "rect":
            transform = lastInstruction.data[4];
            x2 = lastInstruction.data[0];
            y = lastInstruction.data[1];
            if (transform) {
              const { a, b, c, d: d2, tx, ty } = transform;
              out2.x = a * x2 + c * y + tx;
              out2.y = b * x2 + d2 * y + ty;
            } else {
              out2.x = x2;
              out2.y = y;
            }
            break;
          default:
            console.warn(`${lastInstruction.action} is not supported yet`);
            break;
        }
        return out2;
      }
      clear() {
        this.instructions.length = 0;
        this.dirty = true;
        return this;
      }
      transform(matrix) {
        if (matrix.isIdentity())
          return this;
        const a = matrix.a;
        const b = matrix.b;
        const c = matrix.c;
        const d2 = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        let x2 = 0;
        let y = 0;
        let cpx1 = 0;
        let cpy1 = 0;
        let cpx2 = 0;
        let cpy2 = 0;
        let rx = 0;
        let ry = 0;
        for (let i = 0; i < this.instructions.length; i++) {
          const instruction = this.instructions[i];
          const data = instruction.data;
          switch (instruction.action) {
            case "moveTo":
            case "lineTo":
              x2 = data[0];
              y = data[1];
              data[0] = a * x2 + c * y + tx;
              data[1] = b * x2 + d2 * y + ty;
              break;
            case "bezierCurveTo":
              cpx1 = data[0];
              cpy1 = data[1];
              cpx2 = data[2];
              cpy2 = data[3];
              x2 = data[4];
              y = data[5];
              data[0] = a * cpx1 + c * cpy1 + tx;
              data[1] = b * cpx1 + d2 * cpy1 + ty;
              data[2] = a * cpx2 + c * cpy2 + tx;
              data[3] = b * cpx2 + d2 * cpy2 + ty;
              data[4] = a * x2 + c * y + tx;
              data[5] = b * x2 + d2 * y + ty;
              break;
            case "quadraticCurveTo":
              cpx1 = data[0];
              cpy1 = data[1];
              x2 = data[2];
              y = data[3];
              data[0] = a * cpx1 + c * cpy1 + tx;
              data[1] = b * cpx1 + d2 * cpy1 + ty;
              data[2] = a * x2 + c * y + tx;
              data[3] = b * x2 + d2 * y + ty;
              break;
            case "arcToSvg":
              x2 = data[5];
              y = data[6];
              rx = data[0];
              ry = data[1];
              data[0] = a * rx + c * ry;
              data[1] = b * rx + d2 * ry;
              data[5] = a * x2 + c * y + tx;
              data[6] = b * x2 + d2 * y + ty;
              break;
            case "rect":
              data[4] = adjustTransform(data[4], matrix);
              break;
            case "ellipse":
              data[8] = adjustTransform(data[8], matrix);
              break;
            case "roundRect":
              data[5] = adjustTransform(data[5], matrix);
              break;
            case "addPath":
              data[0].transform(matrix);
              break;
            default:
              console.warn("unknown transform action", instruction.action);
              break;
          }
        }
        this.dirty = true;
        return this;
      }
      get bounds() {
        return this.shapePath.bounds;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/svg/SVGParser.mjs
function SVGParser(svg, graphicsContext) {
  if (typeof svg === "string") {
    const div = document.createElement("div");
    div.innerHTML = svg.trim();
    svg = div.querySelector("svg");
  }
  const session = {
    context: graphicsContext,
    path: new GraphicsPath()
  };
  renderChildren(svg, session, null, null);
  return graphicsContext;
}
function renderChildren(svg, session, fillStyle, strokeStyle) {
  const children = svg.children;
  const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);
  if (f1 && fillStyle) {
    fillStyle = { ...fillStyle, ...f1 };
  } else if (f1) {
    fillStyle = f1;
  }
  if (s1 && strokeStyle) {
    strokeStyle = { ...strokeStyle, ...s1 };
  } else if (s1) {
    strokeStyle = s1;
  }
  session.context.fillStyle = fillStyle;
  session.context.strokeStyle = strokeStyle;
  let x2;
  let y;
  let x1;
  let y1;
  let x22;
  let y2;
  let cx;
  let cy;
  let r;
  let rx;
  let ry;
  let points;
  let pointsString;
  let d2;
  let graphicsPath;
  let width;
  let height;
  switch (svg.nodeName.toLowerCase()) {
    case "path":
      d2 = svg.getAttribute("d");
      graphicsPath = new GraphicsPath(d2);
      session.context.path(graphicsPath);
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "circle":
      cx = parseFloatAttribute(svg, "cx", 0);
      cy = parseFloatAttribute(svg, "cy", 0);
      r = parseFloatAttribute(svg, "r", 0);
      session.context.ellipse(cx, cy, r, r);
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "rect":
      x2 = parseFloatAttribute(svg, "x", 0);
      y = parseFloatAttribute(svg, "y", 0);
      width = parseFloatAttribute(svg, "width", 0);
      height = parseFloatAttribute(svg, "height", 0);
      rx = parseFloatAttribute(svg, "rx", 0);
      ry = parseFloatAttribute(svg, "ry", 0);
      if (rx || ry) {
        session.context.roundRect(x2, y, width, height, rx || ry);
      } else {
        session.context.rect(x2, y, width, height);
      }
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "ellipse":
      cx = parseFloatAttribute(svg, "cx", 0);
      cy = parseFloatAttribute(svg, "cy", 0);
      rx = parseFloatAttribute(svg, "rx", 0);
      ry = parseFloatAttribute(svg, "ry", 0);
      session.context.beginPath();
      session.context.ellipse(cx, cy, rx, ry);
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "line":
      x1 = parseFloatAttribute(svg, "x1", 0);
      y1 = parseFloatAttribute(svg, "y1", 0);
      x22 = parseFloatAttribute(svg, "x2", 0);
      y2 = parseFloatAttribute(svg, "y2", 0);
      session.context.beginPath();
      session.context.moveTo(x1, y1);
      session.context.lineTo(x22, y2);
      if (strokeStyle)
        session.context.stroke();
      break;
    case "polygon":
      pointsString = svg.getAttribute("points");
      points = pointsString.match(/\d+/g).map((n) => parseInt(n, 10));
      session.context.poly(points, true);
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "polyline":
      pointsString = svg.getAttribute("points");
      points = pointsString.match(/\d+/g).map((n) => parseInt(n, 10));
      session.context.poly(points, false);
      if (strokeStyle)
        session.context.stroke();
      break;
    case "g":
    case "svg":
      break;
    default: {
      console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);
      break;
    }
  }
  for (let i = 0; i < children.length; i++) {
    renderChildren(children[i], session, fillStyle, strokeStyle);
  }
}
function parseFloatAttribute(svg, id, defaultValue2) {
  const value = svg.getAttribute(id);
  return value ? Number(value) : defaultValue2;
}
function parseStyle(svg) {
  const style = svg.getAttribute("style");
  const strokeStyle = {};
  const fillStyle = {};
  let useFill = false;
  let useStroke = false;
  if (style) {
    const styleParts = style.split(";");
    for (let i = 0; i < styleParts.length; i++) {
      const stylePart = styleParts[i];
      const [key, value] = stylePart.split(":");
      switch (key) {
        case "stroke":
          if (value !== "none") {
            strokeStyle.color = convertColorToNumber(value);
            useStroke = true;
          }
          break;
        case "stroke-width":
          strokeStyle.width = Number(value);
          break;
        case "fill":
          if (value !== "none") {
            useFill = true;
            fillStyle.color = convertColorToNumber(value);
          }
          break;
        case "fill-opacity":
          fillStyle.alpha = Number(value);
          break;
        case "stroke-opacity":
          strokeStyle.alpha = Number(value);
          break;
        case "opacity":
          fillStyle.alpha = Number(value);
          strokeStyle.alpha = Number(value);
          break;
      }
    }
  } else {
    const stroke = svg.getAttribute("stroke");
    if (stroke && stroke !== "none") {
      useStroke = true;
      strokeStyle.color = convertColorToNumber(stroke);
      strokeStyle.width = parseFloatAttribute(svg, "stroke-width", 1);
    }
    const fill = svg.getAttribute("fill");
    if (fill && fill !== "none") {
      useFill = true;
      fillStyle.color = convertColorToNumber(fill);
    }
  }
  return { strokeStyle: useStroke ? strokeStyle : null, fillStyle: useFill ? fillStyle : null };
}
var init_SVGParser = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/svg/SVGParser.mjs"() {
    init_convertColorToNumber();
    init_GraphicsPath();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/utils/convertFillInputToFillStyle.mjs
function convertFillInputToFillStyle(value, defaultStyle) {
  if (!value) {
    return null;
  }
  let fillStyleToParse;
  let styleToMerge;
  if (value?.fill) {
    styleToMerge = value.fill;
    fillStyleToParse = { ...defaultStyle, ...value };
  } else {
    styleToMerge = value;
    fillStyleToParse = defaultStyle;
  }
  if (typeof styleToMerge === "number" || typeof styleToMerge === "string") {
    return {
      ...fillStyleToParse,
      color: convertColorToNumber(styleToMerge),
      texture: Texture.WHITE
    };
  } else if (styleToMerge instanceof FillPattern) {
    const pattern = styleToMerge;
    return {
      ...fillStyleToParse,
      color: 16777215,
      texture: pattern.texture,
      matrix: pattern.transform
    };
  } else if (styleToMerge instanceof FillGradient) {
    const gradient = styleToMerge;
    gradient.buildLinearGradient();
    return {
      ...fillStyleToParse,
      color: 16777215,
      texture: gradient.texture,
      matrix: gradient.transform
    };
  }
  const style = { ...defaultStyle, ...value };
  if (style.texture !== Texture.WHITE) {
    const m2 = style.matrix || new Matrix();
    m2.scale(
      1 / style.texture.frameWidth,
      1 / style.texture.frameHeight
    );
    style.matrix = m2;
    style.color = 16777215;
  }
  style.color = convertColorToNumber(style.color);
  return style;
}
var init_convertFillInputToFillStyle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/utils/convertFillInputToFillStyle.mjs"() {
    init_Matrix();
    init_convertColorToNumber();
    init_Texture();
    init_FillGradient();
    init_FillPattern();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/GraphicsContext.mjs
var UID7, tmpPoint, tempMatrix2, _GraphicsContext, GraphicsContext;
var init_GraphicsContext = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/GraphicsContext.mjs"() {
    init_eventemitter3();
    init_Matrix();
    init_Point();
    init_convertColorToNumber();
    init_Texture();
    init_Bounds();
    init_FillGradient();
    init_FillPattern();
    init_GraphicsPath();
    init_SVGParser();
    init_convertFillInputToFillStyle();
    UID7 = 0;
    tmpPoint = new Point();
    tempMatrix2 = new Matrix();
    _GraphicsContext = class extends eventemitter3_default {
      constructor() {
        super(...arguments);
        this.uid = UID7++;
        this.usage = 0;
        this.dirty = true;
        this.batchMode = "auto";
        this.instructions = [];
        this.activePath = new GraphicsPath();
        this._transform = new Matrix();
        this._fillStyle = { ..._GraphicsContext.defaultFillStyle };
        this._fillStyleOriginal = 16777215;
        this._strokeStyle = { ..._GraphicsContext.defaultStrokeStyle };
        this._strokeStyleOriginal = 16777215;
        this._stateStack = [];
        this._tick = 0;
        this._bounds = new Bounds();
        this.boundsDirty = true;
      }
      set fillStyle(value) {
        if (this._fillStyleOriginal === value)
          return;
        this._fillStyleOriginal = value;
        if (typeof value === "number" || typeof value === "string") {
          this._fillStyle.color = convertColorToNumber(value);
          this._fillStyle.texture = Texture.WHITE;
        } else if (value instanceof FillPattern) {
          const pattern = value;
          this._fillStyle.color = 16777215;
          this._fillStyle.texture = pattern.texture;
          this._fillStyle.matrix = pattern.transform;
        } else if (value instanceof FillGradient) {
          const gradient = value;
          gradient.buildLinearGradient();
          this._fillStyle.color = 16777215;
          this._fillStyle.texture = gradient.texture;
          this._fillStyle.matrix = gradient.transform;
        } else {
          this._fillStyle = { ..._GraphicsContext.defaultFillStyle, ...value };
        }
      }
      get fillStyle() {
        return this._fillStyleOriginal;
      }
      set strokeStyle(value) {
        if (this._strokeStyleOriginal === value)
          return;
        this._strokeStyleOriginal = value;
        if (typeof value === "number" || typeof value === "string") {
          this._strokeStyle.color = convertColorToNumber(value);
          this._strokeStyle.texture = Texture.WHITE;
        } else if (value instanceof FillGradient) {
          const gradient = value;
          gradient.buildLinearGradient();
          this._strokeStyle.color = 16777215;
          this._strokeStyle.texture = gradient.texture;
          this._strokeStyle.matrix = gradient.transform;
        } else {
          this._strokeStyle = { ..._GraphicsContext.defaultStrokeStyle, ...value };
        }
      }
      get strokeStyle() {
        return this._strokeStyleOriginal;
      }
      setFillStyle(style) {
        this.fillStyle = style;
        return this;
      }
      setStrokeStyle(style) {
        this.strokeStyle = style;
        return this;
      }
      texture(texture, tint, dx, dy, dw, dh) {
        this.instructions.push({
          action: "texture",
          data: {
            image: texture,
            dx: dx || 0,
            dy: dy || 0,
            dw: dw || texture.frameWidth,
            dh: dh || texture.frameHeight,
            transform: this._transform.clone(),
            alpha: this._fillStyle.alpha,
            style: tint || 16777215
          }
        });
        this.onUpdate();
        return this;
      }
      beginPath() {
        this.activePath = new GraphicsPath();
        return this;
      }
      fill(style) {
        let path2;
        const lastInstruction = this.instructions[this.instructions.length - 1];
        if (this._tick === 0 && lastInstruction && lastInstruction.action === "stroke") {
          path2 = lastInstruction.data.path;
        } else {
          path2 = this.activePath.clone();
        }
        if (!path2)
          return this;
        let fillStyle = this._fillStyle;
        if (style) {
          fillStyle = convertFillInputToFillStyle(style, _GraphicsContext.defaultFillStyle);
        }
        this.instructions.push({
          action: "fill",
          // TODO copy fill style!
          data: { style: fillStyle, path: path2 }
        });
        this.onUpdate();
        this.activePath.instructions.length = 0;
        this._tick = 0;
        return this;
      }
      stroke(style) {
        let path2;
        const lastInstruction = this.instructions[this.instructions.length - 1];
        if (this._tick === 0 && lastInstruction && lastInstruction.action === "fill") {
          path2 = lastInstruction.data.path;
        } else {
          path2 = this.activePath.clone();
        }
        if (!path2)
          return this;
        let strokeStyle = this._strokeStyle;
        if (style) {
          strokeStyle = convertFillInputToFillStyle(style, _GraphicsContext.defaultStrokeStyle);
        }
        this.instructions.push({
          action: "stroke",
          // TODO copy fill style!
          data: { style: strokeStyle, path: path2 }
        });
        this.onUpdate();
        this.activePath.instructions.length = 0;
        this._tick = 0;
        return this;
      }
      cut() {
        for (let i = 0; i < 2; i++) {
          const lastInstruction = this.instructions[this.instructions.length - 1 - i];
          const holePath = this.activePath.clone();
          if (lastInstruction) {
            if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {
              lastInstruction.data.hole = holePath;
            }
          }
        }
        this.activePath.instructions.length = 0;
        return this;
      }
      arc(x2, y, radius, startAngle, endAngle, counterclockwise) {
        this._tick++;
        const t = this._transform;
        this.activePath.arc(
          t.a * x2 + t.c * y + t.tx,
          t.b * x2 + t.d * y + t.ty,
          radius,
          startAngle,
          endAngle,
          counterclockwise
        );
        return this;
      }
      arcTo(x1, y1, x2, y2, radius) {
        this._tick++;
        const t = this._transform;
        this.activePath.arcTo(
          t.a * x1 + t.c * y1 + t.tx,
          t.b * x1 + t.d * y1 + t.ty,
          t.a * x2 + t.c * y2 + t.tx,
          t.b * x2 + t.d * y2 + t.ty,
          radius
        );
        return this;
      }
      arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y) {
        this._tick++;
        const t = this._transform;
        this.activePath.arcToSvg(
          rx,
          ry,
          xAxisRotation,
          // should we rotate this with transform??
          largeArcFlag,
          sweepFlag,
          t.a * x2 + t.c * y + t.tx,
          t.b * x2 + t.d * y + t.ty
        );
        return this;
      }
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y) {
        this._tick++;
        const t = this._transform;
        this.activePath.bezierCurveTo(
          t.a * cp1x + t.c * cp1y + t.tx,
          t.b * cp1x + t.d * cp1y + t.ty,
          t.a * cp2x + t.c * cp2y + t.tx,
          t.b * cp2x + t.d * cp2y + t.ty,
          t.a * x2 + t.c * y + t.tx,
          t.b * x2 + t.d * y + t.ty
        );
        return this;
      }
      closePath() {
        this._tick++;
        this.activePath?.closePath();
        return this;
      }
      ellipse(x2, y, radiusX, radiusY) {
        this._tick++;
        this.activePath.ellipse(x2, y, radiusX, radiusY, this._transform.clone());
        return this;
      }
      circle(x2, y, radius) {
        this._tick++;
        this.activePath.circle(x2, y, radius, this._transform.clone());
        return this;
      }
      path(path2) {
        this._tick++;
        this.activePath.addPath(path2, this._transform.clone());
        return this;
      }
      lineTo(x2, y) {
        this._tick++;
        const t = this._transform;
        this.activePath.lineTo(
          t.a * x2 + t.c * y + t.tx,
          t.b * x2 + t.d * y + t.ty
        );
        return this;
      }
      moveTo(x2, y) {
        this._tick++;
        const t = this._transform;
        this.activePath.moveTo(
          t.a * x2 + t.c * y + t.tx,
          t.b * x2 + t.d * y + t.ty
        );
        return this;
      }
      quadraticCurveTo(cpx, cpy, x2, y) {
        this._tick++;
        const t = this._transform;
        this.activePath.quadraticCurveTo(
          t.a * cpx + t.c * cpy + t.tx,
          t.b * cpx + t.d * cpy + t.ty,
          t.a * x2 + t.c * y + t.tx,
          t.b * x2 + t.d * y + t.ty
        );
      }
      rect(x2, y, w, h) {
        this._tick++;
        this.activePath.rect(x2, y, w, h, this._transform.clone());
        return this;
      }
      roundRect(x2, y, w, h, radii) {
        this._tick++;
        this.activePath.roundRect(x2, y, w, h, radii, this._transform.clone());
        return this;
      }
      poly(points, close) {
        this._tick++;
        this.activePath.poly(points, close, this._transform.clone());
        return this;
      }
      star(x2, y, points, radius, innerRadius, rotation) {
        this._tick++;
        this.activePath.star(x2, y, points, radius, innerRadius, rotation, this._transform.clone());
        return this;
      }
      svg(svg) {
        this._tick++;
        SVGParser(svg, this);
      }
      restore() {
        const state = this._stateStack.pop();
        if (state) {
          this._transform = state.transform;
          this._fillStyle = state.fillStyle;
          this._strokeStyle = state.strokeStyle;
        }
      }
      save() {
        this._stateStack.push({
          transform: this._transform.clone(),
          fillStyle: { ...this._fillStyle },
          strokeStyle: { ...this._strokeStyle }
        });
      }
      getTransform() {
        return this._transform;
      }
      resetTransform() {
        this._transform.identity();
        return this;
      }
      rotate(angle) {
        this._transform.rotate(angle);
        return this;
      }
      scale(x2, y = x2) {
        this._transform.scale(x2, y);
        return this;
      }
      setTransform(a, b, c, d2, dx, dy) {
        if (a instanceof Matrix) {
          this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);
          return this;
        }
        this._transform.set(a, b, c, d2, dx, dy);
        return this;
      }
      transform(a, b, c, d2, dx, dy) {
        if (a instanceof Matrix) {
          this._transform.append(a);
          return this;
        }
        tempMatrix2.set(a, b, c, d2, dx, dy);
        this._transform.append(tempMatrix2);
        return this;
      }
      translate(x2, y) {
        this._transform.translate(x2, y);
        return this;
      }
      clear() {
        this.instructions.length = 0;
        this.resetTransform();
        this.onUpdate();
        return this;
      }
      onUpdate() {
        if (this.dirty)
          return;
        this.emit("update", this, 16);
        this.dirty = true;
        this.boundsDirty = true;
      }
      get bounds() {
        if (!this.boundsDirty)
          return this._bounds;
        const bounds = this._bounds;
        bounds.clear();
        for (let i = 0; i < this.instructions.length; i++) {
          const instruction = this.instructions[i];
          const action = instruction.action;
          if (action === "fill") {
            const data = instruction.data;
            bounds.addBounds(data.path.bounds);
          } else if (action === "texture") {
            const data = instruction.data;
            bounds.pushMatrix(data.transform);
            bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh);
            bounds.popMatrix();
          }
        }
        return bounds;
      }
      /**
       * Check to see if a point is contained within this geometry.
       * @param point - Point to check if it's contained.
       * @returns {boolean} `true` if the point is contained within geometry.
       */
      containsPoint(point) {
        const instructions = this.instructions;
        let hasHit = false;
        instructions.forEach((instruction) => {
          const data = instruction.data;
          const path2 = data.path;
          if (!instruction.action || !path2)
            return;
          const style = data.style;
          const shapes = path2.shapePath?.shapePrimitives;
          this._forEachShape(shapes, (shape) => {
            if (!style || !shape)
              return;
            if (typeof style !== "number" && style.matrix) {
              style.matrix.applyInverse(point, tmpPoint);
            } else {
              tmpPoint.copyFrom(point);
            }
            hasHit = shape.contains(tmpPoint.x, tmpPoint.y);
            const holes = data.hole;
            if (!holes)
              return;
            const holeShapes = holes.shapePath?.shapePrimitives;
            if (!holeShapes)
              return;
            this._forEachShape(holeShapes, (hole) => {
              if (hole.contains(tmpPoint.x, tmpPoint.y)) {
                hasHit = false;
              }
            });
          });
        });
        return hasHit;
      }
      _forEachShape(shapes, callback) {
        shapes?.forEach((shapePrimitive) => {
          const shape = shapePrimitive?.shape;
          if (shape) {
            callback(shape);
          }
        });
      }
      /**
       * Destroys the GraphicsData object.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?
       * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?
       */
      destroy(options = false) {
        this._stateStack.length = 0;
        this._transform = null;
        this.emit("destroy", this);
        this.removeAllListeners();
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          if (this._fillStyle.texture) {
            this._fillStyle.texture.destroy(destroyTextureSource);
          }
          if (this._strokeStyle.texture) {
            this._strokeStyle.texture.destroy(destroyTextureSource);
          }
        }
        this._fillStyle = null;
        this._strokeStyle = null;
        this.instructions = null;
        this.activePath = null;
        this._bounds = null;
        this._stateStack = null;
        this.transformMatrix = null;
        this.customShader = null;
        this._transform = null;
      }
    };
    GraphicsContext = _GraphicsContext;
    GraphicsContext.defaultFillStyle = {
      color: 0,
      alpha: 1,
      texture: Texture.WHITE
    };
    GraphicsContext.defaultStrokeStyle = {
      width: 1,
      color: 0,
      alpha: 1,
      alignment: 0.5,
      miterLimit: 10,
      cap: "butt",
      join: "miter",
      texture: Texture.WHITE
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs
var SVG_XML, validSVGExtension, validSVGMIME, loadSvg;
var init_loadSVG = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs"() {
    init_Extensions();
    init_GraphicsContext();
    init_settings();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
    validSVGExtension = ".svg";
    validSVGMIME = "image/svg+xml";
    loadSvg = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Low
      },
      name: "loadSVG",
      test(url) {
        return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);
      },
      async testParse(data) {
        return typeof data === "string" && data.startsWith("data:image/svg+xml") || typeof data === "string" && SVG_XML.test(data);
      },
      async parse(asset) {
        const context = new GraphicsContext();
        context.svg(asset);
        return context;
      },
      async load(url) {
        const response = await settings.ADAPTER.fetch(url);
        return response.text();
      }
      // TODO: unload function
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs
function getResolutionOfUrl(url, defaultValue2 = 1) {
  const resolution = settings.RETINA_PREFIX?.exec(url);
  if (resolution) {
    return parseFloat(resolution[1]);
  }
  return defaultValue2;
}
var init_getResolutionOfUrl = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs"() {
    init_settings();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/loader/parsers/WorkerManager.mjs
var UUID, MAX_WORKERS, WHITE_PNG, checkImageBitmapCode, workerCode, workerURL, WorkerManagerClass, WorkerManager;
var init_WorkerManager = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/loader/parsers/WorkerManager.mjs"() {
    UUID = 0;
    WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    checkImageBitmapCode = {
      id: "checkImageBitmap",
      code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${WHITE_PNG}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
    };
    workerCode = {
      id: "loadImageBitmap",
      code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
    };
    WorkerManagerClass = class {
      constructor() {
        this._initialized = false;
        this._createdWorkers = 0;
        this.workerPool = [];
        this.queue = [];
        this.resolveHash = {};
      }
      isImageBitmapSupported() {
        if (this._isImageBitmapSupported !== void 0)
          return this._isImageBitmapSupported;
        this._isImageBitmapSupported = new Promise((resolve) => {
          const workerURL2 = URL.createObjectURL(new Blob(
            [checkImageBitmapCode.code],
            { type: "application/javascript" }
          ));
          const worker = new Worker(workerURL2);
          worker.addEventListener("message", (event) => {
            worker.terminate();
            URL.revokeObjectURL(workerURL2);
            resolve(event.data);
          });
        });
        return this._isImageBitmapSupported;
      }
      loadImageBitmap(src) {
        return this._run("loadImageBitmap", [src]);
      }
      async _initWorkers() {
        if (this._initialized)
          return;
        this._initialized = true;
      }
      getWorker() {
        if (MAX_WORKERS === void 0) {
          MAX_WORKERS = navigator.hardwareConcurrency || 4;
        }
        let worker = this.workerPool.pop();
        if (!worker && this._createdWorkers < MAX_WORKERS) {
          if (!workerURL) {
            workerURL = URL.createObjectURL(new Blob([workerCode.code], { type: "application/javascript" }));
          }
          this._createdWorkers++;
          worker = new Worker(workerURL);
          worker.addEventListener("message", (event) => {
            this.complete(event.data);
            this.returnWorker(event.target);
            this.next();
          });
        }
        return worker;
      }
      returnWorker(worker) {
        this.workerPool.push(worker);
      }
      complete(data) {
        if (data.error !== void 0) {
          this.resolveHash[data.uuid].reject(data.error);
        } else {
          this.resolveHash[data.uuid].resolve(data.data);
        }
        this.resolveHash[data.uuid] = null;
      }
      async _run(id, args) {
        await this._initWorkers();
        const promise = new Promise((resolve, reject) => {
          this.queue.push({ id, arguments: args, resolve, reject });
        });
        this.next();
        return promise;
      }
      next() {
        if (!this.queue.length)
          return;
        const worker = this.getWorker();
        if (!worker) {
          return;
        }
        const toDo = this.queue.pop();
        const id = toDo.id;
        this.resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };
        worker.postMessage({
          data: toDo.arguments,
          uuid: UUID++,
          id
        });
      }
    };
    WorkerManager = new WorkerManagerClass();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs
function createTexture(source3, _loader, _url) {
  const texture = new Texture({
    source: source3,
    label: _url
  });
  return texture;
}
var init_createTexture = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs"() {
    init_Texture();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs
async function loadImageBitmap(url) {
  const response = await settings.ADAPTER.fetch(url);
  if (!response.ok) {
    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);
  }
  const imageBlob = await response.blob();
  const imageBitmap = await createImageBitmap(imageBlob);
  return imageBitmap;
}
var validImageExtensions, validImageMIMEs, loadTextures;
var init_loadTextures = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs"() {
    init_Extensions();
    init_ImageSource();
    init_settings();
    init_getResolutionOfUrl();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    init_WorkerManager();
    init_createTexture();
    validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
    validImageMIMEs = [
      "image/jpeg",
      "image/png",
      "image/webp",
      "image/avif"
    ];
    loadTextures = {
      name: "loadTextures",
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.High
      },
      config: {
        preferWorkers: true,
        preferCreateImageBitmap: true,
        crossOrigin: "anonymous"
      },
      test(url) {
        return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);
      },
      async load(url, asset, loader) {
        let src = null;
        if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {
          if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {
            src = await WorkerManager.loadImageBitmap(url);
          } else {
            src = await loadImageBitmap(url);
          }
        } else {
          src = await new Promise((resolve) => {
            src = new Image();
            src.crossOrigin = this.config.crossOrigin;
            src.src = url;
            if (src.complete) {
              resolve(src);
            } else {
              src.onload = () => {
                resolve(src);
              };
            }
          });
        }
        const base = new ImageSource({
          resource: src,
          resolution: asset.data?.resolution || getResolutionOfUrl(url),
          ...asset.data
        });
        return createTexture(base, loader, url);
      },
      unload(texture) {
        texture.destroy(true);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs
var resolveTextureUrl;
var init_resolveTextureUrl = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs"() {
    init_Extensions();
    init_settings();
    init_loadTextures();
    resolveTextureUrl = {
      extension: ExtensionType.ResolveParser,
      test: loadTextures.test,
      parse: (value) => ({
        resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
        format: value.split(".").pop(),
        src: value
      })
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/init.mjs
var assetKeyMap;
var init_init2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/init.mjs"() {
    init_Extensions();
    init_loadBitmapFont();
    init_cacheTextureArray();
    init_detectAvif();
    init_detectDefaults();
    init_detectMp4();
    init_detectOgv();
    init_detectWebm();
    init_detectWebp();
    init_loadJson();
    init_loadTxt();
    init_loadWebFont();
    init_loadSVG();
    init_loadTextures();
    init_resolveTextureUrl();
    extensions.add(
      cacheTextureArray,
      detectDefaults,
      detectAvif,
      detectWebp,
      detectMp4,
      detectOgv,
      detectWebm,
      loadJson,
      loadTxt,
      loadWebFont,
      loadSvg,
      loadTextures,
      resolveTextureUrl,
      // TODO: these should probably be moved to its own init, along with splitting out all the
      // text pipeline stuff
      xmlBitmapFontLoader,
      bitmapFontCachePlugin
    );
    assetKeyMap = {
      loader: ExtensionType.LoadParser,
      resolver: ExtensionType.ResolveParser,
      cache: ExtensionType.CacheParser,
      detection: ExtensionType.DetectionParser
    };
    extensions.handle(ExtensionType.Asset, (extension) => {
      const ref = extension.ref;
      Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => extensions.add(Object.assign(
        ref[key],
        // Allow the function to optionally define it's own
        // ExtensionMetadata, the use cases here is priority for LoaderParsers
        { extension: ref[key].extension ?? type }
      )));
    }, (extension) => {
      const ref = extension.ref;
      Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => extensions.remove(ref[key]));
    });
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/maths/ObservablePoint.mjs
var ObservablePoint;
var init_ObservablePoint = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/maths/ObservablePoint.mjs"() {
    ObservablePoint = class _ObservablePoint {
      /**
       * Creates a new `ObservablePoint`
       * @param observer - Observer to pass to listen for change events.
       * @param {number} [x=0] - position of the point on the x axis
       * @param {number} [y=0] - position of the point on the y axis
       */
      constructor(observer, x2, y) {
        this._x = x2 || 0;
        this._y = y || 0;
        this.observer = observer;
      }
      /**
       * Creates a clone of this point.
       * @param observer - Optional observer to pass to the new observable point.
       * @returns a copy of this observable point
       */
      clone(observer) {
        return new _ObservablePoint(observer, this._x, this._y);
      }
      /**
       * Sets the point to a new `x` and `y` position.
       * If `y` is omitted, both `x` and `y` will be set to `x`.
       * @param {number} [x=0] - position of the point on the x axis
       * @param {number} [y=x] - position of the point on the y axis
       * @returns The observable point instance itself
       */
      set(x2 = 0, y = x2) {
        if (this._x !== x2 || this._y !== y) {
          this._x = x2;
          this._y = y;
          this.observer.onUpdate();
        }
        return this;
      }
      /**
       * Copies x and y from the given point (`p`)
       * @param p - The point to copy from. Can be any of type that is or extends `PointData`
       * @returns The observable point instance itself
       */
      copyFrom(p) {
        if (this._x !== p.x || this._y !== p.y) {
          this._x = p.x;
          this._y = p.y;
          this.observer.onUpdate();
        }
        return this;
      }
      /**
       * Copies this point's x and y into that of the given point (`p`)
       * @param p - The point to copy to. Can be any of type that is or extends `PointData`
       * @returns The point (`p`) with values updated
       */
      copyTo(p) {
        p.set(this._x, this._y);
        return p;
      }
      /**
       * Accepts another point (`p`) and returns `true` if the given point is equal to this point
       * @param p - The point to check
       * @returns Returns `true` if both `x` and `y` are equal
       */
      equals(p) {
        return p.x === this._x && p.y === this._y;
      }
      toString() {
        return `[@pixi/math:ObservablePoint x=${0} y=${0} scope=${this.observer}]`;
      }
      /** Position of the observable point on the x axis. */
      get x() {
        return this._x;
      }
      set x(value) {
        if (this._x !== value) {
          this._x = value;
          this.observer.onUpdate(this);
        }
      }
      /** Position of the observable point on the y axis. */
      get y() {
        return this._y;
      }
      set y(value) {
        if (this._y !== value) {
          this._y = value;
          this.observer.onUpdate(this);
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/data/removeItems.mjs
function removeItems(arr, startIdx, removeCount) {
  const length = arr.length;
  let i;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  const len = length - removeCount;
  for (i = startIdx; i < len; ++i) {
    arr[i] = arr[i + removeCount];
  }
  arr.length = len;
}
var init_removeItems = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/data/removeItems.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/container-mixins/childrenHelperMixin.mjs
var childrenHelperMixin;
var init_childrenHelperMixin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/container-mixins/childrenHelperMixin.mjs"() {
    init_removeItems();
    childrenHelperMixin = {
      /**
       * Removes all children from this container that are within the begin and end indexes.
       * @param beginIndex - The beginning position.
       * @param endIndex - The ending position. Default value is size of the container.
       * @returns - List of removed children
       * @memberof PIXI.Container#
       */
      removeChildren(beginIndex = 0, endIndex) {
        const end = endIndex ?? this.children.length;
        const range = end - beginIndex;
        const removed = [];
        if (range > 0 && range <= end) {
          for (let i = end - 1; i >= beginIndex; i--) {
            const child = this.children[i];
            if (!child)
              continue;
            if (this.layerGroup) {
              this.layerGroup.removeChild(child);
            }
            removed.push(child);
            child.parent = null;
          }
          removeItems(this.children, beginIndex, end);
          for (let i = 0; i < removed.length; ++i) {
            this.emit("childRemoved", removed[i], this, i);
            removed[i].emit("removed", this);
          }
          return removed;
        } else if (range === 0 && this.children.length === 0) {
          return removed;
        }
        throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
      },
      /**
       * Removes a child from the specified index position.
       * @param index - The index to get the child from
       * @returns The child that was removed.
       * @memberof PIXI.Container#
       */
      removeChildAt(index) {
        const child = this.getChildAt(index);
        return this.removeChild(child);
      },
      /**
       * Returns the child at the specified index
       * @param index - The index to get the child at
       * @returns - The child at the given index, if any.
       * @memberof PIXI.Container#
       */
      getChildAt(index) {
        if (index < 0 || index >= this.children.length) {
          throw new Error(`getChildAt: Index (${index}) does not exist.`);
        }
        return this.children[index];
      },
      /**
       * Changes the position of an existing child in the container container
       * @param child - The child Container instance for which you want to change the index number
       * @param index - The resulting index number for the child container
       * @memberof PIXI.Container#
       */
      setChildIndex(child, index) {
        if (index < 0 || index >= this.children.length) {
          throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
        }
        this.getChildIndex(child);
        this.addChildAt(child, index);
      },
      /**
       * Returns the index position of a child Container instance
       * @param child - The Container instance to identify
       * @returns - The index position of the child container to identify
       * @memberof PIXI.Container#
       */
      getChildIndex(child) {
        const index = this.children.indexOf(child);
        if (index === -1) {
          throw new Error("The supplied Container must be a child of the caller");
        }
        return index;
      },
      /**
       * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
       * @param {PIXI.Container} child - The child to add
       * @param {number} index - The index to place the child in
       * @returns {PIXI.Container} The child that was added.
       * @memberof PIXI.Container#
       */
      addChildAt(child, index) {
        const { children } = this;
        if (index < 0 || index > children.length) {
          throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);
        }
        if (child.parent) {
          const currentIndex = child.parent.children.indexOf(child);
          if (child.parent === this && currentIndex === index) {
            return child;
          }
          if (currentIndex !== -1) {
            child.parent.children.splice(currentIndex, 1);
          }
        }
        if (index === children.length) {
          children.push(child);
        } else {
          children.splice(index, 0, child);
        }
        child.parent = this;
        child.didChange = true;
        child.didViewUpdate = false;
        child.updateFlags = 15;
        if (this.layerGroup) {
          this.layerGroup.addChild(child);
        }
        this.emit("childAdded", child, this, index);
        child.emit("added", this);
        return child;
      },
      /**
       * Swaps the position of 2 Containers within this container.
       * @param child - First container to swap
       * @param child2 - Second container to swap
       */
      swapChildren(child, child2) {
        if (child === child2) {
          return;
        }
        const index1 = this.getChildIndex(child);
        const index2 = this.getChildIndex(child2);
        this.children[index1] = child2;
        this.children[index2] = child;
      },
      /** Remove the DisplayObject from its parent Container. If the DisplayObject has no parent, do nothing. */
      removeFromParent() {
        this.parent?.removeChild(this);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/FilterEffect.mjs
function getFilterEffect(filters) {
  const filterEffect = filterEffectsPool.pop() || new FilterEffect();
  filterEffect.filters = filters;
  return filterEffect;
}
function returnFilterEffect(effect) {
  effect.filters = null;
  filterEffectsPool.push(effect);
}
var FilterEffect, filterEffectsPool;
var init_FilterEffect = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/FilterEffect.mjs"() {
    FilterEffect = class {
      constructor(options) {
        this.pipe = "filter";
        this.priority = 1;
        this.filters = options?.filters;
      }
      destroy() {
        for (let i = 0; i < this.filters.length; i++) {
          this.filters[i].destroy();
        }
        this.filters = null;
      }
      // addBounds(_bounds: Bounds): void
      // {
      //     // TODO do we take into account padding?
      // }
      // addLocalBounds(_bounds: Bounds, _localRoot: Container<any>): void
      // {
      //     // nothing?? :D
      //     // lets see if this need to exist in time!
      // }
    };
    filterEffectsPool = [];
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/pool/Pool.mjs
var Pool;
var init_Pool = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/pool/Pool.mjs"() {
    Pool = class {
      constructor(ClassType, initialSize) {
        this._pool = [];
        this._count = 0;
        this._index = 0;
        this._classType = ClassType;
        if (initialSize) {
          this.prepopulate(initialSize);
        }
      }
      prepopulate(total) {
        for (let i = 0; i < total; i++) {
          this._pool[this._index++] = new this._classType();
        }
        this._count += total;
      }
      get(data) {
        let item;
        if (this._index > 0) {
          item = this._pool[--this._index];
        } else {
          item = new this._classType();
        }
        item.init?.(data);
        return item;
      }
      return(item) {
        item.reset?.();
        this._pool[this._index++] = item;
      }
      get totalSize() {
        return this._count;
      }
      get totalFree() {
        return this._pool.length;
      }
      get totalUsed() {
        return this._count - this._pool.length;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs
var PoolGroupClass, BigPool;
var init_PoolGroup = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"() {
    init_Pool();
    PoolGroupClass = class {
      constructor() {
        this._poolsByClass = /* @__PURE__ */ new Map();
      }
      prepopulate(Class, total) {
        const classPool = this.getPool(Class);
        classPool.prepopulate(total);
      }
      get(Class, data) {
        const pool = this.getPool(Class);
        return pool.get(data);
      }
      return(item) {
        const pool = this.getPool(item.constructor);
        pool.return(item);
      }
      getPool(ClassType) {
        if (!this._poolsByClass.has(ClassType)) {
          this._poolsByClass.set(ClassType, new Pool(ClassType));
        }
        return this._poolsByClass.get(ClassType);
      }
      /** gets the usage stats of each pool in the system */
      stats() {
        const stats = {};
        this._poolsByClass.forEach((pool) => {
          const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;
          stats[name] = {
            free: pool.totalFree,
            used: pool.totalUsed,
            size: pool.totalSize
          };
        });
        return stats;
      }
    };
    BigPool = new PoolGroupClass();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mask/shared/MaskEffectManager.mjs
var MaskEffectManagerClass, MaskEffectManager;
var init_MaskEffectManager = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mask/shared/MaskEffectManager.mjs"() {
    init_Extensions();
    init_PoolGroup();
    MaskEffectManagerClass = class {
      constructor() {
        this._effectClasses = [];
        this.tests = [];
        this._initialized = false;
      }
      init() {
        if (this._initialized)
          return;
        this._initialized = true;
        this._effectClasses.forEach((test) => {
          this.add({
            test: test.test,
            maskClass: test
          });
        });
      }
      add(test) {
        this.tests.push(test);
      }
      getMaskEffect(item) {
        if (!this._initialized)
          this.init();
        for (let i = 0; i < this.tests.length; i++) {
          const test = this.tests[i];
          if (test.test(item)) {
            return BigPool.get(test.maskClass, item);
          }
        }
        return item;
      }
      returnMaskEffect(effect) {
        BigPool.return(effect);
      }
    };
    MaskEffectManager = new MaskEffectManagerClass();
    extensions.handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/container-mixins/effectsMixin.mjs
var effectsMixin;
var init_effectsMixin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/container-mixins/effectsMixin.mjs"() {
    init_FilterEffect();
    init_MaskEffectManager();
    effectsMixin = {
      _mask: null,
      _filters: null,
      set mask(value) {
        this._mask || (this._mask = { mask: null, effect: null });
        if (this._mask.mask === value)
          return;
        if (this._mask.effect) {
          this.removeEffect(this._mask.effect);
          MaskEffectManager.returnMaskEffect(this._mask.effect);
          this._mask.effect = null;
        }
        this._mask.mask = value;
        if (value === null || value === void 0)
          return;
        const effect = MaskEffectManager.getMaskEffect(value);
        this._mask.effect = effect;
        this.addEffect(effect);
      },
      get mask() {
        return this._mask?.mask;
      },
      set filters(value) {
        if (!Array.isArray(value) && value !== null)
          value = [value];
        this._filters || (this._filters = { filters: null, effect: null });
        if (this._filters.filters === value)
          return;
        if (this._filters.effect) {
          this.removeEffect(this._filters.effect);
          returnFilterEffect(this._filters.effect);
          this._filters.effect = null;
        }
        this._filters.filters = value;
        if (!value)
          return;
        const effect = getFilterEffect(value);
        this._filters.effect = effect;
        this.addEffect(effect);
      },
      get filters() {
        return this._filters?.filters;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/container-mixins/getByLabelMixin.mjs
var findMixin;
var init_getByLabelMixin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/container-mixins/getByLabelMixin.mjs"() {
    findMixin = {
      /**
       * Returns the first child in the container with the specified label.
       *
       * Recursive searches are done in a pre-order traversal.
       * @method getChildByName
       * @memberof PIXI.Container#
       * @param {string|RegExp} label - Instance label.
       * @param {boolean}[deep=false] - Whether to search recursively
       * @returns {PIXI.DisplayObject} The child with the specified label.
       */
      getChildByLabel(label, deep = false) {
        const children = this.children;
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.label === label || label instanceof RegExp && label.test(child.label))
            return child;
        }
        if (deep) {
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            const found = child.getChildByLabel(label, true);
            if (found) {
              return found;
            }
          }
        }
        return null;
      },
      /**
       * Returns all children in the container with the specified label.
       * @method getChildrenByLabel
       * @memberof PIXI.Container#
       * @param {string|RegExp} label - Instance label.
       * @param {boolean}[deep=false] - Whether to search recursively
       * @param {PIXI.Container[]} [out=[]] - The array to store matching children in.
       * @returns {PIXI.Container[]} An array of children with the specified label.
       */
      getChildrenByLabel(label, deep = false, out2 = []) {
        const children = this.children;
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.label === label || label instanceof RegExp && label.test(child.label)) {
            out2.push(child);
          }
        }
        if (deep) {
          for (let i = 0; i < children.length; i++) {
            children[i].getChildrenByLabel(label, true, out2);
          }
        }
        return out2;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/utils/updateLocalTransform.mjs
function updateLocalTransform(lt, container) {
  const scale3 = container._scale;
  const pivot = container._pivot;
  const position = container.position;
  const sx = scale3._x;
  const sy = scale3._y;
  const px = pivot._x;
  const py = pivot._y;
  lt.a = container._cx * sx;
  lt.b = container._sx * sx;
  lt.c = container._cy * sy;
  lt.d = container._sy * sy;
  lt.tx = position._x - (px * lt.a + py * lt.c);
  lt.ty = position._y - (px * lt.b + py * lt.d);
}
var init_updateLocalTransform = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/utils/updateLocalTransform.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/bounds/getGlobalBounds.mjs
function getGlobalBounds(target, skipUpdateTransform, bounds) {
  bounds.clear();
  let parentTransform;
  if (target.parent) {
    if (!skipUpdateTransform) {
      parentTransform = updateTransformBackwards(target, new Matrix());
    } else {
      parentTransform = target.parent.worldTransform;
    }
  } else {
    parentTransform = Matrix.IDENTITY;
  }
  _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  return bounds;
}
function _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {
  if (!target.visible || !target.measurable)
    return;
  let worldTransform;
  if (!skipUpdateTransform) {
    if (target.didChange) {
      updateLocalTransform(target.localTransform, target);
    }
    worldTransform = Matrix.shared.appendFrom(target.localTransform, parentTransform).clone();
  } else {
    worldTransform = target.worldTransform;
  }
  const parentBounds = bounds;
  const preserveBounds = !!target.effects.length;
  if (preserveBounds) {
    bounds = bounds.clone();
  }
  if (target.view) {
    bounds.setMatrix(worldTransform);
    target.view.addBounds(bounds);
  }
  for (let i = 0; i < target.children.length; i++) {
    _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);
  }
  if (preserveBounds) {
    for (let i = 0; i < target.effects.length; i++) {
      target.effects[i].addBounds?.(bounds);
    }
    parentBounds.addBounds(bounds);
  }
}
function updateTransformBackwards(target, parentTransform) {
  const parent = target.parent;
  if (parent) {
    updateTransformBackwards(parent, parentTransform);
    if (parent.didChange) {
      updateLocalTransform(parent.localTransform, parent);
    }
    parentTransform.append(parent.localTransform);
  }
  return parentTransform;
}
var init_getGlobalBounds = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/bounds/getGlobalBounds.mjs"() {
    init_Matrix();
    init_updateLocalTransform();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/bounds/getLocalBounds.mjs
function getLocalBounds(target, bounds, relativeMatrix) {
  bounds.clear();
  relativeMatrix || (relativeMatrix = new Matrix());
  if (target.view) {
    bounds.setMatrix(relativeMatrix);
    target.view.addBounds(bounds);
  }
  for (let i = 0; i < target.children.length; i++) {
    _getLocalBounds(target.children[i], bounds, relativeMatrix, target);
  }
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  return bounds;
}
function _getLocalBounds(target, bounds, parentTransform, rootContainer) {
  if (!target.visible || !target.measurable)
    return;
  if (target.didChange) {
    updateLocalTransform(target.localTransform, target);
  }
  const localTransform = target.localTransform;
  const relativeTransform = Matrix.shared.appendFrom(localTransform, parentTransform).clone();
  if (target.view) {
    bounds.setMatrix(relativeTransform);
    target.view.addBounds(bounds);
  }
  for (let i = 0; i < target.children.length; i++) {
    _getLocalBounds(target.children[i], bounds, relativeTransform, rootContainer);
  }
  for (let i = 0; i < target.effects.length; i++) {
    target.effects[i].addLocalBounds?.(bounds, rootContainer);
  }
}
var init_getLocalBounds = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/bounds/getLocalBounds.mjs"() {
    init_Matrix();
    init_updateLocalTransform();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/container-mixins/measureMixin.mjs
var tempBounds, tempMatrix3, measureMixin;
var init_measureMixin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/container-mixins/measureMixin.mjs"() {
    init_Matrix();
    init_Bounds();
    init_getGlobalBounds();
    init_getLocalBounds();
    tempBounds = new Bounds();
    tempMatrix3 = new Matrix();
    measureMixin = {
      get width() {
        return this.scale.x * getLocalBounds(this, tempBounds, tempMatrix3).width;
      },
      set width(value) {
        this.scale.x = value / getLocalBounds(this, tempBounds, tempMatrix3).width;
      },
      get height() {
        return this.scale.y * getLocalBounds(this, tempBounds, tempMatrix3).height;
      },
      set height(value) {
        this.scale.y = value / getLocalBounds(this, tempBounds, tempMatrix3).height;
      },
      /**
       * Retrieves the local bounds of the displayObject as a Bounds object.
       * @returns - The bounding area.
       */
      getLocalBounds() {
        return getLocalBounds(this, tempBounds, this.localTransform).rectangle;
      },
      /**
       * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link PIXI.Rectangle}.
       * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from
       *  being updated. This means the calculation returned MAY be out of date BUT will give you a
       *  nice performance boost.
       * @returns - The minimum axis-aligned rectangle in world space that fits around this object.
       */
      getBounds(skipUpdate) {
        return getGlobalBounds(this, skipUpdate, tempBounds).rectangle;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/container-mixins/onRenderMixin.mjs
var onRenderMixin;
var init_onRenderMixin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/container-mixins/onRenderMixin.mjs"() {
    onRenderMixin = {
      _onRender: null,
      set onRender(func) {
        const layerGroup = this.layerGroup;
        if (!func) {
          if (this._onRender) {
            layerGroup?.removeOnRender(this);
          }
          this._onRender = null;
          return;
        }
        if (!this._onRender) {
          layerGroup?.addOnRender(this);
        }
        this._onRender = func;
      },
      get onRender() {
        return this._onRender;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/container-mixins/toLocalGlobalMixin.mjs
var toLocalGlobalMixin;
var init_toLocalGlobalMixin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/container-mixins/toLocalGlobalMixin.mjs"() {
    init_Matrix();
    init_Point();
    init_getGlobalBounds();
    init_updateLocalTransform();
    toLocalGlobalMixin = {
      /**
       * Returns the global position of the container.
       * @param point - The optional point to write the global value to.
       * @param skipUpdate - Should we skip the update transform.
       * @returns - The updated point.
       * @memberof PIXI.Container#
       */
      getGlobalPosition(point = new Point(), skipUpdate = false) {
        if (this.parent) {
          this.parent.toGlobal(this.position, point, skipUpdate);
        } else {
          point.x = this.position.x;
          point.y = this.position.y;
        }
        return point;
      },
      /**
       * Calculates the global position of the container.
       * @param position - The world origin to calculate from.
       * @param point - A Point object in which to store the value, optional
       *  (otherwise will create a new Point).
       * @param skipUpdate - Should we skip the update transform.
       * @returns - A point object representing the position of this object.
       * @memberof PIXI.Container#
       */
      toGlobal(position, point, skipUpdate = false) {
        if (!skipUpdate) {
          if (this.didChange) {
            updateLocalTransform(this.localTransform, this);
          }
          const globalMatrix = updateTransformBackwards(this, new Matrix());
          globalMatrix.append(this.localTransform);
          return globalMatrix.apply(position, point);
        }
        return this.worldTransform.apply(position, point);
      },
      /**
       * Calculates the local position of the container relative to another point.
       * @param position - The world origin to calculate from.
       * @param from - The Container to calculate the global position from.
       * @param point - A Point object in which to store the value, optional
       *  (otherwise will create a new Point).
       * @param skipUpdate - Should we skip the update transform
       * @returns - A point object representing the position of this object
       * @memberof PIXI.Container#
       */
      toLocal(position, from, point, skipUpdate) {
        if (from) {
          position = from.toGlobal(position, point, skipUpdate);
        }
        if (!skipUpdate) {
          if (this.didChange) {
            updateLocalTransform(this.localTransform, this);
          }
          const globalMatrix = updateTransformBackwards(this, new Matrix());
          globalMatrix.append(this.localTransform);
          return globalMatrix.applyInverse(position, point);
        }
        return this.worldTransform.applyInverse(position, point);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs
var UID8, InstructionSet;
var init_InstructionSet = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs"() {
    UID8 = 0;
    InstructionSet = class {
      constructor() {
        this.uid = UID8++;
        this.instructions = [];
        this.instructionSize = 0;
      }
      reset() {
        this.instructionSize = 0;
      }
      add(instruction) {
        this.instructions[this.instructionSize++] = instruction;
      }
      log() {
        this.instructions.length = this.instructionSize;
        console.table(this.instructions, ["type", "action"]);
      }
      lastInstruction() {
        return this.instructions[this.instructionSize - 1];
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/LayerGroup.mjs
var LayerGroup;
var init_LayerGroup = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/LayerGroup.mjs"() {
    init_Matrix();
    init_InstructionSet();
    LayerGroup = class {
      constructor(root) {
        this.type = "layer";
        this.root = null;
        this.rootRenderable = null;
        this.canBundle = false;
        this.layerGroupParent = null;
        this.layerGroupChildren = [];
        this.children = [];
        this.worldTransform = new Matrix();
        this.worldColor = 4294967295;
        this.childrenToUpdate = {};
        this.updateTick = 0;
        this.childrenRenderablesToUpdate = { list: [], index: 0 };
        this.structureDidChange = true;
        this.instructionSet = new InstructionSet();
        this.onRenderContainers = [];
        this.root = root;
        this.addChild(root);
      }
      get localTransform() {
        return this.root.localTransform;
      }
      get layerTransform() {
        return this.root.layerTransform;
      }
      addLayerGroupChild(layerGroupChild) {
        if (layerGroupChild.layerGroupParent) {
          layerGroupChild.layerGroupParent.removeLayerGroupChild(layerGroupChild);
        }
        layerGroupChild.layerGroupParent = this;
        this.onChildUpdate(layerGroupChild.root);
        this.layerGroupChildren.push(layerGroupChild);
      }
      removeLayerGroupChild(layerGroupChild) {
        if (layerGroupChild.root.didChange) {
          this.removeChildFromUpdate(layerGroupChild.root);
        }
        const index = this.layerGroupChildren.indexOf(layerGroupChild);
        if (index > -1) {
          this.layerGroupChildren.splice(index, 1);
        }
        layerGroupChild.layerGroupParent = null;
      }
      addChild(child) {
        this.structureDidChange = true;
        if (child !== this.root) {
          this.children.push(child);
          child.updateTick = -1;
          if (child.parent === this.root) {
            child.relativeLayerDepth = 1;
          } else {
            child.relativeLayerDepth = child.parent.relativeLayerDepth + 1;
          }
          if (child._onRender) {
            this.addOnRender(child);
          }
        }
        if (child.layerGroup) {
          if (child.layerGroup.root === child) {
            this.addLayerGroupChild(child.layerGroup);
            return;
          }
        } else {
          child.layerGroup = this;
          child.didChange = true;
        }
        const children = child.children;
        if (!child.isLayerRoot) {
          this.onChildUpdate(child);
        }
        for (let i = 0; i < children.length; i++) {
          this.addChild(children[i]);
        }
      }
      removeChild(child) {
        this.structureDidChange = true;
        if (child._onRender) {
          this.removeOnRender(child);
        }
        if (child.layerGroup.root !== child) {
          const children = child.children;
          for (let i = 0; i < children.length; i++) {
            this.removeChild(children[i]);
          }
          if (child.didChange) {
            child.layerGroup.removeChildFromUpdate(child);
          }
          child.layerGroup = null;
        } else {
          this.removeLayerGroupChild(child.layerGroup);
        }
        const index = this.children.indexOf(child);
        if (index > -1) {
          this.children.splice(index, 1);
        }
      }
      onChildUpdate(child) {
        let childrenToUpdate = this.childrenToUpdate[child.relativeLayerDepth];
        if (!childrenToUpdate) {
          childrenToUpdate = this.childrenToUpdate[child.relativeLayerDepth] = {
            index: 0,
            list: []
          };
        }
        childrenToUpdate.list[childrenToUpdate.index++] = child;
      }
      // SHOULD THIS BE HERE?
      updateRenderable(container) {
        if (container.layerVisibleRenderable < 3)
          return;
        container.didViewUpdate = false;
        this.instructionSet.renderPipes[container.view.type].updateRenderable(container);
      }
      onChildViewUpdate(child) {
        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;
      }
      removeChildFromUpdate(child) {
        const childrenToUpdate = this.childrenToUpdate[child.relativeLayerDepth];
        if (!childrenToUpdate) {
          return;
        }
        const index = childrenToUpdate.list.indexOf(child);
        if (index > -1) {
          childrenToUpdate.list.splice(index, 1);
        }
        childrenToUpdate.index--;
      }
      get isRenderable() {
        const worldAlpha = this.worldColor >> 24 & 255;
        return this.root.localVisibleRenderable === 3 && worldAlpha > 0;
      }
      /**
       * adding a container to the onRender list will make sure the user function
       * passed in to the user defined 'onRender` callBack
       * @param container - the container to add to the onRender list
       */
      addOnRender(container) {
        this.onRenderContainers.push(container);
      }
      removeOnRender(container) {
        this.onRenderContainers.splice(this.onRenderContainers.indexOf(container), 1);
      }
      runOnRender() {
        this.onRenderContainers.forEach((container) => {
          container._onRender();
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/Container.mjs
function getRenderableUID() {
  return uid++;
}
var uid, defaultSkew, defaultPivot, defaultScale, UPDATE_COLOR, UPDATE_BLEND, UPDATE_VISIBLE, Container;
var init_Container = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/Container.mjs"() {
    init_eventemitter3();
    init_const2();
    init_Matrix();
    init_ObservablePoint();
    init_childrenHelperMixin();
    init_effectsMixin();
    init_getByLabelMixin();
    init_measureMixin();
    init_onRenderMixin();
    init_toLocalGlobalMixin();
    init_LayerGroup();
    uid = 0;
    defaultSkew = new ObservablePoint(null);
    defaultPivot = new ObservablePoint(null);
    defaultScale = new ObservablePoint(null, 1, 1);
    UPDATE_COLOR = 1;
    UPDATE_BLEND = 2;
    UPDATE_VISIBLE = 4;
    Container = class _Container extends eventemitter3_default {
      constructor({ label, layer, view } = {}) {
        super();
        this.uid = uid++;
        this.label = null;
        this.updateFlags = 15;
        this.isLayerRoot = false;
        this.layerGroup = null;
        this.didChange = false;
        this.didViewUpdate = false;
        this.relativeLayerDepth = 0;
        this.children = [];
        this.parent = null;
        this.includeInBuild = true;
        this.measurable = true;
        this.isSimple = true;
        this.updateTick = -1;
        this.localTransform = new Matrix();
        this.layerTransform = new Matrix();
        this.position = new ObservablePoint(this, 0, 0);
        this._scale = defaultScale;
        this._pivot = defaultPivot;
        this._skew = defaultSkew;
        this._cx = 1;
        this._sx = 0;
        this._cy = 0;
        this._sy = 1;
        this._rotation = 0;
        this.localColor = 4294967295;
        this.layerColor = 4294967295;
        this.localBlendMode = "inherit";
        this.layerBlendMode = "normal";
        this.localVisibleRenderable = 3;
        this.layerVisibleRenderable = 3;
        this.effects = [];
        if (label) {
          this.label = label;
        }
        if (layer) {
          this.enableLayer();
        }
        if (view) {
          this.view = view;
          this.view.owner = this;
        }
      }
      /**
       * Mixes all enumerable properties and methods from a source object to Container.
       * @param source - The source of properties and methods to mix in.
       */
      static mixin(source3) {
        Object.defineProperties(_Container.prototype, Object.getOwnPropertyDescriptors(source3));
      }
      addEffect(effect) {
        const index = this.effects.indexOf(effect);
        if (index !== -1)
          return;
        this.effects.push(effect);
        this.effects.sort((a, b) => a.priority - b.priority);
        if (!this.isLayerRoot && this.layerGroup) {
          this.layerGroup.structureDidChange = true;
        }
        this.updateIsSimple();
      }
      removeEffect(effect) {
        const index = this.effects.indexOf(effect);
        if (index === -1)
          return;
        this.effects.splice(index, 1);
        if (!this.isLayerRoot && this.layerGroup) {
          this.layerGroup.structureDidChange = true;
        }
        this.updateIsSimple();
      }
      /**
       * Adds one or more children to the container.
       *
       * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
       * @param {...PIXI.Container} children - The Container(s) to add to the container
       * @returns {PIXI.Container} - The first child that was added.
       */
      addChild(...children) {
        if (children.length > 1) {
          for (let i = 0; i < children.length; i++) {
            this.addChild(children[i]);
          }
          return children[0];
        }
        const child = children[0];
        if (child.parent === this) {
          this.children.splice(this.children.indexOf(child), 1);
          this.children.push(child);
          if (this.layerGroup && !this.isLayerRoot) {
            this.layerGroup.structureDidChange = true;
          }
          return child;
        }
        if (child.parent) {
          child.parent.removeChild(child);
        }
        this.children.push(child);
        child.parent = this;
        child.didChange = true;
        child.didViewUpdate = false;
        child.updateFlags = 15;
        if (this.layerGroup) {
          this.layerGroup.addChild(child);
        }
        return child;
      }
      /**
       * Removes one or more children from the container.
       * @param {...PIXI.Container} children - The Container(s) to remove
       * @returns {PIXI.Container} The first child that was removed.
       */
      removeChild(...children) {
        if (children.length > 1) {
          for (let i = 0; i < children.length; i++) {
            this.removeChild(children[i]);
          }
          return children[0];
        }
        const child = children[0];
        const index = this.children.indexOf(child);
        if (index > -1) {
          this.children.splice(index, 1);
          if (this.layerGroup) {
            this.layerGroup.removeChild(child);
          }
        }
        child.parent = null;
        return child;
      }
      onUpdate(point) {
        if (point) {
          if (point === this._skew) {
            this.updateSkew();
          }
        }
        if (this.didChange)
          return;
        this.didChange = true;
        if (this.isLayerRoot) {
          const layerGroupParent = this.layerGroup.layerGroupParent;
          if (layerGroupParent) {
            layerGroupParent.onChildUpdate(this);
          }
        } else if (this.layerGroup) {
          this.layerGroup.onChildUpdate(this);
        }
      }
      onViewUpdate() {
        if (this.didViewUpdate)
          return;
        this.didViewUpdate = true;
        if (this.layerGroup) {
          this.layerGroup.onChildViewUpdate(this);
        }
      }
      set layer(value) {
        if (this.isLayerRoot && value === false) {
          throw new Error("[Pixi] cannot undo a layer just yet");
        }
        if (value) {
          this.enableLayer();
        }
      }
      get layer() {
        return this.isLayerRoot;
      }
      enableLayer() {
        if (this.layerGroup && this.layerGroup.root === this)
          return;
        this.isLayerRoot = true;
        const parentLayerGroup = this.layerGroup;
        if (parentLayerGroup) {
          parentLayerGroup.removeChild(this);
        }
        this.layerGroup = new LayerGroup(this);
        if (parentLayerGroup) {
          for (let i = 0; i < parentLayerGroup.layerGroupChildren.length; i++) {
            const childLayerGroup = parentLayerGroup.layerGroupChildren[i];
            let parent = childLayerGroup.root;
            while (parent) {
              if (parent === this) {
                this.layerGroup.addLayerGroupChild(childLayerGroup);
                break;
              }
              parent = parent.parent;
            }
          }
          parentLayerGroup.addLayerGroupChild(this.layerGroup);
        }
        this.updateIsSimple();
      }
      get worldTransform() {
        this._worldTransform || (this._worldTransform = new Matrix());
        if (this.layerGroup) {
          if (this.isLayerRoot) {
            this._worldTransform.copyFrom(this.layerGroup.worldTransform);
          } else {
            this._worldTransform.appendFrom(this.layerTransform, this.layerGroup.worldTransform);
          }
        }
        return this._worldTransform;
      }
      /// ////// transform related stuff
      /**
       * The position of the displayObject on the x axis relative to the local coordinates of the parent.
       * An alias to position.x
       */
      get x() {
        return this.position.x;
      }
      set x(value) {
        this.position.x = value;
      }
      /**
       * The position of the displayObject on the y axis relative to the local coordinates of the parent.
       * An alias to position.y
       */
      get y() {
        return this.position.y;
      }
      set y(value) {
        this.position.y = value;
      }
      /**
       * The rotation of the object in radians.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get rotation() {
        return this._rotation;
      }
      set rotation(value) {
        if (this._rotation !== value) {
          this._rotation = value;
          this.onUpdate(this._skew);
        }
      }
      /**
       * The angle of the object in degrees.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get angle() {
        return this.rotation * RAD_TO_DEG;
      }
      set angle(value) {
        this.rotation = value * DEG_TO_RAD;
      }
      get pivot() {
        if (this._pivot === defaultPivot) {
          this._pivot = new ObservablePoint(this, 0, 0);
        }
        return this._pivot;
      }
      get skew() {
        if (this._skew === defaultSkew) {
          this._skew = new ObservablePoint(this, 0, 0);
        }
        return this._skew;
      }
      get scale() {
        if (this._scale === defaultScale) {
          this._scale = new ObservablePoint(this, 1, 1);
        }
        return this._scale;
      }
      /** Called when the skew or the rotation changes. */
      updateSkew() {
        const rotation = this._rotation;
        const skew = this._skew;
        this._cx = Math.cos(rotation + skew._y);
        this._sx = Math.sin(rotation + skew._y);
        this._cy = -Math.sin(rotation - skew._x);
        this._sy = Math.cos(rotation - skew._x);
      }
      /// ///// color related stuff
      set alpha(value) {
        value = value * 255 | 0;
        if (value === (this.localColor >> 24 & 255))
          return;
        this.localColor = this.localColor & 16777215 | value << 24;
        this.updateFlags |= UPDATE_COLOR;
        this.onUpdate();
      }
      get alpha() {
        return (this.localColor >> 24 & 255) / 255;
      }
      set tint(value) {
        value = ((value & 255) << 16) + (value & 65280) + (value >> 16 & 255);
        if (value === (this.localColor & 16777215))
          return;
        this.localColor = this.localColor & 4278190080 | value & 16777215;
        this.updateFlags |= UPDATE_COLOR;
        this.onUpdate();
      }
      get tint() {
        const bgr = this.localColor & 16777215;
        return ((bgr & 255) << 16) + (bgr & 65280) + (bgr >> 16 & 255);
      }
      /// //////////////// blend related stuff
      set blendMode(value) {
        if (this.localBlendMode === value)
          return;
        if (this.layerGroup && !this.isLayerRoot) {
          this.layerGroup.structureDidChange = true;
        }
        this.updateFlags |= UPDATE_BLEND;
        this.localBlendMode = value;
        this.onUpdate();
      }
      get blendMode() {
        return this.localBlendMode;
      }
      /// ///////// VISIBILITY / RENDERABLE /////////////////
      get visible() {
        return !!(this.localVisibleRenderable & 2);
      }
      // visible -  the renderable is not shown, also the transform is not updated
      set visible(value) {
        const valueNumber = value ? 1 : 0;
        if ((this.localVisibleRenderable & 2) >> 1 === valueNumber)
          return;
        if (this.layerGroup && !this.isLayerRoot) {
          this.layerGroup.structureDidChange = true;
        }
        this.updateFlags |= UPDATE_VISIBLE;
        this.localVisibleRenderable = this.localVisibleRenderable & 1 | valueNumber << 1;
        this.onUpdate();
      }
      get renderable() {
        return !!(this.localVisibleRenderable & 1);
      }
      set renderable(value) {
        const valueNumber = value ? 1 : 0;
        if ((this.localVisibleRenderable & 1) === valueNumber)
          return;
        this.localVisibleRenderable = this.localVisibleRenderable & 2 | valueNumber;
        this.updateFlags |= UPDATE_VISIBLE;
        if (this.layerGroup && !this.isLayerRoot) {
          this.layerGroup.structureDidChange = true;
        }
        this.onUpdate();
      }
      get isRenderable() {
        const worldAlpha = this.layerColor >> 24 & 255;
        return this.localVisibleRenderable === 3 && worldAlpha > 0;
      }
      updateIsSimple() {
        this.isSimple = !this.isLayerRoot && this.effects.length === 0;
      }
      /**
       * Removes all internal references and listeners as well as removes children from the display list.
       * Do not use a Container after calling `destroy`.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
       *  method called as well. 'options' will be passed on to those calls.
       * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children
       * is set to true it should destroy the texture of the child sprite
       * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
       * If options.children is set to true it should destroy the texture source of the child sprite
       * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
       * If options.children is set to true it should destroy the context of the child graphics
       */
      destroy(options = false) {
        this.removeFromParent();
        this.parent = null;
        this._mask = null;
        this._filters = null;
        this.effects = null;
        this.position = null;
        this._scale = null;
        this._pivot = null;
        this._skew = null;
        this.emit("destroyed");
        this.removeAllListeners();
        const destroyChildren = typeof options === "boolean" ? options : options?.children;
        const oldChildren = this.removeChildren(0, this.children.length);
        if (destroyChildren) {
          for (let i = 0; i < oldChildren.length; ++i) {
            oldChildren[i].destroy(options);
          }
        }
        if (this.view) {
          this.view.destroy(options);
          this.view.owner = null;
        }
      }
    };
    Container.mixin(childrenHelperMixin);
    Container.mixin(toLocalGlobalMixin);
    Container.mixin(onRenderMixin);
    Container.mixin(measureMixin);
    Container.mixin(effectsMixin);
    Container.mixin(findMixin);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/events/EventTicker.mjs
var EventsTickerClass, EventsTicker;
var init_EventTicker = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/events/EventTicker.mjs"() {
    init_const();
    init_Ticker();
    EventsTickerClass = class {
      constructor() {
        this.interactionFrequency = 10;
        this._deltaTime = 0;
        this._didMove = false;
        this.tickerAdded = false;
        this._pauseUpdate = true;
      }
      /**
       * Initializes the event ticker.
       * @param events - The event system.
       */
      init(events) {
        this.removeTickerListener();
        this.events = events;
        this.interactionFrequency = 10;
        this._deltaTime = 0;
        this._didMove = false;
        this.tickerAdded = false;
        this._pauseUpdate = true;
      }
      /** Whether to pause the update checks or not. */
      get pauseUpdate() {
        return this._pauseUpdate;
      }
      set pauseUpdate(paused) {
        this._pauseUpdate = paused;
      }
      /** Adds the ticker listener. */
      addTickerListener() {
        if (this.tickerAdded || !this.domElement) {
          return;
        }
        Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
        this.tickerAdded = true;
      }
      /** Removes the ticker listener. */
      removeTickerListener() {
        if (!this.tickerAdded) {
          return;
        }
        Ticker.system.remove(this.tickerUpdate, this);
        this.tickerAdded = false;
      }
      /** Sets flag to not fire extra events when the user has already moved there mouse */
      pointerMoved() {
        this._didMove = true;
      }
      /** Updates the state of interactive objects. */
      update() {
        if (!this.domElement || this._pauseUpdate) {
          return;
        }
        if (this._didMove) {
          this._didMove = false;
          return;
        }
        const rootPointerEvent = this.events["rootPointerEvent"];
        if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
          return;
        }
        globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
          clientX: rootPointerEvent.clientX,
          clientY: rootPointerEvent.clientY
        }));
      }
      /**
       * Updates the state of interactive objects if at least {@link interactionFrequency}
       * milliseconds have passed since the last invocation.
       *
       * Invoked by a throttled ticker update from {@link PIXI.Ticker.system}.
       * @param ticker - The throttled ticker.
       */
      tickerUpdate(ticker) {
        this._deltaTime += ticker.deltaTime;
        if (this._deltaTime < this.interactionFrequency) {
          return;
        }
        this._deltaTime = 0;
        this.update();
      }
    };
    EventsTicker = new EventsTickerClass();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/events/FederatedEvent.mjs
var FederatedEvent;
var init_FederatedEvent = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/events/FederatedEvent.mjs"() {
    init_Point();
    FederatedEvent = class _FederatedEvent {
      /**
       * @param manager - The event boundary which manages this event. Propagation can only occur
       *  within the boundary's jurisdiction.
       */
      constructor(manager) {
        this.bubbles = true;
        this.cancelBubble = true;
        this.cancelable = false;
        this.composed = false;
        this.defaultPrevented = false;
        this.eventPhase = _FederatedEvent.prototype.NONE;
        this.propagationStopped = false;
        this.propagationImmediatelyStopped = false;
        this.layer = new Point();
        this.page = new Point();
        this.NONE = 0;
        this.CAPTURING_PHASE = 1;
        this.AT_TARGET = 2;
        this.BUBBLING_PHASE = 3;
        this.manager = manager;
      }
      /** @readonly */
      get layerX() {
        return this.layer.x;
      }
      /** @readonly */
      get layerY() {
        return this.layer.y;
      }
      /** @readonly */
      get pageX() {
        return this.page.x;
      }
      /** @readonly */
      get pageY() {
        return this.page.y;
      }
      /**
       * Fallback for the deprecated @code{PIXI.InteractionEvent.data}.
       * @deprecated since 7.0.0
       */
      get data() {
        return this;
      }
      /** The propagation path for this event. Alias for {@link PIXI.EventBoundary.propagationPath}. */
      composedPath() {
        if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
          this.path = this.target ? this.manager.propagationPath(this.target) : [];
        }
        return this.path;
      }
      /**
       * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw an {@code Error}.
       * @deprecated
       * @param _type
       * @param _bubbles
       * @param _cancelable
       */
      initEvent(_type, _bubbles, _cancelable) {
        throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
      }
      /**
       * Unimplemented method included for implementing the DOM interface {@code UIEvent}. It will throw an {@code Error}.
       * @deprecated
       * @param _typeArg
       * @param _bubblesArg
       * @param _cancelableArg
       * @param _viewArg
       * @param _detailArg
       */
      initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
        throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
      }
      /** Prevent default behavior of PixiJS and the user agent. */
      preventDefault() {
        if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
          this.nativeEvent.preventDefault();
        }
        this.defaultPrevented = true;
      }
      /**
       * Stop this event from propagating to any addition listeners, including on the
       * {@link PIXI.FederatedEventTarget.currentTarget currentTarget} and also the following
       * event targets on the propagation path.
       */
      stopImmediatePropagation() {
        this.propagationImmediatelyStopped = true;
      }
      /**
       * Stop this event from propagating to the next {@link PIXI.FederatedEventTarget}. The rest of the listeners
       * on the {@link PIXI.FederatedEventTarget.currentTarget currentTarget} will still be notified.
       */
      stopPropagation() {
        this.propagationStopped = true;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs
var FederatedMouseEvent;
var init_FederatedMouseEvent = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs"() {
    init_Point();
    init_FederatedEvent();
    FederatedMouseEvent = class extends FederatedEvent {
      constructor() {
        super(...arguments);
        this.client = new Point();
        this.movement = new Point();
        this.offset = new Point();
        this.global = new Point();
        this.screen = new Point();
      }
      /** @readonly */
      get clientX() {
        return this.client.x;
      }
      /** @readonly */
      get clientY() {
        return this.client.y;
      }
      /**
       * Alias for {@link PIXI.FederatedMouseEvent.clientX this.clientX}.
       * @readonly
       */
      get x() {
        return this.clientX;
      }
      /**
       * Alias for {@link PIXI.FederatedMouseEvent.clientY this.clientY}.
       * @readonly
       */
      get y() {
        return this.clientY;
      }
      /** @readonly */
      get movementX() {
        return this.movement.x;
      }
      /** @readonly */
      get movementY() {
        return this.movement.y;
      }
      /** @readonly */
      get offsetX() {
        return this.offset.x;
      }
      /** @readonly */
      get offsetY() {
        return this.offset.y;
      }
      /** @readonly */
      get globalX() {
        return this.global.x;
      }
      /** @readonly */
      get globalY() {
        return this.global.y;
      }
      /**
       * The pointer coordinates in the renderer's screen. Alias for {@code screen.x}.
       * @readonly
       */
      get screenX() {
        return this.screen.x;
      }
      /**
       * The pointer coordinates in the renderer's screen. Alias for {@code screen.y}.
       * @readonly
       */
      get screenY() {
        return this.screen.y;
      }
      /**
       * This will return the local coordinates of the specified container for this InteractionData
       * @param {PIXI.Container} container - The Container that you would like the local
       *  coords off
       * @param {PIXI.PointData} point - A Point object in which to store the value, optional (otherwise
       *  will create a new point)
       * @param {PIXI.PointData} globalPos - A Point object containing your custom global coords, optional
       *  (otherwise will use the current global coords)
       * @returns - A point containing the coordinates of the InteractionData position relative
       *  to the Container
       */
      getLocalPosition(container, point, globalPos) {
        return container.worldTransform.applyInverse(globalPos || this.global, point);
      }
      /**
       * Whether the modifier key was pressed when this event natively occurred.
       * @param key - The modifier key.
       */
      getModifierState(key) {
        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
      }
      /**
       * Not supported.
       * @param _typeArg
       * @param _canBubbleArg
       * @param _cancelableArg
       * @param _viewArg
       * @param _detailArg
       * @param _screenXArg
       * @param _screenYArg
       * @param _clientXArg
       * @param _clientYArg
       * @param _ctrlKeyArg
       * @param _altKeyArg
       * @param _shiftKeyArg
       * @param _metaKeyArg
       * @param _buttonArg
       * @param _relatedTargetArg
       * @deprecated since 7.0.0
       */
      // eslint-disable-next-line max-params
      initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
        throw new Error("Method not implemented.");
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs
var FederatedPointerEvent;
var init_FederatedPointerEvent = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs"() {
    init_FederatedMouseEvent();
    FederatedPointerEvent = class extends FederatedMouseEvent {
      constructor() {
        super(...arguments);
        this.width = 0;
        this.height = 0;
        this.isPrimary = false;
      }
      // Only included for completeness for now
      getCoalescedEvents() {
        if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
          return [this];
        }
        return [];
      }
      // Only included for completeness for now
      getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!");
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs
var FederatedWheelEvent;
var init_FederatedWheelEvent = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs"() {
    init_FederatedMouseEvent();
    FederatedWheelEvent = class extends FederatedMouseEvent {
      constructor() {
        super(...arguments);
        this.DOM_DELTA_PIXEL = 0;
        this.DOM_DELTA_LINE = 1;
        this.DOM_DELTA_PAGE = 2;
      }
    };
    FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
    FederatedWheelEvent.DOM_DELTA_LINE = 1;
    FederatedWheelEvent.DOM_DELTA_PAGE = 2;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/events/EventBoundary.mjs
var PROPAGATION_LIMIT, tempHitLocation, tempLocalMapping, EventBoundary;
var init_EventBoundary = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/events/EventBoundary.mjs"() {
    init_eventemitter3();
    init_Point();
    init_EventTicker();
    init_FederatedMouseEvent();
    init_FederatedPointerEvent();
    init_FederatedWheelEvent();
    PROPAGATION_LIMIT = 2048;
    tempHitLocation = new Point();
    tempLocalMapping = new Point();
    EventBoundary = class {
      /**
       * @param rootTarget - The holder of the event boundary.
       */
      constructor(rootTarget) {
        this.dispatch = new eventemitter3_default();
        this.moveOnAll = false;
        this.enableGlobalMoveEvents = true;
        this.mappingState = {
          trackingData: {}
        };
        this.eventPool = /* @__PURE__ */ new Map();
        this._allInteractiveElements = [];
        this._hitElements = [];
        this._isPointerMoveEvent = false;
        this.rootTarget = rootTarget;
        this.hitPruneFn = this.hitPruneFn.bind(this);
        this.hitTestFn = this.hitTestFn.bind(this);
        this.mapPointerDown = this.mapPointerDown.bind(this);
        this.mapPointerMove = this.mapPointerMove.bind(this);
        this.mapPointerOut = this.mapPointerOut.bind(this);
        this.mapPointerOver = this.mapPointerOver.bind(this);
        this.mapPointerUp = this.mapPointerUp.bind(this);
        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
        this.mapWheel = this.mapWheel.bind(this);
        this.mappingTable = {};
        this.addEventMapping("pointerdown", this.mapPointerDown);
        this.addEventMapping("pointermove", this.mapPointerMove);
        this.addEventMapping("pointerout", this.mapPointerOut);
        this.addEventMapping("pointerleave", this.mapPointerOut);
        this.addEventMapping("pointerover", this.mapPointerOver);
        this.addEventMapping("pointerup", this.mapPointerUp);
        this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
        this.addEventMapping("wheel", this.mapWheel);
      }
      /**
       * Adds an event mapping for the event `type` handled by `fn`.
       *
       * Event mappings can be used to implement additional or custom events. They take an event
       * coming from the upstream scene (or directly from the {@link PIXI.EventSystem}) and dispatch new downstream events
       * generally trickling down and bubbling up to {@link PIXI.EventBoundary.rootTarget this.rootTarget}.
       *
       * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden
       * instead.
       * @param type - The type of upstream event to map.
       * @param fn - The mapping method. The context of this function must be bound manually, if desired.
       */
      addEventMapping(type, fn) {
        if (!this.mappingTable[type]) {
          this.mappingTable[type] = [];
        }
        this.mappingTable[type].push({
          fn,
          priority: 0
        });
        this.mappingTable[type].sort((a, b) => a.priority - b.priority);
      }
      /**
       * Dispatches the given event
       * @param e
       * @param type
       */
      dispatchEvent(e, type) {
        e.propagationStopped = false;
        e.propagationImmediatelyStopped = false;
        this.propagate(e, type);
        this.dispatch.emit(type || e.type, e);
      }
      /**
       * Maps the given upstream event through the event boundary and propagates it downstream.
       * @param e
       */
      mapEvent(e) {
        if (!this.rootTarget) {
          return;
        }
        const mappers = this.mappingTable[e.type];
        if (mappers) {
          for (let i = 0, j2 = mappers.length; i < j2; i++) {
            mappers[i].fn(e);
          }
        } else {
          console.warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);
        }
      }
      /**
       * Finds the Container that is the target of a event at the given coordinates.
       *
       * The passed (x,y) coordinates are in the world space above this event boundary.
       * @param x
       * @param y
       */
      hitTest(x2, y) {
        EventsTicker.pauseUpdate = true;
        const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
        const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
        const invertedPath = this[fn](
          this.rootTarget,
          this.rootTarget.eventMode,
          tempHitLocation.set(x2, y),
          this.hitTestFn,
          this.hitPruneFn
        );
        return invertedPath && invertedPath[0];
      }
      /**
       * Propagate the passed event from from {@link PIXI.EventBoundary.rootTarget this.rootTarget} to its
       * target {@code e.target}.
       * @param e - The event to propagate.
       * @param type
       */
      propagate(e, type) {
        if (!e.target) {
          return;
        }
        const composedPath = e.composedPath();
        e.eventPhase = e.CAPTURING_PHASE;
        for (let i = 0, j2 = composedPath.length - 1; i < j2; i++) {
          e.currentTarget = composedPath[i];
          this.notifyTarget(e, type);
          if (e.propagationStopped || e.propagationImmediatelyStopped)
            return;
        }
        e.eventPhase = e.AT_TARGET;
        e.currentTarget = e.target;
        this.notifyTarget(e, type);
        if (e.propagationStopped || e.propagationImmediatelyStopped)
          return;
        e.eventPhase = e.BUBBLING_PHASE;
        for (let i = composedPath.length - 2; i >= 0; i--) {
          e.currentTarget = composedPath[i];
          this.notifyTarget(e, type);
          if (e.propagationStopped || e.propagationImmediatelyStopped)
            return;
        }
      }
      /**
       * Emits the event {@code e} to all interactive containers. The event is propagated in the bubbling phase always.
       *
       * This is used in the `globalpointermove` event.
       * @param e - The emitted event.
       * @param type - The listeners to notify.
       * @param targets - The targets to notify.
       */
      all(e, type, targets = this._allInteractiveElements) {
        if (targets.length === 0)
          return;
        e.eventPhase = e.BUBBLING_PHASE;
        const events = Array.isArray(type) ? type : [type];
        for (let i = targets.length - 1; i >= 0; i--) {
          events.forEach((event) => {
            e.currentTarget = targets[i];
            this.notifyTarget(e, event);
          });
        }
      }
      /**
       * Finds the propagation path from {@link PIXI.EventBoundary.rootTarget rootTarget} to the passed
       * {@code target}. The last element in the path is {@code target}.
       * @param target
       */
      propagationPath(target) {
        const propagationPath = [target];
        for (let i = 0; i < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i++) {
          if (!target.parent) {
            throw new Error("Cannot find propagation path to disconnected target");
          }
          propagationPath.push(target.parent);
          target = target.parent;
        }
        propagationPath.reverse();
        return propagationPath;
      }
      hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
        let shouldReturn = false;
        if (this._interactivePrune(currentTarget))
          return null;
        if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
          EventsTicker.pauseUpdate = false;
        }
        if (currentTarget.interactiveChildren && currentTarget.children) {
          const children = currentTarget.children;
          for (let i = children.length - 1; i >= 0; i--) {
            const child = children[i];
            const nestedHit = this.hitTestMoveRecursive(
              child,
              this._isInteractive(eventMode) ? eventMode : child.eventMode,
              location,
              testFn,
              pruneFn,
              ignore || pruneFn(currentTarget, location)
            );
            if (nestedHit) {
              if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                continue;
              }
              const isInteractive = currentTarget.isInteractive();
              if (nestedHit.length > 0 || isInteractive) {
                if (isInteractive)
                  this._allInteractiveElements.push(currentTarget);
                nestedHit.push(currentTarget);
              }
              if (this._hitElements.length === 0)
                this._hitElements = nestedHit;
              shouldReturn = true;
            }
          }
        }
        const isInteractiveMode = this._isInteractive(eventMode);
        const isInteractiveTarget = currentTarget.isInteractive();
        if (isInteractiveTarget && isInteractiveTarget)
          this._allInteractiveElements.push(currentTarget);
        if (ignore || this._hitElements.length > 0)
          return null;
        if (shouldReturn)
          return this._hitElements;
        if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {
          return isInteractiveTarget ? [currentTarget] : [];
        }
        return null;
      }
      /**
       * Recursive implementation for {@link PIXI.EventBoundary.hitTest hitTest}.
       * @param currentTarget - The Container that is to be hit tested.
       * @param eventMode - The event mode for the `currentTarget` or one of its parents.
       * @param location - The location that is being tested for overlap.
       * @param testFn - Callback that determines whether the target passes hit testing. This callback
       *  can assume that `pruneFn` failed to prune the container.
       * @param pruneFn - Callback that determiness whether the target and all of its children
       *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees
       *  of the scene graph.
       * @returns An array holding the hit testing target and all its ancestors in order. The first element
       *  is the target itself and the last is {@link PIXI.EventBoundary.rootTarget rootTarget}. This is the opposite
       *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.
       */
      hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
        if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
          return null;
        }
        if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
          EventsTicker.pauseUpdate = false;
        }
        if (currentTarget.interactiveChildren && currentTarget.children) {
          const children = currentTarget.children;
          const relativeLocation = location;
          for (let i = children.length - 1; i >= 0; i--) {
            const child = children[i];
            const nestedHit = this.hitTestRecursive(
              child,
              this._isInteractive(eventMode) ? eventMode : child.eventMode,
              relativeLocation,
              testFn,
              pruneFn
            );
            if (nestedHit) {
              if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                continue;
              }
              const isInteractive = currentTarget.isInteractive();
              if (nestedHit.length > 0 || isInteractive)
                nestedHit.push(currentTarget);
              return nestedHit;
            }
          }
        }
        const isInteractiveMode = this._isInteractive(eventMode);
        const isInteractiveTarget = currentTarget.isInteractive();
        if (isInteractiveMode && testFn(currentTarget, location)) {
          return isInteractiveTarget ? [currentTarget] : [];
        }
        return null;
      }
      _isInteractive(int) {
        return int === "static" || int === "dynamic";
      }
      _interactivePrune(container) {
        if (!container || !container.visible || !container.renderable) {
          return true;
        }
        if (container.eventMode === "none") {
          return true;
        }
        if (container.eventMode === "passive" && !container.interactiveChildren) {
          return true;
        }
        return false;
      }
      /**
       * Checks whether the container or any of its children cannot pass the hit test at all.
       *
       * {@link PIXI.EventBoundary}'s implementation uses the {@link PIXI.Container.hitArea hitArea}
       * and {@link PIXI.Container._mask} for pruning.
       * @param container
       * @param location
       */
      hitPruneFn(container, location) {
        if (container.hitArea) {
          container.worldTransform.applyInverse(location, tempLocalMapping);
          if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
            return true;
          }
        }
        if (container.effects && container.effects.length) {
          let hit = false;
          for (let i = 0; i < container.effects.length; i++) {
            const effect = container.effects[i];
            if (effect.containsPoint) {
              if (!effect.containsPoint(location)) {
                return false;
              }
              hit = true;
            }
          }
          return hit;
        }
        return false;
      }
      /**
       * Checks whether the container passes hit testing for the given location.
       * @param container
       * @param location
       * @returns - Whether `displayObject` passes hit testing for `location`.
       */
      hitTestFn(container, location) {
        if (container.eventMode === "passive") {
          return false;
        }
        if (container.hitArea) {
          return true;
        }
        if (container.view?.containsPoint) {
          container.worldTransform.applyInverse(location, tempLocalMapping);
          return container.view.containsPoint(tempLocalMapping);
        }
        return false;
      }
      /**
       * Notify all the listeners to the event's `currentTarget`.
       *
       * If the `currentTarget` contains the property `on<type>`, then it is called here,
       * simulating the behavior from version 6.x and prior.
       * @param e - The event passed to the target.
       * @param type
       */
      notifyTarget(e, type) {
        type = type ?? e.type;
        const handlerKey = `on${type}`;
        e.currentTarget[handlerKey]?.(e);
        const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;
        this.notifyListeners(e, key);
        if (e.eventPhase === e.AT_TARGET) {
          this.notifyListeners(e, type);
        }
      }
      /**
       * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.
       *
       * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.
       * @param from
       */
      mapPointerDown(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const e = this.createPointerEvent(from);
        this.dispatchEvent(e, "pointerdown");
        if (e.pointerType === "touch") {
          this.dispatchEvent(e, "touchstart");
        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
          const isRightButton = e.button === 2;
          this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
        }
        const trackingData = this.trackingData(from.pointerId);
        trackingData.pressTargetsByButton[from.button] = e.composedPath();
        this.freeEvent(e);
      }
      /**
       * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.
       *
       * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,
       * `mousemove`, and `touchmove` events are fired as well for specific pointer types.
       * @param from - The upstream `pointermove` event.
       */
      mapPointerMove(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        this._allInteractiveElements.length = 0;
        this._hitElements.length = 0;
        this._isPointerMoveEvent = true;
        const e = this.createPointerEvent(from);
        this._isPointerMoveEvent = false;
        const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
        const trackingData = this.trackingData(from.pointerId);
        const outTarget = this.findMountedTarget(trackingData.overTargets);
        if (trackingData.overTargets?.length > 0 && outTarget !== e.target) {
          const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
          const outEvent = this.createPointerEvent(from, outType, outTarget);
          this.dispatchEvent(outEvent, "pointerout");
          if (isMouse)
            this.dispatchEvent(outEvent, "mouseout");
          if (!e.composedPath().includes(outTarget)) {
            const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
            leaveEvent.eventPhase = leaveEvent.AT_TARGET;
            while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {
              leaveEvent.currentTarget = leaveEvent.target;
              this.notifyTarget(leaveEvent);
              if (isMouse)
                this.notifyTarget(leaveEvent, "mouseleave");
              leaveEvent.target = leaveEvent.target.parent;
            }
            this.freeEvent(leaveEvent);
          }
          this.freeEvent(outEvent);
        }
        if (outTarget !== e.target) {
          const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
          const overEvent = this.clonePointerEvent(e, overType);
          this.dispatchEvent(overEvent, "pointerover");
          if (isMouse)
            this.dispatchEvent(overEvent, "mouseover");
          let overTargetAncestor = outTarget?.parent;
          while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
            if (overTargetAncestor === e.target)
              break;
            overTargetAncestor = overTargetAncestor.parent;
          }
          const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
          if (didPointerEnter) {
            const enterEvent = this.clonePointerEvent(e, "pointerenter");
            enterEvent.eventPhase = enterEvent.AT_TARGET;
            while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
              enterEvent.currentTarget = enterEvent.target;
              this.notifyTarget(enterEvent);
              if (isMouse)
                this.notifyTarget(enterEvent, "mouseenter");
              enterEvent.target = enterEvent.target.parent;
            }
            this.freeEvent(enterEvent);
          }
          this.freeEvent(overEvent);
        }
        const allMethods = [];
        const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
        this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e, "pointermove");
        allowGlobalPointerEvents && allMethods.push("globalpointermove");
        if (e.pointerType === "touch") {
          this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove");
          allowGlobalPointerEvents && allMethods.push("globaltouchmove");
        }
        if (isMouse) {
          this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove");
          allowGlobalPointerEvents && allMethods.push("globalmousemove");
          this.cursor = e.target?.cursor;
        }
        if (allMethods.length > 0) {
          this.all(e, allMethods);
        }
        this._allInteractiveElements.length = 0;
        this._hitElements.length = 0;
        trackingData.overTargets = e.composedPath();
        this.freeEvent(e);
      }
      /**
       * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.
       *
       * The tracking data for the specific pointer gets a new `overTarget`.
       * @param from - The upstream `pointerover` event.
       */
      mapPointerOver(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const trackingData = this.trackingData(from.pointerId);
        const e = this.createPointerEvent(from);
        const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
        this.dispatchEvent(e, "pointerover");
        if (isMouse)
          this.dispatchEvent(e, "mouseover");
        if (e.pointerType === "mouse")
          this.cursor = e.target?.cursor;
        const enterEvent = this.clonePointerEvent(e, "pointerenter");
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
          enterEvent.currentTarget = enterEvent.target;
          this.notifyTarget(enterEvent);
          if (isMouse)
            this.notifyTarget(enterEvent, "mouseenter");
          enterEvent.target = enterEvent.target.parent;
        }
        trackingData.overTargets = e.composedPath();
        this.freeEvent(e);
        this.freeEvent(enterEvent);
      }
      /**
       * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.
       *
       * The tracking data for the specific pointer is cleared of a `overTarget`.
       * @param from - The upstream `pointerout` event.
       */
      mapPointerOut(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const trackingData = this.trackingData(from.pointerId);
        if (trackingData.overTargets) {
          const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
          const outTarget = this.findMountedTarget(trackingData.overTargets);
          const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
          this.dispatchEvent(outEvent);
          if (isMouse)
            this.dispatchEvent(outEvent, "mouseout");
          const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
          leaveEvent.eventPhase = leaveEvent.AT_TARGET;
          while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
            leaveEvent.currentTarget = leaveEvent.target;
            this.notifyTarget(leaveEvent);
            if (isMouse)
              this.notifyTarget(leaveEvent, "mouseleave");
            leaveEvent.target = leaveEvent.target.parent;
          }
          trackingData.overTargets = null;
          this.freeEvent(outEvent);
          this.freeEvent(leaveEvent);
        }
        this.cursor = null;
      }
      /**
       * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,
       * and `click`/`rightclick`/`pointertap` events, in that order.
       *
       * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific
       * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,
       * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for
       * specific pointer types.
       * @param from - The upstream `pointerup` event.
       */
      mapPointerUp(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const now = performance.now();
        const e = this.createPointerEvent(from);
        this.dispatchEvent(e, "pointerup");
        if (e.pointerType === "touch") {
          this.dispatchEvent(e, "touchend");
        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
          const isRightButton = e.button === 2;
          this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
        }
        const trackingData = this.trackingData(from.pointerId);
        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        let clickTarget = pressTarget;
        if (pressTarget && !e.composedPath().includes(pressTarget)) {
          let currentTarget = pressTarget;
          while (currentTarget && !e.composedPath().includes(currentTarget)) {
            e.currentTarget = currentTarget;
            this.notifyTarget(e, "pointerupoutside");
            if (e.pointerType === "touch") {
              this.notifyTarget(e, "touchendoutside");
            } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
              const isRightButton = e.button === 2;
              this.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");
            }
            currentTarget = currentTarget.parent;
          }
          delete trackingData.pressTargetsByButton[from.button];
          clickTarget = currentTarget;
        }
        if (clickTarget) {
          const clickEvent = this.clonePointerEvent(e, "click");
          clickEvent.target = clickTarget;
          clickEvent.path = null;
          if (!trackingData.clicksByButton[from.button]) {
            trackingData.clicksByButton[from.button] = {
              clickCount: 0,
              target: clickEvent.target,
              timeStamp: now
            };
          }
          const clickHistory = trackingData.clicksByButton[from.button];
          if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
            ++clickHistory.clickCount;
          } else {
            clickHistory.clickCount = 1;
          }
          clickHistory.target = clickEvent.target;
          clickHistory.timeStamp = now;
          clickEvent.detail = clickHistory.clickCount;
          if (clickEvent.pointerType === "mouse") {
            const isRightButton = clickEvent.button === 2;
            this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
          } else if (clickEvent.pointerType === "touch") {
            this.dispatchEvent(clickEvent, "tap");
          }
          this.dispatchEvent(clickEvent, "pointertap");
          this.freeEvent(clickEvent);
        }
        this.freeEvent(e);
      }
      /**
       * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original
       * `pointerdown` target to `rootTarget`.
       *
       * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the
       * `{@link PIXI.EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)
       *
       * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer
       * types. The tracking data for the specific pointer is cleared of a `pressTarget`.
       * @param from - The upstream `pointerupoutside` event.
       */
      mapPointerUpOutside(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const trackingData = this.trackingData(from.pointerId);
        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        const e = this.createPointerEvent(from);
        if (pressTarget) {
          let currentTarget = pressTarget;
          while (currentTarget) {
            e.currentTarget = currentTarget;
            this.notifyTarget(e, "pointerupoutside");
            if (e.pointerType === "touch") {
              this.notifyTarget(e, "touchendoutside");
            } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
              this.notifyTarget(e, e.button === 2 ? "rightupoutside" : "mouseupoutside");
            }
            currentTarget = currentTarget.parent;
          }
          delete trackingData.pressTargetsByButton[from.button];
        }
        this.freeEvent(e);
      }
      /**
       * Maps the upstream `wheel` event to a downstream `wheel` event.
       * @param from - The upstream `wheel` event.
       */
      mapWheel(from) {
        if (!(from instanceof FederatedWheelEvent)) {
          console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
          return;
        }
        const wheelEvent = this.createWheelEvent(from);
        this.dispatchEvent(wheelEvent);
        this.freeEvent(wheelEvent);
      }
      /**
       * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.
       *
       * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`
       * or `pointerover` target was unmounted from the scene graph.
       * @param propagationPath - The propagation path was valid in the past.
       * @returns - The most specific event-target still mounted at the same location in the scene graph.
       */
      findMountedTarget(propagationPath) {
        if (!propagationPath) {
          return null;
        }
        let currentTarget = propagationPath[0];
        for (let i = 1; i < propagationPath.length; i++) {
          if (propagationPath[i].parent === currentTarget) {
            currentTarget = propagationPath[i];
          } else {
            break;
          }
        }
        return currentTarget;
      }
      /**
       * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.
       *
       * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.
       * @param from - The {@code originalEvent} for the returned event.
       * @param [type=from.type] - The type of the returned event.
       * @param target - The target of the returned event.
       */
      createPointerEvent(from, type, target) {
        const event = this.allocateEvent(FederatedPointerEvent);
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
        if (typeof type === "string") {
          event.type = type;
        }
        return event;
      }
      /**
       * Creates a wheel event whose {@code originalEvent} is {@code from}.
       *
       * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.
       * @param from - The upstream wheel event.
       */
      createWheelEvent(from) {
        const event = this.allocateEvent(FederatedWheelEvent);
        this.copyWheelData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        event.target = this.hitTest(event.global.x, event.global.y);
        return event;
      }
      /**
       * Clones the event {@code from}, with an optional {@code type} override.
       *
       * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.
       * @param from - The event to clone.
       * @param [type=from.type] - The type of the returned event.
       */
      clonePointerEvent(from, type) {
        const event = this.allocateEvent(FederatedPointerEvent);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from.originalEvent;
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.target = from.target;
        event.path = from.composedPath().slice();
        event.type = type ?? event.type;
        return event;
      }
      /**
       * Copies wheel {@link PIXI.FederatedWheelEvent} data from {@code from} into {@code to}.
       *
       * The following properties are copied:
       * + deltaMode
       * + deltaX
       * + deltaY
       * + deltaZ
       * @param from
       * @param to
       */
      copyWheelData(from, to) {
        to.deltaMode = from.deltaMode;
        to.deltaX = from.deltaX;
        to.deltaY = from.deltaY;
        to.deltaZ = from.deltaZ;
      }
      /**
       * Copies pointer {@link PIXI.FederatedPointerEvent} data from {@code from} into {@code to}.
       *
       * The following properties are copied:
       * + pointerId
       * + width
       * + height
       * + isPrimary
       * + pointerType
       * + pressure
       * + tangentialPressure
       * + tiltX
       * + tiltY
       * @param from
       * @param to
       */
      copyPointerData(from, to) {
        if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))
          return;
        to.pointerId = from.pointerId;
        to.width = from.width;
        to.height = from.height;
        to.isPrimary = from.isPrimary;
        to.pointerType = from.pointerType;
        to.pressure = from.pressure;
        to.tangentialPressure = from.tangentialPressure;
        to.tiltX = from.tiltX;
        to.tiltY = from.tiltY;
        to.twist = from.twist;
      }
      /**
       * Copies mouse {@link PIXI.FederatedMouseEvent} data from {@code from} to {@code to}.
       *
       * The following properties are copied:
       * + altKey
       * + button
       * + buttons
       * + clientX
       * + clientY
       * + metaKey
       * + movementX
       * + movementY
       * + pageX
       * + pageY
       * + x
       * + y
       * + screen
       * + shiftKey
       * + global
       * @param from
       * @param to
       */
      copyMouseData(from, to) {
        if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))
          return;
        to.altKey = from.altKey;
        to.button = from.button;
        to.buttons = from.buttons;
        to.client.copyFrom(from.client);
        to.ctrlKey = from.ctrlKey;
        to.metaKey = from.metaKey;
        to.movement.copyFrom(from.movement);
        to.screen.copyFrom(from.screen);
        to.shiftKey = from.shiftKey;
        to.global.copyFrom(from.global);
      }
      /**
       * Copies base {@link PIXI.FederatedEvent} data from {@code from} into {@code to}.
       *
       * The following properties are copied:
       * + isTrusted
       * + srcElement
       * + timeStamp
       * + type
       * @param from - The event to copy data from.
       * @param to - The event to copy data into.
       */
      copyData(from, to) {
        to.isTrusted = from.isTrusted;
        to.srcElement = from.srcElement;
        to.timeStamp = performance.now();
        to.type = from.type;
        to.detail = from.detail;
        to.view = from.view;
        to.which = from.which;
        to.layer.copyFrom(from.layer);
        to.page.copyFrom(from.page);
      }
      /**
       * @param id - The pointer ID.
       * @returns The tracking data stored for the given pointer. If no data exists, a blank
       *  state will be created.
       */
      trackingData(id) {
        if (!this.mappingState.trackingData[id]) {
          this.mappingState.trackingData[id] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null
          };
        }
        return this.mappingState.trackingData[id];
      }
      /**
       * Allocate a specific type of event from {@link PIXI.EventBoundary#eventPool this.eventPool}.
       *
       * This allocation is constructor-agnostic, as long as it only takes one argument - this event
       * boundary.
       * @param constructor - The event's constructor.
       */
      allocateEvent(constructor) {
        if (!this.eventPool.has(constructor)) {
          this.eventPool.set(constructor, []);
        }
        const event = this.eventPool.get(constructor).pop() || new constructor(this);
        event.eventPhase = event.NONE;
        event.currentTarget = null;
        event.path = null;
        event.target = null;
        return event;
      }
      /**
       * Frees the event and puts it back into the event pool.
       *
       * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.
       *
       * It is also advised that events not allocated from {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}
       * not be freed. This is because of the possibility that the same event is freed twice, which can cause
       * it to be allocated twice & result in overwriting.
       * @param event - The event to be freed.
       * @throws Error if the event is managed by another event boundary.
       */
      freeEvent(event) {
        if (event.manager !== this)
          throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        const constructor = event.constructor;
        if (!this.eventPool.has(constructor)) {
          this.eventPool.set(constructor, []);
        }
        this.eventPool.get(constructor).push(event);
      }
      /**
       * Similar to {@link PIXI.EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag
       * is set on the event.
       * @param e - The event to call each listener with.
       * @param type - The event key.
       */
      notifyListeners(e, type) {
        const listeners = e.currentTarget._events[type];
        if (!listeners)
          return;
        if (!e.currentTarget.isInteractive())
          return;
        if ("fn" in listeners) {
          if (listeners.once)
            e.currentTarget.removeListener(type, listeners.fn, void 0, true);
          listeners.fn.call(listeners.context, e);
        } else {
          for (let i = 0, j2 = listeners.length; i < j2 && !e.propagationImmediatelyStopped; i++) {
            if (listeners[i].once)
              e.currentTarget.removeListener(type, listeners[i].fn, void 0, true);
            listeners[i].fn.call(listeners[i].context, e);
          }
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/events/EventSystem.mjs
var MOUSE_POINTER_ID, TOUCH_TO_POINTER, _EventSystem, EventSystem;
var init_EventSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/events/EventSystem.mjs"() {
    init_Extensions();
    init_EventBoundary();
    init_EventTicker();
    init_FederatedPointerEvent();
    init_FederatedWheelEvent();
    MOUSE_POINTER_ID = 1;
    TOUCH_TO_POINTER = {
      touchstart: "pointerdown",
      touchend: "pointerup",
      touchendoutside: "pointerupoutside",
      touchmove: "pointermove",
      touchcancel: "pointercancel"
    };
    _EventSystem = class {
      /**
       * @param {PIXI.Renderer} renderer
       */
      constructor(renderer) {
        this.supportsTouchEvents = "ontouchstart" in globalThis;
        this.supportsPointerEvents = !!globalThis.PointerEvent;
        this.domElement = null;
        this.resolution = 1;
        this.renderer = renderer;
        this.rootBoundary = new EventBoundary(null);
        EventsTicker.init(this);
        this.autoPreventDefault = true;
        this.eventsAdded = false;
        this.rootPointerEvent = new FederatedPointerEvent(null);
        this.rootWheelEvent = new FederatedWheelEvent(null);
        this.cursorStyles = {
          default: "inherit",
          pointer: "pointer"
        };
        this.features = new Proxy({ ..._EventSystem.defaultEventFeatures }, {
          set: (target, key, value) => {
            if (key === "globalMove") {
              this.rootBoundary.enableGlobalMoveEvents = value;
            }
            target[key] = value;
            return true;
          }
        });
        this.onPointerDown = this.onPointerDown.bind(this);
        this.onPointerMove = this.onPointerMove.bind(this);
        this.onPointerUp = this.onPointerUp.bind(this);
        this.onPointerOverOut = this.onPointerOverOut.bind(this);
        this.onWheel = this.onWheel.bind(this);
      }
      /**
       * The default interaction mode for all display objects.
       * @see PIXI.DisplayObject.eventMode
       * @type {PIXI.EventMode}
       * @readonly
       * @since 7.2.0
       */
      static get defaultEventMode() {
        return this._defaultEventMode;
      }
      /**
       * Runner init called, view is available at this point.
       * @ignore
       */
      init(options) {
        const { element: canvas2, resolution } = this.renderer;
        this.setTargetElement(canvas2);
        this.resolution = resolution;
        _EventSystem._defaultEventMode = options.eventMode ?? "passive";
        Object.assign(this.features, options.eventFeatures ?? {});
        this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
      }
      /**
       * Handle changing resolution.
       * @ignore
       */
      resolutionChange(resolution) {
        this.resolution = resolution;
      }
      /** Destroys all event listeners and detaches the renderer. */
      destroy() {
        this.setTargetElement(null);
        this.renderer = null;
      }
      /**
       * Sets the current cursor mode, handling any callbacks or CSS style changes.
       * @param mode - cursor mode, a key from the cursorStyles dictionary
       */
      setCursor(mode) {
        mode = mode || "default";
        let applyStyles = true;
        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
          applyStyles = false;
        }
        if (this.currentCursor === mode) {
          return;
        }
        this.currentCursor = mode;
        const style = this.cursorStyles[mode];
        if (style) {
          switch (typeof style) {
            case "string":
              if (applyStyles) {
                this.domElement.style.cursor = style;
              }
              break;
            case "function":
              style(mode);
              break;
            case "object":
              if (applyStyles) {
                Object.assign(this.domElement.style, style);
              }
              break;
          }
        } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
          this.domElement.style.cursor = mode;
        }
      }
      /**
       * The global pointer event.
       * Useful for getting the pointer position without listening to events.
       * @since 7.2.0
       */
      get pointer() {
        return this.rootPointerEvent;
      }
      /**
       * Event handler for pointer down events on {@link PIXI.EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch event.
       */
      onPointerDown(nativeEvent) {
        if (!this.features.click)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
          return;
        const events = this.normalizeToPointerData(nativeEvent);
        if (this.autoPreventDefault && events[0].isNormalized) {
          const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
          if (cancelable) {
            nativeEvent.preventDefault();
          }
        }
        for (let i = 0, j2 = events.length; i < j2; i++) {
          const nativeEvent2 = events[i];
          const federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent2);
          this.rootBoundary.mapEvent(federatedEvent);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Event handler for pointer move events on on {@link PIXI.EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch events.
       */
      onPointerMove(nativeEvent) {
        if (!this.features.move)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
          return;
        EventsTicker.pointerMoved();
        const normalizedEvents = this.normalizeToPointerData(nativeEvent);
        for (let i = 0, j2 = normalizedEvents.length; i < j2; i++) {
          const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
          this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Event handler for pointer up events on {@link PIXI.EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch event.
       */
      onPointerUp(nativeEvent) {
        if (!this.features.click)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
          return;
        let target = nativeEvent.target;
        if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
          target = nativeEvent.composedPath()[0];
        }
        const outside = target !== this.domElement ? "outside" : "";
        const normalizedEvents = this.normalizeToPointerData(nativeEvent);
        for (let i = 0, j2 = normalizedEvents.length; i < j2; i++) {
          const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
          event.type += outside;
          this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Event handler for pointer over & out events on {@link PIXI.EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch event.
       */
      onPointerOverOut(nativeEvent) {
        if (!this.features.click)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
          return;
        const normalizedEvents = this.normalizeToPointerData(nativeEvent);
        for (let i = 0, j2 = normalizedEvents.length; i < j2; i++) {
          const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
          this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Passive handler for `wheel` events on {@link PIXI.EventSystem.domElement this.domElement}.
       * @param nativeEvent - The native wheel event.
       */
      onWheel(nativeEvent) {
        if (!this.features.wheel)
          return;
        const wheelEvent = this.normalizeWheelEvent(nativeEvent);
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        this.rootBoundary.mapEvent(wheelEvent);
      }
      /**
       * Sets the {@link PIXI.EventSystem#domElement domElement} and binds event listeners.
       *
       * To deregister the current DOM element without setting a new one, pass {@code null}.
       * @param element - The new DOM element.
       */
      setTargetElement(element) {
        this.removeEvents();
        this.domElement = element;
        EventsTicker.domElement = element;
        this.addEvents();
      }
      /** Register event listeners on {@link PIXI.Renderer#domElement this.domElement}. */
      addEvents() {
        if (this.eventsAdded || !this.domElement) {
          return;
        }
        EventsTicker.addTickerListener();
        const style = this.domElement.style;
        if (style) {
          if (globalThis.navigator.msPointerEnabled) {
            style.msContentZooming = "none";
            style.msTouchAction = "none";
          } else if (this.supportsPointerEvents) {
            style.touchAction = "none";
          }
        }
        if (this.supportsPointerEvents) {
          globalThis.document.addEventListener("pointermove", this.onPointerMove, true);
          this.domElement.addEventListener("pointerdown", this.onPointerDown, true);
          this.domElement.addEventListener("pointerleave", this.onPointerOverOut, true);
          this.domElement.addEventListener("pointerover", this.onPointerOverOut, true);
          globalThis.addEventListener("pointerup", this.onPointerUp, true);
        } else {
          globalThis.document.addEventListener("mousemove", this.onPointerMove, true);
          this.domElement.addEventListener("mousedown", this.onPointerDown, true);
          this.domElement.addEventListener("mouseout", this.onPointerOverOut, true);
          this.domElement.addEventListener("mouseover", this.onPointerOverOut, true);
          globalThis.addEventListener("mouseup", this.onPointerUp, true);
        }
        if (this.supportsTouchEvents) {
          this.domElement.addEventListener("touchstart", this.onPointerDown, true);
          this.domElement.addEventListener("touchend", this.onPointerUp, true);
          this.domElement.addEventListener("touchmove", this.onPointerMove, true);
        }
        this.domElement.addEventListener("wheel", this.onWheel, {
          passive: true,
          capture: true
        });
        this.eventsAdded = true;
      }
      /** Unregister event listeners on {@link PIXI.EventSystem#domElement this.domElement}. */
      removeEvents() {
        if (!this.eventsAdded || !this.domElement) {
          return;
        }
        EventsTicker.removeTickerListener();
        const style = this.domElement.style;
        if (globalThis.navigator.msPointerEnabled) {
          style.msContentZooming = "";
          style.msTouchAction = "";
        } else if (this.supportsPointerEvents) {
          style.touchAction = "";
        }
        if (this.supportsPointerEvents) {
          globalThis.document.removeEventListener("pointermove", this.onPointerMove, true);
          this.domElement.removeEventListener("pointerdown", this.onPointerDown, true);
          this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, true);
          this.domElement.removeEventListener("pointerover", this.onPointerOverOut, true);
          globalThis.removeEventListener("pointerup", this.onPointerUp, true);
        } else {
          globalThis.document.removeEventListener("mousemove", this.onPointerMove, true);
          this.domElement.removeEventListener("mousedown", this.onPointerDown, true);
          this.domElement.removeEventListener("mouseout", this.onPointerOverOut, true);
          this.domElement.removeEventListener("mouseover", this.onPointerOverOut, true);
          globalThis.removeEventListener("mouseup", this.onPointerUp, true);
        }
        if (this.supportsTouchEvents) {
          this.domElement.removeEventListener("touchstart", this.onPointerDown, true);
          this.domElement.removeEventListener("touchend", this.onPointerUp, true);
          this.domElement.removeEventListener("touchmove", this.onPointerMove, true);
        }
        this.domElement.removeEventListener("wheel", this.onWheel, true);
        this.domElement = null;
        this.eventsAdded = false;
      }
      /**
       * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The
       * resulting value is stored in the point. This takes into account the fact that the DOM
       * element could be scaled and positioned anywhere on the screen.
       * @param  {PIXI.PointData} point - the point that the result will be stored in
       * @param  {number} x - the x coord of the position to map
       * @param  {number} y - the y coord of the position to map
       */
      mapPositionToPoint(point, x2, y) {
        const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
          x: 0,
          y: 0,
          width: this.domElement.width,
          height: this.domElement.height,
          left: 0,
          top: 0
        };
        const resolutionMultiplier = 1 / this.resolution;
        point.x = (x2 - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
        point.y = (y - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
      }
      /**
       * Ensures that the original event object contains all data that a regular pointer event would have
       * @param event - The original event data from a touch or mouse event
       * @returns An array containing a single normalized pointer event, in the case of a pointer
       *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
       */
      normalizeToPointerData(event) {
        const normalizedEvents = [];
        if (this.supportsTouchEvents && event instanceof TouchEvent) {
          for (let i = 0, li = event.changedTouches.length; i < li; i++) {
            const touch = event.changedTouches[i];
            if (typeof touch.button === "undefined")
              touch.button = 0;
            if (typeof touch.buttons === "undefined")
              touch.buttons = 1;
            if (typeof touch.isPrimary === "undefined") {
              touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
            }
            if (typeof touch.width === "undefined")
              touch.width = touch.radiusX || 1;
            if (typeof touch.height === "undefined")
              touch.height = touch.radiusY || 1;
            if (typeof touch.tiltX === "undefined")
              touch.tiltX = 0;
            if (typeof touch.tiltY === "undefined")
              touch.tiltY = 0;
            if (typeof touch.pointerType === "undefined")
              touch.pointerType = "touch";
            if (typeof touch.pointerId === "undefined")
              touch.pointerId = touch.identifier || 0;
            if (typeof touch.pressure === "undefined")
              touch.pressure = touch.force || 0.5;
            if (typeof touch.twist === "undefined")
              touch.twist = 0;
            if (typeof touch.tangentialPressure === "undefined")
              touch.tangentialPressure = 0;
            if (typeof touch.layerX === "undefined")
              touch.layerX = touch.offsetX = touch.clientX;
            if (typeof touch.layerY === "undefined")
              touch.layerY = touch.offsetY = touch.clientY;
            touch.isNormalized = true;
            touch.type = event.type;
            normalizedEvents.push(touch);
          }
        } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
          const tempEvent = event;
          if (typeof tempEvent.isPrimary === "undefined")
            tempEvent.isPrimary = true;
          if (typeof tempEvent.width === "undefined")
            tempEvent.width = 1;
          if (typeof tempEvent.height === "undefined")
            tempEvent.height = 1;
          if (typeof tempEvent.tiltX === "undefined")
            tempEvent.tiltX = 0;
          if (typeof tempEvent.tiltY === "undefined")
            tempEvent.tiltY = 0;
          if (typeof tempEvent.pointerType === "undefined")
            tempEvent.pointerType = "mouse";
          if (typeof tempEvent.pointerId === "undefined")
            tempEvent.pointerId = MOUSE_POINTER_ID;
          if (typeof tempEvent.pressure === "undefined")
            tempEvent.pressure = 0.5;
          if (typeof tempEvent.twist === "undefined")
            tempEvent.twist = 0;
          if (typeof tempEvent.tangentialPressure === "undefined")
            tempEvent.tangentialPressure = 0;
          tempEvent.isNormalized = true;
          normalizedEvents.push(tempEvent);
        } else {
          normalizedEvents.push(event);
        }
        return normalizedEvents;
      }
      /**
       * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.
       *
       * The returned {@link PIXI.FederatedWheelEvent} is a shared instance. It will not persist across
       * multiple native wheel events.
       * @param nativeEvent - The native wheel event that occurred on the canvas.
       * @returns A federated wheel event.
       */
      normalizeWheelEvent(nativeEvent) {
        const event = this.rootWheelEvent;
        this.transferMouseData(event, nativeEvent);
        event.deltaX = nativeEvent.deltaX;
        event.deltaY = nativeEvent.deltaY;
        event.deltaZ = nativeEvent.deltaZ;
        event.deltaMode = nativeEvent.deltaMode;
        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
        event.global.copyFrom(event.screen);
        event.offset.copyFrom(event.screen);
        event.nativeEvent = nativeEvent;
        event.type = nativeEvent.type;
        return event;
      }
      /**
       * Normalizes the `nativeEvent` into a federateed {@link PIXI.FederatedPointerEvent}.
       * @param event
       * @param nativeEvent
       */
      bootstrapEvent(event, nativeEvent) {
        event.originalEvent = null;
        event.nativeEvent = nativeEvent;
        event.pointerId = nativeEvent.pointerId;
        event.width = nativeEvent.width;
        event.height = nativeEvent.height;
        event.isPrimary = nativeEvent.isPrimary;
        event.pointerType = nativeEvent.pointerType;
        event.pressure = nativeEvent.pressure;
        event.tangentialPressure = nativeEvent.tangentialPressure;
        event.tiltX = nativeEvent.tiltX;
        event.tiltY = nativeEvent.tiltY;
        event.twist = nativeEvent.twist;
        this.transferMouseData(event, nativeEvent);
        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
        event.global.copyFrom(event.screen);
        event.offset.copyFrom(event.screen);
        event.isTrusted = nativeEvent.isTrusted;
        if (event.type === "pointerleave") {
          event.type = "pointerout";
        }
        if (event.type.startsWith("mouse")) {
          event.type = event.type.replace("mouse", "pointer");
        }
        if (event.type.startsWith("touch")) {
          event.type = TOUCH_TO_POINTER[event.type] || event.type;
        }
        return event;
      }
      /**
       * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.
       * @param event
       * @param nativeEvent
       */
      transferMouseData(event, nativeEvent) {
        event.isTrusted = nativeEvent.isTrusted;
        event.srcElement = nativeEvent.srcElement;
        event.timeStamp = performance.now();
        event.type = nativeEvent.type;
        event.altKey = nativeEvent.altKey;
        event.button = nativeEvent.button;
        event.buttons = nativeEvent.buttons;
        event.client.x = nativeEvent.clientX;
        event.client.y = nativeEvent.clientY;
        event.ctrlKey = nativeEvent.ctrlKey;
        event.metaKey = nativeEvent.metaKey;
        event.movement.x = nativeEvent.movementX;
        event.movement.y = nativeEvent.movementY;
        event.page.x = nativeEvent.pageX;
        event.page.y = nativeEvent.pageY;
        event.relatedTarget = null;
        event.shiftKey = nativeEvent.shiftKey;
      }
    };
    EventSystem = _EventSystem;
    EventSystem.extension = {
      name: "events",
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.CanvasSystem,
        ExtensionType.WebGPUSystem
      ],
      priority: -1
    };
    EventSystem.defaultEventFeatures = {
      move: true,
      globalMove: true,
      click: true,
      wheel: true
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/events/FederatedEventTarget.mjs
var FederatedContainer;
var init_FederatedEventTarget = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/events/FederatedEventTarget.mjs"() {
    init_EventSystem();
    init_FederatedEvent();
    FederatedContainer = {
      /**
       * Property-based event handler for the `click` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onclick = (event) => {
       *  //some function here that happens on click
       * }
       */
      onclick: null,
      /**
       * Property-based event handler for the `mousedown` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onmousedown = (event) => {
       *  //some function here that happens on mousedown
       * }
       */
      onmousedown: null,
      /**
       * Property-based event handler for the `mouseenter` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onmouseenter = (event) => {
       *  //some function here that happens on mouseenter
       * }
       */
      onmouseenter: null,
      /**
       * Property-based event handler for the `mouseleave` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onmouseleave = (event) => {
       *  //some function here that happens on mouseleave
       * }
       */
      onmouseleave: null,
      /**
       * Property-based event handler for the `mousemove` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onmousemove = (event) => {
       *  //some function here that happens on mousemove
       * }
       */
      onmousemove: null,
      /**
       * Property-based event handler for the `globalmousemove` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onglobalmousemove = (event) => {
       *  //some function here that happens on globalmousemove
       * }
       */
      onglobalmousemove: null,
      /**
       * Property-based event handler for the `mouseout` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onmouseout = (event) => {
       *  //some function here that happens on mouseout
       * }
       */
      onmouseout: null,
      /**
       * Property-based event handler for the `mouseover` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onmouseover = (event) => {
       *  //some function here that happens on mouseover
       * }
       */
      onmouseover: null,
      /**
       * Property-based event handler for the `mouseup` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onmouseup = (event) => {
       *  //some function here that happens on mouseup
       * }
       */
      onmouseup: null,
      /**
       * Property-based event handler for the `mouseupoutside` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onmouseupoutside = (event) => {
       *  //some function here that happens on mouseupoutside
       * }
       */
      onmouseupoutside: null,
      /**
       * Property-based event handler for the `pointercancel` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onpointercancel = (event) => {
       *  //some function here that happens on pointercancel
       * }
       */
      onpointercancel: null,
      /**
       * Property-based event handler for the `pointerdown` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onpointerdown = (event) => {
       *  //some function here that happens on pointerdown
       * }
       */
      onpointerdown: null,
      /**
       * Property-based event handler for the `pointerenter` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onpointerenter = (event) => {
       *  //some function here that happens on pointerenter
       * }
       */
      onpointerenter: null,
      /**
       * Property-based event handler for the `pointerleave` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onpointerleave = (event) => {
       *  //some function here that happens on pointerleave
       * }
       */
      onpointerleave: null,
      /**
       * Property-based event handler for the `pointermove` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onpointermove = (event) => {
       *  //some function here that happens on pointermove
       * }
       */
      onpointermove: null,
      /**
       * Property-based event handler for the `globalpointermove` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onglobalpointermove = (event) => {
       *  //some function here that happens on globalpointermove
       * }
       */
      onglobalpointermove: null,
      /**
       * Property-based event handler for the `pointerout` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onpointerout = (event) => {
       *  //some function here that happens on pointerout
       * }
       */
      onpointerout: null,
      /**
       * Property-based event handler for the `pointerover` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onpointerover = (event) => {
       *  //some function here that happens on pointerover
       * }
       */
      onpointerover: null,
      /**
       * Property-based event handler for the `pointertap` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onpointertap = (event) => {
       *  //some function here that happens on pointertap
       * }
       */
      onpointertap: null,
      /**
       * Property-based event handler for the `pointerup` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onpointerup = (event) => {
       *  //some function here that happens on pointerup
       * }
       */
      onpointerup: null,
      /**
       * Property-based event handler for the `pointerupoutside` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onpointerupoutside = (event) => {
       *  //some function here that happens on pointerupoutside
       * }
       */
      onpointerupoutside: null,
      /**
       * Property-based event handler for the `rightclick` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onrightclick = (event) => {
       *  //some function here that happens on rightclick
       * }
       */
      onrightclick: null,
      /**
       * Property-based event handler for the `rightdown` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onrightdown = (event) => {
       *  //some function here that happens on rightdown
       * }
       */
      onrightdown: null,
      /**
       * Property-based event handler for the `rightup` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onrightup = (event) => {
       *  //some function here that happens on rightup
       * }
       */
      onrightup: null,
      /**
       * Property-based event handler for the `rightupoutside` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onrightupoutside = (event) => {
       *  //some function here that happens on rightupoutside
       * }
       */
      onrightupoutside: null,
      /**
       * Property-based event handler for the `tap` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.ontap = (event) => {
       *  //some function here that happens on tap
       * }
       */
      ontap: null,
      /**
       * Property-based event handler for the `touchcancel` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.ontouchcancel = (event) => {
       *  //some function here that happens on touchcancel
       * }
       */
      ontouchcancel: null,
      /**
       * Property-based event handler for the `touchend` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.ontouchend = (event) => {
       *  //some function here that happens on touchend
       * }
       */
      ontouchend: null,
      /**
       * Property-based event handler for the `touchendoutside` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.ontouchendoutside = (event) => {
       *  //some function here that happens on touchendoutside
       * }
       */
      ontouchendoutside: null,
      /**
       * Property-based event handler for the `touchmove` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.ontouchmove = (event) => {
       *  //some function here that happens on touchmove
       * }
       */
      ontouchmove: null,
      /**
       * Property-based event handler for the `globaltouchmove` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onglobaltouchmove = (event) => {
       *  //some function here that happens on globaltouchmove
       * }
       */
      onglobaltouchmove: null,
      /**
       * Property-based event handler for the `touchstart` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.ontouchstart = (event) => {
       *  //some function here that happens on touchstart
       * }
       */
      ontouchstart: null,
      /**
       * Property-based event handler for the `wheel` event.
       * @memberof PIXI.DisplayObject#
       * @default null
       * @example
       * this.onwheel = (event) => {
       *  //some function here that happens on wheel
       * }
       */
      onwheel: null,
      /**
       * Enable interaction events for the DisplayObject. Touch, pointer and mouse
       * @memberof PIXI.DisplayObject#
       */
      get interactive() {
        return this.eventMode === "dynamic" || this.eventMode === "static";
      },
      set interactive(value) {
        this.eventMode = value ? "static" : "passive";
      },
      /**
       * @ignore
       */
      _internalEventMode: void 0,
      /**
       * Enable interaction events for the DisplayObject. Touch, pointer and mouse.
       * This now replaces the `interactive` property
       * There is 5 types of interaction settings:
       * - `'none'`: Ignores all interaction events, even on its children.
       * - `'passive'`: Does not emit events and ignores all hit testing on itself and non-interactive children.
       * Interactive children will still emit events.
       * - `'auto'`: Does not emit events and but is hit tested if parent is interactive. Same as `interactive = false` in v7
       * - `'static'`: Emit events and is hit tested. Same as `interaction = true` in v7
       * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from a ticker to
       * allow for interaction when the mouse isn't moving
       * @example
       * import { Sprite } from 'pixi.js';
       *
       * const sprite = new Sprite(texture);
       * sprite.eventMode = 'static';
       * sprite.on('tap', (event) => {
       *     // Handle event
       * });
       * @memberof PIXI.DisplayObject#
       * @since 7.2.0
       */
      get eventMode() {
        return this._internalEventMode ?? EventSystem.defaultEventMode;
      },
      set eventMode(value) {
        this._internalEventMode = value;
      },
      /**
       * Determines if the displayObject is interactive or not
       * @returns {boolean} Whether the displayObject is interactive or not
       * @memberof PIXI.DisplayObject#
       * @since 7.2.0
       * @example
       * import { Sprite } from 'pixi.js';
       * const sprite = new Sprite(texture);
       * sprite.eventMode = 'static';
       * sprite.isInteractive(); // true
       *
       * sprite.eventMode = 'dynamic';
       * sprite.isInteractive(); // true
       *
       * sprite.eventMode = 'none';
       * sprite.isInteractive(); // false
       *
       * sprite.eventMode = 'passive';
       * sprite.isInteractive(); // false
       *
       * sprite.eventMode = 'auto';
       * sprite.isInteractive(); // false
       */
      isInteractive() {
        return this.eventMode === "static" || this.eventMode === "dynamic";
      },
      /**
       * Determines if the children to the displayObject can be clicked/touched
       * Setting this to false allows PixiJS to bypass a recursive `hitTest` function
       * @memberof PIXI.Container#
       */
      interactiveChildren: true,
      /**
       * Interaction shape. Children will be hit first, then this shape will be checked.
       * Setting this will cause this shape to be checked in hit tests rather than the displayObject's bounds.
       * @example
       * import { Rectangle, Sprite } from 'pixi.js';
       *
       * const sprite = new Sprite(texture);
       * sprite.interactive = true;
       * sprite.hitArea = new Rectangle(0, 0, 100, 100);
       * @member {PIXI.IHitArea}
       * @memberof PIXI.DisplayObject#
       */
      hitArea: null,
      /**
       * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`
       * seeks to be compatible with the DOM's `addEventListener` with support for options.
       * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.
       * @memberof PIXI.DisplayObject
       * @param type - The type of event to listen to.
       * @param listener - The listener callback or object.
       * @param options - Listener options, used for capture phase.
       * @example
       * // Tell the user whether they did a single, double, triple, or nth click.
       * button.addEventListener('click', {
       *     handleEvent(e): {
       *         let prefix;
       *
       *         switch (e.detail) {
       *             case 1: prefix = 'single'; break;
       *             case 2: prefix = 'double'; break;
       *             case 3: prefix = 'triple'; break;
       *             default: prefix = e.detail + 'th'; break;
       *         }
       *
       *         console.log('That was a ' + prefix + 'click');
       *     }
       * });
       *
       * // But skip the first click!
       * button.parent.addEventListener('click', function blockClickOnce(e) {
       *     e.stopImmediatePropagation();
       *     button.parent.removeEventListener('click', blockClickOnce, true);
       * }, {
       *     capture: true,
       * });
       */
      addEventListener(type, listener, options) {
        const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
        const context = typeof listener === "function" ? void 0 : listener;
        type = capture ? `${type}capture` : type;
        listener = typeof listener === "function" ? listener : listener.handleEvent;
        this.on(type, listener, context);
      },
      /**
       * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`
       * seeks to be compatible with the DOM's `removeEventListener` with support for options.
       * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.
       * @memberof PIXI.DisplayObject
       * @param type - The type of event the listener is bound to.
       * @param listener - The listener callback or object.
       * @param options - The original listener options. This is required to deregister a capture phase listener.
       */
      removeEventListener(type, listener, options) {
        const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
        const context = typeof listener === "function" ? void 0 : listener;
        type = capture ? `${type}capture` : type;
        listener = typeof listener === "function" ? listener : listener.handleEvent;
        this.off(type, listener, context);
      },
      /**
       * Dispatch the event on this {@link PIXI.DisplayObject} using the event's {@link PIXI.EventBoundary}.
       *
       * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.
       *
       * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.
       * @memberof PIXI.DisplayObject
       * @param e - The event to dispatch.
       * @returns Whether the {@link PIXI.FederatedEvent.preventDefault preventDefault}() method was not invoked.
       * @example
       * // Reuse a click event!
       * button.dispatchEvent(clickEvent);
       */
      dispatchEvent(e) {
        if (!(e instanceof FederatedEvent)) {
          throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
        }
        e.defaultPrevented = false;
        e.path = null;
        e.target = this;
        e.manager.dispatchEvent(e);
        return !e.defaultPrevented;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/events/init.mjs
var init_init3 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/events/init.mjs"() {
    init_Extensions();
    init_Container();
    init_EventSystem();
    init_FederatedEventTarget();
    extensions.add(EventSystem);
    Container.mixin(FederatedContainer);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs
var _Spritesheet, Spritesheet;
var init_Spritesheet = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs"() {
    init_Rectangle();
    init_Texture();
    _Spritesheet = class {
      /**
       * @param texture - Reference to the source BaseTexture object.
       * @param {object} data - Spritesheet image data.
       */
      constructor(texture, data) {
        this.linkedSheets = [];
        this._texture = texture instanceof Texture ? texture : null;
        this.textureSource = texture.source;
        this.textures = {};
        this.animations = {};
        this.data = data;
        const metaResolution = parseFloat(data.meta.scale);
        if (metaResolution) {
          this.resolution = metaResolution;
          texture.source.resolution = this.resolution;
        } else {
          this.resolution = texture.source._resolution;
        }
        this._frames = this.data.frames;
        this._frameKeys = Object.keys(this._frames);
        this._batchIndex = 0;
        this._callback = null;
      }
      /**
       * Parser spritesheet from loaded data. This is done asynchronously
       * to prevent creating too many Texture within a single process.
       * @method PIXI.Spritesheet#parse
       */
      parse() {
        return new Promise((resolve) => {
          this._callback = resolve;
          this._batchIndex = 0;
          if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {
            this._processFrames(0);
            this._processAnimations();
            this._parseComplete();
          } else {
            this._nextBatch();
          }
        });
      }
      /**
       * Process a batch of frames
       * @param initialFrameIndex - The index of frame to start.
       */
      _processFrames(initialFrameIndex) {
        let frameIndex = initialFrameIndex;
        const maxFrames = _Spritesheet.BATCH_SIZE;
        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
          const i = this._frameKeys[frameIndex];
          const data = this._frames[i];
          const rect = data.frame;
          if (rect) {
            let frame = null;
            let trim = null;
            const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
            const orig = new Rectangle(
              0,
              0,
              Math.floor(sourceSize.w) / this.resolution,
              Math.floor(sourceSize.h) / this.resolution
            );
            if (data.rotated) {
              frame = new Rectangle(
                Math.floor(rect.x) / this.resolution,
                Math.floor(rect.y) / this.resolution,
                Math.floor(rect.h) / this.resolution,
                Math.floor(rect.w) / this.resolution
              );
            } else {
              frame = new Rectangle(
                Math.floor(rect.x) / this.resolution,
                Math.floor(rect.y) / this.resolution,
                Math.floor(rect.w) / this.resolution,
                Math.floor(rect.h) / this.resolution
              );
            }
            if (data.trimmed !== false && data.spriteSourceSize) {
              trim = new Rectangle(
                Math.floor(data.spriteSourceSize.x) / this.resolution,
                Math.floor(data.spriteSourceSize.y) / this.resolution,
                Math.floor(rect.w) / this.resolution,
                Math.floor(rect.h) / this.resolution
              );
              trim.x /= this.textureSource.width;
              trim.y /= this.textureSource.height;
              trim.width /= this.textureSource.width;
              trim.height /= this.textureSource.height;
            }
            frame.x /= this.textureSource.width;
            frame.y /= this.textureSource.height;
            frame.width /= this.textureSource.width;
            frame.height /= this.textureSource.height;
            orig.x /= this.textureSource.width;
            orig.y /= this.textureSource.height;
            orig.width /= this.textureSource.width;
            orig.height /= this.textureSource.height;
            this.textures[i] = new Texture({
              source: this.textureSource,
              layout: {
                frame,
                orig,
                trim,
                rotate: data.rotated ? 2 : 0,
                defaultAnchor: data.anchor
                // TODO - add data.borders
              },
              label: i
            });
          }
          frameIndex++;
        }
      }
      /** Parse animations config. */
      _processAnimations() {
        const animations = this.data.animations || {};
        for (const animName in animations) {
          this.animations[animName] = [];
          for (let i = 0; i < animations[animName].length; i++) {
            const frameName = animations[animName][i];
            this.animations[animName].push(this.textures[frameName]);
          }
        }
      }
      /** The parse has completed. */
      _parseComplete() {
        const callback = this._callback;
        this._callback = null;
        this._batchIndex = 0;
        callback.call(this, this.textures);
      }
      /** Begin the next batch of textures. */
      _nextBatch() {
        this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);
        this._batchIndex++;
        setTimeout(() => {
          if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {
            this._nextBatch();
          } else {
            this._processAnimations();
            this._parseComplete();
          }
        }, 0);
      }
      /**
       * Destroy Spritesheet and don't use after this.
       * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
       */
      destroy(destroyBase = false) {
        for (const i in this.textures) {
          this.textures[i].destroy();
        }
        this._frames = null;
        this._frameKeys = null;
        this.data = null;
        this.textures = null;
        if (destroyBase) {
          this._texture?.destroy();
          this.textureSource.destroy();
        }
        this._texture = null;
        this.textureSource = null;
        this.linkedSheets = [];
      }
    };
    Spritesheet = _Spritesheet;
    Spritesheet.BATCH_SIZE = 1e3;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs
function getCacheableAssets(keys, asset, ignoreMultiPack) {
  const out2 = {};
  keys.forEach((key) => {
    out2[key] = asset;
  });
  Object.keys(asset.textures).forEach((key) => {
    out2[key] = asset.textures[key];
  });
  if (!ignoreMultiPack) {
    const basePath = path.dirname(keys[0]);
    asset.linkedSheets.forEach((item, i) => {
      const out22 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);
      Object.assign(out2, out22);
    });
  }
  return out2;
}
var validImages, spritesheetAsset;
var init_spritesheetAsset = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs"() {
    init_LoaderParser();
    init_copySearchParams();
    init_Extensions();
    init_settings();
    init_path();
    init_Spritesheet();
    validImages = ["jpg", "png", "jpeg", "avif", "webp"];
    spritesheetAsset = {
      extension: ExtensionType.Asset,
      /** Handle the caching of the related Spritesheet Textures */
      cache: {
        test: (asset) => asset instanceof Spritesheet,
        getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
      },
      /** Resolve the the resolution of the asset. */
      resolver: {
        test: (value) => {
          const tempURL = value.split("?")[0];
          const split = tempURL.split(".");
          const extension = split.pop();
          const format2 = split.pop();
          return extension === "json" && validImages.includes(format2);
        },
        parse: (value) => {
          const split = value.split(".");
          return {
            resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
            format: split[split.length - 2],
            src: value
          };
        }
      },
      /**
       * Loader plugin that parses sprite sheets!
       * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
       * If it is, we load the spritesheets image and parse the data into PIXI.Spritesheet
       * All textures in the sprite sheet are then added to the cache
       * @ignore
       */
      loader: {
        name: "spritesheetLoader",
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Normal
        },
        async testParse(asset, options) {
          return path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
        },
        async parse(asset, options, loader) {
          let basePath = path.dirname(options.src);
          if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
            basePath += "/";
          }
          let imagePath = basePath + asset.meta.image;
          imagePath = copySearchParams(imagePath, options.src);
          const assets = await loader.load([imagePath]);
          const texture = assets[imagePath];
          const spritesheet = new Spritesheet(
            texture.source,
            asset
          );
          await spritesheet.parse();
          const multiPacks = asset?.meta?.related_multi_packs;
          if (Array.isArray(multiPacks)) {
            const promises = [];
            for (const item of multiPacks) {
              if (typeof item !== "string") {
                continue;
              }
              let itemUrl = basePath + item;
              if (options.data?.ignoreMultiPack) {
                continue;
              }
              itemUrl = copySearchParams(itemUrl, options.src);
              promises.push(loader.load({
                src: itemUrl,
                data: {
                  ignoreMultiPack: true
                }
              }));
            }
            const res = await Promise.all(promises);
            spritesheet.linkedSheets = res;
            res.forEach((item) => {
              item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
            });
          }
          return spritesheet;
        },
        unload(spritesheet) {
          spritesheet.destroy(true);
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/spritesheet/init.mjs
var init_init4 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/spritesheet/init.mjs"() {
    init_Extensions();
    init_spritesheetAsset();
    extensions.add(spritesheetAsset);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/View.mjs
var emptyViewObserver;
var init_View = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/View.mjs"() {
    emptyViewObserver = {
      onViewUpdate: () => {
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/sprite/shared/SpriteView.mjs
var uid2, SpriteView;
var init_SpriteView = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/sprite/shared/SpriteView.mjs"() {
    init_ObservablePoint();
    init_View();
    uid2 = 0;
    SpriteView = class {
      constructor(texture) {
        this.owner = emptyViewObserver;
        this.batched = true;
        this.buildId = 0;
        this.uid = uid2++;
        this.type = "sprite";
        this._bounds = [0, 1, 0, 0];
        this._sourceBounds = [0, 1, 0, 0];
        this.boundsDirty = true;
        this.sourceBoundsDirty = true;
        this.anchor = new ObservablePoint(
          this,
          texture.layout.defaultAnchor?.x || 0,
          texture.layout.defaultAnchor?.y || 0
        );
        this.texture = texture;
      }
      set texture(value) {
        if (this._texture === value)
          return;
        value.on("update", this.onUpdate, this);
        this._texture = value;
        value.off("update", this.onUpdate, this);
        this.onUpdate();
      }
      get texture() {
        return this._texture;
      }
      get bounds() {
        if (this.boundsDirty) {
          this.updateBounds();
          this.boundsDirty = false;
        }
        return this._bounds;
      }
      get sourceBounds() {
        if (this.sourceBoundsDirty) {
          this._updateSourceBounds();
          this.sourceBoundsDirty = false;
        }
        return this._sourceBounds;
      }
      updateBounds() {
        const texture = this._texture;
        const textureSource = texture._source;
        const layout = texture.layout;
        const orig = layout.orig;
        const trim = layout.trim;
        const textureSourceWidth = textureSource.width;
        const textureSourceHeight = textureSource.height;
        const width = textureSourceWidth * orig.width;
        const height = textureSourceHeight * orig.height;
        const anchor = this.anchor;
        const bounds = this._bounds;
        if (trim) {
          const sourceWidth = textureSourceWidth * trim.width;
          const sourceHeight = textureSourceHeight * trim.height;
          bounds[1] = trim.x * textureSourceWidth - anchor._x * width;
          bounds[0] = bounds[1] + sourceWidth;
          bounds[3] = trim.y * textureSourceHeight - anchor._y * height;
          bounds[2] = bounds[3] + sourceHeight;
        } else {
          bounds[1] = -anchor._x * width;
          bounds[0] = bounds[1] + width;
          bounds[3] = -anchor._y * height;
          bounds[2] = bounds[3] + height;
        }
        return;
      }
      _updateSourceBounds() {
        const anchor = this.anchor;
        const texture = this._texture;
        const textureSource = texture._source;
        const layout = texture.layout;
        const orig = layout.orig;
        const sourceBounds = this._sourceBounds;
        const width = textureSource.width * orig.width;
        const height = textureSource.height * orig.height;
        sourceBounds[1] = -anchor._x * width;
        sourceBounds[0] = sourceBounds[1] + width;
        sourceBounds[3] = -anchor._y * height;
        sourceBounds[2] = sourceBounds[3] + height;
      }
      addBounds(bounds) {
        const trim = this._texture._layout.trim;
        if (trim) {
          const sourceBounds = this.sourceBounds;
          bounds.addFrame(sourceBounds[0], sourceBounds[2], sourceBounds[1], sourceBounds[3]);
        } else {
          const _bounds = this.bounds;
          bounds.addFrame(_bounds[0], _bounds[2], _bounds[1], _bounds[3]);
        }
      }
      onUpdate() {
        this.didUpdate = true;
        this.sourceBoundsDirty = this.boundsDirty = true;
        this.owner.onViewUpdate();
      }
      // passed local space..
      containsPoint(point) {
        const width = this._texture.frameWidth;
        const height = this._texture.frameHeight;
        const x1 = -width * this.anchor.x;
        let y1 = 0;
        if (point.x >= x1 && point.x < x1 + width) {
          y1 = -height * this.anchor.y;
          if (point.y >= y1 && point.y < y1 + height) {
            return true;
          }
        }
        return false;
      }
      /**
       * Destroys this sprite renderable and optionally its texture.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
       * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
       */
      destroy(options = false) {
        this.anchor = null;
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          this._texture.destroy(destroyTextureSource);
        }
        this._texture = null;
        this._bounds = null;
        this._sourceBounds = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/sprite/shared/Sprite.mjs
var Sprite;
var init_Sprite = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/sprite/shared/Sprite.mjs"() {
    init_Cache();
    init_Texture();
    init_Container();
    init_SpriteView();
    Sprite = class _Sprite extends Container {
      static from(id) {
        if (typeof id === "string") {
          return new _Sprite(Cache.get(id));
        }
        return new _Sprite(id);
      }
      constructor(options = Texture.EMPTY) {
        if (options instanceof Texture) {
          options = { texture: options };
        }
        options.texture ?? (options.texture = Texture.EMPTY);
        super({
          view: new SpriteView(options.texture),
          label: "Sprite",
          ...options
        });
      }
      get anchor() {
        return this.view.anchor;
      }
      get texture() {
        return this.view.texture;
      }
      set texture(value) {
        this.view.texture = value;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mask/shared/addMaskBounds.mjs
function addMaskBounds(mask, bounds, skipUpdateTransform) {
  const boundsToMask = tempBounds2;
  mask.measurable = true;
  getGlobalBounds(mask, skipUpdateTransform, boundsToMask);
  bounds.addBoundsMask(boundsToMask);
  mask.measurable = false;
}
var tempBounds2;
var init_addMaskBounds = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mask/shared/addMaskBounds.mjs"() {
    init_Bounds();
    init_getGlobalBounds();
    tempBounds2 = new Bounds();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mask/shared/addMaskLocalBounds.mjs
function addMaskLocalBounds(mask, bounds, localRoot) {
  const boundsToMask = new Bounds();
  mask.measurable = true;
  const relativeMask = getMatrixRelativeToParent(mask, localRoot, new Matrix());
  getLocalBounds(mask, boundsToMask, relativeMask);
  mask.measurable = false;
  bounds.addBoundsMask(boundsToMask);
}
function getMatrixRelativeToParent(target, root, matrix) {
  if (!target) {
    console.warn("Item is not inside the root container");
    return matrix;
  }
  if (target !== root) {
    getMatrixRelativeToParent(target.parent, root, matrix);
    if (target.didChange) {
      updateLocalTransform(target.localTransform, target);
    }
    matrix.append(target.localTransform);
  }
  return matrix;
}
var init_addMaskLocalBounds = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mask/shared/addMaskLocalBounds.mjs"() {
    init_Matrix();
    init_Bounds();
    init_getLocalBounds();
    init_updateLocalTransform();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mask/shared/AlphaMask.mjs
var AlphaMask;
var init_AlphaMask = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mask/shared/AlphaMask.mjs"() {
    init_Extensions();
    init_Sprite();
    init_addMaskBounds();
    init_addMaskLocalBounds();
    AlphaMask = class {
      constructor(options) {
        this.priority = 0;
        this.pipe = "alphaMask";
        if (options?.mask) {
          this.init(options.mask);
        }
      }
      init(mask) {
        this.mask = mask;
        this.renderMaskToTexture = !(mask instanceof Sprite);
        this.mask.renderable = this.renderMaskToTexture;
        this.mask.includeInBuild = !this.renderMaskToTexture;
        this.mask.measurable = false;
      }
      reset() {
        this.mask.measurable = true;
        this.mask = null;
      }
      addBounds(bounds, skipUpdateTransform) {
        addMaskBounds(this.mask, bounds, skipUpdateTransform);
      }
      addLocalBounds(bounds, localRoot) {
        addMaskLocalBounds(this.mask, bounds, localRoot);
      }
      containsPoint(point) {
        const mask = this.mask;
        if (mask.containsPoint) {
          return mask.containsPoint(point);
        }
        return false;
      }
      destroy() {
        this.reset();
      }
      static test(mask) {
        return mask instanceof Sprite;
      }
    };
    AlphaMask.extension = ExtensionType.MaskEffect;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mask/shared/ColorMask.mjs
var ColorMask;
var init_ColorMask = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mask/shared/ColorMask.mjs"() {
    init_Extensions();
    ColorMask = class {
      constructor(options) {
        this.priority = 0;
        this.pipe = "colorMask";
        if (options?.mask) {
          this.init(options.mask);
        }
      }
      init(mask) {
        this.mask = mask;
      }
      destroy() {
      }
      static test(mask) {
        return typeof mask === "number";
      }
    };
    ColorMask.extension = ExtensionType.MaskEffect;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mask/shared/StencilMask.mjs
var StencilMask;
var init_StencilMask = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mask/shared/StencilMask.mjs"() {
    init_Extensions();
    init_Container();
    init_addMaskBounds();
    init_addMaskLocalBounds();
    StencilMask = class {
      constructor(options) {
        this.priority = 0;
        this.pipe = "stencilMask";
        if (options?.mask) {
          this.init(options.mask);
        }
      }
      init(mask) {
        this.mask = mask;
        this.mask.includeInBuild = false;
        this.mask.measurable = false;
      }
      reset() {
        this.mask.measurable = true;
        this.mask.includeInBuild = true;
        this.mask = null;
      }
      addBounds(bounds, skipUpdateTransform) {
        addMaskBounds(this.mask, bounds, skipUpdateTransform);
      }
      addLocalBounds(bounds, localRoot) {
        addMaskLocalBounds(this.mask, bounds, localRoot);
      }
      containsPoint(point) {
        const mask = this.mask;
        if (mask.containsPoint) {
          return mask.containsPoint(point);
        }
        return false;
      }
      destroy() {
        this.reset();
      }
      static test(mask) {
        return mask instanceof Container;
      }
    };
    StencilMask.extension = ExtensionType.MaskEffect;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/init.mjs
var init_init5 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/init.mjs"() {
    init_Extensions();
    init_AlphaMask();
    init_ColorMask();
    init_StencilMask();
    extensions.add(AlphaMask, ColorMask, StencilMask);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/all.mjs
var all_exports = {};
var init_all = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/all.mjs"() {
    init_init();
    init_init2();
    init_init3();
    init_init4();
    init_init5();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs
var BindGroup;
var init_BindGroup = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs"() {
    BindGroup = class {
      constructor(resources) {
        this.usageTick = 0;
        this.dirty = true;
        this.resources = {};
        let index = 0;
        for (const i in resources) {
          const resource = resources[i];
          this.setResource(resource, index++);
        }
        this.updateKey();
      }
      update() {
        this.updateKey();
      }
      updateKey() {
        if (!this.dirty)
          return;
        this.dirty = false;
        const keyParts = [];
        let index = 0;
        for (const i in this.resources) {
          keyParts[index++] = this.resources[i].resourceId;
        }
        this.key = keyParts.join("|");
      }
      setResource(resource, index) {
        const currentResource = this.resources[index];
        if (resource === currentResource)
          return;
        if (currentResource) {
          resource.off?.("change", this.onResourceChange, this);
        }
        resource.on?.("change", this.onResourceChange, this);
        this.resources[index] = resource;
        this.dirty = true;
      }
      getResource(index) {
        return this.resources[index];
      }
      destroy() {
        const resources = this.resources;
        for (const i in resources) {
          const resource = resources[i];
          resource.off?.("change", this.onResourceChange, this);
        }
        this.resources = null;
      }
      onResourceChange() {
        this.dirty = true;
        this.update();
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs
var Shader;
var init_Shader = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs"() {
    init_eventemitter3();
    init_BindGroup();
    Shader = class extends eventemitter3_default {
      constructor({ gpuProgram, glProgram, groups, resources, groupMap }) {
        super();
        this.uniformBindMap = {};
        this.gpuProgram = gpuProgram;
        this.glProgram = glProgram;
        const nameHash = {};
        if (resources && groups) {
          throw new Error("[Shader] Cannot have both resources and groups");
        } else if (!resources && !groups) {
          throw new Error("[Shader] Must provide either resources or groups descriptor");
        } else if (!gpuProgram && groups && !groupMap) {
          throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
        } else if (!gpuProgram && groups && groupMap) {
          for (const i in groupMap) {
            for (const j2 in groupMap[i]) {
              const uniformName = groupMap[i][j2];
              nameHash[uniformName] = {
                group: i,
                binding: j2,
                name: uniformName
              };
            }
          }
        } else if (gpuProgram && groups && !groupMap) {
          const groupData = gpuProgram.structsAndGroups.groups;
          groupMap = {};
          groupData.forEach((data) => {
            groupMap[data.group] = groupMap[data.group] || {};
            groupMap[data.group][data.binding] = data.name;
            nameHash[data.name] = data;
          });
        } else if (resources) {
          if (!gpuProgram) {
            groupMap = {};
            groups = {
              99: new BindGroup()
            };
            let bindTick = 0;
            for (const i in resources) {
              nameHash[i] = { group: 99, binding: bindTick, name: i };
              groups[99].setResource(resources[i], bindTick);
              groupMap[99] = groupMap[99] || {};
              groupMap[99][bindTick] = i;
              bindTick++;
            }
          } else {
            const groupData = gpuProgram.structsAndGroups.groups;
            groupMap = {};
            groupData.forEach((data) => {
              groupMap[data.group] = groupMap[data.group] || {};
              groupMap[data.group][data.binding] = data.name;
              nameHash[data.name] = data;
            });
          }
          groups = {};
          for (const i in resources) {
            const name = i;
            const value = resources[i];
            const data = nameHash[name];
            if (data) {
              groups[data.group] = groups[data.group] || new BindGroup();
              groups[data.group].setResource(value, data.binding);
            }
          }
        }
        this.groups = groups;
        this.uniformBindMap = groupMap;
        this.resources = this._buildResourceAccessor(groups, nameHash);
      }
      _buildResourceAccessor(groups, nameHash) {
        const uniformsOut = {};
        for (const i in nameHash) {
          const data = nameHash[i];
          Object.defineProperty(uniformsOut, data.name, {
            get() {
              return groups[data.group].getResource(data.binding);
            },
            set(value) {
              groups[data.group].setResource(value, data.binding);
            }
          });
        }
        return uniformsOut;
      }
      destroy(destroyProgram = false) {
        this.emit("destroy", this);
        if (destroyProgram) {
          this.gpuProgram?.destroy();
          this.glProgram?.destroy();
        }
        this.gpuProgram = null;
        this.glProgram = null;
        this.groups = null;
        this.removeAllListeners();
        this.uniformBindMap = null;
        this.resources = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/shared/const.mjs
var MAX_TEXTURES;
var init_const3 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/shared/const.mjs"() {
    MAX_TEXTURES = 16;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gpu/batcher-template.mjs
var programSrc;
var init_batcher_template = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gpu/batcher-template.mjs"() {
    programSrc = "struct GlobalUniforms {\n  projectionMatrix:mat3x3<f32>,\n  worldTransformMatrix:mat3x3<f32>,\n  worldAlpha: f32\n}\n\n@group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) color : vec4<f32>,\n    @location(2) @interpolate(flat) textureId : u32,\n  };\n\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n  @location(1) aUV : vec2<f32>,\n  @location(2) aColor : vec4<f32>,\n  @location(3) aTexture : f32,\n) -> VSOutput {\n\n  var  mvpMatrix = globalUniforms.projectionMatrix * globalUniforms.worldTransformMatrix;\n\n  var  colorOut = aColor;\n\n  var alpha = vec4<f32>(\n    colorOut.a * globalUniforms.worldAlpha,\n    colorOut.a * globalUniforms.worldAlpha,\n    colorOut.a * globalUniforms.worldAlpha,\n    globalUniforms.worldAlpha\n  );\n\n  colorOut *= alpha;\n\n\n  return VSOutput(\n    vec4<f32>((mvpMatrix * vec3<f32>(aPosition, 1.0)).xy, 0.0, 1.0),\n    aUV,\n    colorOut,\n    u32(aTexture)\n  );\n};\n\n%bindings%\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) color:vec4<f32>,\n  @location(2) @interpolate(flat) textureId: u32,\n) -> @location(0) vec4<f32> {\n\n\n    var uvDx = dpdx(uv);\n    var uvDy = dpdy(uv);\n\n    var outColor:vec4<f32>;\n    \n    %forloop%\n  \n    // multiply the alpha!\n    outColor.r *= outColor.a;\n    outColor.g *= outColor.a;\n    outColor.b *= outColor.a;\n\n    return (outColor) * color;\n};\n";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/extractStructAndGroups.mjs
function extractStructAndGroups(wgsl) {
  const linePattern = /(?<!\/\/.*)@(group|binding)\(\d+\)[^;]+;/g;
  const groupPattern = /@group\((\d+)\)/;
  const bindingPattern = /@binding\((\d+)\)/;
  const namePattern = /var(<[^>]+>)? (\w+)/;
  const typePattern = /:\s*(\w+)/;
  const structPattern = /struct\s+(\w+)\s*{([^}]+)}/g;
  const structMemberPattern = /(\w+)\s*:\s*([\w\<\>]+)/g;
  const structName = /struct\s+(\w+)/;
  const groups = wgsl.match(linePattern)?.map((item) => ({
    group: parseInt(item.match(groupPattern)[1], 10),
    binding: parseInt(item.match(bindingPattern)[1], 10),
    name: item.match(namePattern)[2],
    isUniform: item.match(namePattern)[1] === "<uniform>",
    type: item.match(typePattern)[1]
  }));
  if (!groups) {
    return {
      groups: [],
      structs: []
    };
  }
  const structs = wgsl.match(structPattern).map((struct) => {
    const name = struct.match(structName)[1];
    const members = struct.match(structMemberPattern).reduce((acc, member) => {
      const [name2, type] = member.split(":");
      acc[name2.trim()] = type.trim();
      return acc;
    }, {});
    return { name, members };
  }).filter(({ name }) => groups.some((group) => group.type === name));
  return {
    groups,
    structs
  };
}
var init_extractStructAndGroups = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/extractStructAndGroups.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs
var ShaderStage;
var init_const4 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs"() {
    ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {
      ShaderStage2[ShaderStage2["VERTEX"] = 1] = "VERTEX";
      ShaderStage2[ShaderStage2["FRAGMENT"] = 2] = "FRAGMENT";
      ShaderStage2[ShaderStage2["COMPUTE"] = 4] = "COMPUTE";
      return ShaderStage2;
    })(ShaderStage || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/generateGpuLayoutGroups.mjs
function generateGpuLayoutGroups({ groups }) {
  const layout = [];
  for (let i = 0; i < groups.length; i++) {
    const group = groups[i];
    if (!layout[group.group]) {
      layout[group.group] = [];
    }
    if (group.isUniform) {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,
        buffer: {
          type: "uniform"
        }
      });
    } else if (group.type === "sampler") {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.FRAGMENT,
        sampler: {
          type: "filtering"
        }
      });
    } else if (group.type === "texture_2d") {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.FRAGMENT,
        texture: {
          sampleType: "float",
          viewDimension: "2d",
          multisampled: false
        }
      });
    }
  }
  return layout;
}
var init_generateGpuLayoutGroups = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/generateGpuLayoutGroups.mjs"() {
    init_const4();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/generateLayoutHash.mjs
function generateLayoutHash({ groups }) {
  const layout = [];
  for (let i = 0; i < groups.length; i++) {
    const group = groups[i];
    if (!layout[group.group]) {
      layout[group.group] = {};
    }
    layout[group.group][group.name] = group.binding;
  }
  return layout;
}
var init_generateLayoutHash = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/generateLayoutHash.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs
var _GpuProgram, GpuProgram;
var init_GpuProgram = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs"() {
    init_extractStructAndGroups();
    init_generateGpuLayoutGroups();
    init_generateLayoutHash();
    _GpuProgram = class {
      constructor({ fragment: fragment2, vertex: vertex2, compute, layout, gpuLayout }) {
        this._layoutKey = 0;
        this.fragment = fragment2;
        this.vertex = vertex2;
        this.compute = compute;
        const structsAndGroups = extractStructAndGroups(this.fragment.source);
        this.structsAndGroups = structsAndGroups;
        this.layout = layout ?? generateLayoutHash(structsAndGroups);
        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(structsAndGroups);
      }
      destroy() {
        this._gpuLayout = null;
        this.gpuLayout = null;
        this.layout = null;
        this.structsAndGroups = null;
        this.fragment = null;
        this.vertex = null;
        this.compute = null;
      }
      static from(options) {
        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;
        if (!_GpuProgram.programCached[key]) {
          _GpuProgram.programCached[key] = new _GpuProgram(options);
        }
        return _GpuProgram.programCached[key];
      }
    };
    GpuProgram = _GpuProgram;
    GpuProgram.programCached = {};
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gpu/generateBatchProgram.mjs
function generateBatchProgram({ vertex: vertex2, fragment: fragment2, maxTextures }) {
  if (fragment2.source.indexOf("%bindings%") < 0) {
    throw new Error('Fragment template must contain "%bindings%".');
  }
  if (fragment2.source.indexOf("%forloop%") < 0) {
    throw new Error('Fragment template must contain "%forloop%".');
  }
  const bindingSrc = generateBindingSrc(maxTextures);
  const samplerSrc = generateSampleSrc(maxTextures);
  let fragmentSrc4 = fragment2.source;
  fragmentSrc4 = fragmentSrc4.replace(/%bindings%/gi, bindingSrc);
  fragmentSrc4 = fragmentSrc4.replace(/%forloop%/gi, samplerSrc);
  let vertexSrc4 = vertex2.source;
  if (vertexSrc4 === fragment2.source) {
    vertexSrc4 = fragmentSrc4;
  }
  const program = new GpuProgram({
    vertex: {
      source: vertexSrc4,
      entryPoint: vertex2.entryPoint
    },
    fragment: {
      source: fragmentSrc4,
      entryPoint: fragment2.entryPoint
    }
  });
  return program;
}
function generateSampleSrc(maxTextures) {
  const src = [];
  if (maxTextures === 1) {
    src.push("outColor = textureSampleGrad(textureSource1, textureSampler1, uv, uvDx, uvDy);");
  } else {
    src.push("switch textureId {");
    for (let i = 0; i < maxTextures; i++) {
      if (i === maxTextures - 1) {
        src.push(`  default:{`);
      } else {
        src.push(`  case ${i}:{`);
      }
      src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, uv, uvDx, uvDy);`);
      src.push(`      break;}`);
    }
    src.push(`}`);
  }
  return src.join("\n");
}
function generateBindingSrc(maxTextures) {
  const src = [];
  if (maxTextures === 1) {
    src.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;");
    src.push("@group(1) @binding(1) var textureSampler1: sampler;");
  } else {
    let bindingIndex = 0;
    for (let i = 0; i < maxTextures; i++) {
      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);
      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);
    }
  }
  return src.join("\n");
}
var init_generateBatchProgram = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gpu/generateBatchProgram.mjs"() {
    init_GpuProgram();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gpu/generateDefaultBatchProgram.mjs
function generateDefaultBatchProgram(maxTextures) {
  return generateBatchProgram({
    vertex: {
      source: programSrc,
      entryPoint: "mainVertex"
    },
    fragment: {
      source: programSrc,
      entryPoint: "mainFragment"
    },
    maxTextures
  });
}
var init_generateDefaultBatchProgram = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gpu/generateDefaultBatchProgram.mjs"() {
    init_batcher_template();
    init_generateBatchProgram();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs
function getTextureBatchBindGroup(textures) {
  const key = textures.map((t) => t.styleSourceKey).join("-");
  return cachedGroups[key] || generateTextureBatchBindGroup(textures, key);
}
function generateTextureBatchBindGroup(textures, key) {
  const bindGroupResources = {};
  let bindIndex = 0;
  for (let i = 0; i < MAX_TEXTURES; i++) {
    const texture = i < textures.length ? textures[i] : Texture.EMPTY.source;
    bindGroupResources[bindIndex++] = texture.source;
    bindGroupResources[bindIndex++] = texture.style;
  }
  const bindGroup = new BindGroup(bindGroupResources);
  cachedGroups[key] = bindGroup;
  return bindGroup;
}
var cachedGroups;
var init_getTextureBatchBindGroup = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs"() {
    init_BindGroup();
    init_Texture();
    init_const3();
    cachedGroups = {};
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs
var GpuBatchAdaptor;
var init_GpuBatchAdaptor = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs"() {
    init_Extensions();
    init_Shader();
    init_const3();
    init_generateDefaultBatchProgram();
    init_getTextureBatchBindGroup();
    GpuBatchAdaptor = class {
      init() {
        this.shader = new Shader({
          gpuProgram: generateDefaultBatchProgram(MAX_TEXTURES),
          groups: {
            // these will be dynamically allocated
          }
        });
      }
      execute(batchPipe, batch) {
        batchPipe.state.blendMode = batch.blendMode;
        if (!batch.textures.bindGroup) {
          batch.textures.bindGroup = getTextureBatchBindGroup(batch.textures.textures);
        }
        const program = this.shader.gpuProgram;
        const encoder = batchPipe.renderer.encoder;
        const globalUniformsBindGroup = batchPipe.renderer.globalUniforms.bindGroup;
        this.shader.groups[1] = batch.textures.bindGroup;
        const activeBatcher = batch.batchParent;
        encoder.setPipelineFromGeometryProgramAndState(
          activeBatcher.geometry,
          program,
          batchPipe.state
        );
        encoder.setGeometry(activeBatcher.geometry);
        encoder.setBindGroup(0, globalUniformsBindGroup, program);
        encoder.setBindGroup(1, batch.textures.bindGroup, program);
        encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
      }
      destroy() {
        this.shader.destroy(true);
        this.shader = null;
      }
    };
    GpuBatchAdaptor.extension = {
      type: [
        ExtensionType.WebGPUPipesAdaptor
      ],
      name: "batch"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/generateUID.mjs
function generateUID() {
  return uidCount++;
}
var uidCount;
var init_generateUID = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/generateUID.mjs"() {
    uidCount = 0;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs
var _UniformGroup, UniformGroup;
var init_UniformGroup = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"() {
    init_generateUID();
    _UniformGroup = class {
      constructor(uniformStructures, options) {
        this.uid = generateUID();
        this.resourceType = "uniformGroup";
        this.resourceId = this.uid;
        this.isUniformGroup = true;
        this.dirtyId = 0;
        options = { ..._UniformGroup.DEFAULT, ...options };
        this.uniformStructures = uniformStructures;
        const uniforms = {};
        for (const i in uniformStructures) {
          const uniformData = uniformStructures[i];
          uniformData.name = i;
          uniformData.size = uniformData.size ?? 1;
          uniforms[i] = uniformData.value ?? uniformData;
        }
        this.uniforms = uniforms;
        this.dirtyId = 1;
        this.ubo = options.ubo;
        this.isStatic = options.isStatic;
        this.signature = Object.keys(uniforms).map(
          (i) => `${i}-${uniformStructures[i].type}`
        ).join("-");
      }
      update() {
        this.dirtyId++;
      }
    };
    UniformGroup = _UniformGroup;
    UniformGroup.DEFAULT = {
      ubo: false,
      isStatic: false
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/gpu/colorToUniform.mjs
function color32BitToUniform(abgr, out2, offset) {
  out2[offset++] = (abgr & 255) / 255;
  out2[offset++] = (abgr >> 8 & 255) / 255;
  out2[offset++] = (abgr >> 16 & 255) / 255;
  out2[offset++] = (abgr >> 24 & 255) / 255;
}
var init_colorToUniform = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/gpu/colorToUniform.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/gpu/graphics-batcher-template.mjs
var programSrc2;
var init_graphics_batcher_template = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/gpu/graphics-batcher-template.mjs"() {
    programSrc2 = "struct GlobalUniforms {\n  projectionMatrix:mat3x3<f32>,\n  worldTransformMatrix:mat3x3<f32>,\n  worldAlpha: f32\n}\n\nstruct LocalUniforms {\n  color:vec4<f32>,\n  transformMatrix:mat3x3<f32>\n}\n\n\n@group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n%bindings%\n@group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) color : vec4<f32>,\n    @location(2) @interpolate(flat) textureId : u32,\n  };\n\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n  @location(1) aUV : vec2<f32>,\n  @location(2) aColor : vec4<f32>,\n  @location(3) aTexture : f32,\n) -> VSOutput {\n\n  var  mvpMatrix = globalUniforms.projectionMatrix * globalUniforms.worldTransformMatrix * localUniforms.transformMatrix;\n\n  var  colorOut = aColor * localUniforms.color.bgra;\n\n  var alpha = vec4<f32>(\n    colorOut.a * globalUniforms.worldAlpha,\n    colorOut.a * globalUniforms.worldAlpha,\n    colorOut.a * globalUniforms.worldAlpha,\n    globalUniforms.worldAlpha\n  );\n\n  colorOut *= alpha;\n\n\n  return VSOutput(\n    vec4<f32>((mvpMatrix * vec3<f32>(aPosition, 1.0)).xy, 0.0, 1.0),\n    aUV,\n    colorOut,\n    u32(aTexture)\n  );\n};\n\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) color:vec4<f32>,\n  @location(2) @interpolate(flat) textureId: u32,\n) -> @location(0) vec4<f32> {\n\n\n    var uvDx = dpdx(uv);\n    var uvDy = dpdy(uv);\n\n    var outColor:vec4<f32>;\n    \n    %forloop%\n  \n    // multiply the alpha!\n    outColor.r *= outColor.a;\n    outColor.g *= outColor.a;\n    outColor.b *= outColor.a;\n\n    return (outColor) * color; //* 0.1;\n};\n";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/gpu/generateDefaultGraphicsBatchProgram.mjs
function generateDefaultGraphicsBatchProgram(maxTextures) {
  return generateBatchProgram({
    vertex: {
      source: programSrc2,
      entryPoint: "mainVertex"
    },
    fragment: {
      source: programSrc2,
      entryPoint: "mainFragment"
    },
    maxTextures
  });
}
var init_generateDefaultGraphicsBatchProgram = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/gpu/generateDefaultGraphicsBatchProgram.mjs"() {
    init_generateBatchProgram();
    init_graphics_batcher_template();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/gpu/GpuGraphicsAdaptor.mjs
var GpuGraphicsAdaptor;
var init_GpuGraphicsAdaptor = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/gpu/GpuGraphicsAdaptor.mjs"() {
    init_Extensions();
    init_Matrix();
    init_const3();
    init_BindGroup();
    init_Shader();
    init_UniformGroup();
    init_colorToUniform();
    init_generateDefaultGraphicsBatchProgram();
    GpuGraphicsAdaptor = class {
      init() {
        const localUniforms = new UniformGroup({
          color: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          transformMatrix: { value: new Matrix(), type: "mat3x3<f32>" }
        });
        this.shader = new Shader({
          gpuProgram: generateDefaultGraphicsBatchProgram(MAX_TEXTURES),
          groups: {
            // added on the fly!
            2: new BindGroup({ 0: localUniforms })
          }
        });
      }
      execute(graphicsPipe, renderable) {
        const context = renderable.view.context;
        const shader = context.customShader || this.shader;
        const renderer = graphicsPipe.renderer;
        const contextSystem = renderer.graphicsContext;
        if (!contextSystem.getGpuContext(context).batches.length) {
          return;
        }
        const {
          geometry,
          batches
        } = contextSystem.getContextRenderData(context);
        graphicsPipe.state.blendMode = renderable.layerBlendMode;
        const localUniforms = shader.resources.localUniforms;
        shader.resources.localUniforms.uniforms.transformMatrix = renderable.layerTransform;
        color32BitToUniform(
          renderable.layerColor,
          localUniforms.uniforms.color,
          0
        );
        const encoder = renderer.encoder;
        encoder.setPipelineFromGeometryProgramAndState(
          geometry,
          shader.gpuProgram,
          graphicsPipe.state
        );
        encoder.setGeometry(geometry);
        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
        encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);
        const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);
        encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);
        for (let i = 0; i < batches.length; i++) {
          const batch = batches[i];
          shader.groups[1] = batch.textures.bindGroup;
          encoder.setBindGroup(1, batch.textures.bindGroup, shader.gpuProgram);
          encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
        }
      }
      destroy() {
        this.shader.destroy(true);
        this.shader = null;
      }
    };
    GpuGraphicsAdaptor.extension = {
      type: [
        ExtensionType.WebGPUPipesAdaptor
      ],
      name: "graphics"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mesh/gpu/GpuMeshAdapter.mjs
var GpuMeshAdapter;
var init_GpuMeshAdapter = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mesh/gpu/GpuMeshAdapter.mjs"() {
    init_Extensions();
    init_colorToUniform();
    GpuMeshAdapter = class {
      execute(meshPipe, renderable) {
        const renderer = meshPipe.renderer;
        const view = renderable.view;
        const state = meshPipe.state;
        state.blendMode = renderable.layerBlendMode;
        const localUniforms = meshPipe.localUniforms;
        localUniforms.uniforms.transformMatrix = renderable.layerTransform;
        localUniforms.update();
        color32BitToUniform(
          renderable.layerColor,
          localUniforms.uniforms.color,
          0
        );
        let shader = view._shader;
        if (!shader) {
          shader = meshPipe.meshShader;
          shader.groups[2] = renderer.texture.getTextureBindGroup(view.texture);
        }
        shader.groups[0] = renderer.globalUniforms.bindGroup;
        shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);
        renderer.encoder.draw({
          geometry: view._geometry,
          shader,
          state
        });
      }
    };
    GpuMeshAdapter.extension = {
      type: [
        ExtensionType.WebGPUPipesAdaptor
      ],
      name: "mesh"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/logging/deprecation.mjs
function deprecation(version, message, ignoreDepth = 3) {
  if (warnings[message]) {
    return;
  }
  let stack = new Error().stack;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (console.groupCollapsed) {
      console.groupCollapsed(
        "%cPixiJS Deprecation Warning: %c%s",
        "color:#614108;background:#fffbe6",
        "font-weight:normal;color:#614108;background:#fffbe6",
        `${message}
Deprecated since v${version}`
      );
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
      console.warn(stack);
    }
  }
  warnings[message] = true;
}
var warnings;
var init_deprecation = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/logging/deprecation.mjs"() {
    warnings = {};
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs
var SystemRunner;
var init_SystemRunner = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs"() {
    SystemRunner = class {
      /**
       * @param name - The function name that will be executed on the listeners added to this Runner.
       */
      constructor(name) {
        this.items = [];
        this._name = name;
      }
      /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */
      /**
       * Dispatch/Broadcast Runner to all listeners added to the queue.
       * @param {...any} params - (optional) parameters to pass to each listener
       */
      /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */
      emit(a0, a1, a2, a3, a4, a5, a6, a7) {
        const { name, items } = this;
        for (let i = 0, len = items.length; i < len; i++) {
          items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);
        }
        return this;
      }
      /**
       * Add a listener to the Runner
       *
       * Runners do not need to have scope or functions passed to them.
       * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
       * as the name provided to the Runner when it was created.
       *
       * Eg A listener passed to this Runner will require a 'complete' function.
       *
       * ```
       * import { Runner } from '@pixi/runner';
       *
       * const complete = new Runner('complete');
       * ```
       *
       * The scope used will be the object itself.
       * @param {any} item - The object that will be listening.
       */
      add(item) {
        if (item[this._name]) {
          this.remove(item);
          this.items.push(item);
        }
        return this;
      }
      /**
       * Remove a single listener from the dispatch queue.
       * @param {any} item - The listener that you would like to remove.
       */
      remove(item) {
        const index = this.items.indexOf(item);
        if (index !== -1) {
          this.items.splice(index, 1);
        }
        return this;
      }
      /**
       * Check to see if the listener is already in the Runner
       * @param {any} item - The listener that you would like to check.
       */
      contains(item) {
        return this.items.indexOf(item) !== -1;
      }
      /** Remove all listeners from the Runner */
      removeAll() {
        this.items.length = 0;
        return this;
      }
      /** Remove all references, don't use after this. */
      destroy() {
        this.removeAll();
        this.items = null;
        this._name = null;
      }
      /**
       * `true` if there are no this Runner contains no listeners
       * @readonly
       */
      get empty() {
        return this.items.length === 0;
      }
      /**
       * The name of the runner.
       * @readonly
       */
      get name() {
        return this._name;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs
var defaultRunners, AbstractRenderer;
var init_AbstractRenderer = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs"() {
    init_deprecation();
    init_Container();
    init_SystemRunner();
    defaultRunners = [
      "init",
      "destroy",
      "contextChange",
      "reset",
      "renderEnd",
      "renderStart",
      "render",
      "update",
      "postrender",
      "prerender"
    ];
    AbstractRenderer = class {
      /**
       * Set up a system with a collection of SystemClasses and runners.
       * Systems are attached dynamically to this class when added.
       * @param config - the config for the system manager
       */
      constructor(config) {
        this.runners = {};
        this.renderPipes = {};
        this._systemsHash = {};
        this.type = config.type;
        const combinedRunners = [...defaultRunners, ...config.runners ?? []];
        this.addRunners(...combinedRunners);
        this.addSystems(config.systems);
        this.addPipes(config.renderPipes, config.renderPipeAdaptors);
      }
      /**
       * Initialize the renderer.
       * @param options - The options to use to create the renderer.
       */
      async init(options = {}) {
        for (const systemName in this._systemsHash) {
          const system = this._systemsHash[systemName];
          const defaultSystemOptions = system.constructor.defaultOptions;
          options = { ...defaultSystemOptions, ...options };
        }
        for (let i = 0; i < this.runners.init.items.length; i++) {
          await this.runners.init.items[i].init(options);
        }
      }
      /**
       * Renders the object to its view.
       * @param options - The options to render with.
       * @param options.container - The container to render.
       * @param [options.target] - The target to render to.
       */
      render(options) {
        if (options instanceof Container) {
          deprecation("8", "passing Container as argument is deprecated, please use render options instead");
          options = { container: options, target: arguments[1] };
        }
        options.target = options.target || this.view.texture;
        this._lastObjectRendered = options.container;
        this.runners.prerender.emit(options);
        this.runners.renderStart.emit(options);
        this.runners.render.emit(options);
        this.runners.renderEnd.emit(options);
        this.runners.postrender.emit(options);
      }
      /**
       * Resizes the WebGL view to the specified width and height.
       * @param desiredScreenWidth - The desired width of the screen.
       * @param desiredScreenHeight - The desired height of the screen.
       * @param resolution - The resolution / device pixel ratio of the renderer.
       */
      resize(desiredScreenWidth, desiredScreenHeight, resolution) {
        this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);
      }
      /** The resolution / device pixel ratio of the renderer. */
      get resolution() {
        return this.view.resolution;
      }
      set resolution(value) {
        this.view.resolution = value;
      }
      get width() {
        return this.view.texture.frameWidth;
      }
      get height() {
        return this.view.texture.frameHeight;
      }
      // NOTE: this was `view` in v7
      /** The canvas element that everything is drawn to.*/
      get element() {
        return this.view.element;
      }
      /**
       * the last object rendered by the renderer. Useful for other plugins like interaction managers
       * @readonly
       */
      get lastObjectRendered() {
        return this._lastObjectRendered;
      }
      /**
       * Flag if we are rendering to the screen vs renderTexture
       * @readonly
       * @default true
       */
      get renderingToScreen() {
        const renderer = this;
        return renderer.renderTarget.renderingToScreen;
      }
      /**
       * Create a bunch of runners based of a collection of ids
       * @param runnerIds - the runner ids to add
       */
      addRunners(...runnerIds) {
        runnerIds.forEach((runnerId) => {
          this.runners[runnerId] = new SystemRunner(runnerId);
        });
      }
      addSystems(systems3) {
        let i;
        for (i in systems3) {
          const val = systems3[i];
          this.addSystem(val.value, val.name);
        }
      }
      /**
       * Add a new system to the renderer.
       * @param ClassRef - Class reference
       * @param name - Property name for system, if not specified
       *        will use a static `name` property on the class itself. This
       *        name will be assigned as s property on the Renderer so make
       *        sure it doesn't collide with properties on Renderer.
       * @returns Return instance of renderer
       */
      addSystem(ClassRef, name) {
        const system = new ClassRef(this);
        if (this[name]) {
          throw new Error(`Whoops! The name "${name}" is already in use`);
        }
        this[name] = system;
        this._systemsHash[name] = system;
        for (const i in this.runners) {
          this.runners[i].add(system);
        }
        return this;
      }
      addPipes(pipes, pipeAdaptors) {
        const adaptors = pipeAdaptors.reduce((acc, adaptor) => {
          acc[adaptor.name] = adaptor.value;
          return acc;
        }, {});
        pipes.forEach((pipe) => {
          const PipeClass = pipe.value;
          const name = pipe.name;
          const Adaptor = adaptors[name];
          this.renderPipes[name] = new PipeClass(
            this,
            Adaptor ? new Adaptor() : null
          );
        });
      }
      /** destroy the all runners and systems. Its apps job to */
      destroy() {
        Object.values(this.runners).forEach((runner) => {
          runner.destroy();
        });
        this._systemsHash = null;
        this.renderPipes = null;
        this.runners = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mesh/shared/MeshView.mjs
var UID9, tempPolygon, MeshView;
var init_MeshView = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mesh/shared/MeshView.mjs"() {
    init_Polygon();
    init_View();
    UID9 = 0;
    tempPolygon = new Polygon();
    MeshView = class {
      constructor(options) {
        this.uid = UID9++;
        this.type = "mesh";
        this.canBundle = true;
        this.owner = emptyViewObserver;
        this.shader = options.shader;
        if (options.texture) {
          this.texture = options.texture;
        }
        this._geometry = options.geometry;
        this._geometry.on("update", this.onGeometryUpdate, this);
      }
      set shader(value) {
        if (this._shader === value)
          return;
        this._shader = value;
        this.onUpdate();
      }
      get shader() {
        return this._shader;
      }
      set geometry(value) {
        if (this._geometry === value)
          return;
        this._geometry?.off("update", this.onUpdate, this);
        value.on("update", this.onUpdate, this);
        this._geometry = value;
        this.onUpdate();
      }
      get geometry() {
        return this._geometry;
      }
      set texture(value) {
        if (this._texture === value)
          return;
        if (this.shader) {
          this.shader.resources.uTexture = value.source;
          this.shader.resources.uSampler = value.style;
        }
        this._texture = value;
        this.onUpdate();
      }
      get texture() {
        return this._texture;
      }
      addBounds(bounds) {
        bounds.addVertexData(this.geometry.positions, 0, this.geometry.positions.length);
      }
      containsPoint(point) {
        const { x: x2, y } = point;
        const vertices = this.geometry.getBuffer("aPosition").data;
        const points = tempPolygon.points;
        const indices = this.geometry.getIndex().data;
        const len = indices.length;
        const step = this.geometry.topology === "triangle-strip" ? 3 : 1;
        for (let i = 0; i + 2 < len; i += step) {
          const ind0 = indices[i] * 2;
          const ind1 = indices[i + 1] * 2;
          const ind2 = indices[i + 2] * 2;
          points[0] = vertices[ind0];
          points[1] = vertices[ind0 + 1];
          points[2] = vertices[ind1];
          points[3] = vertices[ind1 + 1];
          points[4] = vertices[ind2];
          points[5] = vertices[ind2 + 1];
          if (tempPolygon.contains(x2, y)) {
            return true;
          }
        }
        return false;
      }
      get batched() {
        if (this._shader)
          return false;
        if (this._geometry.batchMode === "auto") {
          return this._geometry.positions.length / 2 <= 100;
        }
        return this._geometry.batchMode === "batch";
      }
      /**
       * Destroys this sprite renderable and optionally its texture.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
       * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
       */
      destroy(options = false) {
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          this._texture.destroy(destroyTextureSource);
        }
        this._texture = null;
        this._geometry = null;
        this._shader = null;
      }
      onGeometryUpdate() {
        this.onUpdate();
      }
      onUpdate() {
        this.owner.onViewUpdate();
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/ProxyRenderable.mjs
var ProxyRenderable;
var init_ProxyRenderable = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/ProxyRenderable.mjs"() {
    init_eventemitter3();
    init_Container();
    ProxyRenderable = class extends eventemitter3_default {
      constructor({ original, view }) {
        super();
        this.uid = getRenderableUID();
        this.didViewUpdate = false;
        this.view = view;
        if (original) {
          this.init(original);
        }
      }
      init(original) {
        this.original = original;
        this.layerTransform = original.layerTransform;
      }
      get layerColor() {
        return this.original.layerColor;
      }
      get layerBlendMode() {
        return this.original.layerBlendMode;
      }
      get layerVisibleRenderable() {
        return this.original.layerVisibleRenderable;
      }
      get isRenderable() {
        return this.original.isRenderable;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs
var UID10, Buffer2;
var init_Buffer = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs"() {
    init_eventemitter3();
    init_generateUID();
    UID10 = 0;
    Buffer2 = class extends eventemitter3_default {
      constructor({ data, size: size2, usage, label }) {
        super();
        this.resourceType = "buffer";
        this.resourceId = generateUID();
        this.uid = UID10++;
        this._updateID = 1;
        if (data instanceof Array) {
          data = new Float32Array(data);
        }
        this._data = data;
        size2 = size2 ?? data?.byteLength;
        const mappedAtCreation = !!data;
        this.descriptor = {
          size: size2,
          usage,
          mappedAtCreation,
          label
        };
      }
      get data() {
        return this._data;
      }
      set data(value) {
        if (this._data !== value) {
          const oldData = this._data;
          this._data = value;
          if (oldData.length !== value.length) {
            this.descriptor.size = value.byteLength;
            this.resourceId = generateUID();
            this.emit("change", this);
          } else {
            this.emit("update", this);
          }
        }
      }
      update(sizeInBytes) {
        this._updateSize = sizeInBytes || this.descriptor.size;
        this._updateID++;
        this.emit("update", this);
      }
      destroy() {
        this.emit("destroy", this);
        this._data = null;
        this.descriptor = null;
        this.removeAllListeners();
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs
var BufferUsage;
var init_const5 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs"() {
    BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {
      BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";
      BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";
      BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";
      BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";
      BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";
      BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";
      BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";
      BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";
      BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";
      BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";
      BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";
      return BufferUsage2;
    })(BufferUsage || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs
function ensureIsBuffer(buffer, index) {
  if (!(buffer instanceof Buffer2)) {
    let usage = index ? BufferUsage.INDEX : BufferUsage.VERTEX;
    if (buffer instanceof Array) {
      if (index) {
        buffer = new Uint32Array(buffer);
        usage = BufferUsage.INDEX | BufferUsage.COPY_DST;
      } else {
        buffer = new Float32Array(buffer);
        usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;
      }
    }
    buffer = new Buffer2({
      data: buffer,
      label: "index-mesh-buffer",
      usage
    });
  }
  return buffer;
}
var init_ensureIsBuffer = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs"() {
    init_Buffer();
    init_const5();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs
var UID11, Geometry;
var init_Geometry = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs"() {
    init_eventemitter3();
    init_ensureIsBuffer();
    UID11 = 1;
    Geometry = class extends eventemitter3_default {
      constructor({ attributes, indexBuffer, topology }) {
        super();
        this.uid = UID11++;
        this._layoutKey = 0;
        this.tick = 0;
        this.attributes = attributes;
        this.buffers = [];
        for (const i in attributes) {
          const attribute = attributes[i];
          attribute.buffer = ensureIsBuffer(attribute.buffer, false);
          const bufferIndex = this.buffers.indexOf(attribute.buffer);
          if (bufferIndex === -1) {
            this.buffers.push(attribute.buffer);
            attribute.buffer.on("update", this.onBufferUpdate, this);
          }
        }
        if (indexBuffer) {
          this.indexBuffer = ensureIsBuffer(indexBuffer, true);
          this.buffers.push(this.indexBuffer);
        }
        this.topology = topology || "triangle-list";
      }
      setBufferAtIndex(buffer, index) {
        const previousBuffer = this.buffers[index];
        previousBuffer.off("update", this.onBufferUpdate, this);
        buffer.on("update", this.onBufferUpdate, this);
        this.buffers[index] = buffer;
        for (const i in this.attributes) {
          const attribute = this.attributes[i];
          if (attribute.buffer === previousBuffer) {
            attribute.buffer = buffer;
          }
        }
      }
      onBufferUpdate() {
        this.tick = this.tick++;
        this.emit("update", this);
      }
      /**
       * Returns the requested attribute.
       * @param id - The name of the attribute required
       * @returns - The attribute requested.
       */
      getAttribute(id) {
        return this.attributes[id];
      }
      /**
       * Returns the index buffer
       * @returns - The index buffer.
       */
      getIndex() {
        return this.indexBuffer;
      }
      /**
       * Returns the requested buffer.
       * @param id - The name of the buffer required.
       * @returns - The buffer requested.
       */
      getBuffer(id) {
        return this.getAttribute(id).buffer;
      }
      getSize() {
        for (const i in this.attributes) {
          const attribute = this.attributes[i];
          const buffer = this.getBuffer(i);
          return buffer.data.length / (attribute.stride / 4 || attribute.size);
        }
        return 0;
      }
      destroy(destroyBuffers = false) {
        this.emit("destroy", this);
        this.removeAllListeners();
        if (destroyBuffers) {
          this.buffers.forEach((buffer) => buffer.destroy());
        }
        this.attributes = null;
        this.buffers = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mesh/shared/MeshGeometry.mjs
var _MeshGeometry, MeshGeometry;
var init_MeshGeometry = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mesh/shared/MeshGeometry.mjs"() {
    init_Buffer();
    init_const5();
    init_Geometry();
    _MeshGeometry = class extends Geometry {
      constructor(options = {}) {
        options = { ..._MeshGeometry.defaultOptions, ...options };
        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
        const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);
        const positionBuffer = new Buffer2({
          data: positions,
          label: "attribute-mesh-positions",
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
        });
        const uvBuffer = new Buffer2({
          data: uvs,
          label: "attribute-mesh-uvs",
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
        });
        const indexBuffer = new Buffer2({
          data: indices,
          label: "index-mesh-buffer",
          usage: BufferUsage.INDEX | BufferUsage.COPY_DST
        });
        super({
          attributes: {
            aPosition: {
              buffer: positionBuffer,
              shaderLocation: 0,
              format: "float32x2",
              stride: 2 * 4,
              offset: 0
            },
            aUV: {
              buffer: uvBuffer,
              shaderLocation: 1,
              format: "float32x2",
              stride: 2 * 4,
              offset: 0
            }
          },
          indexBuffer,
          topology: options.topology
        });
        this.batchMode = "auto";
      }
      get positions() {
        return this.attributes.aPosition.buffer.data;
      }
      set positions(value) {
        this.attributes.aPosition.buffer.data = value;
      }
      get uvs() {
        return this.attributes.aUV.buffer.data;
      }
      set uvs(value) {
        this.attributes.aUV.buffer.data = value;
      }
      get indices() {
        return this.indexBuffer.data;
      }
      set indices(value) {
        this.indexBuffer.data = value;
      }
    };
    MeshGeometry = _MeshGeometry;
    MeshGeometry.defaultOptions = {
      topology: "triangle-list"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/tiling-sprite/QuadGeometry.mjs
var QuadGeometry;
var init_QuadGeometry = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/tiling-sprite/QuadGeometry.mjs"() {
    init_MeshGeometry();
    QuadGeometry = class extends MeshGeometry {
      constructor() {
        super({
          positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
          uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
          indices: new Uint32Array([0, 1, 2, 0, 2, 3])
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensurePrecision.mjs
function ensurePrecision(src, { requestedPrecision, maxSupportedPrecision }) {
  if (src.substring(0, 9) !== "precision") {
    let precision = requestedPrecision;
    if (requestedPrecision === "highp" && maxSupportedPrecision !== "highp") {
      precision = "mediump";
    }
    if (src.substring(0, 8) !== "#version") {
      return `precision ${precision} float;
${src}`;
    }
    const firstLineBreak = src.indexOf("\n");
    return `${src.substring(0, firstLineBreak + 1)}precision ${precision} float;
${src.substring(firstLineBreak + 1)}`;
  } else if (maxSupportedPrecision !== "highp" && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}
var init_ensurePrecision = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensurePrecision.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/setProgramName.mjs
function setProgramName(src, { name = `pixi-program` }, isFragment = true) {
  name = name.replace(/\s+/g, "-");
  name += isFragment ? "-fragment" : "-vertex";
  const nameCache = isFragment ? fragmentNameCache : VertexNameCache;
  if (nameCache[name]) {
    nameCache[name]++;
    name += `-${nameCache[name]}`;
  } else {
    nameCache[name] = 1;
  }
  if (src.indexOf("#define SHADER_NAME") !== -1)
    return src;
  const shaderName = `#define SHADER_NAME ${name}`;
  if (src.substring(0, 8) !== "#version") {
    return `${shaderName}
${src}`;
  }
  const firstLineBreak = src.indexOf("\n");
  return `${src.substring(0, firstLineBreak + 1)}${shaderName}
${src.substring(firstLineBreak + 1)}`;
}
var fragmentNameCache, VertexNameCache;
var init_setProgramName = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/setProgramName.mjs"() {
    fragmentNameCache = {};
    VertexNameCache = {};
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/setProgramVersion.mjs
function setProgramVersion(src, { version = "300 es" }) {
  if (src.substring(0, 8) === "#version")
    return src;
  return `#version ${version}
${src}`;
}
var init_setProgramVersion = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/setProgramVersion.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs
var processes, _GlProgram, GlProgram;
var init_GlProgram = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs"() {
    init_ensurePrecision();
    init_setProgramName();
    init_setProgramVersion();
    processes = {
      ensurePrecision,
      setProgramName,
      setProgramVersion
    };
    _GlProgram = class {
      constructor({ fragment: fragment2, vertex: vertex2, name }) {
        const options = {
          ensurePrecision: {
            requestedPrecision: "highp",
            maxSupportedPrecision: "highp"
          },
          setProgramName: {
            name
          },
          setProgramVersion: {
            version: "300 es"
          }
        };
        Object.keys(processes).forEach((processKey) => {
          const processOptions = options[processKey] ?? {};
          fragment2 = processes[processKey](fragment2, processOptions, true);
          vertex2 = processes[processKey](vertex2, processOptions, false);
        });
        this.fragment = fragment2;
        this.vertex = vertex2;
        this.key = `${this.vertex}:${this.fragment}`;
      }
      destroy() {
        this.fragment = null;
        this.vertex = null;
        this.attributeData = null;
        this.uniformData = null;
        this.uniformBlockData = null;
        this.transformFeedbackVaryings = null;
      }
      static from(options) {
        const key = `${options.vertex}:${options.fragment}`;
        if (!_GlProgram.programCached[key]) {
          _GlProgram.programCached[key] = new _GlProgram(options);
        }
        return _GlProgram.programCached[key];
      }
    };
    GlProgram = _GlProgram;
    GlProgram.programCached = {};
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/tiling-sprite/shader/tiling-sprite.mjs
var programFrag;
var init_tiling_sprite = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/tiling-sprite/shader/tiling-sprite.mjs"() {
    programFrag = "precision lowp float;\n\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 outColor;\n\nuniform sampler2D uTexture;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uTexture, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    outColor = texSample * vColor;\n}\n";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/tiling-sprite/shader/tiling-sprite2.mjs
var programVert;
var init_tiling_sprite2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/tiling-sprite/shader/tiling-sprite2.mjs"() {
    programVert = "precision lowp float;\n\nin vec2 aPosition;\nin vec2 aUV;\n\nuniform globalUniforms {\n  mat3 projectionMatrix;\n  mat3 worldTransformMatrix;\n  float worldAlpha;\n};\n\n\nuniform mat3 transformMatrix;\nuniform vec4 color;\nuniform mat3 uTextureTransform;\nuniform vec4 uSizeAnchor;\n\nout vec2 vTextureCoord;\nout vec4 vColor;\n\nvoid main(void)\n{\n    vec2 modifiedPosition = (aPosition - uSizeAnchor.zw) * uSizeAnchor.xy;\n  \n    gl_Position = vec4((projectionMatrix * worldTransformMatrix * transformMatrix * vec3(modifiedPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n    vColor = color * worldAlpha;\n}\n";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/tiling-sprite/shader/tiling-sprite3.mjs
var programWgsl;
var init_tiling_sprite3 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/tiling-sprite/shader/tiling-sprite3.mjs"() {
    programWgsl = "struct GlobalUniforms {\nprojectionMatrix:mat3x3<f32>,\n  worldTransformMatrix:mat3x3<f32>,\n  worldAlpha: f32\n};\n\nstruct LocalUniforms {\n  transformMatrix:mat3x3<f32>,\n  color:vec4<f32>,\n};\n\nstruct TilingUniforms {\n  uMapCoord:mat3x3<f32>,\n  uClampFrame:vec4<f32>,\n  uClampOffset:vec2<f32>,\n  uTextureTransform:mat3x3<f32>,\n  uSizeAnchor:vec4<f32>\n};\n\n@group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n@group(1) @binding(0) var<uniform> localUniforms: LocalUniforms;\n\n@group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n@group(2) @binding(1) var uTexture: texture_2d<f32>;\n@group(2) @binding(2) var uSampler: sampler;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) color : vec4<f32>,\n  };\n\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n  @location(1) aUV : vec2<f32>,\n) -> VSOutput {\n\n    var modifiedPosition = (aPosition - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n  \n    var  mvpMatrix = globalUniforms.projectionMatrix * globalUniforms.worldTransformMatrix * localUniforms.transformMatrix;\n\n    var  colorOut = localUniforms.color;\n\n    colorOut.r *= colorOut.a;\n    colorOut.g *= colorOut.a;\n    colorOut.b *= colorOut.a;\n    \n  return VSOutput(\n    vec4<f32>((mvpMatrix * vec3<f32>(modifiedPosition, 1.0)).xy, 0.0, 1.0),\n    (tilingUniforms.uTextureTransform * vec3(aUV, 1.0)).xy,\n    colorOut,\n  );\n};\n\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) color:vec4<f32>,\n) -> @location(0) vec4<f32> {\n\n    var coord = uv + ceil(tilingUniforms.uClampOffset - uv);\n    coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n    var unclamped = coord;\n    coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n    var bias = 0.;\n\n    if(unclamped.x == coord.x && unclamped.y == coord.y)\n    {\n      bias = -32.;\n    } \n    \n\n    var finalColor = textureSampleBias(uTexture, uSampler, coord, bias);\n    \n   return finalColor * color;\n\n}";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/tiling-sprite/shader/TilingSpriteShader.mjs
var TilingSpriteShader;
var init_TilingSpriteShader = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/tiling-sprite/shader/TilingSpriteShader.mjs"() {
    init_Matrix();
    init_GlProgram();
    init_GpuProgram();
    init_Shader();
    init_UniformGroup();
    init_tiling_sprite();
    init_tiling_sprite2();
    init_tiling_sprite3();
    TilingSpriteShader = class extends Shader {
      constructor(options) {
        const glProgram = GlProgram.from({
          vertex: programVert,
          fragment: programFrag,
          name: "tiling-sprite"
        });
        const gpuProgram = GpuProgram.from({
          vertex: {
            source: programWgsl,
            entryPoint: "mainVertex"
          },
          fragment: {
            source: programWgsl,
            entryPoint: "mainFragment"
          }
        });
        const tilingUniforms = new UniformGroup({
          uMapCoord: { value: new Matrix(), type: "mat3x3<f32>" },
          uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },
          uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },
          uTextureTransform: { value: new Matrix(), type: "mat3x3<f32>" },
          uSizeAnchor: { value: new Float32Array([100, 200, 0.5, 0.5]), type: "vec4<f32>" }
        });
        super({
          glProgram,
          gpuProgram,
          resources: {
            tilingUniforms,
            uTexture: options.texture.source,
            uSampler: options.texture.style
          }
        });
      }
      get texture() {
        return this._texture;
      }
      set texture(value) {
        if (this._texture === value)
          return;
        this._texture = value;
        this.resources.uTexture = value.source;
        this.resources.uSampler = value.style;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/tiling-sprite/TilingSpritePipe.mjs
function applyMatrix(array, stride, offset, matrix) {
  let index = 0;
  const size2 = array.length / (stride || 2);
  const a = matrix.a;
  const b = matrix.b;
  const c = matrix.c;
  const d2 = matrix.d;
  const tx = matrix.tx;
  const ty = matrix.ty;
  offset *= stride;
  while (index < size2) {
    const x2 = array[offset];
    const y = array[offset + 1];
    array[offset] = a * x2 + c * y + tx;
    array[offset + 1] = b * x2 + d2 * y + ty;
    offset += stride;
    index++;
  }
}
var sharedQuad, TilingSpritePipe;
var init_TilingSpritePipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/tiling-sprite/TilingSpritePipe.mjs"() {
    init_Extensions();
    init_Matrix();
    init_MeshView();
    init_ProxyRenderable();
    init_QuadGeometry();
    init_TilingSpriteShader();
    sharedQuad = new QuadGeometry();
    TilingSpritePipe = class {
      constructor(renderer) {
        this.renderableHash = {};
        this.gpuBatchedTilingSprite = {};
        this.gpuTilingSprite = {};
        this.renderer = renderer;
      }
      validateRenderable(renderable) {
        const textureMatrix = renderable.view.texture.textureMatrix;
        let rebuild = false;
        const renderableData = this.getRenderableData(renderable);
        if (renderableData.batched !== textureMatrix.isSimple) {
          renderableData.batched = textureMatrix.isSimple;
          rebuild = true;
        }
        return rebuild;
      }
      addRenderable(renderable, instructionSet) {
        if (renderable.view.didUpdate) {
          renderable.view.didUpdate = false;
          this.rebuild(renderable);
        }
        const { batched } = this.getRenderableData(renderable);
        if (batched) {
          const batchableTilingSprite = this.getBatchedTilingSprite(renderable);
          this.renderer.renderPipes.mesh.addRenderable(batchableTilingSprite, instructionSet);
        } else {
          const gpuTilingSprite = this.getGpuTilingSprite(renderable);
          this.renderer.renderPipes.mesh.addRenderable(gpuTilingSprite.meshRenderable, instructionSet);
        }
      }
      updateRenderable(renderable) {
        if (renderable.view.didUpdate) {
          renderable.view.didUpdate = false;
          this.rebuild(renderable);
        }
        const { batched } = this.getRenderableData(renderable);
        if (batched) {
          const batchableTilingSprite = this.getBatchedTilingSprite(renderable);
          this.renderer.renderPipes.mesh.updateRenderable(batchableTilingSprite);
        } else {
          const gpuTilingSprite = this.getGpuTilingSprite(renderable);
          this.renderer.renderPipes.mesh.updateRenderable(gpuTilingSprite.meshRenderable);
        }
      }
      destroyRenderable(renderable) {
        this.renderableHash[renderable.uid] = null;
        this.gpuTilingSprite[renderable.uid] = null;
        this.gpuBatchedTilingSprite[renderable.uid] = null;
      }
      getRenderableData(renderable) {
        return this.renderableHash[renderable.uid] || this.initRenderableData(renderable);
      }
      initRenderableData(renderable) {
        const renderableData = {
          batched: true
        };
        this.renderableHash[renderable.uid] = renderableData;
        this.validateRenderable(renderable);
        renderable.on("destroyed", () => {
          this.destroyRenderable(renderable);
        });
        return renderableData;
      }
      rebuild(renderable) {
        const renderableData = this.getRenderableData(renderable);
        const view = renderable.view;
        const textureMatrix = view.texture.textureMatrix;
        if (renderableData.batched) {
          const batchedMesh = this.getBatchedTilingSprite(renderable);
          batchedMesh.view.texture = view.texture;
          view.texture.style.addressMode = "repeat";
          view.texture.style.update();
          this.updateBatchPositions(renderable);
          this.updateBatchUvs(renderable);
        } else {
          const gpuTilingSprite = this.getGpuTilingSprite(renderable);
          const { meshRenderable } = gpuTilingSprite;
          const meshView = meshRenderable.view;
          meshView.shader.texture = view.texture;
          const tilingUniforms = meshView.shader.resources.tilingUniforms;
          const originalWidth = view.width;
          const originalHeight = view.height;
          const tilingSpriteWidth = view.texture.width;
          const tilingSpriteHeight = view.texture.height;
          const matrix = view.tileTransform.matrix;
          const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;
          uTextureTransform.set(
            matrix.a * tilingSpriteWidth / originalWidth,
            matrix.b * tilingSpriteWidth / originalHeight,
            matrix.c * tilingSpriteHeight / originalWidth,
            matrix.d * tilingSpriteHeight / originalHeight,
            matrix.tx / originalWidth,
            matrix.ty / originalHeight
          );
          uTextureTransform.invert();
          tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;
          tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;
          tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;
          tilingUniforms.uniforms.uTextureTransform = uTextureTransform;
          tilingUniforms.uniforms.uSizeAnchor[0] = originalWidth;
          tilingUniforms.uniforms.uSizeAnchor[1] = originalHeight;
          tilingUniforms.uniforms.uSizeAnchor[2] = renderable.view.anchor.x;
          tilingUniforms.uniforms.uSizeAnchor[3] = renderable.view.anchor.y;
          tilingUniforms.update();
        }
      }
      getGpuTilingSprite(renderable) {
        return this.gpuTilingSprite[renderable.uid] || this.initGpuTilingSprite(renderable);
      }
      initGpuTilingSprite(renderable) {
        const view = renderable.view;
        view.texture.style.addressMode = "repeat";
        view.texture.style.update();
        const meshView = new MeshView({
          geometry: sharedQuad,
          shader: new TilingSpriteShader({
            texture: view.texture
          })
        });
        const meshRenderable = new ProxyRenderable({
          original: renderable,
          view: meshView
        });
        const textureMatrix = new Matrix();
        const gpuTilingSpriteData = {
          meshRenderable,
          textureMatrix
        };
        this.gpuTilingSprite[renderable.uid] = gpuTilingSpriteData;
        return gpuTilingSpriteData;
      }
      getBatchedTilingSprite(renderable) {
        return this.gpuBatchedTilingSprite[renderable.uid] || this.initBatchedTilingSprite(renderable);
      }
      initBatchedTilingSprite(renderable) {
        const meshView = new MeshView({
          geometry: new QuadGeometry(),
          texture: renderable.view.texture
        });
        const batchableMeshRenderable = new ProxyRenderable({
          original: renderable,
          view: meshView
        });
        this.gpuBatchedTilingSprite[renderable.uid] = batchableMeshRenderable;
        return batchableMeshRenderable;
      }
      updateBatchPositions(renderable) {
        const meshRenderable = this.getBatchedTilingSprite(renderable);
        const view = renderable.view;
        const positionBuffer = meshRenderable.view.geometry.getBuffer("aPosition");
        const positions = positionBuffer.data;
        const anchorX = view.anchor.x;
        const anchorY = view.anchor.y;
        positions[0] = -anchorX * view.width;
        positions[1] = -anchorY * view.height;
        positions[2] = (1 - anchorX) * view.width;
        positions[3] = -anchorY * view.height;
        positions[4] = (1 - anchorX) * view.width;
        positions[5] = (1 - anchorY) * view.height;
        positions[6] = -anchorX * view.width;
        positions[7] = (1 - anchorY) * view.height;
      }
      updateBatchUvs(renderable) {
        const view = renderable.view;
        const width = view.texture.frameWidth;
        const height = view.texture.frameHeight;
        const meshRenderable = this.getBatchedTilingSprite(renderable);
        const uvBuffer = meshRenderable.view.geometry.getBuffer("aUV");
        const uvs = uvBuffer.data;
        let anchorX = 0;
        let anchorY = 0;
        if (view.applyAnchorToTexture) {
          anchorX = view.anchor.x;
          anchorY = view.anchor.y;
        }
        uvs[0] = uvs[6] = -anchorX;
        uvs[2] = uvs[4] = 1 - anchorX;
        uvs[1] = uvs[3] = -anchorY;
        uvs[5] = uvs[7] = 1 - anchorY;
        const textureMatrix = Matrix.shared;
        textureMatrix.copyFrom(view.tileTransform.matrix);
        textureMatrix.tx /= view.width;
        textureMatrix.ty /= view.height;
        textureMatrix.invert();
        textureMatrix.scale(view.width / width, view.height / height);
        applyMatrix(uvs, 2, 0, textureMatrix);
      }
      destroy() {
        this.renderableHash = null;
        this.gpuTilingSprite = null;
        this.gpuBatchedTilingSprite = null;
        this.renderer = null;
      }
    };
    TilingSpritePipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "tilingSprite"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs
var blendModeIds, BLEND, OFFSET, CULLING, DEPTH_TEST, WINDING, DEPTH_MASK, State;
var init_State = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs"() {
    blendModeIds = {
      normal: 0,
      additive: 1,
      multiply: 2,
      screen: 3,
      overlay: 4
    };
    BLEND = 0;
    OFFSET = 1;
    CULLING = 2;
    DEPTH_TEST = 3;
    WINDING = 4;
    DEPTH_MASK = 5;
    State = class _State {
      constructor() {
        this.data = 0;
        this.blendMode = "normal";
        this.polygonOffset = 0;
        this.blend = true;
        this.depthMask = true;
      }
      /**
       * Activates blending of the computed fragment color values.
       * @default true
       */
      get blend() {
        return !!(this.data & 1 << BLEND);
      }
      set blend(value) {
        if (!!(this.data & 1 << BLEND) !== value) {
          this.data ^= 1 << BLEND;
        }
      }
      /**
       * Activates adding an offset to depth values of polygon's fragments
       * @default false
       */
      get offsets() {
        return !!(this.data & 1 << OFFSET);
      }
      set offsets(value) {
        if (!!(this.data & 1 << OFFSET) !== value) {
          this.data ^= 1 << OFFSET;
        }
      }
      set cullMode(value) {
        if (value === "none") {
          this.culling = false;
          return;
        }
        this.culling = true;
        this.clockwiseFrontFace = value === "front";
      }
      get cullMode() {
        if (!this.culling) {
          return "none";
        }
        return this.clockwiseFrontFace ? "front" : "back";
      }
      /**
       * Activates culling of polygons.
       * @default false
       */
      get culling() {
        return !!(this.data & 1 << CULLING);
      }
      set culling(value) {
        if (!!(this.data & 1 << CULLING) !== value) {
          this.data ^= 1 << CULLING;
        }
      }
      /**
       * Activates depth comparisons and updates to the depth buffer.
       * @default false
       */
      get depthTest() {
        return !!(this.data & 1 << DEPTH_TEST);
      }
      set depthTest(value) {
        if (!!(this.data & 1 << DEPTH_TEST) !== value) {
          this.data ^= 1 << DEPTH_TEST;
        }
      }
      /**
       * Enables or disables writing to the depth buffer.
       * @default true
       */
      get depthMask() {
        return !!(this.data & 1 << DEPTH_MASK);
      }
      set depthMask(value) {
        if (!!(this.data & 1 << DEPTH_MASK) !== value) {
          this.data ^= 1 << DEPTH_MASK;
        }
      }
      /**
       * Specifies whether or not front or back-facing polygons can be culled.
       * @default false
       */
      get clockwiseFrontFace() {
        return !!(this.data & 1 << WINDING);
      }
      set clockwiseFrontFace(value) {
        if (!!(this.data & 1 << WINDING) !== value) {
          this.data ^= 1 << WINDING;
        }
      }
      /**
       * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
       * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      get blendMode() {
        return this._blendMode;
      }
      set blendMode(value) {
        this.blend = value !== "none";
        this._blendMode = value;
        this._blendModeId = blendModeIds[value] || 0;
      }
      /**
       * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
       * @default 0
       */
      get polygonOffset() {
        return this._polygonOffset;
      }
      set polygonOffset(value) {
        this.offsets = !!value;
        this._polygonOffset = value;
      }
      toString() {
        return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
      }
      static for2d() {
        const state = new _State();
        state.depthTest = false;
        state.blend = true;
        return state;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gpu/getBatchedGeometry.mjs
function getBatchedGeometry() {
  const vertexSize = 6;
  const attributeBuffer = new Buffer2({
    data: placeHolderBufferData,
    label: "attribute-batch-buffer",
    usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
  });
  const indexBuffer = new Buffer2({
    data: placeHolderIndexData,
    label: "index-batch-buffer",
    usage: BufferUsage.INDEX | BufferUsage.COPY_DST
    // | BufferUsage.STATIC,
  });
  const stride = vertexSize * 4;
  const geometry = new Geometry({
    attributes: {
      aPosition: {
        buffer: attributeBuffer,
        shaderLocation: 0,
        format: "float32x2",
        stride,
        offset: 0
      },
      aUV: {
        buffer: attributeBuffer,
        shaderLocation: 1,
        format: "float32x2",
        stride,
        offset: 2 * 4
      },
      aColor: {
        buffer: attributeBuffer,
        shaderLocation: 2,
        format: "unorm8x4",
        stride,
        offset: 4 * 4
      },
      aTextureId: {
        buffer: attributeBuffer,
        shaderLocation: 3,
        format: "float32",
        stride,
        offset: 5 * 4
      }
    },
    indexBuffer
  });
  return geometry;
}
var placeHolderBufferData, placeHolderIndexData;
var init_getBatchedGeometry = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gpu/getBatchedGeometry.mjs"() {
    init_Buffer();
    init_const5();
    init_Geometry();
    placeHolderBufferData = new Float32Array(1);
    placeHolderIndexData = new Uint32Array(1);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/ViewableBuffer.mjs
var ViewableBuffer;
var init_ViewableBuffer = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/ViewableBuffer.mjs"() {
    ViewableBuffer = class {
      constructor(sizeOrBuffer) {
        if (typeof sizeOrBuffer === "number") {
          this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
        } else if (sizeOrBuffer instanceof Uint8Array) {
          this.rawBinaryData = sizeOrBuffer.buffer;
        } else {
          this.rawBinaryData = sizeOrBuffer;
        }
        this.uint32View = new Uint32Array(this.rawBinaryData);
        this.float32View = new Float32Array(this.rawBinaryData);
        this.size = this.rawBinaryData.byteLength;
      }
      /** View on the raw binary data as a `Int8Array`. */
      get int8View() {
        if (!this._int8View) {
          this._int8View = new Int8Array(this.rawBinaryData);
        }
        return this._int8View;
      }
      /** View on the raw binary data as a `Uint8Array`. */
      get uint8View() {
        if (!this._uint8View) {
          this._uint8View = new Uint8Array(this.rawBinaryData);
        }
        return this._uint8View;
      }
      /**  View on the raw binary data as a `Int16Array`. */
      get int16View() {
        if (!this._int16View) {
          this._int16View = new Int16Array(this.rawBinaryData);
        }
        return this._int16View;
      }
      /** View on the raw binary data as a `Int32Array`. */
      get int32View() {
        if (!this._int32View) {
          this._int32View = new Int32Array(this.rawBinaryData);
        }
        return this._int32View;
      }
      get float64View() {
        if (!this._float64Array) {
          this._float64Array = new Float64Array(this.rawBinaryData);
        }
        return this._float64Array;
      }
      get bigUint64View() {
        if (!this._bigUint64Array) {
          this._bigUint64Array = new BigUint64Array(this.rawBinaryData);
        }
        return this._bigUint64Array;
      }
      /**
       * Returns the view of the given type.
       * @param type - One of `int8`, `uint8`, `int16`,
       *    `uint16`, `int32`, `uint32`, and `float32`.
       * @returns - typed array of given type
       */
      view(type) {
        return this[`${type}View`];
      }
      /** Destroys all buffer references. Do not use after calling this. */
      destroy() {
        this.rawBinaryData = null;
        this._int8View = null;
        this._uint8View = null;
        this._int16View = null;
        this.uint16View = null;
        this._int32View = null;
        this.uint32View = null;
        this.float32View = null;
      }
      static sizeOf(type) {
        switch (type) {
          case "int8":
          case "uint8":
            return 1;
          case "int16":
          case "uint16":
            return 2;
          case "int32":
          case "uint32":
          case "float32":
            return 4;
          default:
            throw new Error(`${type} isn't a valid view type`);
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs
function fastCopy(sourceBuffer, destinationBuffer) {
  const lengthDouble = sourceBuffer.byteLength / 8 | 0;
  const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);
  const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);
  for (let i = 0; i < lengthDouble; i++) {
    destinationFloat64View[i] = sourceFloat64View[i];
  }
  const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8);
  const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8);
  for (let i = 0; i < sourceUint8View.length; i++) {
    destinationUint8View[i] = sourceUint8View[i];
  }
}
var init_fastCopy = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/shared/optimizeBindings.mjs
function optimizeBindings(previousTextureBatch, currentTextureBatch, tick, bindingOffset) {
  missingCount = 0;
  currentCount = 0;
  const boundTextureSize = 16;
  const prev = previousTextureBatch.textures;
  const next = currentTextureBatch.textures;
  const curr = currentCopy;
  for (let i = 0; i < next.length; i++) {
    curr[i] = next[i];
    currentCount++;
  }
  for (let i = 0; i < prev.length; i++) {
    next[i] = prev[i];
  }
  const batchLocations = currentTextureBatch.batchLocations;
  for (let i = 0; i < currentCount; i++) {
    const boundTexture = curr[i];
    let found = false;
    for (let j2 = 0; j2 < prev.length; j2++) {
      if (boundTexture === prev[j2]) {
        found = true;
        usedSlots[i] = tick;
        batchLocations[boundTexture.styleSourceKey] = j2;
        break;
      }
    }
    if (!found) {
      missing[missingCount++] = curr[i];
    }
  }
  for (let i = 0; i < missingCount; i++) {
    const missingTexture = missing[i];
    for (let j2 = 0; j2 < boundTextureSize; j2++) {
      const modJ = (j2 + bindingOffset) % 16;
      if (usedSlots[modJ] !== tick) {
        next[modJ] = missingTexture;
        usedSlots[modJ] = tick;
        batchLocations[missingTexture.styleSourceKey] = modJ;
        break;
      }
    }
  }
  return currentTextureBatch;
}
var missing, missingCount, currentCopy, currentCount, usedSlots;
var init_optimizeBindings = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/shared/optimizeBindings.mjs"() {
    missing = [];
    missingCount = 0;
    currentCopy = [];
    currentCount = 0;
    usedSlots = {};
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/shared/TextureBatcher.mjs
var batchPool, batchPoolIndex, TextureBatchOutput, TextureBatcher;
var init_TextureBatcher = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/shared/TextureBatcher.mjs"() {
    init_const3();
    init_optimizeBindings();
    batchPool = [];
    batchPoolIndex = 0;
    TextureBatchOutput = class {
      constructor() {
        this.textures = [];
        this.size = 0;
        this.batchLocations = {};
      }
    };
    TextureBatcher = class {
      constructor() {
        this.textureTicks = {};
        this.tick = 1e3;
      }
      begin() {
        batchPoolIndex = 0;
        this.bindingOffset = 0;
        this.reset();
      }
      reset() {
        this.tick++;
        this.output = batchPool[batchPoolIndex++] || new TextureBatchOutput();
        this.output.size = 0;
      }
      finish(previousBatch) {
        let output = this.output;
        if (previousBatch && previousBatch.textures.length && output.textures.length) {
          output = optimizeBindings(previousBatch, output, this.tick, this.bindingOffset++);
        }
        this.reset();
        return output;
      }
      add(texture) {
        const tick = this.tick;
        const textureTicks = this.textureTicks;
        if (textureTicks[texture.styleSourceKey] === tick)
          return true;
        const styleSourceKey = texture.styleSourceKey;
        const output = this.output;
        if (output.size === MAX_TEXTURES)
          return false;
        output.textures[output.size] = texture;
        textureTicks[styleSourceKey] = tick;
        output.batchLocations[styleSourceKey] = output.size++;
        batchPoolIndex = 0;
        return true;
      }
      destroy() {
        this.output = null;
        this.textureTicks = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs
var Batch, Batcher;
var init_Batcher = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs"() {
    init_ViewableBuffer();
    init_fastCopy();
    init_TextureBatcher();
    Batch = class {
      constructor() {
        this.type = "batch";
        this.action = "renderer";
        this.elementStart = 0;
        this.elementSize = 0;
        this.start = 0;
        this.size = 0;
        this.canBundle = true;
      }
      destroy() {
        this.textures = null;
        this.batchParent = null;
      }
    };
    Batcher = class {
      constructor(vertexSize = 4, indexSize = 6) {
        this.maxSize = 4096 * 20;
        this.dirty = true;
        this.batchIndex = 0;
        this.batches = [];
        this.vertexSize = 6;
        this.textureBatcher = new TextureBatcher();
        this.elements = [];
        this.attributeBuffer = new ViewableBuffer(vertexSize * this.vertexSize * 4);
        this.indexBuffer = new Uint32Array(indexSize);
      }
      begin() {
        this.batchIndex = 0;
        this.currentBlendMode = "inherit";
        let currentBatch = this.batches[this.batchIndex];
        if (!currentBatch) {
          currentBatch = this.batches[this.batchIndex] = new Batch();
        }
        currentBatch.elementSize = 0;
        currentBatch.start = 0;
        currentBatch.size = 0;
        this.attributeSize = 0;
        this.indexSize = 0;
        this.elementSize = 0;
        this.textureBatcher.begin();
        this.dirty = true;
      }
      add(batchableObject) {
        let batch = this.batches[this.batchIndex];
        const texture = batchableObject.texture;
        const blendMode = batchableObject.blendMode;
        if (this.currentBlendMode !== blendMode || batch.elementSize >= this.maxSize || !this.textureBatcher.add(texture)) {
          this.break(false);
          this.currentBlendMode = blendMode;
          batch = this.batches[this.batchIndex];
          batch.blendMode = blendMode;
          this.textureBatcher.add(texture);
        }
        batch.elementSize++;
        batchableObject.batcher = this;
        batchableObject.batch = batch;
        batchableObject.location = this.attributeSize;
        batchableObject.indexStart = this.indexSize;
        this.indexSize += batchableObject.indexSize;
        this.attributeSize += batchableObject.vertexSize * this.vertexSize;
        this.elements[this.elementSize++] = batchableObject;
      }
      checkAndUpdateTexture(batchableObject, texture) {
        const textureId = batchableObject.batch.textures.batchLocations[texture.styleSourceKey];
        if (textureId === void 0)
          return false;
        batchableObject.textureId = textureId;
        batchableObject.texture = texture;
        return true;
      }
      updateElement(batchableObject) {
        this.dirty = true;
        batchableObject.packAttributes(
          this.attributeBuffer.float32View,
          this.attributeBuffer.uint32View,
          batchableObject.location,
          batchableObject.textureId
        );
      }
      hideElement(element) {
        this.dirty = true;
        const buffer = this.attributeBuffer.float32View;
        let location = element.location;
        for (let i = 0; i < element.vertexSize; i++) {
          buffer[location] = 0;
          buffer[location + 1] = 0;
          location += 6;
        }
      }
      /**
       * breaks the batcher. This happens when a batch gets too big,
       * or we need to switch to a different type of rendering (a filter for example)
       * @param hardBreak - this breaks all the batch data and stops it from trying to optimise the textures
       */
      break(hardBreak) {
        if (this.elementSize === 0)
          return;
        let previousBatch;
        if (this.batchIndex > 0) {
          previousBatch = this.batches[this.batchIndex - 1];
        }
        if (this.attributeSize * 4 > this.attributeBuffer.size) {
          this._resizeAttributeBuffer(this.attributeSize * 4);
        }
        if (this.indexSize > this.indexBuffer.length) {
          this._resizeIndexBuffer(this.indexSize);
        }
        const currentBatch = this.batches[this.batchIndex];
        currentBatch.size = this.indexSize - currentBatch.start;
        if (!hardBreak && previousBatch) {
          currentBatch.textures = this.textureBatcher.finish(previousBatch.textures);
        } else {
          currentBatch.textures = this.textureBatcher.finish();
        }
        const size2 = this.elementSize - currentBatch.elementStart;
        for (let i = 0; i < size2; i++) {
          const batchableObject = this.elements[currentBatch.elementStart + i];
          batchableObject.textureId = currentBatch.textures.batchLocations[batchableObject.texture.styleSourceKey];
          batchableObject.packAttributes(
            this.attributeBuffer.float32View,
            this.attributeBuffer.uint32View,
            batchableObject.location,
            batchableObject.textureId
          );
          batchableObject.packIndex(
            this.indexBuffer,
            batchableObject.indexStart,
            batchableObject.location / this.vertexSize
          );
        }
        this.batchIndex++;
        let nextBatch = this.batches[this.batchIndex];
        if (!nextBatch) {
          nextBatch = this.batches[this.batchIndex] = new Batch();
        }
        nextBatch.blendMode = this.currentBlendMode;
        nextBatch.elementStart = this.elementSize;
        nextBatch.elementSize = 0;
        nextBatch.start = this.indexSize;
      }
      finish() {
        this.break(false);
        if (this.elementSize === 0)
          return;
        const currentBatch = this.batches[this.batchIndex];
        currentBatch.size = this.indexSize - currentBatch.start;
        if (this.batchIndex > 0) {
          const previousBatch = this.batches[this.batchIndex - 1];
          currentBatch.textures = this.textureBatcher.finish(previousBatch.textures);
          return;
        }
        currentBatch.textures = this.textureBatcher.finish();
      }
      update() {
      }
      ensureAttributeBuffer(size2) {
        if (size2 * 4 < this.attributeBuffer.size)
          return;
        this._resizeAttributeBuffer(size2 * 4);
      }
      ensureIndexBuffer(size2) {
        if (size2 < this.indexBuffer.length)
          return;
        this._resizeIndexBuffer(size2);
      }
      _resizeAttributeBuffer(size2) {
        const newSize = Math.max(size2, this.attributeBuffer.size * 2);
        const newArrayBuffer = new ViewableBuffer(newSize);
        fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);
        this.attributeBuffer = newArrayBuffer;
      }
      _resizeIndexBuffer(size2) {
        const indexBuffer = this.indexBuffer;
        const newSize = Math.max(size2, indexBuffer.length * 2);
        const newIndexBuffer = new Uint32Array(newSize);
        fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);
        this.indexBuffer = newIndexBuffer;
      }
      destroy() {
        for (let i = 0; i < this.batches.length; i++) {
          this.batches[i].destroy();
        }
        this.batches = null;
        for (let i = 0; i < this.elements.length; i++) {
          this.elements[i].batch = null;
        }
        this.elements = null;
        this.indexBuffer = null;
        this.attributeBuffer.destroy();
        this.attributeBuffer = null;
        this.textureBatcher.destroy();
        this.boundTextures = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs
var BatcherPipe;
var init_BatcherPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs"() {
    init_Extensions();
    init_State();
    init_getBatchedGeometry();
    init_Batcher();
    BatcherPipe = class {
      constructor(renderer, adaptor) {
        this.toUpdate = [];
        this.state = State.for2d();
        this._batches = {};
        this.renderer = renderer;
        this.adaptor = adaptor;
        this.adaptor.init();
      }
      buildStart(instructionSet) {
        this.lastBatch = 0;
        if (!this._batches[instructionSet.uid]) {
          this._batches[instructionSet.uid] = {
            batcher: new Batcher(),
            geometry: getBatchedGeometry()
          };
        }
        this._batches[instructionSet.uid].batcher.begin();
      }
      addToBatch(batchableObject, instructionSet) {
        this._batches[instructionSet.uid].batcher.add(batchableObject);
      }
      break(instructionSet) {
        const batcher = this._batches[instructionSet.uid].batcher;
        const hardBreak = instructionSet.instructionSize > 0 && instructionSet.lastInstruction().type !== "batch";
        batcher.break(hardBreak);
        while (this.lastBatch < batcher.batchIndex) {
          const batch = batcher.batches[this.lastBatch++];
          if (batch.elementSize !== 0) {
            batch.batchParent = this._batches[instructionSet.uid];
            instructionSet.instructions[instructionSet.instructionSize++] = batch;
          }
        }
      }
      buildEnd(instructionSet) {
        this.break(instructionSet);
        const { geometry, batcher } = this._batches[instructionSet.uid];
        if (batcher.elementSize === 0)
          return;
        batcher.finish();
        geometry.indexBuffer.data = batcher.indexBuffer;
        geometry.buffers[0].data = batcher.attributeBuffer.float32View;
        geometry.indexBuffer.update(batcher.indexSize * 4);
      }
      upload(instructionSet) {
        const activeBatcher = this._batches[instructionSet.uid];
        if (activeBatcher && activeBatcher.batcher.dirty) {
          activeBatcher.batcher.dirty = false;
          const attributeBuffer = activeBatcher.geometry.buffers[0];
          attributeBuffer.update(activeBatcher.batcher.attributeSize * 4);
          this.renderer.buffer.updateBuffer(attributeBuffer);
        }
      }
      execute(batch) {
        this.adaptor.execute(this, batch);
      }
      destroy() {
        this.toUpdate = null;
        this.instructionSet = null;
        this.activeBatcher = null;
        this.state = null;
        this._batches = null;
        this.renderer = null;
        this.adaptor.destroy();
        this.adaptor = null;
        for (const i in this._batches) {
          const batchData = this._batches[i];
          batchData.batcher.destroy();
          batchData.geometry.destroy();
        }
      }
    };
    BatcherPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "batch"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/shared/FilterPipe.mjs
var FilterPipe;
var init_FilterPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/shared/FilterPipe.mjs"() {
    init_Extensions();
    init_UniformGroup();
    FilterPipe = class {
      constructor(renderer) {
        this.filterGlobalUniforms = new UniformGroup({
          inputSize: { value: new Float32Array(4), type: "vec4<f32>" },
          inputPixel: { value: new Float32Array(4), type: "vec4<f32>" },
          inputClamp: { value: new Float32Array(4), type: "vec4<f32>" },
          outputFrame: { value: new Float32Array(4), type: "vec4<f32>" },
          backgroundFrame: { value: new Float32Array(4), type: "vec4<f32>" },
          globalFrame: { value: new Float32Array(4), type: "vec4<f32>" }
        });
        this.renderer = renderer;
      }
      push(filterEffect, container, instructionSet) {
        const renderPipes3 = this.renderer.renderPipes;
        renderPipes3.batch.break(instructionSet);
        instructionSet.add({
          type: "filter",
          canBundle: false,
          action: "pushFilter",
          container,
          filterEffect
        });
      }
      pop(_filterEffect, _container, instructionSet) {
        this.renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          type: "filter",
          action: "popFilter",
          canBundle: false
        });
      }
      execute(instruction) {
        if (instruction.action === "pushFilter") {
          this.renderer.filter.push(instruction);
        } else if (instruction.action === "popFilter") {
          this.renderer.filter.pop();
        }
      }
      destroy() {
        this.renderer = null;
        this.filterGlobalUniforms = null;
      }
    };
    FilterPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "filter"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/maths/pow2.mjs
function nextPow2(v2) {
  v2 += v2 === 0 ? 1 : 0;
  --v2;
  v2 |= v2 >>> 1;
  v2 |= v2 >>> 2;
  v2 |= v2 >>> 4;
  v2 |= v2 >>> 8;
  v2 |= v2 >>> 16;
  return v2 + 1;
}
var init_pow2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/maths/pow2.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs
var count, TexturePoolClass, TexturePool;
var init_TexturePool = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs"() {
    init_pow2();
    init_TextureSource();
    init_Texture();
    count = 0;
    TexturePoolClass = class {
      /**
       * @param textureOptions - options that will be passed to BaseRenderTexture constructor
       * @param {PIXI.SCALE_MODES} [textureOptions.scaleMode] - See {@link PIXI.SCALE_MODES} for possible values.
       */
      constructor(textureOptions) {
        this.poolKeyHash = {};
        this.texturePool = {};
        this.textureOptions = textureOptions || {};
        this.enableFullScreen = false;
      }
      /**
       * Creates texture with params that were specified in pool constructor.
       * @param pixelWidth - Width of texture in pixels.
       * @param pixelHeight - Height of texture in pixels.
       * @param antialias
       */
      createTexture(pixelWidth, pixelHeight, antialias) {
        const textureSource = new TextureSource({
          ...this.textureOptions,
          width: pixelWidth,
          height: pixelHeight,
          resolution: 1,
          antialias
        });
        return new Texture({
          source: textureSource,
          label: `texturePool_${count++}`
        });
      }
      /**
       * Gets a Power-of-Two render texture or fullScreen texture
       * @param frameWidth - The minimum width of the render texture.
       * @param frameHeight - The minimum height of the render texture.
       * @param resolution - The resolution of the render texture.
       * @param antialias
       * @returns The new render texture.
       */
      getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {
        let po2Width = Math.ceil(frameWidth * resolution - 1e-6);
        let po2Height = Math.ceil(frameHeight * resolution - 1e-6);
        po2Width = nextPow2(po2Width);
        po2Height = nextPow2(po2Height);
        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);
        if (!this.texturePool[key]) {
          this.texturePool[key] = [];
        }
        let texture = this.texturePool[key].pop();
        if (!texture) {
          texture = this.createTexture(po2Width, po2Height, antialias);
        }
        texture.source._resolution = resolution;
        texture.source.width = po2Width / resolution;
        texture.source.height = po2Height / resolution;
        texture.source.pixelWidth = po2Width;
        texture.source.pixelHeight = po2Height;
        texture.frameX = 0;
        texture.frameY = 0;
        texture.frameWidth = frameWidth;
        texture.frameHeight = frameHeight;
        texture.layout.update();
        this.poolKeyHash[texture.id] = key;
        return texture;
      }
      getSameSizeTexture(texture) {
        const source3 = texture.source;
        return this.getOptimalTexture(source3.width, source3.height, source3._resolution, source3.antialias);
      }
      /**
       * Place a render texture back into the pool.
       * @param renderTexture - The renderTexture to free
       */
      returnTexture(renderTexture) {
        const key = this.poolKeyHash[renderTexture.id];
        this.texturePool[key].push(renderTexture);
      }
      /**
       * Clears the pool.
       * @param destroyTextures - Destroy all stored textures.
       */
      clear(destroyTextures) {
        destroyTextures = destroyTextures !== false;
        if (destroyTextures) {
          for (const i in this.texturePool) {
            const textures = this.texturePool[i];
            if (textures) {
              for (let j2 = 0; j2 < textures.length; j2++) {
                textures[j2].destroy(true);
              }
            }
          }
        }
        this.texturePool = {};
      }
    };
    TexturePool = new TexturePoolClass();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/bounds/getRenderableBounds.mjs
function getGlobalRenderableBounds(renderables, bounds) {
  bounds.clear();
  const tempMatrix4 = bounds.matrix;
  for (let i = 0; i < renderables.length; i++) {
    const renderable = renderables[i];
    if (renderable.layerVisibleRenderable < 3) {
      continue;
    }
    bounds.matrix = renderable.worldTransform;
    renderable.view.addBounds(bounds);
  }
  bounds.matrix = tempMatrix4;
  return bounds;
}
var init_getRenderableBounds = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/bounds/getRenderableBounds.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/shared/FilterSystem.mjs
var quadGeometry, FilterSystem;
var init_FilterSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/shared/FilterSystem.mjs"() {
    init_Extensions();
    init_Matrix();
    init_Point();
    init_BindGroup();
    init_Geometry();
    init_UniformGroup();
    init_Texture();
    init_TexturePool();
    init_Bounds();
    init_getGlobalBounds();
    init_getRenderableBounds();
    quadGeometry = new Geometry({
      attributes: {
        aPosition: {
          buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
          shaderLocation: 0,
          format: "float32x2",
          stride: 2 * 4,
          offset: 0
        }
      },
      indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])
    });
    FilterSystem = class {
      constructor(renderer) {
        this.filterStackIndex = 0;
        this.filterStack = [];
        this.filterGlobalUniforms = new UniformGroup({
          inputSize: { value: new Float32Array(4), type: "vec4<f32>" },
          inputPixel: { value: new Float32Array(4), type: "vec4<f32>" },
          inputClamp: { value: new Float32Array(4), type: "vec4<f32>" },
          outputFrame: { value: new Float32Array(4), type: "vec4<f32>" },
          backgroundFrame: { value: new Float32Array(4), type: "vec4<f32>" },
          globalFrame: { value: new Float32Array(4), type: "vec4<f32>" }
        });
        this.globalFilterBindGroup = new BindGroup({});
        this.renderer = renderer;
      }
      push(instruction) {
        const renderer = this.renderer;
        const filters = instruction.filterEffect.filters;
        if (!this.filterStack[this.filterStackIndex]) {
          this.filterStack[this.filterStackIndex] = this.getFilterData();
        }
        const filterData = this.filterStack[this.filterStackIndex];
        this.filterStackIndex++;
        const bounds = filterData.bounds;
        if (instruction.renderables) {
          getGlobalRenderableBounds(instruction.renderables, bounds);
        } else {
          getGlobalBounds(instruction.container, true, bounds);
        }
        if (filters.length === 0) {
          filterData.skip = true;
          return;
        }
        let resolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;
        let padding = 0;
        let antialias = renderer.renderTarget.rootRenderTarget.colorTexture.source.antialias;
        let blendRequired = false;
        let enabled = false;
        for (let i = 0; i < filters.length; i++) {
          const filter = filters[i];
          resolution = Math.min(resolution, filter.resolution);
          padding += filter.padding;
          if (filter.antialias !== "inherit") {
            if (filter.antialias === "on") {
              antialias = true;
            } else {
              antialias = false;
            }
          }
          enabled = filter.enabled || enabled;
          blendRequired = blendRequired || filter.blendRequired;
        }
        if (!enabled) {
          filterData.skip = true;
          return;
        }
        bounds.scale(resolution).fit(renderer.renderTarget.rootRenderTarget.viewport).scale(1 / resolution).pad(padding).ceil();
        if (!bounds.isPositive) {
          filterData.skip = true;
          return;
        }
        filterData.skip = false;
        filterData.bounds = bounds;
        filterData.blendRequired = blendRequired;
        filterData.container = instruction.container;
        filterData.filterEffect = instruction.filterEffect;
        filterData.previousRenderSurface = renderer.renderTarget.renderTarget;
        filterData.inputTexture = TexturePool.getOptimalTexture(
          bounds.width,
          bounds.height,
          resolution,
          antialias
        );
        renderer.renderTarget.bind(filterData.inputTexture, true);
        renderer.globalUniforms.push({
          offset: bounds
        });
      }
      pop() {
        const renderer = this.renderer;
        this.filterStackIndex--;
        const filterData = this.filterStack[this.filterStackIndex];
        if (filterData.skip) {
          return;
        }
        this.activeFilterData = filterData;
        const inputTexture = filterData.inputTexture;
        const bounds = filterData.bounds;
        let backTexture = Texture.EMPTY;
        if (filterData.blendRequired) {
          renderer.encoder.finishRenderPass();
          backTexture = this.getBackTexture(filterData.previousRenderSurface, bounds);
        }
        const offset = Point.shared;
        if (this.filterStackIndex > 0) {
          offset.x = this.filterStack[this.filterStackIndex - 1].bounds.minX;
          offset.y = this.filterStack[this.filterStackIndex - 1].bounds.minY;
        }
        this.updateGlobalFilterUniforms(bounds, inputTexture, backTexture, offset);
        const filters = filterData.filterEffect.filters;
        this.filterGlobalUniforms.update();
        let globalUniforms = this.filterGlobalUniforms;
        if (renderer.renderPipes.uniformBatch) {
          globalUniforms = renderer.renderPipes.uniformBatch.getUniformBufferResource(this.filterGlobalUniforms);
        }
        this.globalFilterBindGroup.setResource(globalUniforms, 0);
        this.globalFilterBindGroup.setResource(inputTexture.style, 2);
        this.globalFilterBindGroup.setResource(backTexture.source, 3);
        if (filters.length === 1) {
          renderer.globalUniforms.pop();
          filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);
          TexturePool.returnTexture(inputTexture);
        } else {
          let flip = filterData.inputTexture;
          const outputFrame = this.filterGlobalUniforms.uniforms.outputFrame;
          const oX = outputFrame[0];
          const oY = outputFrame[1];
          outputFrame[0] = 0;
          outputFrame[1] = 0;
          this.filterGlobalUniforms.update();
          if (renderer.renderPipes.uniformBatch) {
            const globalUniforms2 = renderer.renderPipes.uniformBatch.getUniformBufferResource(this.filterGlobalUniforms);
            this.globalFilterBindGroup.setResource(globalUniforms2, 0);
          }
          let flop = TexturePool.getOptimalTexture(
            bounds.width,
            bounds.height,
            flip.source._resolution,
            false
          );
          let i = 0;
          for (i = 0; i < filters.length - 1; ++i) {
            const filter = filters[i];
            filter.apply(this, flip, flop, true);
            const t = flip;
            flip = flop;
            flop = t;
          }
          renderer.globalUniforms.pop();
          if (renderer.renderPipes.uniformBatch) {
            this.globalFilterBindGroup.setResource(globalUniforms, 0);
          } else {
            outputFrame[0] = oX;
            outputFrame[1] = oY;
            this.filterGlobalUniforms.update();
          }
          filters[i].apply(this, flip, filterData.previousRenderSurface, false);
          TexturePool.returnTexture(flip);
          TexturePool.returnTexture(flop);
        }
        if (filterData.blendRequired) {
          TexturePool.returnTexture(backTexture);
        }
      }
      updateGlobalFilterUniforms(bounds, texture, backTexture, offset) {
        const bx = bounds.minX;
        const by = bounds.minY;
        const uniforms = this.filterGlobalUniforms.uniforms;
        const outputFrame = uniforms.outputFrame;
        const inputSize = uniforms.inputSize;
        const inputPixel = uniforms.inputPixel;
        const inputClamp = uniforms.inputClamp;
        const backgroundFrame = uniforms.backgroundFrame;
        const globalFrame = uniforms.globalFrame;
        outputFrame[0] = bx - offset.x;
        outputFrame[1] = by - offset.y;
        outputFrame[2] = texture.frameWidth;
        outputFrame[3] = texture.frameHeight;
        inputSize[0] = texture.source.width;
        inputSize[1] = texture.source.height;
        inputSize[2] = 1 / inputSize[0];
        inputSize[3] = 1 / inputSize[1];
        inputPixel[0] = texture.source.pixelWidth;
        inputPixel[1] = texture.source.pixelHeight;
        inputPixel[2] = 1 / inputPixel[0];
        inputPixel[3] = 1 / inputPixel[1];
        inputClamp[0] = 0.5 * inputPixel[2];
        inputClamp[1] = 0.5 * inputPixel[3];
        inputClamp[2] = texture.frameWidth * inputSize[2] - 0.5 * inputPixel[2];
        inputClamp[3] = texture.frameHeight * inputSize[3] - 0.5 * inputPixel[3];
        backgroundFrame[0] = 0;
        backgroundFrame[1] = 0;
        backgroundFrame[2] = backTexture.layout.frame.width;
        backgroundFrame[3] = backTexture.layout.frame.height;
        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;
        if (this.filterStackIndex > 0) {
          resolution = this.filterStack[this.filterStackIndex - 1].inputTexture.source._resolution;
        }
        globalFrame[0] = offset.x * resolution;
        globalFrame[1] = offset.y * resolution;
        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;
        globalFrame[2] = rootTexture.source.width * resolution;
        globalFrame[3] = rootTexture.source.height * resolution;
      }
      getBackTexture(lastRenderSurface, bounds) {
        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;
        const backTexture = TexturePool.getOptimalTexture(
          bounds.width,
          bounds.height,
          backgroundResolution,
          false
        );
        let x2 = bounds.minX;
        let y = bounds.minY;
        if (this.filterStackIndex) {
          x2 -= this.filterStack[this.filterStackIndex - 1].bounds.minX;
          y -= this.filterStack[this.filterStackIndex - 1].bounds.minY;
        }
        x2 = Math.floor(x2 * backgroundResolution);
        y = Math.floor(y * backgroundResolution);
        const width = Math.ceil(bounds.width * backgroundResolution);
        const height = Math.ceil(bounds.height * backgroundResolution);
        this.renderer.renderTarget.copyToTexture(
          lastRenderSurface,
          backTexture,
          { x: x2, y },
          { width, height }
        );
        return backTexture;
      }
      applyFilter(filter, input, output, clear) {
        const renderer = this.renderer;
        renderer.renderTarget.bind(output, !!clear);
        this.globalFilterBindGroup.setResource(input.source, 1);
        filter.groups[0] = renderer.globalUniforms.bindGroup;
        filter.groups[1] = this.globalFilterBindGroup;
        renderer.encoder.draw({
          geometry: quadGeometry,
          shader: filter,
          state: filter._state,
          topology: "triangle-list"
        });
      }
      getFilterData() {
        return {
          skip: false,
          inputTexture: null,
          bounds: new Bounds(),
          container: null,
          filterEffect: null,
          blendRequired: false,
          previousRenderSurface: null
        };
      }
      /**
       * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.
       *
       * Use `outputMatrix * vTextureCoord` in the shader.
       * @param outputMatrix - The matrix to output to.
       * @param {PIXI.Sprite} sprite - The sprite to map to.
       * @returns The mapped matrix.
       */
      calculateSpriteMatrix(outputMatrix, sprite) {
        const data = this.activeFilterData;
        const mappedMatrix = outputMatrix.set(
          data.inputTexture._source.width,
          0,
          0,
          data.inputTexture._source.height,
          data.bounds.minX,
          data.bounds.minY
        );
        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);
        worldTransform.invert();
        mappedMatrix.prepend(worldTransform);
        mappedMatrix.scale(1 / sprite.texture.frameWidth, 1 / sprite.texture.frameHeight);
        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
        return mappedMatrix;
      }
      destroy() {
      }
    };
    FilterSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "filter"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gpu/BatchGeometry.mjs
var placeHolderBufferData2, placeHolderIndexData2, BatchGeometry;
var init_BatchGeometry = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gpu/BatchGeometry.mjs"() {
    init_Buffer();
    init_const5();
    init_Geometry();
    placeHolderBufferData2 = new Float32Array(1);
    placeHolderIndexData2 = new Uint32Array(1);
    BatchGeometry = class extends Geometry {
      constructor() {
        const vertexSize = 6;
        const attributeBuffer = new Buffer2({
          data: placeHolderBufferData2,
          label: "attribute-batch-buffer",
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
        });
        const indexBuffer = new Buffer2({
          data: placeHolderIndexData2,
          label: "index-batch-buffer",
          usage: BufferUsage.INDEX | BufferUsage.COPY_DST
          // | BufferUsage.STATIC,
        });
        const stride = vertexSize * 4;
        super({
          attributes: {
            aPosition: {
              buffer: attributeBuffer,
              shaderLocation: 0,
              format: "float32x2",
              stride,
              offset: 0
            },
            aUV: {
              buffer: attributeBuffer,
              shaderLocation: 1,
              format: "float32x2",
              stride,
              offset: 2 * 4
            },
            aColor: {
              buffer: attributeBuffer,
              shaderLocation: 2,
              format: "unorm8x4",
              stride,
              offset: 4 * 4
            },
            aTextureId: {
              buffer: attributeBuffer,
              shaderLocation: 3,
              format: "float32",
              stride,
              offset: 5 * 4
            }
          },
          indexBuffer
        });
      }
      reset() {
        this.indexBuffer.data = placeHolderIndexData2;
        this.buffers[0].data = placeHolderBufferData2;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs
function buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size2, matrix = null) {
  let index = 0;
  verticesOffset *= verticesStride;
  uvsOffset *= uvsStride;
  const a = matrix.a;
  const b = matrix.b;
  const c = matrix.c;
  const d2 = matrix.d;
  const tx = matrix.tx;
  const ty = matrix.ty;
  while (index < size2) {
    const x2 = vertices[verticesOffset];
    const y = vertices[verticesOffset + 1];
    uvs[uvsOffset] = a * x2 + c * y + tx;
    uvs[uvsOffset + 1] = b * x2 + d2 * y + ty;
    uvsOffset += uvsStride;
    verticesOffset += verticesStride;
    index++;
  }
}
function buildSimpleUvs(uvs, uvsOffset, uvsStride, size2) {
  let index = 0;
  uvsOffset *= uvsStride;
  while (index < size2) {
    uvs[uvsOffset] = 0;
    uvs[uvsOffset + 1] = 0;
    uvsOffset += uvsStride;
    index++;
  }
}
var init_buildUvs = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs
function transformVertices(vertices, m2, offset, stride, size2) {
  const a = m2.a;
  const b = m2.b;
  const c = m2.c;
  const d2 = m2.d;
  const tx = m2.tx;
  const ty = m2.ty;
  offset = offset || 0;
  stride = stride || 2;
  size2 = size2 || vertices.length / stride - offset;
  let index = offset * stride;
  for (let i = 0; i < size2; i++) {
    const x2 = vertices[index];
    const y = vertices[index + 1];
    vertices[index] = a * x2 + c * y + tx;
    vertices[index + 1] = b * x2 + d2 * y + ty;
    index += stride;
  }
}
var init_transformVertices = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/utils/mixHexColors.mjs
function mixHexColors(color1, color2, ratio) {
  const r1 = color1 >> 16 & 255;
  const g1 = color1 >> 8 & 255;
  const b1 = color1 & 255;
  const r2 = color2 >> 16 & 255;
  const g2 = color2 >> 8 & 255;
  const b2 = color2 & 255;
  const r = r1 + (r2 - r1) * ratio;
  const g = g1 + (g2 - g1) * ratio;
  const b = b1 + (b2 - b1) * ratio;
  return (r << 16) + (g << 8) + b;
}
var init_mixHexColors = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/utils/mixHexColors.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/utils/mixColors.mjs
function mixColors(localColor, parentColor) {
  const localAlpha = (localColor >> 24 & 255) / 255;
  const parentAlpha = (parentColor >> 24 & 255) / 255;
  const globalAlpha = localAlpha * parentAlpha * 255;
  const localBGRColor = localColor & 16777215;
  const parentBGRColor = parentColor & 16777215;
  let sharedBGRColor = 16777215;
  if (localBGRColor + (parentBGRColor << 32) !== WHITE_WHITE) {
    if (localBGRColor === 16777215) {
      sharedBGRColor = parentBGRColor;
    } else if (parentBGRColor === 16777215) {
      sharedBGRColor = localBGRColor;
    } else {
      sharedBGRColor = mixHexColors(localBGRColor, parentBGRColor, 0.5);
    }
  }
  return sharedBGRColor + (globalAlpha << 24);
}
var WHITE_WHITE;
var init_mixColors = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/utils/mixColors.mjs"() {
    init_mixHexColors();
    WHITE_WHITE = 16777215 + (16777215 << 32);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/BatchableGraphics.mjs
var BatchableGraphics;
var init_BatchableGraphics = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/BatchableGraphics.mjs"() {
    init_mixColors();
    BatchableGraphics = class {
      constructor() {
        this.batcher = null;
        this.batch = null;
        this.applyTransform = true;
      }
      get blendMode() {
        if (this.applyTransform) {
          return this.renderable.layerBlendMode;
        }
        return "normal";
      }
      packIndex(indexBuffer, index, indicesOffset) {
        const indices = this.geometryData.indices;
        for (let i = 0; i < this.indexSize; i++) {
          indexBuffer[index++] = indices[i + this.indexOffset] + indicesOffset - this.vertexOffset;
        }
      }
      packAttributes(float32View, uint32View, index, textureId) {
        const geometry = this.geometryData;
        const positions = geometry.vertices;
        const uvs = geometry.uvs;
        const offset = this.vertexOffset * 2;
        const vertSize = (this.vertexOffset + this.vertexSize) * 2;
        const rgb = this.color;
        const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;
        if (this.applyTransform) {
          const renderable = this.renderable;
          const argb = mixColors(bgr + (this.alpha * 255 << 24), renderable.layerColor);
          const wt = renderable.layerTransform;
          const a = wt.a;
          const b = wt.b;
          const c = wt.c;
          const d2 = wt.d;
          const tx = wt.tx;
          const ty = wt.ty;
          for (let i = offset; i < vertSize; i += 2) {
            const x2 = positions[i];
            const y = positions[i + 1];
            float32View[index++] = a * x2 + c * y + tx;
            float32View[index++] = b * x2 + d2 * y + ty;
            float32View[index++] = uvs[i];
            float32View[index++] = uvs[i + 1];
            uint32View[index++] = argb;
            float32View[index++] = textureId;
          }
        } else {
          const argb = bgr + (this.alpha * 255 << 24);
          for (let i = offset; i < vertSize; i += 2) {
            float32View[index++] = positions[i];
            float32View[index++] = positions[i + 1];
            float32View[index++] = uvs[i];
            float32View[index++] = uvs[i + 1];
            uint32View[index++] = argb;
            float32View[index++] = textureId;
          }
        }
      }
      // TODO rename to vertexSize
      get vertSize() {
        return this.vertexSize;
      }
      copyTo(gpuBuffer) {
        gpuBuffer.indexOffset = this.indexOffset;
        gpuBuffer.indexSize = this.indexSize;
        gpuBuffer.vertexOffset = this.vertexOffset;
        gpuBuffer.vertexSize = this.vertexSize;
        gpuBuffer.color = this.color;
        gpuBuffer.alpha = this.alpha;
        gpuBuffer.texture = this.texture;
        gpuBuffer.geometryData = this.geometryData;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/buildCommands/buildCircle.mjs
var buildCircle;
var init_buildCircle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/buildCommands/buildCircle.mjs"() {
    buildCircle = {
      build(shape, points) {
        let x2;
        let y;
        let dx;
        let dy;
        let rx;
        let ry;
        if (shape.type === "circle") {
          const circle = shape;
          x2 = circle.x;
          y = circle.y;
          rx = ry = circle.radius;
          dx = dy = 0;
        } else if (shape.type === "ellipse") {
          const ellipse = shape;
          x2 = ellipse.x;
          y = ellipse.y;
          rx = ellipse.halfWidth;
          ry = ellipse.halfHeight;
          dx = dy = 0;
        } else {
          const roundedRect = shape;
          const halfWidth = roundedRect.width / 2;
          const halfHeight = roundedRect.height / 2;
          x2 = roundedRect.x + halfWidth;
          y = roundedRect.y + halfHeight;
          rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
          dx = halfWidth - rx;
          dy = halfHeight - ry;
        }
        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
          return points;
        }
        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));
        const m2 = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
        if (m2 === 0) {
          return points;
        }
        if (n === 0) {
          points[0] = points[6] = x2 + dx;
          points[1] = points[3] = y + dy;
          points[2] = points[4] = x2 - dx;
          points[5] = points[7] = y - dy;
          return points;
        }
        let j1 = 0;
        let j2 = n * 4 + (dx ? 2 : 0) + 2;
        let j3 = j2;
        let j4 = m2;
        let x0 = dx + rx;
        let y0 = dy;
        let x1 = x2 + x0;
        let x22 = x2 - x0;
        let y1 = y + y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j2] = y1;
        points[--j2] = x22;
        if (dy) {
          const y22 = y - y0;
          points[j3++] = x22;
          points[j3++] = y22;
          points[--j4] = y22;
          points[--j4] = x1;
        }
        for (let i = 1; i < n; i++) {
          const a = Math.PI / 2 * (i / n);
          const x02 = dx + Math.cos(a) * rx;
          const y02 = dy + Math.sin(a) * ry;
          const x12 = x2 + x02;
          const x222 = x2 - x02;
          const y12 = y + y02;
          const y22 = y - y02;
          points[j1++] = x12;
          points[j1++] = y12;
          points[--j2] = y12;
          points[--j2] = x222;
          points[j3++] = x222;
          points[j3++] = y22;
          points[--j4] = y22;
          points[--j4] = x12;
        }
        x0 = dx;
        y0 = dy + ry;
        x1 = x2 + x0;
        x22 = x2 - x0;
        y1 = y + y0;
        const y2 = y - y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j4] = y2;
        points[--j4] = x1;
        if (dx) {
          points[j1++] = x22;
          points[j1++] = y1;
          points[--j4] = y2;
          points[--j4] = x22;
        }
        return points;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        if (points.length === 0) {
          return;
        }
        let x2 = 0;
        let y = 0;
        const div = points.length / 4;
        x2 += points[0];
        y += points[1];
        x2 += points[div | 0];
        y += points[(div | 0) + 1];
        x2 += points[div * 2 | 0];
        y += points[(div * 2 | 0) + 1];
        x2 += points[div * 3 | 0];
        y += points[(div * 3 | 0) + 1];
        x2 /= 4;
        y /= 4;
        let count2 = verticesOffset;
        vertices[count2 * verticesStride] = x2;
        vertices[count2 * verticesStride + 1] = y;
        count2++;
        const center = verticesOffset;
        vertices[count2 * verticesStride] = points[0];
        vertices[count2 * verticesStride + 1] = points[1];
        count2++;
        for (let i = 2; i < points.length; i += 2) {
          vertices[count2 * verticesStride] = points[i];
          vertices[count2 * verticesStride + 1] = points[i + 1];
          indices[indicesOffset++] = count2;
          indices[indicesOffset++] = center;
          indices[indicesOffset++] = count2 - 1;
          count2++;
        }
        indices[indicesOffset++] = count2 - 1;
        indices[indicesOffset++] = center;
        indices[indicesOffset++] = center + 1;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/const.mjs
var closePointEps, curveEps;
var init_const6 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/const.mjs"() {
    closePointEps = 1e-4;
    curveEps = 1e-4;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/utils/getOrientationOfPoints.mjs
function getOrientationOfPoints(points) {
  const m2 = points.length;
  if (m2 < 6) {
    return 1;
  }
  let area = 0;
  for (let i = 0, x1 = points[m2 - 2], y1 = points[m2 - 1]; i < m2; i += 2) {
    const x2 = points[i];
    const y2 = points[i + 1];
    area += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  if (area < 0) {
    return -1;
  }
  return 1;
}
var init_getOrientationOfPoints = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/utils/getOrientationOfPoints.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/buildCommands/buildLine.mjs
function square(x2, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  const ix = x2 - nx * innerWeight;
  const iy = y - ny * innerWeight;
  const ox = x2 + nx * outerWeight;
  const oy = y + ny * outerWeight;
  let exx;
  let eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  const eix = ix + exx;
  const eiy = iy + eyy;
  const eox = ox + exx;
  const eoy = oy + eyy;
  verts.push(eix, eiy);
  verts.push(eox, eoy);
  return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  const cx2p0x = sx - cx;
  const cy2p0y = sy - cy;
  let angle0 = Math.atan2(cx2p0x, cy2p0y);
  let angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  let startAngle = angle0;
  const angleDiff = angle1 - angle0;
  const absAngleDiff = Math.abs(angleDiff);
  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  const angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy);
    verts.push(sx, sy);
    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts.push(cx, cy);
      verts.push(
        cx + Math.sin(angle) * radius,
        cy + Math.cos(angle) * radius
      );
    }
    verts.push(cx, cy);
    verts.push(ex, ey);
  } else {
    verts.push(sx, sy);
    verts.push(cx, cy);
    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts.push(
        cx + Math.sin(angle) * radius,
        cy + Math.cos(angle) * radius
      );
      verts.push(cx, cy);
    }
    verts.push(ex, ey);
    verts.push(cx, cy);
  }
  return segCount * 2;
}
function buildLine(points, lineStyle, flipAlignment, closed, vertices, _verticesStride, _verticesOffset, indices, _indicesOffset) {
  const eps = closePointEps;
  if (points.length === 0) {
    return;
  }
  const style = lineStyle;
  let alignment = style.alignment;
  if (lineStyle.alignment !== 0.5) {
    let orientation = getOrientationOfPoints(points);
    if (flipAlignment)
      orientation *= -1;
    alignment = (alignment - 0.5) * orientation + 0.5;
  }
  const firstPoint = new Point(points[0], points[1]);
  const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
  const closedShape = closed;
  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  const verts = vertices;
  const length = points.length / 2;
  let indexCount = points.length;
  const indexStart = verts.length / 2;
  const width = style.width / 2;
  const widthSquared = width * width;
  const miterLimitSquared = style.miterLimit * style.miterLimit;
  let x0 = points[0];
  let y0 = points[1];
  let x1 = points[2];
  let y1 = points[3];
  let x2 = 0;
  let y2 = 0;
  let perpX = -(y0 - y1);
  let perpY = x0 - x1;
  let perp1x = 0;
  let perp1y = 0;
  let dist = Math.sqrt(perpX * perpX + perpY * perpY);
  perpX /= dist;
  perpY /= dist;
  perpX *= width;
  perpY *= width;
  const ratio = alignment;
  const innerWeight = (1 - ratio) * 2;
  const outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === "round") {
      indexCount += round(
        x0 - perpX * (innerWeight - outerWeight) * 0.5,
        y0 - perpY * (innerWeight - outerWeight) * 0.5,
        x0 - perpX * innerWeight,
        y0 - perpY * innerWeight,
        x0 + perpX * outerWeight,
        y0 + perpY * outerWeight,
        verts,
        true
      ) + 2;
    } else if (style.cap === "square") {
      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(
    x0 - perpX * innerWeight,
    y0 - perpY * innerWeight
  );
  verts.push(
    x0 + perpX * outerWeight,
    y0 + perpY * outerWeight
  );
  for (let i = 1; i < length - 1; ++i) {
    x0 = points[(i - 1) * 2];
    y0 = points[(i - 1) * 2 + 1];
    x1 = points[i * 2];
    y1 = points[i * 2 + 1];
    x2 = points[(i + 1) * 2];
    y2 = points[(i + 1) * 2 + 1];
    perpX = -(y0 - y1);
    perpY = x0 - x1;
    dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    perp1x = -(y1 - y2);
    perp1y = x1 - x2;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    const dx0 = x1 - x0;
    const dy0 = y0 - y1;
    const dx1 = x1 - x2;
    const dy1 = y2 - y1;
    const dot = dx0 * dx1 + dy0 * dy1;
    const cross = dy0 * dx1 - dy1 * dx0;
    const clockwise = cross < 0;
    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
      verts.push(
        x1 - perpX * innerWeight,
        y1 - perpY * innerWeight
      );
      verts.push(
        x1 + perpX * outerWeight,
        y1 + perpY * outerWeight
      );
      if (dot >= 0) {
        if (style.join === "round") {
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 4;
        } else {
          indexCount += 2;
        }
        verts.push(
          x1 - perp1x * outerWeight,
          y1 - perp1y * outerWeight
        );
        verts.push(
          x1 + perp1x * innerWeight,
          y1 + perp1y * innerWeight
        );
      }
      continue;
    }
    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);
    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
    const px = (dx0 * c2 - dx1 * c1) / cross;
    const py = (dy1 * c1 - dy0 * c2) / cross;
    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    const imx = x1 + (px - x1) * innerWeight;
    const imy = y1 + (py - y1) * innerWeight;
    const omx = x1 - (px - x1) * outerWeight;
    const omy = y1 - (py - y1) * outerWeight;
    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    const insideWeight = clockwise ? innerWeight : outerWeight;
    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    const insideMiterOk = pDist <= smallerInsideDiagonalSq;
    if (insideMiterOk) {
      if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
          verts.push(omx, omy);
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
        indexCount += 2;
      } else if (style.join === "round") {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
          indexCount += round(
            x1,
            y1,
            x1 + perpX * outerWeight,
            y1 + perpY * outerWeight,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight,
            verts,
            true
          ) + 4;
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
          verts.push(omx, omy);
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 4;
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
      } else {
        verts.push(imx, imy);
        verts.push(omx, omy);
      }
    } else {
      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
      if (style.join === "round") {
        if (clockwise) {
          indexCount += round(
            x1,
            y1,
            x1 + perpX * outerWeight,
            y1 + perpY * outerWeight,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight,
            verts,
            true
          ) + 2;
        } else {
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 2;
        }
      } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {
        if (clockwise) {
          verts.push(omx, omy);
          verts.push(omx, omy);
        } else {
          verts.push(imx, imy);
          verts.push(imx, imy);
        }
        indexCount += 2;
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length - 2) * 2];
  y0 = points[(length - 2) * 2 + 1];
  x1 = points[(length - 1) * 2];
  y1 = points[(length - 1) * 2 + 1];
  perpX = -(y0 - y1);
  perpY = x0 - x1;
  dist = Math.sqrt(perpX * perpX + perpY * perpY);
  perpX /= dist;
  perpY /= dist;
  perpX *= width;
  perpY *= width;
  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
  if (!closedShape) {
    if (style.cap === "round") {
      indexCount += round(
        x1 - perpX * (innerWeight - outerWeight) * 0.5,
        y1 - perpY * (innerWeight - outerWeight) * 0.5,
        x1 - perpX * innerWeight,
        y1 - perpY * innerWeight,
        x1 + perpX * outerWeight,
        y1 + perpY * outerWeight,
        verts,
        false
      ) + 2;
    } else if (style.cap === "square") {
      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);
    }
  }
  const eps2 = curveEps * curveEps;
  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {
    x0 = verts[i * 2];
    y0 = verts[i * 2 + 1];
    x1 = verts[(i + 1) * 2];
    y1 = verts[(i + 1) * 2 + 1];
    x2 = verts[(i + 2) * 2];
    y2 = verts[(i + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
      continue;
    }
    indices.push(i, i + 1, i + 2);
  }
}
var init_buildLine = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/buildCommands/buildLine.mjs"() {
    init_Point();
    init_const6();
    init_getOrientationOfPoints();
  }
});

// ../../node_modules/.pnpm/earcut@2.2.4/node_modules/earcut/src/earcut.js
var require_earcut = __commonJS({
  "../../node_modules/.pnpm/earcut@2.2.4/node_modules/earcut/src/earcut.js"(exports, module) {
    "use strict";
    module.exports = earcut2;
    module.exports.default = earcut2;
    function earcut2(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev)
        return triangles;
      var minX, minY, maxX, maxY, x2, y, invSize;
      if (hasHoles)
        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i = dim; i < outerLen; i += dim) {
          x2 = data[i];
          y = data[i + 1];
          if (x2 < minX)
            minX = x2;
          if (y < minY)
            minY = y;
          if (x2 > maxX)
            maxX = x2;
          if (y > maxY)
            maxY = y;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
      return triangles;
    }
    function linkedList(data, start, end, dim, clockwise) {
      var i, last;
      if (clockwise === signedArea(data, start, end, dim) > 0) {
        for (i = start; i < end; i += dim)
          last = insertNode(i, data[i], data[i + 1], last);
      } else {
        for (i = end - dim; i >= start; i -= dim)
          last = insertNode(i, data[i], data[i + 1], last);
      }
      if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints(start, end) {
      if (!start)
        return start;
      if (!end)
        end = start;
      var p = start, again;
      do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
          removeNode(p);
          p = end = p.prev;
          if (p === p.next)
            break;
          again = true;
        } else {
          p = p.next;
        }
      } while (again || p !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear)
        return;
      if (!pass && invSize)
        indexCurve(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev.i / dim | 0);
          triangles.push(ear.i / dim | 0);
          triangles.push(next.i / dim | 0);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0)
        return false;
      var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var p = c.next;
      while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0)
        return false;
      var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
      var p = ear.prevZ, n = ear.nextZ;
      while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.prevZ;
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
          return false;
        n = n.nextZ;
      }
      while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.prevZ;
      }
      while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
          return false;
        n = n.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      var p = start;
      do {
        var a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
          triangles.push(a.i / dim | 0);
          triangles.push(p.i / dim | 0);
          triangles.push(b.i / dim | 0);
          removeNode(p);
          removeNode(p.next);
          p = start = b;
        }
        p = p.next;
      } while (p !== start);
      return filterPoints(p);
    }
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
      var a = start;
      do {
        var b = a.next.next;
        while (b !== a.prev) {
          if (a.i !== b.i && isValidDiagonal(a, b)) {
            var c = splitPolygon(a, b);
            a = filterPoints(a, a.next);
            c = filterPoints(c, c.next);
            earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
            earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
            return;
          }
          b = b.next;
        }
        a = a.next;
      } while (a !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [], i, len, start, end, list;
      for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next)
          list.steiner = true;
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
      }
      return outerNode;
    }
    function compareX(a, b) {
      return a.x - b.x;
    }
    function eliminateHole(hole, outerNode) {
      var bridge = findHoleBridge(hole, outerNode);
      if (!bridge) {
        return outerNode;
      }
      var bridgeReverse = splitPolygon(bridge, hole);
      filterPoints(bridgeReverse, bridgeReverse.next);
      return filterPoints(bridge, bridge.next);
    }
    function findHoleBridge(hole, outerNode) {
      var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
      do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
          var x2 = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
          if (x2 <= hx && x2 > qx) {
            qx = x2;
            m2 = p.x < p.next.x ? p : p.next;
            if (x2 === hx)
              return m2;
          }
        }
        p = p.next;
      } while (p !== outerNode);
      if (!m2)
        return null;
      var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan;
      p = m2;
      do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
          tan = Math.abs(hy - p.y) / (hx - p.x);
          if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m2.x || p.x === m2.x && sectorContainsSector(m2, p)))) {
            m2 = p;
            tanMin = tan;
          }
        }
        p = p.next;
      } while (p !== stop);
      return m2;
    }
    function sectorContainsSector(m2, p) {
      return area(m2.prev, m2, p.prev) < 0 && area(p.next, m2, m2.next) < 0;
    }
    function indexCurve(start, minX, minY, invSize) {
      var p = start;
      do {
        if (p.z === 0)
          p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
      } while (p !== start);
      p.prevZ.nextZ = null;
      p.prevZ = null;
      sortLinked(p);
    }
    function sortLinked(list) {
      var i, p, q2, e, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p) {
          numMerges++;
          q2 = p;
          pSize = 0;
          for (i = 0; i < inSize; i++) {
            pSize++;
            q2 = q2.nextZ;
            if (!q2)
              break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q2) {
            if (pSize !== 0 && (qSize === 0 || !q2 || p.z <= q2.z)) {
              e = p;
              p = p.nextZ;
              pSize--;
            } else {
              e = q2;
              q2 = q2.nextZ;
              qSize--;
            }
            if (tail)
              tail.nextZ = e;
            else
              list = e;
            e.prevZ = tail;
            tail = e;
          }
          p = q2;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x2, y, minX, minY, invSize) {
      x2 = (x2 - minX) * invSize | 0;
      y = (y - minY) * invSize | 0;
      x2 = (x2 | x2 << 8) & 16711935;
      x2 = (x2 | x2 << 4) & 252645135;
      x2 = (x2 | x2 << 2) & 858993459;
      x2 = (x2 | x2 << 1) & 1431655765;
      y = (y | y << 8) & 16711935;
      y = (y | y << 4) & 252645135;
      y = (y | y << 2) & 858993459;
      y = (y | y << 1) & 1431655765;
      return x2 | y << 1;
    }
    function getLeftmost(start) {
      var p = start, leftmost = start;
      do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
          leftmost = p;
        p = p.next;
      } while (p !== start);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }
    function isValidDiagonal(a, b) {
      return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
      (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
      (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
      equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
    }
    function area(p, q2, r) {
      return (q2.y - p.y) * (r.x - q2.x) - (q2.x - p.x) * (r.y - q2.y);
    }
    function equals(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      var o1 = sign(area(p1, q1, p2));
      var o2 = sign(area(p1, q1, q2));
      var o3 = sign(area(p2, q2, p1));
      var o4 = sign(area(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4)
        return true;
      if (o1 === 0 && onSegment(p1, p2, q1))
        return true;
      if (o2 === 0 && onSegment(p1, q2, q1))
        return true;
      if (o3 === 0 && onSegment(p2, p1, q2))
        return true;
      if (o4 === 0 && onSegment(p2, q1, q2))
        return true;
      return false;
    }
    function onSegment(p, q2, r) {
      return q2.x <= Math.max(p.x, r.x) && q2.x >= Math.min(p.x, r.x) && q2.y <= Math.max(p.y, r.y) && q2.y >= Math.min(p.y, r.y);
    }
    function sign(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon(a, b) {
      var p = a;
      do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
          return true;
        p = p.next;
      } while (p !== a);
      return false;
    }
    function locallyInside(a, b) {
      return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    function middleInside(a, b) {
      var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
      do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
          inside = !inside;
        p = p.next;
      } while (p !== a);
      return inside;
    }
    function splitPolygon(a, b) {
      var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
      a.next = b;
      b.prev = a;
      a2.next = an;
      an.prev = a2;
      b2.next = a2;
      a2.prev = b2;
      bp.next = b2;
      b2.prev = bp;
      return b2;
    }
    function insertNode(i, x2, y, last) {
      var p = new Node(i, x2, y);
      if (!last) {
        p.prev = p;
        p.next = p;
      } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
      }
      return p;
    }
    function removeNode(p) {
      p.next.prev = p.prev;
      p.prev.next = p.next;
      if (p.prevZ)
        p.prevZ.nextZ = p.nextZ;
      if (p.nextZ)
        p.nextZ.prevZ = p.prevZ;
    }
    function Node(i, x2, y) {
      this.i = i;
      this.x = x2;
      this.y = y;
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut2.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
          var start = holeIndices[i] * dim;
          var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
      }
      var trianglesArea = 0;
      for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
          (data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1])
        );
      }
      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data, start, end, dim) {
      var sum = 0;
      for (var i = start, j2 = end - dim; i < end; i += dim) {
        sum += (data[j2] - data[i]) * (data[i + 1] + data[j2 + 1]);
        j2 = i;
      }
      return sum;
    }
    earcut2.flatten = function(data) {
      var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i = 0; i < data.length; i++) {
        for (var j2 = 0; j2 < data[i].length; j2++) {
          for (var d2 = 0; d2 < dim; d2++)
            result.vertices.push(data[i][j2][d2]);
        }
        if (i > 0) {
          holeIndex += data[i - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/utils/triangulateWithHoles.mjs
function triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
  const triangles = (0, import_earcut.default)(points, holes, 2);
  if (!triangles) {
    return;
  }
  for (let i = 0; i < triangles.length; i += 3) {
    indices[indicesOffset++] = triangles[i] + verticesOffset;
    indices[indicesOffset++] = triangles[i + 1] + verticesOffset;
    indices[indicesOffset++] = triangles[i + 2] + verticesOffset;
  }
  let index = verticesOffset * verticesStride;
  for (let i = 0; i < points.length; i += 2) {
    vertices[index] = points[i];
    vertices[index + 1] = points[i + 1];
    index += verticesStride;
  }
}
var import_earcut;
var init_triangulateWithHoles = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/utils/triangulateWithHoles.mjs"() {
    import_earcut = __toESM(require_earcut(), 1);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/buildCommands/buildPolygon.mjs
var emptyArray, buildPolygon;
var init_buildPolygon = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/buildCommands/buildPolygon.mjs"() {
    init_triangulateWithHoles();
    emptyArray = [];
    buildPolygon = {
      build(shape, points) {
        for (let i = 0; i < shape.points.length; i++) {
          points[i] = shape.points[i];
        }
        return points;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/buildCommands/buildRectangle.mjs
var buildRectangle;
var init_buildRectangle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/buildCommands/buildRectangle.mjs"() {
    buildRectangle = {
      build(shape, points) {
        const rectData = shape;
        const x2 = rectData.x;
        const y = rectData.y;
        const width = rectData.width;
        const height = rectData.height;
        if (!(width >= 0 && height >= 0)) {
          return points;
        }
        points[0] = x2;
        points[1] = y;
        points[2] = x2 + width;
        points[3] = y;
        points[4] = x2 + width;
        points[5] = y + height;
        points[6] = x2;
        points[7] = y + height;
        return points;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        let count2 = 0;
        verticesOffset *= verticesStride;
        vertices[verticesOffset + count2] = points[0];
        vertices[verticesOffset + count2 + 1] = points[1];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[2];
        vertices[verticesOffset + count2 + 1] = points[3];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[6];
        vertices[verticesOffset + count2 + 1] = points[7];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[4];
        vertices[verticesOffset + count2 + 1] = points[5];
        count2 += verticesStride;
        const verticesIndex = verticesOffset / verticesStride;
        indices[indicesOffset++] = verticesIndex;
        indices[indicesOffset++] = verticesIndex + 1;
        indices[indicesOffset++] = verticesIndex + 2;
        indices[indicesOffset++] = verticesIndex + 1;
        indices[indicesOffset++] = verticesIndex + 3;
        indices[indicesOffset++] = verticesIndex + 2;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/buildCommands/buildTriangle.mjs
var buildTriangle;
var init_buildTriangle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/buildCommands/buildTriangle.mjs"() {
    buildTriangle = {
      build(shape, points) {
        points[0] = shape.x;
        points[1] = shape.y;
        points[2] = shape.x2;
        points[3] = shape.y2;
        points[4] = shape.x3;
        points[5] = shape.y3;
        return points;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        let count2 = 0;
        verticesOffset *= verticesStride;
        vertices[verticesOffset + count2] = points[0];
        vertices[verticesOffset + count2 + 1] = points[1];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[2];
        vertices[verticesOffset + count2 + 1] = points[3];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[4];
        vertices[verticesOffset + count2 + 1] = points[5];
        const verticesIndex = verticesOffset / verticesStride;
        indices[indicesOffset++] = verticesIndex;
        indices[indicesOffset++] = verticesIndex + 1;
        indices[indicesOffset++] = verticesIndex + 2;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/utils/buildContextBatches.mjs
function buildContextBatches(context) {
  const vertices = [];
  const uvs = [];
  const indices = [];
  const geometryData = {
    vertices,
    uvs,
    indices
  };
  const batches = [];
  for (let i = 0; i < context.instructions.length; i++) {
    const instruction = context.instructions[i];
    if (instruction.action === "texture") {
      addTextureToGeometryData(instruction.data, batches, geometryData);
    } else if (instruction.action === "fill" || instruction.action === "stroke") {
      const isStroke = instruction.action === "stroke";
      const shapePath = instruction.data.path.shapePath;
      const style = instruction.data.style;
      const hole = instruction.data.hole;
      if (isStroke && hole) {
        addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);
      }
      addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);
    }
  }
  return batches;
}
function addTextureToGeometryData(data, batches, geometryData) {
  const { vertices, uvs, indices } = geometryData;
  const indexOffset = indices.length;
  const vertOffset = vertices.length / 2;
  const points = [];
  const build = buildMap.rectangle;
  const rect = tempRect;
  const texture = data.image;
  rect.x = data.dx;
  rect.y = data.dy;
  rect.width = data.dw;
  rect.height = data.dh;
  const matrix = data.transform;
  build.build(rect, points);
  if (matrix) {
    transformVertices(points, matrix);
  }
  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
  const textureUvs = texture.layout.uvs;
  uvs.push(
    textureUvs.x0,
    textureUvs.y0,
    textureUvs.x1,
    textureUvs.y1,
    textureUvs.x3,
    textureUvs.y3,
    textureUvs.x2,
    textureUvs.y2
  );
  const graphicsBatch = BigPool.get(BatchableGraphics);
  graphicsBatch.indexOffset = indexOffset;
  graphicsBatch.indexSize = indices.length - indexOffset;
  graphicsBatch.vertexOffset = vertOffset;
  graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;
  graphicsBatch.color = data.style;
  graphicsBatch.alpha = data.alpha;
  graphicsBatch.texture = texture;
  graphicsBatch.geometryData = geometryData;
  batches.push(graphicsBatch);
}
function addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {
  const { vertices, uvs, indices } = geometryData;
  const lastIndex = shapePath.shapePrimitives.length - 1;
  shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i) => {
    const indexOffset = indices.length;
    const vertOffset = vertices.length / 2;
    const points = [];
    const build = buildMap[shape.type];
    build.build(shape, points);
    if (matrix) {
      transformVertices(points, matrix);
    }
    if (!isStroke) {
      if (hole && lastIndex === i) {
        if (lastIndex !== 0) {
          console.warn("[Pixi Graphics] only the last shape have be cut out");
        }
        const holeIndices = [];
        const otherPoints = points.slice();
        const holeArrays = getHoleArrays(hole.shapePath);
        holeArrays.forEach((holePoints) => {
          holeIndices.push(otherPoints.length / 2);
          otherPoints.push(...holePoints);
        });
        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);
      } else {
        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
      }
    } else {
      const close = shape.closePath ?? true;
      const lineStyle = style;
      buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);
    }
    const uvsOffset = uvs.length / 2;
    const texture = style.texture;
    if (texture !== Texture.WHITE) {
      const textureMatrix = style.matrix;
      if (matrix) {
        textureMatrix.append(matrix.clone().invert());
      }
      buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
    } else {
      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
    }
    const graphicsBatch = BigPool.get(BatchableGraphics);
    graphicsBatch.indexOffset = indexOffset;
    graphicsBatch.indexSize = indices.length - indexOffset;
    graphicsBatch.vertexOffset = vertOffset;
    graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;
    graphicsBatch.color = style.color;
    graphicsBatch.alpha = style.alpha;
    graphicsBatch.texture = texture;
    graphicsBatch.geometryData = geometryData;
    batches.push(graphicsBatch);
  });
}
function getHoleArrays(shape) {
  if (!shape)
    return [];
  const holePrimitives = shape.shapePrimitives;
  const holeArrays = [];
  for (let k2 = 0; k2 < holePrimitives.length; k2++) {
    const holePrimitive = holePrimitives[k2].shape;
    const holePoints = [];
    const holeBuilder = buildMap[holePrimitive.type];
    holeBuilder.build(holePrimitive, holePoints);
    holeArrays.push(holePoints);
  }
  return holeArrays;
}
var buildMap, tempRect;
var init_buildContextBatches = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/utils/buildContextBatches.mjs"() {
    init_Rectangle();
    init_PoolGroup();
    init_buildUvs();
    init_transformVertices();
    init_Texture();
    init_BatchableGraphics();
    init_buildCircle();
    init_buildLine();
    init_buildPolygon();
    init_buildRectangle();
    init_buildTriangle();
    init_triangulateWithHoles();
    buildMap = {
      rectangle: buildRectangle,
      polygon: buildPolygon,
      triangle: buildTriangle,
      circle: buildCircle,
      ellipse: buildCircle,
      roundedRectangle: buildCircle
    };
    tempRect = new Rectangle();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/GraphicsContextSystem.mjs
var GpuGraphicsContext, GraphicsContextRenderData, GraphicsContextSystem;
var init_GraphicsContextSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/GraphicsContextSystem.mjs"() {
    init_Extensions();
    init_PoolGroup();
    init_BatchGeometry();
    init_getTextureBatchBindGroup();
    init_Batcher();
    init_buildContextBatches();
    GpuGraphicsContext = class {
    };
    GraphicsContextRenderData = class {
      constructor() {
        this.geometry = new BatchGeometry();
        this.batches = [];
      }
      init() {
        this.batches.length = 0;
        this.geometry.reset();
      }
    };
    GraphicsContextSystem = class {
      constructor() {
        this.activeBatchers = [];
        this.gpuContextHash = {};
        this.graphicsDataContextHash = {};
        this._needsContextNeedsRebuild = [];
      }
      prerender() {
        this.returnActiveBatchers();
      }
      getContextRenderData(context) {
        return this.graphicsDataContextHash[context.uid] || this.initContextRenderData(context);
      }
      // Context management functions
      updateGpuContext(context) {
        let gpuContext = this.gpuContextHash[context.uid] || this.initContext(context);
        if (context.dirty) {
          if (gpuContext) {
            this.cleanGraphicsContextData(context);
          } else {
            gpuContext = this.initContext(context);
          }
          const contextBatches = buildContextBatches(context);
          let size2 = 0;
          const batchMode = context.batchMode;
          let isBatchable = true;
          if (batchMode === "auto") {
            for (let i = 0; i < contextBatches.length; i++) {
              size2 += contextBatches[i].vertexSize;
              if (size2 > 100) {
                isBatchable = false;
                break;
              }
            }
          } else if (batchMode === "no-batch") {
            isBatchable = false;
          }
          gpuContext = this.gpuContextHash[context.uid] = {
            isBatchable,
            batches: contextBatches
          };
          context.dirty = false;
        }
        return gpuContext;
      }
      getGpuContext(context) {
        return this.gpuContextHash[context.uid] || this.initContext(context);
      }
      returnActiveBatchers() {
        for (let i = 0; i < this.activeBatchers.length; i++) {
          BigPool.return(this.activeBatchers[i]);
        }
        this.activeBatchers.length = 0;
      }
      initContextRenderData(context) {
        const graphicsData = BigPool.get(GraphicsContextRenderData);
        const batches = this.gpuContextHash[context.uid].batches;
        let vertexSize = 0;
        let indexSize = 0;
        batches.forEach((batch) => {
          batch.applyTransform = false;
          vertexSize += batch.geometryData.vertices.length;
          indexSize += batch.geometryData.indices.length;
        });
        const batcher = BigPool.get(Batcher);
        this.activeBatchers.push(batcher);
        batcher.ensureAttributeBuffer(vertexSize);
        batcher.ensureIndexBuffer(indexSize);
        batcher.begin();
        for (let i = 0; i < batches.length; i++) {
          const batch = batches[i];
          batcher.add(batch);
        }
        batcher.finish();
        const geometry = graphicsData.geometry;
        geometry.indexBuffer.data = batcher.indexBuffer;
        geometry.buffers[0].data = batcher.attributeBuffer.float32View;
        const drawBatches = batcher.batches;
        for (let i = 0; i < drawBatches.length; i++) {
          const batch = drawBatches[i];
          batch.textures.bindGroup = getTextureBatchBindGroup(batch.textures.textures);
        }
        this.graphicsDataContextHash[context.uid] = graphicsData;
        graphicsData.batches = drawBatches;
        return graphicsData;
      }
      initContext(context) {
        const gpuContext = new GpuGraphicsContext();
        this.gpuContextHash[context.uid] = gpuContext;
        context.on("update", this.onGraphicsContextUpdate, this);
        context.on("destroy", this.onGraphicsContextDestroy, this);
        return this.gpuContextHash[context.uid];
      }
      onGraphicsContextUpdate(context) {
        this._needsContextNeedsRebuild.push(context);
      }
      onGraphicsContextDestroy(context) {
        this.cleanGraphicsContextData(context);
        this.gpuContextHash[context.uid] = null;
      }
      cleanGraphicsContextData(context) {
        const gpuContext = this.gpuContextHash[context.uid];
        if (!gpuContext.isBatchable) {
          if (this.graphicsDataContextHash[context.uid]) {
            BigPool.return(this.getContextRenderData(context));
            this.graphicsDataContextHash[context.uid] = null;
          }
        }
        if (gpuContext.batches) {
          gpuContext.batches.forEach((batch) => {
            BigPool.return(batch);
          });
        }
      }
      destroy() {
      }
    };
    GraphicsContextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "graphicsContext"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/GraphicsPipe.mjs
var GraphicsPipe;
var init_GraphicsPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/GraphicsPipe.mjs"() {
    init_Extensions();
    init_PoolGroup();
    init_State();
    init_BatchableGraphics();
    GraphicsPipe = class {
      constructor(renderer, adaptor) {
        this.state = State.for2d();
        this.renderableBatchesHash = {};
        this.renderer = renderer;
        this.adaptor = adaptor;
        this.adaptor.init();
      }
      validateRenderable(renderable) {
        const context = renderable.view.context;
        const wasBatched = !!this.renderableBatchesHash[renderable.uid];
        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);
        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {
          return true;
        }
        return false;
      }
      addRenderable(renderable, instructionSet) {
        const gpuContext = this.renderer.graphicsContext.updateGpuContext(renderable.view.context);
        if (renderable.view.didUpdate) {
          renderable.view.didUpdate = false;
          this.rebuild(renderable);
        }
        if (gpuContext.isBatchable) {
          this.addToBatcher(renderable, instructionSet);
        } else {
          this.renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            type: "graphics",
            renderable
          });
        }
      }
      updateRenderable(renderable) {
        const batches = this.renderableBatchesHash[renderable.uid];
        if (batches) {
          for (let i = 0; i < batches.length; i++) {
            const batch = batches[i];
            batch.batcher.updateElement(batch);
          }
        }
      }
      execute({ renderable }) {
        if (!renderable.isRenderable)
          return;
        this.adaptor.execute(this, renderable);
      }
      rebuild(renderable) {
        const wasBatched = !!this.renderableBatchesHash[renderable.uid];
        const gpuContext = this.renderer.graphicsContext.updateGpuContext(renderable.view.context);
        if (wasBatched) {
          this.removeBatchForRenderable(renderable.uid);
        }
        if (gpuContext.isBatchable) {
          this.initBatchesForRenderable(renderable);
        }
        renderable.view.batched = gpuContext.isBatchable;
      }
      // Batchable graphics functions
      addToBatcher(renderable, instructionSet) {
        const batchPipe = this.renderer.renderPipes.batch;
        const batches = this.getBatchesForRenderable(renderable);
        for (let i = 0; i < batches.length; i++) {
          const batch = batches[i];
          batchPipe.addToBatch(batch, instructionSet);
        }
      }
      getBatchesForRenderable(renderable) {
        return this.renderableBatchesHash[renderable.uid] || this.initBatchesForRenderable(renderable);
      }
      initBatchesForRenderable(renderable) {
        const context = renderable.view.context;
        const gpuContext = this.renderer.graphicsContext.getGpuContext(context);
        const batches = gpuContext.batches.map((batch) => {
          const batchClone = BigPool.get(BatchableGraphics);
          batch.copyTo(batchClone);
          batchClone.renderable = renderable;
          return batchClone;
        });
        this.renderableBatchesHash[renderable.uid] = batches;
        renderable.on("destroyed", () => {
          this.destroyRenderable(renderable);
        });
        return batches;
      }
      destroyRenderable(renderable) {
        this.removeBatchForRenderable(renderable.uid);
      }
      removeBatchForRenderable(renderableUid) {
        this.renderableBatchesHash[renderableUid].forEach((batch) => {
          BigPool.return(batch);
        });
        this.renderableBatchesHash[renderableUid] = null;
      }
      destroy() {
        this.renderer = null;
        this.shader.destroy();
        this.shader = null;
        this.adaptor.destroy();
        this.adaptor = null;
        this.state = null;
        for (const i in this.renderableBatchesHash) {
          this.removeBatchForRenderable(i);
        }
        this.renderableBatchesHash = null;
      }
    };
    GraphicsPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "graphics"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/Filter.mjs
var _Filter, Filter;
var init_Filter = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/Filter.mjs"() {
    init_Shader();
    init_State();
    _Filter = class extends Shader {
      constructor(options) {
        options = { ..._Filter.defaultOptions, ...options };
        super({
          gpuProgram: options.gpuProgram,
          glProgram: options.glProgram,
          resources: options.resources
        });
        this.enabled = true;
        this._state = State.for2d();
        this.padding = options.padding;
        if (typeof options.antialias === "boolean") {
          this.antialias = options.antialias ? "on" : "off";
        } else {
          this.antialias = options.antialias ?? "inherit";
        }
        this.resolution = options.resolution;
        this.blendRequired = options.blendRequired;
      }
      /**
       * Applies the filter
       * @param filterManager - The renderer to retrieve the filter from
       * @param input - The input render target.
       * @param output - The target to output to.
       * @param clearMode - Should the output be cleared before rendering to it
       */
      apply(filterManager, input, output, clearMode) {
        filterManager.applyFilter(this, input, output, clearMode);
      }
      /**
       * Sets the blend mode of the filter.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      get blendMode() {
        return this._state.blendMode;
      }
      set blendMode(value) {
        this._state.blendMode = value;
      }
    };
    Filter = _Filter;
    Filter.defaultOptions = {
      blendMode: "normal",
      resolution: 1,
      padding: 0,
      antialias: "inherit",
      blendRequired: false
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/mask/mask.mjs
var fragment;
var init_mask = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/mask/mask.mjs"() {
    fragment = "in vec2 vMaskCoord;\nin vec2 vTextureCoord;\n\nuniform sampler2D myTexture;\nuniform sampler2D mapTexture;\n\nuniform float alpha;\nuniform vec4 maskClamp;\n\nout vec4 fragColor;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    // TODO look into why this is needed\n    float npmAlpha = alpha; \n    vec4 original = texture(myTexture, vTextureCoord);\n    vec4 masky = texture(mapTexture, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    fragColor = original;\n}\n";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/mask/mask2.mjs
var vertex;
var init_mask2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/mask/mask2.mjs"() {
    vertex = "in vec2 aPosition;\n\nout vec2 vTextureCoord;\nout vec2 vMaskCoord;\n\nuniform globalUniforms {\n  mat3 projectionMatrix;\n  mat3 worldTransformMatrix;\n  float worldAlpha;\n};\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nuniform mat3 filterMatrix;\n\nvec4 filterVertexPosition(  vec2 aPosition )\n{\n    vec2 position = aPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord(  vec2 aPosition )\n{\n    return aPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvec2 getFilterCoord( vec2 aPosition )\n{\n    return  ( filterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}   \n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition(aPosition);\n    vTextureCoord = filterTextureCoord(aPosition);\n    vMaskCoord = getFilterCoord(aPosition);\n}\n";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/mask/mask3.mjs
var source;
var init_mask3 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/mask/mask3.mjs"() {
    source = "struct GlobalUniforms {\n  projectionMatrix:mat3x3<f32>,\n  worldTransformMatrix:mat3x3<f32>,\n  worldAlpha: f32\n}\n\nstruct GlobalFilterUniforms {\n  inputSize:vec4<f32>,\n  inputPixel:vec4<f32>,\n  inputClamp:vec4<f32>,\n  outputFrame:vec4<f32>,\n  backgroundFrame:vec4<f32>,\n  globalFrame:vec4<f32>,\n};\n\nstruct MaskUniforms {\n  filterMatrix:mat3x3<f32>,\n  maskClamp:vec4<f32>,\n  alpha:f32,\n};\n\n\n\n@group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n\n@group(1) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(1) @binding(1) var myTexture: texture_2d<f32>;\n@group(1) @binding(2) var mySampler : sampler;\n@group(1) @binding(3) var backTexture: texture_2d<f32>;\n\n@group(2) @binding(0) var<uniform> filterUniforms : MaskUniforms;\n@group(2) @binding(1) var mapTexture: texture_2d<f32>;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) backgroundUv : vec2<f32>,\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;\n\n    return vec4((globalUniforms.projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);\n}\n\nfn filterBackgroundTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * gfu.backgroundFrame.zw;\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  \n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.filterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n\n  \n  return gfu.globalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var maskClamp = filterUniforms.maskClamp;\n\n     var clip = step(3.5,\n        step(maskClamp.x, filterUv.x) +\n        step(maskClamp.y, filterUv.y) +\n        step(filterUv.x, maskClamp.z) +\n        step(filterUv.y, maskClamp.w));\n\n    var mask = textureSample(mapTexture, mySampler, filterUv);\n    var source = textureSample(myTexture, mySampler, uv);\n    \n    var npmAlpha = 0.0;\n\n    var alphaMul = 1.0 - npmAlpha * (1.0 - mask.a);\n\n   \n    //return source * (alphaMul * masky.r * alpha * clip);\n    return source  * (alphaMul * mask.r) * clip;//  * (alphaMul * mask.r) * clip;// * filterUniforms.alpha * clip);\n}";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/mask/MaskFilter.mjs
var MaskFilter;
var init_MaskFilter = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/mask/MaskFilter.mjs"() {
    init_Matrix();
    init_GlProgram();
    init_GpuProgram();
    init_UniformGroup();
    init_TextureMatrix();
    init_Filter();
    init_mask();
    init_mask2();
    init_mask3();
    MaskFilter = class extends Filter {
      constructor({ sprite }) {
        const textureMatrix = new TextureMatrix(sprite.texture);
        const filterUniforms = new UniformGroup({
          filterMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          maskClamp: { value: textureMatrix.uClampFrame, type: "vec4<f32>" },
          alpha: { value: 1, type: "f32" }
        });
        const gpuProgram = new GpuProgram({
          vertex: {
            source,
            entryPoint: "mainVertex"
          },
          fragment: {
            source,
            entryPoint: "mainFragment"
          }
        });
        const glProgram = GlProgram.from({
          vertex,
          fragment,
          name: "mask-filter"
        });
        super({
          gpuProgram,
          glProgram,
          resources: {
            filterUniforms,
            mapTexture: sprite.texture.source
          }
        });
        this.sprite = sprite;
        this.textureMatrix = textureMatrix;
      }
      apply(filterManager, input, output, clearMode) {
        this.textureMatrix.texture = this.sprite.texture;
        filterManager.calculateSpriteMatrix(
          this.resources.filterUniforms.uniforms.filterMatrix,
          this.sprite
        ).prepend(this.textureMatrix.mapCoord);
        this.resources.mapTexture = this.sprite.texture.source;
        filterManager.applyFilter(this, input, output, clearMode);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/LayerRenderable.mjs
var LayerRenderable;
var init_LayerRenderable = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/LayerRenderable.mjs"() {
    init_eventemitter3();
    init_Matrix();
    init_Container();
    LayerRenderable = class extends eventemitter3_default {
      constructor({ original, view }) {
        super();
        this.uid = getRenderableUID();
        this.view = view;
        this.original = original;
        this.layerTransform = new Matrix();
        this.layerColor = 4294967295;
        this.layerVisibleRenderable = 3;
        this.view.owner = this;
      }
      get layerBlendMode() {
        return this.original.layerBlendMode;
      }
      onViewUpdate() {
        this.didViewUpdate = true;
        this.original.layerGroup.onChildViewUpdate(this);
      }
      get isRenderable() {
        return this.original.isRenderable;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/utils/buildInstructions.mjs
function buildInstructions(layerGroup, renderPipes3) {
  const root = layerGroup.root;
  const instructionSet = layerGroup.instructionSet;
  instructionSet.reset();
  renderPipes3.batch.buildStart(instructionSet);
  renderPipes3.blendMode.buildStart();
  renderPipes3.colorMask.buildStart();
  if (layerGroup.root.view) {
    const proxyRenderable = layerGroup.proxyRenderable ?? initProxyRenderable(layerGroup);
    if (proxyRenderable) {
      renderPipes3.blendMode.setBlendMode(proxyRenderable, proxyRenderable.layerBlendMode, instructionSet);
      renderPipes3[proxyRenderable.view.type].addRenderable(proxyRenderable, instructionSet);
    }
  }
  const children = root.children;
  const length = children.length;
  for (let i = 0; i < length; i++) {
    collectAllRenderables(children[i], instructionSet, renderPipes3);
  }
  renderPipes3.batch.buildEnd(instructionSet);
  renderPipes3.blendMode.buildEnd(instructionSet);
}
function collectAllRenderables(container, instructionSet, rendererPipes) {
  if (container.layerVisibleRenderable < 3 || !container.includeInBuild)
    return;
  if (container.isSimple) {
    collectAllRenderablesSimple(container, instructionSet, rendererPipes);
  } else {
    collectAllRenderablesAdvanced(container, instructionSet, rendererPipes);
  }
}
function collectAllRenderablesSimple(container, instructionSet, renderPipes3) {
  const view = container.view;
  if (view) {
    renderPipes3.blendMode.setBlendMode(container, container.layerBlendMode, instructionSet);
    container.didViewUpdate = false;
    const rp = renderPipes3;
    rp[view.type].addRenderable(container, instructionSet);
  }
  if (!container.isLayerRoot) {
    const children = container.children;
    const length = children.length;
    for (let i = 0; i < length; i++) {
      collectAllRenderables(children[i], instructionSet, renderPipes3);
    }
  }
}
function collectAllRenderablesAdvanced(container, instructionSet, renderPipes3) {
  for (let i = 0; i < container.effects.length; i++) {
    const effect = container.effects[i];
    renderPipes3[effect.pipe].push(effect, container, instructionSet);
  }
  if (container.isLayerRoot) {
    renderPipes3.layer.addLayerGroup(container.layerGroup, instructionSet);
  } else {
    const view = container.view;
    if (view) {
      renderPipes3.blendMode.setBlendMode(container, container.layerBlendMode, instructionSet);
      container.didViewUpdate = false;
      renderPipes3[view.type].addRenderable(container, instructionSet);
    }
    const children = container.children;
    if (children.length) {
      for (let i = 0; i < children.length; i++) {
        collectAllRenderables(children[i], instructionSet, renderPipes3);
      }
    }
  }
  for (let i = container.effects.length - 1; i >= 0; i--) {
    const effect = container.effects[i];
    renderPipes3[effect.pipe].pop(effect, container, instructionSet);
  }
}
function initProxyRenderable(layerGroup) {
  const root = layerGroup.root;
  if (root.view) {
    layerGroup.proxyRenderable = new LayerRenderable({
      original: root,
      view: root.view
    });
  }
}
var init_buildInstructions = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/utils/buildInstructions.mjs"() {
    init_LayerRenderable();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mask/shared/AlphaMaskPipe.mjs
var tempBounds3, AlphaMaskEffect, AlphaMaskPipe;
var init_AlphaMaskPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mask/shared/AlphaMaskPipe.mjs"() {
    init_Extensions();
    init_PoolGroup();
    init_FilterEffect();
    init_MaskFilter();
    init_Texture();
    init_TexturePool();
    init_Bounds();
    init_getGlobalBounds();
    init_buildInstructions();
    init_Sprite();
    tempBounds3 = new Bounds();
    AlphaMaskEffect = class extends FilterEffect {
      constructor() {
        super({
          filters: [new MaskFilter({
            sprite: new Sprite(Texture.EMPTY)
          })]
        });
      }
      get sprite() {
        return this.filters[0].sprite;
      }
      set sprite(value) {
        this.filters[0].sprite = value;
      }
    };
    AlphaMaskPipe = class {
      constructor(renderer) {
        this.activeMaskStage = [];
        this.renderer = renderer;
      }
      push(mask, maskedContainer, instructionSet) {
        const renderer = this.renderer;
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          type: "alphaMask",
          action: "pushMaskBegin",
          mask,
          canBundle: false,
          maskedContainer
        });
        if (mask.renderMaskToTexture) {
          const maskContainer = mask.mask;
          maskContainer.includeInBuild = true;
          collectAllRenderables(
            maskContainer,
            instructionSet,
            renderer.renderPipes
          );
          maskContainer.includeInBuild = false;
        }
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          type: "alphaMask",
          action: "pushMaskEnd",
          mask,
          maskedContainer,
          canBundle: false
        });
      }
      pop(mask, _maskedContainer, instructionSet) {
        const renderer = this.renderer;
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          type: "alphaMask",
          action: "popMaskEnd",
          mask,
          canBundle: false
        });
      }
      execute(instruction) {
        const renderer = this.renderer;
        const renderMask = instruction.mask.renderMaskToTexture;
        if (instruction.action === "pushMaskBegin") {
          const filterEffect = BigPool.get(AlphaMaskEffect);
          if (renderMask) {
            instruction.mask.mask.measurable = true;
            const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds3);
            instruction.mask.mask.measurable = false;
            bounds.ceil();
            const filterTexture = TexturePool.getOptimalTexture(
              bounds.width,
              bounds.height,
              1,
              false
            );
            const renderTarget = renderer.renderTarget.push(filterTexture, true);
            renderer.globalUniforms.push({
              projectionMatrix: renderTarget.projectionMatrix,
              offset: bounds,
              worldColor: 4294967295
            });
            const sprite = filterEffect.sprite;
            sprite.texture = filterTexture;
            sprite.worldTransform.tx = bounds.minX;
            sprite.worldTransform.ty = bounds.minY;
            this.activeMaskStage.push({
              filterEffect,
              maskedContainer: instruction.maskedContainer,
              filterTexture
            });
          } else {
            filterEffect.sprite = instruction.mask.mask;
            this.activeMaskStage.push({
              filterEffect,
              maskedContainer: instruction.maskedContainer
            });
          }
        } else if (instruction.action === "pushMaskEnd") {
          const maskData = this.activeMaskStage[this.activeMaskStage.length - 1];
          if (renderMask) {
            renderer.renderTarget.pop();
            renderer.globalUniforms.pop();
          }
          renderer.filter.push({
            type: "filter",
            action: "pushFilter",
            container: maskData.maskedContainer,
            filterEffect: maskData.filterEffect,
            canBundle: false
          });
        } else if (instruction.action === "popMaskEnd") {
          renderer.filter.pop();
          const maskData = this.activeMaskStage.pop();
          if (renderMask) {
            TexturePool.returnTexture(maskData.filterTexture);
          }
          BigPool.return(maskData.filterEffect);
        }
      }
      destroy() {
        this.renderer = null;
        this.activeMaskStage = null;
      }
    };
    AlphaMaskPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "alphaMask"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mask/shared/ColorMaskPipe.mjs
var ColorMaskPipe;
var init_ColorMaskPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mask/shared/ColorMaskPipe.mjs"() {
    init_Extensions();
    ColorMaskPipe = class {
      constructor(renderer) {
        this.colorStack = [];
        this.colorStackIndex = 0;
        this.currentColor = 0;
        this.renderer = renderer;
      }
      buildStart() {
        this.colorStack[0] = 15;
        this.colorStackIndex = 1;
        this.currentColor = 15;
      }
      push(mask, _container, instructionSet) {
        const renderer = this.renderer;
        renderer.renderPipes.batch.break(instructionSet);
        const colorStack = this.colorStack;
        colorStack[this.colorStackIndex] = colorStack[this.colorStackIndex - 1] & mask.mask;
        const currentColor = this.colorStack[this.colorStackIndex];
        if (currentColor !== this.currentColor) {
          this.currentColor = currentColor;
          instructionSet.add({
            type: "colorMask",
            colorMask: currentColor,
            canBundle: false
          });
        }
        this.colorStackIndex++;
      }
      pop(_mask, _container, instructionSet) {
        const renderer = this.renderer;
        renderer.renderPipes.batch.break(instructionSet);
        const colorStack = this.colorStack;
        this.colorStackIndex--;
        const currentColor = colorStack[this.colorStackIndex - 1];
        if (currentColor !== this.currentColor) {
          this.currentColor = currentColor;
          instructionSet.add({
            type: "colorMask",
            colorMask: currentColor,
            canBundle: false
          });
        }
      }
      execute(instruction) {
        const renderer = this.renderer;
        renderer.colorMask.setMask(instruction.colorMask);
      }
      destroy() {
        this.colorStack = null;
      }
    };
    ColorMaskPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "colorMask"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs
var STENCIL_MODES;
var init_const7 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs"() {
    STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {
      STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";
      STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";
      STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";
      STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 3] = "RENDERING_MASK_REMOVE";
      STENCIL_MODES2[STENCIL_MODES2["NONE"] = 4] = "NONE";
      return STENCIL_MODES2;
    })(STENCIL_MODES || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mask/shared/StencilMaskPipe.mjs
var StencilMaskPipe;
var init_StencilMaskPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mask/shared/StencilMaskPipe.mjs"() {
    init_Extensions();
    init_const7();
    init_buildInstructions();
    StencilMaskPipe = class {
      constructor(renderer) {
        this.maskStackHash = {};
        this.maskHash = /* @__PURE__ */ new WeakMap();
        this.renderer = renderer;
      }
      push(mask, _container, instructionSet) {
        const renderer = this.renderer;
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          type: "stencilMask",
          action: "pushMaskBegin",
          mask,
          canBundle: false
        });
        const maskContainer = mask.mask;
        maskContainer.includeInBuild = true;
        if (!this.maskHash.has(mask)) {
          this.maskHash.set(mask, {
            instructionsStart: 0,
            instructionsLength: 0
          });
        }
        const maskData = this.maskHash.get(mask);
        maskData.instructionsStart = instructionSet.instructionSize;
        collectAllRenderables(
          maskContainer,
          instructionSet,
          renderer.renderPipes
        );
        maskContainer.includeInBuild = false;
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          type: "stencilMask",
          action: "pushMaskEnd",
          mask,
          canBundle: false
        });
        const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;
        maskData.instructionsLength = instructionsLength;
        if (this.maskStackHash[_container.uid] === void 0) {
          this.maskStackHash[_container.uid] = 0;
        }
        this.maskStackHash[_container.uid]++;
      }
      pop(mask, _container, instructionSet) {
        const renderer = this.renderer;
        this.maskStackHash[_container.uid]--;
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          type: "stencilMask",
          action: "popMaskBegin",
          canBundle: false
        });
        const maskData = this.maskHash.get(mask);
        if (this.maskStackHash[_container.uid]) {
          for (let i = 0; i < maskData.instructionsLength; i++) {
            instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];
          }
        }
        instructionSet.add({
          type: "stencilMask",
          action: "popMaskEnd",
          canBundle: false
        });
      }
      execute(instruction) {
        const renderer = this.renderer;
        const currentRenderTargetUid = renderer.renderTarget.renderTarget.uid;
        let maskStackIndex = this.maskStackHash[currentRenderTargetUid] ?? 0;
        if (instruction.action === "pushMaskBegin") {
          maskStackIndex++;
          renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);
          renderer.colorMask.setMask(0);
        } else if (instruction.action === "pushMaskEnd") {
          renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
          renderer.colorMask.setMask(15);
        } else if (instruction.action === "popMaskBegin") {
          maskStackIndex--;
          if (maskStackIndex !== 0) {
            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);
            renderer.colorMask.setMask(0);
          }
        } else if (instruction.action === "popMaskEnd") {
          if (maskStackIndex === 0) {
            renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);
          } else {
            renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
          }
          renderer.colorMask.setMask(15);
        }
        this.maskStackHash[currentRenderTargetUid] = maskStackIndex;
      }
      destroy() {
        this.renderer = null;
        this.maskStackHash = null;
        this.maskHash = null;
      }
    };
    StencilMaskPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "stencilMask"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mesh/shared/BatchableMesh.mjs
var BatchableMesh;
var init_BatchableMesh = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mesh/shared/BatchableMesh.mjs"() {
    BatchableMesh = class {
      constructor() {
        this.batcher = null;
        this.batch = null;
      }
      get blendMode() {
        return this.renderable.layerBlendMode;
      }
      reset() {
        this.renderable = null;
        this.texture = null;
        this.batcher = null;
        this.batch = null;
      }
      packIndex(indexBuffer, index, indicesOffset) {
        const indices = this.renderable.view.geometry.indices;
        for (let i = 0; i < indices.length; i++) {
          indexBuffer[index++] = indices[i] + indicesOffset;
        }
      }
      packAttributes(float32View, uint32View, index, textureId) {
        const renderable = this.renderable;
        const geometry = this.renderable.view.geometry;
        const wt = renderable.layerTransform;
        const a = wt.a;
        const b = wt.b;
        const c = wt.c;
        const d2 = wt.d;
        const tx = wt.tx;
        const ty = wt.ty;
        const positions = geometry.positions;
        const uvs = geometry.uvs;
        const abgr = renderable.layerColor;
        for (let i = 0; i < positions.length; i += 2) {
          const x2 = positions[i];
          const y = positions[i + 1];
          float32View[index++] = a * x2 + c * y + tx;
          float32View[index++] = b * x2 + d2 * y + ty;
          float32View[index++] = uvs[i];
          float32View[index++] = uvs[i + 1];
          uint32View[index++] = abgr;
          float32View[index++] = textureId;
        }
      }
      get vertexSize() {
        return this.renderable.view.geometry.positions.length / 2;
      }
      get indexSize() {
        return this.renderable.view.geometry.indices.length;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mesh/gl/mesh-default.mjs
var programFrag2;
var init_mesh_default = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mesh/gl/mesh-default.mjs"() {
    programFrag2 = "in vec2 vTextureCoord;\nin vec4 vColor;\n\nuniform sampler2D uTexture;\n\nout vec4 outColor;\n\nvoid main(void){\n   outColor = texture(uTexture, vTextureCoord) * vColor;\n}";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mesh/gl/mesh-default2.mjs
var programVert2;
var init_mesh_default2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mesh/gl/mesh-default2.mjs"() {
    programVert2 = "\nin vec2 aPosition;\nin vec2 aUV;\n\nuniform globalUniforms {\n  mat3 projectionMatrix;\n  mat3 worldTransformMatrix;\n  float worldAlpha;\n};\n\nuniform mat3 transformMatrix;\nuniform vec4 color;\n\nout vec2 vTextureCoord;\nout vec4 vColor;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * worldTransformMatrix * transformMatrix * vec3(aPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aUV;\n    \n    vColor = vec4(color.rgb * color.a, color.a) * worldAlpha;\n}";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mesh/gpu/mesh-default.mjs
var programWgsl2;
var init_mesh_default3 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mesh/gpu/mesh-default.mjs"() {
    programWgsl2 = "struct GlobalUniforms {\n  projectionMatrix:mat3x3<f32>,\n  worldTransformMatrix:mat3x3<f32>,\n  worldAlpha: f32\n}\n\nstruct LocalUniforms {\n  transformMatrix:mat3x3<f32>,\n  color:vec4<f32>\n}\n\n\n@group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n@group(1) @binding(0) var<uniform> localUniforms: LocalUniforms;\n\n@group(2) @binding(0) var uTexture: texture_2d<f32>;\n@group(2) @binding(1) var uSampler: sampler;\n\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) color : vec4<f32>,\n  };\n\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n  @location(1) aUV : vec2<f32>,\n) -> VSOutput {\n\n    var  mvpMatrix = globalUniforms.projectionMatrix * globalUniforms.worldTransformMatrix * localUniforms.transformMatrix;\n\n    var  colorOut = localUniforms.color;\n\n    colorOut.r *= colorOut.a;\n    colorOut.g *= colorOut.a;\n    colorOut.b *= colorOut.a;\n    \n  return VSOutput(\n    vec4<f32>((mvpMatrix * vec3<f32>(aPosition, 1.0)).xy, 0.0, 1.0),\n    aUV,\n    colorOut,\n  );\n};\n\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) color:vec4<f32>,\n) -> @location(0) vec4<f32> {\n\n  return textureSample(uTexture, uSampler, uv) * color;\n  \n}";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mesh/shared/MeshShader.mjs
var MeshShader;
var init_MeshShader = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mesh/shared/MeshShader.mjs"() {
    init_GlProgram();
    init_GpuProgram();
    init_Shader();
    init_mesh_default();
    init_mesh_default2();
    init_mesh_default3();
    MeshShader = class extends Shader {
      constructor(options) {
        const glProgram = GlProgram.from({
          vertex: programVert2,
          fragment: programFrag2,
          name: "mesh-default"
        });
        const gpuProgram = GpuProgram.from({
          vertex: {
            source: programWgsl2,
            entryPoint: "mainVertex"
          },
          fragment: {
            source: programWgsl2,
            entryPoint: "mainFragment"
          }
        });
        super({
          glProgram,
          gpuProgram,
          resources: {
            uTexture: options.texture.source,
            uSampler: options.texture.style
          }
        });
      }
      get texture() {
        return this._texture;
      }
      set texture(value) {
        if (this._texture === value)
          return;
        this._texture = value;
        this.resources.uTexture = value.source;
        this.resources.uSampler = value.style;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mesh/shared/MeshPipe.mjs
var MeshPipe;
var init_MeshPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mesh/shared/MeshPipe.mjs"() {
    init_Extensions();
    init_Matrix();
    init_PoolGroup();
    init_BindGroup();
    init_UniformGroup();
    init_State();
    init_Texture();
    init_BatchableMesh();
    init_MeshShader();
    MeshPipe = class {
      constructor(renderer, adaptor) {
        this.localUniforms = new UniformGroup({
          transformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          color: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }
        });
        this.localUniformsBindGroup = new BindGroup({
          0: this.localUniforms
        });
        this.meshShader = new MeshShader({
          texture: Texture.EMPTY
        });
        this.state = State.for2d();
        this.renderableHash = {};
        this.gpuBatchableMeshHash = {};
        this.renderer = renderer;
        this.adaptor = adaptor;
      }
      validateRenderable(renderable) {
        const renderableData = this.getRenderableData(renderable);
        const wasBatched = renderableData.batched;
        const isBatched = renderable.view.batched;
        renderableData.batched = isBatched;
        if (wasBatched !== isBatched) {
          return true;
        } else if (isBatched) {
          const geometry = renderable.view._geometry;
          if (geometry.indices.length !== renderableData.indexSize || geometry.positions.length !== renderableData.vertexSize) {
            renderableData.indexSize = geometry.indices.length;
            renderableData.vertexSize = geometry.positions.length;
            return true;
          }
          const batchableMesh = this.getBatchableMesh(renderable);
          const texture = renderable.view.texture;
          if (batchableMesh.texture._source !== texture._source) {
            if (batchableMesh.texture._source !== texture._source) {
              return batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);
            }
          }
        }
        return false;
      }
      addRenderable(renderable, instructionSet) {
        const batcher = this.renderer.renderPipes.batch;
        const { batched } = this.getRenderableData(renderable);
        if (batched) {
          const gpuBatchableMesh = this.getBatchableMesh(renderable);
          gpuBatchableMesh.texture = renderable.view._texture;
          batcher.addToBatch(gpuBatchableMesh, instructionSet);
        } else {
          batcher.break(instructionSet);
          instructionSet.add({
            type: "mesh",
            renderable
          });
        }
      }
      updateRenderable(renderable) {
        if (renderable.view.batched) {
          const gpuBatchableMesh = this.gpuBatchableMeshHash[renderable.uid];
          gpuBatchableMesh.texture = renderable.view._texture;
          gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);
        }
      }
      destroyRenderable(renderable) {
        this.renderableHash[renderable.uid] = null;
        const gpuMesh = this.gpuBatchableMeshHash[renderable.uid];
        BigPool.return(gpuMesh);
        this.gpuBatchableMeshHash[renderable.uid] = null;
      }
      execute({ renderable }) {
        if (!renderable.isRenderable)
          return;
        this.adaptor.execute(this, renderable);
      }
      getRenderableData(renderable) {
        return this.renderableHash[renderable.uid] || this.initRenderableData(renderable);
      }
      initRenderableData(renderable) {
        const view = renderable.view;
        this.renderableHash[renderable.uid] = {
          batched: view.batched,
          indexSize: view._geometry.indices.length,
          vertexSize: view._geometry.positions.length
        };
        renderable.on("destroyed", () => {
          this.destroyRenderable(renderable);
        });
        return this.renderableHash[renderable.uid];
      }
      getBatchableMesh(renderable) {
        return this.gpuBatchableMeshHash[renderable.uid] || this.initBatchableMesh(renderable);
      }
      initBatchableMesh(renderable) {
        const gpuMesh = BigPool.get(BatchableMesh);
        gpuMesh.renderable = renderable;
        gpuMesh.texture = renderable.view._texture;
        this.gpuBatchableMeshHash[renderable.uid] = gpuMesh;
        gpuMesh.renderable = renderable;
        return gpuMesh;
      }
      destroy() {
        for (const i in this.gpuBatchableMeshHash) {
          if (this.gpuBatchableMeshHash[i]) {
            BigPool.return(this.gpuBatchableMeshHash[i]);
          }
        }
        this.gpuBatchableMeshHash = null;
        this.renderableHash = null;
        this.localUniforms = null;
        this.localUniformsBindGroup = null;
        this.meshShader.destroy();
        this.meshShader = null;
        this.adaptor = null;
        this.renderer = null;
        this.state = null;
      }
    };
    MeshPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "mesh"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/utils/executeInstructions.mjs
function executeInstructions(layerGroup, renderer) {
  const instructionSet = layerGroup.instructionSet;
  const instructions = instructionSet.instructions;
  for (let i = 0; i < instructionSet.instructionSize; i++) {
    const instruction = instructions[i];
    renderer[instruction.type].execute(instruction);
  }
}
var init_executeInstructions = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/utils/executeInstructions.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/LayerPipe.mjs
var LayerPipe;
var init_LayerPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/LayerPipe.mjs"() {
    init_Extensions();
    init_executeInstructions();
    LayerPipe = class {
      constructor(renderer) {
        this.renderer = renderer;
      }
      addLayerGroup(layerGroup, instructionSet) {
        this.renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add(layerGroup);
      }
      execute(layerGroup) {
        if (!layerGroup.isRenderable)
          return;
        this.renderer.globalUniforms.push({
          projectionMatrix: this.renderer.renderTarget.renderTarget.projectionMatrix,
          worldTransformMatrix: layerGroup.worldTransform,
          worldColor: layerGroup.worldColor
        });
        executeInstructions(layerGroup, this.renderer.renderPipes);
        this.renderer.globalUniforms.pop();
      }
      destroy() {
        this.renderer = null;
      }
    };
    LayerPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "layer"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/utils/collectLayerGroups.mjs
function collectLayerGroups(renderGroup, out2 = []) {
  out2.push(renderGroup);
  for (let i = 0; i < renderGroup.layerGroupChildren.length; i++) {
    collectLayerGroups(renderGroup.layerGroupChildren[i], out2);
  }
  return out2;
}
var init_collectLayerGroups = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/utils/collectLayerGroups.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/utils/updateLayerGroupTransforms.mjs
function updateLayerGroupTransforms(layerGroup, updateChildRenderGroups = false) {
  updateLayerTransform(layerGroup);
  const childrenToUpdate = layerGroup.childrenToUpdate;
  const updateTick = layerGroup.updateTick;
  layerGroup.updateTick++;
  for (const j2 in childrenToUpdate) {
    const childrenAtDepth = childrenToUpdate[j2];
    const list = childrenAtDepth.list;
    const index = childrenAtDepth.index;
    for (let i = 0; i < index; i++) {
      updateTransformAndChildren(list[i], updateTick, 0);
    }
    childrenAtDepth.index = 0;
  }
  if (updateChildRenderGroups) {
    for (let i = 0; i < layerGroup.layerGroupChildren.length; i++) {
      updateLayerGroupTransforms(layerGroup.layerGroupChildren[i], updateChildRenderGroups);
    }
  }
}
function updateLayerTransform(layerGroup) {
  if (layerGroup.layerGroupParent) {
    layerGroup.worldTransform.appendFrom(
      layerGroup.root.layerTransform,
      layerGroup.layerGroupParent.worldTransform
    );
    layerGroup.worldColor = mixColors(
      layerGroup.root.layerColor,
      layerGroup.layerGroupParent.worldColor
    );
  } else {
    layerGroup.worldTransform.copyFrom(layerGroup.root.layerTransform);
    layerGroup.worldColor = layerGroup.root.localColor;
  }
}
function updateTransformAndChildren(container, updateTick, updateFlags) {
  if (updateTick === container.updateTick)
    return;
  container.updateTick = updateTick;
  container.didChange = false;
  const localTransform = container.localTransform;
  updateLocalTransform(localTransform, container);
  const parent = container.parent;
  if (parent && !parent.isLayerRoot) {
    updateFlags = updateFlags | container.updateFlags;
    container.layerTransform.appendFrom(
      localTransform,
      parent.layerTransform
    );
    if (updateFlags) {
      updateColorBlendVisibility(container, parent, updateFlags);
    }
  } else {
    updateFlags = container.updateFlags;
    container.layerTransform.copyFrom(localTransform);
    if (updateFlags) {
      updateColorBlendVisibility(container, tempContainer, updateFlags);
    }
  }
  if (!container.isLayerRoot) {
    const children = container.children;
    const length = children.length;
    for (let i = 0; i < length; i++) {
      updateTransformAndChildren(children[i], updateTick, updateFlags);
    }
    const layerGroup = container.layerGroup;
    if (container.view && !layerGroup.structureDidChange) {
      layerGroup.updateRenderable(container);
    }
  }
}
function updateColorBlendVisibility(container, parent, updateFlags) {
  if (updateFlags & UPDATE_COLOR) {
    container.layerColor = mixColors(container.localColor, parent.layerColor);
  }
  if (updateFlags & UPDATE_BLEND) {
    container.layerBlendMode = container.localBlendMode === "inherit" ? parent.layerBlendMode : container.localBlendMode;
  }
  if (updateFlags & UPDATE_VISIBLE) {
    container.layerVisibleRenderable = container.localVisibleRenderable & parent.layerVisibleRenderable;
  }
  container.updateFlags = 0;
}
var tempContainer;
var init_updateLayerGroupTransforms = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/utils/updateLayerGroupTransforms.mjs"() {
    init_Container();
    init_mixColors();
    init_updateLocalTransform();
    tempContainer = new Container();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/utils/validateRenderables.mjs
function validateRenderables(layerGroup, renderPipes3) {
  const { list, index } = layerGroup.childrenRenderablesToUpdate;
  let rebuildRequired = false;
  for (let i = 0; i < index; i++) {
    const container = list[i];
    const renderable = container.view;
    rebuildRequired = renderPipes3[renderable.type].validateRenderable(container);
    if (rebuildRequired) {
      break;
    }
  }
  layerGroup.structureDidChange = rebuildRequired;
  if (rebuildRequired) {
    layerGroup.childrenRenderablesToUpdate.index = 0;
  }
  return rebuildRequired;
}
var init_validateRenderables = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/utils/validateRenderables.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/LayerSystem.mjs
function updateThings(layerGroup) {
  const { list, index } = layerGroup.childrenRenderablesToUpdate;
  for (let i = 0; i < index; i++) {
    const container = list[i];
    if (container.didViewUpdate) {
      layerGroup.updateRenderable(container);
    }
  }
  layerGroup.childrenRenderablesToUpdate.index = 0;
}
var LayerSystem;
var init_LayerSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/scene/LayerSystem.mjs"() {
    init_Extensions();
    init_buildInstructions();
    init_collectLayerGroups();
    init_executeInstructions();
    init_updateLayerGroupTransforms();
    init_validateRenderables();
    LayerSystem = class {
      constructor(renderer) {
        this.renderer = renderer;
      }
      render({ container }) {
        container.layer = true;
        const renderer = this.renderer;
        const layerGroups = collectLayerGroups(container.layerGroup, []);
        const renderPipes3 = renderer.renderPipes;
        for (let i = 0; i < layerGroups.length; i++) {
          const layerGroup = layerGroups[i];
          layerGroup.runOnRender();
          layerGroup.instructionSet.renderPipes = renderPipes3;
          if (!layerGroup.structureDidChange) {
            validateRenderables(layerGroup, renderPipes3);
          }
          updateLayerGroupTransforms(layerGroup);
          if (layerGroup.structureDidChange) {
            layerGroup.structureDidChange = false;
            buildInstructions(layerGroup, renderPipes3);
          } else {
            updateThings(layerGroup);
          }
          renderer.renderPipes.batch.upload(layerGroup.instructionSet);
        }
        renderer.globalUniforms.start(
          {
            projectionMatrix: renderer.renderTarget.rootProjectionMatrix,
            worldTransformMatrix: container.layerGroup.worldTransform
          }
        );
        executeInstructions(container.layerGroup, renderPipes3);
        if (renderPipes3.uniformBatch) {
          renderPipes3.uniformBatch.renderEnd();
          renderPipes3.uniformBuffer.renderEnd();
        }
      }
      destroy() {
      }
    };
    LayerSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "layer"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/sprite/shared/BatchableSprite.mjs
var BatchableSprite;
var init_BatchableSprite = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/sprite/shared/BatchableSprite.mjs"() {
    BatchableSprite = class {
      constructor() {
        this.vertexSize = 4;
        this.indexSize = 6;
        this.location = 0;
        this.batcher = null;
        this.batch = null;
      }
      get blendMode() {
        return this.sprite.layerBlendMode;
      }
      packAttributes(float32View, uint32View, index, textureId) {
        const sprite = this.sprite;
        const texture = this.texture;
        const wt = sprite.layerTransform;
        const a = wt.a;
        const b = wt.b;
        const c = wt.c;
        const d2 = wt.d;
        const tx = wt.tx;
        const ty = wt.ty;
        const bounds = this.bounds;
        const w0 = bounds[0];
        const w1 = bounds[1];
        const h0 = bounds[2];
        const h1 = bounds[3];
        const uvs = texture._layout.uvs;
        const argb = sprite.layerColor;
        float32View[index++] = a * w1 + c * h1 + tx;
        float32View[index++] = d2 * h1 + b * w1 + ty;
        float32View[index++] = uvs.x0;
        float32View[index++] = uvs.y0;
        uint32View[index++] = argb;
        float32View[index++] = textureId;
        float32View[index++] = a * w0 + c * h1 + tx;
        float32View[index++] = d2 * h1 + b * w0 + ty;
        float32View[index++] = uvs.x1;
        float32View[index++] = uvs.y1;
        uint32View[index++] = argb;
        float32View[index++] = textureId;
        float32View[index++] = a * w0 + c * h0 + tx;
        float32View[index++] = d2 * h0 + b * w0 + ty;
        float32View[index++] = uvs.x2;
        float32View[index++] = uvs.y2;
        uint32View[index++] = argb;
        float32View[index++] = textureId;
        float32View[index++] = a * w1 + c * h0 + tx;
        float32View[index++] = d2 * h0 + b * w1 + ty;
        float32View[index++] = uvs.x3;
        float32View[index++] = uvs.y3;
        uint32View[index++] = argb;
        float32View[index++] = textureId;
      }
      packIndex(indexBuffer, index, indicesOffset) {
        indexBuffer[index++] = indicesOffset + 0;
        indexBuffer[index++] = indicesOffset + 1;
        indexBuffer[index++] = indicesOffset + 2;
        indexBuffer[index++] = indicesOffset + 0;
        indexBuffer[index++] = indicesOffset + 2;
        indexBuffer[index++] = indicesOffset + 3;
      }
      reset() {
        this.sprite = null;
        this.texture = null;
        this.batcher = null;
        this.batch = null;
        this.bounds = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/sprite/shared/SpritePipe.mjs
var gpuSpriteHash, SpritePipe;
var init_SpritePipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/sprite/shared/SpritePipe.mjs"() {
    init_Extensions();
    init_PoolGroup();
    init_BatchableSprite();
    SpritePipe = class {
      constructor(renderer) {
        this.gpuSpriteHash = {};
        this.renderer = renderer;
        gpuSpriteHash = this.gpuSpriteHash;
      }
      addRenderable(renderable, instructionSet) {
        const gpuSprite = this.getGpuSprite(renderable);
        if (renderable.view.didUpdate)
          this.updateBatchableSprite(renderable, gpuSprite);
        this.renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
      }
      updateRenderable(renderable) {
        const gpuSprite = gpuSpriteHash[renderable.uid];
        if (renderable.view.didUpdate)
          this.updateBatchableSprite(renderable, gpuSprite);
        gpuSprite.batcher.updateElement(gpuSprite);
      }
      validateRenderable(renderable) {
        const texture = renderable.view._texture;
        const gpuSprite = this.getGpuSprite(renderable);
        if (gpuSprite.texture._source !== texture._source) {
          return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);
        }
        return false;
      }
      destroyRenderable(renderable) {
        const batchableSprite = gpuSpriteHash[renderable.uid];
        BigPool.return(batchableSprite);
        gpuSpriteHash[renderable.uid] = null;
      }
      updateBatchableSprite(renderable, batchableSprite) {
        const view = renderable.view;
        view.didUpdate = false;
        batchableSprite.bounds = view.bounds;
        batchableSprite.texture = view._texture;
      }
      getGpuSprite(renderable) {
        return gpuSpriteHash[renderable.uid] || this.initGPUSprite(renderable);
      }
      initGPUSprite(renderable) {
        const batchableSprite = BigPool.get(BatchableSprite);
        batchableSprite.sprite = renderable;
        batchableSprite.texture = renderable.view._texture;
        batchableSprite.bounds = renderable.view.bounds;
        gpuSpriteHash[renderable.uid] = batchableSprite;
        renderable.view.didUpdate = false;
        renderable.on("destroyed", () => {
          this.destroyRenderable(renderable);
        });
        return batchableSprite;
      }
      destroy() {
        for (const i in this.gpuSpriteHash) {
          BigPool.return(this.gpuSpriteHash[i]);
        }
        this.gpuSpriteHash = null;
        this.renderer = null;
      }
    };
    SpritePipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "sprite"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/GraphicsView.mjs
var UID12, GraphicsView;
var init_GraphicsView = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/GraphicsView.mjs"() {
    init_View();
    init_GraphicsContext();
    UID12 = 0;
    GraphicsView = class {
      constructor(graphicsContext) {
        this.uid = UID12++;
        this.canBundle = true;
        this.owner = emptyViewObserver;
        this.type = "graphics";
        this._context = graphicsContext || new GraphicsContext();
        this._context.on("update", this.onGraphicsContextUpdate, this);
      }
      set context(context) {
        if (context === this._context)
          return;
        this._context.off("update", this.onGraphicsContextUpdate, this);
        this._context = context;
        this._context.on("update", this.onGraphicsContextUpdate, this);
        this.onGraphicsContextUpdate();
      }
      get context() {
        return this._context;
      }
      addBounds(bounds) {
        bounds.addBounds(this._context.bounds);
      }
      containsPoint(point) {
        return this._context.containsPoint(point);
      }
      onGraphicsContextUpdate() {
        this.didUpdate = true;
        this.owner.onViewUpdate();
      }
      /**
       * Destroys this graphics renderable and optionally its context.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context
       * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context
       * @param {boolean} [options.context=false] - Should destroy the context
       */
      destroy(options = false) {
        this.owner = null;
        const destroyContext = typeof options === "boolean" ? options : options?.context;
        if (destroyContext) {
          this._context.destroy(options);
        }
        this._context = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/batchSamplersUniformGroup.mjs
var sampleValues, batchSamplersUniformGroup;
var init_batchSamplersUniformGroup = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/batchSamplersUniformGroup.mjs"() {
    init_const3();
    init_UniformGroup();
    sampleValues = new Int32Array(MAX_TEXTURES);
    for (let i = 0; i < MAX_TEXTURES; i++) {
      sampleValues[i] = i;
    }
    batchSamplersUniformGroup = new UniformGroup({
      uSamplers: { value: sampleValues, type: `array<u32,${MAX_TEXTURES}>` }
    }, { isStatic: true });
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gl/generateBatchGlProgram.mjs
function generateBatchGlProgram({ vertexSrc: vertexSrc4, fragmentSrc: fragmentSrc4, maxTextures, name }) {
  if (fragmentSrc4.indexOf("%count%") < 0) {
    throw new Error('Fragment template must contain "%count%".');
  }
  if (fragmentSrc4.indexOf("%forloop%") < 0) {
    throw new Error('Fragment template must contain "%forloop%".');
  }
  const samplerSrc = generateSampleSrc2(maxTextures);
  fragmentSrc4 = fragmentSrc4.replace(/%count%/gi, `${maxTextures}`);
  fragmentSrc4 = fragmentSrc4.replace(/%forloop%/gi, samplerSrc);
  name = name ? `${name}-` : "";
  const program = new GlProgram({ vertex: vertexSrc4, fragment: fragmentSrc4, name: `${name}batch` });
  return program;
}
function generateSampleSrc2(maxTextures) {
  const src = [];
  for (let i = 0; i < maxTextures; i++) {
    if (i > 0) {
      src.push("else");
    }
    if (i < maxTextures - 1) {
      src.push(`if(vTextureId < ${i}.5)`);
    }
    src.push("{");
    src.push(`	outColor = texture(uSamplers[${i}], vTextureCoord);`);
    src.push("}");
  }
  return src.join("\n");
}
var init_generateBatchGlProgram = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gl/generateBatchGlProgram.mjs"() {
    init_GlProgram();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/sdfShader/sdf-batcher-template.mjs
var fragmentSrc;
var init_sdf_batcher_template = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/sdfShader/sdf-batcher-template.mjs"() {
    fragmentSrc = "in vec2 vTextureCoord;\nin vec4 vColor;\nin float vTextureId;\n\nuniform sampler2D uSamplers[%count%];\nuniform float distance;\n\nout vec4 finalColor;\n\nvoid main(void){\n    vec4 outColor;\n    %forloop%\n\n\n    // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\n   outColor.rgb = outColor.rgb / outColor.a;\n\n    // MSDF\n    float median = outColor.r + outColor.g + outColor.b -\n                    min(outColor.r, min(outColor.g, outColor.b)) -\n                    max(outColor.r, max(outColor.g, outColor.b));\n   \n    // SDF\n    median = min(median, outColor.a);\n\n    float screenPxDistance = distance * (median - 0.5);\n    float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n    if (median < 0.01) {\n        alpha = 0.0;\n    } else if (median > 0.99) {\n        alpha = 1.0;\n    }\n\n    finalColor =  vec4(vColor.rgb * alpha, alpha);\n}\n";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/sdfShader/sdf-batcher-template2.mjs
var vertexSrc;
var init_sdf_batcher_template2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/sdfShader/sdf-batcher-template2.mjs"() {
    vertexSrc = "precision highp float;\nin vec2 aPosition;\nin vec2 aUV;\nin vec4 aColor;\nin float aTextureId;\n\nuniform globalUniforms {\n  mat3 projectionMatrix;\n  mat3 worldTransformMatrix;\n  float worldAlpha;\n};\n\nuniform mat3 transformMatrix;\nuniform vec4 color;\n\nout vec2 vTextureCoord;\nout vec4 vColor;\nout float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * worldTransformMatrix * transformMatrix * vec3(aPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aUV;\n    vTextureId = aTextureId;\n\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a)  * worldAlpha;\n}\n";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/sdfShader/generateDefaultSdfBatchGlProgram.mjs
function generateDefaultSdfBatchGlProgram(maxTextures) {
  return generateBatchGlProgram({
    vertexSrc,
    fragmentSrc,
    maxTextures,
    name: "sdf"
  });
}
var init_generateDefaultSdfBatchGlProgram = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/sdfShader/generateDefaultSdfBatchGlProgram.mjs"() {
    init_generateBatchGlProgram();
    init_sdf_batcher_template();
    init_sdf_batcher_template2();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/sdfShader/sdf-batcher-template3.mjs
var programSrc3;
var init_sdf_batcher_template3 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/sdfShader/sdf-batcher-template3.mjs"() {
    programSrc3 = "struct GlobalUniforms {\n  projectionMatrix:mat3x3<f32>,\n  worldTransformMatrix:mat3x3<f32>,\n  worldAlpha: f32\n}\n\nstruct LocalUniforms {\n  color:vec4<f32>,\n  transformMatrix:mat3x3<f32>,\n  distance: f32\n}\n\n// struct DistanceUniforms {\n//   distance: f32,\n// }\n\n@group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n%bindings%\n@group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n//@group(3) @binding(0) var<uniform> distanceUniforms : DistanceUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) color : vec4<f32>,\n    @location(2) @interpolate(flat) textureId : u32,\n  };\n\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n  @location(1) aUV : vec2<f32>,\n  @location(2) aColor : vec4<f32>,\n  @location(3) aTexture : f32,\n) -> VSOutput {\n\n  var  mvpMatrix = globalUniforms.projectionMatrix * globalUniforms.worldTransformMatrix * localUniforms.transformMatrix;\n\n  var  colorOut = aColor.bgra * localUniforms.color.rgba;\n\n  var alpha = vec4<f32>(\n    colorOut.a * globalUniforms.worldAlpha,\n    colorOut.a * globalUniforms.worldAlpha,\n    colorOut.a * globalUniforms.worldAlpha,\n    globalUniforms.worldAlpha\n  );\n\n  colorOut *= alpha;\n\n\n  return VSOutput(\n    vec4<f32>((mvpMatrix * vec3<f32>(aPosition, 1.0)).xy, 0.0, 1.0),\n    aUV,\n    colorOut,\n    u32(aTexture)\n  );\n};\n\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) color:vec4<f32>,\n  @location(2) @interpolate(flat) textureId: u32,\n) -> @location(0) vec4<f32> {\n\n\n    var uvDx = dpdx(uv);\n    var uvDy = dpdy(uv);\n\n    var outColor:vec4<f32>;\n    \n    %forloop%\n  \n    var dist = outColor.r;\n\n    // MSDF\n  var median = outColor.r + outColor.g + outColor.b -\n      min(outColor.r, min(outColor.g, outColor.b)) -\n      max(outColor.r, max(outColor.g, outColor.b));\n  // SDF\n  median = min(median, outColor.a);\n\n  // on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\n  \n  var screenPxDistance = localUniforms.distance * (median - 0.5);\n  var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n  if (median < 0.01) {\n    alpha = 0.0;\n  } else if (median > 0.99) {\n    alpha = 1.0;\n  }\n\n  return vec4(color.rgb * alpha, alpha);\n};\n";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/sdfShader/generateDefaultSdfBatchProgram.mjs
function generateDefaultSdfBatchProgram(maxTextures) {
  return generateBatchProgram({
    vertex: {
      source: programSrc3,
      entryPoint: "mainVertex"
    },
    fragment: {
      source: programSrc3,
      entryPoint: "mainFragment"
    },
    maxTextures
  });
}
var init_generateDefaultSdfBatchProgram = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/sdfShader/generateDefaultSdfBatchProgram.mjs"() {
    init_generateBatchProgram();
    init_sdf_batcher_template3();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/sdfShader/SdfShader.mjs
var SdfShader;
var init_SdfShader = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/sdfShader/SdfShader.mjs"() {
    init_Matrix();
    init_const3();
    init_Filter();
    init_batchSamplersUniformGroup();
    init_UniformGroup();
    init_generateDefaultSdfBatchGlProgram();
    init_generateDefaultSdfBatchProgram();
    SdfShader = class extends Filter {
      constructor() {
        const uniforms = new UniformGroup({
          color: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          transformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          distance: { value: 4, type: "f32" }
        });
        super({
          glProgram: generateDefaultSdfBatchGlProgram(MAX_TEXTURES),
          gpuProgram: generateDefaultSdfBatchProgram(MAX_TEXTURES),
          resources: {
            localUniforms: uniforms,
            batchSamplers: batchSamplersUniformGroup
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/color/hex.mjs
function hex2rgb(hex, out2 = []) {
  out2[0] = (hex >> 16 & 255) / 255;
  out2[1] = (hex >> 8 & 255) / 255;
  out2[2] = (hex & 255) / 255;
  return out2;
}
function hex2string(hex) {
  let hexString = hex.toString(16);
  hexString = "000000".substring(0, 6 - hexString.length) + hexString;
  return `#${hexString}`;
}
var init_hex = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/color/hex.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs
var CanvasPoolClass, CanvasPool;
var init_CanvasPool = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs"() {
    init_pow2();
    init_settings();
    CanvasPoolClass = class {
      constructor(canvasOptions) {
        this.poolKeyHash = {};
        this.canvasPool = {};
        this.canvasOptions = canvasOptions || {};
        this.enableFullScreen = false;
      }
      /**
       * Creates texture with params that were specified in pool constructor.
       * @param pixelWidth - Width of texture in pixels.
       * @param pixelHeight - Height of texture in pixels.
       */
      createCanvasAndContext(pixelWidth, pixelHeight) {
        const canvas2 = settings.ADAPTER.createCanvas();
        canvas2.width = pixelWidth;
        canvas2.height = pixelHeight;
        const context = canvas2.getContext("2d");
        return { canvas: canvas2, context };
      }
      /**
       * Gets a Power-of-Two render texture or fullScreen texture
       * @param minWidth - The minimum width of the render texture.
       * @param minHeight - The minimum height of the render texture.
       * @param resolution - The resolution of the render texture.
       * @returns The new render texture.
       */
      getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {
        minWidth = Math.ceil(minWidth * resolution - 1e-6);
        minHeight = Math.ceil(minHeight * resolution - 1e-6);
        minWidth = nextPow2(minWidth);
        minHeight = nextPow2(minHeight);
        const key = (minWidth << 17) + (minHeight << 1);
        if (!this.canvasPool[key]) {
          this.canvasPool[key] = [];
        }
        let canvasAndContext = this.canvasPool[key].pop();
        if (!canvasAndContext) {
          canvasAndContext = this.createCanvasAndContext(minWidth, minHeight);
        }
        return canvasAndContext;
      }
      /**
       * Place a render texture back into the pool.
       * @param canvasAndContext
       */
      returnCanvasAndContext(canvasAndContext) {
        const { width, height } = canvasAndContext.canvas;
        const key = (width << 17) + (height << 1);
        this.canvasPool[key].push(canvasAndContext);
      }
      clear() {
        this.canvasPool = {};
      }
    };
    CanvasPool = new CanvasPoolClass();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/const.mjs
var ALPHA_MODES;
var init_const8 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/const.mjs"() {
    ALPHA_MODES = /* @__PURE__ */ ((ALPHA_MODES2) => {
      ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
      ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
      ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
      ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
      ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
      ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
      return ALPHA_MODES2;
    })(ALPHA_MODES || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/canvas/utils/fontStringFromTextStyle.mjs
function fontStringFromTextStyle(style) {
  const fontSizeString = typeof style.fontSize === "number" ? `${style.fontSize}px` : style.fontSize;
  let fontFamilies = style.fontFamily;
  if (!Array.isArray(style.fontFamily)) {
    fontFamilies = style.fontFamily.split(",");
  }
  for (let i = fontFamilies.length - 1; i >= 0; i--) {
    let fontFamily = fontFamilies[i].trim();
    if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
      fontFamily = `"${fontFamily}"`;
    }
    fontFamilies[i] = fontFamily;
  }
  return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
}
var genericFontFamilies;
var init_fontStringFromTextStyle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/canvas/utils/fontStringFromTextStyle.mjs"() {
    genericFontFamilies = [
      "serif",
      "sans-serif",
      "monospace",
      "cursive",
      "fantasy",
      "system-ui"
    ];
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/canvas/CanvasTextMetrics.mjs
var contextSettings, _CanvasTextMetrics, CanvasTextMetrics;
var init_CanvasTextMetrics = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/canvas/CanvasTextMetrics.mjs"() {
    init_settings();
    init_fontStringFromTextStyle();
    contextSettings = {
      // TextMetrics requires getImageData readback for measuring fonts.
      willReadFrequently: true
    };
    _CanvasTextMetrics = class {
      /**
       * Checking that we can use modern canvas 2D API.
       *
       * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.
       * @see PIXI.TextMetrics.experimentalLetterSpacing
       * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing
       * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441
       */
      static get experimentalLetterSpacingSupported() {
        let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;
        if (result !== void 0) {
          const proto = settings.ADAPTER.getCanvasRenderingContext2D().prototype;
          result = _CanvasTextMetrics._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
        }
        return result;
      }
      /**
       * @param text - the text that was measured
       * @param style - the style that was measured
       * @param width - the measured width of the text
       * @param height - the measured height of the text
       * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style
       * @param lineWidths - an array of the line widths for each line matched to `lines`
       * @param lineHeight - the measured line height for this style
       * @param maxLineWidth - the maximum line width for all measured lines
       * @param {PIXI.IFontMetrics} fontProperties - the font properties object from TextMetrics.measureFont
       */
      constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
        this.text = text;
        this.style = style;
        this.width = width;
        this.height = height;
        this.lines = lines;
        this.lineWidths = lineWidths;
        this.lineHeight = lineHeight;
        this.maxLineWidth = maxLineWidth;
        this.fontProperties = fontProperties;
      }
      /**
       * Measures the supplied string of text and returns a Rectangle.
       * @param text - The text to measure.
       * @param style - The text style to use for measuring
       * @param canvas - optional specification of the canvas to use for measuring.
       * @param wordWrap
       * @returns Measured width and height of the text.
       */
      static measureText(text = " ", style, canvas2 = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {
        const textKey = `${text}:${style.styleKey}`;
        if (_CanvasTextMetrics._measurementCache[textKey])
          return _CanvasTextMetrics._measurementCache[textKey];
        const font = fontStringFromTextStyle(style);
        const fontProperties = _CanvasTextMetrics.measureFont(font);
        if (fontProperties.fontSize === 0) {
          fontProperties.fontSize = style.fontSize;
          fontProperties.ascent = style.fontSize;
        }
        const context = _CanvasTextMetrics.__context;
        context.font = font;
        const outputText = wordWrap ? _CanvasTextMetrics.wordWrap(text, style, canvas2) : text;
        const lines = outputText.split(/(?:\r\n|\r|\n)/);
        const lineWidths = new Array(lines.length);
        let maxLineWidth = 0;
        for (let i = 0; i < lines.length; i++) {
          const lineWidth = _CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);
          lineWidths[i] = lineWidth;
          maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        const strokeWidth = style.stroke?.width || 0;
        let width = maxLineWidth + strokeWidth;
        if (style.dropShadow) {
          width += style.dropShadow.distance;
        }
        const lineHeight = style.lineHeight || fontProperties.fontSize + strokeWidth;
        let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth * 2) + (lines.length - 1) * (lineHeight + style.leading);
        if (style.dropShadow) {
          height += style.dropShadow.distance;
        }
        const measurements = new _CanvasTextMetrics(
          text,
          style,
          width,
          height,
          lines,
          lineWidths,
          lineHeight + style.leading,
          maxLineWidth,
          fontProperties
        );
        return measurements;
      }
      static _measureText(text, letterSpacing, context) {
        let useExperimentalLetterSpacing = false;
        if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {
          if (_CanvasTextMetrics.experimentalLetterSpacing) {
            context.letterSpacing = `${letterSpacing}px`;
            context.textLetterSpacing = `${letterSpacing}px`;
            useExperimentalLetterSpacing = true;
          } else {
            context.letterSpacing = "0px";
            context.textLetterSpacing = "0px";
          }
        }
        let width = context.measureText(text).width;
        if (width > 0) {
          if (useExperimentalLetterSpacing) {
            width -= letterSpacing;
          } else {
            width += (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;
          }
        }
        return width;
      }
      /**
       * Applies newlines to a string to have it optimally fit into the horizontal
       * bounds set by the Text object's wordWrapWidth property.
       * @param text - String to apply word wrapping to
       * @param style - the style to use when wrapping
       * @param canvas - optional specification of the canvas to use for measuring.
       * @returns New string with new lines applied where required
       */
      static wordWrap(text, style, canvas2 = _CanvasTextMetrics._canvas) {
        const context = canvas2.getContext("2d", contextSettings);
        let width = 0;
        let line = "";
        let lines = "";
        const cache = /* @__PURE__ */ Object.create(null);
        const { letterSpacing, whiteSpace } = style;
        const collapseSpaces = _CanvasTextMetrics.collapseSpaces(whiteSpace);
        const collapseNewlines = _CanvasTextMetrics.collapseNewlines(whiteSpace);
        let canPrependSpaces = !collapseSpaces;
        const wordWrapWidth = style.wordWrapWidth + letterSpacing;
        const tokens = _CanvasTextMetrics.tokenize(text);
        for (let i = 0; i < tokens.length; i++) {
          let token = tokens[i];
          if (_CanvasTextMetrics.isNewline(token)) {
            if (!collapseNewlines) {
              lines += _CanvasTextMetrics.addLine(line);
              canPrependSpaces = !collapseSpaces;
              line = "";
              width = 0;
              continue;
            }
            token = " ";
          }
          if (collapseSpaces) {
            const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);
            const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);
            if (currIsBreakingSpace && lastIsBreakingSpace) {
              continue;
            }
          }
          const tokenWidth = _CanvasTextMetrics.getFromCache(token, letterSpacing, cache, context);
          if (tokenWidth > wordWrapWidth) {
            if (line !== "") {
              lines += _CanvasTextMetrics.addLine(line);
              line = "";
              width = 0;
            }
            if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {
              const characters = _CanvasTextMetrics.wordWrapSplit(token);
              for (let j2 = 0; j2 < characters.length; j2++) {
                let char = characters[j2];
                let lastChar = char;
                let k2 = 1;
                while (characters[j2 + k2]) {
                  const nextChar = characters[j2 + k2];
                  if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j2, style.breakWords)) {
                    char += nextChar;
                  } else {
                    break;
                  }
                  lastChar = nextChar;
                  k2++;
                }
                j2 += k2 - 1;
                const characterWidth = _CanvasTextMetrics.getFromCache(char, letterSpacing, cache, context);
                if (characterWidth + width > wordWrapWidth) {
                  lines += _CanvasTextMetrics.addLine(line);
                  canPrependSpaces = false;
                  line = "";
                  width = 0;
                }
                line += char;
                width += characterWidth;
              }
            } else {
              if (line.length > 0) {
                lines += _CanvasTextMetrics.addLine(line);
                line = "";
                width = 0;
              }
              const isLastToken = i === tokens.length - 1;
              lines += _CanvasTextMetrics.addLine(token, !isLastToken);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
          } else {
            if (tokenWidth + width > wordWrapWidth) {
              canPrependSpaces = false;
              lines += _CanvasTextMetrics.addLine(line);
              line = "";
              width = 0;
            }
            if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {
              line += token;
              width += tokenWidth;
            }
          }
        }
        lines += _CanvasTextMetrics.addLine(line, false);
        return lines;
      }
      /**
       * Convienience function for logging each line added during the wordWrap method.
       * @param line    - The line of text to add
       * @param newLine - Add new line character to end
       * @returns A formatted line
       */
      static addLine(line, newLine = true) {
        line = _CanvasTextMetrics.trimRight(line);
        line = newLine ? `${line}
` : line;
        return line;
      }
      /**
       * Gets & sets the widths of calculated characters in a cache object
       * @param key            - The key
       * @param letterSpacing  - The letter spacing
       * @param cache          - The cache
       * @param context        - The canvas context
       * @returns The from cache.
       */
      static getFromCache(key, letterSpacing, cache, context) {
        let width = cache[key];
        if (typeof width !== "number") {
          width = _CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;
          cache[key] = width;
        }
        return width;
      }
      /**
       * Determines whether we should collapse breaking spaces.
       * @param whiteSpace - The TextStyle property whiteSpace
       * @returns Should collapse
       */
      static collapseSpaces(whiteSpace) {
        return whiteSpace === "normal" || whiteSpace === "pre-line";
      }
      /**
       * Determines whether we should collapse newLine chars.
       * @param whiteSpace - The white space
       * @returns should collapse
       */
      static collapseNewlines(whiteSpace) {
        return whiteSpace === "normal";
      }
      /**
       * Trims breaking whitespaces from string.
       * @param text - The text
       * @returns Trimmed string
       */
      static trimRight(text) {
        if (typeof text !== "string") {
          return "";
        }
        for (let i = text.length - 1; i >= 0; i--) {
          const char = text[i];
          if (!_CanvasTextMetrics.isBreakingSpace(char)) {
            break;
          }
          text = text.slice(0, -1);
        }
        return text;
      }
      /**
       * Determines if char is a newline.
       * @param char - The character
       * @returns True if newline, False otherwise.
       */
      static isNewline(char) {
        if (typeof char !== "string") {
          return false;
        }
        return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));
      }
      /**
       * Determines if char is a breaking whitespace.
       *
       * It allows one to determine whether char should be a breaking whitespace
       * For example certain characters in CJK langs or numbers.
       * It must return a boolean.
       * @param char - The character
       * @param [_nextChar] - The next character
       * @returns True if whitespace, False otherwise.
       */
      static isBreakingSpace(char, _nextChar) {
        if (typeof char !== "string") {
          return false;
        }
        return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));
      }
      /**
       * Splits a string into words, breaking-spaces and newLine characters
       * @param text - The text
       * @returns A tokenized array
       */
      static tokenize(text) {
        const tokens = [];
        let token = "";
        if (typeof text !== "string") {
          return tokens;
        }
        for (let i = 0; i < text.length; i++) {
          const char = text[i];
          const nextChar = text[i + 1];
          if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics.isNewline(char)) {
            if (token !== "") {
              tokens.push(token);
              token = "";
            }
            tokens.push(char);
            continue;
          }
          token += char;
        }
        if (token !== "") {
          tokens.push(token);
        }
        return tokens;
      }
      /**
       * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
       *
       * It allows one to customise which words should break
       * Examples are if the token is CJK or numbers.
       * It must return a boolean.
       * @param _token - The token
       * @param breakWords - The style attr break words
       * @returns Whether to break word or not
       */
      static canBreakWords(_token, breakWords) {
        return breakWords;
      }
      /**
       * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
       *
       * It allows one to determine whether a pair of characters
       * should be broken by newlines
       * For example certain characters in CJK langs or numbers.
       * It must return a boolean.
       * @param _char - The character
       * @param _nextChar - The next character
       * @param _token - The token/word the characters are from
       * @param _index - The index in the token of the char
       * @param _breakWords - The style attr break words
       * @returns whether to break word or not
       */
      static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
        return true;
      }
      /**
       * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
       *
       * It is called when a token (usually a word) has to be split into separate pieces
       * in order to determine the point to break a word.
       * It must return an array of characters.
       * @param token - The token to split
       * @returns The characters of the token
       * @see CanvasTextMetrics.graphemeSegmenter
       */
      static wordWrapSplit(token) {
        return _CanvasTextMetrics.graphemeSegmenter(token);
      }
      /**
       * Calculates the ascent, descent and fontSize of a given font-style
       * @param font - String representing the style of the font
       * @returns Font properties object
       */
      static measureFont(font) {
        if (_CanvasTextMetrics._fonts[font]) {
          return _CanvasTextMetrics._fonts[font];
        }
        const context = _CanvasTextMetrics._context;
        context.font = font;
        const metrics = context.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);
        const properties = {
          ascent: metrics.actualBoundingBoxAscent,
          descent: metrics.actualBoundingBoxDescent,
          fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
        };
        _CanvasTextMetrics._fonts[font] = properties;
        return properties;
      }
      /**
       * Clear font metrics in metrics cache.
       * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
       */
      static clearMetrics(font = "") {
        if (font) {
          delete _CanvasTextMetrics._fonts[font];
        } else {
          _CanvasTextMetrics._fonts = {};
        }
      }
      /**
       * Cached canvas element for measuring text
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      static get _canvas() {
        if (!_CanvasTextMetrics.__canvas) {
          let canvas2;
          try {
            const c = new OffscreenCanvas(0, 0);
            const context = c.getContext("2d", contextSettings);
            if (context?.measureText) {
              _CanvasTextMetrics.__canvas = c;
              return c;
            }
            canvas2 = settings.ADAPTER.createCanvas();
          } catch (ex) {
            canvas2 = settings.ADAPTER.createCanvas();
          }
          canvas2.width = canvas2.height = 10;
          _CanvasTextMetrics.__canvas = canvas2;
        }
        return _CanvasTextMetrics.__canvas;
      }
      /**
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      static get _context() {
        if (!_CanvasTextMetrics.__context) {
          _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext("2d", contextSettings);
        }
        return _CanvasTextMetrics.__context;
      }
    };
    CanvasTextMetrics = _CanvasTextMetrics;
    CanvasTextMetrics.METRICS_STRING = "|\xC9q\xC5";
    CanvasTextMetrics.BASELINE_SYMBOL = "M";
    CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;
    CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;
    CanvasTextMetrics.graphemeSegmenter = (() => {
      if (typeof Intl?.Segmenter === "function") {
        const segmenter = new Intl.Segmenter();
        return (s) => [...segmenter.segment(s)].map((x2) => x2.segment);
      }
      return (s) => [...s];
    })();
    CanvasTextMetrics.experimentalLetterSpacing = false;
    CanvasTextMetrics._fonts = {};
    CanvasTextMetrics._newlines = [
      10,
      // line feed
      13
      // carriage return
    ];
    CanvasTextMetrics._breakingSpaces = [
      9,
      // character tabulation
      32,
      // space
      8192,
      // en quad
      8193,
      // em quad
      8194,
      // en space
      8195,
      // em space
      8196,
      // three-per-em space
      8197,
      // four-per-em space
      8198,
      // six-per-em space
      8200,
      // punctuation space
      8201,
      // thin space
      8202,
      // hair space
      8287,
      // medium mathematical space
      12288
      // ideographic space
    ];
    CanvasTextMetrics._measurementCache = {};
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/canvas/utils/getCanvasFillStyle.mjs
function getCanvasFillStyle(fillStyle, context) {
  if (fillStyle.texture === Texture.WHITE && !fillStyle.fill) {
    return convertNumberToHex(fillStyle.color);
  } else if (!fillStyle.fill) {
    const pattern = context.createPattern(fillStyle.texture.source.resource, "repeat");
    const tempMatrix4 = fillStyle.matrix.copyTo(Matrix.shared);
    tempMatrix4.scale(fillStyle.texture.frameWidth, fillStyle.texture.frameHeight);
    pattern.setTransform(tempMatrix4);
    return pattern;
  } else if (fillStyle.fill instanceof FillPattern) {
    const fillPattern = fillStyle.fill;
    const pattern = context.createPattern(fillPattern.texture.source.resource, "repeat");
    const tempMatrix4 = fillPattern.transform.copyTo(Matrix.shared);
    tempMatrix4.scale(fillPattern.texture.frameWidth, fillPattern.texture.frameHeight);
    pattern.setTransform(tempMatrix4);
    return pattern;
  } else if (fillStyle.fill instanceof FillGradient) {
    const fillGradient = fillStyle.fill;
    if (fillGradient.type === "linear") {
      const gradient = context.createLinearGradient(
        fillGradient.x0,
        fillGradient.y0,
        fillGradient.x1,
        fillGradient.y1
      );
      fillGradient.gradientStops.forEach((stop) => {
        gradient.addColorStop(stop.offset, convertNumberToHex(stop.color));
      });
      return gradient;
    }
  }
  console.warn("[PixiJS] FillStyle not recognised", fillStyle);
  return "red";
}
var init_getCanvasFillStyle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/canvas/utils/getCanvasFillStyle.mjs"() {
    init_Matrix();
    init_convertNumberToHex();
    init_FillGradient();
    init_FillPattern();
    init_Texture();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/TextStyle.mjs
function addFillStyleKey(fillStyle, key, index) {
  if (!fillStyle)
    return index;
  key[index++] = fillStyle.color;
  key[index++] = fillStyle.alpha;
  key[index++] = fillStyle.fill?.uid;
  return index;
}
function addStokeStyleKey(strokeStyle, key, index) {
  if (!strokeStyle)
    return index;
  index = addFillStyleKey(strokeStyle, key, index);
  key[index++] = strokeStyle.width;
  key[index++] = strokeStyle.alignment;
  key[index++] = strokeStyle.cap;
  key[index++] = strokeStyle.join;
  key[index++] = strokeStyle.miterLimit;
  return index;
}
var valuesToIterateForKeys, _TextStyle, TextStyle;
var init_TextStyle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/TextStyle.mjs"() {
    init_eventemitter3();
    init_GraphicsContext();
    init_convertFillInputToFillStyle();
    valuesToIterateForKeys = [
      "fontFamily",
      "fontStyle",
      "fontVariant",
      "fontWeight",
      "breakWords",
      "align",
      "leading",
      "letterSpacing",
      "lineHeight",
      "textBaseline",
      "whiteSpace",
      "wordWrap",
      "wordWrapWidth",
      "padding"
    ];
    _TextStyle = class extends eventemitter3_default {
      constructor(style = {}) {
        super();
        const fullStyle = { ..._TextStyle.defaultTextStyle, ...style };
        for (const key in _TextStyle.defaultTextStyle) {
          const thisKey = key;
          this[thisKey] = fullStyle[key];
        }
        this.dropShadow = null;
        if (typeof fullStyle.fill === "string") {
          this.fontSize = parseInt(fullStyle.fontSize, 10);
        } else {
          this.fontSize = fullStyle.fontSize;
        }
        if (style.dropShadow) {
          if (style.dropShadow instanceof Boolean) {
            if (style.dropShadow === true) {
              this.dropShadow = {
                ..._TextStyle.defaultTextStyle.dropShadow
              };
            }
          } else {
            this.dropShadow = {
              ..._TextStyle.defaultTextStyle.dropShadow,
              ...style.dropShadow
            };
          }
        }
        this.update();
      }
      generateKey() {
        const key = [];
        let index = 0;
        for (let i = 0; i < valuesToIterateForKeys.length; i++) {
          const prop = valuesToIterateForKeys[i];
          key[index++] = this[prop];
        }
        index = addFillStyleKey(this._fill, key, index);
        index = addStokeStyleKey(this._stroke, key, index);
        this._styleKey = key.join("-");
        return this._styleKey;
      }
      update() {
        this._styleKey = null;
        this.emit("update", this);
      }
      get fill() {
        return this._originalFill;
      }
      set fill(value) {
        if (value === this._fill)
          return;
        this._originalFill = value;
        this._fill = convertFillInputToFillStyle(value, GraphicsContext.defaultFillStyle);
      }
      get stroke() {
        return this._originalStroke;
      }
      set stroke(value) {
        if (value === this._fill)
          return;
        this._originalFill = value;
        this._stroke = convertFillInputToFillStyle(value, GraphicsContext.defaultStrokeStyle);
      }
      get styleKey() {
        return this._styleKey || this.generateKey();
      }
      clone() {
        return new _TextStyle({
          align: this.align,
          breakWords: this.breakWords,
          dropShadow: this.dropShadow,
          fill: this._fill,
          fontFamily: this.fontFamily,
          fontSize: this.fontSize,
          fontStyle: this.fontStyle,
          fontVariant: this.fontVariant,
          fontWeight: this.fontWeight,
          leading: this.leading,
          letterSpacing: this.letterSpacing,
          lineHeight: this.lineHeight,
          padding: this.padding,
          stroke: this._stroke,
          textBaseline: this.textBaseline,
          whiteSpace: this.whiteSpace,
          wordWrap: this.wordWrap,
          wordWrapWidth: this.wordWrapWidth
        });
      }
      /**
       * Destroys this text style.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style
       * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style
       */
      destroy(options = false) {
        this.removeAllListeners();
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          if (this._fill?.texture) {
            this._fill.texture.destroy(destroyTextureSource);
          }
          if (this._originalFill?.texture) {
            this._originalFill.texture.destroy(destroyTextureSource);
          }
          if (this._stroke?.texture) {
            this._stroke.texture.destroy(destroyTextureSource);
          }
          if (this._originalStroke?.texture) {
            this._originalStroke.texture.destroy(destroyTextureSource);
          }
        }
        this._fill = null;
        this._stroke = null;
        this.dropShadow = null;
        this._originalStroke = null;
        this._originalFill = null;
      }
    };
    TextStyle = _TextStyle;
    TextStyle.defaultTextStyle = {
      /**
       * See {@link PIXI.TextStyle.align}
       * @type {'left'|'center'|'right'|'justify'}
       */
      align: "left",
      /** See {@link PIXI.TextStyle.breakWords} */
      breakWords: false,
      /** See {@link PIXI.TextStyle.dropShadow} */
      dropShadow: {
        alpha: 1,
        angle: Math.PI / 6,
        blur: 0,
        color: "black",
        distance: 5
      },
      /**
       * See {@link PIXI.TextStyle.fill}
       * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
       */
      fill: "black",
      /**
       * See {@link PIXI.TextStyle.fontFamily}
       * @type {string|string[]}
       */
      fontFamily: "Arial",
      /**
       * See {@link PIXI.TextStyle.fontSize}
       * @type {number|string}
       */
      fontSize: 26,
      /**
       * See {@link PIXI.TextStyle.fontStyle}
       * @type {'normal'|'italic'|'oblique'}
       */
      fontStyle: "normal",
      /**
       * See {@link PIXI.TextStyle.fontVariant}
       * @type {'normal'|'small-caps'}
       */
      fontVariant: "normal",
      /**
       * See {@link PIXI.TextStyle.fontWeight}
       * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
       */
      fontWeight: "normal",
      /** See {@link PIXI.TextStyle.leading} */
      leading: 0,
      /** See {@link PIXI.TextStyle.letterSpacing} */
      letterSpacing: 0,
      /** See {@link PIXI.TextStyle.lineHeight} */
      lineHeight: 0,
      /** See {@link PIXI.TextStyle.padding} */
      padding: 0,
      /**
       * See {@link PIXI.TextStyle.stroke}
       * @type {string|number}
       */
      stroke: null,
      /**
       * See {@link PIXI.TextStyle.textBaseline}
       * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
       */
      textBaseline: "alphabetic",
      /** See {@link PIXI.TextStyle.trim} */
      trim: false,
      /**
       * See {@link PIXI.TextStyle.whiteSpace}
       * @type {'normal'|'pre'|'pre-line'}
       */
      whiteSpace: "pre",
      /** See {@link PIXI.TextStyle.wordWrap} */
      wordWrap: false,
      /** See {@link PIXI.TextStyle.wordWrapWidth} */
      wordWrapWidth: 100
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/bitmap/utils/resolveCharacters.mjs
function resolveCharacters(chars) {
  if (typeof chars === "string") {
    chars = [chars];
  }
  const result = [];
  for (let i = 0, j2 = chars.length; i < j2; i++) {
    const item = chars[i];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
      }
      const startCode = item[0].charCodeAt(0);
      const endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (let i2 = startCode, j22 = endCode; i2 <= j22; i2++) {
        result.push(String.fromCharCode(i2));
      }
    } else {
      result.push(...Array.from(item));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
}
var init_resolveCharacters = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/bitmap/utils/resolveCharacters.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/bitmap/DynamicBitmapFont.mjs
var DynamicBitmapFont;
var init_DynamicBitmapFont = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/bitmap/DynamicBitmapFont.mjs"() {
    init_eventemitter3();
    init_Rectangle();
    init_convertColorToNumber();
    init_hex();
    init_CanvasPool();
    init_const8();
    init_ImageSource();
    init_Texture();
    init_CanvasTextMetrics();
    init_fontStringFromTextStyle();
    init_getCanvasFillStyle();
    init_TextStyle();
    init_resolveCharacters();
    DynamicBitmapFont = class extends eventemitter3_default {
      constructor(options) {
        super();
        this.baseRenderedFontSize = 100;
        this.baseMeasurementFontSize = 100;
        this.padding = 4;
        this.baseLineOffset = 0;
        this.pages = [];
        this.chars = {};
        this.lineHeight = 0;
        this.measureCache = {};
        this.currentChars = [];
        this.dynamic = true;
        this.currentX = 0;
        this.currentY = 0;
        this.currentPageIndex = -1;
        this.resolution = 1;
        this.distanceField = {
          fieldType: "none",
          distanceRange: 0
        };
        this.pages = [];
        const dynamicOptions = options;
        this.dynamic = true;
        let style;
        if (dynamicOptions.style instanceof TextStyle) {
          style = dynamicOptions.style.clone();
        } else {
          style = new TextStyle(dynamicOptions.style);
        }
        style.fontSize = this.baseMeasurementFontSize;
        if (dynamicOptions.overrideFill) {
          style._fill.color = 16777215;
          style._fill.alpha = 1;
          style._fill.texture = Texture.WHITE;
          style._fill.fill = null;
        }
        this.style = style;
        const font = fontStringFromTextStyle(style);
        this.fontMetrics = CanvasTextMetrics.measureFont(font);
        this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;
      }
      ensureCharacters(chars) {
        const charList = resolveCharacters(chars).filter((char) => !this.currentChars.includes(char)).filter((char, index, self2) => self2.indexOf(char) === index);
        if (!charList.length)
          return;
        this.currentChars = [...this.currentChars, ...charList];
        let pageData;
        if (this.currentPageIndex === -1) {
          pageData = this.nextPage();
        } else {
          pageData = this.pages[this.currentPageIndex];
        }
        let { canvas: canvas2, context } = pageData.canvasAndContext;
        let textureSource = pageData.texture.source;
        const style = this.style;
        let currentX = this.currentX;
        let currentY = this.currentY;
        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;
        const padding = this.padding * fontScale;
        const widthScale = style.fontStyle === "italic" ? 2 : 1;
        let maxCharHeight = 0;
        let skipTexture = false;
        for (let i = 0; i < charList.length; i++) {
          const char = charList[i];
          const metrics = CanvasTextMetrics.measureText(char, style, canvas2, false);
          const width = widthScale * metrics.width * fontScale;
          const height = metrics.height * fontScale;
          const paddedWidth = width + padding * 2;
          const paddedHeight = height + padding * 2;
          skipTexture = false;
          if (char !== "\n" && char !== "\r" && char !== "	" && char !== " ") {
            skipTexture = true;
            maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));
          }
          if (currentX + paddedWidth > 512) {
            currentY += maxCharHeight;
            maxCharHeight = paddedHeight;
            currentX = 0;
            if (currentY + maxCharHeight > 512) {
              textureSource.update();
              const pageData2 = this.nextPage();
              canvas2 = pageData2.canvasAndContext.canvas;
              context = pageData2.canvasAndContext.context;
              textureSource = pageData2.texture.source;
              currentY = 0;
            }
          }
          const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);
          this.chars[char] = {
            id: char.codePointAt(0),
            xOffset: -this.padding,
            yOffset: -this.padding,
            xAdvance,
            kerning: {}
          };
          if (skipTexture) {
            this.drawGlyph(
              context,
              metrics,
              currentX + padding,
              currentY + padding,
              fontScale,
              style
            );
            const px = textureSource.width * fontScale;
            const py = textureSource.height * fontScale;
            const frame = new Rectangle(
              currentX / px,
              currentY / py,
              paddedWidth / px,
              paddedHeight / py
            );
            this.chars[char].texture = new Texture({
              source: textureSource,
              layout: {
                frame
              }
            });
            currentX += Math.ceil(paddedWidth);
          }
        }
        textureSource.update();
        this.currentX = currentX;
        this.currentY = currentY;
        this.applyKerning(charList, context);
      }
      applyKerning(newChars, context) {
        const measureCache = this.measureCache;
        for (let i = 0; i < newChars.length; i++) {
          const first = newChars[i];
          for (let j2 = 0; j2 < this.currentChars.length; j2++) {
            const second = this.currentChars[j2];
            let c1 = measureCache[first];
            if (!c1)
              c1 = measureCache[first] = context.measureText(first).width;
            let c2 = measureCache[second];
            if (!c2)
              c2 = measureCache[second] = context.measureText(second).width;
            let total = context.measureText(first + second).width;
            let amount = total - (c1 + c2);
            if (amount) {
              this.chars[first].kerning[second] = amount;
            }
            total = context.measureText(first + second).width;
            amount = total - (c1 + c2);
            if (amount) {
              this.chars[second].kerning[first] = amount;
            }
          }
        }
      }
      nextPage() {
        this.currentPageIndex++;
        const textureResolution = this.resolution;
        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(512, 512, textureResolution);
        this.setupContext(canvasAndContext.context, this.style, textureResolution);
        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);
        const texture = new Texture({
          source: new ImageSource({
            resource: canvasAndContext.canvas,
            resolution,
            alphaMode: ALPHA_MODES.PMA
          })
        });
        const pageData = {
          canvasAndContext,
          texture
        };
        this.pages[this.currentPageIndex] = pageData;
        return pageData;
      }
      // canvas style!
      setupContext(context, style, resolution) {
        style.fontSize = this.baseRenderedFontSize;
        context.scale(resolution, resolution);
        context.font = fontStringFromTextStyle(style);
        style.fontSize = this.baseMeasurementFontSize;
        context.textBaseline = style.textBaseline;
        const stroke = style._stroke;
        const strokeThickness = stroke?.width ?? 0;
        if (stroke) {
          context.lineWidth = strokeThickness;
          context.lineJoin = stroke.join;
          context.miterLimit = stroke.miterLimit;
          context.strokeStyle = getCanvasFillStyle(stroke, context);
        }
        if (style._fill) {
          context.fillStyle = getCanvasFillStyle(style._fill, context);
        }
        if (style.dropShadow) {
          const shadowOptions = style.dropShadow;
          const dropShadowColor = convertColorToNumber(shadowOptions.color);
          const rgb = hex2rgb(dropShadowColor);
          const dropShadowBlur = shadowOptions.blur * resolution;
          const dropShadowDistance = shadowOptions.distance * resolution;
          context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;
          context.shadowBlur = dropShadowBlur;
          context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
          context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;
        } else {
          context.shadowColor = "black";
          context.shadowBlur = 0;
          context.shadowOffsetX = 0;
          context.shadowOffsetY = 0;
        }
      }
      drawGlyph(context, metrics, x2, y, fontScale, style) {
        const char = metrics.text;
        const fontProperties = metrics.fontProperties;
        const stroke = style._stroke;
        const strokeThickness = (stroke?.width ?? 0) * fontScale;
        const tx = x2 + strokeThickness / 2;
        const ty = y - strokeThickness / 2;
        const descent = fontProperties.descent * fontScale;
        const lineHeight = metrics.lineHeight * fontScale;
        if (style.stroke && strokeThickness) {
          context.strokeText(char, tx, ty + lineHeight - descent);
        }
        if (style._fill) {
          context.fillText(char, tx, ty + lineHeight - descent);
        }
      }
      destroy() {
        this.emit("destroy", this);
        this.removeAllListeners();
        for (const i in this.chars) {
          this.chars[i].texture.destroy();
        }
        this.chars = null;
        for (let i = 0; i < this.pages.length; i++) {
          const { canvasAndContext, texture } = this.pages[i];
          CanvasPool.returnCanvasAndContext(canvasAndContext);
          texture.destroy(true);
        }
        this.pages = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/bitmap/utils/getBitmapTextLayout.mjs
function getBitmapTextLayout(chars, style, font) {
  const layoutData = {
    width: 0,
    height: 0,
    offsetY: 0,
    scale: style.fontSize / font.baseMeasurementFontSize,
    lines: [{
      width: 0,
      charPositions: [],
      spaceWidth: 0,
      spacesIndex: [],
      chars: []
    }]
  };
  layoutData.offsetY = font.baseLineOffset;
  let currentLine = layoutData.lines[0];
  let previousChar = null;
  let firstWord = true;
  const currentWord = {
    spaceWord: false,
    width: 0,
    start: 0,
    index: 0,
    // use index to not modify the array as we use it a lot!
    positions: [],
    chars: []
  };
  const nextWord = (word) => {
    const start = currentLine.width;
    for (let j2 = 0; j2 < currentWord.index; j2++) {
      const position = word.positions[j2];
      currentLine.chars.push(word.chars[j2]);
      currentLine.charPositions.push(position + start);
    }
    currentLine.width += word.width;
    firstWord = false;
    currentWord.width = 0;
    currentWord.index = 0;
    currentWord.chars.length = 0;
  };
  const nextLine = () => {
    let index = currentLine.chars.length - 1;
    let lastChar = currentLine.chars[index];
    while (lastChar === " ") {
      currentLine.width -= font.chars[lastChar].xAdvance;
      lastChar = currentLine.chars[--index];
    }
    layoutData.width = Math.max(layoutData.width, currentLine.width);
    currentLine = {
      width: 0,
      charPositions: [],
      chars: [],
      spaceWidth: 0,
      spacesIndex: []
    };
    firstWord = true;
    layoutData.lines.push(currentLine);
    layoutData.height += font.lineHeight;
  };
  const scale3 = font.baseMeasurementFontSize / style.fontSize;
  const adjustedLetterSpacing = style.letterSpacing * scale3;
  const adjustedWordWrapWidth = style.wordWrapWidth * scale3;
  for (let i = 0; i < chars.length + 1; i++) {
    let char;
    const isEnd = i === chars.length;
    if (!isEnd) {
      char = chars[i];
    }
    const charData = font.chars[char];
    const isSpace = /(?:\s)/.test(char);
    const isWordBreak = isSpace || char === "\r" || char === "\n" || isEnd;
    if (isWordBreak) {
      const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;
      if (addWordToNextLine) {
        nextLine();
        nextWord(currentWord);
        if (!isEnd) {
          currentLine.charPositions.push(0);
        }
      } else {
        currentWord.start = currentLine.width;
        nextWord(currentWord);
        if (!isEnd) {
          currentLine.charPositions.push(0);
        }
      }
      if (char === "\r" || char === "\n") {
        if (currentLine.width !== 0) {
          nextLine();
        }
      } else if (!isEnd) {
        const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;
        currentLine.width += spaceWidth;
        currentLine.spaceWidth = spaceWidth;
        currentLine.spacesIndex.push(currentLine.charPositions.length);
        currentLine.chars.push(char);
      }
    } else {
      const kerning = charData.kerning[previousChar] || 0;
      const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;
      currentWord.positions[currentWord.index++] = currentWord.width + kerning;
      currentWord.chars.push(char);
      currentWord.width += nextCharWidth;
    }
    previousChar = char;
  }
  nextLine();
  if (style.align === "center") {
    alignCenter(layoutData);
  } else if (style.align === "right") {
    alignRight(layoutData);
  } else if (style.align === "justify") {
    alignJustify(layoutData);
  }
  return layoutData;
}
function alignCenter(measurementData) {
  for (let i = 0; i < measurementData.lines.length; i++) {
    const line = measurementData.lines[i];
    const offset = measurementData.width / 2 - line.width / 2;
    for (let j2 = 0; j2 < line.charPositions.length; j2++) {
      line.charPositions[j2] += offset;
    }
  }
}
function alignRight(measurementData) {
  for (let i = 0; i < measurementData.lines.length; i++) {
    const line = measurementData.lines[i];
    const offset = measurementData.width - line.width;
    for (let j2 = 0; j2 < line.charPositions.length; j2++) {
      line.charPositions[j2] += offset;
    }
  }
}
function alignJustify(measurementData) {
  const width = measurementData.width;
  for (let i = 0; i < measurementData.lines.length; i++) {
    const line = measurementData.lines[i];
    let indy = 0;
    let spaceIndex = line.spacesIndex[indy++];
    let offset = 0;
    const totalSpaces = line.spacesIndex.length;
    const newSpaceWidth = (width - line.width) / totalSpaces;
    const spaceWidth = newSpaceWidth;
    for (let j2 = 0; j2 < line.charPositions.length; j2++) {
      if (j2 === spaceIndex) {
        spaceIndex = line.spacesIndex[indy++];
        offset += spaceWidth;
      }
      line.charPositions[j2] += offset;
    }
  }
}
var init_getBitmapTextLayout = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/bitmap/utils/getBitmapTextLayout.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/bitmap/BitmapFontManager.mjs
var BitmapFontManagerClass, BitmapFontManager;
var init_BitmapFontManager = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/bitmap/BitmapFontManager.mjs"() {
    init_Cache();
    init_DynamicBitmapFont();
    init_getBitmapTextLayout();
    BitmapFontManagerClass = class {
      getFont(text, style) {
        let fontFamilyKey = style.fontFamily;
        let overrideFill = true;
        if (style._fill.fill) {
          fontFamilyKey += style._fill.fill.uid;
          overrideFill = false;
        }
        if (!Cache.has(fontFamilyKey)) {
          Cache.set(fontFamilyKey, new DynamicBitmapFont({
            style,
            overrideFill
          }));
        }
        const dynamicFont = Cache.get(fontFamilyKey);
        dynamicFont.ensureCharacters?.(text);
        return dynamicFont;
      }
      getLayout(text, style) {
        const bitmapFont = this.getFont(text, style);
        return getBitmapTextLayout(text.split(""), style, bitmapFont);
      }
      measureText(text, style) {
        return this.getLayout(text, style);
      }
    };
    BitmapFontManager = new BitmapFontManagerClass();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/bitmap/BitmapTextPipe.mjs
var GraphicsProxyRenderable, BitmapTextPipe;
var init_BitmapTextPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/bitmap/BitmapTextPipe.mjs"() {
    init_Cache();
    init_Extensions();
    init_PoolGroup();
    init_GraphicsView();
    init_ProxyRenderable();
    init_SdfShader();
    init_BitmapFontManager();
    init_getBitmapTextLayout();
    GraphicsProxyRenderable = class extends ProxyRenderable {
      constructor() {
        super({
          view: new GraphicsView()
        });
      }
    };
    BitmapTextPipe = class {
      constructor(renderer) {
        this.gpuBitmapText = {};
        this.renderer = renderer;
      }
      validateRenderable(renderable) {
        const graphicsRenderable = this.getGpuBitmapText(renderable);
        this.updateContext(renderable, graphicsRenderable.view.context);
        const rebuild = this.renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);
        return rebuild;
      }
      addRenderable(renderable, instructionSet) {
        const graphicsRenderable = this.getGpuBitmapText(renderable);
        this.renderer.renderPipes.batch.break(instructionSet);
        this.renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);
        if (graphicsRenderable.view.context.customShader) {
          this.updateDistanceField(renderable);
        }
      }
      destroyRenderable(renderable) {
        this.destroyRenderableByUid(renderable.uid);
      }
      destroyRenderableByUid(renderableUid) {
        BigPool.return(this.gpuBitmapText[renderableUid]);
        this.gpuBitmapText[renderableUid] = null;
      }
      updateRenderable(renderable) {
        const graphicsRenderable = this.getGpuBitmapText(renderable);
        this.renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);
        if (graphicsRenderable.view.context.customShader) {
          this.updateDistanceField(renderable);
        }
      }
      updateContext(renderable, context) {
        const view = renderable.view;
        const bitmapFont = BitmapFontManager.getFont(view.text, view._style);
        context.clear();
        if (bitmapFont.distanceField.fieldType !== "none") {
          if (!context.customShader) {
            if (!this.sdfShader) {
              this.sdfShader = new SdfShader();
            }
            context.customShader = this.sdfShader;
          }
        }
        const chars = Array.from(view.text);
        const style = view._style;
        let currentY = (style._stroke?.width || 0) / 2;
        currentY += bitmapFont.baseLineOffset;
        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont);
        let index = 0;
        const scale3 = style.fontSize / bitmapFont.baseMeasurementFontSize;
        context.scale(scale3, scale3);
        const offsetX = -view.anchor.x * bitmapTextLayout.width;
        const offsetY = -view.anchor.y * bitmapTextLayout.height;
        context.translate(offsetX, offsetY);
        const tint = style._fill.color;
        for (let i = 0; i < bitmapTextLayout.lines.length; i++) {
          const line = bitmapTextLayout.lines[i];
          for (let j2 = 0; j2 < line.charPositions.length; j2++) {
            const char = chars[index++];
            const charData = bitmapFont.chars[char];
            if (charData?.texture) {
              context.texture(
                charData.texture,
                tint,
                Math.round(line.charPositions[j2] + charData.xOffset),
                Math.round(currentY + charData.yOffset)
              );
            }
          }
          currentY += bitmapFont.lineHeight;
        }
      }
      getGpuBitmapText(renderable) {
        return this.gpuBitmapText[renderable.uid] || this.initGpuText(renderable);
      }
      initGpuText(renderable) {
        renderable.view._style.update();
        const proxyRenderable = BigPool.get(GraphicsProxyRenderable, renderable);
        this.gpuBitmapText[renderable.uid] = proxyRenderable;
        this.updateContext(renderable, proxyRenderable.view.context);
        renderable.on("destroyed", () => {
          this.destroyRenderable(renderable);
        });
        return this.gpuBitmapText[renderable.uid];
      }
      updateDistanceField(renderable) {
        const context = this.getGpuBitmapText(renderable).view.context;
        const view = renderable.view;
        const fontFamily = view._style.fontFamily;
        const dynamicFont = Cache.get(fontFamily);
        const { a, b, c, d: d2 } = renderable.layerTransform;
        const dx = Math.sqrt(a * a + b * b);
        const dy = Math.sqrt(c * c + d2 * d2);
        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
        const fontScale = dynamicFont.baseRenderedFontSize / view._style.fontSize;
        const resolution = 1;
        const distance = worldScale * dynamicFont.distanceField.distanceRange * (1 / fontScale) * resolution;
        context.customShader.resources.localUniforms.uniforms.distance = distance;
      }
      destroy() {
        for (const uid5 in this.gpuBitmapText) {
          this.destroyRenderableByUid(uid5);
        }
        this.gpuBitmapText = null;
        this.sdfShader?.destroy(true);
        this.sdfShader = null;
        this.renderer = null;
      }
    };
    BitmapTextPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "bitmapText"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/canvas/CanvasTextPipe.mjs
function updateBounds(bounds, anchor, texture) {
  const textureSource = texture._source;
  const layout = texture.layout;
  const orig = layout.orig;
  const trim = layout.trim;
  const textureSourceWidth = textureSource.width;
  const textureSourceHeight = textureSource.height;
  const width = textureSourceWidth * orig.width;
  const height = textureSourceHeight * orig.height;
  if (trim) {
    const sourceWidth = textureSourceWidth * trim.width;
    const sourceHeight = textureSourceHeight * trim.height;
    bounds[1] = trim.x * textureSourceWidth - anchor._x * width;
    bounds[0] = bounds[1] + sourceWidth;
    bounds[3] = trim.y * textureSourceHeight - anchor._y * height;
    bounds[2] = bounds[3] + sourceHeight;
  } else {
    bounds[1] = -anchor._x * width;
    bounds[0] = bounds[1] + width;
    bounds[3] = -anchor._y * height;
    bounds[2] = bounds[3] + height;
  }
  return;
}
var CanvasTextPipe;
var init_CanvasTextPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/canvas/CanvasTextPipe.mjs"() {
    init_Extensions();
    init_PoolGroup();
    init_BatchableSprite();
    CanvasTextPipe = class {
      constructor(renderer) {
        this.gpuText = {};
        this.renderer = renderer;
      }
      validateRenderable(renderable) {
        const gpuText = this.getGpuText(renderable);
        const newKey = renderable.view._getKey();
        if (gpuText.currentKey !== newKey) {
          const view = renderable.view;
          const resolution = view._autoResolution ? this.renderer.view.resolution : view._resolution;
          const { width, height } = this.renderer.canvasText.getTextureSize(
            view.text,
            resolution,
            view._style
          );
          if (
            // is only being used by this text:
            this.renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1 && width === gpuText.texture._source.width && height === gpuText.texture._source.height
          ) {
            return false;
          }
          return true;
        }
        return false;
      }
      addRenderable(renderable, instructionSet) {
        const gpuText = this.getGpuText(renderable);
        const batchableSprite = gpuText.batchableSprite;
        if (renderable.view.didUpdate) {
          this.updateText(renderable);
        }
        this.renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);
      }
      updateRenderable(renderable) {
        const gpuText = this.getGpuText(renderable);
        const batchableSprite = gpuText.batchableSprite;
        if (renderable.view.didUpdate) {
          this.updateText(renderable);
        }
        batchableSprite.batcher.updateElement(batchableSprite);
      }
      destroyRenderable(renderable) {
        this.destroyRenderableById(renderable.uid);
      }
      destroyRenderableById(renderableUid) {
        const gpuText = this.gpuText[renderableUid];
        this.renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
        BigPool.return(gpuText.batchableSprite);
        this.gpuText[renderableUid] = null;
      }
      updateText(renderable) {
        const newKey = renderable.view._getKey();
        const gpuText = this.getGpuText(renderable);
        const batchableSprite = gpuText.batchableSprite;
        if (gpuText.currentKey !== newKey) {
          this.updateGpuText(renderable);
        }
        renderable.view.didUpdate = false;
        updateBounds(batchableSprite.bounds, renderable.view.anchor, batchableSprite.texture);
      }
      updateGpuText(renderable) {
        const gpuText = this.getGpuText(renderable);
        const batchableSprite = gpuText.batchableSprite;
        const view = renderable.view;
        if (gpuText.texture) {
          this.renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
        }
        const resolution = view._autoResolution ? this.renderer.view.resolution : view._resolution;
        gpuText.texture = batchableSprite.texture = this.renderer.canvasText.getTexture(
          view.text,
          resolution,
          view._style,
          view._getKey()
        );
        gpuText.currentKey = view._getKey();
        batchableSprite.texture = gpuText.texture;
        gpuText.needsTextureUpdate = false;
      }
      getGpuText(renderable) {
        return this.gpuText[renderable.uid] || this.initGpuText(renderable);
      }
      initGpuText(renderable) {
        const view = renderable.view;
        view._style.update();
        const gpuTextData = {
          texture: null,
          currentKey: "--",
          batchableSprite: BigPool.get(BatchableSprite),
          needsTextureUpdate: true
        };
        gpuTextData.batchableSprite.sprite = renderable;
        gpuTextData.batchableSprite.bounds = [0, 1, 0, 0];
        this.gpuText[renderable.uid] = gpuTextData;
        this.updateText(renderable);
        renderable.on("destroyed", () => {
          this.destroyRenderable(renderable);
        });
        return gpuTextData;
      }
      destroy() {
        for (const i in this.gpuText) {
          this.destroyRenderableById(i);
        }
        this.gpuText = null;
        this.renderer = null;
      }
    };
    CanvasTextPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "text"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/canvas/CanvasTextSystem.mjs
var tempBounds4, CanvasTextSystem;
var init_CanvasTextSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/canvas/CanvasTextSystem.mjs"() {
    init_Extensions();
    init_pow2();
    init_convertColorToNumber();
    init_hex();
    init_CanvasPool();
    init_TexturePool();
    init_Bounds();
    init_CanvasTextMetrics();
    init_fontStringFromTextStyle();
    init_getCanvasFillStyle();
    tempBounds4 = new Bounds();
    CanvasTextSystem = class {
      constructor() {
        this.activeTextures = {};
      }
      getTextureSize(text, resolution, style) {
        const measured = CanvasTextMetrics.measureText(text || " ", style);
        let width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
        let height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
        width = Math.ceil(width - 1e-6);
        height = Math.ceil(height - 1e-6);
        width = nextPow2(width);
        height = nextPow2(height);
        return { width, height };
      }
      getTexture(text, resolution, style, textKey) {
        if (this.activeTextures[textKey]) {
          this.increaseReferenceCount(textKey);
          return this.activeTextures[textKey].texture;
        }
        const measured = CanvasTextMetrics.measureText(text || " ", style);
        const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
        const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);
        const { canvas: canvas2 } = canvasAndContext;
        this.renderTextToCanvas(text, style, resolution, canvasAndContext);
        const bounds = tempBounds4;
        bounds.minX = 0;
        bounds.minY = 0;
        bounds.maxX = canvas2.width / resolution | 0;
        bounds.maxY = canvas2.height / resolution | 0;
        const texture = TexturePool.getOptimalTexture(
          bounds.width,
          bounds.height,
          resolution,
          false
        );
        texture.source.type = "image";
        texture.source.resource = canvas2;
        texture.frameWidth = measured.width;
        texture.frameHeight = measured.height;
        texture.source.update();
        texture.layout.updateUvs();
        this.activeTextures[textKey] = {
          canvasAndContext,
          texture,
          usageCount: 1
        };
        return texture;
      }
      increaseReferenceCount(textKey) {
        this.activeTextures[textKey].usageCount++;
      }
      decreaseReferenceCount(textKey) {
        const activeTexture = this.activeTextures[textKey];
        activeTexture.usageCount--;
        if (activeTexture.usageCount === 0) {
          CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);
          TexturePool.returnTexture(activeTexture.texture);
          activeTexture.texture.source.resource = null;
          activeTexture.texture.source.type = "unknown";
          this.activeTextures[textKey] = null;
        }
      }
      getReferenceCount(textKey) {
        return this.activeTextures[textKey].usageCount;
      }
      /**
       * Renders text to its canvas, and updates its texture.
       *
       * By default this is used internally to ensure the texture is correct before rendering,
       * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,
       * and then shared across multiple Sprites.
       * @param text
       * @param style
       * @param resolution
       * @param canvasAndContext
       */
      renderTextToCanvas(text, style, resolution, canvasAndContext) {
        const { canvas: canvas2, context } = canvasAndContext;
        const font = fontStringFromTextStyle(style);
        const measured = CanvasTextMetrics.measureText(text || " ", style);
        const lines = measured.lines;
        const lineHeight = measured.lineHeight;
        const lineWidths = measured.lineWidths;
        const maxLineWidth = measured.maxLineWidth;
        const fontProperties = measured.fontProperties;
        const height = canvas2.height;
        context.resetTransform();
        context.scale(resolution, resolution);
        context.clearRect(0, 0, measured.width, measured.height);
        context.font = font;
        let linePositionX;
        let linePositionY;
        const passesCount = style.dropShadow ? 2 : 1;
        for (let i = 0; i < passesCount; ++i) {
          const isShadowPass = style.dropShadow && i === 0;
          const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
          const dsOffsetShadow = dsOffsetText * resolution;
          if (isShadowPass) {
            context.fillStyle = "black";
            context.strokeStyle = "black";
            const shadowOptions = style.dropShadow;
            const dropShadowColor = convertColorToNumber(shadowOptions.color);
            const rgb = hex2rgb(dropShadowColor);
            const dropShadowBlur = shadowOptions.blur * resolution;
            const dropShadowDistance = shadowOptions.distance * resolution;
            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;
            context.shadowBlur = dropShadowBlur;
            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;
          } else {
            context.globalAlpha = style._fill?.alpha ?? 1;
            context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context) : null;
            if (style._stroke?.width) {
              const strokeStyle = style._stroke;
              context.strokeStyle = getCanvasFillStyle(style._stroke, context);
              context.lineWidth = strokeStyle.width;
              context.miterLimit = strokeStyle.miterLimit;
              context.lineJoin = strokeStyle.join;
              context.lineCap = strokeStyle.cap;
            }
            context.shadowColor = "black";
            context.shadowBlur = 0;
            context.shadowOffsetX = 0;
            context.shadowOffsetY = 0;
          }
          let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
          if (lineHeight - fontProperties.fontSize < 0) {
            linePositionYShift = 0;
          }
          const strokeWidth = style.stroke?.width ?? 0;
          for (let i2 = 0; i2 < lines.length; i2++) {
            linePositionX = strokeWidth / 2;
            linePositionY = strokeWidth / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;
            if (style.align === "right") {
              linePositionX += maxLineWidth - lineWidths[i2];
            } else if (style.align === "center") {
              linePositionX += (maxLineWidth - lineWidths[i2]) / 2;
            }
            if (style._stroke) {
              this.drawLetterSpacing(
                lines[i2],
                style,
                canvasAndContext,
                linePositionX + style.padding,
                linePositionY + style.padding - dsOffsetText,
                true
              );
            }
            if (style._fill !== void 0) {
              this.drawLetterSpacing(
                lines[i2],
                style,
                canvasAndContext,
                linePositionX + style.padding,
                linePositionY + style.padding - dsOffsetText
              );
            }
          }
        }
      }
      /**
       * Render the text with letter-spacing.
       * @param text - The text to draw
       * @param style
       * @param canvasAndContext
       * @param x - Horizontal position to draw the text
       * @param y - Vertical position to draw the text
       * @param isStroke - Is this drawing for the outside stroke of the
       *  text? If not, it's for the inside fill
       */
      drawLetterSpacing(text, style, canvasAndContext, x2, y, isStroke = false) {
        const { context } = canvasAndContext;
        const letterSpacing = style.letterSpacing;
        let useExperimentalLetterSpacing = false;
        if (CanvasTextMetrics.experimentalLetterSpacingSupported) {
          if (CanvasTextMetrics.experimentalLetterSpacing) {
            context.letterSpacing = `${letterSpacing}px`;
            context.textLetterSpacing = `${letterSpacing}px`;
            useExperimentalLetterSpacing = true;
          } else {
            context.letterSpacing = "0px";
            context.textLetterSpacing = "0px";
          }
        }
        if (letterSpacing === 0 || useExperimentalLetterSpacing) {
          if (isStroke) {
            context.strokeText(text, x2, y);
          } else {
            context.fillText(text, x2, y);
          }
          return;
        }
        let currentPosition = x2;
        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);
        let previousWidth = context.measureText(text).width;
        let currentWidth = 0;
        for (let i = 0; i < stringArray.length; ++i) {
          const currentChar = stringArray[i];
          if (isStroke) {
            context.strokeText(currentChar, currentPosition, y);
          } else {
            context.fillText(currentChar, currentPosition, y);
          }
          let textStr = "";
          for (let j2 = i + 1; j2 < stringArray.length; ++j2) {
            textStr += stringArray[j2];
          }
          currentWidth = context.measureText(textStr).width;
          currentPosition += previousWidth - currentWidth + letterSpacing;
          previousWidth = currentWidth;
        }
      }
      destroy() {
      }
    };
    CanvasTextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "canvasText"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs
var defaultBackgroundOptions, BackgroundSystem;
var init_BackgroundSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs"() {
    init_Extensions();
    init_hex();
    defaultBackgroundOptions = {
      alpha: 1,
      color: 0,
      clearBeforeRender: true
    };
    BackgroundSystem = class {
      constructor() {
        this.clearBeforeRender = true;
        this._backgroundColor = 0;
        this._backgroundColorRgba = [0, 0, 0, 1];
        this._backgroundColorRgbaObject = { r: 0, g: 0, b: 0, a: 1 };
        this._backgroundColorString = "#000000";
        this.color = this._backgroundColor;
        this.alpha = 1;
      }
      /**
       * initiates the background system
       * @param options - the options for the background colors
       */
      init(options) {
        options = { ...defaultBackgroundOptions, ...options };
        this.clearBeforeRender = options.clearBeforeRender;
        this.color = options.backgroundColor || this._backgroundColor;
        this.alpha = options.backgroundAlpha;
      }
      /** The background color to fill if not transparent */
      get color() {
        return this._backgroundColor;
      }
      set color(value) {
        this._backgroundColor = value;
        this._backgroundColorString = hex2string(value);
        const rgbaObject = this._backgroundColorRgbaObject;
        const rgba = this._backgroundColorRgba;
        hex2rgb(value, rgba);
        rgbaObject.r = rgba[0];
        rgbaObject.g = rgba[1];
        rgbaObject.b = rgba[2];
        rgbaObject.a = rgba[3];
      }
      /** The background color alpha. Setting this to 0 will make the canvas transparent. */
      get alpha() {
        return this._backgroundColorRgba[3];
      }
      set alpha(value) {
        this._backgroundColorRgba[3] = value;
      }
      /** The background color as an [R, G, B, A] array. */
      get colorRgba() {
        return this._backgroundColorRgba;
      }
      get colorRgbaObject() {
        return this._backgroundColorRgbaObject;
      }
      /** The background color as a string. */
      get colorString() {
        return this._backgroundColorString;
      }
      destroy() {
      }
    };
    BackgroundSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "background",
      priority: 0
    };
    BackgroundSystem.defaultOptions = {
      /**
       * {@link PIXI.WebGLOptions.backgroundAlpha}
       * @default 1
       */
      backgroundAlpha: 1,
      /**
       * {@link PIXI.WebGLOptions.backgroundColor}
       * @default 0x000000
       */
      backgroundColor: 0,
      /**
       * {@link PIXI.WebGLOptions.clearBeforeRender}
       * @default true
       */
      clearBeforeRender: true
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/blend-template.mjs
var blendTemplateFrag;
var init_blend_template = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/blend-template.mjs"() {
    blendTemplateFrag = "\nin vec2 vTextureCoord;\nin vec2 backgroundUv;\nin vec4 vColor;\n\nout vec4 fragColor;\n\nuniform float uBlend;\n\nuniform sampler2D myTexture;\nuniform sampler2D backTexture;\n\n{FUNCTIONS}\n\nvoid main()\n{ \n    vec4 back = texture(backTexture, backgroundUv);\n    vec4 front = texture(myTexture, vTextureCoord);\n\n    {MAIN}\n}\n";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/blend-template2.mjs
var blendTemplateVert;
var init_blend_template2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/blend-template2.mjs"() {
    blendTemplateVert = "in vec2 aPosition;\nout vec2 vTextureCoord;\nout vec2 backgroundUv;\n\nuniform globalUniforms {\n  mat3 projectionMatrix;\n  mat3 worldTransformMatrix;\n  float worldAlpha;\n};\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nuniform vec4 backgroundFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvec2 filterBackgroundTextureCoord( void ) \n{\n    return aPosition * aPosition * backgroundFrame.zw;\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n    backgroundUv = filterBackgroundTextureCoord();\n}\n";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/blend-template3.mjs
var blendTemplate;
var init_blend_template3 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/blend-template3.mjs"() {
    blendTemplate = "struct GlobalUniforms {\n  projectionMatrix:mat3x3<f32>,\n  worldTransformMatrix:mat3x3<f32>,\n  worldAlpha: f32\n}\n\nstruct GlobalFilterUniforms {\n  inputSize:vec4<f32>,\n  inputPixel:vec4<f32>,\n  inputClamp:vec4<f32>,\n  outputFrame:vec4<f32>,\n  backgroundFrame:vec4<f32>,\n  globalFrame:vec4<f32>,\n};\n\nstruct BlendUniforms {\n  uBlend:f32,\n};\n\n@group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n\n@group(1) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(1) @binding(1) var myTexture: texture_2d<f32>;\n@group(1) @binding(2) var mySampler : sampler;\n@group(1) @binding(3) var backTexture: texture_2d<f32>;\n\n@group(2) @binding(0) var<uniform> blendUniforms : BlendUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) backgroundUv : vec2<f32>,\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;\n\n    return vec4((globalUniforms.projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);\n}\n\nfn filterBackgroundTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * aPosition * gfu.backgroundFrame.zw;\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  \n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   filterBackgroundTextureCoord(aPosition),\n  );\n}\n\n{FUNCTIONS}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) backgroundUv: vec2<f32>,\n) -> @location(0) vec4<f32> {\n\n\n   var back =  textureSample(backTexture, mySampler, backgroundUv);\n   var front = textureSample(myTexture, mySampler, uv);\n   \n   var out = vec4<f32>(0.0,0.0,0.0,0.0);\n\n   {MAIN}\n\n   return out;\n}";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/BlendModeFilter.mjs
function compileBlendModeShader(options) {
  const { source: source3, functions, main } = options;
  return source3.replace("{FUNCTIONS}", functions).replace("{MAIN}", main);
}
var BlendModeFilter;
var init_BlendModeFilter = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/BlendModeFilter.mjs"() {
    init_GlProgram();
    init_GpuProgram();
    init_UniformGroup();
    init_Texture();
    init_Filter();
    init_blend_template();
    init_blend_template2();
    init_blend_template3();
    BlendModeFilter = class extends Filter {
      constructor(options) {
        const gpuOptions = options.gpu;
        const gpuSource = compileBlendModeShader({ source: blendTemplate, ...gpuOptions });
        const gpuProgram = new GpuProgram({
          vertex: {
            source: gpuSource,
            entryPoint: "mainVertex"
          },
          fragment: {
            source: gpuSource,
            entryPoint: "mainFragment"
          }
        });
        const glOptions = options.gl;
        const glSource = compileBlendModeShader({ source: blendTemplateFrag, ...glOptions });
        const glProgram = new GlProgram({
          vertex: blendTemplateVert,
          fragment: glSource
        });
        const uniformGroup = new UniformGroup({
          uBlend: {
            value: 1,
            type: "f32"
          }
        });
        super({
          gpuProgram,
          glProgram,
          blendRequired: true,
          resources: {
            blendUniforms: uniformGroup,
            backTexture: Texture.EMPTY
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/hls/GLhls.mjs
var hslgl;
var init_GLhls = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/hls/GLhls.mjs"() {
    hslgl = `
	float getLuminosity(vec3 c) {
		return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;
	}

	vec3 setLuminosity(vec3 c, float lum) {
		float modLum = lum - getLuminosity(c);
		vec3 color = c.rgb + vec3(modLum);

		// clip back into legal range
		modLum = getLuminosity(color);
		vec3 modLumVec = vec3(modLum);

		float cMin = min(color.r, min(color.g, color.b));
		float cMax = max(color.r, max(color.g, color.b));

		if(cMin < 0.0) {
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0) {
			color = mix(modLumVec, color, (1.0 - modLum) / (cMax - modLum));
		}

		return color;
	}

	float getSaturation(vec3 c) {
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	vec3 setSaturationMinMidMax(vec3 cSorted, float s) {
		vec3 colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x) {
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else {
			colorSorted.y = 0.0;
			colorSorted.z = 0.0;
		}

		colorSorted.x = 0.0;

		return colorSorted;
	}

	vec3 setSaturation(vec3 c, float s) {
		vec3 color = c;

		if(color.r <= color.g && color.r <= color.b) {
			if(color.g <= color.b) {
				color = setSaturationMinMidMax(color.rgb, s).rgb;
			}
			else {
				color = setSaturationMinMidMax(color.rbg, s).rbg;
			}
		}
		else if(color.g <= color.r && color.g <= color.b) {
			if(color.r <= color.b) {
				color = setSaturationMinMidMax(color.grb, s).grb;
			}
			else {
				color = setSaturationMinMidMax(color.gbr, s).gbr;
			}
		}
		else {
			// Using bgr for both fixes part of hue
			if(color.r <= color.g) {
				color = setSaturationMinMidMax(color.brg, s).brg;
			}
			else {
				color = setSaturationMinMidMax(color.bgr, s).bgr;
			}
		}

		return color;
	}
    `;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/hls/GPUhls.mjs
var hslgpu;
var init_GPUhls = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/hls/GPUhls.mjs"() {
    hslgpu = `
	fn getLuminosity(c: vec3<f32>) -> f32
	{
		return 0.3*c.r + 0.59*c.g + 0.11*c.b;
	}

	fn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32>
	{
		var modLum: f32 = lum - getLuminosity(c);
		var color: vec3<f32> = c.rgb + modLum;

		// clip back into legal range
		modLum = getLuminosity(color);
		let modLumVec = vec3<f32>(modLum);

		let cMin: f32 = min(color.r, min(color.g, color.b));
		let cMax: f32 = max(color.r, max(color.g, color.b));

		if(cMin < 0.0)
		{
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0)
		{
			color = mix(modLumVec, color, (1 - modLum) / (cMax - modLum));
		}

		return color;
	}

	fn getSaturation(c: vec3<f32>) -> f32
	{
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	fn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32>
	{
		var colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x)
		{
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else
		{
			colorSorted.y = 0;
			colorSorted.z = 0;
		}

		colorSorted.x = 0;

		return colorSorted;
	}

	fn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32>
	{
		var color = c;

		if (color.r <= color.g && color.r <= color.b)
		{
			if (color.g <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rgb, s)).rgb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rbg, s)).rbg;
			}
		}
		else if (color.g <= color.r && color.g <= color.b)
		{
			if (color.r <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.grb, s)).grb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.gbr, s)).gbr;
			}
		}
		else
		{
			// Using bgr for both fixes part of hue
			if (color.r <= color.g)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.brg, s)).brg;
			}
			else
			{
				color  = vec3<f32>(setSaturationMinMidMax(color.bgr, s)).bgr;
			}
		}

		return color;
	}
	`;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/ColorBlend.mjs
var ColorBlend;
var init_ColorBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/ColorBlend.mjs"() {
    init_BlendModeFilter();
    init_GLhls();
    init_GPUhls();
    ColorBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                ${hslgl}

                vec3 blendColor(vec3 base, vec3 blend,  float opacity)
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendColor(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                ${hslgpu}

                fn blendColorOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendColorOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/ColorBurnBlend.mjs
var ColorBurnBlend;
var init_ColorBurnBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/ColorBurnBlend.mjs"() {
    init_BlendModeFilter();
    ColorBurnBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0 - ((1.0 - base) / blend)), 0.0);
                }

                vec3 blendColorBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                fragColor = vec4(blendColorBurn(back.rgb, front.rgb, front.a), uBlend);
            `
          },
          gpu: {
            functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn blendColorBurn(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendColorBurn(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/ColorDodgeBlend.mjs
var ColorDodgeBlend;
var init_ColorDodgeBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/ColorDodgeBlend.mjs"() {
    init_BlendModeFilter();
    ColorDodgeBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float colorDodge(float base, float blend)
                {
                    return base / (1.0 - blend);
                }

                vec3 blendColorDodge(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendColorDodge(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return base / (1.0 - blend);
                }

                fn blendColorDodge(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                    out = vec4<f32>(blendColorDodge(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/DarkenBlend.mjs
var DarkenBlend;
var init_DarkenBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/DarkenBlend.mjs"() {
    init_BlendModeFilter();
    DarkenBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                vec3 blendDarken(vec3 base, vec3 blend, float opacity)
                {
                    return (min(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendDarken(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn blendDarken(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (min(blend,base) * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendDarken(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/DifferenceBlend.mjs
var DifferenceBlend;
var init_DifferenceBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/DifferenceBlend.mjs"() {
    init_BlendModeFilter();
    DifferenceBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                vec3 blendDifference(vec3 base, vec3 blend,  float opacity)
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                fragColor = vec4(blendDifference(back.rgb, front.rgb, front.a), uBlend);
            `
          },
          gpu: {
            functions: `
                fn blendDifference(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendDifference(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/DivideBlend.mjs
var DivideBlend;
var init_DivideBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/DivideBlend.mjs"() {
    init_BlendModeFilter();
    DivideBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float divide(float base, float blend)
                {
                    return (blend > 0.0) ? clamp(base / blend, 0.0, 1.0) : 1.0;
                }

                vec3 blendDivide(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendDivide(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn divide(base: f32, blend: f32) -> f32
                {
                    return select(1.0, clamp(base / blend, 0.0, 1.0), blend > 0.0);
                }

                fn blendDivide(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendDivide(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/ExclusionBlend.mjs
var ExclusionBlend;
var init_ExclusionBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/ExclusionBlend.mjs"() {
    init_BlendModeFilter();
    ExclusionBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                vec3 exclusion(vec3 base, vec3 blend)
                {
                    return base + blend - 2.0 * base * blend;
                }

                vec3 blendExclusion(vec3 base, vec3 blend, float opacity)
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendExclusion(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn exclusion(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return base+blend-2.0*base*blend;
                }

                fn blendExclusion(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendExclusion(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/HardLightBlend.mjs
var HardLightBlend;
var init_HardLightBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/HardLightBlend.mjs"() {
    init_BlendModeFilter();
    HardLightBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float hardLight(float base, float blend)
                {
                    return (blend < 0.5) ? 2.0 * base * blend : 1.0 - 2.0 * (1.0 - base) * (1.0 - blend);
                }

                vec3 blendHardLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                fragColor = vec4(blendHardLight(back.rgb, front.rgb, front.a), uBlend);
            `
          },
          gpu: {
            functions: `
                fn hardLight(base: f32, blend: f32) -> f32
                {
                    return select(1.0 - 2.0 * (1.0 - base) * (1.0 - blend), 2.0 * base * blend, blend < 0.5);
                }

                fn blendHardLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendHardLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/HardMixBlend.mjs
var HardMixBlend;
var init_HardMixBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/HardMixBlend.mjs"() {
    init_BlendModeFilter();
    HardMixBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float hardMix(float base, float blend)
                {
                    return (base + blend >= 1.0) ? 1.0 : 0.0;
                }

                vec3 blendHardMix(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blended = vec3(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                fragColor = vec4(blendHardMix(back.rgb, front.rgb, front.a), uBlend);
            `
          },
          gpu: {
            functions: `
                fn hardMix(base: f32, blend: f32) -> f32
                {
                    return select(0.0, 1.0, base + blend >= 1.0);
                }

                fn blendHardMix(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendHardMix(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/LightenBlend.mjs
var LightenBlend;
var init_LightenBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/LightenBlend.mjs"() {
    init_BlendModeFilter();
    LightenBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                vec3 blendLighten(vec3 base, vec3 blend, float opacity)
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendLighten(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn blendLighten(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendLighten(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/LinearBurnBlend.mjs
var LinearBurnBlend;
var init_LinearBurnBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/LinearBurnBlend.mjs"() {
    init_BlendModeFilter();
    LinearBurnBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float linearBurn(float base, float blend)
                {
                    return max(0.0, base + blend - 1.0);
                }

                vec3 blendLinearBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendLinearBurn(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn blendLinearBurn(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendLinearBurn(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/LinearDodgeBlend.mjs
var LinearDodgeBlend;
var init_LinearDodgeBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/LinearDodgeBlend.mjs"() {
    init_BlendModeFilter();
    LinearDodgeBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                vec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendLinearDodge(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1, base + blend);
                }

                fn blendLinearDodge(base:vec3<f32>, blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendLinearDodge(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/LinearLightBlend.mjs
var LinearLightBlend;
var init_LinearLightBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/LinearLightBlend.mjs"() {
    init_BlendModeFilter();
    LinearLightBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float linearBurn(float base, float blend) {
                    return max(0.0, base + blend - 1.0);
                }

                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                float linearLight(float base, float blend) {
                    return (blend <= 0.5) ? linearBurn(base,2.0*blend) : linearBurn(base,2.0*(blend-0.5));
                }

                vec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                fragColor = vec4(blendLinearLight(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base + blend);
                }

                fn linearLight(base: f32, blend: f32) -> f32
                {
                    return select(linearBurn(base,2.0*(blend-0.5)), linearBurn(base,2.0*blend), blend <= 0.5);
                }

                fn blendLinearLightOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendLinearLightOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/LuminosityBlend.mjs
var LuminosityBlend;
var init_LuminosityBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/LuminosityBlend.mjs"() {
    init_BlendModeFilter();
    init_GLhls();
    init_GPUhls();
    LuminosityBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                ${hslgl}

                vec3 blendLuminosity(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendLuminosity = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendLuminosity(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                ${hslgpu}

                fn blendLuminosity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendLuminosity: vec3<f32> = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendLuminosity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/NegationBlend.mjs
var NegationBlend;
var init_NegationBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/NegationBlend.mjs"() {
    init_BlendModeFilter();
    NegationBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                vec3 negation(vec3 base, vec3 blend)
                {
                    return 1.0-abs(1.0-base-blend);
                }

                vec3 blendNegation(vec3 base, vec3 blend, float opacity)
                {
                    return (negation(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendNegation(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn blendNegation(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return 1.0-abs(1.0-base-blend);
                }

                fn blendNegationOpacity(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (blendNegation(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendNegationOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/OverlayBlend.mjs
var OverlayBlend;
var init_OverlayBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/OverlayBlend.mjs"() {
    init_BlendModeFilter();
    OverlayBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float overlay(float base, float blend)
                {
                    return (blend < 0.5) ? (2.0*base*blend) : (1.0-2.0*(1.0-base)*(1.0-blend));
                }

                vec3 blendOverlay(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendOverlay(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn overlay(base: f32, blend: f32) -> f32
                {
                    return select((1.0-2.0*(1.0-base)*(1.0-blend)), (2.0*base*blend), base < 0.5);
                }

                fn blendOverlay(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendOverlay(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/PinLightBlend.mjs
var PinLightBlend;
var init_PinLightBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/PinLightBlend.mjs"() {
    init_BlendModeFilter();
    PinLightBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float pinLight(float base, float blend)
                {
                    return (blend <= 0.5) ? min(base, 2.0 * blend) : max(base, 2.0 * (blend - 0.5));
                }

                vec3 blendPinLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                fragColor = vec4(blendPinLight(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn pinLight(base: f32, blend: f32) -> f32
                {
                    return select(max(base,2.0*(blend-0.5)), min(base,2.0*blend), blend <= 0.5);
                }

                fn blendPinLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendPinLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/SaturationBlend.mjs
var SaturationBlend;
var init_SaturationBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/SaturationBlend.mjs"() {
    init_BlendModeFilter();
    init_GLhls();
    init_GPUhls();
    SaturationBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                ${hslgl}

                vec3 blendSaturation(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                fragColor = vec4(blendSaturation(back.rgb, front.rgb, front.a), uBlend);
            `
          },
          gpu: {
            functions: `
                ${hslgpu}

                fn blendSaturation(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendSaturation(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/SoftLightBlend.mjs
var SoftLightBlend;
var init_SoftLightBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/SoftLightBlend.mjs"() {
    init_BlendModeFilter();
    SoftLightBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float softLight(float base, float blend)
                {
                    return (blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));
                }

                vec3 blendSoftLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendSoftLight(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn softLight(base: f32, blend: f32) -> f32
                {
                    return select(2.0 * base * blend + base * base * (1.0 - 2.0 * blend), sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend), blend < 0.5);
                }

                fn blendSoftLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendSoftLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/SubtractBlend.mjs
var SubtractBlend;
var init_SubtractBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/SubtractBlend.mjs"() {
    init_BlendModeFilter();
    SubtractBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float subtract(float base, float blend)
                {
                    return max(0.0, base - blend);
                }

                vec3 blendSubtract(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                fragColor = vec4(blendSubtract(back.rgb, front.rgb, front.a), uBlend);
                `
          },
          gpu: {
            functions: `
                fn subtract(base: f32, blend: f32) -> f32
                {
                    return max(0, base - blend);
                }

                fn blendSubtract(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendSubtract(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/VividLightBlend.mjs
var VividLightBlend;
var init_VividLightBlend = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/blend-modes/VividLightBlend.mjs"() {
    init_BlendModeFilter();
    VividLightBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                float colorDodge(float base, float blend)
                {
                    return min(1.0, base / (1.0-blend));
                }

                float vividLight(float base, float blend)
                {
                    return (blend < 0.5) ? colorBurn(base,(2.0*blend)) : colorDodge(base,(2.0*(blend-0.5)));
                }

                vec3 blendVividLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                fragColor = vec4(blendVividLight(back.rgb, front.rgb, front.a), uBlend);
            `
          },
          gpu: {
            functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base / (1.0-blend));
                }

                fn vividLight(base: f32, blend: f32) -> f32
                {
                    return select(colorDodge(base,(2.0*(blend-0.5))), colorBurn(base,(2.0*blend)), blend<0.5);
                }

                fn blendVividLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendVividLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/BlendModePipe.mjs
var BLEND_MODE_FILTERS, BlendModePipe;
var init_BlendModePipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/BlendModePipe.mjs"() {
    init_Extensions();
    init_ColorBlend();
    init_ColorBurnBlend();
    init_ColorDodgeBlend();
    init_DarkenBlend();
    init_DifferenceBlend();
    init_DivideBlend();
    init_ExclusionBlend();
    init_HardLightBlend();
    init_HardMixBlend();
    init_LightenBlend();
    init_LinearBurnBlend();
    init_LinearDodgeBlend();
    init_LinearLightBlend();
    init_LuminosityBlend();
    init_NegationBlend();
    init_OverlayBlend();
    init_PinLightBlend();
    init_SaturationBlend();
    init_SoftLightBlend();
    init_SubtractBlend();
    init_VividLightBlend();
    init_FilterEffect();
    BLEND_MODE_FILTERS = {
      color: ColorBlend,
      "color-burn": ColorBurnBlend,
      "color-dodge": ColorDodgeBlend,
      darken: DarkenBlend,
      difference: DifferenceBlend,
      divide: DivideBlend,
      exclusion: ExclusionBlend,
      "hard-light": HardLightBlend,
      "hard-mix": HardMixBlend,
      lighten: LightenBlend,
      "linear-burn": LinearBurnBlend,
      "linear-dodge": LinearDodgeBlend,
      "linear-light": LinearLightBlend,
      luminosity: LuminosityBlend,
      negation: NegationBlend,
      overlay: OverlayBlend,
      "pin-light": PinLightBlend,
      saturation: SaturationBlend,
      "soft-light": SoftLightBlend,
      subtract: SubtractBlend,
      "vivid-light": VividLightBlend
    };
    BlendModePipe = class {
      constructor(renderer) {
        this.isAdvanced = false;
        this.filterHash = {};
        this.renderer = renderer;
      }
      setBlendMode(renderable, blendMode, instructionSet) {
        if (this.activeBlendMode === blendMode) {
          if (this.isAdvanced) {
            this.renderableList.push(renderable);
          }
          return;
        }
        this.activeBlendMode = blendMode;
        if (this.isAdvanced) {
          this.endAdvancedBlendMode(instructionSet);
        }
        this.isAdvanced = !!BLEND_MODE_FILTERS[blendMode];
        if (this.isAdvanced) {
          this.beginAdvancedBlendMode(instructionSet);
          this.renderableList.push(renderable);
        }
      }
      beginAdvancedBlendMode(instructionSet) {
        this.renderer.renderPipes.batch.break(instructionSet);
        const blendMode = this.activeBlendMode;
        if (!BLEND_MODE_FILTERS[blendMode]) {
          console.warn(`Unable to assign 'BLEND_MODES.${blendMode}' using the blend mode pipeline`);
          return;
        }
        if (!this.filterHash[blendMode]) {
          this.filterHash[blendMode] = new FilterEffect({
            filters: [new BLEND_MODE_FILTERS[blendMode]()]
          });
        }
        const instruction = {
          type: "filter",
          action: "pushFilter",
          renderables: [],
          filterEffect: this.filterHash[blendMode],
          canBundle: false
        };
        this.renderableList = instruction.renderables;
        instructionSet.add(instruction);
      }
      endAdvancedBlendMode(instructionSet) {
        this.renderableList = null;
        this.renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          type: "filter",
          action: "popFilter",
          canBundle: false
        });
      }
      buildStart() {
        this.isAdvanced = false;
      }
      buildEnd(instructionSet) {
        if (this.isAdvanced) {
          this.endAdvancedBlendMode(instructionSet);
        }
      }
      destroy() {
        this.renderer = null;
        this.renderableList = null;
        for (const i in this.filterHash) {
          this.filterHash[i].destroy();
        }
        this.filterHash = null;
      }
    };
    BlendModePipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "blendMode"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs
var GlobalUniformSystem;
var init_GlobalUniformSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs"() {
    init_Extensions();
    init_Matrix();
    init_Point();
    init_BindGroup();
    init_UniformGroup();
    GlobalUniformSystem = class {
      constructor(renderer) {
        this.stackIndex = 0;
        this.globalUniformDataStack = [];
        this.uniformsPool = [];
        this.activeUniforms = [];
        this.bindGroupPool = [];
        this.activeBindGroups = [];
        this.renderer = renderer;
      }
      reset() {
        this.stackIndex = 0;
        for (let i = 0; i < this.activeUniforms.length; i++) {
          this.uniformsPool.push(this.activeUniforms[i]);
        }
        for (let i = 0; i < this.activeBindGroups.length; i++) {
          this.bindGroupPool.push(this.activeBindGroups[i]);
        }
        this.activeUniforms.length = 0;
        this.activeBindGroups.length = 0;
      }
      start(options) {
        this.reset();
        this.push(options);
      }
      bind({
        projectionMatrix,
        worldTransformMatrix,
        worldColor,
        offset
      }) {
        const currentGlobalUniformData = this.stackIndex ? this.globalUniformDataStack[this.stackIndex - 1] : {
          projectionMatrix: this.renderer.renderTarget.renderTarget.projectionMatrix,
          worldTransformMatrix: new Matrix(),
          worldColor: 4294967295,
          offset: new Point()
        };
        const globalUniformData = {
          projectionMatrix: projectionMatrix || this.renderer.renderTarget.renderTarget.projectionMatrix,
          worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,
          worldColor: worldColor || currentGlobalUniformData.worldColor,
          offset: offset || currentGlobalUniformData.offset,
          bindGroup: null
        };
        const uniformGroup = this.uniformsPool.pop() || this.createUniforms();
        this.activeUniforms.push(uniformGroup);
        const uniforms = uniformGroup.uniforms;
        uniforms.projectionMatrix = globalUniformData.projectionMatrix;
        uniforms.worldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);
        uniforms.worldTransformMatrix.tx -= globalUniformData.offset.x;
        uniforms.worldTransformMatrix.ty -= globalUniformData.offset.y;
        uniforms.worldAlpha = (globalUniformData.worldColor >> 24 & 255) / 255;
        uniformGroup.update();
        let bindGroup;
        if (this.renderer.renderPipes.uniformBatch) {
          bindGroup = this.renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);
        } else {
          this.renderer.uniformBuffer.updateUniformGroup(uniformGroup);
          bindGroup = this.bindGroupPool.pop() || new BindGroup();
          this.activeBindGroups.push(bindGroup);
          bindGroup.setResource(uniformGroup, 0);
        }
        globalUniformData.bindGroup = bindGroup;
        this.currentGlobalUniformData = globalUniformData;
      }
      push(options) {
        this.bind(options);
        this.globalUniformDataStack[this.stackIndex++] = this.currentGlobalUniformData;
      }
      pop() {
        this.currentGlobalUniformData = this.globalUniformDataStack[--this.stackIndex - 1];
      }
      get bindGroup() {
        return this.currentGlobalUniformData.bindGroup;
      }
      get uniformGroup() {
        return this.currentGlobalUniformData.bindGroup.resources[0];
      }
      createUniforms() {
        const globalUniforms = new UniformGroup({
          projectionMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          worldTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>
          worldAlpha: { value: 1, type: "f32" }
        }, {
          ubo: true,
          isStatic: true
        });
        return globalUniforms;
      }
      destroy() {
      }
    };
    GlobalUniformSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "globalUniforms"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUBOElements.mjs
function createUBOElements(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    size: 0
  }));
  let size2 = 0;
  let chunkSize = 0;
  let offset = 0;
  for (let i = 0; i < uboElements.length; i++) {
    const uboElement = uboElements[i];
    size2 = WGSL_TO_STD40_SIZE[uboElement.data.type];
    if (!size2) {
      throw new Error(`Unknown type ${uboElement.data.type}`);
    }
    if (uboElement.data.size > 1) {
      size2 = Math.max(size2, 16) * uboElement.data.size;
    }
    uboElement.size = size2;
    if (chunkSize % size2 !== 0 && chunkSize < 16) {
      const lineUpValue = chunkSize % size2 % 16;
      chunkSize += lineUpValue;
      offset += lineUpValue;
    }
    if (chunkSize + size2 > 16) {
      offset = Math.ceil(offset / 16) * 16;
      uboElement.offset = offset;
      offset += size2;
      chunkSize = size2;
    } else {
      uboElement.offset = offset;
      chunkSize += size2;
      offset += size2;
    }
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}
var WGSL_TO_STD40_SIZE;
var init_createUBOElements = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUBOElements.mjs"() {
    WGSL_TO_STD40_SIZE = {
      "f32": 4,
      "vec2<f32>": 8,
      "vec3<f32>": 12,
      "vec4<f32>": 16,
      "mat2x2<f32>": 16 * 3,
      "mat3x3<f32>": 16 * 3,
      "mat4x4<f32>": 16 * 4
      // float:  4,
      // vec2:   8,
      // vec3:   12,
      // vec4:   16,
      // int:      4,
      // ivec2:    8,
      // ivec3:    12,
      // ivec4:    16,
      // uint:     4,
      // uvec2:    8,
      // uvec3:    12,
      // uvec4:    16,
      // bool:     4,
      // bvec2:    8,
      // bvec3:    12,
      // bvec4:    16,
      // mat2:     16 * 2,
      // mat3:     16 * 3,
      // mat4:     16 * 4,
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformBufferParsers.mjs
var uniformBufferParsers;
var init_uniformBufferParsers = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformBufferParsers.mjs"() {
    uniformBufferParsers = [
      // uploading pixi matrix object to mat3
      {
        type: "mat3x3<f32>",
        test: (data) => data.value.a !== void 0,
        code: (name) => `
                var ${name}_matrix = uv.${name}.toArray(true);

                data[offset] = ${name}_matrix[0];
                data[offset+1] = ${name}_matrix[1];
                data[offset+2] = ${name}_matrix[2];

                data[offset + 4] = ${name}_matrix[3];
                data[offset + 5] = ${name}_matrix[4];
                data[offset + 6] = ${name}_matrix[5];

                data[offset + 8] = ${name}_matrix[6];
                data[offset + 9] = ${name}_matrix[7];
                data[offset + 10] = ${name}_matrix[8];
            `
      },
      {
        type: "vec4<f32>",
        test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.width !== void 0,
        code: (name) => `
                        v = uv.${name};

                        data[offset] = v.x;
                        data[offset+1] = v.y;
                        data[offset+2] = v.width;
                        data[offset+3] = v.height;
                    `
      },
      {
        type: "vec2<f32>",
        test: (data) => data.type === "vec2<f32>" && data.size === 1 && data.value.x !== void 0,
        code: (name) => `
                    v = uv.${name};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                `
      }
      // uploading a pixi point as a vec2 with caching layer
      // {
      //     test: (data: any, uniform: any): boolean =>
      //         data.type === 'vec2' && data.size === 1 && uniform.x !== undefined,
      //     code: (name: string): string =>
      //         `
      //             v = uv.${name};
      //             data[offset] = v.x;
      //             data[offset+1] = v.y;
      //         `,
      // },
      // caching layer for a vec2
      // {
      //     test: (data: any): boolean =>
      //         data.type === 'vec2' && data.size === 1,
      //     code: (name: string): string =>
      //         `
      //             cv = ud["${name}"].value;
      //             v = uv["${name}"];
      //             if(cv[0] !== v[0] || cv[1] !== v[1])
      //             {
      //                 cv[0] = v[0];
      //                 cv[1] = v[1];
      //                 gl.uniform2f(ud["${name}"].location, v[0], v[1]);
      //             }
      //         `,
      // },
      // upload a pixi rectangle as a vec4 with caching layer
      // {
      //     test: (data: any, uniform: any): boolean =>
      //         data.type === 'vec4' && data.size === 1 && uniform.width !== undefined,
      //     code: (name: string): string =>
      //         `
      //                 v = uv.${name};
      //                 data[offset] = v.x;
      //                 data[offset+1] = v.y;
      //                 data[offset+2] = v.width;
      //                 data[offset+3] = v.height;
      //             `,
      // },
      // a caching layer for vec4 uploading
      // {
      //     test: (data: any): boolean =>
      //         data.type === 'vec4' && data.size === 1,
      //     code: (name: string): string =>
      //         `
      //             cv = ud["${name}"].value;
      //             v = uv["${name}"];
      //             if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
      //             {
      //                 cv[0] = v[0];
      //                 cv[1] = v[1];
      //                 cv[2] = v[2];
      //                 cv[3] = v[3];
      //                 gl.uniform4f(ud["${name}"].location, v[0], v[1], v[2], v[3])
      //             }`,
      // },
    ];
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUniformBufferSync.mjs
function generateUniformBufferSync(uboElements) {
  const funcFragments = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
    `];
  let prev = 0;
  for (let i = 0; i < uboElements.length; i++) {
    const uboElement = uboElements[i];
    const name = uboElement.data.name;
    let parsed = false;
    let offset = 0;
    for (let j2 = 0; j2 < uniformBufferParsers.length; j2++) {
      const uniformParser = uniformBufferParsers[j2];
      if (uniformParser.test(uboElement.data)) {
        offset = uboElement.offset / 4;
        funcFragments.push(
          `offset += ${offset - prev};`,
          uniformBufferParsers[j2].code(name)
        );
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      if (uboElement.data.size > 1) {
        const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
        const elementSize = uboElement.data.value.length / uboElement.data.size;
        const remainder = (4 - elementSize % 4) % 4;
        offset = uboElement.offset / 4;
        funcFragments.push(
          /* wgsl */
          `
                    v = uv.${name};
                    offset += ${offset - prev};

                    t = 0;

                    for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
                    {
                        for(var j = 0; j < ${elementSize}; j++)
                        {
                            data[offset++] = v[t++];
                        }
                        offset += ${remainder};
                    }
                `
        );
      } else {
        const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
        offset = uboElement.offset / 4;
        funcFragments.push(
          /* wgsl */
          `
                    v = uv.${name};
                    offset += ${offset - prev};
                    ${template};
                `
        );
      }
    }
    prev = offset;
  }
  const fragmentSrc4 = funcFragments.join("\n");
  return new Function(
    "uv",
    "data",
    "offset",
    fragmentSrc4
  );
}
var UBO_TO_SINGLE_SETTERS;
var init_createUniformBufferSync = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUniformBufferSync.mjs"() {
    init_createUBOElements();
    init_uniformBufferParsers();
    UBO_TO_SINGLE_SETTERS = {
      "f32": `
        data[offset] = v;
    `,
      "vec2<f32>": `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
      "vec3<f32>": `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
      "vec4<f32>": `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
      "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
      "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
      "mat4x4<f32>": `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformBufferSystem.mjs
var UniformBufferSystem;
var init_UniformBufferSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformBufferSystem.mjs"() {
    init_Extensions();
    init_Buffer();
    init_const5();
    init_createUBOElements();
    init_createUniformBufferSync();
    UniformBufferSystem = class {
      constructor(renderer) {
        this._syncFunctionHash = {};
        this.renderer = renderer;
      }
      ensureUniformGroup(uniformGroup) {
        if (!uniformGroup._syncFunction) {
          this.initUniformGroup(uniformGroup);
        }
      }
      initUniformGroup(uniformGroup) {
        const uniformGroupSignature = uniformGroup.signature;
        let uniformData = this._syncFunctionHash[uniformGroupSignature];
        if (!uniformData) {
          const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);
          const layout = createUBOElements(elements);
          const syncFunction = generateUniformBufferSync(layout.uboElements);
          uniformData = this._syncFunctionHash[uniformGroupSignature] = {
            layout,
            syncFunction
          };
        }
        uniformGroup._syncFunction = uniformData.syncFunction;
        uniformGroup.buffer = new Buffer2({
          data: new Float32Array(uniformData.layout.size / 4),
          usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
        });
        return uniformGroup._syncFunction;
      }
      syncUniformGroup(uniformGroup, data, offset) {
        const syncFunction = uniformGroup._syncFunction || this.initUniformGroup(uniformGroup);
        data || (data = uniformGroup.buffer.data);
        offset || (offset = 0);
        syncFunction(uniformGroup.uniforms, data, offset);
        return true;
      }
      updateUniformGroup(uniformGroup) {
        if (uniformGroup.isStatic && !uniformGroup.dirtyId)
          return false;
        uniformGroup.dirtyId = 0;
        const synced = this.syncUniformGroup(uniformGroup);
        uniformGroup.buffer.update();
        return synced;
      }
      destroy() {
        throw new Error("Method not implemented.");
      }
    };
    UniformBufferSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "uniformBuffer"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/sayHello.mjs
function sayHello(type) {
  if (saidHello) {
    return;
  }
  if (settings.ADAPTER.getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
    const args = [
      `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/

`,
      "background: #E72264; padding:5px 0;",
      "background: #6CA2EA; padding:5px 0;",
      "background: #B5D33D; padding:5px 0;",
      "background: #FED23F; padding:5px 0;",
      "color: #FFFFFF; background: #E72264; padding:5px 0;",
      "color: #E72264; background: #FFFFFF; padding:5px 0;"
    ];
    globalThis.console.log(...args);
  } else if (globalThis.console) {
    globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);
  }
  saidHello = true;
}
var saidHello, VERSION;
var init_sayHello = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/sayHello.mjs"() {
    init_settings();
    saidHello = false;
    VERSION = "8.0.0-alpha.1";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs
var HelloSystem;
var init_HelloSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs"() {
    init_Extensions();
    init_sayHello();
    HelloSystem = class {
      constructor(renderer) {
        this.renderer = renderer;
      }
      /**
       * It all starts here! This initiates every system, passing in the options for any system by name.
       * @param options - the config for the renderer and all its systems
       */
      init(options) {
        if (options.hello) {
          sayHello(this.renderer.type);
        }
      }
    };
    HelloSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "hello",
      priority: 0
    };
    HelloSystem.defaultOptions = {
      /**
       * {@link PIXI.WebGLOptions.hello}
       * @default false
       */
      hello: false
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs
var CanvasSource;
var init_CanvasSource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs"() {
    init_settings();
    init_TextureSource();
    CanvasSource = class extends TextureSource {
      constructor(options) {
        if (!options.resource) {
          options.resource = settings.ADAPTER.createCanvas();
        }
        if (!options.width) {
          options.width = options.resource.width;
          if (!options.autoDensity) {
            options.width /= options.resolution;
          }
        }
        if (!options.height) {
          options.height = options.resource.height;
          if (!options.autoDensity) {
            options.height /= options.resolution;
          }
        }
        super(options);
        this.type = "image";
        this.alphaMode = 0;
        this.autoDensity = options.autoDensity;
        const canvas2 = options.resource;
        if (this.pixelWidth !== canvas2.width || this.pixelWidth !== canvas2.height) {
          this.resizeCanvas();
        }
      }
      resizeCanvas() {
        if (this.autoDensity) {
          this.resource.style.width = `${this.width}px`;
          this.resource.style.height = `${this.height}px`;
        }
        this.resource.width = this.pixelWidth;
        this.resource.height = this.pixelHeight;
      }
      resize(width = this.width, height = this.height, resolution = this._resolution) {
        super.resize(width, height, resolution);
        this.resizeCanvas();
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs
function getCanvasTexture(canvas2, options) {
  if (!canvasCache.has(canvas2)) {
    const texture = new Texture({
      source: new CanvasSource({
        resource: canvas2,
        ...options
      })
    });
    canvasCache.set(canvas2, texture);
  }
  return canvasCache.get(canvas2);
}
var canvasCache;
var init_getCanvasTexture = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs"() {
    init_CanvasSource();
    init_Texture();
    canvasCache = /* @__PURE__ */ new Map();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/ViewSystem.mjs
var ViewSystem;
var init_ViewSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/ViewSystem.mjs"() {
    init_Extensions();
    init_settings();
    init_getCanvasTexture();
    ViewSystem = class {
      constructor(renderer) {
        this.renderer = renderer;
      }
      get resolution() {
        return this.texture.source._resolution;
      }
      set resolution(value) {
        this.texture.source.resize(
          this.texture.source.width,
          this.texture.source.height,
          value
        );
      }
      /**
       * initiates the view system
       * @param options - the options for the view
       */
      init(options) {
        this.element = options.element || settings.ADAPTER.createCanvas();
        this.antialias = !!options.antialias;
        this.texture = getCanvasTexture(this.element, options);
        this.multiView = !!options.multiView;
        if (this.autoDensity) {
          this.element.style.width = `${this.texture.width}px`;
          this.element.style.height = `${this.texture.height}px`;
        }
      }
      /**
       * Resizes the screen and canvas to the specified dimensions.
       * @param desiredScreenWidth - The new width of the screen.
       * @param desiredScreenHeight - The new height of the screen.
       * @param resolution
       */
      resize(desiredScreenWidth, desiredScreenHeight, resolution) {
        this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);
        if (this.autoDensity) {
          this.element.style.width = `${desiredScreenWidth}px`;
          this.element.style.height = `${desiredScreenHeight}px`;
        }
      }
      /**
       * Destroys this System and optionally removes the canvas from the dom.
       * @param {boolean} [removeView=false] - Whether to remove the canvas from the DOM.
       */
      destroy(removeView) {
        if (removeView && this.element.parentNode) {
          this.element.parentNode.removeChild(this.element);
        }
        this.element = null;
      }
    };
    ViewSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "view",
      priority: 0
    };
    ViewSystem.defaultOptions = {
      /**
       * {@link PIXI.WebGLOptions.width}
       * @default 800
       */
      width: 800,
      /**
       * {@link PIXI.WebGLOptions.height}
       * @default 600
       */
      height: 600,
      /**
       * {@link PIXI.WebGLOptions.resolution}
       * @type {number}
       * @default PIXI.settings.RESOLUTION
       */
      resolution: settings.RESOLUTION,
      /**
       * {@link PIXI.WebGLOptions.autoDensity}
       * @default false
       */
      autoDensity: true,
      /**
       * {@link PIXI.WebGLOptions.antialias}
       * @default false
       */
      antialias: false
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs
var SharedSystems, SharedRenderPipes;
var init_SharedSystems = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs"() {
    init_TilingSpritePipe();
    init_BatcherPipe();
    init_FilterPipe();
    init_FilterSystem();
    init_GraphicsContextSystem();
    init_GraphicsPipe();
    init_AlphaMaskPipe();
    init_ColorMaskPipe();
    init_StencilMaskPipe();
    init_MeshPipe();
    init_LayerPipe();
    init_LayerSystem();
    init_SpritePipe();
    init_BitmapTextPipe();
    init_CanvasTextPipe();
    init_CanvasTextSystem();
    init_BackgroundSystem();
    init_BlendModePipe();
    init_GlobalUniformSystem();
    init_UniformBufferSystem();
    init_HelloSystem();
    init_ViewSystem();
    SharedSystems = [
      BackgroundSystem,
      FilterSystem,
      GraphicsContextSystem,
      GlobalUniformSystem,
      HelloSystem,
      ViewSystem,
      CanvasTextSystem,
      LayerSystem,
      UniformBufferSystem
    ];
    SharedRenderPipes = [
      BlendModePipe,
      BatcherPipe,
      SpritePipe,
      LayerPipe,
      MeshPipe,
      GraphicsPipe,
      CanvasTextPipe,
      BitmapTextPipe,
      TilingSpritePipe,
      FilterPipe,
      AlphaMaskPipe,
      StencilMaskPipe,
      ColorMaskPipe
    ];
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs
var BindGroupSystem;
var init_BindGroupSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs"() {
    init_Extensions();
    BindGroupSystem = class {
      // TODO implement a way to tidy up unused bind groups!
      // private bindGroupCount = 0;
      constructor(renderer) {
        this.hash = {};
        this.renderer = renderer;
      }
      contextChange(gpu) {
        this.gpu = gpu;
      }
      getBindGroup(bindGroup, program, groupIndex) {
        bindGroup.updateKey();
        const gpuBindGroup = this.hash[bindGroup.key] || this.createBindGroup(bindGroup, program, groupIndex);
        return gpuBindGroup;
      }
      createBindGroup(group, program, groupIndex) {
        const device = this.gpu.device;
        const groupLayout = program.layout[groupIndex];
        const entries = [];
        for (const j2 in groupLayout) {
          const resource = group.resources[j2] ?? group.resources[groupLayout[j2]];
          let gpuResource;
          if (resource.resourceType === "uniformGroup") {
            const uniformGroup = resource;
            this.renderer.uniformBuffer.updateUniformGroup(uniformGroup);
            const buffer = uniformGroup.buffer;
            gpuResource = {
              buffer: this.renderer.buffer.getGPUBuffer(buffer),
              offset: 0,
              size: buffer.descriptor.size
            };
          } else if (resource.resourceType === "buffer") {
            const buffer = resource;
            gpuResource = {
              buffer: this.renderer.buffer.getGPUBuffer(buffer),
              offset: 0,
              size: buffer.descriptor.size
            };
          } else if (resource.resourceType === "bufferResource") {
            const bufferResource = resource;
            gpuResource = {
              buffer: this.renderer.buffer.getGPUBuffer(bufferResource.buffer),
              offset: bufferResource.offset,
              size: bufferResource.size
            };
          } else if (resource.resourceType === "textureSampler") {
            const sampler = resource;
            gpuResource = this.renderer.texture.getGpuSampler(sampler);
          } else if (resource.resourceType === "textureSource") {
            const texture = resource;
            gpuResource = this.renderer.texture.getGpuSource(texture).createView({});
          }
          entries.push({
            binding: groupLayout[j2],
            resource: gpuResource
          });
        }
        const gpuBindGroup = device.createBindGroup({
          layout: program._gpuLayout.bindGroups[groupIndex],
          entries
        });
        this.hash[group.key] = gpuBindGroup;
        return gpuBindGroup;
      }
      destroy() {
      }
    };
    BindGroupSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "bindGroup"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs
var BufferSystem;
var init_GpuBufferSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs"() {
    init_Extensions();
    init_fastCopy();
    BufferSystem = class {
      constructor() {
        this._gpuBuffers = {};
      }
      contextChange(gpu) {
        this.gpu = gpu;
      }
      getGPUBuffer(buffer) {
        return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
      }
      updateBuffer(buffer) {
        const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
        if (buffer._updateID && buffer.data) {
          buffer._updateID = 0;
          this.gpu.device.queue.writeBuffer(gpuBuffer, 0, buffer.data.buffer, 0, buffer._updateSize);
        }
        return gpuBuffer;
      }
      /** dispose all WebGL resources of all managed buffers */
      destroyAll() {
        for (const id in this._gpuBuffers) {
          this._gpuBuffers[id].destroy();
        }
        this._gpuBuffers = {};
      }
      createGPUBuffer(buffer) {
        const gpuBuffer = this.gpu.device.createBuffer(buffer.descriptor);
        buffer._updateID = 0;
        if (buffer.data) {
          fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());
          gpuBuffer.unmap();
        }
        this._gpuBuffers[buffer.uid] = gpuBuffer;
        buffer.on("update", this.updateBuffer, this);
        buffer.on("change", this.onBufferChange, this);
        buffer.on("destroy", this.onBufferDestroy, this);
        return gpuBuffer;
      }
      onBufferChange(buffer) {
        let gpuBuffer = this._gpuBuffers[buffer.uid];
        gpuBuffer.destroy();
        gpuBuffer = this.createGPUBuffer(buffer);
        buffer._updateID = 0;
      }
      /**
       * Disposes buffer
       * @param buffer - buffer with data
       */
      onBufferDestroy(buffer) {
        const gpuBuffer = this._gpuBuffers[buffer.uid];
        gpuBuffer.destroy();
        this._gpuBuffers[buffer.uid] = null;
      }
      destroy() {
        throw new Error("Method not implemented.");
      }
    };
    BufferSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "buffer"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs
var GpuColorMaskSystem;
var init_GpuColorMaskSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs"() {
    init_Extensions();
    GpuColorMaskSystem = class {
      constructor(renderer) {
        this.colorMaskCache = 15;
        this.renderer = renderer;
      }
      setMask(colorMask) {
        if (this.colorMaskCache === colorMask)
          return;
        this.colorMaskCache = colorMask;
        this.renderer.pipeline.setColorMask(colorMask);
      }
      destroy() {
      }
    };
    GpuColorMaskSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "colorMask"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs
var GpuDeviceSystem;
var init_GpuDeviceSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs"() {
    init_Extensions();
    GpuDeviceSystem = class {
      /**
       * @param {PIXI.Renderer} renderer - The renderer this System works for.
       */
      constructor(renderer) {
        this._renderer = renderer;
      }
      async init() {
        if (this._initPromise)
          return this._initPromise;
        this._initPromise = this.createDeviceAndAdaptor({}).then((gpu) => {
          this.gpu = gpu;
          this._renderer.runners.contextChange.emit(this.gpu);
        });
        return this._initPromise;
      }
      /**
       * Handle the context change event
       * @param gpu
       */
      contextChange(gpu) {
        this._renderer.gpu = gpu;
      }
      /**
       * Helper class to create a WebGL Context
       * @param {object} options - An options object that gets passed in to the canvas element containing the
       *    context attributes
       * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
       * @returns {WebGLRenderingContext} the WebGL context
       */
      async createDeviceAndAdaptor(options) {
        const adapter = await navigator.gpu.requestAdapter(options);
        const device = await adapter.requestDevice();
        return { adapter, device };
      }
      destroy() {
        this._renderer = null;
      }
    };
    GpuDeviceSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "device"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs
var GpuEncoderSystem;
var init_GpuEncoderSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs"() {
    init_Extensions();
    GpuEncoderSystem = class {
      constructor(renderer) {
        this.boundBindGroup = {};
        this.boundVertexBuffer = {};
        this.renderer = renderer;
      }
      start() {
        this.commandFinished = new Promise((resolve) => {
          this.resolveCommandFinished = resolve;
        });
        this.commandEncoder = this.renderer.gpu.device.createCommandEncoder();
      }
      beginRenderPass(renderTarget, gpuRenderTarget) {
        if (this.renderPassEncoder) {
          this.renderPassEncoder.end();
        }
        this.clearCache();
        this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);
        this.setViewport(renderTarget.viewport);
      }
      setViewport(viewport) {
        this.renderPassEncoder.setViewport(
          viewport.x,
          viewport.y,
          viewport.width,
          viewport.height,
          0,
          1
        );
      }
      setScissor(bounds) {
        bounds.fit(this.renderer.renderTarget.renderTarget.viewport);
        this.renderPassEncoder.setScissorRect(
          bounds.minX,
          bounds.minY,
          bounds.width,
          bounds.height
        );
      }
      clearScissor() {
        const viewport = this.renderer.renderTarget.renderTarget.viewport;
        this.renderPassEncoder.setScissorRect(
          viewport.x,
          viewport.y,
          viewport.width,
          viewport.height
        );
      }
      setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {
        const pipeline = this.renderer.pipeline.getPipeline(geometry, program, state, topology);
        this.setPipeline(pipeline);
      }
      setPipeline(pipeline) {
        if (this.boundPipeline === pipeline)
          return;
        this.boundPipeline = pipeline;
        this.renderPassEncoder.setPipeline(pipeline);
      }
      setVertexBuffer(index, buffer) {
        if (this.boundVertexBuffer[index] === buffer)
          return;
        this.boundVertexBuffer[index] = buffer;
        this.renderPassEncoder.setVertexBuffer(
          index,
          this.renderer.buffer.updateBuffer(buffer)
        );
      }
      setIndexBuffer(buffer) {
        if (this.boundIndexBuffer === buffer)
          return;
        this.boundIndexBuffer = buffer;
        this.renderPassEncoder.setIndexBuffer(
          this.renderer.buffer.updateBuffer(buffer),
          "uint32"
        );
      }
      setBindGroup(index, bindGroup, program) {
        if (this.boundBindGroup[index] === bindGroup)
          return;
        this.boundBindGroup[index] = bindGroup;
        const gpuBindGroup = this.renderer.bindGroup.getBindGroup(bindGroup, program, index);
        this.renderPassEncoder.setBindGroup(index, gpuBindGroup);
      }
      setGeometry(geometry) {
        for (const i in geometry.attributes) {
          const attribute = geometry.attributes[i];
          this.setVertexBuffer(attribute.shaderLocation, attribute.buffer);
        }
        if (geometry.indexBuffer) {
          this.setIndexBuffer(geometry.indexBuffer);
        }
      }
      setShaderBindGroups(shader, skipSync) {
        for (const i in shader.groups) {
          const bindGroup = shader.groups[i];
          if (!skipSync) {
            this.syncBindGroup(bindGroup);
          }
          this.setBindGroup(i, bindGroup, shader.gpuProgram);
        }
      }
      syncBindGroup(bindGroup) {
        for (const j2 in bindGroup.resources) {
          const resource = bindGroup.resources[j2];
          if (resource.isUniformGroup) {
            this.renderer.uniformBuffer.updateUniformGroup(resource);
          }
        }
      }
      draw(options) {
        const { geometry, shader, state, topology, size: size2, start, instanceCount, skipSync } = options;
        this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);
        this.setGeometry(geometry);
        this.setShaderBindGroups(shader, skipSync);
        if (geometry.indexBuffer) {
          this.renderPassEncoder.drawIndexed(size2 || geometry.indexBuffer.data.length, instanceCount || 1, start || 0);
        } else {
          this.renderPassEncoder.draw(size2 || geometry.getSize(), instanceCount || 1, start || 0);
        }
      }
      finishRenderPass() {
        if (this.renderPassEncoder) {
          this.renderPassEncoder.end();
          this.renderPassEncoder = null;
        }
      }
      postrender() {
        this.finishRenderPass();
        this.gpu.device.queue.submit([this.commandEncoder.finish()]);
        this.resolveCommandFinished();
      }
      // restores a render pass if finishRenderPass was called
      // not optimised as really used for debugging!
      // used when we want to stop drawing and log a texture..
      restoreRenderPass() {
        const descriptor = this.renderer.renderTarget.getDescriptor(
          this.renderer.renderTarget.renderTarget,
          false,
          [0, 0, 0, 1]
        );
        this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);
        const boundPipeline = this.boundPipeline;
        const boundVertexBuffer = { ...this.boundVertexBuffer };
        const boundIndexBuffer = this.boundIndexBuffer;
        const boundBindGroup = { ...this.boundBindGroup };
        this.clearCache();
        const viewport = this.renderer.renderTarget.renderTarget.viewport;
        this.renderPassEncoder.setViewport(
          viewport.x,
          viewport.y,
          viewport.width,
          viewport.height,
          0,
          1
        );
        this.setPipeline(boundPipeline);
        for (const i in boundVertexBuffer) {
          this.setVertexBuffer(i, boundVertexBuffer[i]);
        }
        for (const i in boundBindGroup) {
          this.setBindGroup(i, boundBindGroup[i], null);
        }
        this.setIndexBuffer(boundIndexBuffer);
      }
      clearCache() {
        for (let i = 0; i < 16; i++) {
          this.boundBindGroup[i] = null;
          this.boundVertexBuffer[i] = null;
        }
        this.boundIndexBuffer = null;
        this.boundPipeline = null;
      }
      destroy() {
      }
      contextChange(gpu) {
        this.gpu = gpu;
      }
    };
    GpuEncoderSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "encoder"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs
var GpuStencilSystem;
var init_GpuStencilSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs"() {
    init_Extensions();
    init_const7();
    GpuStencilSystem = class {
      constructor(renderer) {
        this.renderTargetStencilState = {};
        this.renderer = renderer;
        renderer.renderTarget.onRenderTargetChange.add(this);
      }
      onRenderTargetChange(renderTarget) {
        let stencilState = this.renderTargetStencilState[renderTarget.uid];
        if (!stencilState) {
          stencilState = this.renderTargetStencilState[renderTarget.uid] = {
            stencilMode: STENCIL_MODES.DISABLED,
            stencilReference: 0
          };
        }
        this.activeRenderTarget = renderTarget;
        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
      }
      setStencilMode(stencilMode, stencilReference) {
        const stencilState = this.renderTargetStencilState[this.activeRenderTarget.uid];
        stencilState.stencilMode = stencilMode;
        stencilState.stencilReference = stencilReference;
        const renderer = this.renderer;
        renderer.pipeline.setStencilMode(stencilMode);
        renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);
      }
      destroy() {
      }
    };
    GpuStencilSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "stencil"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs
var BufferResource;
var init_BufferResource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs"() {
    init_eventemitter3();
    init_generateUID();
    BufferResource = class extends eventemitter3_default {
      constructor({ buffer, offset, size: size2 }) {
        super();
        this.uid = generateUID();
        this.resourceType = "bufferResource";
        this.resourceId = generateUID();
        this.bufferResource = true;
        this.buffer = buffer;
        this.offset = offset;
        this.size = size2;
        this.buffer.on("change", this.onBufferChange, this);
      }
      onBufferChange() {
        this.resourceId = generateUID();
        this.emit("change", this);
      }
      destroy(destroyBuffer = false) {
        if (destroyBuffer) {
          this.buffer.destroy();
        }
        this.buffer = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UniformBufferBatch.mjs
var UniformBufferBatch;
var init_UniformBufferBatch = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UniformBufferBatch.mjs"() {
    UniformBufferBatch = class {
      constructor({ minUniformOffsetAlignment: minUniformOffsetAlignment2 }) {
        this.minUniformOffsetAlignment = 256;
        this.byteIndex = 0;
        this.minUniformOffsetAlignment = minUniformOffsetAlignment2;
        this.data = new Float32Array(65535);
      }
      clear() {
        this.byteIndex = 0;
      }
      addEmptyGroup(size2) {
        if (size2 > this.minUniformOffsetAlignment / 4) {
          throw new Error(`UniformBufferBatch: array is too large: ${size2 * 4}`);
        }
        const start = this.byteIndex;
        let newSize = start + size2 * 4;
        newSize = Math.ceil(newSize / this.minUniformOffsetAlignment) * this.minUniformOffsetAlignment;
        if (newSize > this.data.length * 4) {
          throw new Error("UniformBufferBatch: ubo batch got too big");
        }
        this.byteIndex = newSize;
        return start;
      }
      addGroup(array) {
        const offset = this.addEmptyGroup(array.length);
        for (let i = 0; i < array.length; i++) {
          this.data[offset / 4 + i] = array[i];
        }
        return offset;
      }
      upload() {
      }
      destroy() {
        this.buffer.destroy();
        this.buffer = null;
        this.data = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs
var minUniformOffsetAlignment, GpuUniformBatchPipe;
var init_GpuUniformBatchPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs"() {
    init_Extensions();
    init_Buffer();
    init_BufferResource();
    init_const5();
    init_UniformBufferBatch();
    init_BindGroup();
    minUniformOffsetAlignment = 128;
    GpuUniformBatchPipe = class {
      constructor(renderer) {
        this.bindGroupHash = {};
        this.buffers = [];
        this.bindGroups = [];
        this.bufferResources = [];
        this.renderer = renderer;
        this.batchBuffer = new UniformBufferBatch({ minUniformOffsetAlignment });
        const totalBuffers = 256 / minUniformOffsetAlignment;
        for (let i = 0; i < totalBuffers; i++) {
          let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;
          if (i === 0)
            usage |= BufferUsage.COPY_SRC;
          this.buffers.push(new Buffer2({
            data: this.batchBuffer.data,
            usage
          }));
        }
      }
      renderEnd() {
        this.uploadBindGroups();
        this.resetBindGroups();
      }
      resetBindGroups() {
        for (const i in this.bindGroupHash) {
          this.bindGroupHash[i] = null;
        }
        this.batchBuffer.clear();
      }
      // just works for single bind groups for now
      getUniformBindGroup(group, duplicate) {
        if (!duplicate && this.bindGroupHash[group.uid]) {
          return this.bindGroupHash[group.uid];
        }
        this.renderer.uniformBuffer.ensureUniformGroup(group);
        const data = group.buffer.data;
        const offset = this.batchBuffer.addEmptyGroup(data.length);
        this.renderer.uniformBuffer.syncUniformGroup(group, this.batchBuffer.data, offset / 4);
        this.bindGroupHash[group.uid] = this.getBindGroup(offset / minUniformOffsetAlignment);
        return this.bindGroupHash[group.uid];
      }
      getUniformBufferResource(group) {
        this.renderer.uniformBuffer.updateUniformGroup(group);
        const data = group.buffer.data;
        const offset = this.batchBuffer.addGroup(data);
        return this.getBufferResource(offset / minUniformOffsetAlignment);
      }
      getArrayBindGroup(data) {
        const offset = this.batchBuffer.addGroup(data);
        return this.getBindGroup(offset / minUniformOffsetAlignment);
      }
      getArrayBufferResource(data) {
        const offset = this.batchBuffer.addGroup(data);
        const index = offset / minUniformOffsetAlignment;
        return this.getBufferResource(index);
      }
      getBufferResource(index) {
        if (!this.bufferResources[index]) {
          const buffer = this.buffers[index % 2];
          this.bufferResources[index] = new BufferResource({
            buffer,
            offset: (index / 2 | 0) * 256,
            size: minUniformOffsetAlignment
          });
        }
        return this.bufferResources[index];
      }
      getBindGroup(index) {
        if (!this.bindGroups[index]) {
          const bindGroup = new BindGroup({
            0: this.getBufferResource(index)
          });
          this.bindGroups[index] = bindGroup;
        }
        return this.bindGroups[index];
      }
      uploadBindGroups() {
        const bufferSystem = this.renderer.buffer;
        const firstBuffer = this.buffers[0];
        firstBuffer.update(this.batchBuffer.byteIndex);
        bufferSystem.updateBuffer(firstBuffer);
        const commandEncoder = this.renderer.gpu.device.createCommandEncoder();
        for (let i = 1; i < this.buffers.length; i++) {
          const buffer = this.buffers[i];
          commandEncoder.copyBufferToBuffer(
            bufferSystem.getGPUBuffer(firstBuffer),
            minUniformOffsetAlignment,
            bufferSystem.getGPUBuffer(buffer),
            0,
            this.batchBuffer.byteIndex
          );
        }
        this.renderer.gpu.device.queue.submit([commandEncoder.finish()]);
      }
      destroy() {
        for (let i = 0; i < this.bindGroups.length; i++) {
          this.bindGroups[i].destroy();
        }
        this.bindGroups = null;
        this.bindGroupHash = null;
        for (let i = 0; i < this.buffers.length; i++) {
          this.buffers[i].destroy();
        }
        this.buffers = null;
        for (let i = 0; i < this.bufferResources.length; i++) {
          this.bufferResources[i].destroy();
        }
        this.bufferResources = null;
        this.batchBuffer.destroy();
        this.bindGroupHash = null;
        this.renderer = null;
      }
    };
    GpuUniformBatchPipe.extension = {
      type: [
        ExtensionType.WebGPUPipes
      ],
      name: "uniformBatch"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBufferPipe.mjs
var UniformBindGroup, GpuUniformBufferPipe;
var init_GpuUniformBufferPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBufferPipe.mjs"() {
    init_Extensions();
    init_PoolGroup();
    init_Buffer();
    init_const5();
    init_BindGroup();
    UniformBindGroup = class extends BindGroup {
      constructor() {
        super({
          0: new Buffer2({
            data: new Float32Array(128),
            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
          })
        });
      }
      get buffer() {
        return this.resources[0];
      }
      get data() {
        return this.resources[0].data;
      }
    };
    GpuUniformBufferPipe = class {
      constructor(renderer) {
        this.activeBindGroups = [];
        this.activeBindGroupIndex = 0;
        this.renderer = renderer;
      }
      getUniformBindGroup(uniformGroup) {
        const renderer = this.renderer;
        renderer.uniformBuffer.ensureUniformGroup(uniformGroup);
        const bindGroup = BigPool.get(UniformBindGroup);
        renderer.uniformBuffer.syncUniformGroup(uniformGroup, bindGroup.data, 0);
        bindGroup.buffer.update(uniformGroup.buffer.data.byteLength);
        this.activeBindGroups[this.activeBindGroupIndex++] = bindGroup;
        return bindGroup;
      }
      renderEnd() {
        for (let i = 0; i < this.activeBindGroupIndex; i++) {
          BigPool.return(this.activeBindGroups[i]);
        }
        this.activeBindGroupIndex = 0;
      }
    };
    GpuUniformBufferPipe.extension = {
      type: [
        ExtensionType.WebGPUPipes
      ],
      name: "uniformBuffer"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs
var GpuStencilModesToPixi;
var init_GpuStencilModesToPixi = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs"() {
    init_const7();
    GpuStencilModesToPixi = [];
    GpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;
    GpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {
      format: "stencil8",
      depthCompare: "always",
      depthWriteEnabled: false,
      stencilWriteMask: 0,
      stencilReadMask: 0,
      stencilBack: {
        compare: "always",
        passOp: "keep"
      }
    };
    GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {
      format: "stencil8",
      depthCompare: "always",
      depthWriteEnabled: false,
      stencilBack: {
        compare: "always",
        passOp: "increment-clamp"
      }
    };
    GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {
      format: "stencil8",
      depthCompare: "always",
      depthWriteEnabled: false,
      stencilBack: {
        compare: "always",
        passOp: "increment-clamp"
      }
    };
    GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {
      format: "stencil8",
      depthCompare: "always",
      depthWriteEnabled: false,
      stencilBack: {
        compare: "always",
        passOp: "decrement-clamp"
      }
    };
    GpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {
      format: "stencil8",
      depthCompare: "always",
      depthWriteEnabled: false,
      stencilWriteMask: 0,
      stencilBack: {
        compare: "equal",
        passOp: "keep"
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs
function getKey(geometryId, programId, stateId, blendModeId, stencilStateId, multiSampleCount, colorMask, topology) {
  return geometryId << 26 | programId << 18 | colorMask << 14 | stateId << 8 | blendModeId << 3 | topology << 1 | stencilStateId << 4 | multiSampleCount;
}
var topologyStringToId, PipelineSystem;
var init_PipelineSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs"() {
    init_Extensions();
    init_createIdFromString();
    init_const7();
    init_GpuStencilModesToPixi();
    topologyStringToId = {
      "point-list": 0,
      "line-list": 1,
      "line-strip": 2,
      "triangle-list": 3,
      "triangle-strip": 4
    };
    PipelineSystem = class {
      constructor(renderer) {
        this._moduleCache = {};
        this._bufferLayoutsCache = {};
        this._pipeCache = {};
        this.colorMask = 15;
        this.multisampleCount = 1;
        this.renderer = renderer;
      }
      contextChange(gpu) {
        this.gpu = gpu;
        this.setStencilMode(STENCIL_MODES.DISABLED);
      }
      setMultisampleCount(multisampleCount) {
        this.multisampleCount = multisampleCount;
      }
      setColorMask(colorMask) {
        this.colorMask = colorMask;
      }
      setStencilMode(stencilMode) {
        this.stencilMode = stencilMode;
        this.stencilState = GpuStencilModesToPixi[stencilMode];
      }
      setPipeline(geometry, program, state, passEncoder) {
        const pipeline = this.getPipeline(geometry, program, state);
        passEncoder.setPipeline(pipeline);
      }
      getPipeline(geometry, program, state, topology) {
        if (!geometry._layoutKey) {
          this.generateBufferKey(geometry);
        }
        if (!program._layoutKey) {
          this.generateProgramKey(program);
          this.renderer.shader.createProgramLayout(program);
        }
        topology = topology || geometry.topology;
        const key = getKey(
          geometry._layoutKey,
          program._layoutKey,
          state.data,
          state._blendModeId,
          this.stencilMode,
          this.multisampleCount,
          this.colorMask,
          topologyStringToId[topology]
        );
        if (this._pipeCache[key])
          return this._pipeCache[key];
        this._pipeCache[key] = this.createPipeline(geometry, program, state, topology);
        return this._pipeCache[key];
      }
      createPipeline(geometry, program, state, topology) {
        const device = this.gpu.device;
        const buffers = this.createVertexBufferLayouts(geometry);
        const blendModes = this.renderer.state.getColorTargets(state);
        let depthStencil = this.stencilState;
        depthStencil = GpuStencilModesToPixi[this.stencilMode];
        blendModes[0].writeMask = this.stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this.colorMask;
        const descriptor = {
          // TODO later check if its helpful to create..
          // layout,
          vertex: {
            module: this.getModule(program.vertex.source),
            entryPoint: program.vertex.entryPoint,
            // geometry..
            buffers
          },
          fragment: {
            module: this.getModule(program.fragment.source),
            entryPoint: program.fragment.entryPoint,
            targets: blendModes
          },
          primitive: {
            topology,
            cullMode: state.cullMode
          },
          layout: program._gpuLayout.pipeline,
          multisample: {
            count: this.multisampleCount
          },
          depthStencil,
          label: `PIXI Pipeline`
        };
        const pipeline = device.createRenderPipeline(descriptor);
        return pipeline;
      }
      getModule(code) {
        return this._moduleCache[code] || this.createModule(code);
      }
      createModule(code) {
        const device = this.gpu.device;
        this._moduleCache[code] = device.createShaderModule({
          code
        });
        return this._moduleCache[code];
      }
      generateProgramKey(program) {
        const { vertex: vertex2, fragment: fragment2 } = program;
        const bigKey = vertex2.source + fragment2.source + vertex2.entryPoint + fragment2.entryPoint;
        program._layoutKey = createIdFromString(bigKey, "program");
        return program._layoutKey;
      }
      generateBufferKey(geometry) {
        const keyGen = [];
        let index = 0;
        const attributeKeys = Object.keys(geometry.attributes).sort();
        for (let i = 0; i < attributeKeys.length; i++) {
          const attribute = geometry.attributes[attributeKeys[i]];
          keyGen[index++] = attribute.shaderLocation;
          keyGen[index++] = attribute.offset;
          keyGen[index++] = attribute.format;
          keyGen[index++] = attribute.stride;
        }
        const stringKey = keyGen.join("");
        geometry._layoutKey = createIdFromString(stringKey, "geometry");
        return geometry._layoutKey;
      }
      createVertexBufferLayouts(geometry) {
        if (this._bufferLayoutsCache[geometry._layoutKey]) {
          return this._bufferLayoutsCache[geometry._layoutKey];
        }
        const vertexBuffersLayout = [];
        geometry.buffers.forEach((buffer) => {
          const bufferEntry = {
            arrayStride: 0,
            stepMode: "vertex",
            attributes: []
          };
          const bufferEntryAttributes = bufferEntry.attributes;
          for (const i in geometry.attributes) {
            const attribute = geometry.attributes[i];
            if (attribute.buffer === buffer) {
              bufferEntry.arrayStride = attribute.stride;
              bufferEntryAttributes.push({
                shaderLocation: attribute.shaderLocation,
                offset: attribute.offset,
                format: attribute.format
              });
            }
          }
          if (bufferEntryAttributes.length) {
            vertexBuffersLayout.push(bufferEntry);
          }
        });
        this._bufferLayoutsCache[geometry._layoutKey] = vertexBuffersLayout;
        return vertexBuffersLayout;
      }
      destroy() {
        throw new Error("Method not implemented.");
      }
    };
    PipelineSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "pipeline"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs
function isRenderingToScreen(renderTarget) {
  const resource = renderTarget.colorTexture.source.resource;
  return resource instanceof HTMLCanvasElement && document.body.contains(resource);
}
var init_isRenderingToScreen = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs
function calculateProjection(pm, x2, y, width, height, flipY) {
  const sign = flipY ? 1 : -1;
  pm.identity();
  pm.a = 1 / width * 2;
  pm.d = sign * (1 / height * 2);
  pm.tx = -1 - x2 * pm.a;
  pm.ty = -sign - y * pm.d;
  return pm;
}
var init_calculateProjection = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs
var UID13, _RenderTarget, RenderTarget;
var init_RenderTarget = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs"() {
    init_Matrix();
    init_Rectangle();
    init_calculateProjection();
    init_TextureSource();
    init_Texture();
    UID13 = 0;
    _RenderTarget = class {
      constructor(descriptor = {}) {
        this.uid = UID13++;
        this.width = 0;
        this.height = 0;
        this.resolution = 1;
        this.colorTextures = [];
        this.clearColor = 0;
        this.dirtyId = 0;
        this.isRoot = false;
        this._projectionMatrix = new Matrix();
        descriptor = { ..._RenderTarget.defaultDescriptor, ...descriptor };
        this.width = descriptor.width;
        this.height = descriptor.height;
        this.resolution = descriptor.resolution;
        this.stencil = descriptor.stencil;
        this._viewport = new Rectangle(0, 0, this.width, this.height);
        if (typeof descriptor.colorTextures === "number") {
          for (let i = 0; i < descriptor.colorTextures; i++) {
            this.colorTextures.push(new Texture({
              source: new TextureSource({
                width: this.width,
                height: this.height,
                resolution: descriptor.resolution,
                antialias: descriptor.antialias
              })
            }));
          }
        } else {
          this.colorTextures = [...descriptor.colorTextures];
          const colorSource = this.colorTexture.source;
          this.resize(colorSource.width, colorSource.height, colorSource._resolution);
        }
        this.colorTexture.source.on("resize", this.onSourceResize, this);
        if (descriptor.depthTexture) {
          this.depthTexture = new Texture({
            source: new TextureSource({
              width: this.width,
              height: this.height,
              resolution: this.resolution,
              format: "stencil8"
              // sampleCount: handled by the render target system..
            })
          });
        }
      }
      get pixelWidth() {
        return this.width * this.resolution;
      }
      get pixelHeight() {
        return this.height * this.resolution;
      }
      get colorTexture() {
        return this.colorTextures[0];
      }
      get projectionMatrix() {
        const texture = this.colorTexture;
        calculateProjection(this._projectionMatrix, 0, 0, texture.frameWidth, texture.frameHeight, !this.isRoot);
        return this._projectionMatrix;
      }
      get viewport() {
        const texture = this.colorTexture;
        const source3 = texture.source;
        const pixelWidth = source3.pixelWidth;
        const pixelHeight = source3.pixelHeight;
        const viewport = this._viewport;
        const frame = texture.layout.frame;
        viewport.x = frame.x * pixelWidth | 0;
        viewport.y = frame.y * pixelHeight | 0;
        viewport.width = frame.width * pixelWidth | 0;
        viewport.height = frame.height * pixelHeight | 0;
        return viewport;
      }
      onSourceResize(source3) {
        this.resize(source3.width, source3.height, source3._resolution, true);
      }
      resize(width, height, resolution = this.resolution, skipColorTexture = false) {
        this.width = width;
        this.height = height;
        this.resolution = resolution;
        this.dirtyId++;
        this.colorTextures.forEach((colorTexture, i) => {
          if (skipColorTexture && i === 0)
            return;
          colorTexture.source.resize(width, height, resolution);
        });
        if (this.depthTexture) {
          this.depthTexture.source.resize(width, height, resolution);
        }
      }
      destroy() {
        throw new Error("Method not implemented.");
      }
    };
    RenderTarget = _RenderTarget;
    RenderTarget.defaultDescriptor = {
      width: 0,
      height: 0,
      resolution: 1,
      colorTextures: 1,
      stencil: true,
      antialias: false
      // save on perf by default!
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs
var GpuRenderTarget;
var init_GpuRenderTarget = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs"() {
    GpuRenderTarget = class {
      constructor() {
        this.contexts = [];
        this.msaaTextures = [];
        this.msaaSamples = 1;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs
var DEFAULT_CLEAR_COLOR, GpuRenderTargetSystem;
var init_GpuRenderTargetSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs"() {
    init_Extensions();
    init_Matrix();
    init_isRenderingToScreen();
    init_RenderTarget();
    init_SystemRunner();
    init_TextureSource();
    init_Texture();
    init_getCanvasTexture();
    init_GpuRenderTarget();
    DEFAULT_CLEAR_COLOR = [0, 0, 0, 0];
    GpuRenderTargetSystem = class {
      constructor(renderer) {
        this.rootProjectionMatrix = new Matrix();
        this.onRenderTargetChange = new SystemRunner("onRenderTargetChange");
        this.renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();
        this.gpuRenderTargetHash = {};
        this.renderTargetStack = [];
        this.renderer = renderer;
      }
      renderStart({
        target,
        clear,
        clearColor
      }) {
        this.rootRenderTarget = this.getRenderTarget(target);
        this.rootProjectionMatrix = this.rootRenderTarget.projectionMatrix;
        this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);
        this.renderTargetStack.length = 0;
        this.renderer.encoder.start();
        this.push(
          this.rootRenderTarget,
          clear,
          clearColor ?? this.renderer.background.colorRgba
        );
      }
      contextChange(gpu) {
        this.gpu = gpu;
      }
      bind(renderSurface, clear = true, clearColor) {
        const renderTarget = this.getRenderTarget(renderSurface);
        this.renderTarget = renderTarget;
        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);
        if (renderTarget.width !== gpuRenderTarget.width || renderTarget.height !== gpuRenderTarget.height) {
          this.resizeGpuRenderTarget(renderTarget);
        }
        const descriptor = this.getDescriptor(renderTarget, clear, clearColor);
        gpuRenderTarget.descriptor = descriptor;
        this.renderer.encoder.beginRenderPass(renderTarget, gpuRenderTarget);
        this.renderer.pipeline.setMultisampleCount(gpuRenderTarget.msaaSamples);
        this.onRenderTargetChange.emit(renderTarget);
        return renderTarget;
      }
      /**
       * returns the gpu texture for the first color texture in the render target
       * mainly used by the filter manager to get copy the texture for blending
       * @param renderTarget
       * @returns a gpu texture
       */
      getGpuColorTexture(renderTarget) {
        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);
        if (gpuRenderTarget.contexts[0]) {
          return gpuRenderTarget.contexts[0].getCurrentTexture();
        }
        return this.renderer.texture.getGpuSource(
          renderTarget.colorTextures[0].source
        );
      }
      getDescriptor(renderTarget, clear, clearValue) {
        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);
        const loadOp = clear ? "clear" : "load";
        const colorAttachments = renderTarget.colorTextures.map(
          (texture, i) => {
            const context = gpuRenderTarget.contexts[i];
            let view;
            let resolveTarget;
            if (context) {
              const currentTexture = context.getCurrentTexture();
              const canvasTextureView = currentTexture.createView();
              view = canvasTextureView;
            } else {
              view = this.renderer.texture.getTextureView(texture);
            }
            if (gpuRenderTarget.msaaTextures[i]) {
              resolveTarget = view;
              view = this.renderer.texture.getTextureView(
                gpuRenderTarget.msaaTextures[i]
              );
            }
            return {
              view,
              // assign each frame based on the swap chain!
              resolveTarget,
              clearValue: clearValue || DEFAULT_CLEAR_COLOR,
              storeOp: "store",
              loadOp
            };
          }
        );
        let depthStencilAttachment;
        if (renderTarget.depthTexture) {
          depthStencilAttachment = {
            view: this.renderer.texture.getGpuSource(renderTarget.depthTexture.source).createView(),
            stencilStoreOp: "store",
            stencilLoadOp: loadOp
          };
        }
        const descriptor = {
          colorAttachments,
          depthStencilAttachment
        };
        return descriptor;
      }
      push(renderSurface, clear = true, clearColor) {
        const renderTarget = this.bind(renderSurface, clear, clearColor);
        this.renderTargetStack.push(renderTarget);
        return renderTarget;
      }
      pop() {
        this.renderTargetStack.pop();
        this.bind(
          this.renderTargetStack[this.renderTargetStack.length - 1],
          false
        );
      }
      getRenderTarget(renderSurface) {
        return this.renderSurfaceToRenderTargetHash.get(renderSurface) ?? this.initRenderTarget(renderSurface);
      }
      copyToTexture(sourceRenderSurfaceTexture, destinationTexture, origin, size2) {
        const renderer = this.renderer;
        const baseGpuTexture = renderer.renderTarget.getGpuColorTexture(
          sourceRenderSurfaceTexture
        );
        const backGpuTexture = renderer.texture.getGpuSource(
          destinationTexture.source
        );
        renderer.encoder.commandEncoder.copyTextureToTexture(
          {
            texture: baseGpuTexture,
            origin
          },
          {
            texture: backGpuTexture
          },
          size2
        );
        return destinationTexture;
      }
      restart() {
        this.bind(this.rootRenderTarget, false);
      }
      destroy() {
      }
      initRenderTarget(renderSurface) {
        let renderTarget = null;
        if (renderSurface instanceof HTMLCanvasElement) {
          renderSurface = getCanvasTexture(renderSurface);
        }
        if (renderSurface instanceof RenderTarget) {
          renderTarget = renderSurface;
        } else if (renderSurface instanceof Texture) {
          renderTarget = new RenderTarget({
            colorTextures: [renderSurface],
            depthTexture: renderSurface.source.depthStencil
          });
        }
        renderTarget.isRoot = true;
        this.renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);
        return renderTarget;
      }
      getGpuRenderTarget(renderTarget) {
        return this.gpuRenderTargetHash[renderTarget.uid] || this.initGpuRenderTarget(renderTarget);
      }
      initGpuRenderTarget(renderTarget) {
        renderTarget.isRoot = true;
        const gpuRenderTarget = new GpuRenderTarget();
        renderTarget.colorTextures.forEach((colorTexture, i) => {
          if (colorTexture.source.resource instanceof HTMLCanvasElement) {
            const context = renderTarget.colorTexture.source.resource.getContext(
              "webgpu"
            );
            try {
              context.configure({
                device: this.gpu.device,
                // eslint-disable-next-line max-len
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
                format: "bgra8unorm",
                alphaMode: "opaque"
              });
            } catch (e) {
              console.error(e);
            }
            gpuRenderTarget.contexts[i] = context;
          }
          gpuRenderTarget.msaa = colorTexture.source.antialias;
          if (colorTexture.source.antialias) {
            const msaaTexture = new TextureSource({
              width: 0,
              height: 0,
              sampleCount: 4
            });
            gpuRenderTarget.msaaTextures[i] = msaaTexture;
          }
        });
        if (gpuRenderTarget.msaa) {
          gpuRenderTarget.msaaSamples = 4;
          if (renderTarget.depthTexture) {
            renderTarget.depthTexture.source.sampleCount = 4;
          }
        }
        this.gpuRenderTargetHash[renderTarget.uid] = gpuRenderTarget;
        return gpuRenderTarget;
      }
      resizeGpuRenderTarget(renderTarget) {
        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);
        gpuRenderTarget.width = renderTarget.width;
        gpuRenderTarget.height = renderTarget.height;
        if (gpuRenderTarget.msaa) {
          renderTarget.colorTextures.forEach((colorTexture, i) => {
            const msaaTexture = gpuRenderTarget.msaaTextures[i];
            msaaTexture?.resize(
              colorTexture.source.width,
              colorTexture.source.height,
              colorTexture.source._resolution
            );
          });
        }
      }
    };
    GpuRenderTargetSystem.extension = {
      type: [ExtensionType.WebGPUSystem],
      name: "renderTarget"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs
var GpuShaderSystem;
var init_GpuShaderSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs"() {
    init_Extensions();
    init_UniformGroup();
    GpuShaderSystem = class {
      constructor(renderer) {
        this.renderer = renderer;
      }
      contextChange(gpu) {
        this.gpu = gpu;
      }
      createProgramLayout(program) {
        const device = this.gpu.device;
        if (!program._gpuLayout) {
          if (program.gpuLayout) {
            const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));
            const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };
            program._gpuLayout = {
              bindGroups,
              pipeline: device.createPipelineLayout(pipelineLayoutDesc)
            };
          } else {
            program._gpuLayout = {
              bindGroups: null,
              pipeline: "auto"
            };
          }
        }
      }
      updateData(shader) {
        for (let i = 0; i < shader.gpuProgram.layout.length; i++) {
          const group = shader.groups[i];
          const groupLayout = shader.gpuProgram.layout[i];
          for (const j2 in groupLayout) {
            const resource = group.resources[j2] ?? group.resources[groupLayout[j2]];
            if (resource instanceof UniformGroup) {
              const uniformGroup = resource;
              this.renderer.uniformBuffer.updateUniformGroup(uniformGroup);
            }
          }
        }
      }
      destroy() {
        throw new Error("Method not implemented.");
      }
    };
    GpuShaderSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "shader"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs
var GpuBlendModesToPixi;
var init_GpuBlendModesToPixi = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs"() {
    GpuBlendModesToPixi = {};
    GpuBlendModesToPixi.normal = {
      alpha: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.add = {
      alpha: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.multiply = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "dst",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.screen = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.overlay = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.none = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "zero",
        dstFactor: "zero",
        operation: "add"
      }
    };
    GpuBlendModesToPixi["normal-npm"] = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      }
    };
    GpuBlendModesToPixi["add-npm"] = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "add"
      },
      color: {
        srcFactor: "src-alpha",
        dstFactor: "one",
        operation: "add"
      }
    };
    GpuBlendModesToPixi["screen-npm"] = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs
var GpuStateSystem;
var init_GpuStateSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs"() {
    init_Extensions();
    init_State();
    init_GpuBlendModesToPixi();
    GpuStateSystem = class {
      constructor() {
        this.defaultState = new State();
        this.defaultState.blend = true;
      }
      contextChange(gpu) {
        this.gpu = gpu;
      }
      getColorTargets(state) {
        const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;
        return [
          {
            format: "bgra8unorm",
            writeMask: 0,
            blend
          }
        ];
      }
      destroy() {
        this.gpu = null;
      }
    };
    GpuStateSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "state"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs
var gpuUploadBufferImageResource;
var init_gpuUploadBufferImageResource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs"() {
    gpuUploadBufferImageResource = {
      type: "image",
      upload(source3, gpuTexture, gpu) {
        const resource = source3.resource;
        const total = (source3.pixelWidth | 0) * (source3.pixelHeight | 0);
        const bytesPerPixel = resource.byteLength / total;
        gpu.device.queue.writeTexture(
          { texture: gpuTexture },
          resource,
          {
            offset: 0,
            rowsPerImage: source3.pixelWidth,
            bytesPerRow: source3.pixelWidth * bytesPerPixel
          },
          {
            width: source3.pixelWidth,
            height: source3.pixelHeight,
            depthOrArrayLayers: 1
          }
        );
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs
var gpuUploadImageResource;
var init_gpuUploadImageSource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs"() {
    gpuUploadImageResource = {
      type: "image",
      upload(source3, gpuTexture, gpu) {
        const resource = source3.resource;
        if (!resource)
          return;
        const width = source3.resource?.width || source3.pixelWidth;
        const height = source3.resource?.height || source3.pixelHeight;
        gpu.device.queue.copyExternalImageToTexture(
          { source: resource },
          { texture: gpuTexture },
          {
            width,
            height
          }
        );
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs
var GpuMipmapGenerator;
var init_GpuMipmapGenerator = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs"() {
    GpuMipmapGenerator = class {
      constructor(device) {
        this.device = device;
        this.sampler = device.createSampler({ minFilter: "linear" });
        this.pipelines = {};
      }
      getMipmapPipeline(format2) {
        let pipeline = this.pipelines[format2];
        if (!pipeline) {
          if (!this.mipmapShaderModule) {
            this.mipmapShaderModule = this.device.createShaderModule({
              code: (
                /* wgsl */
                `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
              )
            });
          }
          pipeline = this.device.createRenderPipeline({
            layout: "auto",
            vertex: {
              module: this.mipmapShaderModule,
              entryPoint: "vertexMain"
            },
            fragment: {
              module: this.mipmapShaderModule,
              entryPoint: "fragmentMain",
              targets: [{ format: format2 }]
            }
          });
          this.pipelines[format2] = pipeline;
        }
        return pipeline;
      }
      /**
       * Generates mipmaps for the given GPUTexture from the data in level 0.
       * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.
       * @returns {module:External.GPUTexture} - The originally passed texture
       */
      generateMipmap(texture) {
        const pipeline = this.getMipmapPipeline(texture.format);
        if (texture.dimension === "3d" || texture.dimension === "1d") {
          throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
        }
        let mipTexture = texture;
        const arrayLayerCount = texture.depthOrArrayLayers || 1;
        const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;
        if (!renderToSource) {
          const mipTextureDescriptor = {
            size: {
              width: Math.ceil(texture.width / 2),
              height: Math.ceil(texture.height / 2),
              depthOrArrayLayers: arrayLayerCount
            },
            format: texture.format,
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
            mipLevelCount: texture.mipLevelCount - 1
          };
          mipTexture = this.device.createTexture(mipTextureDescriptor);
        }
        const commandEncoder = this.device.createCommandEncoder({});
        const bindGroupLayout = pipeline.getBindGroupLayout(0);
        for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {
          let srcView = texture.createView({
            baseMipLevel: 0,
            mipLevelCount: 1,
            dimension: "2d",
            baseArrayLayer: arrayLayer,
            arrayLayerCount: 1
          });
          let dstMipLevel = renderToSource ? 1 : 0;
          for (let i = 1; i < texture.mipLevelCount; ++i) {
            const dstView = mipTexture.createView({
              baseMipLevel: dstMipLevel++,
              mipLevelCount: 1,
              dimension: "2d",
              baseArrayLayer: arrayLayer,
              arrayLayerCount: 1
            });
            const passEncoder = commandEncoder.beginRenderPass({
              colorAttachments: [{
                view: dstView,
                storeOp: "store",
                loadOp: "clear",
                clearValue: { r: 0, g: 0, b: 0, a: 0 }
              }]
            });
            const bindGroup = this.device.createBindGroup({
              layout: bindGroupLayout,
              entries: [{
                binding: 0,
                resource: this.sampler
              }, {
                binding: 1,
                resource: srcView
              }]
            });
            passEncoder.setPipeline(pipeline);
            passEncoder.setBindGroup(0, bindGroup);
            passEncoder.draw(3, 1, 0, 0);
            passEncoder.end();
            srcView = dstView;
          }
        }
        if (!renderToSource) {
          const mipLevelSize = {
            width: Math.ceil(texture.width / 2),
            height: Math.ceil(texture.height / 2),
            depthOrArrayLayers: arrayLayerCount
          };
          for (let i = 1; i < texture.mipLevelCount; ++i) {
            commandEncoder.copyTextureToTexture({
              texture: mipTexture,
              mipLevel: i - 1
            }, {
              texture,
              mipLevel: i
            }, mipLevelSize);
            mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);
            mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);
          }
        }
        this.device.queue.submit([commandEncoder.finish()]);
        if (!renderToSource) {
          mipTexture.destroy();
        }
        return texture;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs
var GpuTextureSystem;
var init_GpuTextureSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs"() {
    init_Extensions();
    init_BindGroup();
    init_gpuUploadBufferImageResource();
    init_gpuUploadImageSource();
    init_GpuMipmapGenerator();
    GpuTextureSystem = class {
      constructor() {
        this.gpuSources = {};
        this.gpuSamplers = {};
        this.bindGroupHash = {};
        this.textureViewHash = {};
        this.managedTextureSources = {};
        this.uploads = {
          image: gpuUploadImageResource,
          buffer: gpuUploadBufferImageResource
        };
      }
      contextChange(gpu) {
        this.gpu = gpu;
      }
      initSource(source3) {
        if (source3.autoGenerateMipmaps) {
          const biggestDimension = Math.max(source3.pixelWidth, source3.pixelHeight);
          source3.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
        }
        const textureDescriptor = {
          size: { width: source3.pixelWidth, height: source3.pixelHeight },
          format: source3.format,
          sampleCount: source3.sampleCount,
          mipLevelCount: source3.mipLevelCount,
          dimension: source3.dimension,
          usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
        };
        const gpuTexture = this.gpu.device.createTexture(textureDescriptor);
        this.gpuSources[source3.uid] = gpuTexture;
        this.managedTextureSources[source3.uid] = source3;
        source3.on("update", this.onSourceUpdate, this);
        source3.on("destroy", this.onSourceDestroy, this);
        source3.on("resize", this.onSourceResize, this);
        this.onSourceUpdate(source3);
        return gpuTexture;
      }
      onSourceUpdate(source3) {
        const gpuTexture = this.gpuSources[source3.uid];
        if (!gpuTexture)
          return;
        if (this.uploads[source3.type]) {
          this.uploads[source3.type].upload(source3, gpuTexture, this.gpu);
        }
        if (source3.autoGenerateMipmaps && source3.mipLevelCount > 1) {
          if (!this.mipmapGenerator) {
            this.mipmapGenerator = new GpuMipmapGenerator(this.gpu.device);
          }
          this.mipmapGenerator.generateMipmap(gpuTexture);
        }
      }
      onSourceDestroy(source3) {
        source3.off("update", this.onSourceUpdate, this);
        source3.off("destroy", this.onSourceDestroy, this);
        source3.off("resize", this.onSourceResize, this);
        const gpuTexture = this.gpuSources[source3.uid];
        delete this.gpuSources[source3.uid];
        gpuTexture.destroy();
      }
      onSourceResize(source3) {
        const gpuTexture = this.gpuSources[source3.uid];
        if (gpuTexture.width !== source3.pixelWidth || gpuTexture.height !== source3.pixelHeight) {
          this.gpuSources[source3.uid].destroy();
          this.gpuSources[source3.uid] = null;
          this.initSource(source3);
        }
      }
      initSampler(sampler) {
        this.gpuSamplers[sampler.resourceId] = this.gpu.device.createSampler(sampler);
        return this.gpuSamplers[sampler.resourceId];
      }
      getGpuSampler(sampler) {
        return this.gpuSamplers[sampler.resourceId] || this.initSampler(sampler);
      }
      getGpuSource(source3) {
        return this.gpuSources[source3.uid] || this.initSource(source3);
      }
      getTextureBindGroup(texture) {
        return this.bindGroupHash[texture.id] ?? this.createTextureBindGroup(texture);
      }
      createTextureBindGroup(texture) {
        const bindGroupId = texture.id;
        this.bindGroupHash[bindGroupId] = new BindGroup({
          0: texture.source,
          1: texture.style
        });
        return this.bindGroupHash[bindGroupId];
      }
      getTextureView(texture) {
        const source3 = texture.source;
        return this.textureViewHash[source3.uid] ?? this.createTextureView(source3);
      }
      createTextureView(texture) {
        this.textureViewHash[texture.uid] = this.getGpuSource(texture).createView();
        return this.textureViewHash[texture.uid];
      }
      destroy() {
        throw new Error("Method not implemented.");
      }
    };
    GpuTextureSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "texture"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs
var WebGPURenderer_exports = {};
__export(WebGPURenderer_exports, {
  WebGPURenderer: () => WebGPURenderer
});
var DefaultWebGPUSystems, DefaultWebGPUPipes, DefaultWebGPUAdapters, systems, renderPipes, renderPipeAdaptors, WebGPURenderer;
var init_WebGPURenderer = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs"() {
    init_Extensions();
    init_GpuBatchAdaptor();
    init_GpuGraphicsAdaptor();
    init_GpuMeshAdapter();
    init_AbstractRenderer();
    init_SharedSystems();
    init_BindGroupSystem();
    init_GpuBufferSystem();
    init_GpuColorMaskSystem();
    init_GpuDeviceSystem();
    init_GpuEncoderSystem();
    init_GpuStencilSystem();
    init_GpuUniformBatchPipe();
    init_GpuUniformBufferPipe();
    init_PipelineSystem();
    init_GpuRenderTargetSystem();
    init_GpuShaderSystem();
    init_GpuStateSystem();
    init_GpuTextureSystem();
    DefaultWebGPUSystems = [
      ...SharedSystems,
      GpuDeviceSystem,
      BufferSystem,
      GpuTextureSystem,
      GpuRenderTargetSystem,
      GpuEncoderSystem,
      GpuShaderSystem,
      GpuStateSystem,
      PipelineSystem,
      GpuColorMaskSystem,
      GpuStencilSystem,
      BindGroupSystem
    ];
    DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe, GpuUniformBufferPipe];
    DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];
    systems = [];
    renderPipes = [];
    renderPipeAdaptors = [];
    extensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);
    extensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);
    extensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);
    extensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);
    WebGPURenderer = class extends AbstractRenderer {
      constructor() {
        const systemConfig = {
          type: "webgpu",
          systems,
          renderPipes,
          renderPipeAdaptors
        };
        super(systemConfig);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gl/batcher-template.mjs
var fragmentSrc2;
var init_batcher_template2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gl/batcher-template.mjs"() {
    fragmentSrc2 = "in vec2 vTextureCoord;\nin vec4 vColor;\nin float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nout vec4 finalColor;\n\nvoid main(void){\n    vec4 outColor;\n    %forloop%\n    finalColor = outColor * vColor;\n}\n";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gl/batcher-template2.mjs
var vertexSrc2;
var init_batcher_template22 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gl/batcher-template2.mjs"() {
    vertexSrc2 = "precision highp float;\nin vec2 aPosition;\nin vec2 aUV;\nin vec4 aColor;\nin float aTextureId;\n\nuniform globalUniforms {\n  mat3 projectionMatrix;\n  mat3 worldTransformMatrix;\n  float worldAlpha;\n};\n\nout vec2 vTextureCoord;\nout vec4 vColor;\nout float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * worldTransformMatrix * vec3(aPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aUV;\n    vTextureId = aTextureId;\n    \n    vColor = vec4(aColor.rgb * aColor.a, aColor.a)  * worldAlpha;\n}\n";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gl/generateDefaultBatchGlProgram.mjs
function generateDefaultBatchGlProgram(maxTextures) {
  return generateBatchGlProgram({
    vertexSrc: vertexSrc2,
    fragmentSrc: fragmentSrc2,
    maxTextures,
    name: "default"
  });
}
var init_generateDefaultBatchGlProgram = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gl/generateDefaultBatchGlProgram.mjs"() {
    init_batcher_template2();
    init_batcher_template22();
    init_generateBatchGlProgram();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs
var GlBatchAdaptor;
var init_GlBatchAdaptor = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs"() {
    init_Extensions();
    init_Matrix();
    init_batchSamplersUniformGroup();
    init_Shader();
    init_UniformGroup();
    init_const3();
    init_generateDefaultBatchGlProgram();
    GlBatchAdaptor = class {
      constructor() {
        this.didUpload = false;
      }
      init() {
        const uniforms = new UniformGroup({
          tint: { value: new Float32Array([1, 1, 1, 1]), type: "f32" },
          translationMatrix: { value: new Matrix(), type: "mat3x3<f32>" }
        });
        this.shader = new Shader({
          glProgram: generateDefaultBatchGlProgram(MAX_TEXTURES),
          resources: {
            uniforms,
            batchSamplers: batchSamplersUniformGroup
          }
        });
      }
      execute(batchPipe, batch) {
        const renderer = batchPipe.renderer;
        batchPipe.state.blendMode = batch.blendMode;
        renderer.state.set(batchPipe.state);
        renderer.shader.bind(this.shader, this.didUpload);
        this.didUpload = true;
        const activeBatcher = batch.batchParent;
        renderer.geometry.bind(activeBatcher.geometry, this.shader.glProgram);
        for (let i = 0; i < batch.textures.textures.length; i++) {
          renderer.texture.bind(batch.textures.textures[i], i);
        }
        renderer.shader.bindUniformBlock(renderer.globalUniforms.uniformGroup, "globalUniforms", 0);
        renderer.geometry.draw("triangle-list", batch.size, batch.start);
      }
      destroy() {
        this.shader.destroy(true);
        this.shader = null;
      }
    };
    GlBatchAdaptor.extension = {
      type: [
        ExtensionType.WebGLPipesAdaptor
      ],
      name: "batch"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/gl/graphics-batcher-template.mjs
var fragmentSrc3;
var init_graphics_batcher_template2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/gl/graphics-batcher-template.mjs"() {
    fragmentSrc3 = "in vec2 vTextureCoord;\nin vec4 vColor;\nin float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nout vec4 finalColor;\n\nvoid main(void){\n    vec4 outColor;\n    %forloop%\n    finalColor = outColor * vColor;\n}\n";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/gl/graphics-batcher-template2.mjs
var vertexSrc3;
var init_graphics_batcher_template22 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/gl/graphics-batcher-template2.mjs"() {
    vertexSrc3 = "precision highp float;\nin vec2 aPosition;\nin vec2 aUV;\nin vec4 aColor;\nin float aTextureId;\n\nuniform globalUniforms {\n  mat3 projectionMatrix;\n  mat3 worldTransformMatrix;\n  float worldAlpha;\n};\n\nuniform mat3 transformMatrix;\nuniform vec4 color;\n\nout vec2 vTextureCoord;\nout vec4 vColor;\nout float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * worldTransformMatrix * transformMatrix * vec3(aPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aUV;\n    vTextureId = aTextureId;\n    \n    vColor = vec4(aColor.rgb * aColor.a, aColor.a)  * worldAlpha;\n}\n";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/gl/generateDefaultGraphicsBatchGlProgram.mjs
function generateDefaultGraphicsBatchGlProgram(maxTextures) {
  return generateBatchGlProgram({
    vertexSrc: vertexSrc3,
    fragmentSrc: fragmentSrc3,
    maxTextures,
    name: "graphics"
  });
}
var init_generateDefaultGraphicsBatchGlProgram = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/gl/generateDefaultGraphicsBatchGlProgram.mjs"() {
    init_generateBatchGlProgram();
    init_graphics_batcher_template2();
    init_graphics_batcher_template22();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/gl/GlGraphicsAdaptor.mjs
var GlGraphicsAdaptor;
var init_GlGraphicsAdaptor = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/gl/GlGraphicsAdaptor.mjs"() {
    init_Extensions();
    init_Matrix();
    init_const3();
    init_batchSamplersUniformGroup();
    init_Shader();
    init_UniformGroup();
    init_colorToUniform();
    init_generateDefaultGraphicsBatchGlProgram();
    GlGraphicsAdaptor = class {
      init() {
        const uniforms = new UniformGroup({
          color: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          transformMatrix: { value: new Matrix(), type: "mat3x3<f32>" }
        });
        this.shader = new Shader({
          glProgram: generateDefaultGraphicsBatchGlProgram(MAX_TEXTURES),
          resources: {
            localUniforms: uniforms,
            batchSamplers: batchSamplersUniformGroup
          }
        });
      }
      execute(graphicsPipe, renderable) {
        const context = renderable.view.context;
        const shader = context.customShader || this.shader;
        const renderer = graphicsPipe.renderer;
        const contextSystem = renderer.graphicsContext;
        if (!contextSystem.updateGpuContext(context).batches.length) {
          return;
        }
        const {
          geometry,
          batches
        } = contextSystem.getContextRenderData(context);
        const state = graphicsPipe.state;
        state.blendMode = renderable.layerBlendMode;
        renderer.state.set(graphicsPipe.state);
        const localUniforms = shader.resources.localUniforms.uniforms;
        localUniforms.transformMatrix = renderable.layerTransform;
        color32BitToUniform(
          renderable.layerColor,
          localUniforms.color,
          0
        );
        renderer.shader.bind(shader);
        renderer.shader.bindUniformBlock(renderer.globalUniforms.uniformGroup, "globalUniforms");
        renderer.geometry.bind(geometry, shader.glProgram);
        for (let i = 0; i < batches.length; i++) {
          const batch = batches[i];
          if (batch.size) {
            for (let j2 = 0; j2 < batch.textures.textures.length; j2++) {
              renderer.texture.bind(batch.textures.textures[j2], j2);
            }
            renderer.geometry.draw("triangle-list", batch.size, batch.start);
          }
        }
      }
      destroy() {
        this.shader.destroy(true);
        this.shader = null;
      }
    };
    GlGraphicsAdaptor.extension = {
      type: [
        ExtensionType.WebGLPipesAdaptor
      ],
      name: "graphics"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mesh/gl/GlMeshAdaptor.mjs
var GlMeshAdaptor;
var init_GlMeshAdaptor = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/mesh/gl/GlMeshAdaptor.mjs"() {
    init_Extensions();
    init_colorToUniform();
    GlMeshAdaptor = class {
      execute(meshPipe, renderable) {
        const renderer = meshPipe.renderer;
        const view = renderable.view;
        const state = meshPipe.state;
        state.blendMode = renderable.layerBlendMode;
        const localUniforms = meshPipe.localUniforms;
        localUniforms.uniforms.transformMatrix = renderable.layerTransform;
        localUniforms.update();
        color32BitToUniform(
          renderable.layerColor,
          localUniforms.uniforms.color,
          0
        );
        let shader = view._shader;
        if (!shader) {
          shader = meshPipe.meshShader;
          shader.texture = view.texture;
        }
        shader.groups[0] = renderer.globalUniforms.bindGroup;
        shader.groups[1] = meshPipe.localUniformsBindGroup;
        renderer.encoder.draw({
          geometry: view._geometry,
          shader,
          state
        });
      }
    };
    GlMeshAdaptor.extension = {
      type: [
        ExtensionType.WebGLPipesAdaptor
      ],
      name: "mesh"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs
var BUFFER_TYPE;
var init_const9 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs"() {
    BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
      BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
      BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
      BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
      return BUFFER_TYPE2;
    })(BUFFER_TYPE || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs
var GlBuffer;
var init_GlBuffer = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs"() {
    GlBuffer = class {
      constructor(buffer, type) {
        this.buffer = buffer || null;
        this.updateID = -1;
        this.byteLength = -1;
        this.refCount = 0;
        this.type = type;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs
var GlBufferSystem;
var init_GlBufferSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs"() {
    init_Extensions();
    init_const5();
    init_const9();
    init_GlBuffer();
    GlBufferSystem = class {
      /**
       * @param {PIXI.Renderer} renderer - The renderer this System works for.
       */
      constructor(renderer) {
        this._gpuBuffers = {};
        this.renderer = renderer;
        this.boundBufferBases = {};
      }
      /**
       * @ignore
       */
      destroy() {
        this.renderer = null;
      }
      /** Sets up the renderer context and necessary buffers. */
      contextChange() {
        this.destroyAll(true);
        this.gl = this.renderer.gl;
      }
      getGlBuffer(buffer) {
        return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);
      }
      /**
       * This binds specified buffer. On first run, it will create the webGL buffers for the context too
       * @param buffer - the buffer to bind to the renderer
       */
      bind(buffer) {
        const { gl } = this;
        const glBuffer = this.getGlBuffer(buffer);
        gl.bindBuffer(glBuffer.type, glBuffer.buffer);
      }
      /**
       * Binds an uniform buffer to at the given index.
       *
       * A cache is used so a buffer will not be bound again if already bound.
       * @param buffer - the buffer to bind
       * @param index - the base index to bind it to.
       */
      bindBufferBase(buffer, index) {
        const { gl } = this;
        if (this.boundBufferBases[index] !== buffer) {
          const glBuffer = this.getGlBuffer(buffer);
          this.boundBufferBases[index] = buffer;
          gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
        }
      }
      /**
       * Binds a buffer whilst also binding its range.
       * This will make the buffer start from the offset supplied rather than 0 when it is read.
       * @param buffer - the buffer to bind
       * @param index - the base index to bind at, defaults to 0
       * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc
       */
      bindBufferRange(buffer, index, offset) {
        const { gl } = this;
        offset = offset || 0;
        const glBuffer = this.getGlBuffer(buffer);
        gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);
      }
      /**
       * Will ensure the data in the buffer is uploaded to the GPU.
       * @param {PIXI.Buffer} buffer - the buffer to update
       */
      updateBuffer(buffer) {
        const { gl } = this;
        const glBuffer = this.getGlBuffer(buffer);
        if (buffer._updateID === glBuffer.updateID) {
          return glBuffer;
        }
        glBuffer.updateID = buffer._updateID;
        gl.bindBuffer(glBuffer.type, glBuffer.buffer);
        if (glBuffer.byteLength >= buffer.data.byteLength) {
          gl.bufferSubData(glBuffer.type, 0, buffer.data, 0, buffer._updateSize / 4);
        } else {
          const drawType = buffer.descriptor.usage & BufferUsage.STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
          glBuffer.byteLength = buffer.data.byteLength;
          gl.bufferData(glBuffer.type, buffer.data, drawType);
        }
        return glBuffer;
      }
      /**
       * dispose all WebGL resources of all managed buffers
       * @param {boolean} [contextLost=false] - If context was lost, we suppress `gl.delete` calls
       */
      destroyAll(contextLost) {
        const gl = this.gl;
        if (!contextLost) {
          for (const id in this._gpuBuffers) {
            gl.deleteBuffer(this._gpuBuffers[id].buffer);
          }
        }
        this._gpuBuffers = {};
      }
      /**
       * Disposes buffer
       * @param {Buffer} buffer - buffer with data
       * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray
       */
      onBufferDestroy(buffer, contextLost) {
        const glBuffer = this._gpuBuffers[buffer.uid];
        const gl = this.gl;
        if (!contextLost) {
          gl.deleteBuffer(glBuffer.buffer);
        }
        this._gpuBuffers[buffer.uid] = null;
      }
      /**
       * creates and attaches a GLBuffer object tied to the current context.
       * @param buffer
       * @protected
       */
      createGLBuffer(buffer) {
        const { gl } = this;
        let type = BUFFER_TYPE.ARRAY_BUFFER;
        if (buffer.descriptor.usage & BufferUsage.INDEX) {
          type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
        } else if (buffer.descriptor.usage & BufferUsage.UNIFORM) {
          type = BUFFER_TYPE.UNIFORM_BUFFER;
        }
        const glBuffer = new GlBuffer(gl.createBuffer(), type);
        this._gpuBuffers[buffer.uid] = glBuffer;
        buffer.on("destroy", this.onBufferDestroy, this);
        return glBuffer;
      }
    };
    GlBufferSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "buffer"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs
var GlContextSystem;
var init_GlContextSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs"() {
    init_Extensions();
    GlContextSystem = class {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this.renderer = renderer;
        this.webGLVersion = 1;
        this.extensions = {};
        this.supports = {
          uint32Indices: false
        };
        this.handleContextLost = this.handleContextLost.bind(this);
        this.handleContextRestored = this.handleContextRestored.bind(this);
      }
      /**
       * `true` if the context is lost
       * @readonly
       */
      get isLost() {
        return !this.gl || this.gl.isContextLost();
      }
      /**
       * Handles the context change event.
       * @param {WebGLRenderingContext} gl - New WebGL context.
       */
      contextChange(gl) {
        this.gl = gl;
        this.renderer.gl = gl;
        if (gl.isContextLost() && gl.getExtension("WEBGL_lose_context")) {
          gl.getExtension("WEBGL_lose_context").restoreContext();
        }
      }
      init(options) {
        if (options?.context) {
          this.initFromContext(options.context);
        } else {
          const alpha = this.renderer.background.alpha < 1;
          const premultipliedAlpha = options.premultipliedAlpha ?? true;
          this.preserveDrawingBuffer = options.preserveDrawingBuffer;
          this.powerPreference = options.powerPreference;
          this.initFromOptions({
            alpha,
            premultipliedAlpha,
            antialias: options.antialias,
            stencil: true,
            preserveDrawingBuffer: options.preserveDrawingBuffer,
            powerPreference: options.powerPreference
          });
        }
      }
      /**
       * Initializes the context.
       * @protected
       * @param {WebGLRenderingContext} gl - WebGL context
       */
      initFromContext(gl) {
        this.gl = gl;
        this.validateContext(gl);
        this.renderer.runners.contextChange.emit(gl);
        const element = this.renderer.view.element;
        element.addEventListener("webglcontextlost", this.handleContextLost, false);
        element.addEventListener("webglcontextrestored", this.handleContextRestored, false);
      }
      /**
       * Initialize from context options
       * @protected
       * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
       * @param {object} options - context attributes
       */
      initFromOptions(options) {
        const gl = this.createContext(this.renderer.view.element, options);
        this.initFromContext(gl);
      }
      /**
       * Helper class to create a WebGL Context
       * @param canvas - the canvas element that we will get the context from
       * @param options - An options object that gets passed in to the canvas element containing the
       *    context attributes
       * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
       * @returns {WebGLRenderingContext} the WebGL context
       */
      createContext(canvas2, options) {
        const gl = canvas2.getContext("webgl2", options);
        this.webGLVersion = 2;
        this.gl = gl;
        this.getExtensions();
        return this.gl;
      }
      /** Auto-populate the {@link PIXI.ContextSystem.extensions extensions}. */
      getExtensions() {
        const { gl } = this;
        const common = {
          anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
          floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
          s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
          s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
          // eslint-disable-line camelcase
          etc: gl.getExtension("WEBGL_compressed_texture_etc"),
          etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
          pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
          atc: gl.getExtension("WEBGL_compressed_texture_atc"),
          astc: gl.getExtension("WEBGL_compressed_texture_astc")
        };
        Object.assign(this.extensions, common, {
          // Floats and half-floats
          colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
        });
      }
      /**
       * Handles a lost webgl context
       * @param {WebGLContextEvent} event - The context lost event.
       */
      handleContextLost(event) {
        event.preventDefault();
      }
      /** Handles a restored webgl context. */
      handleContextRestored() {
        this.renderer.runners.contextChange.emit(this.gl);
      }
      destroy() {
        const element = this.renderer.view.element;
        this.renderer = null;
        element.removeEventListener("webglcontextlost", this.handleContextLost);
        element.removeEventListener("webglcontextrestored", this.handleContextRestored);
        this.gl.useProgram(null);
        if (this.extensions.loseContext) {
          this.extensions.loseContext.loseContext();
        }
      }
      /** Handle the post-render runner event. */
      postrender() {
      }
      /**
       * Validate context.
       * @param {WebGLRenderingContext} gl - Render context.
       */
      validateContext(gl) {
        const attributes = gl.getContextAttributes();
        const isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
        if (isWebGl2) {
          this.webGLVersion = 2;
        }
        if (attributes && !attributes.stencil) {
          console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        }
        const hasUint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
        this.supports.uint32Indices = hasUint32;
        if (!hasUint32) {
          console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
        }
      }
    };
    GlContextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "context"
    };
    GlContextSystem.defaultOptions = {
      /**
       * {@link PIXI.WebGLOptions.context}
       * @default null
       */
      context: null,
      /**
       * {@link PIXI.WebGLOptions.premultipliedAlpha}
       * @default true
       */
      premultipliedAlpha: true,
      /**
       * {@link PIXI.WebGLOptions.preserveDrawingBuffer}
       * @default false
       */
      preserveDrawingBuffer: false,
      /**
       * {@link PIXI.WebGLOptions.powerPreference}
       * @default default
       */
      powerPreference: "default"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs
var GL_FORMATS, GL_TARGETS, GL_TYPES;
var init_const10 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs"() {
    GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2) => {
      GL_FORMATS2[GL_FORMATS2["RGBA"] = 6408] = "RGBA";
      GL_FORMATS2[GL_FORMATS2["RGB"] = 6407] = "RGB";
      GL_FORMATS2[GL_FORMATS2["RG"] = 33319] = "RG";
      GL_FORMATS2[GL_FORMATS2["RED"] = 6403] = "RED";
      GL_FORMATS2[GL_FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
      GL_FORMATS2[GL_FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
      GL_FORMATS2[GL_FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
      GL_FORMATS2[GL_FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
      GL_FORMATS2[GL_FORMATS2["ALPHA"] = 6406] = "ALPHA";
      GL_FORMATS2[GL_FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
      GL_FORMATS2[GL_FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
      GL_FORMATS2[GL_FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
      GL_FORMATS2[GL_FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
      return GL_FORMATS2;
    })(GL_FORMATS || {});
    GL_TARGETS = /* @__PURE__ */ ((GL_TARGETS2) => {
      GL_TARGETS2[GL_TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
      return GL_TARGETS2;
    })(GL_TARGETS || {});
    GL_TYPES = /* @__PURE__ */ ((GL_TYPES2) => {
      GL_TYPES2[GL_TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
      GL_TYPES2[GL_TYPES2["BYTE"] = 5120] = "BYTE";
      GL_TYPES2[GL_TYPES2["SHORT"] = 5122] = "SHORT";
      GL_TYPES2[GL_TYPES2["INT"] = 5124] = "INT";
      GL_TYPES2[GL_TYPES2["FLOAT"] = 5126] = "FLOAT";
      GL_TYPES2[GL_TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
      GL_TYPES2[GL_TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
      return GL_TYPES2;
    })(GL_TYPES || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlInfoFromFormat.mjs
function getGlInfoFromFormat(format2) {
  return infoMap[format2] ?? infoMap.float32;
}
var infoMap;
var init_getGlInfoFromFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlInfoFromFormat.mjs"() {
    init_const10();
    infoMap = {
      uint8x2: { type: GL_TYPES.UNSIGNED_BYTE, size: 2, normalised: false },
      uint8x4: { type: GL_TYPES.UNSIGNED_BYTE, size: 4, normalised: false },
      sint8x2: { type: GL_TYPES.BYTE, size: 2, normalised: false },
      sint8x4: { type: GL_TYPES.BYTE, size: 4, normalised: false },
      unorm8x2: { type: GL_TYPES.UNSIGNED_BYTE, size: 2, normalised: true },
      unorm8x4: { type: GL_TYPES.UNSIGNED_BYTE, size: 4, normalised: true },
      snorm8x2: { type: GL_TYPES.BYTE, size: 2, normalised: true },
      snorm8x4: { type: GL_TYPES.BYTE, size: 4, normalised: true },
      uint16x2: { type: GL_TYPES.UNSIGNED_SHORT, size: 2, normalised: false },
      uint16x4: { type: GL_TYPES.UNSIGNED_SHORT, size: 4, normalised: false },
      sint16x2: { type: GL_TYPES.SHORT, size: 2, normalised: false },
      sint16x4: { type: GL_TYPES.SHORT, size: 4, normalised: false },
      unorm16x2: { type: GL_TYPES.UNSIGNED_SHORT, size: 2, normalised: true },
      unorm16x4: { type: GL_TYPES.UNSIGNED_SHORT, size: 4, normalised: true },
      snorm16x2: { type: GL_TYPES.SHORT, size: 2, normalised: true },
      snorm16x4: { type: GL_TYPES.SHORT, size: 4, normalised: true },
      float16x2: { type: GL_TYPES.HALF_FLOAT, size: 2, normalised: false },
      float16x4: { type: GL_TYPES.HALF_FLOAT, size: 4, normalised: false },
      float32: { type: GL_TYPES.FLOAT, size: 1, normalised: false },
      float32x2: { type: GL_TYPES.FLOAT, size: 2, normalised: false },
      float32x3: { type: GL_TYPES.FLOAT, size: 3, normalised: false },
      float32x4: { type: GL_TYPES.FLOAT, size: 4, normalised: false },
      uint32: { type: GL_TYPES.UNSIGNED_INT, size: 1, normalised: false },
      uint32x2: { type: GL_TYPES.UNSIGNED_INT, size: 2, normalised: false },
      uint32x3: { type: GL_TYPES.UNSIGNED_INT, size: 3, normalised: false },
      uint32x4: { type: GL_TYPES.UNSIGNED_INT, size: 4, normalised: false },
      sint32: { type: GL_TYPES.INT, size: 1, normalised: false },
      sint32x2: { type: GL_TYPES.INT, size: 2, normalised: false },
      sint32x3: { type: GL_TYPES.INT, size: 3, normalised: false },
      sint32x4: { type: GL_TYPES.INT, size: 4, normalised: false }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs
var byteSizeMap, topologyToGlMap, GlGeometrySystem;
var init_GlGeometrySystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs"() {
    init_Extensions();
    init_getGlInfoFromFormat();
    byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
    topologyToGlMap = {
      "point-list": 0,
      "line-list": 1,
      "line-strip": 3,
      "triangle-list": 4,
      "triangle-strip": 5
    };
    GlGeometrySystem = class {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this._geometryVaoHash = {};
        this.renderer = renderer;
        this._activeGeometry = null;
        this._activeVao = null;
        this.hasVao = true;
        this.hasInstance = true;
        this.canUseUInt32ElementIndex = true;
        this.managedGeometries = {};
      }
      /** Sets up the renderer context and necessary buffers. */
      contextChange() {
        this.gl = this.renderer.gl;
      }
      /**
       * Binds geometry so that is can be drawn. Creating a Vao if required
       * @param geometry - Instance of geometry to bind.
       * @param program - Instance of program to use vao for.
       */
      bind(geometry, program) {
        const gl = this.gl;
        this._activeGeometry = geometry;
        const vao = this.getVao(geometry, program);
        if (this._activeVao !== vao) {
          this._activeVao = vao;
          gl.bindVertexArray(vao);
        }
        this.updateBuffers();
      }
      /** Reset and unbind any active VAO and geometry. */
      reset() {
        this.unbind();
      }
      /** Update buffers of the currently bound geometry. */
      updateBuffers() {
        const geometry = this._activeGeometry;
        const bufferSystem = this.renderer.buffer;
        for (let i = 0; i < geometry.buffers.length; i++) {
          const buffer = geometry.buffers[i];
          bufferSystem.updateBuffer(buffer);
        }
      }
      /**
       * Check compatibility between a geometry and a program
       * @param geometry - Geometry instance.
       * @param program - Program instance.
       */
      checkCompatibility(geometry, program) {
        const geometryAttributes = geometry.attributes;
        const shaderAttributes = program.attributeData;
        for (const j2 in shaderAttributes) {
          if (!geometryAttributes[j2]) {
            throw new Error(`shader and geometry incompatible, geometry missing the "${j2}" attribute`);
          }
        }
      }
      /**
       * Takes a geometry and program and generates a unique signature for them.
       * @param geometry - To get signature from.
       * @param program - To test geometry against.
       * @returns - Unique signature of the geometry and program
       */
      getSignature(geometry, program) {
        const attribs = geometry.attributes;
        const shaderAttributes = program.attributeData;
        const strings = ["g", geometry.uid];
        for (const i in attribs) {
          if (shaderAttributes[i]) {
            strings.push(i, shaderAttributes[i].location);
          }
        }
        return strings.join("-");
      }
      getVao(geometry, program) {
        return this._geometryVaoHash[geometry.uid]?.[program.key] || this.initGeometryVao(geometry, program);
      }
      /**
       * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
       * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the
       * attribute locations.
       * @param geometry - Instance of geometry to to generate Vao for.
       * @param program
       * @param _incRefCount - Increment refCount of all geometry buffers.
       */
      initGeometryVao(geometry, program, _incRefCount = true) {
        const gl = this.renderer.gl;
        const bufferSystem = this.renderer.buffer;
        this.renderer.shader.getProgramData(program);
        this.checkCompatibility(geometry, program);
        const signature = this.getSignature(geometry, program);
        if (!this._geometryVaoHash[geometry.uid]) {
          this._geometryVaoHash[geometry.uid] = {};
          geometry.on("destroy", this.onGeometryDestroy, this);
        }
        const vaoObjectHash = this._geometryVaoHash[geometry.uid];
        let vao = vaoObjectHash[signature];
        if (vao) {
          vaoObjectHash[program.key] = vao;
          return vao;
        }
        const buffers = geometry.buffers;
        const attributes = geometry.attributes;
        const tempStride = {};
        const tempStart = {};
        for (const j2 in buffers) {
          tempStride[j2] = 0;
          tempStart[j2] = 0;
        }
        for (const j2 in attributes) {
          if (!attributes[j2].size && program.attributeData[j2]) {
            attributes[j2].size = program.attributeData[j2].size;
          } else if (!attributes[j2].size) {
            console.warn(`PIXI Geometry attribute '${j2}' size cannot be determined (likely the bound shader does not have the attribute)`);
          }
          tempStride[attributes[j2].buffer.uid] += attributes[j2].size * byteSizeMap[attributes[j2].type];
        }
        for (const j2 in attributes) {
          const attribute = attributes[j2];
          const attribSize = attribute.size;
          if (attribute.stride === void 0) {
            if (tempStride[attribute.buffer.uid] === attribSize * byteSizeMap[attribute.type]) {
              attribute.stride = 0;
            } else {
              attribute.stride = tempStride[attribute.buffer.uid];
            }
          }
          if (attribute.start === void 0) {
            attribute.start = tempStart[attribute.buffer.uid];
            tempStart[attribute.buffer.uid] += attribSize * byteSizeMap[attribute.type];
          }
        }
        vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        for (let i = 0; i < buffers.length; i++) {
          const buffer = buffers[i];
          bufferSystem.bind(buffer);
        }
        this.activateVao(geometry, program);
        vaoObjectHash[program.key] = vao;
        vaoObjectHash[signature] = vao;
        gl.bindVertexArray(null);
        return vao;
      }
      /**
       * Disposes geometry.
       * @param geometry - Geometry with buffers. Only VAO will be disposed
       * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray
       */
      onGeometryDestroy(geometry, contextLost) {
        const vaoObjectHash = this._geometryVaoHash[geometry.uid];
        const gl = this.gl;
        if (vaoObjectHash) {
          if (contextLost) {
            for (const i in vaoObjectHash) {
              if (this._activeVao !== vaoObjectHash[i]) {
                this.unbind();
              }
              gl.deleteVertexArray(vaoObjectHash[i]);
            }
          }
          this._geometryVaoHash[geometry.uid] = null;
        }
      }
      /**
       * Dispose all WebGL resources of all managed geometries.
       * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls
       */
      destroyAll(contextLost = false) {
        const gl = this.gl;
        for (const i in this._geometryVaoHash) {
          if (contextLost) {
            for (const j2 in this._geometryVaoHash[i]) {
              const vaoObjectHash = this._geometryVaoHash[i];
              if (this._activeVao !== vaoObjectHash) {
                this.unbind();
              }
              gl.deleteVertexArray(vaoObjectHash[j2]);
            }
          }
          this._geometryVaoHash[i] = null;
        }
      }
      /**
       * Activate vertex array object.
       * @param geometry - Geometry instance.
       * @param program - Shader program instance.
       */
      activateVao(geometry, program) {
        const gl = this.renderer.gl;
        const bufferSystem = this.renderer.buffer;
        const attributes = geometry.attributes;
        if (geometry.indexBuffer) {
          bufferSystem.bind(geometry.indexBuffer);
        }
        let lastBuffer = null;
        for (const j2 in attributes) {
          const attribute = attributes[j2];
          const buffer = attribute.buffer;
          const glBuffer = bufferSystem.getGlBuffer(buffer);
          if (program.attributeData[j2]) {
            if (lastBuffer !== glBuffer) {
              bufferSystem.bind(buffer);
              lastBuffer = glBuffer;
            }
            const location = program.attributeData[j2].location;
            gl.enableVertexAttribArray(location);
            const glInfo = getGlInfoFromFormat(attribute.format);
            gl.vertexAttribPointer(
              location,
              glInfo.size,
              glInfo.type,
              // attribute.type || gl.FLOAT,
              glInfo.normalised,
              attribute.stride,
              attribute.offset
            );
            if (attribute.instance) {
              if (this.hasInstance) {
                gl.vertexAttribDivisor(location, 1);
              } else {
                throw new Error("geometry error, GPU Instancing is not supported on this device");
              }
            }
          }
        }
      }
      /**
       * Draws the currently bound geometry.
       * @param topology - The type primitive to render.
       * @param size - The number of elements to be rendered. If not specified, all vertices after the
       *  starting vertex will be drawn.
       * @param start - The starting vertex in the geometry to start drawing from. If not specified,
       *  drawing will start from the first vertex.
       * @param instanceCount - The number of instances of the set of elements to execute. If not specified,
       *  all instances will be drawn.
       */
      draw(topology, size2, start, instanceCount) {
        const { gl } = this.renderer;
        const geometry = this._activeGeometry;
        const glTopology = topologyToGlMap[geometry.topology || topology];
        if (geometry.indexBuffer) {
          const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
          const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
          if (geometry.instanced) {
            gl.drawElementsInstanced(glTopology, size2 || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, geometry.instanceCount || 1);
          } else {
            gl.drawElements(glTopology, size2 || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
          }
        } else if (geometry.instanced) {
          gl.drawArraysInstanced(glTopology, start, size2 || geometry.getSize(), instanceCount || 1);
        } else {
          gl.drawArrays(glTopology, start, size2 || geometry.getSize());
        }
        return this;
      }
      /** Unbind/reset everything. */
      unbind() {
        this.gl.bindVertexArray(null);
        this._activeVao = null;
        this._activeGeometry = null;
      }
      destroy() {
        this.renderer = null;
      }
    };
    GlGeometrySystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "geometry"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs
var bigTriangleProgram, bigTriangleShader, GlBackBufferSystem;
var init_GlBackBufferSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs"() {
    init_Extensions();
    init_Shader();
    init_State();
    init_TextureSource();
    init_Texture();
    init_GlProgram();
    bigTriangleProgram = new GlProgram({
      vertex: `
        out vec2 vUv;

        void main() {
            vUv = vec2((gl_VertexID << 1) & 2, (gl_VertexID & 2));

            gl_Position = vec4(vUv * 2.0f + -1.0f, 0.0f, 1.0f);

            // flip dem UVs
            vUv.y = 1.0f - vUv.y;
        }`,
      fragment: `
        in vec2 vUv;
        out vec4 fragColor;

        uniform sampler2D uTexture;

        void main() {
            fragColor = texture(uTexture, vUv);
        }`,
      name: "big-triangle"
    });
    bigTriangleShader = new Shader({
      glProgram: bigTriangleProgram,
      resources: {
        uTexture: Texture.WHITE.source
      }
    });
    GlBackBufferSystem = class {
      constructor(renderer) {
        this.useBackBuffer = false;
        this.renderer = renderer;
      }
      init({ useBackBuffer } = {}) {
        this.useBackBuffer = useBackBuffer;
      }
      renderStart({ target, clear }) {
        if (this.useBackBuffer) {
          const renderTarget = this.renderer.renderTarget.getRenderTarget(target);
          this.targetTexture = renderTarget.colorTexture;
          target = this._getBackBufferTexture(renderTarget.colorTexture);
        }
        this.renderer.renderTarget.start(target, clear, this.renderer.background.colorRgba);
      }
      renderEnd() {
        this._presentBackBuffer();
      }
      _presentBackBuffer() {
        if (!this.useBackBuffer)
          return;
        const renderer = this.renderer;
        const gl = renderer.gl;
        renderer.renderTarget.finishRenderPass();
        renderer.renderTarget.bind(this.targetTexture, false);
        bigTriangleShader.resources.uTexture = this.backBufferTexture.source;
        renderer.shader.bind(bigTriangleShader, false);
        renderer.state.set(State.for2d());
        gl.drawArrays(gl.TRIANGLES, 0, 3);
      }
      _getBackBufferTexture(targetTexture) {
        const source3 = targetTexture.source;
        this.backBufferTexture = this.backBufferTexture || new Texture({
          source: new TextureSource({
            width: 1,
            height: 1,
            resolution: 1,
            antialias: false
          })
        });
        this.backBufferTexture.source.resize(
          source3.width,
          source3.height,
          source3._resolution
        );
        return this.backBufferTexture;
      }
      destroy() {
      }
    };
    GlBackBufferSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "backBuffer"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs
var GlColorMaskSystem;
var init_GlColorMaskSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs"() {
    init_Extensions();
    GlColorMaskSystem = class {
      constructor(renderer) {
        this.colorMaskCache = 15;
        this.renderer = renderer;
      }
      setMask(colorMask) {
        if (this.colorMaskCache === colorMask)
          return;
        this.colorMaskCache = colorMask;
        this.renderer.gl.colorMask(
          !!(colorMask & 8),
          !!(colorMask & 4),
          !!(colorMask & 2),
          !!(colorMask & 1)
        );
      }
      destroy() {
      }
    };
    GlColorMaskSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "colorMask"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs
var GlEncoderSystem;
var init_GlEncoderSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs"() {
    init_Extensions();
    GlEncoderSystem = class {
      // private gl: WebGL2RenderingContext;
      constructor(renderer) {
        this.commandFinished = Promise.resolve();
        this.renderer = renderer;
      }
      start() {
      }
      // protected contextChange(gl: GlRenderingContext): void
      // {
      //     this.gl = gl;
      // }
      beginRenderPass(renderTarget, _gpuRenderTarget) {
        this.setViewport(renderTarget.viewport);
      }
      setViewport(_viewport) {
      }
      setScissor(bounds) {
        bounds.fit(this.renderer.renderTarget.renderTarget.viewport);
      }
      clearScissor() {
      }
      setGeometry(geometry, shader) {
        this.renderer.geometry.bind(geometry, shader.glProgram);
      }
      setShaderBindGroups(_shader, _sync) {
      }
      syncBindGroup(_bindGroup) {
      }
      draw(options) {
        const renderer = this.renderer;
        const { geometry, shader, state, skipSync, topology: type, size: size2, start, instanceCount } = options;
        renderer.shader.bind(shader, skipSync);
        renderer.geometry.bind(geometry, renderer.shader.activeProgram);
        if (state) {
          renderer.state.set(state);
        }
        renderer.geometry.draw(type, size2, start, instanceCount);
      }
      finishRenderPass() {
      }
      finish() {
      }
      // restores a render pass if finishRenderPass was called
      // not optimised as really used for debugging!
      // used when we want to stop drawing and log a texture..
      restoreRenderPass() {
      }
      destroy() {
      }
    };
    GlEncoderSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "encoder"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs
var GlRenderTarget;
var init_GlRenderTarget = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs"() {
    GlRenderTarget = class {
      constructor() {
        this.width = -1;
        this.height = -1;
        this.msaaRenderBuffer = [];
        this.msaa = false;
        this.dirtyId = -1;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTargetSystem.mjs
var GlRenderTargetSystem;
var init_GlRenderTargetSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTargetSystem.mjs"() {
    init_Extensions();
    init_Matrix();
    init_isRenderingToScreen();
    init_RenderTarget();
    init_SystemRunner();
    init_Texture();
    init_getCanvasTexture();
    init_GlRenderTarget();
    GlRenderTargetSystem = class {
      constructor(renderer) {
        this.onRenderTargetChange = new SystemRunner("onRenderTargetChange");
        this.renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();
        this.gpuRenderTargetHash = {};
        this.renderTargetStack = [];
        this.defaultClearColor = [0, 0, 0, 0];
        this.clearColorCache = [0, 0, 0, 0];
        this.viewPortCache = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
        this.rootProjectionMatrix = new Matrix();
        this.renderer = renderer;
      }
      contextChange(gl) {
        this.gl = gl;
      }
      start(rootRenderSurface, clear = true, clearColor) {
        this.renderTargetStack.length = 0;
        const renderTarget = this.getRenderTarget(rootRenderSurface);
        this.rootRenderTarget = renderTarget;
        this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);
        this.rootProjectionMatrix = renderTarget.projectionMatrix;
        this.push(renderTarget, clear, clearColor);
      }
      renderEnd() {
        this.finish();
      }
      bind(renderSurface, clear = true, clearColor) {
        const renderTarget = this.getRenderTarget(renderSurface);
        this.renderTarget = renderTarget;
        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);
        if (renderTarget.dirtyId !== gpuRenderTarget.dirtyId) {
          gpuRenderTarget.dirtyId = renderTarget.dirtyId;
          this.resizeGpuRenderTarget(renderTarget);
        }
        const gl = this.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);
        renderTarget.colorTextures.forEach((texture) => {
          this.renderer.texture.unbind(texture);
        });
        const viewport = renderTarget.viewport;
        let viewPortY = viewport.y;
        if (renderTarget.isRoot) {
          viewPortY = this.renderer.view.element.height - viewport.height;
        }
        const viewPortCache = this.viewPortCache;
        if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {
          viewPortCache.x = viewport.x;
          viewPortCache.y = viewPortY;
          viewPortCache.width = viewport.width;
          viewPortCache.height = viewport.height;
          gl.viewport(
            viewport.x,
            viewPortY,
            viewport.width,
            viewport.height
          );
        }
        if (clear) {
          const gl2 = this.gl;
          if (clear) {
            clearColor = clearColor ?? this.defaultClearColor;
            const clearColorCache = this.clearColorCache;
            if (clearColorCache[0] !== clearColor[0] || clearColorCache[1] !== clearColor[1] || clearColorCache[2] !== clearColor[2] || clearColorCache[3] !== clearColor[3]) {
              clearColorCache[0] = clearColor[0];
              clearColorCache[1] = clearColor[1];
              clearColorCache[2] = clearColor[2];
              clearColorCache[3] = clearColor[3];
              gl2.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
            }
            gl2.clear(gl2.COLOR_BUFFER_BIT | gl2.DEPTH_BUFFER_BIT | gl2.STENCIL_BUFFER_BIT);
          }
        }
        this.onRenderTargetChange.emit(renderTarget);
        return renderTarget;
      }
      /**
       * returns the gpu texture for the first color texture in the render target
       * mainly used by the filter manager to get copy the texture for blending
       * @param renderTarget
       * @returns a gpu texture
       */
      getGpuColorTexture(renderTarget) {
        return renderTarget.colorTexture;
      }
      push(renderSurface, clear = true, clearColor) {
        const renderTarget = this.bind(renderSurface, clear, clearColor);
        this.renderTargetStack.push(renderTarget);
        return renderTarget;
      }
      pop() {
        this.renderTargetStack.pop();
        this.bind(this.renderTargetStack[this.renderTargetStack.length - 1], false);
      }
      getRenderTarget(renderSurface) {
        return this.renderSurfaceToRenderTargetHash.get(renderSurface) ?? this.initRenderTarget(renderSurface);
      }
      initRenderTarget(renderSurface) {
        let renderTarget = null;
        if (renderSurface instanceof HTMLCanvasElement) {
          renderSurface = getCanvasTexture(renderSurface);
        }
        if (renderSurface instanceof RenderTarget) {
          renderTarget = renderSurface;
        } else if (renderSurface instanceof Texture) {
          renderTarget = new RenderTarget({
            colorTextures: [renderSurface]
          });
          if (renderSurface.source.resource instanceof HTMLCanvasElement) {
            renderTarget.isRoot = true;
          }
          renderSurface.source.on("destroy", () => {
            renderTarget.destroy();
          });
        }
        this.renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);
        return renderTarget;
      }
      finishRenderPass() {
        const glRenderTarget = this.getGpuRenderTarget(this.renderTarget);
        if (!glRenderTarget.msaa)
          return;
        const gl = this.renderer.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);
        gl.blitFramebuffer(
          0,
          0,
          glRenderTarget.width,
          glRenderTarget.height,
          0,
          0,
          glRenderTarget.width,
          glRenderTarget.height,
          gl.COLOR_BUFFER_BIT,
          gl.NEAREST
        );
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
      }
      finish() {
      }
      copyToTexture(sourceRenderSurfaceTexture, destinationTexture, origin, size2) {
        const renderer = this.renderer;
        const baseTexture = renderer.renderTarget.getGpuColorTexture(sourceRenderSurfaceTexture);
        renderer.renderTarget.bind(baseTexture, false);
        renderer.texture.bind(destinationTexture, 0);
        const gl = renderer.gl;
        gl.copyTexSubImage2D(
          gl.TEXTURE_2D,
          0,
          0,
          0,
          origin.x,
          origin.y,
          size2.width,
          size2.height
        );
        return destinationTexture;
      }
      getGpuRenderTarget(renderTarget) {
        return this.gpuRenderTargetHash[renderTarget.uid] || this.initGpuRenderTarget(renderTarget);
      }
      initGpuRenderTarget(renderTarget) {
        const renderer = this.renderer;
        const gl = renderer.gl;
        const glRenderTarget = new GlRenderTarget();
        if (renderTarget.colorTexture.source.resource instanceof HTMLCanvasElement) {
          this.gpuRenderTargetHash[renderTarget.uid] = glRenderTarget;
          glRenderTarget.framebuffer = null;
          return glRenderTarget;
        }
        this.initColor(renderTarget, glRenderTarget);
        if (renderTarget.stencil) {
          this.initStencil(glRenderTarget);
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        this.gpuRenderTargetHash[renderTarget.uid] = glRenderTarget;
        return glRenderTarget;
      }
      resizeGpuRenderTarget(renderTarget) {
        if (renderTarget.isRoot)
          return;
        const glRenderTarget = this.getGpuRenderTarget(renderTarget);
        this.resizeColor(renderTarget, glRenderTarget);
        if (renderTarget.stencil) {
          this.resizeStencil(glRenderTarget);
        }
      }
      initColor(renderTarget, glRenderTarget) {
        const renderer = this.renderer;
        const gl = renderer.gl;
        const resolveTargetFramebuffer = gl.createFramebuffer();
        glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);
        glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;
        glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;
        renderTarget.colorTextures.forEach((colorTexture, i) => {
          const source3 = colorTexture.source;
          if (source3.antialias) {
            glRenderTarget.msaa = true;
          }
          renderer.texture.bindSource(source3, 0);
          const glSource = renderer.texture.getGlSource(source3);
          const glTexture = glSource.texture;
          gl.framebufferTexture2D(
            gl.FRAMEBUFFER,
            gl.COLOR_ATTACHMENT0 + i,
            3553,
            // texture.target,
            glTexture,
            0
          );
        });
        if (glRenderTarget.msaa) {
          const viewFramebuffer = gl.createFramebuffer();
          glRenderTarget.framebuffer = viewFramebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
          renderTarget.colorTextures.forEach((_2, i) => {
            const msaaRenderBuffer = gl.createRenderbuffer();
            glRenderTarget.msaaRenderBuffer[i] = msaaRenderBuffer;
          });
        } else {
          glRenderTarget.framebuffer = resolveTargetFramebuffer;
        }
      }
      resizeColor(renderTarget, glRenderTarget) {
        const source3 = renderTarget.colorTexture.source;
        glRenderTarget.width = source3.pixelWidth;
        glRenderTarget.height = source3.pixelHeight;
        renderTarget.colorTextures.forEach((colorTexture, i) => {
          if (i === 0)
            return;
          colorTexture.source.resize(source3.width, source3.height, source3._resolution);
        });
        if (glRenderTarget.msaa) {
          const renderer = this.renderer;
          const gl = renderer.gl;
          const viewFramebuffer = glRenderTarget.framebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
          renderTarget.colorTextures.forEach((colorTexture, i) => {
            const source22 = colorTexture.source;
            renderer.texture.bindSource(source22, 0);
            const glSource = renderer.texture.getGlSource(source22);
            const glInternalFormat = glSource.internalFormat;
            const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i];
            gl.bindRenderbuffer(
              gl.RENDERBUFFER,
              msaaRenderBuffer
            );
            gl.renderbufferStorageMultisample(
              gl.RENDERBUFFER,
              4,
              glInternalFormat,
              source22.pixelWidth,
              source22.pixelHeight
            );
            gl.framebufferRenderbuffer(
              gl.FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0 + i,
              gl.RENDERBUFFER,
              msaaRenderBuffer
            );
          });
        }
      }
      initStencil(glRenderTarget) {
        const gl = this.renderer.gl;
        const depthStencilRenderBuffer = gl.createRenderbuffer();
        glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;
        gl.bindRenderbuffer(
          gl.RENDERBUFFER,
          depthStencilRenderBuffer
        );
        gl.framebufferRenderbuffer(
          gl.FRAMEBUFFER,
          gl.DEPTH_STENCIL_ATTACHMENT,
          gl.RENDERBUFFER,
          depthStencilRenderBuffer
        );
      }
      resizeStencil(glRenderTarget) {
        const gl = this.renderer.gl;
        gl.bindRenderbuffer(
          gl.RENDERBUFFER,
          glRenderTarget.depthStencilRenderBuffer
        );
        if (glRenderTarget.msaa) {
          gl.renderbufferStorageMultisample(
            gl.RENDERBUFFER,
            4,
            gl.DEPTH24_STENCIL8,
            glRenderTarget.width,
            glRenderTarget.height
          );
        } else {
          gl.renderbufferStorage(
            gl.RENDERBUFFER,
            gl.DEPTH_STENCIL,
            glRenderTarget.width,
            glRenderTarget.height
          );
        }
      }
      destroy() {
      }
    };
    GlRenderTargetSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "renderTarget"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs
var GlStencilSystem;
var init_GlStencilSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs"() {
    init_Extensions();
    init_GpuStencilModesToPixi();
    init_const7();
    GlStencilSystem = class {
      constructor(renderer) {
        this.stencilCache = {
          enabled: false,
          stencilReference: 0
        };
        this.renderTargetStencilState = {};
        renderer.renderTarget.onRenderTargetChange.add(this);
      }
      contextChange(gl) {
        this.gl = gl;
        this.comparisonFuncMapping = {
          always: gl.ALWAYS,
          never: gl.NEVER,
          equal: gl.EQUAL,
          "not-equal": gl.NOTEQUAL,
          less: gl.LESS,
          "less-equal": gl.LEQUAL,
          greater: gl.GREATER,
          "greater-equal": gl.GEQUAL
        };
        this.stencilOpsMapping = {
          keep: gl.KEEP,
          zero: gl.ZERO,
          replace: gl.REPLACE,
          invert: gl.INVERT,
          "increment-clamp": gl.INCR,
          "decrement-clamp": gl.DECR,
          "increment-wrap": gl.INCR_WRAP,
          "decrement-wrap": gl.DECR_WRAP
        };
      }
      onRenderTargetChange(renderTarget) {
        this.activeRenderTarget = renderTarget;
        let stencilState = this.renderTargetStencilState[renderTarget.uid];
        if (!stencilState) {
          stencilState = this.renderTargetStencilState[renderTarget.uid] = {
            stencilMode: STENCIL_MODES.DISABLED,
            stencilReference: 0
          };
        }
        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
      }
      setStencilMode(stencilMode, stencilReference) {
        const stencilState = this.renderTargetStencilState[this.activeRenderTarget.uid];
        stencilState.stencilMode = stencilMode;
        stencilState.stencilReference = stencilReference;
        const mode = GpuStencilModesToPixi[stencilMode];
        const gl = this.gl;
        if (stencilMode === STENCIL_MODES.DISABLED) {
          if (this.stencilCache.enabled) {
            this.stencilCache.enabled = false;
            gl.disable(gl.STENCIL_TEST);
          }
          return;
        }
        if (!this.stencilCache.enabled) {
          this.stencilCache.enabled = true;
          gl.enable(gl.STENCIL_TEST);
        }
        gl.stencilFunc(this.comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 255);
        gl.stencilOp(gl.KEEP, gl.KEEP, this.stencilOpsMapping[mode.stencilBack.passOp]);
      }
      destroy() {
      }
    };
    GlStencilSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "stencil"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs
var GlProgramData;
var init_GlProgramData = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs"() {
    GlProgramData = class {
      /**
       * Makes a new Pixi program.
       * @param program - webgl program
       * @param uniformData - uniforms
       */
      constructor(program, uniformData) {
        this.program = program;
        this.uniformData = uniformData;
        this.uniformGroups = {};
        this.uniformDirtyGroups = {};
        this.uniformBlockBindings = {};
      }
      /** Destroys this program. */
      destroy() {
        this.uniformData = null;
        this.uniformGroups = null;
        this.uniformDirtyGroups = null;
        this.uniformBlockBindings = null;
        this.program = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs
function compileShader(gl, type, src) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}
var init_compileShader = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs
function booleanArray(size2) {
  const array = new Array(size2);
  for (let i = 0; i < array.length; i++) {
    array[i] = false;
  }
  return array;
}
function defaultValue(type, size2) {
  switch (type) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size2);
    case "vec3":
      return new Float32Array(3 * size2);
    case "vec4":
      return new Float32Array(4 * size2);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size2);
    case "ivec3":
      return new Int32Array(3 * size2);
    case "ivec4":
      return new Int32Array(4 * size2);
    case "uvec2":
      return new Uint32Array(2 * size2);
    case "uvec3":
      return new Uint32Array(3 * size2);
    case "uvec4":
      return new Uint32Array(4 * size2);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size2);
    case "bvec3":
      return booleanArray(3 * size2);
    case "bvec4":
      return booleanArray(4 * size2);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var init_defaultValue = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapSize.mjs
function mapSize(type) {
  return GLSL_TO_SIZE[type];
}
var GLSL_TO_SIZE;
var init_mapSize = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapSize.mjs"() {
    GLSL_TO_SIZE = {
      float: 1,
      vec2: 2,
      vec3: 3,
      vec4: 4,
      int: 1,
      ivec2: 2,
      ivec3: 3,
      ivec4: 4,
      uint: 1,
      uvec2: 2,
      uvec3: 3,
      uvec4: 4,
      bool: 1,
      bvec2: 2,
      bvec3: 3,
      bvec4: 4,
      mat2: 4,
      mat3: 9,
      mat4: 16,
      sampler2D: 1
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs
function mapType(gl, type) {
  if (!GL_TABLE) {
    const typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (let i = 0; i < typeNames.length; ++i) {
      const tn = typeNames[i];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type];
}
var GL_TABLE, GL_TO_GLSL_TYPES;
var init_mapType = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs"() {
    GL_TABLE = null;
    GL_TO_GLSL_TYPES = {
      FLOAT: "float",
      FLOAT_VEC2: "vec2",
      FLOAT_VEC3: "vec3",
      FLOAT_VEC4: "vec4",
      INT: "int",
      INT_VEC2: "ivec2",
      INT_VEC3: "ivec3",
      INT_VEC4: "ivec4",
      UNSIGNED_INT: "uint",
      UNSIGNED_INT_VEC2: "uvec2",
      UNSIGNED_INT_VEC3: "uvec3",
      UNSIGNED_INT_VEC4: "uvec4",
      BOOL: "bool",
      BOOL_VEC2: "bvec2",
      BOOL_VEC3: "bvec3",
      BOOL_VEC4: "bvec4",
      FLOAT_MAT2: "mat2",
      FLOAT_MAT3: "mat3",
      FLOAT_MAT4: "mat4",
      SAMPLER_2D: "sampler2D",
      INT_SAMPLER_2D: "sampler2D",
      UNSIGNED_INT_SAMPLER_2D: "sampler2D",
      SAMPLER_CUBE: "samplerCube",
      INT_SAMPLER_CUBE: "samplerCube",
      UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
      SAMPLER_2D_ARRAY: "sampler2DArray",
      INT_SAMPLER_2D_ARRAY: "sampler2DArray",
      UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getAttributeData.mjs
function getAttributeData(program, gl) {
  const attributes = {};
  const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < totalAttributes; i++) {
    const attribData = gl.getActiveAttrib(program, i);
    if (attribData.name.startsWith("gl_")) {
      continue;
    }
    const type = mapType(gl, attribData.type);
    const data = {
      type,
      name: attribData.name,
      size: mapSize(type),
      location: gl.getAttribLocation(program, attribData.name)
    };
    attributes[attribData.name] = data;
  }
  return attributes;
}
var init_getAttributeData = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getAttributeData.mjs"() {
    init_mapSize();
    init_mapType();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformBufferData.mjs
function getUniformBufferData(program, gl) {
  const uniformBlocks = {};
  const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
  for (let i = 0; i < totalUniformsBlocks; i++) {
    const name = gl.getActiveUniformBlockName(program, i);
    const uniformBlockIndex = gl.getUniformBlockIndex(program, name);
    const size2 = gl.getActiveUniformBlockParameter(program, i, gl.UNIFORM_BLOCK_DATA_SIZE);
    uniformBlocks[name] = {
      name,
      index: uniformBlockIndex,
      size: size2
    };
  }
  return uniformBlocks;
}
var init_getUniformBufferData = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformBufferData.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs
function getUniformData(program, gl) {
  const uniforms = {};
  const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i = 0; i < totalUniforms; i++) {
    const uniformData = gl.getActiveUniform(program, i);
    const name = uniformData.name.replace(/\[.*?\]$/, "");
    const isArray = !!uniformData.name.match(/\[.*?\]$/);
    const type = mapType(gl, uniformData.type);
    uniforms[name] = {
      name,
      index: i,
      type,
      size: uniformData.size,
      isArray,
      value: defaultValue(type, uniformData.size)
    };
  }
  return uniforms;
}
var init_getUniformData = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs"() {
    init_defaultValue();
    init_mapType();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs
function logPrettyShaderError(gl, shader) {
  const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index) => `${index}: ${line}`);
  const shaderLog = gl.getShaderInfoLog(shader);
  const splitShader = shaderLog.split("\n");
  const dedupe = {};
  const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n) => {
    if (n && !dedupe[n]) {
      dedupe[n] = true;
      return true;
    }
    return false;
  });
  const logArgs = [""];
  lineNumbers.forEach((number) => {
    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  const fragmentSourceToLog = shaderSrc.join("\n");
  logArgs[0] = fragmentSourceToLog;
  console.error(shaderLog);
  console.groupCollapsed("click to view full shader code");
  console.warn(...logArgs);
  console.groupEnd();
}
function logProgramError(gl, program, vertexShader, fragmentShader) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, vertexShader);
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, fragmentShader);
    }
    console.error("PixiJS Error: Could not initialize shader.");
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
  }
}
var init_logProgramError = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs
function generateProgram(gl, program) {
  const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);
  const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);
  const webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader);
  gl.attachShader(webGLProgram, glFragShader);
  const transformFeedbackVaryings = program.transformFeedbackVaryings;
  if (transformFeedbackVaryings) {
    if (typeof gl.transformFeedbackVaryings !== "function") {
      console.warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
    } else {
      gl.transformFeedbackVaryings(
        webGLProgram,
        transformFeedbackVaryings.names,
        transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS
      );
    }
  }
  gl.linkProgram(webGLProgram);
  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
    logProgramError(gl, webGLProgram, glVertShader, glFragShader);
  }
  program.attributeData = getAttributeData(webGLProgram, gl);
  program.uniformData = getUniformData(webGLProgram, gl);
  program.uniformBlockData = getUniformBufferData(webGLProgram, gl);
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  const uniformData = {};
  for (const i in program.uniformData) {
    const data = program.uniformData[i];
    uniformData[i] = {
      location: gl.getUniformLocation(webGLProgram, i),
      value: defaultValue(data.type, data.size)
    };
  }
  const glProgram = new GlProgramData(webGLProgram, uniformData);
  return glProgram;
}
var init_generateProgram = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs"() {
    init_GlProgramData();
    init_compileShader();
    init_defaultValue();
    init_getAttributeData();
    init_getUniformBufferData();
    init_getUniformData();
    init_logProgramError();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs
var defaultSyncData, GlShaderSystem;
var init_GlShaderSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs"() {
    init_Extensions();
    init_BufferResource();
    init_UniformGroup();
    init_TextureSource();
    init_TextureStyle();
    init_generateProgram();
    defaultSyncData = {
      textureCount: 0,
      blockIndex: 0
    };
    GlShaderSystem = class {
      constructor(renderer) {
        this.programDataHash = {};
        this.activeProgram = null;
        this.nextIndex = 0;
        this.boundUniformsIdsToIndexHash = {};
        this.boundIndexToUniformsHash = {};
        this.renderer = renderer;
      }
      contextChange(gl) {
        this.gl = gl;
        this.maxBindings = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);
      }
      bind(shader, skipSync) {
        this.setProgram(shader.glProgram);
        if (skipSync)
          return;
        defaultSyncData.textureCount = 0;
        defaultSyncData.blockIndex = 0;
        const gl = this.gl;
        const programData = this.getProgramData(shader.glProgram);
        for (const i in shader.groups) {
          const bindGroup = shader.groups[i];
          for (const j2 in bindGroup.resources) {
            const resource = bindGroup.resources[j2];
            if (resource instanceof UniformGroup) {
              if (resource.ubo) {
                this.bindUniformBlock(
                  resource,
                  shader.uniformBindMap[i][j2],
                  defaultSyncData.blockIndex++
                );
              } else {
                this.updateUniformGroup(resource);
              }
            } else if (resource instanceof BufferResource) {
              this.bindUniformBlock(
                resource,
                shader.uniformBindMap[i][j2],
                defaultSyncData.blockIndex++
              );
            } else if (resource instanceof TextureSource) {
              this.renderer.texture.bind(resource, defaultSyncData.textureCount);
              const uniformName = shader.uniformBindMap[i][j2];
              const uniformData = programData.uniformData[uniformName];
              if (uniformData) {
                gl.uniform1i(uniformData.location, defaultSyncData.textureCount++);
              }
            } else if (resource instanceof TextureStyle) {
            }
          }
        }
      }
      updateUniformGroup(uniformGroup) {
        this.renderer.uniformGroup.updateUniformGroup(uniformGroup, this.activeProgram, defaultSyncData);
      }
      bindUniformBlock(uniformGroup, name, index = 0) {
        const bufferSystem = this.renderer.buffer;
        const programData = this.getProgramData(this.activeProgram);
        const isBufferResource = uniformGroup.bufferResource;
        if (isBufferResource) {
          this.renderer.uniformBuffer.updateUniformGroup(uniformGroup);
        }
        bufferSystem.updateBuffer(uniformGroup.buffer);
        let boundIndex = this.boundUniformsIdsToIndexHash[uniformGroup.uid];
        if (boundIndex === void 0) {
          const nextIndex = this.nextIndex++ % this.maxBindings;
          const currentBoundUniformGroup = this.boundIndexToUniformsHash[nextIndex];
          if (currentBoundUniformGroup) {
            this.boundUniformsIdsToIndexHash[currentBoundUniformGroup.uid] = void 0;
          }
          boundIndex = this.boundUniformsIdsToIndexHash[uniformGroup.uid] = nextIndex;
          this.boundIndexToUniformsHash[nextIndex] = uniformGroup;
          if (isBufferResource) {
            bufferSystem.bindBufferRange(uniformGroup.buffer, nextIndex, uniformGroup.offset);
          } else {
            bufferSystem.bindBufferBase(uniformGroup.buffer, nextIndex);
          }
        }
        const gl = this.gl;
        const uniformBlockIndex = this.activeProgram.uniformBlockData[name].index;
        if (programData.uniformBlockBindings[index] === boundIndex)
          return;
        programData.uniformBlockBindings[index] = boundIndex;
        gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundIndex);
      }
      setProgram(program) {
        if (this.activeProgram === program)
          return;
        this.activeProgram = program;
        const programData = this.getProgramData(program);
        this.gl.useProgram(programData.program);
      }
      getProgramData(program) {
        const key = program.key;
        return this.programDataHash[key] || this.createProgramData(program);
      }
      createProgramData(program) {
        const key = program.key;
        this.programDataHash[key] = generateProgram(this.gl, program);
        return this.programDataHash[key];
      }
    };
    GlShaderSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "shader"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/unsafeEvalSupported.mjs
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func({ a: "b" }, "a", "b") === true;
  } catch (e) {
    unsafeEval = false;
  }
  return unsafeEval;
}
var unsafeEval;
var init_unsafeEvalSupported = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/unsafeEvalSupported.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/uniformParsers.mjs
var uniformParsers;
var init_uniformParsers = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/uniformParsers.mjs"() {
    init_Texture();
    uniformParsers = [
      // a float cache layer
      {
        test: (data) => data.type === "float" && data.size === 1 && !data.isArray,
        code: (name) => `
            if(uv["${name}"] !== ud["${name}"].value)
            {
                ud["${name}"].value = uv["${name}"]
                gl.uniform1f(ud["${name}"].location, uv["${name}"])
            }
            `
      },
      // handling samplers
      {
        test: (data, uniform) => (
          // eslint-disable-next-line max-len,no-eq-null,eqeqeq
          (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform instanceof Texture)
        ),
        code: (name) => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${name}"], t);

            if(ud["${name}"].value !== t)
            {
                ud["${name}"].value = t;
                gl.uniform1i(ud["${name}"].location, t);
; // eslint-disable-line max-len
            }`
      },
      // uploading pixi matrix object to mat3
      {
        test: (data, uniform) => data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== void 0,
        code: (name) => (
          // TODO and some smart caching dirty ids here!
          `
            gl.uniformMatrix3fv(ud["${name}"].location, false, uv["${name}"].toArray(true));
            `
        )
      },
      // uploading a pixi point as a vec2 with caching layer
      {
        test: (data, uniform) => data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== void 0,
        code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${name}"].location, v.x, v.y);
                }`
      },
      // caching layer for a vec2
      {
        test: (data) => data.type === "vec2" && data.size === 1 && !data.isArray,
        code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${name}"].location, v[0], v[1]);
                }
            `
      },
      // upload a pixi rectangle as a vec4 with caching layer
      {
        test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== void 0,
        code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${name}"].location, v.x, v.y, v.width, v.height)
                }`
      },
      // upload a pixi color as vec4 with caching layer
      {
        test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.red !== void 0,
        code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${name}"].location, v.red, v.green, v.blue, v.alpha)
                }`
      },
      // upload a pixi color as a vec3 with caching layer
      {
        test: (data, uniform) => data.type === "vec3" && data.size === 1 && !data.isArray && uniform.red !== void 0,
        code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
    
                    gl.uniform3f(ud["${name}"].location, v.red, v.green, v.blue)
                }`
      },
      // a caching layer for vec4 uploading
      {
        test: (data) => data.type === "vec4" && data.size === 1 && !data.isArray,
        code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${name}"].location, v[0], v[1], v[2], v[3])
                }`
      }
    ];
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateUniformsSync.mjs
function generateUniformsSync(group, uniformData) {
  const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
  for (const i in group.uniforms) {
    const data = uniformData[i];
    if (!data) {
      if (group.uniforms[i] instanceof UniformGroup) {
        if (group.uniforms[i].ubo) {
          funcFragments.push(`
                        renderer.shader.bindUniformBlock(uv.${i}, "${i}");
                    `);
        } else {
          funcFragments.push(`
                        renderer.shader.updateUniformGroup(uv.${i});
                    `);
        }
      } else if (group.uniforms[i] instanceof BufferResource) {
        funcFragments.push(`
                        renderer.shader.bindBufferResource(uv.${i}, "${i}");
                    `);
      }
      continue;
    }
    const uniform = group.uniforms[i];
    let parsed = false;
    for (let j2 = 0; j2 < uniformParsers.length; j2++) {
      if (uniformParsers[j2].test(data, uniform)) {
        funcFragments.push(uniformParsers[j2].code(i, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      const templateType = data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
      const template = templateType[data.type].replace("location", `ud["${i}"].location`);
      funcFragments.push(`
            cu = ud["${i}"];
            cv = cu.value;
            v = uv["${i}"];
            ${template};`);
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
}
var GLSL_TO_SINGLE_SETTERS_CACHED, GLSL_TO_ARRAY_SETTERS;
var init_generateUniformsSync = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateUniformsSync.mjs"() {
    init_BufferResource();
    init_UniformGroup();
    init_uniformParsers();
    GLSL_TO_SINGLE_SETTERS_CACHED = {
      float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
      vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
      vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
      vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
      int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
      ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
      ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
      ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
      uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
      uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
      uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
      uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
      bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
      bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
      bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
      bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
      mat2: "gl.uniformMatrix2fv(location, false, v)",
      mat3: "gl.uniformMatrix3fv(location, false, v)",
      mat4: "gl.uniformMatrix4fv(location, false, v)",
      sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
      samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
      sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
    };
    GLSL_TO_ARRAY_SETTERS = {
      float: `gl.uniform1fv(location, v)`,
      vec2: `gl.uniform2fv(location, v)`,
      vec3: `gl.uniform3fv(location, v)`,
      vec4: "gl.uniform4fv(location, v)",
      mat4: "gl.uniformMatrix4fv(location, false, v)",
      mat3: "gl.uniformMatrix3fv(location, false, v)",
      mat2: "gl.uniformMatrix2fv(location, false, v)",
      int: "gl.uniform1iv(location, v)",
      ivec2: "gl.uniform2iv(location, v)",
      ivec3: "gl.uniform3iv(location, v)",
      ivec4: "gl.uniform4iv(location, v)",
      uint: "gl.uniform1uiv(location, v)",
      uvec2: "gl.uniform2uiv(location, v)",
      uvec3: "gl.uniform3uiv(location, v)",
      uvec4: "gl.uniform4uiv(location, v)",
      bool: "gl.uniform1iv(location, v)",
      bvec2: "gl.uniform2iv(location, v)",
      bvec3: "gl.uniform3iv(location, v)",
      bvec4: "gl.uniform4iv(location, v)",
      sampler2D: "gl.uniform1iv(location, v)",
      samplerCube: "gl.uniform1iv(location, v)",
      sampler2DArray: "gl.uniform1iv(location, v)"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs
var GlUniformGroupSystem;
var init_GlUniformGroupSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs"() {
    init_Extensions();
    init_unsafeEvalSupported();
    init_generateUniformsSync();
    GlUniformGroupSystem = class {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this.destroyed = false;
        this.cache = {};
        this.uniformGroupSyncHash = {};
        this.renderer = renderer;
        this.systemCheck();
        this.gl = null;
        this.cache = {};
      }
      /**
       * Overrideable function by `@pixi/unsafe-eval` to silence
       * throwing an error if platform doesn't support unsafe-evals.
       * @private
       */
      systemCheck() {
        if (!unsafeEvalSupported()) {
          throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
        }
      }
      contextChange(gl) {
        this.gl = gl;
      }
      /**
       * Uploads the uniforms values to the currently bound shader.
       * @param group - the uniforms values that be applied to the current shader
       * @param program
       * @param syncData
       * @param syncData.textureCount
       */
      updateUniformGroup(group, program, syncData) {
        const programData = this.renderer.shader.getProgramData(program);
        if (!group.isStatic || group.dirtyId !== programData.uniformDirtyGroups[group.uid]) {
          programData.uniformDirtyGroups[group.uid] = group.dirtyId;
          const syncFunc = this.getUniformSyncFunction(group, program);
          syncFunc(programData.uniformData, group.uniforms, this.renderer, syncData);
        }
      }
      /**
       * Overrideable by the @pixi/unsafe-eval package to use static syncUniforms instead.
       * @param group
       * @param program
       */
      getUniformSyncFunction(group, program) {
        return this.uniformGroupSyncHash[group.signature]?.[program.key] || this.createUniformSyncFunction(group, program);
      }
      createUniformSyncFunction(group, program) {
        const uniformGroupSyncHash = this.uniformGroupSyncHash[group.signature] || (this.uniformGroupSyncHash[group.signature] = {});
        const id = this.getSignature(group, program.uniformData, "u");
        if (!this.cache[id]) {
          this.cache[id] = generateUniformsSync(group, program.uniformData);
        }
        uniformGroupSyncHash[program.key] = this.cache[id];
        return uniformGroupSyncHash[program.key];
      }
      /**
       * Takes a uniform group and data and generates a unique signature for them.
       * @param group - The uniform group to get signature of
       * @param group.uniforms
       * @param uniformData - Uniform information generated by the shader
       * @param preFix
       * @returns Unique signature of the uniform group
       */
      getSignature(group, uniformData, preFix) {
        const uniforms = group.uniforms;
        const strings = [`${preFix}-`];
        for (const i in uniforms) {
          strings.push(i);
          if (uniformData[i]) {
            strings.push(uniformData[i].type);
          }
        }
        return strings.join("-");
      }
      /** Destroys this System and removes all its textures. */
      destroy() {
        this.renderer = null;
        this.destroyed = true;
      }
    };
    GlUniformGroupSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "uniformGroup"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs
function mapWebGLBlendModesToPixi(gl) {
  const blendMap = {};
  blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.add = [gl.ONE, gl.ONE];
  blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.none = [0, 0];
  blendMap["normal-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap["add-npm"] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  blendMap["screen-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  return blendMap;
}
var init_mapWebGLBlendModesToPixi = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs
var BLEND2, OFFSET2, CULLING2, DEPTH_TEST2, WINDING2, DEPTH_MASK2, _GlStateSystem, GlStateSystem;
var init_GlStateSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs"() {
    init_Extensions();
    init_State();
    init_mapWebGLBlendModesToPixi();
    BLEND2 = 0;
    OFFSET2 = 1;
    CULLING2 = 2;
    DEPTH_TEST2 = 3;
    WINDING2 = 4;
    DEPTH_MASK2 = 5;
    _GlStateSystem = class {
      constructor() {
        this.gl = null;
        this.stateId = 0;
        this.polygonOffset = 0;
        this.blendMode = "none";
        this._blendEq = false;
        this.map = [];
        this.map[BLEND2] = this.setBlend;
        this.map[OFFSET2] = this.setOffset;
        this.map[CULLING2] = this.setCullFace;
        this.map[DEPTH_TEST2] = this.setDepthTest;
        this.map[WINDING2] = this.setFrontFace;
        this.map[DEPTH_MASK2] = this.setDepthMask;
        this.checks = [];
        this.defaultState = new State();
        this.defaultState.blend = true;
      }
      contextChange(gl) {
        this.gl = gl;
        this.blendModesMap = mapWebGLBlendModesToPixi(gl);
        this.set(this.defaultState);
        this.reset();
      }
      /**
       * Sets the current state
       * @param {*} state - The state to set.
       */
      set(state) {
        state = state || this.defaultState;
        if (this.stateId !== state.data) {
          let diff = this.stateId ^ state.data;
          let i = 0;
          while (diff) {
            if (diff & 1) {
              this.map[i].call(this, !!(state.data & 1 << i));
            }
            diff = diff >> 1;
            i++;
          }
          this.stateId = state.data;
        }
        for (let i = 0; i < this.checks.length; i++) {
          this.checks[i](this, state);
        }
      }
      /**
       * Sets the state, when previous state is unknown.
       * @param {*} state - The state to set
       */
      forceState(state) {
        state = state || this.defaultState;
        for (let i = 0; i < this.map.length; i++) {
          this.map[i].call(this, !!(state.data & 1 << i));
        }
        for (let i = 0; i < this.checks.length; i++) {
          this.checks[i](this, state);
        }
        this.stateId = state.data;
      }
      /**
       * Sets whether to enable or disable blending.
       * @param value - Turn on or off WebGl blending.
       */
      setBlend(value) {
        this.updateCheck(_GlStateSystem.checkBlendMode, value);
        this.gl[value ? "enable" : "disable"](this.gl.BLEND);
      }
      /**
       * Sets whether to enable or disable polygon offset fill.
       * @param value - Turn on or off webgl polygon offset testing.
       */
      setOffset(value) {
        this.updateCheck(_GlStateSystem.checkPolygonOffset, value);
        this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
      }
      /**
       * Sets whether to enable or disable depth test.
       * @param value - Turn on or off webgl depth testing.
       */
      setDepthTest(value) {
        this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
      }
      /**
       * Sets whether to enable or disable depth mask.
       * @param value - Turn on or off webgl depth mask.
       */
      setDepthMask(value) {
        this.gl.depthMask(value);
      }
      /**
       * Sets whether to enable or disable cull face.
       * @param {boolean} value - Turn on or off webgl cull face.
       */
      setCullFace(value) {
        this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
      }
      /**
       * Sets the gl front face.
       * @param {boolean} value - true is clockwise and false is counter-clockwise
       */
      setFrontFace(value) {
        this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
      }
      /**
       * Sets the blend mode.
       * @param {number} value - The blend mode to set to.
       */
      setBlendMode(value) {
        if (!this.blendModesMap[value]) {
          value = "normal";
        }
        if (value === this.blendMode) {
          return;
        }
        this.blendMode = value;
        const mode = this.blendModesMap[value];
        const gl = this.gl;
        if (mode.length === 2) {
          gl.blendFunc(mode[0], mode[1]);
        } else {
          gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
        }
        if (mode.length === 6) {
          this._blendEq = true;
          gl.blendEquationSeparate(mode[4], mode[5]);
        } else if (this._blendEq) {
          this._blendEq = false;
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        }
      }
      /**
       * Sets the polygon offset.
       * @param {number} value - the polygon offset
       * @param {number} scale - the polygon offset scale
       */
      setPolygonOffset(value, scale3) {
        this.gl.polygonOffset(value, scale3);
      }
      // used
      /** Resets all the logic and disables the VAOs. */
      reset() {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
        this.forceState(this.defaultState);
        this._blendEq = true;
        this.blendMode = "";
        this.setBlendMode("normal");
      }
      /**
       * Checks to see which updates should be checked based on which settings have been activated.
       *
       * For example, if blend is enabled then we should check the blend modes each time the state is changed
       * or if polygon fill is activated then we need to check if the polygon offset changes.
       * The idea is that we only check what we have too.
       * @param func - the checking function to add or remove
       * @param value - should the check function be added or removed.
       */
      updateCheck(func, value) {
        const index = this.checks.indexOf(func);
        if (value && index === -1) {
          this.checks.push(func);
        } else if (!value && index !== -1) {
          this.checks.splice(index, 1);
        }
      }
      /**
       * A private little wrapper function that we call to check the blend mode.
       * @param system - the System to perform the state check on
       * @param state - the state that the blendMode will pulled from
       */
      static checkBlendMode(system, state) {
        system.setBlendMode(state.blendMode);
      }
      /**
       * A private little wrapper function that we call to check the polygon offset.
       * @param system - the System to perform the state check on
       * @param state - the state that the blendMode will pulled from
       */
      static checkPolygonOffset(system, state) {
        system.setPolygonOffset(1, state.polygonOffset);
      }
      /**
       * @ignore
       */
      destroy() {
        this.gl = null;
      }
    };
    GlStateSystem = _GlStateSystem;
    GlStateSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "state"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs
var GlTexture;
var init_GlTexture = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs"() {
    init_const10();
    GlTexture = class {
      constructor(texture) {
        this.target = GL_TARGETS.TEXTURE_2D;
        this.texture = texture;
        this.width = -1;
        this.height = -1;
        this.type = GL_TYPES.UNSIGNED_BYTE;
        this.internalFormat = GL_FORMATS.RGBA;
        this.format = GL_FORMATS.RGBA;
        this.samplerType = 0;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs
var glUploadBufferImageResource;
var init_glUploadBufferImageResource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs"() {
    glUploadBufferImageResource = {
      type: "image",
      upload(source3, glTexture, gl) {
        if (glTexture.width === source3.width || glTexture.height === source3.height) {
          gl.texSubImage2D(
            gl.TEXTURE_2D,
            0,
            0,
            0,
            glTexture.format,
            glTexture.type,
            source3.resource
          );
        } else {
          gl.texImage2D(
            glTexture.target,
            0,
            glTexture.internalFormat,
            source3.width,
            source3.height,
            0,
            glTexture.format,
            glTexture.type,
            source3.resource
          );
        }
        glTexture.width = source3.width;
        glTexture.height = source3.height;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs
var glUploadImageResource;
var init_glUploadImageResource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs"() {
    glUploadImageResource = {
      type: "image",
      upload(source3, glTexture, gl) {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !(source3.alphaMode === 0));
        if (glTexture.width === source3.width || glTexture.height === source3.height) {
          gl.texSubImage2D(
            gl.TEXTURE_2D,
            0,
            0,
            0,
            glTexture.format,
            glTexture.type,
            source3.resource
          );
        } else {
          gl.texImage2D(
            glTexture.target,
            0,
            glTexture.internalFormat,
            source3.pixelWidth,
            source3.pixelHeight,
            0,
            glTexture.format,
            glTexture.type,
            source3.resource
          );
        }
        glTexture.width = source3.pixelWidth;
        glTexture.height = source3.pixelHeight;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs
function mapFormatToGlFormat(gl) {
  return {
    // 8-bit formats
    r8unorm: gl.RED,
    r8snorm: gl.RED,
    r8uint: gl.RED,
    r8sint: gl.RED,
    // 16-bit formats
    r16uint: gl.RED,
    r16sint: gl.RED,
    r16float: gl.RED,
    rg8unorm: gl.RG,
    rg8snorm: gl.RG,
    rg8uint: gl.RG,
    rg8sint: gl.RG,
    // 32-bit formats
    r32uint: gl.RED,
    r32sint: gl.RED,
    r32float: gl.RED,
    rg16uint: gl.RG,
    rg16sint: gl.RG,
    rg16float: gl.RG,
    rgba8unorm: gl.RGBA,
    "rgba8unorm-srgb": gl.RGBA,
    // Packed 32-bit formats
    rgba8snorm: gl.RGBA,
    rgba8uint: gl.RGBA,
    rgba8sint: gl.RGBA,
    bgra8unorm: gl.RGBA,
    "bgra8unorm-srgb": gl.RGBA,
    rgb9e5ufloat: gl.RGB,
    rgb10a2unorm: gl.RGBA,
    rg11b10ufloat: gl.RGB,
    // 64-bit formats
    rg32uint: gl.RG,
    rg32sint: gl.RG,
    rg32float: gl.RG,
    rgba16uint: gl.RGBA,
    rgba16sint: gl.RGBA,
    rgba16float: gl.RGBA,
    // 128-bit formats
    rgba32uint: gl.RGBA,
    rgba32sint: gl.RGBA,
    rgba32float: gl.RGBA,
    // Depth/stencil formats
    stencil8: gl.STENCIL_INDEX8,
    depth16unorm: gl.DEPTH_COMPONENT,
    depth24plus: gl.DEPTH_COMPONENT,
    "depth24plus-stencil8": gl.DEPTH_STENCIL,
    depth32float: gl.DEPTH_COMPONENT,
    "depth32float-stencil8": gl.DEPTH_STENCIL
  };
}
var init_mapFormatToGlFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs
function mapFormatToGlInternalFormat(gl) {
  return {
    // 8-bit formats
    r8unorm: gl.R8,
    r8snorm: gl.R8_SNORM,
    r8uint: gl.R8UI,
    r8sint: gl.R8I,
    // 16-bit formats
    r16uint: gl.R16UI,
    r16sint: gl.R16I,
    r16float: gl.R16F,
    rg8unorm: gl.RG8,
    rg8snorm: gl.RG8_SNORM,
    rg8uint: gl.RG8UI,
    rg8sint: gl.RG8I,
    // 32-bit formats
    r32uint: gl.R32UI,
    r32sint: gl.R32I,
    r32float: gl.R32F,
    rg16uint: gl.RG16UI,
    rg16sint: gl.RG16I,
    rg16float: gl.RG16F,
    rgba8unorm: gl.RGBA,
    "rgba8unorm-srgb": gl.SRGB8_ALPHA8,
    // Packed 32-bit formats
    rgba8snorm: gl.RGBA8_SNORM,
    rgba8uint: gl.RGBA8UI,
    rgba8sint: gl.RGBA8I,
    bgra8unorm: gl.RGBA8,
    "bgra8unorm-srgb": gl.SRGB8_ALPHA8,
    rgb9e5ufloat: gl.RGB9_E5,
    rgb10a2unorm: gl.RGB10_A2,
    rg11b10ufloat: gl.R11F_G11F_B10F,
    // 64-bit formats
    rg32uint: gl.RG32UI,
    rg32sint: gl.RG32I,
    rg32float: gl.RG32F,
    rgba16uint: gl.RGBA16UI,
    rgba16sint: gl.RGBA16I,
    rgba16float: gl.RGBA16F,
    // 128-bit formats
    rgba32uint: gl.RGBA32UI,
    rgba32sint: gl.RGBA32I,
    rgba32float: gl.RGBA32F,
    // Depth/stencil formats
    stencil8: gl.STENCIL_INDEX8,
    depth16unorm: gl.DEPTH_COMPONENT16,
    depth24plus: gl.DEPTH_COMPONENT24,
    "depth24plus-stencil8": gl.DEPTH24_STENCIL8,
    depth32float: gl.DEPTH_COMPONENT32F,
    "depth32float-stencil8": gl.DEPTH32F_STENCIL8
  };
}
var init_mapFormatToGlInternalFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs
function mapFormatToGlType(gl) {
  return {
    // 8-bit formats
    r8unorm: gl.UNSIGNED_BYTE,
    r8snorm: gl.BYTE,
    r8uint: gl.UNSIGNED_BYTE,
    r8sint: gl.BYTE,
    // 16-bit formats
    r16uint: gl.UNSIGNED_SHORT,
    r16sint: gl.SHORT,
    r16float: gl.HALF_FLOAT,
    rg8unorm: gl.UNSIGNED_BYTE,
    rg8snorm: gl.BYTE,
    rg8uint: gl.UNSIGNED_BYTE,
    rg8sint: gl.BYTE,
    // 32-bit formats
    r32uint: gl.UNSIGNED_INT,
    r32sint: gl.INT,
    r32float: gl.FLOAT,
    rg16uint: gl.UNSIGNED_SHORT,
    rg16sint: gl.SHORT,
    rg16float: gl.HALF_FLOAT,
    rgba8unorm: gl.UNSIGNED_BYTE,
    "rgba8unorm-srgb": gl.UNSIGNED_BYTE,
    // Packed 32-bit formats
    rgba8snorm: gl.BYTE,
    rgba8uint: gl.UNSIGNED_BYTE,
    rgba8sint: gl.BYTE,
    bgra8unorm: gl.UNSIGNED_BYTE,
    "bgra8unorm-srgb": gl.UNSIGNED_BYTE,
    rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,
    rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,
    rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,
    // 64-bit formats
    rg32uint: gl.UNSIGNED_INT,
    rg32sint: gl.INT,
    rg32float: gl.FLOAT,
    rgba16uint: gl.UNSIGNED_SHORT,
    rgba16sint: gl.SHORT,
    rgba16float: gl.HALF_FLOAT,
    // 128-bit formats
    rgba32uint: gl.UNSIGNED_INT,
    rgba32sint: gl.INT,
    rgba32float: gl.FLOAT,
    // Depth/stencil formats
    stencil8: gl.UNSIGNED_BYTE,
    depth16unorm: gl.UNSIGNED_SHORT,
    depth24plus: gl.UNSIGNED_INT,
    "depth24plus-stencil8": gl.UNSIGNED_INT_24_8,
    depth32float: gl.FLOAT,
    "depth32float-stencil8": gl.FLOAT_32_UNSIGNED_INT_24_8_REV
  };
}
var init_mapFormatToGlType = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs
var scaleModeToGlFilter, mipmapScaleModeToGlFilter, wrapModeToGlAddress, compareModeToGlCompare;
var init_pixiToGlMaps = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs"() {
    scaleModeToGlFilter = {
      linear: 9729,
      nearest: 9728
    };
    mipmapScaleModeToGlFilter = {
      linear: {
        linear: 9987,
        nearest: 9985
      },
      nearest: {
        linear: 9986,
        nearest: 9984
      }
    };
    wrapModeToGlAddress = {
      "clamp-to-edge": 33071,
      repeat: 10497,
      "mirror-repeat": 33648
    };
    compareModeToGlCompare = {
      never: 512,
      less: 513,
      equal: 514,
      "less-equal": 515,
      greater: 516,
      "not-equal": 517,
      "greater-equal": 518,
      always: 519
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs
var GlTextureSystem;
var init_GlTextureSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs"() {
    init_Extensions();
    init_Texture();
    init_GlTexture();
    init_glUploadBufferImageResource();
    init_glUploadImageResource();
    init_mapFormatToGlFormat();
    init_mapFormatToGlInternalFormat();
    init_mapFormatToGlType();
    init_pixiToGlMaps();
    GlTextureSystem = class {
      constructor(renderer) {
        this.glTextures = {};
        this.glSamplers = {};
        this.boundTextures = [];
        this.boundTexturesSamplers = [];
        this.activeTextureLocation = -1;
        this.boundSamplers = {};
        this.managedTextureSources = {};
        this.uploads = {
          image: glUploadImageResource,
          buffer: glUploadBufferImageResource
        };
        this.renderer = renderer;
      }
      contextChange(gl) {
        this.gl = gl;
        if (!this.mapFormatToInternalFormat) {
          this.mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl);
          this.mapFormatToType = mapFormatToGlType(gl);
          this.mapFormatToFormat = mapFormatToGlFormat(gl);
        }
        for (let i = 0; i < 16; i++) {
          this.bind(Texture.EMPTY, i);
        }
      }
      bind(texture, location = 0) {
        if (texture) {
          this.bindSource(texture.source, location);
          this.bindSampler(texture.style, location);
        } else {
          this.bindSource(null, location);
          this.bindSampler(null, location);
        }
      }
      bindSource(source3, location = 0) {
        const gl = this.gl;
        if (this.boundTextures[location] !== source3) {
          this.boundTextures[location] = source3;
          this.activateLocation(location);
          source3 = source3 || Texture.EMPTY.source;
          const glTexture = this.getGlSource(source3);
          gl.bindTexture(glTexture.target, glTexture.texture);
        }
      }
      bindSampler(style, location = 0) {
        const gl = this.gl;
        if (!style) {
          this.boundSamplers[location] = null;
          gl.bindSampler(location, null);
          return;
        }
        const sampler = this.getGlSampler(style);
        if (this.boundSamplers[location] !== sampler) {
          this.boundSamplers[location] = sampler;
          gl.bindSampler(location, sampler);
        }
      }
      unbind(texture) {
        const source3 = texture.source;
        const boundTextures = this.boundTextures;
        const gl = this.gl;
        for (let i = 0; i < boundTextures.length; i++) {
          if (boundTextures[i] === source3) {
            this.activateLocation(i);
            const glTexture = this.getGlSource(source3);
            gl.bindTexture(glTexture.target, null);
            boundTextures[i] = null;
          }
        }
      }
      activateLocation(location) {
        if (this.activeTextureLocation !== location) {
          this.activeTextureLocation = location;
          this.gl.activeTexture(this.gl.TEXTURE0 + location);
        }
      }
      initSource(source3) {
        const gl = this.gl;
        const glTexture = new GlTexture(gl.createTexture());
        glTexture.type = this.mapFormatToType[source3.format];
        glTexture.internalFormat = this.mapFormatToInternalFormat[source3.format];
        glTexture.format = this.mapFormatToFormat[source3.format];
        if (source3.autoGenerateMipmaps) {
          const biggestDimension = Math.max(source3.width, source3.height);
          source3.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
        }
        this.glTextures[source3.uid] = glTexture;
        source3.on("update", this.onSourceUpdate, this);
        source3.on("destroy", this.onSourceDestroy, this);
        this.onSourceUpdate(source3);
        return glTexture;
      }
      onSourceUpdate(source3) {
        const gl = this.gl;
        const glTexture = this.glTextures[source3.uid];
        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
        this.boundTextures[this.activeTextureLocation] = source3;
        if (this.uploads[source3.type]) {
          this.uploads[source3.type].upload(source3, glTexture, this.gl);
          if (source3.autoGenerateMipmaps && source3.mipLevelCount > 1) {
            gl.generateMipmap(glTexture.target);
          }
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source3.pixelWidth, source3.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
      }
      onSourceDestroy(source3) {
        const gl = this.gl;
        source3.off("destroy", this.onSourceDestroy, this);
        source3.off("update", this.onSourceUpdate, this);
        const glTexture = this.glTextures[source3.uid];
        delete this.glTextures[source3.uid];
        gl.deleteTexture(glTexture.target);
      }
      initSampler(style) {
        const gl = this.gl;
        const glSampler = this.gl.createSampler();
        this.glSamplers[style.resourceId] = glSampler;
        gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_S, wrapModeToGlAddress[style.addressModeU]);
        gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_T, wrapModeToGlAddress[style.addressModeV]);
        gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_R, wrapModeToGlAddress[style.addressModeW]);
        gl.samplerParameteri(glSampler, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.minFilter]);
        if (this.boundTextures[this.activeTextureLocation].mipLevelCount > 1) {
          const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];
          gl.samplerParameteri(glSampler, gl.TEXTURE_MIN_FILTER, glFilterMode);
        } else {
          gl.samplerParameteri(glSampler, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.magFilter]);
        }
        const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
        if (anisotropicExt && style.maxAnisotropy > 1) {
          const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
          gl.samplerParameteri(glSampler, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
        }
        if (style.compare) {
          gl.samplerParameteri(glSampler, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);
        }
        return this.glSamplers[style.resourceId];
      }
      getGlSampler(sampler) {
        return this.glSamplers[sampler.resourceId] || this.initSampler(sampler);
      }
      getGlSource(source3) {
        return this.glTextures[source3.uid] || this.initSource(source3);
      }
      destroy() {
        throw new Error("Method not implemented.");
      }
    };
    GlTextureSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "texture"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs
var WebGLRenderer_exports = {};
__export(WebGLRenderer_exports, {
  WebGLRenderer: () => WebGLRenderer
});
var DefaultWebGLSystems, DefaultWebGLPipes, DefaultWebGLAdapters, systems2, renderPipes2, renderPipeAdaptors2, WebGLRenderer;
var init_WebGLRenderer = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs"() {
    init_Extensions();
    init_GlBatchAdaptor();
    init_GlGraphicsAdaptor();
    init_GlMeshAdaptor();
    init_AbstractRenderer();
    init_SharedSystems();
    init_GlBufferSystem();
    init_GlContextSystem();
    init_GlGeometrySystem();
    init_GlBackBufferSystem();
    init_GlColorMaskSystem();
    init_GlEncoderSystem();
    init_GlRenderTargetSystem();
    init_GlStencilSystem();
    init_GlShaderSystem();
    init_GlUniformGroupSystem();
    init_GlStateSystem();
    init_GlTextureSystem();
    DefaultWebGLSystems = [
      ...SharedSystems,
      GlBackBufferSystem,
      GlContextSystem,
      GlBufferSystem,
      GlTextureSystem,
      GlRenderTargetSystem,
      GlGeometrySystem,
      GlUniformGroupSystem,
      GlShaderSystem,
      GlEncoderSystem,
      GlStateSystem,
      GlStencilSystem,
      GlColorMaskSystem
    ];
    DefaultWebGLPipes = [...SharedRenderPipes];
    DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];
    systems2 = [];
    renderPipes2 = [];
    renderPipeAdaptors2 = [];
    extensions.handleByNamedList(ExtensionType.WebGLSystem, systems2);
    extensions.handleByNamedList(ExtensionType.WebGLPipes, renderPipes2);
    extensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors2);
    extensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);
    WebGLRenderer = class extends AbstractRenderer {
      constructor() {
        const systemConfig = {
          type: "webgl2",
          systems: systems2,
          renderPipes: renderPipes2,
          renderPipeAdaptors: renderPipeAdaptors2
        };
        super(systemConfig);
      }
    };
  }
});

// ../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js
var require_events = __commonJS({
  "../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js"(exports, module) {
    "use strict";
    var R2 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R2 && typeof R2.ownKeys === "function") {
      ReflectOwnKeys = R2.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter3() {
      EventEmitter3.init.call(this);
    }
    module.exports = EventEmitter3;
    module.exports.once = once;
    EventEmitter3.EventEmitter = EventEmitter3;
    EventEmitter3.prototype._events = void 0;
    EventEmitter3.prototype._eventsCount = 0;
    EventEmitter3.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter3, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter3.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter3.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter3.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter3.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter3.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m2;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m2 = _getMaxListeners(target);
        if (m2 > 0 && existing.length > m2 && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter3.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter3.prototype.on = EventEmitter3.prototype.addListener;
    EventEmitter3.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter3.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter3.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter3.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter3.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter3.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter3.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter3.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/index.mjs
init_all();

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/app/Application.mjs
init_Extensions();

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs
init_settings();
var supported;
function isWebGLSupported() {
  if (typeof supported === "undefined") {
    supported = function supported2() {
      const contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
      };
      try {
        if (!settings.ADAPTER.getWebGLRenderingContext()) {
          return false;
        }
        const canvas2 = settings.ADAPTER.createCanvas();
        let gl = canvas2.getContext("webgl2", contextOptions);
        const success = !!gl?.getContextAttributes()?.stencil;
        if (gl) {
          const loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success;
      } catch (e) {
        return false;
      }
    }();
  }
  return supported;
}

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs
init_settings();
function isWebGPUSupported() {
  return !!settings.ADAPTER.getNavigator().gpu;
}

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs
var renderPriority = ["webgpu", "webgl", "canvas"];
async function autoDetectRenderer(options) {
  let preferredOrder = [];
  if (options.preference) {
    preferredOrder.push(options.preference);
    renderPriority.forEach((item) => {
      if (item !== options.preference) {
        preferredOrder.push(item);
      }
    });
  } else {
    preferredOrder = renderPriority.slice();
  }
  let RendererClass;
  if (options.manageImports ?? true) {
    await Promise.resolve().then(() => (init_all(), all_exports));
  }
  let finalOptions = {};
  for (let i = 0; i < preferredOrder.length; i++) {
    const rendererType = preferredOrder[i];
    if (rendererType === "webgpu" && isWebGPUSupported()) {
      const { WebGPURenderer: WebGPURenderer2 } = await Promise.resolve().then(() => (init_WebGPURenderer(), WebGPURenderer_exports));
      RendererClass = WebGPURenderer2;
      finalOptions = { ...options, ...options.webgpu };
      break;
    } else if (rendererType === "webgl" && isWebGLSupported()) {
      const { WebGLRenderer: WebGLRenderer2 } = await Promise.resolve().then(() => (init_WebGLRenderer(), WebGLRenderer_exports));
      RendererClass = WebGLRenderer2;
      finalOptions = { ...options, ...options.webgl };
      break;
    } else if (rendererType === "canvas") {
      finalOptions = { ...options };
      break;
    }
  }
  delete finalOptions.webgpu;
  delete finalOptions.webgl;
  const renderer = new RendererClass();
  await renderer.init(finalOptions);
  return renderer;
}

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/app/Application.mjs
init_Container();
var _Application = class {
  constructor() {
    this.stage = new Container();
  }
  /**
   * @param options - The optional application and renderer parameters.
   */
  async init(options) {
    options = {
      ...{
        // forceCanvas: false,
      },
      ...options
    };
    this.renderer = await autoDetectRenderer(options);
    _Application._plugins.forEach((plugin) => {
      plugin.init.call(this, options);
    });
  }
  /** Render the current stage. */
  render() {
    this.renderer.render({ container: this.stage });
  }
  /**
   * Reference to the renderer's canvas element.
   * @member {PIXI.ICanvas}
   * @readonly
   */
  get canvas() {
    return this.renderer.element;
  }
  // TODO: not implemented
  // /**
  //  * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
  //  * @member {PIXI.Rectangle}
  //  * @readonly
  //  */
  // get screen(): Rectangle
  // {
  //     return this.renderer.screen;
  // }
  // TODO: implement destroy
  // /**
  //  * Destroy and don't use after this.
  //  * @param {boolean} [removeView=false] - Automatically remove canvas from DOM.
  //  * @param {object|boolean} [stageOptions] - Options parameter. A boolean will act as if all options
  //  *  have been set to that value
  //  * @param {boolean} [stageOptions.children=false] - if set to true, all the children will have their destroy
  //  *  method called as well. 'stageOptions' will be passed on to those calls.
  //  * @param {boolean} [stageOptions.texture=false] - Only used for child Sprites if stageOptions.children is set
  //  *  to true. Should it destroy the texture of the child sprite
  //  * @param {boolean} [stageOptions.baseTexture=false] - Only used for child Sprites if stageOptions.children is set
  //  *  to true. Should it destroy the base texture of the child sprite
  //  */
  // public destroy(removeView?: boolean, stageOptions?: IDestroyOptions | boolean): void
  // {
  //     // Destroy plugins in the opposite order
  //     // which they were constructed
  //     const plugins = Application._plugins.slice(0);
  //     plugins.reverse();
  //     plugins.forEach((plugin) =>
  //     {
  //         plugin.destroy.call(this);
  //     });
  //     this.stage.destroy(stageOptions);
  //     this.stage = null;
  //     this.renderer.destroy(removeView);
  //     this.renderer = null;
  // }
};
var Application = _Application;
Application._plugins = [];
extensions.handleByList(ExtensionType.Application, Application._plugins);

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/index.mjs
init_init();

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/Assets.mjs
init_Extensions();

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/BackgroundLoader.mjs
var BackgroundLoader = class {
  /**
   * @param loader
   * @param verbose - should the loader log to the console
   */
  constructor(loader, verbose = false) {
    this._loader = loader;
    this._assetList = [];
    this._isLoading = false;
    this._maxConcurrent = 1;
    this.verbose = verbose;
  }
  /**
   * Adds an array of assets to load.
   * @param assetUrls - assets to load
   */
  add(assetUrls) {
    assetUrls.forEach((a) => {
      this._assetList.push(a);
    });
    if (this.verbose)
      console.log("[BackgroundLoader] assets: ", this._assetList);
    if (this._isActive && !this._isLoading) {
      this._next();
    }
  }
  /**
   * Loads the next set of assets. Will try to load as many assets as it can at the same time.
   *
   * The max assets it will try to load at one time will be 4.
   */
  async _next() {
    if (this._assetList.length && this._isActive) {
      this._isLoading = true;
      const toLoad = [];
      const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
      for (let i = 0; i < toLoadAmount; i++) {
        toLoad.push(this._assetList.pop());
      }
      await this._loader.load(toLoad);
      this._isLoading = false;
      this._next();
    }
  }
  /**
   * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.
   * @returns whether the class is active
   */
  get active() {
    return this._isActive;
  }
  set active(value) {
    if (this._isActive === value)
      return;
    this._isActive = value;
    if (value && !this._isLoading) {
      this._next();
    }
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/Assets.mjs
init_Cache();

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/loader/Loader.mjs
init_path();
init_convertToList();

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs
var isSingleItem = (item) => !Array.isArray(item);

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/loader/Loader.mjs
var Loader = class {
  constructor() {
    this._parsers = [];
    this._parsersValidated = false;
    this.parsers = new Proxy(this._parsers, {
      set: (target, key, value) => {
        this._parsersValidated = false;
        target[key] = value;
        return true;
      }
    });
    this.promiseCache = {};
  }
  /** function used for testing */
  reset() {
    this._parsersValidated = false;
    this.promiseCache = {};
  }
  /**
   * Used internally to generate a promise for the asset to be loaded.
   * @param url - The URL to be loaded
   * @param data - any custom additional information relevant to the asset being loaded
   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object
   */
  _getLoadPromiseAndParser(url, data) {
    const result = {
      promise: null,
      parser: null
    };
    result.promise = (async () => {
      let asset = null;
      let parser = null;
      if (data.loadParser) {
        parser = this._parserHash[data.loadParser];
        if (!parser) {
          console.warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url}`);
        }
      }
      if (!parser) {
        for (let i = 0; i < this.parsers.length; i++) {
          const parserX = this.parsers[i];
          if (parserX.load && parserX.test?.(url, data, this)) {
            parser = parserX;
            break;
          }
        }
        if (!parser) {
          console.warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);
          return null;
        }
      }
      asset = await parser.load(url, data, this);
      result.parser = parser;
      for (let i = 0; i < this.parsers.length; i++) {
        const parser2 = this.parsers[i];
        if (parser2.parse) {
          if (parser2.parse && await parser2.testParse?.(asset, data, this)) {
            asset = await parser2.parse(asset, data, this) || asset;
            result.parser = parser2;
          }
        }
      }
      return asset;
    })();
    return result;
  }
  async load(assetsToLoadIn, onProgress) {
    if (!this._parsersValidated) {
      this._validateParsers();
    }
    let count2 = 0;
    const assets = {};
    const singleAsset = isSingleItem(assetsToLoadIn);
    const assetsToLoad = convertToList(assetsToLoadIn, (item) => ({
      alias: [item],
      src: item
    }));
    const total = assetsToLoad.length;
    const promises = assetsToLoad.map(async (asset) => {
      const url = path.toAbsolute(asset.src);
      if (!assets[asset.src]) {
        try {
          if (!this.promiseCache[url]) {
            this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);
          }
          assets[asset.src] = await this.promiseCache[url].promise;
          if (onProgress)
            onProgress(++count2 / total);
        } catch (e) {
          delete this.promiseCache[url];
          delete assets[asset.src];
          throw new Error(`[Loader.load] Failed to load ${url}.
${e}`);
        }
      }
    });
    await Promise.all(promises);
    return singleAsset ? assets[assetsToLoad[0].src] : assets;
  }
  /**
   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.
   * The parser that created the asset, will be the one that unloads it.
   * @example
   * // Single asset:
   * const asset = await Loader.load('cool.png');
   *
   * await Loader.unload('cool.png');
   *
   * console.log(asset.destroyed); // true
   * @param assetsToUnloadIn - urls that you want to unload, or a single one!
   */
  async unload(assetsToUnloadIn) {
    const assetsToUnload = convertToList(assetsToUnloadIn, (item) => ({
      alias: [item],
      src: item
    }));
    const promises = assetsToUnload.map(async (asset) => {
      const url = path.toAbsolute(asset.src);
      const loadPromise = this.promiseCache[url];
      if (loadPromise) {
        const loadedAsset = await loadPromise.promise;
        loadPromise.parser?.unload?.(loadedAsset, asset, this);
        delete this.promiseCache[url];
      }
    });
    await Promise.all(promises);
  }
  /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */
  _validateParsers() {
    this._parsersValidated = true;
    this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {
      if (hash[parser.name]) {
        console.warn(`[Assets] loadParser name conflict "${parser.name}"`);
      }
      return { ...hash, [parser.name]: parser };
    }, {});
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/resolver/Resolver.mjs
init_path();
init_convertToList();

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs
function processX(base, ids, depth, result, tags) {
  const id = ids[depth];
  for (let i = 0; i < id.length; i++) {
    const value = id[i];
    if (depth < ids.length - 1) {
      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);
    } else {
      tags.push(base.replace(result[depth], value));
    }
  }
}
function createStringVariations(string) {
  const regex = /\{(.*?)\}/g;
  const result = string.match(regex);
  const tags = [];
  if (result) {
    const ids = [];
    result.forEach((vars) => {
      const split = vars.substring(1, vars.length - 1).split(",");
      ids.push(split);
    });
    processX(string, ids, 0, result, tags);
  } else {
    tags.push(string);
  }
  return tags;
}

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/resolver/Resolver.mjs
var Resolver = class {
  constructor() {
    this._defaultBundleIdentifierOptions = {
      connector: "-",
      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
    };
    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
    this._assetMap = {};
    this._preferredOrder = [];
    this._parsers = [];
    this._resolverHash = {};
    this._bundles = {};
  }
  /**
   * Override how the resolver deals with generating bundle ids.
   * must be called before any bundles are added
   * @param bundleIdentifier - the bundle identifier options
   */
  setBundleIdentifier(bundleIdentifier) {
    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
    if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
    }
  }
  /**
   * Let the resolver know which assets you prefer to use when resolving assets.
   * Multiple prefer user defined rules can be added.
   * @example
   * resolver.prefer({
   *     // first look for something with the correct format, and then then correct resolution
   *     priority: ['format', 'resolution'],
   *     params:{
   *         format:'webp', // prefer webp images
   *         resolution: 2, // prefer a resolution of 2
   *     }
   * })
   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
   * resolver.resolveUrl('foo') // => 'bar@2x.webp'
   * @param preferOrders - the prefer options
   */
  prefer(...preferOrders) {
    preferOrders.forEach((prefer) => {
      this._preferredOrder.push(prefer);
      if (!prefer.priority) {
        prefer.priority = Object.keys(prefer.params);
      }
    });
    this._resolverHash = {};
  }
  /**
   * Set the base path to prepend to all urls when resolving
   * @example
   * resolver.basePath = 'https://home.com/';
   * resolver.add('foo', 'bar.ong');
   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
   * @param basePath - the base path to use
   */
  set basePath(basePath) {
    this._basePath = basePath;
  }
  get basePath() {
    return this._basePath;
  }
  /**
   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
   * default value for browsers is `window.location.origin`
   * @example
   * // Application hosted on https://home.com/some-path/index.html
   * resolver.basePath = 'https://home.com/some-path/';
   * resolver.rootPath = 'https://home.com/';
   * resolver.add('foo', '/bar.png');
   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
   * @param rootPath - the root path to use
   */
  set rootPath(rootPath) {
    this._rootPath = rootPath;
  }
  get rootPath() {
    return this._rootPath;
  }
  /**
   * All the active URL parsers that help the parser to extract information and create
   * an asset object-based on parsing the URL itself.
   *
   * Can be added using the extensions API
   * @example
   * resolver.add('foo', [
   *     {
   *         resolution: 2,
   *         format: 'png',
   *         src: 'image@2x.png',
   *     },
   *     {
   *         resolution:1,
   *         format:'png',
   *         src: 'image.png',
   *     },
   * ]);
   *
   * // With a url parser the information such as resolution and file format could extracted from the url itself:
   * extensions.add({
   *     extension: ExtensionType.ResolveParser,
   *     test: loadTextures.test, // test if url ends in an image
   *     parse: (value: string) =>
   *     ({
   *         resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
   *         format: value.split('.').pop(),
   *         src: value,
   *     }),
   * });
   *
   * // Now resolution and format can be extracted from the url
   * resolver.add('foo', [
   *     'image@2x.png',
   *     'image.png',
   * ]);
   */
  get parsers() {
    return this._parsers;
  }
  /** Used for testing, this resets the resolver to its initial state */
  reset() {
    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
    this._assetMap = {};
    this._preferredOrder = [];
    this._resolverHash = {};
    this._rootPath = null;
    this._basePath = null;
    this._manifest = null;
    this._bundles = {};
    this._defaultSearchParams = null;
  }
  /**
   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.
   * @param searchParams - the default url parameters to append when resolving urls
   */
  setDefaultSearchParams(searchParams) {
    if (typeof searchParams === "string") {
      this._defaultSearchParams = searchParams;
    } else {
      const queryValues = searchParams;
      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
    }
  }
  /**
   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
   * generally a manifest would be built using a tool.
   * @param manifest - the manifest to add to the resolver
   */
  addManifest(manifest) {
    if (this._manifest) {
      console.warn("[Resolver] Manifest already exists, this will be overwritten");
    }
    this._manifest = manifest;
    manifest.bundles.forEach((bundle) => {
      this.addBundle(bundle.name, bundle.assets);
    });
  }
  /**
   * This adds a bundle of assets in one go so that you can resolve them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * resolver.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const resolvedAssets = await resolver.resolveBundle('animals');
   * @param bundleId - The id of the bundle to add
   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
   */
  addBundle(bundleId, assets) {
    const assetNames = [];
    if (Array.isArray(assets)) {
      assets.forEach((asset) => {
        const srcs = asset.src ?? asset.srcs;
        const aliases = asset.alias ?? asset.name;
        let ids;
        if (typeof aliases === "string") {
          const bundleAssetId = this._createBundleAssetId(bundleId, aliases);
          assetNames.push(bundleAssetId);
          ids = [aliases, bundleAssetId];
        } else {
          const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));
          assetNames.push(...bundleIds);
          ids = [...aliases, ...bundleIds];
        }
        this.add({
          ...asset,
          ...{
            alias: ids,
            src: srcs
          }
        });
      });
    } else {
      Object.keys(assets).forEach((key) => {
        const aliases = [key, this._createBundleAssetId(bundleId, key)];
        if (typeof assets[key] === "string") {
          this.add({
            alias: aliases,
            src: assets[key]
          });
        } else if (Array.isArray(assets[key])) {
          this.add({
            alias: aliases,
            src: assets[key]
          });
        } else {
          const asset = assets[key];
          const assetSrc = asset.src ?? asset.srcs;
          this.add({
            ...asset,
            ...{
              alias: aliases,
              src: Array.isArray(assetSrc) ? assetSrc : [assetSrc]
            }
          });
        }
        assetNames.push(...aliases);
      });
    }
    this._bundles[bundleId] = assetNames;
  }
  /**
   * Tells the resolver what keys are associated with witch asset.
   * The most important thing the resolver does
   * @example
   * // Single key, single asset:
   * resolver.add({alias: 'foo', src: 'bar.png');
   * resolver.resolveUrl('foo') // => 'bar.png'
   *
   * // Multiple keys, single asset:
   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});
   * resolver.resolveUrl('foo') // => 'bar.png'
   * resolver.resolveUrl('boo') // => 'bar.png'
   *
   * // Multiple keys, multiple assets:
   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});
   * resolver.resolveUrl('foo') // => 'bar.png'
   *
   * // Add custom data attached to the resolver
   * Resolver.add({
   *     alias: 'bunnyBooBooSmooth',
   *     src: 'bunny{png,webp}',
   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options
   * });
   *
   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }
   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver
   */
  add(aliases) {
    const assets = [];
    if (Array.isArray(aliases)) {
      assets.push(...aliases);
    } else {
      assets.push(aliases);
    }
    const keyCheck = (key) => {
      if (this.hasKey(key)) {
        console.warn(`[Resolver] already has key: ${key} overwriting`);
      }
    };
    const assetArray = convertToList(assets);
    assetArray.forEach((asset) => {
      const { alias, name, src, srcs } = asset;
      let { data, format: format2, loadParser } = asset;
      const srcsToUse = convertToList(src || srcs).map((src2) => {
        if (typeof src2 === "string") {
          return createStringVariations(src2);
        }
        return Array.isArray(src2) ? src2 : [src2];
      });
      const aliasesToUse = convertToList(alias || name);
      Array.isArray(alias) ? alias.forEach(keyCheck) : keyCheck(alias);
      const resolvedAssets = [];
      srcsToUse.forEach((srcs2) => {
        srcs2.forEach((src2) => {
          let formattedAsset = {};
          if (typeof src2 !== "object") {
            formattedAsset.src = src2;
            for (let i = 0; i < this._parsers.length; i++) {
              const parser = this._parsers[i];
              if (parser.test(src2)) {
                formattedAsset = parser.parse(src2);
                break;
              }
            }
          } else {
            data = src2.data ?? data;
            format2 = src2.format ?? format2;
            loadParser = src2.loadParser ?? loadParser;
            formattedAsset = {
              ...formattedAsset,
              ...src2
            };
          }
          formattedAsset = this.buildResolvedAsset(formattedAsset, {
            aliases: aliasesToUse,
            data,
            format: format2,
            loadParser
          });
          resolvedAssets.push(formattedAsset);
        });
      });
      aliasesToUse.forEach((alias2) => {
        this._assetMap[alias2] = resolvedAssets;
      });
    });
  }
  // TODO: this needs an overload like load did in Assets
  /**
   * If the resolver has had a manifest set via setManifest, this will return the assets urls for
   * a given bundleId or bundleIds.
   * @example
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     name: 'background',
   *                     srcs: 'sunset.png',
   *                 },
   *                 {
   *                     name: 'bar',
   *                     srcs: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     name: 'character',
   *                     srcs: 'robot.png',
   *                 },
   *                 {
   *                     name: 'enemy',
   *                     srcs: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * resolver.setManifest(manifest);
   * const resolved = resolver.resolveBundle('load-screen');
   * @param bundleIds - The bundle ids to resolve
   * @returns All the bundles assets or a hash of assets for each bundle specified
   */
  resolveBundle(bundleIds) {
    const singleAsset = isSingleItem(bundleIds);
    bundleIds = convertToList(bundleIds);
    const out2 = {};
    bundleIds.forEach((bundleId) => {
      const assetNames = this._bundles[bundleId];
      if (assetNames) {
        const results = this.resolve(assetNames);
        const assets = {};
        for (const key in results) {
          const asset = results[key];
          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
        }
        out2[bundleId] = assets;
      }
    });
    return singleAsset ? out2[bundleIds[0]] : out2;
  }
  /**
   * Does exactly what resolve does, but returns just the URL rather than the whole asset object
   * @param key - The key or keys to resolve
   * @returns - The URLs associated with the key(s)
   */
  resolveUrl(key) {
    const result = this.resolve(key);
    if (typeof key !== "string") {
      const out2 = {};
      for (const i in result) {
        out2[i] = result[i].src;
      }
      return out2;
    }
    return result.src;
  }
  resolve(keys) {
    const singleAsset = isSingleItem(keys);
    keys = convertToList(keys);
    const result = {};
    keys.forEach((key) => {
      if (!this._resolverHash[key]) {
        if (this._assetMap[key]) {
          let assets = this._assetMap[key];
          const bestAsset = assets[0];
          const preferredOrder = this._getPreferredOrder(assets);
          preferredOrder?.priority.forEach((priorityKey) => {
            preferredOrder.params[priorityKey].forEach((value) => {
              const filteredAssets = assets.filter((asset) => {
                if (asset[priorityKey]) {
                  return asset[priorityKey] === value;
                }
                return false;
              });
              if (filteredAssets.length) {
                assets = filteredAssets;
              }
            });
          });
          this._resolverHash[key] = assets[0] ?? bestAsset;
        } else {
          this._resolverHash[key] = this.buildResolvedAsset({
            alias: [key],
            src: key
          }, {});
        }
      }
      result[key] = this._resolverHash[key];
    });
    return singleAsset ? result[keys[0]] : result;
  }
  /**
   * Checks if an asset with a given key exists in the resolver
   * @param key - The key of the asset
   */
  hasKey(key) {
    return !!this._assetMap[key];
  }
  /**
   * Checks if a bundle with the given key exists in the resolver
   * @param key - The key of the bundle
   */
  hasBundle(key) {
    return !!this._bundles[key];
  }
  /**
   * Internal function for figuring out what prefer criteria an asset should use.
   * @param assets
   */
  _getPreferredOrder(assets) {
    for (let i = 0; i < assets.length; i++) {
      const asset = assets[0];
      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
      if (preferred) {
        return preferred;
      }
    }
    return this._preferredOrder[0];
  }
  /**
   * Appends the default url parameters to the url
   * @param url - The url to append the default parameters to
   * @returns - The url with the default parameters appended
   */
  _appendDefaultSearchParams(url) {
    if (!this._defaultSearchParams)
      return url;
    const paramConnector = /\?/.test(url) ? "&" : "?";
    return `${url}${paramConnector}${this._defaultSearchParams}`;
  }
  buildResolvedAsset(formattedAsset, data) {
    const { aliases, data: assetData, loadParser, format: format2 } = data;
    if (this._basePath || this._rootPath) {
      formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
    }
    formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];
    formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
    formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };
    formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;
    formattedAsset.format = format2 ?? formattedAsset.src.split(".").pop();
    formattedAsset.srcs = formattedAsset.src;
    formattedAsset.name = formattedAsset.alias;
    return formattedAsset;
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/assets/Assets.mjs
init_convertToList();
var AssetsClass = class {
  constructor() {
    this._detections = [];
    this._initialized = false;
    this.resolver = new Resolver();
    this.loader = new Loader();
    this.cache = Cache;
    this._backgroundLoader = new BackgroundLoader(this.loader);
    this._backgroundLoader.active = true;
    this.reset();
  }
  /**
   * Best practice is to call this function before any loading commences
   * Initiating is the best time to add any customization to the way things are loaded.
   *
   * you do not need to call this for the Asset class to work, only if you want to set any initial properties
   * @param options - options to initialize the Asset manager with
   */
  async init(options = {}) {
    if (this._initialized) {
      console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
      return;
    }
    this._initialized = true;
    if (options.defaultSearchParams) {
      this.resolver.setDefaultSearchParams(options.defaultSearchParams);
    }
    if (options.basePath) {
      this.resolver.basePath = options.basePath;
    }
    if (options.bundleIdentifier) {
      this.resolver.setBundleIdentifier(options.bundleIdentifier);
    }
    if (options.manifest) {
      let manifest = options.manifest;
      if (typeof manifest === "string") {
        manifest = await this.load(manifest);
      }
      this.resolver.addManifest(manifest);
    }
    const resolutionPref = options.texturePreference?.resolution ?? 1;
    const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;
    let formats = [];
    if (options.texturePreference?.format) {
      const formatPref = options.texturePreference?.format;
      formats = typeof formatPref === "string" ? [formatPref] : formatPref;
      for (const detection of this._detections) {
        if (!await detection.test()) {
          formats = await detection.remove(formats);
        }
      }
    } else {
      for (const detection of this._detections) {
        if (await detection.test()) {
          formats = await detection.add(formats);
        }
      }
    }
    this.resolver.prefer({
      params: {
        format: formats,
        resolution
      }
    });
    if (options.preferences) {
      this.setPreferences(options.preferences);
    }
  }
  /**
   * Allows you to specify how to resolve any assets load requests.
   * There are a few ways to add things here as shown below:
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Simple
   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});
   * const bunny = await Assets.load('bunnyBooBoo');
   *
   * // Multiple keys:
   * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});
   *
   * const bunny = await Assets.load('burger');
   * const bunny2 = await Assets.load('chicken');
   *
   * // passing options to to the object
   * Assets.add({
   *     alias: 'bunnyBooBooSmooth',
   *     src: 'bunny{png,webp}',
   *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options
   * });
   *
   * // Multiple assets
   *
   * // The following all do the same thing:
   *
   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny{png,webp}'});
   *
   * Assets.add({
   *     alias: 'bunnyBooBoo',
   *     src: [
   *         'bunny.png',
   *         'bunny.webp',
   *    ],
   * });
   *
   * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available
   * @param assets - the unresolved assets to add to the resolver
   */
  add(assets) {
    this.resolver.add(assets);
  }
  async load(urls, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    const singleAsset = isSingleItem(urls);
    const urlArray = convertToList(urls).map((url) => {
      if (typeof url !== "string") {
        this.add(url);
        const srcs = url.src || url.srcs;
        const aliases = url.alias || url.name;
        if (aliases && Array.isArray(aliases))
          return aliases[0];
        if (srcs && Array.isArray(srcs))
          return srcs[0];
        return aliases || srcs;
      }
      if (!this.resolver.hasKey(url))
        this.add({ alias: url, src: url });
      return url;
    });
    const resolveResults = this.resolver.resolve(urlArray);
    const out2 = await this._mapLoadToResolve(resolveResults, onProgress);
    return singleAsset ? out2[urlArray[0]] : out2;
  }
  /**
   * This adds a bundle of assets in one go so that you can load them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const assets = await Assets.loadBundle('animals');
   * @param bundleId - the id of the bundle to add
   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key
   */
  addBundle(bundleId, assets) {
    this.resolver.addBundle(bundleId, assets);
  }
  /**
   * Bundles are a way to load multiple assets at once.
   * If a manifest has been provided to the init function then you can load a bundle, or bundles.
   * you can also add bundles via `addBundle`
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     name: 'background',
   *                     srcs: 'sunset.png',
   *                 },
   *                 {
   *                     name: 'bar',
   *                     srcs: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     name: 'character',
   *                     srcs: 'robot.png',
   *                 },
   *                 {
   *                     name: 'enemy',
   *                     srcs: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * await Asset.init({ manifest });
   *
   * // Load a bundle...
   * loadScreenAssets = await Assets.loadBundle('load-screen');
   * // Load another bundle...
   * gameScreenAssets = await Assets.loadBundle('game-screen');
   * @param bundleIds - the bundle id or ids to load
   * @param onProgress - Optional function that is called when progress on asset loading is made.
   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)
   * of the assets loaded. Do not use this function to detect when assets are complete and available,
   * instead use the Promise returned by this function.
   * @returns all the bundles assets or a hash of assets for each bundle specified
   */
  async loadBundle(bundleIds, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    let singleAsset = false;
    if (typeof bundleIds === "string") {
      singleAsset = true;
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const out2 = {};
    const keys = Object.keys(resolveResults);
    let count2 = 0;
    let total = 0;
    const _onProgress = () => {
      onProgress?.(++count2 / total);
    };
    const promises = keys.map((bundleId) => {
      const resolveResult = resolveResults[bundleId];
      total += Object.keys(resolveResult).length;
      return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
        out2[bundleId] = resolveResult2;
      });
    });
    await Promise.all(promises);
    return singleAsset ? out2[bundleIds[0]] : out2;
  }
  /**
   * Initiate a background load of some assets. It will passively begin to load these assets in the background.
   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately
   *
   * An example of this might be that you would background load game assets after your inital load.
   * then when you got to actually load your game screen assets when a player goes to the game - the loading
   * would already have stared or may even be complete, saving you having to show an interim load bar.
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.backgroundLoad('bunny.png');
   *
   * // later on in your app...
   * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!
   * @param urls - the url / urls you want to background load
   */
  async backgroundLoad(urls) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof urls === "string") {
      urls = [urls];
    }
    const resolveResults = this.resolver.resolve(urls);
    this._backgroundLoader.add(Object.values(resolveResults));
  }
  /**
   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.
   * this can only be used if the loader has been initiated with a manifest
   * @example
   * import { Assets } from 'pixi.js';
   *
   * await Assets.init({
   *     manifest: {
   *         bundles: [
   *             {
   *                 name: 'load-screen',
   *                 assets: [...],
   *             },
   *             ...
   *         ],
   *     },
   * });
   *
   * Assets.backgroundLoadBundle('load-screen');
   *
   * // Later on in your app...
   * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!
   * @param bundleIds - the bundleId / bundleIds you want to background load
   */
  async backgroundLoadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof bundleIds === "string") {
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    Object.values(resolveResults).forEach((resolveResult) => {
      this._backgroundLoader.add(Object.values(resolveResult));
    });
  }
  /**
   * Only intended for development purposes.
   * This will wipe the resolver and caches.
   * You will need to reinitialize the Asset
   */
  reset() {
    this.resolver.reset();
    this.loader.reset();
    this.cache.reset();
    this._initialized = false;
  }
  get(keys) {
    if (typeof keys === "string") {
      return Cache.get(keys);
    }
    const assets = {};
    for (let i = 0; i < keys.length; i++) {
      assets[i] = Cache.get(keys[i]);
    }
    return assets;
  }
  /**
   * helper function to map resolved assets back to loaded assets
   * @param resolveResults - the resolve results from the resolver
   * @param onProgress - the progress callback
   */
  async _mapLoadToResolve(resolveResults, onProgress) {
    const resolveArray = Object.values(resolveResults);
    const resolveKeys = Object.keys(resolveResults);
    this._backgroundLoader.active = false;
    const loadedAssets3 = await this.loader.load(resolveArray, onProgress);
    this._backgroundLoader.active = true;
    const out2 = {};
    resolveArray.forEach((resolveResult, i) => {
      const asset = loadedAssets3[resolveResult.src];
      const keys = [resolveResult.src];
      if (resolveResult.alias) {
        keys.push(...resolveResult.alias);
      }
      out2[resolveKeys[i]] = asset;
      Cache.set(keys, asset);
    });
    return out2;
  }
  /**
   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function
   * this will make sure to destroy any assets and release them from memory.
   * Once unloaded, you will need to load the asset again.
   *
   * Use this to help manage assets if you find that you have a large app and you want to free up memory.
   *
   * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,
   * Pixi won't break but you will end up with missing assets. Not a good look for the user!
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Load a URL:
   * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture
   *
   * await Assets.unload('http://some.url.com/image.png')
   *
   * // myImageTexture will be destroyed now.
   *
   * // Unload multiple assets:
   * const textures = await Assets.unload(['thumper', 'chicko']);
   * @param urls - the urls to unload
   */
  async unload(urls) {
    if (!this._initialized) {
      await this.init();
    }
    const urlArray = convertToList(urls).map((url) => typeof url !== "string" ? url.src : url);
    const resolveResults = this.resolver.resolve(urlArray);
    await this._unloadFromResolved(resolveResults);
  }
  /**
   * Bundles are a way to manage multiple assets at once.
   * this will unload all files in a bundle.
   *
   * once a bundle has been unloaded, you need to load it again to have access to the assets.
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.addBundle({
   *     'thumper': 'http://some.url.com/thumper.png',
   * })
   *
   * const assets = await Assets.loadBundle('thumper');
   *
   * // Now to unload...
   *
   * await Assets.unloadBundle('thumper');
   *
   * // All assets in the assets object will now have been destroyed and purged from the cache
   * @param bundleIds - the bundle id or ids to unload
   */
  async unloadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    bundleIds = convertToList(bundleIds);
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
    await Promise.all(promises);
  }
  async _unloadFromResolved(resolveResult) {
    const resolveArray = Object.values(resolveResult);
    resolveArray.forEach((resolveResult2) => {
      Cache.remove(resolveResult2.src);
    });
    await this.loader.unload(resolveArray);
  }
  /** All the detection parsers currently added to the Assets class. */
  get detections() {
    return this._detections;
  }
  /**
   * General setter for preferences. This is a helper function to set preferences on all parsers.
   * @param preferences - the preferences to set
   */
  setPreferences(preferences) {
    this.loader.parsers.forEach((parser) => {
      if (!parser.config)
        return;
      Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {
        parser.config[key] = preferences[key];
      });
    });
  }
};
var Assets = new AssetsClass();
extensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/index.mjs
init_init2();
init_init3();
init_Point();
init_Rectangle();

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/mesh-extras/NineSliceGeometry.mjs
init_Matrix();

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/mesh-extras/PlaneGeometry.mjs
init_MeshGeometry();
var _PlaneGeometry = class extends MeshGeometry {
  /**
   * @param options - Options to be applied to plane geometry
   * @param options.width - Width of plane
   * @param options.height - Height of plane
   * @param options.verticesX - Number of vertices on x-axis
   * @param options.verticesY - Number of vertices on y-axis
   */
  constructor(options = {}) {
    super({});
    this.build(options);
  }
  /**
   * Refreshes plane coordinates
   * @param options
   */
  build(options) {
    options = { ..._PlaneGeometry.defaultOptions, ...options };
    this.verticesX = this.verticesX ?? options.verticesX;
    this.verticesY = this.verticesY ?? options.verticesY;
    this.width = this.width ?? options.width;
    this.height = this.height ?? options.height;
    const total = this.verticesX * this.verticesY;
    const verts = [];
    const uvs = [];
    const indices = [];
    const verticesX = this.verticesX - 1;
    const verticesY = this.verticesY - 1;
    const sizeX = this.width / verticesX;
    const sizeY = this.height / verticesY;
    for (let i = 0; i < total; i++) {
      const x2 = i % this.verticesX;
      const y = i / this.verticesX | 0;
      verts.push(x2 * sizeX, y * sizeY);
      uvs.push(x2 / verticesX, y / verticesY);
    }
    const totalSub = verticesX * verticesY;
    for (let i = 0; i < totalSub; i++) {
      const xpos = i % verticesX;
      const ypos = i / verticesX | 0;
      const value = ypos * this.verticesX + xpos;
      const value2 = ypos * this.verticesX + xpos + 1;
      const value3 = (ypos + 1) * this.verticesX + xpos;
      const value4 = (ypos + 1) * this.verticesX + xpos + 1;
      indices.push(
        value,
        value2,
        value3,
        value2,
        value4,
        value3
      );
    }
    this.buffers[0].data = new Float32Array(verts);
    this.buffers[1].data = new Float32Array(uvs);
    this.indexBuffer.data = new Uint32Array(indices);
    this.buffers[0].update();
    this.buffers[1].update();
    this.indexBuffer.update();
  }
};
var PlaneGeometry = _PlaneGeometry;
PlaneGeometry.defaultOptions = {
  width: 100,
  height: 100,
  verticesX: 10,
  verticesY: 10
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/mesh-extras/NineSliceGeometry.mjs
var _NineSliceGeometry = class extends PlaneGeometry {
  constructor(options) {
    options = { ..._NineSliceGeometry.defaultOptions, ...options };
    super({
      width: options.width,
      height: options.height,
      verticesX: 4,
      verticesY: 4
    });
    this._textureMatrix = new Matrix();
    this.update(options);
  }
  update(options) {
    this.updateUvs(options);
    this.updatePositions(options);
  }
  updatePositions(options) {
    this.width = options.width ?? this.width;
    this.height = options.height ?? this.height;
    this._leftWidth = options.leftWidth ?? this._leftWidth;
    this._rightWidth = options.rightWidth ?? this._rightWidth;
    this._topHeight = options.topHeight ?? this._topHeight;
    this._bottomHeight = options.bottomHeight ?? this._bottomHeight;
    const positions = this.positions;
    const w = this._leftWidth + this._rightWidth;
    const scaleW = this.width > w ? 1 : this.width / w;
    const h = this._topHeight + this._bottomHeight;
    const scaleH = this.height > h ? 1 : this.height / h;
    const scale3 = Math.min(scaleW, scaleH);
    positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale3;
    positions[17] = positions[19] = positions[21] = positions[23] = this.height - this._bottomHeight * scale3;
    positions[25] = positions[27] = positions[29] = positions[31] = this.height;
    positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale3;
    positions[4] = positions[12] = positions[20] = positions[28] = this.width - this._rightWidth * scale3;
    positions[6] = positions[14] = positions[22] = positions[30] = this.width;
    this.getBuffer("aPosition").update();
  }
  updateUvs(options) {
    this._originalWidth = options.originalWidth ?? this._originalWidth;
    this._originalHeight = options.originalHeight ?? this._originalHeight;
    this._leftWidth = options.leftWidth ?? this._leftWidth;
    this._rightWidth = options.rightWidth ?? this._rightWidth;
    this._topHeight = options.topHeight ?? this._topHeight;
    this._bottomHeight = options.bottomHeight ?? this._bottomHeight;
    if (options.textureMatrix) {
      this._textureMatrix.copyFrom(options.textureMatrix);
    }
    const textureMatrix = this._textureMatrix;
    const uvs = this.uvs;
    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
    const _uvw = 1 / this._originalWidth;
    const _uvh = 1 / this._originalHeight;
    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
    multiplyUvs(textureMatrix, uvs);
    this.getBuffer("aUV").update();
  }
};
var NineSliceGeometry = _NineSliceGeometry;
NineSliceGeometry.defaultOptions = {
  width: 100,
  height: 100,
  leftWidth: 10,
  topHeight: 10,
  rightWidth: 10,
  bottomHeight: 10,
  originalWidth: 100,
  originalHeight: 100
};
function multiplyUvs(matrix, uvs, out2) {
  out2 ?? (out2 = uvs);
  const a = matrix.a;
  const b = matrix.b;
  const c = matrix.c;
  const d2 = matrix.d;
  const tx = matrix.tx;
  const ty = matrix.ty;
  for (let i = 0; i < uvs.length; i += 2) {
    const x2 = uvs[i];
    const y = uvs[i + 1];
    out2[i] = x2 * a + y * c + tx;
    out2[i + 1] = x2 * b + y * d2 + ty;
  }
  return out2;
}

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/mesh-extras/NineSlicePlane.mjs
init_MeshView();
init_Texture();
init_Container();
init_deprecation();
var _NineSliceSprite = class extends Container {
  /**
   * @param options - Options to use
   * @param options.texture - The texture to use on the NineSlicePlane.
   * @param options.leftWidth - Width of the left vertical bar (A)
   * @param options.topHeight - Height of the top horizontal bar (C)
   * @param options.rightWidth - Width of the right vertical bar (B)
   * @param options.bottomHeight - Height of the bottom horizontal bar (D)
   * @param options.width - Width of the NineSlicePlane,
   * setting this will actually modify the vertices and not the UV's of this plane.
   * @param options.height - Height of the NineSlicePlane,
   * setting this will actually modify the vertices and not UV's of this plane.
   */
  constructor(options) {
    if (options instanceof Texture) {
      options = { texture: options };
    }
    options = { ..._NineSliceSprite.defaultOptions, ...options };
    const texture = options.texture;
    const nineSliceGeometry = new NineSliceGeometry({
      width: texture.width,
      height: texture.height,
      originalWidth: texture.width,
      originalHeight: texture.height,
      leftWidth: options.leftWidth,
      topHeight: options.topHeight,
      rightWidth: options.rightWidth,
      bottomHeight: options.bottomHeight,
      textureMatrix: texture.textureMatrix.mapCoord
    });
    super({
      view: new MeshView({
        geometry: nineSliceGeometry,
        texture
      }),
      label: "NineSlicePlane",
      ...options
    });
  }
  // /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
  get width() {
    return this.view.geometry.width;
  }
  set width(value) {
    this.view.geometry.updatePositions({
      width: value
    });
  }
  get height() {
    return this.view.geometry.height;
  }
  set height(value) {
    this.view.geometry.updatePositions({
      height: value
    });
  }
  get leftWidth() {
    return this.view.geometry._leftWidth;
  }
  set leftWidth(value) {
    this.view.geometry.updateUvs({
      leftWidth: value
    });
  }
  get topHeight() {
    return this.view.geometry._topHeight;
  }
  set topHeight(value) {
    this.view.geometry.updateUvs({
      topHeight: value
    });
  }
  get rightWidth() {
    return this.view.geometry._rightWidth;
  }
  set rightWidth(value) {
    this.view.geometry.updateUvs({
      rightWidth: value
    });
  }
  get bottomHeight() {
    return this.view.geometry._bottomHeight;
  }
  set bottomHeight(value) {
    this.view.geometry.updateUvs({
      bottomHeight: value
    });
  }
  get texture() {
    return this.view.texture;
  }
  set texture(value) {
    if (value === this.view.texture)
      return;
    this.view.geometry.updateUvs({
      originalWidth: value.width,
      originalHeight: value.height,
      textureMatrix: value.textureMatrix.mapCoord
    });
    this.view.texture = value;
  }
};
var NineSliceSprite = _NineSliceSprite;
NineSliceSprite.defaultOptions = {
  texture: Texture.EMPTY,
  leftWidth: 10,
  topHeight: 10,
  rightWidth: 10,
  bottomHeight: 10
};
var NineSlicePlane = class extends NineSliceSprite {
  constructor(options) {
    deprecation("v8", "NineSlicePlane is deprecated. Use NineSliceSprite instead.");
    super(options);
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/alpha/AlphaFilter.mjs
init_GpuProgram();
init_UniformGroup();
init_Filter();

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/alpha/alpha.mjs
var source2 = "struct GlobalUniforms {\n  projectionMatrix:mat3x3<f32>,\n  worldTransformMatrix:mat3x3<f32>,\n  worldAlpha: f32\n}\n\nstruct GlobalFilterUniforms {\n  inputSize:vec4<f32>,\n  inputPixel:vec4<f32>,\n  inputClamp:vec4<f32>,\n  outputFrame:vec4<f32>,\n  backgroundFrame:vec4<f32>,\n  globalFrame:vec4<f32>,\n};\n\nstruct AlphaUniforms {\n  uAlpha:f32,\n};\n\n@group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n\n@group(1) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(1) @binding(1) var iTexture: texture_2d<f32>;\n@group(1) @binding(2) var iSampler : sampler;\n\n@group(2) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * max(gfu.outputFrame.zw, vec2(0.)) + gfu.outputFrame.xy;\n\n    return vec4((globalUniforms.projectionMatrix * globalUniforms.worldTransformMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);\n}\n\nfn filterBackgroundTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * gfu.backgroundFrame.zw;\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.globalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n) -> @location(0) vec4<f32> {\n  return textureSample(iTexture, iSampler, uv) * alphaUniforms.uAlpha;\n}";

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/filters/alpha/AlphaFilter.mjs
var _AlphaFilter = class extends Filter {
  constructor(options) {
    options = { ..._AlphaFilter.DEFAULT_OPTIONS, ...options };
    const gpuProgram = new GpuProgram({
      vertex: {
        source: source2,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source2,
        entryPoint: "mainFragment"
      }
    });
    const filterUniforms = new UniformGroup({
      uAlpha: { value: options.alpha, type: "f32" }
    });
    super({
      gpuProgram,
      resources: {
        filterUniforms
      }
    });
  }
  /**
   * Coefficient for alpha multiplication
   * @default 1
   */
  get alpha() {
    return this.resources.filterUniforms.uniforms.uAlpha;
  }
  set alpha(value) {
    this.resources.filterUniforms.uniforms.uAlpha = value;
  }
};
var AlphaFilter = _AlphaFilter;
AlphaFilter.DEFAULT_OPTIONS = {
  alpha: 1
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/graphics/shared/Graphics.mjs
init_Container();
init_GraphicsContext();
init_GraphicsView();
var Graphics = class extends Container {
  constructor(options) {
    if (options instanceof GraphicsContext) {
      options = { context: options };
    }
    super({
      view: new GraphicsView(options?.context),
      label: "Graphics",
      ...options
    });
  }
  get context() {
    return this.view.context;
  }
  set context(context) {
    this.view.context = context;
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/index.mjs
init_init5();
init_Container();
init_Sprite();

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/Text.mjs
init_Container();

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/TextView.mjs
init_Cache();
init_ObservablePoint();
init_View();
init_BitmapFontManager();
init_CanvasTextMetrics();
init_TextStyle();
var uid3 = 0;
var map = {
  canvas: "text",
  html: "text",
  bitmap: "bitmapText"
};
var _TextView = class {
  constructor(options) {
    this.uid = uid3++;
    this.batched = true;
    this.type = "text";
    this.owner = emptyViewObserver;
    this._bounds = [0, 1, 0, 0];
    this.boundsDirty = true;
    this._autoResolution = _TextView.defaultAutoResolution;
    this._resolution = _TextView.defaultResolution;
    this.didUpdate = true;
    this.text = options.text ?? "";
    this._style = options.style instanceof TextStyle ? options.style : new TextStyle(options.style);
    const renderMode = options.renderMode ?? this.detectRenderType(this._style);
    this.type = map[renderMode];
    this.anchor = new ObservablePoint(this, 0, 0);
    this._resolution = options.resolution ?? _TextView.defaultResolution;
  }
  set text(value) {
    value = value.toString();
    if (this._text === value)
      return;
    this._text = value;
    this.onUpdate();
  }
  get text() {
    return this._text;
  }
  get style() {
    return this._style;
  }
  set style(style) {
    style = style || {};
    this._style?.off("update", this.onUpdate, this);
    if (style instanceof TextStyle) {
      this._style = style;
    } else {
      this._style = new TextStyle(style);
    }
    this._style.on("update", this.onUpdate, this);
    this.onUpdate();
  }
  set resolution(value) {
    this._resolution = value;
  }
  get resolution() {
    return this._resolution;
  }
  get bounds() {
    if (this.boundsDirty) {
      this.updateBounds();
      this.boundsDirty = false;
    }
    return this._bounds;
  }
  updateBounds() {
    const bounds = this._bounds;
    if (this.type === "bitmapText") {
      const bitmapMeasurement = BitmapFontManager.measureText(this.text, this._style);
      const scale3 = bitmapMeasurement.scale;
      const offset = bitmapMeasurement.offsetY * scale3;
      bounds[0] = 0;
      bounds[1] = offset;
      bounds[2] = bitmapMeasurement.width * scale3;
      bounds[3] = bitmapMeasurement.height * scale3 + offset;
    } else {
      const canvasMeasurement = CanvasTextMetrics.measureText(this.text, this._style);
      bounds[0] = 0;
      bounds[1] = 0;
      bounds[2] = canvasMeasurement.width;
      bounds[3] = canvasMeasurement.height;
    }
  }
  addBounds(bounds) {
    const _bounds = this.bounds;
    bounds.addFrame(
      _bounds[0],
      _bounds[1],
      _bounds[2],
      _bounds[3]
    );
  }
  /**
   * @internal
   */
  onUpdate() {
    this.didUpdate = true;
    this.boundsDirty = true;
    this.owner.onViewUpdate();
  }
  _getKey() {
    return `${this.text}:${this._style.styleKey}`;
  }
  containsPoint(point) {
    const width = this.bounds[2];
    const height = this.bounds[3];
    const x1 = -width * this.anchor.x;
    let y1 = 0;
    if (point.x >= x1 && point.x < x1 + width) {
      y1 = -height * this.anchor.y;
      if (point.y >= y1 && point.y < y1 + height)
        return true;
    }
    return false;
  }
  detectRenderType(style) {
    return Cache.has(style.fontFamily) ? "bitmap" : "canvas";
  }
  /**
   * Destroys this text renderable and optionally its style texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style
   */
  destroy(options = false) {
    this.owner = null;
    this._bounds = null;
    this.anchor = null;
    this._style.destroy(options);
    this._style = null;
    this._text = null;
  }
};
var TextView = _TextView;
TextView.defaultResolution = 1;
TextView.defaultAutoResolution = true;

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/rendering/text/Text.mjs
var Text = class extends Container {
  constructor(options) {
    super({
      view: new TextView(options),
      label: "Text",
      ...options
    });
  }
  get anchor() {
    return this.view.anchor;
  }
  set text(value) {
    this.view.text = value;
  }
  get text() {
    return this.view.text;
  }
  set style(value) {
    this.view.style = value;
  }
  get style() {
    return this.view.style;
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/index.mjs
init_init4();
init_Ticker();

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/tiling-sprite/TilingSprite.mjs
init_Container();

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/tiling-sprite/TilingSpriteView.mjs
init_ObservablePoint();
init_Texture();
init_View();
init_NOOP();

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/utils/Transform.mjs
init_Matrix();
init_ObservablePoint();
var Transform = class {
  constructor({ matrix, observer } = {}) {
    this.dirty = true;
    this._matrix = matrix ?? new Matrix();
    this.observer = observer;
    this.position = new ObservablePoint(this, 0, 0);
    this.scale = new ObservablePoint(this, 1, 1);
    this.pivot = new ObservablePoint(this, 0, 0);
    this.skew = new ObservablePoint(this, 0, 0);
    this._rotation = 0;
    this._cx = 1;
    this._sx = 0;
    this._cy = 0;
    this._sy = 1;
  }
  get matrix() {
    const lt = this._matrix;
    if (!this.dirty)
      return lt;
    lt.a = this._cx * this.scale.x;
    lt.b = this._sx * this.scale.x;
    lt.c = this._cy * this.scale.y;
    lt.d = this._sy * this.scale.y;
    lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
    lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
    this.dirty = false;
    return lt;
  }
  /**
   * Called when a value changes.
   * @param point
   * @internal
   */
  onUpdate(point) {
    this.dirty = true;
    if (point === this.skew) {
      this.updateSkew();
    }
    this.observer?.onUpdate(this);
  }
  /** Called when the skew or the rotation changes. */
  updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew.y);
    this._sx = Math.sin(this._rotation + this.skew.y);
    this._cy = -Math.sin(this._rotation - this.skew.x);
    this._sy = Math.cos(this._rotation - this.skew.x);
    this.dirty = true;
  }
  toString() {
    return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
  }
  /**
   * Decomposes a matrix and sets the transforms properties based on it.
   * @param matrix - The matrix to decompose
   */
  setFromMatrix(matrix) {
    matrix.decompose(this);
    this.dirty = true;
  }
  /** The rotation of the object in radians. */
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    if (this._rotation !== value) {
      this._rotation = value;
      this.updateSkew();
    }
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/tiling-sprite/TilingSpriteView.mjs
var uid4 = 0;
var _TilingSpriteView = class {
  constructor(options) {
    this.batched = true;
    this.owner = emptyViewObserver;
    this.uid = uid4++;
    this.type = "tilingSprite";
    this.onRenderableUpdate = NOOP;
    this._bounds = [0, 1, 0, 0];
    this.boundsDirty = true;
    options = { ..._TilingSpriteView.defaultOptions, ...options };
    this.anchor = new ObservablePoint(this, 0, 0);
    this.applyAnchorToTexture = options.applyAnchorToTexture;
    this.texture = options.texture;
    this._width = options.width;
    this._height = options.height;
    this.tileTransform = new Transform({ observer: this });
  }
  get bounds() {
    if (this.boundsDirty) {
      this.updateBounds();
      this.boundsDirty = false;
    }
    return this._bounds;
  }
  updateBounds() {
    const bounds = this._bounds;
    const anchor = this.anchor;
    const width = this._width;
    const height = this._height;
    bounds[1] = -anchor._x * width;
    bounds[0] = bounds[1] + width;
    bounds[3] = -anchor._y * height;
    bounds[2] = bounds[3] + height;
  }
  addBounds(bounds) {
    const _bounds = this.bounds;
    bounds.addFrame(
      _bounds[0],
      _bounds[2],
      _bounds[1],
      _bounds[3]
    );
  }
  set texture(value) {
    if (this._texture === value)
      return;
    this._texture = value;
    this.onUpdate();
  }
  get texture() {
    return this._texture;
  }
  set width(value) {
    this._width = value;
    this.onUpdate();
  }
  get width() {
    return this._width;
  }
  set height(value) {
    this._height = value;
    this.onUpdate();
  }
  get height() {
    return this._height;
  }
  /**
   * @internal
   */
  onUpdate() {
    this.boundsDirty = true;
    this.didUpdate = true;
    this.owner.onViewUpdate();
  }
  containsPoint(point) {
    const width = this.bounds[2];
    const height = this.bounds[3];
    const x1 = -width * this.anchor.x;
    let y1 = 0;
    if (point.x >= x1 && point.x < x1 + width) {
      y1 = -height * this.anchor.y;
      if (point.y >= y1 && point.y < y1 + height)
        return true;
    }
    return false;
  }
  /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
   */
  destroy(options = false) {
    this.onRenderableUpdate = NOOP;
    this.anchor = null;
    this.tileTransform = null;
    this._bounds = null;
    const destroyTexture = typeof options === "boolean" ? options : options?.texture;
    if (destroyTexture) {
      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
      this._texture.destroy(destroyTextureSource);
    }
    this._texture = null;
  }
};
var TilingSpriteView = _TilingSpriteView;
TilingSpriteView.defaultOptions = {
  texture: Texture.WHITE,
  width: 256,
  height: 256,
  applyAnchorToTexture: false
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-alpha.1/node_modules/pixi.js/lib/tiling-sprite/TilingSprite.mjs
var TilingSprite = class extends Container {
  constructor(options) {
    super({
      view: new TilingSpriteView(options),
      label: "TilingSprite",
      ...options
    });
  }
  set texture(value) {
    this.view.texture = value;
  }
  get texture() {
    return this.view.texture;
  }
  get anchor() {
    return this.view.anchor;
  }
  get width() {
    return this.view.width;
  }
  set width(value) {
    this.view.width = value;
  }
  get height() {
    return this.view.height;
  }
  set height(value) {
    this.view.height = value;
  }
  get tilePosition() {
    return this.view.tileTransform.position;
  }
  set tilePosition(value) {
    this.view.tileTransform.position.copyFrom(value);
  }
  get tileScale() {
    return this.view.tileTransform.scale;
  }
  set tileScale(value) {
    this.view.tileTransform.scale.copyFrom(value);
  }
  set tileRotation(value) {
    this.view.tileTransform.rotation = value;
  }
  get tileRotation() {
    return this.view.tileTransform.rotation;
  }
  get tileTransform() {
    return this.view.tileTransform;
  }
};

// src/frontend/game/assets.ts
var loadedAssets = {};
async function loadAssets() {
  const sheet = await Assets.load("stars.json");
  const planetsheet = await Assets.load("planets.json");
  const uisheet = await Assets.load("uisheet.json");
  const planet = await Assets.load("planet.json");
  const buttonSheet = await Assets.load("ui/button.json");
  const font = await Assets.load("font.fnt");
  const buttonText = await Assets.load("buttontext.fnt");
  const segment = await Assets.load("segment.fnt");
  const buttonTextWhite = await Assets.load("buttontext_white.fnt");
  const bgTexture = await Assets.load("starfield.png");
  const navArrow = await Assets.load("navarrow.png");
  const starTexture = await Assets.load("stars.png");
  const shipyard = await Assets.load("shipyard.png");
  const station = await Assets.load("station.png");
  const jumpgate = await Assets.load("jumpgate.png");
  const treasure = await Assets.load("treasure-map.png");
  const select = await Assets.load("ui/select.png");
  const statsBlock = await Assets.load("ui/stats.png");
  const panel2 = await Assets.load("ui/panel2.png");
  const panelInvisible = await Assets.load("ui/panel_invisible.png");
  const selectInactive = await Assets.load("ui/select_inactive.png");
  const asteroidBelt = await Assets.load("asteroid_belt.png");
  const market = await Assets.load("money-bag-xxl.png");
  const spaceshipTexture = await Assets.load("spaceship.png");
  const probeTexture = await Assets.load("ships/PROBE.png");
  const lightFreighterTexture = await Assets.load("ships/LIGHT_FREIGHTER.png");
  loadedAssets = {
    sheet,
    planetsheet,
    uisheet,
    font,
    buttonsheet: buttonSheet,
    buttonText,
    planet,
    buttonTextWhite,
    bgTexture,
    navArrow,
    panelInvisible,
    starTexture,
    statsBlock,
    panel2,
    station,
    jumpgate,
    treasure,
    spaceshipTexture,
    spaceshipTextures: {
      FRAME_PROBE: probeTexture,
      FRAME_LIGHT_FREIGHTER: lightFreighterTexture,
      FRAME_EXPLORER: await Assets.load("ships/FRAME_EXPLORER.png")
    },
    asteroidBelt,
    shipyard,
    select,
    selectInactive,
    market,
    panel: await Assets.load("ui/panel.png"),
    button: await Assets.load("ui/button.png"),
    panelBg: await Assets.load("ui/panelbg.png")
  };
}

// ../../node_modules/.pnpm/@trpc+server@10.38.5/node_modules/@trpc/server/dist/observable-ade1bad8.mjs
function identity(x2) {
  return x2;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce((prev, fn) => fn(prev), input);
  };
}
function observable(subscribe) {
  const self2 = {
    subscribe(observer) {
      let teardownRef = null;
      let isDone = false;
      let unsubscribed = false;
      let teardownImmediately = false;
      function unsubscribe() {
        if (teardownRef === null) {
          teardownImmediately = true;
          return;
        }
        if (unsubscribed) {
          return;
        }
        unsubscribed = true;
        if (typeof teardownRef === "function") {
          teardownRef();
        } else if (teardownRef) {
          teardownRef.unsubscribe();
        }
      }
      teardownRef = subscribe({
        next(value) {
          if (isDone) {
            return;
          }
          observer.next?.(value);
        },
        error(err) {
          if (isDone) {
            return;
          }
          isDone = true;
          observer.error?.(err);
          unsubscribe();
        },
        complete() {
          if (isDone) {
            return;
          }
          isDone = true;
          observer.complete?.();
          unsubscribe();
        }
      });
      if (teardownImmediately) {
        unsubscribe();
      }
      return {
        unsubscribe
      };
    },
    pipe(...operations) {
      return pipeFromArray(operations)(self2);
    }
  };
  return self2;
}

// ../../node_modules/.pnpm/@trpc+server@10.38.5/node_modules/@trpc/server/dist/observable/index.mjs
function share(_opts) {
  return (originalObserver) => {
    let refCount = 0;
    let subscription = null;
    const observers = [];
    function startIfNeeded() {
      if (subscription) {
        return;
      }
      subscription = originalObserver.subscribe({
        next(value) {
          for (const observer of observers) {
            observer.next?.(value);
          }
        },
        error(error) {
          for (const observer of observers) {
            observer.error?.(error);
          }
        },
        complete() {
          for (const observer of observers) {
            observer.complete?.();
          }
        }
      });
    }
    function resetIfNeeded() {
      if (refCount === 0 && subscription) {
        const _sub = subscription;
        subscription = null;
        _sub.unsubscribe();
      }
    }
    return {
      subscribe(observer) {
        refCount++;
        observers.push(observer);
        startIfNeeded();
        return {
          unsubscribe() {
            refCount--;
            resetIfNeeded();
            const index = observers.findIndex((v2) => v2 === observer);
            if (index > -1) {
              observers.splice(index, 1);
            }
          }
        };
      }
    };
  };
}
var ObservableAbortError = class _ObservableAbortError extends Error {
  constructor(message) {
    super(message);
    this.name = "ObservableAbortError";
    Object.setPrototypeOf(this, _ObservableAbortError.prototype);
  }
};
function observableToPromise(observable2) {
  let abort;
  const promise = new Promise((resolve, reject) => {
    let isDone = false;
    function onDone() {
      if (isDone) {
        return;
      }
      isDone = true;
      reject(new ObservableAbortError("This operation was aborted."));
      obs$.unsubscribe();
    }
    const obs$ = observable2.subscribe({
      next(data) {
        isDone = true;
        resolve(data);
        onDone();
      },
      error(data) {
        isDone = true;
        reject(data);
        onDone();
      },
      complete() {
        isDone = true;
        onDone();
      }
    });
    abort = onDone;
  });
  return {
    promise,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort
  };
}

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/splitLink-4c75f7be.mjs
function createChain(opts) {
  return observable((observer) => {
    function execute(index = 0, op = opts.op) {
      const next = opts.links[index];
      if (!next) {
        throw new Error("No more links to execute - did you forget to add an ending link?");
      }
      const subscription = next({
        op,
        next(nextOp) {
          const nextObserver = execute(index + 1, nextOp);
          return nextObserver;
        }
      });
      return subscription;
    }
    const obs$ = execute();
    return obs$.subscribe(observer);
  });
}
function asArray(value) {
  return Array.isArray(value) ? value : [
    value
  ];
}
function splitLink(opts) {
  return (runtime) => {
    const yes = asArray(opts.true).map((link) => link(runtime));
    const no = asArray(opts.false).map((link) => link(runtime));
    return (props) => {
      return observable((observer) => {
        const links = opts.condition(props.op) ? yes : no;
        return createChain({
          op: props.op,
          links
        }).subscribe(observer);
      });
    };
  };
}

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/transformResult-ace864b8.mjs
function isObject(value) {
  return !!value && !Array.isArray(value) && typeof value === "object";
}
function transformResultInner(response, runtime) {
  if ("error" in response) {
    const error = runtime.transformer.deserialize(response.error);
    return {
      ok: false,
      error: {
        ...response,
        error
      }
    };
  }
  const result = {
    ...response.result,
    ...(!response.result.type || response.result.type === "data") && {
      type: "data",
      data: runtime.transformer.deserialize(response.result.data)
    }
  };
  return {
    ok: true,
    result
  };
}
var TransformResultError = class extends Error {
  constructor() {
    super("Unable to transform response from server");
  }
};
function transformResult(response, runtime) {
  let result;
  try {
    result = transformResultInner(response, runtime);
  } catch (err) {
    throw new TransformResultError();
  }
  if (!result.ok && (!isObject(result.error.error) || typeof result.error.error.code !== "number")) {
    throw new TransformResultError();
  }
  if (result.ok && !isObject(result.result)) {
    throw new TransformResultError();
  }
  return result;
}

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/TRPCClientError-0de4d231.mjs
function isTRPCClientError(cause) {
  return cause instanceof TRPCClientError || /**
  * @deprecated
  * Delete in next major
  */
  cause instanceof Error && cause.name === "TRPCClientError";
}
function isTRPCErrorResponse(obj) {
  return isObject(obj) && isObject(obj.error) && typeof obj.error.code === "number" && typeof obj.error.message === "string";
}
var TRPCClientError = class _TRPCClientError extends Error {
  static from(_cause, opts = {}) {
    const cause = _cause;
    if (isTRPCClientError(cause)) {
      if (opts.meta) {
        cause.meta = {
          ...cause.meta,
          ...opts.meta
        };
      }
      return cause;
    }
    if (isTRPCErrorResponse(cause)) {
      return new _TRPCClientError(cause.error.message, {
        ...opts,
        result: cause
      });
    }
    if (!(cause instanceof Error)) {
      return new _TRPCClientError("Unknown error", {
        ...opts,
        cause
      });
    }
    return new _TRPCClientError(cause.message, {
      ...opts,
      cause
    });
  }
  constructor(message, opts) {
    const cause = opts?.cause;
    super(message, {
      cause
    });
    this.meta = opts?.meta;
    this.cause = cause;
    this.shape = opts?.result?.error;
    this.data = opts?.result?.error.data;
    this.name = "TRPCClientError";
    Object.setPrototypeOf(this, _TRPCClientError.prototype);
  }
};

// ../../node_modules/.pnpm/@trpc+server@10.38.5/node_modules/@trpc/server/dist/codes-c924c3db.mjs
function invert(obj) {
  const newObj = /* @__PURE__ */ Object.create(null);
  for (const key in obj) {
    const v2 = obj[key];
    newObj[v2] = key;
  }
  return newObj;
}
var TRPC_ERROR_CODES_BY_KEY = {
  /**
  * Invalid JSON was received by the server.
  * An error occurred on the server while parsing the JSON text.
  */
  PARSE_ERROR: -32700,
  /**
  * The JSON sent is not a valid Request object.
  */
  BAD_REQUEST: -32600,
  // Internal JSON-RPC error
  INTERNAL_SERVER_ERROR: -32603,
  NOT_IMPLEMENTED: -32603,
  // Implementation specific errors
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099
};
var TRPC_ERROR_CODES_BY_NUMBER = invert(TRPC_ERROR_CODES_BY_KEY);

// ../../node_modules/.pnpm/@trpc+server@10.38.5/node_modules/@trpc/server/dist/index-f91d720c.mjs
var TRPC_ERROR_CODES_BY_NUMBER2 = invert(TRPC_ERROR_CODES_BY_KEY);
var noop = () => {
};
function createInnerProxy(callback, path2) {
  const proxy = new Proxy(noop, {
    get(_obj, key) {
      if (typeof key !== "string" || key === "then") {
        return void 0;
      }
      return createInnerProxy(callback, [
        ...path2,
        key
      ]);
    },
    apply(_1, _2, args) {
      const isApply = path2[path2.length - 1] === "apply";
      return callback({
        args: isApply ? args.length >= 2 ? args[1] : [] : args,
        path: isApply ? path2.slice(0, -1) : path2
      });
    }
  });
  return proxy;
}
var createRecursiveProxy = (callback) => createInnerProxy(callback, []);
var createFlatProxy = (callback) => {
  return new Proxy(noop, {
    get(_obj, name) {
      if (typeof name !== "string" || name === "then") {
        return void 0;
      }
      return callback(name);
    }
  });
};

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/httpUtils-0cb58db4.mjs
var isFunction = (fn) => typeof fn === "function";
function getFetch(customFetchImpl) {
  if (customFetchImpl) {
    return customFetchImpl;
  }
  if (typeof window !== "undefined" && isFunction(window.fetch)) {
    return window.fetch;
  }
  if (typeof globalThis !== "undefined" && isFunction(globalThis.fetch)) {
    return globalThis.fetch;
  }
  throw new Error("No fetch implementation found");
}
function getAbortController(customAbortControllerImpl) {
  if (customAbortControllerImpl) {
    return customAbortControllerImpl;
  }
  if (typeof window !== "undefined" && window.AbortController) {
    return window.AbortController;
  }
  if (typeof globalThis !== "undefined" && globalThis.AbortController) {
    return globalThis.AbortController;
  }
  return null;
}
function resolveHTTPLinkOptions(opts) {
  return {
    url: opts.url,
    fetch: opts.fetch,
    AbortController: getAbortController(opts.AbortController)
  };
}
function arrayToDict(array) {
  const dict = {};
  for (let index = 0; index < array.length; index++) {
    const element = array[index];
    dict[index] = element;
  }
  return dict;
}
var METHOD = {
  query: "GET",
  mutation: "POST"
};
function getInput(opts) {
  return "input" in opts ? opts.runtime.transformer.serialize(opts.input) : arrayToDict(opts.inputs.map((_input) => opts.runtime.transformer.serialize(_input)));
}
var getUrl = (opts) => {
  let url = opts.url + "/" + opts.path;
  const queryParts = [];
  if ("inputs" in opts) {
    queryParts.push("batch=1");
  }
  if (opts.type === "query") {
    const input = getInput(opts);
    if (input !== void 0) {
      queryParts.push(`input=${encodeURIComponent(JSON.stringify(input))}`);
    }
  }
  if (queryParts.length) {
    url += "?" + queryParts.join("&");
  }
  return url;
};
var getBody = (opts) => {
  if (opts.type === "query") {
    return void 0;
  }
  const input = getInput(opts);
  return input !== void 0 ? JSON.stringify(input) : void 0;
};
var jsonHttpRequester = (opts) => {
  return httpRequest({
    ...opts,
    contentTypeHeader: "application/json",
    getUrl,
    getBody
  });
};
async function fetchHTTPResponse(opts, ac) {
  const url = opts.getUrl(opts);
  const body = opts.getBody(opts);
  const { type } = opts;
  const resolvedHeaders = await opts.headers();
  if (type === "subscription") {
    throw new Error("Subscriptions should use wsLink");
  }
  const headers = {
    ...opts.contentTypeHeader ? {
      "content-type": opts.contentTypeHeader
    } : {},
    ...opts.batchModeHeader ? {
      "trpc-batch-mode": opts.batchModeHeader
    } : {},
    ...resolvedHeaders
  };
  return getFetch(opts.fetch)(url, {
    method: METHOD[type],
    signal: ac?.signal,
    body,
    headers
  });
}
function httpRequest(opts) {
  const ac = opts.AbortController ? new opts.AbortController() : null;
  const meta = {};
  let done = false;
  const promise = new Promise((resolve, reject) => {
    fetchHTTPResponse(opts, ac).then((_res) => {
      meta.response = _res;
      done = true;
      return _res.json();
    }).then((json) => {
      meta.responseJSON = json;
      resolve({
        json,
        meta
      });
    }).catch((err) => {
      done = true;
      reject(TRPCClientError.from(err, {
        meta
      }));
    });
  });
  const cancel = () => {
    if (!done) {
      ac?.abort();
    }
  };
  return {
    promise,
    cancel
  };
}

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/httpBatchLink-cee1f56c.mjs
var throwFatalError = () => {
  throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
};
function dataLoader(batchLoader) {
  let pendingItems = null;
  let dispatchTimer = null;
  const destroyTimerAndPendingItems = () => {
    clearTimeout(dispatchTimer);
    dispatchTimer = null;
    pendingItems = null;
  };
  function groupItems(items) {
    const groupedItems = [
      []
    ];
    let index = 0;
    while (true) {
      const item = items[index];
      if (!item) {
        break;
      }
      const lastGroup = groupedItems[groupedItems.length - 1];
      if (item.aborted) {
        item.reject?.(new Error("Aborted"));
        index++;
        continue;
      }
      const isValid = batchLoader.validate(lastGroup.concat(item).map((it) => it.key));
      if (isValid) {
        lastGroup.push(item);
        index++;
        continue;
      }
      if (lastGroup.length === 0) {
        item.reject?.(new Error("Input is too big for a single dispatch"));
        index++;
        continue;
      }
      groupedItems.push([]);
    }
    return groupedItems;
  }
  function dispatch() {
    const groupedItems = groupItems(pendingItems);
    destroyTimerAndPendingItems();
    for (const items of groupedItems) {
      if (!items.length) {
        continue;
      }
      const batch = {
        items,
        cancel: throwFatalError
      };
      for (const item of items) {
        item.batch = batch;
      }
      const unitResolver = (index, value) => {
        const item = batch.items[index];
        item.resolve?.(value);
        item.batch = null;
        item.reject = null;
        item.resolve = null;
      };
      const { promise, cancel } = batchLoader.fetch(batch.items.map((_item) => _item.key), unitResolver);
      batch.cancel = cancel;
      promise.then((result) => {
        for (let i = 0; i < result.length; i++) {
          const value = result[i];
          unitResolver(i, value);
        }
        for (const item of batch.items) {
          item.reject?.(new Error("Missing result"));
          item.batch = null;
        }
      }).catch((cause) => {
        for (const item of batch.items) {
          item.reject?.(cause);
          item.batch = null;
        }
      });
    }
  }
  function load(key) {
    const item = {
      aborted: false,
      key,
      batch: null,
      resolve: throwFatalError,
      reject: throwFatalError
    };
    const promise = new Promise((resolve, reject) => {
      item.reject = reject;
      item.resolve = resolve;
      if (!pendingItems) {
        pendingItems = [];
      }
      pendingItems.push(item);
    });
    if (!dispatchTimer) {
      dispatchTimer = setTimeout(dispatch);
    }
    const cancel = () => {
      item.aborted = true;
      if (item.batch?.items.every((item2) => item2.aborted)) {
        item.batch.cancel();
        item.batch = null;
      }
    };
    return {
      promise,
      cancel
    };
  }
  return {
    load
  };
}
function createHTTPBatchLink(requester) {
  return function httpBatchLink2(opts) {
    const resolvedOpts = resolveHTTPLinkOptions(opts);
    const maxURLLength = opts.maxURLLength ?? Infinity;
    return (runtime) => {
      const batchLoader = (type) => {
        const validate = (batchOps) => {
          if (maxURLLength === Infinity) {
            return true;
          }
          const path2 = batchOps.map((op) => op.path).join(",");
          const inputs = batchOps.map((op) => op.input);
          const url = getUrl({
            ...resolvedOpts,
            runtime,
            type,
            path: path2,
            inputs
          });
          return url.length <= maxURLLength;
        };
        const fetch2 = requester({
          ...resolvedOpts,
          runtime,
          type,
          opts
        });
        return {
          validate,
          fetch: fetch2
        };
      };
      const query = dataLoader(batchLoader("query"));
      const mutation = dataLoader(batchLoader("mutation"));
      const subscription = dataLoader(batchLoader("subscription"));
      const loaders = {
        query,
        subscription,
        mutation
      };
      return ({ op }) => {
        return observable((observer) => {
          const loader = loaders[op.type];
          const { promise, cancel } = loader.load(op);
          let _res = void 0;
          promise.then((res) => {
            _res = res;
            const transformed = transformResult(res.json, runtime);
            if (!transformed.ok) {
              observer.error(TRPCClientError.from(transformed.error, {
                meta: res.meta
              }));
              return;
            }
            observer.next({
              context: res.meta,
              result: transformed.result
            });
            observer.complete();
          }).catch((err) => {
            observer.error(TRPCClientError.from(err, {
              meta: _res?.meta
            }));
          });
          return () => {
            cancel();
          };
        });
      };
    };
  };
}
var batchRequester = (requesterOpts) => {
  return (batchOps) => {
    const path2 = batchOps.map((op) => op.path).join(",");
    const inputs = batchOps.map((op) => op.input);
    const { promise, cancel } = jsonHttpRequester({
      ...requesterOpts,
      path: path2,
      inputs,
      headers() {
        if (!requesterOpts.opts.headers) {
          return {};
        }
        if (typeof requesterOpts.opts.headers === "function") {
          return requesterOpts.opts.headers({
            opList: batchOps
          });
        }
        return requesterOpts.opts.headers;
      }
    });
    return {
      promise: promise.then((res) => {
        const resJSON = Array.isArray(res.json) ? res.json : batchOps.map(() => res.json);
        const result = resJSON.map((item) => ({
          meta: res.meta,
          json: item
        }));
        return result;
      }),
      cancel
    };
  };
};
var httpBatchLink = createHTTPBatchLink(batchRequester);

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/links/httpLink.mjs
function httpLinkFactory(factoryOpts) {
  return (opts) => {
    const resolvedOpts = resolveHTTPLinkOptions(opts);
    return (runtime) => ({ op }) => observable((observer) => {
      const { path: path2, input, type } = op;
      const { promise, cancel } = factoryOpts.requester({
        ...resolvedOpts,
        runtime,
        type,
        path: path2,
        input,
        headers() {
          if (!opts.headers) {
            return {};
          }
          if (typeof opts.headers === "function") {
            return opts.headers({
              op
            });
          }
          return opts.headers;
        }
      });
      let meta = void 0;
      promise.then((res) => {
        meta = res.meta;
        const transformed = transformResult(res.json, runtime);
        if (!transformed.ok) {
          observer.error(TRPCClientError.from(transformed.error, {
            meta
          }));
          return;
        }
        observer.next({
          context: res.meta,
          result: transformed.result
        });
        observer.complete();
      }).catch((cause) => {
        observer.error(TRPCClientError.from(cause, {
          meta
        }));
      });
      return () => {
        cancel();
      };
    });
  };
}
var httpLink = httpLinkFactory({
  requester: jsonHttpRequester
});

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/links/wsLink.mjs
var retryDelay = (attemptIndex) => attemptIndex === 0 ? 0 : Math.min(1e3 * 2 ** attemptIndex, 3e4);
function createWSClient(opts) {
  const { url, WebSocket: WebSocketImpl = WebSocket, retryDelayMs: retryDelayFn = retryDelay, onOpen, onClose } = opts;
  if (!WebSocketImpl) {
    throw new Error("No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill");
  }
  let outgoing = [];
  const pendingRequests = /* @__PURE__ */ Object.create(null);
  let connectAttempt = 0;
  let dispatchTimer = null;
  let connectTimer = null;
  let activeConnection = createWS();
  let state = "connecting";
  function dispatch() {
    if (state !== "open" || dispatchTimer) {
      return;
    }
    dispatchTimer = setTimeout(() => {
      dispatchTimer = null;
      if (outgoing.length === 1) {
        activeConnection.send(JSON.stringify(outgoing.pop()));
      } else {
        activeConnection.send(JSON.stringify(outgoing));
      }
      outgoing = [];
    });
  }
  function tryReconnect() {
    if (connectTimer !== null || state === "closed") {
      return;
    }
    const timeout = retryDelayFn(connectAttempt++);
    reconnectInMs(timeout);
  }
  function reconnect() {
    state = "connecting";
    const oldConnection = activeConnection;
    activeConnection = createWS();
    closeIfNoPending(oldConnection);
  }
  function reconnectInMs(ms) {
    if (connectTimer) {
      return;
    }
    state = "connecting";
    connectTimer = setTimeout(reconnect, ms);
  }
  function closeIfNoPending(conn) {
    const hasPendingRequests = Object.values(pendingRequests).some((p) => p.ws === conn);
    if (!hasPendingRequests) {
      conn.close();
    }
  }
  function closeActiveSubscriptions() {
    Object.values(pendingRequests).forEach((req) => {
      if (req.type === "subscription") {
        req.callbacks.complete();
      }
    });
  }
  function resumeSubscriptionOnReconnect(req) {
    if (outgoing.some((r) => r.id === req.op.id)) {
      return;
    }
    request(req.op, req.callbacks);
  }
  function createWS() {
    const urlString = typeof url === "function" ? url() : url;
    const conn = new WebSocketImpl(urlString);
    clearTimeout(connectTimer);
    connectTimer = null;
    conn.addEventListener("open", () => {
      if (conn !== activeConnection) {
        return;
      }
      connectAttempt = 0;
      state = "open";
      onOpen?.();
      dispatch();
    });
    conn.addEventListener("error", () => {
      if (conn === activeConnection) {
        tryReconnect();
      }
    });
    const handleIncomingRequest = (req) => {
      if (req.method === "reconnect" && conn === activeConnection) {
        if (state === "open") {
          onClose?.();
        }
        reconnect();
        for (const pendingReq of Object.values(pendingRequests)) {
          if (pendingReq.type === "subscription") {
            resumeSubscriptionOnReconnect(pendingReq);
          }
        }
      }
    };
    const handleIncomingResponse = (data) => {
      const req = data.id !== null && pendingRequests[data.id];
      if (!req) {
        return;
      }
      req.callbacks.next?.(data);
      if (req.ws !== activeConnection && conn === activeConnection) {
        const oldWs = req.ws;
        req.ws = activeConnection;
        closeIfNoPending(oldWs);
      }
      if ("result" in data && data.result.type === "stopped" && conn === activeConnection) {
        req.callbacks.complete();
      }
    };
    conn.addEventListener("message", ({ data }) => {
      const msg = JSON.parse(data);
      if ("method" in msg) {
        handleIncomingRequest(msg);
      } else {
        handleIncomingResponse(msg);
      }
      if (conn !== activeConnection || state === "closed") {
        closeIfNoPending(conn);
      }
    });
    conn.addEventListener("close", ({ code }) => {
      if (state === "open") {
        onClose?.({
          code
        });
      }
      if (activeConnection === conn) {
        tryReconnect();
      }
      for (const [key, req] of Object.entries(pendingRequests)) {
        if (req.ws !== conn) {
          continue;
        }
        if (state === "closed") {
          delete pendingRequests[key];
          req.callbacks.complete?.();
          continue;
        }
        if (req.type === "subscription") {
          resumeSubscriptionOnReconnect(req);
        } else {
          delete pendingRequests[key];
          req.callbacks.error?.(TRPCClientError.from(new TRPCWebSocketClosedError("WebSocket closed prematurely")));
        }
      }
    });
    return conn;
  }
  function request(op, callbacks) {
    const { type, input, path: path2, id } = op;
    const envelope = {
      id,
      method: type,
      params: {
        input,
        path: path2
      }
    };
    pendingRequests[id] = {
      ws: activeConnection,
      type,
      callbacks,
      op
    };
    outgoing.push(envelope);
    dispatch();
    return () => {
      const callbacks2 = pendingRequests[id]?.callbacks;
      delete pendingRequests[id];
      outgoing = outgoing.filter((msg) => msg.id !== id);
      callbacks2?.complete?.();
      if (activeConnection.readyState === WebSocketImpl.OPEN && op.type === "subscription") {
        outgoing.push({
          id,
          method: "subscription.stop"
        });
        dispatch();
      }
    };
  }
  return {
    close: () => {
      state = "closed";
      onClose?.();
      closeActiveSubscriptions();
      closeIfNoPending(activeConnection);
      clearTimeout(connectTimer);
      connectTimer = null;
    },
    request,
    getConnection() {
      return activeConnection;
    }
  };
}
var TRPCWebSocketClosedError = class _TRPCWebSocketClosedError extends Error {
  constructor(message) {
    super(message);
    this.name = "TRPCWebSocketClosedError";
    Object.setPrototypeOf(this, _TRPCWebSocketClosedError.prototype);
  }
};
function wsLink(opts) {
  return (runtime) => {
    const { client } = opts;
    return ({ op }) => {
      return observable((observer) => {
        const { type, path: path2, id, context } = op;
        const input = runtime.transformer.serialize(op.input);
        const unsub = client.request({
          type,
          path: path2,
          input,
          id,
          context
        }, {
          error(err) {
            observer.error(err);
            unsub();
          },
          complete() {
            observer.complete();
          },
          next(message) {
            const transformed = transformResult(message, runtime);
            if (!transformed.ok) {
              observer.error(TRPCClientError.from(transformed.error));
              return;
            }
            observer.next({
              result: transformed.result
            });
            if (op.type !== "subscription") {
              unsub();
              observer.complete();
            }
          }
        });
        return () => {
          unsub();
        };
      });
    };
  };
}

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/index.mjs
var TRPCUntypedClient = class {
  $request({ type, input, path: path2, context = {} }) {
    const chain$ = createChain({
      links: this.links,
      op: {
        id: ++this.requestId,
        type,
        path: path2,
        input,
        context
      }
    });
    return chain$.pipe(share());
  }
  requestAsPromise(opts) {
    const req$ = this.$request(opts);
    const { promise, abort } = observableToPromise(req$);
    const abortablePromise = new Promise((resolve, reject) => {
      opts.signal?.addEventListener("abort", abort);
      promise.then((envelope) => {
        resolve(envelope.result.data);
      }).catch((err) => {
        reject(TRPCClientError.from(err));
      });
    });
    return abortablePromise;
  }
  query(path2, input, opts) {
    return this.requestAsPromise({
      type: "query",
      path: path2,
      input,
      context: opts?.context,
      signal: opts?.signal
    });
  }
  mutation(path2, input, opts) {
    return this.requestAsPromise({
      type: "mutation",
      path: path2,
      input,
      context: opts?.context,
      signal: opts?.signal
    });
  }
  subscription(path2, input, opts) {
    const observable$ = this.$request({
      type: "subscription",
      path: path2,
      input,
      context: opts?.context
    });
    return observable$.subscribe({
      next(envelope) {
        if (envelope.result.type === "started") {
          opts.onStarted?.();
        } else if (envelope.result.type === "stopped") {
          opts.onStopped?.();
        } else {
          opts.onData?.(envelope.result.data);
        }
      },
      error(err) {
        opts.onError?.(err);
      },
      complete() {
        opts.onComplete?.();
      }
    });
  }
  constructor(opts) {
    this.requestId = 0;
    const combinedTransformer = (() => {
      const transformer = opts.transformer;
      if (!transformer) {
        return {
          input: {
            serialize: (data) => data,
            deserialize: (data) => data
          },
          output: {
            serialize: (data) => data,
            deserialize: (data) => data
          }
        };
      }
      if ("input" in transformer) {
        return opts.transformer;
      }
      return {
        input: transformer,
        output: transformer
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (data) => combinedTransformer.input.serialize(data),
        deserialize: (data) => combinedTransformer.output.deserialize(data)
      },
      combinedTransformer
    };
    this.links = opts.links.map((link) => link(this.runtime));
  }
};
var clientCallTypeMap = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
};
var clientCallTypeToProcedureType = (clientCallType) => {
  return clientCallTypeMap[clientCallType];
};
function createTRPCClientProxy(client) {
  return createFlatProxy((key) => {
    if (client.hasOwnProperty(key)) {
      return client[key];
    }
    if (key === "__untypedClient") {
      return client;
    }
    return createRecursiveProxy(({ path: path2, args }) => {
      const pathCopy = [
        key,
        ...path2
      ];
      const procedureType = clientCallTypeToProcedureType(pathCopy.pop());
      const fullPath = pathCopy.join(".");
      return client[procedureType](fullPath, ...args);
    });
  });
}
function createTRPCProxyClient(opts) {
  const client = new TRPCUntypedClient(opts);
  const proxy = createTRPCClientProxy(client);
  return proxy;
}
function getTextDecoder(customTextDecoder) {
  if (customTextDecoder) {
    return customTextDecoder;
  }
  if (typeof window !== "undefined" && window.TextDecoder) {
    return new window.TextDecoder();
  }
  if (typeof globalThis !== "undefined" && globalThis.TextDecoder) {
    return new globalThis.TextDecoder();
  }
  throw new Error("No TextDecoder implementation found");
}
async function parseJSONStream(opts) {
  const parse = opts.parse ?? JSON.parse;
  const onLine = (line) => {
    if (opts.signal?.aborted)
      return;
    if (!line || line === "}") {
      return;
    }
    const indexOfColon = line.indexOf(":");
    const indexAsStr = line.substring(2, indexOfColon - 1);
    const text = line.substring(indexOfColon + 1);
    opts.onSingle(Number(indexAsStr), parse(text));
  };
  await readLines(opts.readableStream, onLine, opts.textDecoder);
}
async function readLines(readableStream, onLine, textDecoder) {
  let partOfLine = "";
  const onChunk = (chunk) => {
    const chunkText = textDecoder.decode(chunk);
    const chunkLines = chunkText.split("\n");
    if (chunkLines.length === 1) {
      partOfLine += chunkLines[0];
    } else if (chunkLines.length > 1) {
      onLine(partOfLine + chunkLines[0]);
      for (let i = 1; i < chunkLines.length - 1; i++) {
        onLine(chunkLines[i]);
      }
      partOfLine = chunkLines[chunkLines.length - 1];
    }
  };
  if ("getReader" in readableStream) {
    await readStandardChunks(readableStream, onChunk);
  } else {
    await readNodeChunks(readableStream, onChunk);
  }
  onLine(partOfLine);
}
function readNodeChunks(stream, onChunk) {
  return new Promise((resolve) => {
    stream.on("data", onChunk);
    stream.on("end", resolve);
  });
}
async function readStandardChunks(stream, onChunk) {
  const reader = stream.getReader();
  let readResult = await reader.read();
  while (!readResult.done) {
    onChunk(readResult.value);
    readResult = await reader.read();
  }
}
var streamingJsonHttpRequester = (opts, onSingle) => {
  const ac = opts.AbortController ? new opts.AbortController() : null;
  const responsePromise = fetchHTTPResponse({
    ...opts,
    contentTypeHeader: "application/json",
    batchModeHeader: "stream",
    getUrl,
    getBody
  }, ac);
  const cancel = () => ac?.abort();
  const promise = responsePromise.then(async (res) => {
    if (!res.body)
      throw new Error("Received response without body");
    const meta = {
      response: res
    };
    return parseJSONStream({
      readableStream: res.body,
      onSingle,
      parse: (string) => ({
        json: JSON.parse(string),
        meta
      }),
      signal: ac?.signal,
      textDecoder: opts.textDecoder
    });
  });
  return {
    cancel,
    promise
  };
};
var streamRequester = (requesterOpts) => {
  const textDecoder = getTextDecoder(requesterOpts.opts.textDecoder);
  return (batchOps, unitResolver) => {
    const path2 = batchOps.map((op) => op.path).join(",");
    const inputs = batchOps.map((op) => op.input);
    const { cancel, promise } = streamingJsonHttpRequester({
      ...requesterOpts,
      textDecoder,
      path: path2,
      inputs,
      headers() {
        if (!requesterOpts.opts.headers) {
          return {};
        }
        if (typeof requesterOpts.opts.headers === "function") {
          return requesterOpts.opts.headers({
            opList: batchOps
          });
        }
        return requesterOpts.opts.headers;
      }
    }, (index, res) => {
      unitResolver(index, res);
    });
    return {
      /**
      * return an empty array because the batchLoader expects an array of results
      * but we've already called the `unitResolver` for each of them, there's
      * nothing left to do here.
      */
      promise: promise.then(() => []),
      cancel
    };
  };
};
var unstable_httpBatchStreamLink = createHTTPBatchLink(streamRequester);
var getBody2 = (opts) => {
  if (!("input" in opts)) {
    return void 0;
  }
  if (!(opts.input instanceof FormData)) {
    throw new Error("Input is not FormData");
  }
  return opts.input;
};
var formDataRequester = (opts) => {
  if (opts.type !== "mutation") {
    throw new Error("We only handle mutations with formdata");
  }
  return httpRequest({
    ...opts,
    getUrl() {
      return `${opts.url}/${opts.path}`;
    },
    getBody: getBody2
  });
};
var experimental_formDataLink = httpLinkFactory({
  requester: formDataRequester
});

// src/frontend/trpc.ts
var backendUrl = "http://" + window.location.hostname;
var wsClient = createWSClient({
  // * put ws instead of http on the url
  url: backendUrl.replace("https", "wss").replace("http", "ws") + ":4002/trpc",
  retryDelayMs: (attempt) => {
    if (attempt > 10) {
      return null;
    } else {
      return 1e3;
    }
  }
});
var trpc = createTRPCProxyClient({
  links: [
    splitLink({
      // * only use the web socket link if the operation is a subscription
      condition: (operation) => {
        return operation.type === "subscription";
      },
      true: wsLink({
        client: wsClient
        // * <- use the web socket client
      }),
      // * use the httpBatchLink for everything else (query, mutation)
      false: httpBatchLink({
        url: backendUrl + ":4001",
        async headers() {
          const token = localStorage.getItem("agent-token") ?? localStorage.getItem("user-token");
          return token ? {
            authorization: "Bearer " + token
          } : {};
        }
      })
    })
  ]
});

// src/frontend/game/game-state.ts
var GameState = {
  agent: {
    symbol: "",
    credits: 0
  },
  currentView: "universe",
  currentSystem: void 0,
  selected: void 0,
  systemShips: {},
  shipData: {},
  waypoints: {},
  systems: {},
  universeShips: {},
  displayedMarket: void 0,
  systemData: {},
  waypointData: {}
};

// src/frontend/game/makeInteractiveAndSelectable.ts
var import_events = __toESM(require_events());
var deselectListeners = new import_events.EventEmitter();
function makeInteractiveAndSelectable(item, options) {
  item.interactive = true;
  item.cursor = "pointer";
  item.on("mouseover", () => {
    item.filters = [];
    options?.onMouseOver?.();
  });
  const removeGlow = () => {
    item.filters = [];
  };
  item.on("mouseout", removeGlow);
  item.on("mouseout", () => {
    options?.onMouseOut?.();
  });
  if (options?.onOrder) {
    item.on("rightclick", async (event) => {
      event.stopPropagation();
      const allCommands = typeof options.onOrder == "function" ? await options.onOrder() : options.onOrder;
      const filteredCommands = allCommands.filter((c) => {
        if (c.withSelection && (!GameState.selected || GameState.selected.type !== c.withSelection)) {
          return false;
        }
        return true;
      });
      const isCommandAvailable = await Promise.all(filteredCommands.map((c) => {
        return c.isAvailable ? c.isAvailable() : true;
      }));
      const validCommands = filteredCommands.filter((c, index) => {
        return isCommandAvailable[index];
      });
      if (validCommands.length == 0) {
      } else if (filteredCommands.length === 1) {
        filteredCommands[0].action(GameState.selected.symbol);
      } else {
        const background = new NineSlicePlane(loadedAssets.statsBlock);
        background.height = filteredCommands.length * 40;
        background.width = 180;
        item.addChild(background);
        deselectListeners.once("deselect", () => {
          item.removeChild(background);
        });
      }
    });
  }
  if (options?.onSelect) {
    item.on("click", (event) => {
      deselectListeners.emit("deselect");
      event.stopPropagation();
      deselectListeners.once("deselect", () => {
        removeGlow();
        GameState.selected = void 0;
        item.on("mouseout", removeGlow);
      });
      item.off("mouseout", removeGlow);
      GameState.selected = options.onSelect;
    });
  }
}

// src/frontend/game/consts.ts
var totalSize = 5e5;
var systemScale = 12;
var universeCoordinates = {
  minX: 0,
  minY: 0,
  maxX: 0,
  maxY: 0
};
var systemCoordinates = {
  minX: 0,
  minY: 0
};
var scale = {
  universe: 1
};
var gameWidth = window.innerWidth ?? 1920;
var gameHeight = window.innerHeight ?? 1080;

// ../pixi-viewport/dist/pixi_viewport.js
var u = class {
  /** @param {Viewport} parent */
  constructor(t) {
    this.parent = t, this.paused = false;
  }
  /** Called when plugin is removed */
  destroy() {
  }
  /** Handler for pointerdown PIXI event */
  down(t) {
    return false;
  }
  /** Handler for pointermove PIXI event */
  move(t) {
    return false;
  }
  /** Handler for pointerup PIXI event */
  up(t) {
    return false;
  }
  /** Handler for wheel event on div */
  wheel(t) {
    return false;
  }
  /**
   * Called on each tick
   * @param {number} elapsed time in millisecond since last update
   */
  update(t) {
  }
  /** Called when the viewport is resized */
  resize() {
  }
  /** Called when the viewport is manually moved */
  reset() {
  }
  /** Pause the plugin */
  pause() {
    this.paused = true;
  }
  /** Un-pause the plugin */
  resume() {
    this.paused = false;
  }
};
var S = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function M(l) {
  return l && l.__esModule && Object.prototype.hasOwnProperty.call(l, "default") ? l.default : l;
}
var W = { exports: {} };
(function(l, t) {
  (function() {
    var e, n;
    n = function(i) {
      return l.exports = i;
    }, e = {
      linear: function(i, s, h, o) {
        return h * i / o + s;
      },
      easeInQuad: function(i, s, h, o) {
        return h * (i /= o) * i + s;
      },
      easeOutQuad: function(i, s, h, o) {
        return -h * (i /= o) * (i - 2) + s;
      },
      easeInOutQuad: function(i, s, h, o) {
        return (i /= o / 2) < 1 ? h / 2 * i * i + s : -h / 2 * (--i * (i - 2) - 1) + s;
      },
      easeInCubic: function(i, s, h, o) {
        return h * (i /= o) * i * i + s;
      },
      easeOutCubic: function(i, s, h, o) {
        return h * ((i = i / o - 1) * i * i + 1) + s;
      },
      easeInOutCubic: function(i, s, h, o) {
        return (i /= o / 2) < 1 ? h / 2 * i * i * i + s : h / 2 * ((i -= 2) * i * i + 2) + s;
      },
      easeInQuart: function(i, s, h, o) {
        return h * (i /= o) * i * i * i + s;
      },
      easeOutQuart: function(i, s, h, o) {
        return -h * ((i = i / o - 1) * i * i * i - 1) + s;
      },
      easeInOutQuart: function(i, s, h, o) {
        return (i /= o / 2) < 1 ? h / 2 * i * i * i * i + s : -h / 2 * ((i -= 2) * i * i * i - 2) + s;
      },
      easeInQuint: function(i, s, h, o) {
        return h * (i /= o) * i * i * i * i + s;
      },
      easeOutQuint: function(i, s, h, o) {
        return h * ((i = i / o - 1) * i * i * i * i + 1) + s;
      },
      easeInOutQuint: function(i, s, h, o) {
        return (i /= o / 2) < 1 ? h / 2 * i * i * i * i * i + s : h / 2 * ((i -= 2) * i * i * i * i + 2) + s;
      },
      easeInSine: function(i, s, h, o) {
        return -h * Math.cos(i / o * (Math.PI / 2)) + h + s;
      },
      easeOutSine: function(i, s, h, o) {
        return h * Math.sin(i / o * (Math.PI / 2)) + s;
      },
      easeInOutSine: function(i, s, h, o) {
        return -h / 2 * (Math.cos(Math.PI * i / o) - 1) + s;
      },
      easeInExpo: function(i, s, h, o) {
        return i === 0 ? s : h * Math.pow(2, 10 * (i / o - 1)) + s;
      },
      easeOutExpo: function(i, s, h, o) {
        return i === o ? s + h : h * (-Math.pow(2, -10 * i / o) + 1) + s;
      },
      easeInOutExpo: function(i, s, h, o) {
        return (i /= o / 2) < 1 ? h / 2 * Math.pow(2, 10 * (i - 1)) + s : h / 2 * (-Math.pow(2, -10 * --i) + 2) + s;
      },
      easeInCirc: function(i, s, h, o) {
        return -h * (Math.sqrt(1 - (i /= o) * i) - 1) + s;
      },
      easeOutCirc: function(i, s, h, o) {
        return h * Math.sqrt(1 - (i = i / o - 1) * i) + s;
      },
      easeInOutCirc: function(i, s, h, o) {
        return (i /= o / 2) < 1 ? -h / 2 * (Math.sqrt(1 - i * i) - 1) + s : h / 2 * (Math.sqrt(1 - (i -= 2) * i) + 1) + s;
      },
      easeInElastic: function(i, s, h, o) {
        var r, a, p;
        return p = 1.70158, a = 0, r = h, i === 0 || (i /= o), a || (a = o * 0.3), r < Math.abs(h) ? (r = h, p = a / 4) : p = a / (2 * Math.PI) * Math.asin(h / r), -(r * Math.pow(2, 10 * (i -= 1)) * Math.sin((i * o - p) * (2 * Math.PI) / a)) + s;
      },
      easeOutElastic: function(i, s, h, o) {
        var r, a, p;
        return p = 1.70158, a = 0, r = h, i === 0 || (i /= o), a || (a = o * 0.3), r < Math.abs(h) ? (r = h, p = a / 4) : p = a / (2 * Math.PI) * Math.asin(h / r), r * Math.pow(2, -10 * i) * Math.sin((i * o - p) * (2 * Math.PI) / a) + h + s;
      },
      easeInOutElastic: function(i, s, h, o) {
        var r, a, p;
        return p = 1.70158, a = 0, r = h, i === 0 || (i /= o / 2), a || (a = o * (0.3 * 1.5)), r < Math.abs(h) ? (r = h, p = a / 4) : p = a / (2 * Math.PI) * Math.asin(h / r), i < 1 ? -0.5 * (r * Math.pow(2, 10 * (i -= 1)) * Math.sin((i * o - p) * (2 * Math.PI) / a)) + s : r * Math.pow(2, -10 * (i -= 1)) * Math.sin((i * o - p) * (2 * Math.PI) / a) * 0.5 + h + s;
      },
      easeInBack: function(i, s, h, o, r) {
        return r === void 0 && (r = 1.70158), h * (i /= o) * i * ((r + 1) * i - r) + s;
      },
      easeOutBack: function(i, s, h, o, r) {
        return r === void 0 && (r = 1.70158), h * ((i = i / o - 1) * i * ((r + 1) * i + r) + 1) + s;
      },
      easeInOutBack: function(i, s, h, o, r) {
        return r === void 0 && (r = 1.70158), (i /= o / 2) < 1 ? h / 2 * (i * i * (((r *= 1.525) + 1) * i - r)) + s : h / 2 * ((i -= 2) * i * (((r *= 1.525) + 1) * i + r) + 2) + s;
      },
      easeInBounce: function(i, s, h, o) {
        var r;
        return r = e.easeOutBounce(o - i, 0, h, o), h - r + s;
      },
      easeOutBounce: function(i, s, h, o) {
        return (i /= o) < 1 / 2.75 ? h * (7.5625 * i * i) + s : i < 2 / 2.75 ? h * (7.5625 * (i -= 1.5 / 2.75) * i + 0.75) + s : i < 2.5 / 2.75 ? h * (7.5625 * (i -= 2.25 / 2.75) * i + 0.9375) + s : h * (7.5625 * (i -= 2.625 / 2.75) * i + 0.984375) + s;
      },
      easeInOutBounce: function(i, s, h, o) {
        var r;
        return i < o / 2 ? (r = e.easeInBounce(i * 2, 0, h, o), r * 0.5 + s) : (r = e.easeOutBounce(i * 2 - o, 0, h, o), r * 0.5 + h * 0.5 + s);
      }
    }, n(e);
  }).call(S);
})(W);
var O = W.exports;
var v = /* @__PURE__ */ M(O);
function x(l, t) {
  if (l) {
    if (typeof l == "function")
      return l;
    if (typeof l == "string")
      return v[l];
  } else
    return v[t];
}
var P = {
  removeOnInterrupt: false,
  ease: "linear",
  time: 1e3
};
var C = class extends u {
  /**
   * This is called by {@link Viewport.animate}.
   *
   * @param parent
   * @param options
   */
  constructor(t, e = {}) {
    super(t), this.startWidth = null, this.startHeight = null, this.deltaWidth = null, this.deltaHeight = null, this.width = null, this.height = null, this.time = 0, this.options = Object.assign({}, P, e), this.options.ease = x(this.options.ease), this.setupPosition(), this.setupZoom(), this.time = 0;
  }
  /**
   * Setup `startX`, `startY`, `deltaX`, `deltaY`, `keepCenter`.
   *
   * This is called during construction.
   */
  setupPosition() {
    typeof this.options.position < "u" ? (this.startX = this.parent.center.x, this.startY = this.parent.center.y, this.deltaX = this.options.position.x - this.parent.center.x, this.deltaY = this.options.position.y - this.parent.center.y, this.keepCenter = false) : this.keepCenter = true;
  }
  /**
   * Setup `startWidth, `startHeight`, `deltaWidth, `deltaHeight, `width`, `height`.
   *
   * This is called during construction.
   */
  setupZoom() {
    this.width = null, this.height = null, typeof this.options.scale < "u" ? this.width = this.parent.screenWidth / this.options.scale : typeof this.options.scaleX < "u" || typeof this.options.scaleY < "u" ? (typeof this.options.scaleX < "u" && (this.width = this.parent.screenWidth / this.options.scaleX), typeof this.options.scaleY < "u" && (this.height = this.parent.screenHeight / this.options.scaleY)) : (typeof this.options.width < "u" && (this.width = this.options.width), typeof this.options.height < "u" && (this.height = this.options.height)), this.width !== null && (this.startWidth = this.parent.screenWidthInWorldPixels, this.deltaWidth = this.width - this.startWidth), this.height !== null && (this.startHeight = this.parent.screenHeightInWorldPixels, this.deltaHeight = this.height - this.startHeight);
  }
  down() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("animate"), false;
  }
  complete() {
    this.parent.plugins.remove("animate"), this.width !== null && this.parent.fitWidth(this.width, this.keepCenter, this.height === null), this.height !== null && this.parent.fitHeight(this.height, this.keepCenter, this.width === null), !this.keepCenter && this.options.position && this.parent.moveCenter(this.options.position), this.parent.emit("animate-end", this.parent), this.options.callbackOnComplete && this.options.callbackOnComplete(this.parent);
  }
  update(t) {
    if (this.paused)
      return;
    this.time += t;
    const e = new Point(this.parent.scale.x, this.parent.scale.y);
    if (this.time >= this.options.time) {
      const n = this.parent.width, i = this.parent.height;
      this.complete(), (n !== this.parent.width || i !== this.parent.height) && this.parent.emit("zoomed", { viewport: this.parent, original: e, type: "animate" });
    } else {
      const n = this.options.ease(this.time, 0, 1, this.options.time);
      if (this.width !== null) {
        const i = this.startWidth, s = this.deltaWidth;
        this.parent.fitWidth(
          i + s * n,
          this.keepCenter,
          this.height === null
        );
      }
      if (this.height !== null) {
        const i = this.startHeight, s = this.deltaHeight;
        this.parent.fitHeight(
          i + s * n,
          this.keepCenter,
          this.width === null
        );
      }
      if (this.width === null ? this.parent.scale.x = this.parent.scale.y : this.height === null && (this.parent.scale.y = this.parent.scale.x), !this.keepCenter) {
        const i = this.startX, s = this.startY, h = this.deltaX, o = this.deltaY, r = new Point(this.parent.x, this.parent.y);
        this.parent.moveCenter(i + h * n, s + o * n), this.parent.emit("moved", { viewport: this.parent, original: r, type: "animate" });
      }
      (this.width || this.height) && this.parent.emit("zoomed", { viewport: this.parent, original: e, type: "animate" });
    }
  }
};
var I = {
  sides: "all",
  friction: 0.5,
  time: 150,
  ease: "easeInOutSine",
  underflow: "center",
  bounceBox: null
};
var k = class extends u {
  /**
   * This is called by {@link Viewport.bounce}.
   */
  constructor(t, e = {}) {
    super(t), this.options = Object.assign({}, I, e), this.ease = x(this.options.ease, "easeInOutSine"), this.options.sides ? this.options.sides === "all" ? this.top = this.bottom = this.left = this.right = true : this.options.sides === "horizontal" ? (this.right = this.left = true, this.top = this.bottom = false) : this.options.sides === "vertical" ? (this.left = this.right = false, this.top = this.bottom = true) : (this.top = this.options.sides.indexOf("top") !== -1, this.bottom = this.options.sides.indexOf("bottom") !== -1, this.left = this.options.sides.indexOf("left") !== -1, this.right = this.options.sides.indexOf("right") !== -1) : this.left = this.top = this.right = this.bottom = false;
    const n = this.options.underflow.toLowerCase();
    n === "center" ? (this.underflowX = 0, this.underflowY = 0) : (this.underflowX = n.indexOf("left") !== -1 ? -1 : n.indexOf("right") !== -1 ? 1 : 0, this.underflowY = n.indexOf("top") !== -1 ? -1 : n.indexOf("bottom") !== -1 ? 1 : 0), this.reset();
  }
  isActive() {
    return this.toX !== null || this.toY !== null;
  }
  down() {
    return this.toX = this.toY = null, false;
  }
  up() {
    return this.bounce(), false;
  }
  update(t) {
    if (!this.paused) {
      if (this.bounce(), this.toX) {
        const e = this.toX;
        e.time += t, this.parent.emit("moved", { viewport: this.parent, type: "bounce-x" }), e.time >= this.options.time ? (this.parent.x = e.end, this.toX = null, this.parent.emit("bounce-x-end", this.parent)) : this.parent.x = this.ease(e.time, e.start, e.delta, this.options.time);
      }
      if (this.toY) {
        const e = this.toY;
        e.time += t, this.parent.emit("moved", { viewport: this.parent, type: "bounce-y" }), e.time >= this.options.time ? (this.parent.y = e.end, this.toY = null, this.parent.emit("bounce-y-end", this.parent)) : this.parent.y = this.ease(e.time, e.start, e.delta, this.options.time);
      }
    }
  }
  /** @internal */
  calcUnderflowX() {
    let t;
    switch (this.underflowX) {
      case -1:
        t = 0;
        break;
      case 1:
        t = this.parent.screenWidth - this.parent.screenWorldWidth;
        break;
      default:
        t = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
    }
    return t;
  }
  /** @internal */
  calcUnderflowY() {
    let t;
    switch (this.underflowY) {
      case -1:
        t = 0;
        break;
      case 1:
        t = this.parent.screenHeight - this.parent.screenWorldHeight;
        break;
      default:
        t = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
    }
    return t;
  }
  oob() {
    const t = this.options.bounceBox;
    if (t) {
      const e = typeof t.x > "u" ? 0 : t.x, n = typeof t.y > "u" ? 0 : t.y, i = typeof t.width > "u" ? this.parent.worldWidth : t.width, s = typeof t.height > "u" ? this.parent.worldHeight : t.height;
      return {
        left: this.parent.left < e,
        right: this.parent.right > i,
        top: this.parent.top < n,
        bottom: this.parent.bottom > s,
        topLeft: new Point(
          e * this.parent.scale.x,
          n * this.parent.scale.y
        ),
        bottomRight: new Point(
          i * this.parent.scale.x - this.parent.screenWidth,
          s * this.parent.scale.y - this.parent.screenHeight
        )
      };
    }
    return {
      left: this.parent.left < 0,
      right: this.parent.right > this.parent.worldWidth,
      top: this.parent.top < 0,
      bottom: this.parent.bottom > this.parent.worldHeight,
      topLeft: new Point(0, 0),
      bottomRight: new Point(
        this.parent.worldWidth * this.parent.scale.x - this.parent.screenWidth,
        this.parent.worldHeight * this.parent.scale.y - this.parent.screenHeight
      )
    };
  }
  bounce() {
    var s, h;
    if (this.paused)
      return;
    let t, e = this.parent.plugins.get("decelerate", true);
    e && (e.x || e.y) && (e.x && e.percentChangeX === ((s = e.options) == null ? void 0 : s.friction) || e.y && e.percentChangeY === ((h = e.options) == null ? void 0 : h.friction)) && (t = this.oob(), (t.left && this.left || t.right && this.right) && (e.percentChangeX = this.options.friction), (t.top && this.top || t.bottom && this.bottom) && (e.percentChangeY = this.options.friction));
    const n = this.parent.plugins.get("drag", true) || {}, i = this.parent.plugins.get("pinch", true) || {};
    if (e = e || {}, !(n != null && n.active) && !(i != null && i.active) && (!this.toX || !this.toY) && (!e.x || !e.y)) {
      t = t || this.oob();
      const o = t.topLeft, r = t.bottomRight;
      if (!this.toX && !e.x) {
        let a = null;
        t.left && this.left ? a = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -o.x : t.right && this.right && (a = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -r.x), a !== null && this.parent.x !== a && (this.toX = { time: 0, start: this.parent.x, delta: a - this.parent.x, end: a }, this.parent.emit("bounce-x-start", this.parent));
      }
      if (!this.toY && !e.y) {
        let a = null;
        t.top && this.top ? a = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -o.y : t.bottom && this.bottom && (a = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -r.y), a !== null && this.parent.y !== a && (this.toY = { time: 0, start: this.parent.y, delta: a - this.parent.y, end: a }, this.parent.emit("bounce-y-start", this.parent));
      }
    }
  }
  reset() {
    this.toX = this.toY = null, this.bounce();
  }
};
var Y = {
  left: false,
  right: false,
  top: false,
  bottom: false,
  direction: null,
  underflow: "center"
};
var X = class extends u {
  /**
   * This is called by {@link Viewport.clamp}.
   */
  constructor(t, e = {}) {
    super(t), this.options = Object.assign({}, Y, e), this.options.direction && (this.options.left = this.options.direction === "x" || this.options.direction === "all" ? true : null, this.options.right = this.options.direction === "x" || this.options.direction === "all" ? true : null, this.options.top = this.options.direction === "y" || this.options.direction === "all" ? true : null, this.options.bottom = this.options.direction === "y" || this.options.direction === "all" ? true : null), this.parseUnderflow(), this.last = { x: null, y: null, scaleX: null, scaleY: null }, this.update();
  }
  parseUnderflow() {
    const t = this.options.underflow.toLowerCase();
    t === "none" ? this.noUnderflow = true : t === "center" ? (this.underflowX = this.underflowY = 0, this.noUnderflow = false) : (this.underflowX = t.indexOf("left") !== -1 ? -1 : t.indexOf("right") !== -1 ? 1 : 0, this.underflowY = t.indexOf("top") !== -1 ? -1 : t.indexOf("bottom") !== -1 ? 1 : 0, this.noUnderflow = false);
  }
  move() {
    return this.update(), false;
  }
  update() {
    if (this.paused || this.parent.x === this.last.x && this.parent.y === this.last.y && this.parent.scale.x === this.last.scaleX && this.parent.scale.y === this.last.scaleY)
      return;
    const t = new Point(this.parent.x, this.parent.y), e = this.parent.plugins.decelerate || {};
    if (this.options.left !== null || this.options.right !== null) {
      let n = false;
      if (!this.noUnderflow && this.parent.screenWorldWidth < this.parent.screenWidth)
        switch (this.underflowX) {
          case -1:
            this.parent.x !== 0 && (this.parent.x = 0, n = true);
            break;
          case 1:
            this.parent.x !== this.parent.screenWidth - this.parent.screenWorldWidth && (this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth, n = true);
            break;
          default:
            this.parent.x !== (this.parent.screenWidth - this.parent.screenWorldWidth) / 2 && (this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2, n = true);
        }
      else
        this.options.left !== null && this.parent.left < (this.options.left === true ? 0 : this.options.left) && (this.parent.x = -(this.options.left === true ? 0 : this.options.left) * this.parent.scale.x, e.x = 0, n = true), this.options.right !== null && this.parent.right > (this.options.right === true ? this.parent.worldWidth : this.options.right) && (this.parent.x = -(this.options.right === true ? this.parent.worldWidth : this.options.right) * this.parent.scale.x + this.parent.screenWidth, e.x = 0, n = true);
      n && this.parent.emit("moved", { viewport: this.parent, original: t, type: "clamp-x" });
    }
    if (this.options.top !== null || this.options.bottom !== null) {
      let n = false;
      if (!this.noUnderflow && this.parent.screenWorldHeight < this.parent.screenHeight)
        switch (this.underflowY) {
          case -1:
            this.parent.y !== 0 && (this.parent.y = 0, n = true);
            break;
          case 1:
            this.parent.y !== this.parent.screenHeight - this.parent.screenWorldHeight && (this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight, n = true);
            break;
          default:
            this.parent.y !== (this.parent.screenHeight - this.parent.screenWorldHeight) / 2 && (this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2, n = true);
        }
      else
        this.options.top !== null && this.parent.top < (this.options.top === true ? 0 : this.options.top) && (this.parent.y = -(this.options.top === true ? 0 : this.options.top) * this.parent.scale.y, e.y = 0, n = true), this.options.bottom !== null && this.parent.bottom > (this.options.bottom === true ? this.parent.worldHeight : this.options.bottom) && (this.parent.y = -(this.options.bottom === true ? this.parent.worldHeight : this.options.bottom) * this.parent.scale.y + this.parent.screenHeight, e.y = 0, n = true);
      n && this.parent.emit("moved", { viewport: this.parent, original: t, type: "clamp-y" });
    }
    this.last.x = this.parent.x, this.last.y = this.parent.y, this.last.scaleX = this.parent.scale.x, this.last.scaleY = this.parent.scale.y;
  }
  reset() {
    this.update();
  }
};
var z = {
  minWidth: null,
  minHeight: null,
  maxWidth: null,
  maxHeight: null,
  minScale: null,
  maxScale: null
};
var A = class extends u {
  /**
   * This is called by {@link Viewport.clampZoom}.
   */
  constructor(t, e = {}) {
    super(t), this.options = Object.assign({}, z, e), this.clamp();
  }
  resize() {
    this.clamp();
  }
  /** Clamp the viewport scale zoom) */
  clamp() {
    if (!this.paused) {
      if (this.options.minWidth || this.options.minHeight || this.options.maxWidth || this.options.maxHeight) {
        let t = this.parent.worldScreenWidth, e = this.parent.worldScreenHeight;
        if (this.options.minWidth !== null && t < this.options.minWidth) {
          const n = this.parent.scale.x;
          this.parent.fitWidth(this.options.minWidth, false, false, true), this.parent.scale.y *= this.parent.scale.x / n, t = this.parent.worldScreenWidth, e = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.maxWidth !== null && t > this.options.maxWidth) {
          const n = this.parent.scale.x;
          this.parent.fitWidth(this.options.maxWidth, false, false, true), this.parent.scale.y *= this.parent.scale.x / n, t = this.parent.worldScreenWidth, e = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.minHeight !== null && e < this.options.minHeight) {
          const n = this.parent.scale.y;
          this.parent.fitHeight(this.options.minHeight, false, false, true), this.parent.scale.x *= this.parent.scale.y / n, t = this.parent.worldScreenWidth, e = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.maxHeight !== null && e > this.options.maxHeight) {
          const n = this.parent.scale.y;
          this.parent.fitHeight(this.options.maxHeight, false, false, true), this.parent.scale.x *= this.parent.scale.y / n, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
      } else if (this.options.minScale || this.options.maxScale) {
        const t = { x: null, y: null }, e = { x: null, y: null };
        if (typeof this.options.minScale == "number")
          t.x = this.options.minScale, t.y = this.options.minScale;
        else if (this.options.minScale !== null) {
          const s = this.options.minScale;
          t.x = typeof s.x > "u" ? null : s.x, t.y = typeof s.y > "u" ? null : s.y;
        }
        if (typeof this.options.maxScale == "number")
          e.x = this.options.maxScale, e.y = this.options.maxScale;
        else if (this.options.maxScale !== null) {
          const s = this.options.maxScale;
          e.x = typeof s.x > "u" ? null : s.x, e.y = typeof s.y > "u" ? null : s.y;
        }
        let n = this.parent.scale.x, i = this.parent.scale.y;
        t.x !== null && n < t.x && (n = t.x), e.x !== null && n > e.x && (n = e.x), t.y !== null && i < t.y && (i = t.y), e.y !== null && i > e.y && (i = e.y), (n !== this.parent.scale.x || i !== this.parent.scale.y) && (this.parent.scale.set(n, i), this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" }));
      }
    }
  }
  reset() {
    this.clamp();
  }
};
var _ = {
  friction: 0.98,
  bounce: 0.8,
  minSpeed: 0.01
};
var d = 16;
var T = class extends u {
  /**
   * This is called by {@link Viewport.decelerate}.
   */
  constructor(t, e = {}) {
    super(t), this.options = Object.assign({}, _, e), this.saved = [], this.timeSinceRelease = 0, this.reset(), this.parent.on("moved", (n) => this.handleMoved(n));
  }
  down() {
    return this.saved = [], this.x = this.y = null, false;
  }
  isActive() {
    return !!(this.x || this.y);
  }
  move() {
    if (this.paused)
      return false;
    const t = this.parent.input.count();
    return (t === 1 || t > 1 && !this.parent.plugins.get("pinch", true)) && (this.saved.push({ x: this.parent.x, y: this.parent.y, time: performance.now() }), this.saved.length > 60 && this.saved.splice(0, 30)), false;
  }
  /** Listener to viewport's "moved" event. */
  handleMoved(t) {
    if (this.saved.length) {
      const e = this.saved[this.saved.length - 1];
      t.type === "clamp-x" && t.original ? e.x === t.original.x && (e.x = this.parent.x) : t.type === "clamp-y" && t.original && e.y === t.original.y && (e.y = this.parent.y);
    }
  }
  up() {
    if (this.parent.input.count() === 0 && this.saved.length) {
      const t = performance.now();
      for (const e of this.saved)
        if (e.time >= t - 100) {
          const n = t - e.time;
          this.x = (this.parent.x - e.x) / n, this.y = (this.parent.y - e.y) / n, this.percentChangeX = this.percentChangeY = this.options.friction, this.timeSinceRelease = 0;
          break;
        }
    }
    return false;
  }
  /**
   * Manually activate deceleration, starting from the (x, y) velocity components passed in the options.
   *
   * @param {object} options
   * @param {number} [options.x] - Specify x-component of initial velocity.
   * @param {number} [options.y] - Specify y-component of initial velocity.
   */
  activate(t) {
    t = t || {}, typeof t.x < "u" && (this.x = t.x, this.percentChangeX = this.options.friction), typeof t.y < "u" && (this.y = t.y, this.percentChangeY = this.options.friction);
  }
  update(t) {
    if (this.paused)
      return;
    const e = this.x || this.y, n = this.timeSinceRelease, i = this.timeSinceRelease + t;
    if (this.x) {
      const s = this.percentChangeX, h = Math.log(s);
      this.parent.x += this.x * d / h * (Math.pow(s, i / d) - Math.pow(s, n / d)), this.x *= Math.pow(this.percentChangeX, t / d);
    }
    if (this.y) {
      const s = this.percentChangeY, h = Math.log(s);
      this.parent.y += this.y * d / h * (Math.pow(s, i / d) - Math.pow(s, n / d)), this.y *= Math.pow(this.percentChangeY, t / d);
    }
    this.timeSinceRelease += t, this.x && this.y ? Math.abs(this.x) < this.options.minSpeed && Math.abs(this.y) < this.options.minSpeed && (this.x = 0, this.y = 0) : (Math.abs(this.x || 0) < this.options.minSpeed && (this.x = 0), Math.abs(this.y || 0) < this.options.minSpeed && (this.y = 0)), e && this.parent.emit("moved", { viewport: this.parent, type: "decelerate" });
  }
  reset() {
    this.x = this.y = null;
  }
};
var E = {
  direction: "all",
  pressDrag: true,
  wheel: true,
  wheelScroll: 1,
  reverse: false,
  clampWheel: false,
  underflow: "center",
  factor: 1,
  mouseButtons: "all",
  keyToPress: null,
  ignoreKeyToPressOnTouch: false,
  lineHeight: 20,
  wheelSwapAxes: false
};
var D = class extends u {
  /**
   * This is called by {@link Viewport.drag}.
   */
  constructor(t, e = {}) {
    super(t), this.windowEventHandlers = [], this.options = Object.assign({}, E, e), this.moved = false, this.reverse = this.options.reverse ? 1 : -1, this.xDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "x", this.yDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "y", this.keyIsPressed = false, this.parseUnderflow(), this.mouseButtons(this.options.mouseButtons), this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress);
  }
  /**
   * Handles keypress events and set the keyIsPressed boolean accordingly
   *
   * @param {array} codes - key codes that can be used to trigger drag event
   */
  handleKeyPresses(t) {
    const e = (i) => {
      t.includes(i.code) && (this.keyIsPressed = true);
    }, n = (i) => {
      t.includes(i.code) && (this.keyIsPressed = false);
    };
    this.addWindowEventHandler("keyup", n), this.addWindowEventHandler("keydown", e);
  }
  addWindowEventHandler(t, e) {
    typeof window > "u" || (window.addEventListener(t, e), this.windowEventHandlers.push({ event: t, handler: e }));
  }
  destroy() {
    typeof window > "u" || this.windowEventHandlers.forEach(({ event: t, handler: e }) => {
      window.removeEventListener(t, e);
    });
  }
  /**
   * initialize mousebuttons array
   * @param {string} buttons
   */
  mouseButtons(t) {
    !t || t === "all" ? this.mouse = [true, true, true] : this.mouse = [
      t.indexOf("left") !== -1,
      t.indexOf("middle") !== -1,
      t.indexOf("right") !== -1
    ];
  }
  parseUnderflow() {
    const t = this.options.underflow.toLowerCase();
    t === "center" ? (this.underflowX = 0, this.underflowY = 0) : (t.includes("left") ? this.underflowX = -1 : t.includes("right") ? this.underflowX = 1 : this.underflowX = 0, t.includes("top") ? this.underflowY = -1 : t.includes("bottom") ? this.underflowY = 1 : this.underflowY = 0);
  }
  /**
   * @param {PIXI.FederatedPointerEvent} event
   * @returns {boolean}
   */
  checkButtons(t) {
    const e = t.pointerType === "mouse", n = this.parent.input.count();
    return !!((n === 1 || n > 1 && !this.parent.plugins.get("pinch", true)) && (!e || this.mouse[t.button]));
  }
  /**
   * @param {PIXI.FederatedPointerEvent} event
   * @returns {boolean}
   */
  checkKeyPress(t) {
    return !this.options.keyToPress || this.keyIsPressed || this.options.ignoreKeyToPressOnTouch && t.data.pointerType === "touch";
  }
  down(t) {
    return this.paused || !this.options.pressDrag ? false : this.checkButtons(t) && this.checkKeyPress(t) ? (this.last = { x: t.global.x, y: t.global.y }, this.current = t.pointerId, true) : (this.last = null, false);
  }
  get active() {
    return this.moved;
  }
  move(t) {
    if (this.paused || !this.options.pressDrag)
      return false;
    if (this.last && this.current === t.data.pointerId) {
      const e = t.global.x, n = t.global.y, i = this.parent.input.count();
      if (i === 1 || i > 1 && !this.parent.plugins.get("pinch", true)) {
        const s = e - this.last.x, h = n - this.last.y;
        if (this.moved || this.xDirection && this.parent.input.checkThreshold(s) || this.yDirection && this.parent.input.checkThreshold(h)) {
          const o = { x: e, y: n };
          return this.xDirection && (this.parent.x += (o.x - this.last.x) * this.options.factor), this.yDirection && (this.parent.y += (o.y - this.last.y) * this.options.factor), this.last = o, this.moved || this.parent.emit("drag-start", {
            event: t,
            screen: new Point(this.last.x, this.last.y),
            world: this.parent.toWorld(new Point(this.last.x, this.last.y)),
            viewport: this.parent
          }), this.moved = true, this.parent.emit("moved", { viewport: this.parent, type: "drag" }), true;
        }
      } else
        this.moved = false;
    }
    return false;
  }
  up(t) {
    if (this.paused)
      return false;
    const e = this.parent.input.touches;
    if (e.length === 1) {
      const n = e[0];
      return n.last && (this.last = { x: n.last.x, y: n.last.y }, this.current = n.id), this.moved = false, true;
    } else if (this.last && this.moved) {
      const n = new Point(this.last.x, this.last.y);
      return this.parent.emit("drag-end", {
        event: t,
        screen: n,
        world: this.parent.toWorld(n),
        viewport: this.parent
      }), this.last = null, this.moved = false, true;
    }
    return false;
  }
  wheel(t) {
    if (this.paused)
      return false;
    if (this.options.wheel) {
      const e = this.parent.plugins.get("wheel", true);
      if (!e || !e.options.wheelZoom && !t.ctrlKey) {
        const n = t.deltaMode ? this.options.lineHeight : 1, i = [t.deltaX, t.deltaY], [s, h] = this.options.wheelSwapAxes ? i.reverse() : i;
        return this.xDirection && (this.parent.x += s * n * this.options.wheelScroll * this.reverse), this.yDirection && (this.parent.y += h * n * this.options.wheelScroll * this.reverse), this.options.clampWheel && this.clamp(), this.parent.emit("wheel-scroll", this.parent), this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.options.passiveWheel || t.preventDefault(), this.parent.options.stopPropagation && t.stopPropagation(), true;
      }
    }
    return false;
  }
  resume() {
    this.last = null, this.paused = false;
  }
  clamp() {
    const t = this.parent.plugins.get("decelerate", true) || {};
    if (this.options.clampWheel !== "y")
      if (this.parent.screenWorldWidth < this.parent.screenWidth)
        switch (this.underflowX) {
          case -1:
            this.parent.x = 0;
            break;
          case 1:
            this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth;
            break;
          default:
            this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
        }
      else
        this.parent.left < 0 ? (this.parent.x = 0, t.x = 0) : this.parent.right > this.parent.worldWidth && (this.parent.x = -this.parent.worldWidth * this.parent.scale.x + this.parent.screenWidth, t.x = 0);
    if (this.options.clampWheel !== "x")
      if (this.parent.screenWorldHeight < this.parent.screenHeight)
        switch (this.underflowY) {
          case -1:
            this.parent.y = 0;
            break;
          case 1:
            this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight;
            break;
          default:
            this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
        }
      else
        this.parent.top < 0 && (this.parent.y = 0, t.y = 0), this.parent.bottom > this.parent.worldHeight && (this.parent.y = -this.parent.worldHeight * this.parent.scale.y + this.parent.screenHeight, t.y = 0);
  }
};
var L = {
  speed: 0,
  acceleration: null,
  radius: null
};
var U = class extends u {
  /**
   * This is called by {@link Viewport.follow}.
   *
   * @param parent
   * @param target - target to follow
   * @param options
   */
  constructor(t, e, n = {}) {
    super(t), this.target = e, this.options = Object.assign({}, L, n), this.velocity = { x: 0, y: 0 };
  }
  update(t) {
    if (this.paused)
      return;
    const e = this.parent.center;
    let n = this.target.x, i = this.target.y;
    if (this.options.radius)
      if (Math.sqrt(Math.pow(this.target.y - e.y, 2) + Math.pow(this.target.x - e.x, 2)) > this.options.radius) {
        const r = Math.atan2(this.target.y - e.y, this.target.x - e.x);
        n = this.target.x - Math.cos(r) * this.options.radius, i = this.target.y - Math.sin(r) * this.options.radius;
      } else
        return;
    const s = n - e.x, h = i - e.y;
    if (s || h)
      if (this.options.speed)
        if (this.options.acceleration) {
          const o = Math.atan2(i - e.y, n - e.x), r = Math.sqrt(Math.pow(s, 2) + Math.pow(h, 2));
          if (r) {
            const a = (Math.pow(this.velocity.x, 2) + Math.pow(this.velocity.y, 2)) / (2 * this.options.acceleration);
            r > a ? this.velocity = {
              x: Math.min(this.velocity.x + (this.options.acceleration * t, this.options.speed)),
              y: Math.min(this.velocity.y + (this.options.acceleration * t, this.options.speed))
            } : this.velocity = {
              x: Math.max(this.velocity.x - this.options.acceleration * this.options.speed, 0),
              y: Math.max(this.velocity.y - this.options.acceleration * this.options.speed, 0)
            };
            const p = Math.cos(o) * this.velocity.x, f = Math.sin(o) * this.velocity.y, g = Math.abs(p) > Math.abs(s) ? n : e.x + p, w = Math.abs(f) > Math.abs(h) ? i : e.y + f;
            this.parent.moveCenter(g, w), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
          }
        } else {
          const o = Math.atan2(i - e.y, n - e.x), r = Math.cos(o) * this.options.speed, a = Math.sin(o) * this.options.speed, p = Math.abs(r) > Math.abs(s) ? n : e.x + r, f = Math.abs(a) > Math.abs(h) ? i : e.y + a;
          this.parent.moveCenter(p, f), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
        }
      else
        this.parent.moveCenter(n, i), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
  }
};
var F = {
  radius: null,
  distance: null,
  top: null,
  bottom: null,
  left: null,
  right: null,
  speed: 8,
  reverse: false,
  noDecelerate: false,
  linear: false,
  allowButtons: false
};
var B = class extends u {
  /**
   * This is called by {@link Viewport.mouseEdges}.
   */
  constructor(t, e = {}) {
    super(t), this.options = Object.assign({}, F, e), this.reverse = this.options.reverse ? 1 : -1, this.radiusSquared = typeof this.options.radius == "number" ? Math.pow(this.options.radius, 2) : null, this.resize();
  }
  resize() {
    const t = this.options.distance;
    t !== null ? (this.left = t, this.top = t, this.right = this.parent.screenWidth - t, this.bottom = this.parent.screenHeight - t) : this.options.radius || (this.left = this.options.left, this.top = this.options.top, this.right = this.options.right === null ? null : this.parent.screenWidth - this.options.right, this.bottom = this.options.bottom === null ? null : this.parent.screenHeight - this.options.bottom);
  }
  down() {
    return this.paused || this.options.allowButtons || (this.horizontal = this.vertical = null), false;
  }
  move(t) {
    if (this.paused || t.pointerType !== "mouse" && t.pointerId !== 1 || !this.options.allowButtons && t.buttons !== 0)
      return false;
    const e = t.global.x, n = t.global.y;
    if (this.radiusSquared) {
      const i = this.parent.toScreen(this.parent.center);
      if (Math.pow(i.x - e, 2) + Math.pow(i.y - n, 2) >= this.radiusSquared) {
        const h = Math.atan2(i.y - n, i.x - e);
        this.options.linear ? (this.horizontal = Math.round(Math.cos(h)) * this.options.speed * this.reverse * (60 / 1e3), this.vertical = Math.round(Math.sin(h)) * this.options.speed * this.reverse * (60 / 1e3)) : (this.horizontal = Math.cos(h) * this.options.speed * this.reverse * (60 / 1e3), this.vertical = Math.sin(h) * this.options.speed * this.reverse * (60 / 1e3));
      } else
        this.horizontal && this.decelerateHorizontal(), this.vertical && this.decelerateVertical(), this.horizontal = this.vertical = 0;
    } else
      this.left !== null && e < this.left ? this.horizontal = Number(this.reverse) * this.options.speed * (60 / 1e3) : this.right !== null && e > this.right ? this.horizontal = -1 * this.reverse * this.options.speed * (60 / 1e3) : (this.decelerateHorizontal(), this.horizontal = 0), this.top !== null && n < this.top ? this.vertical = Number(this.reverse) * this.options.speed * (60 / 1e3) : this.bottom !== null && n > this.bottom ? this.vertical = -1 * this.reverse * this.options.speed * (60 / 1e3) : (this.decelerateVertical(), this.vertical = 0);
    return false;
  }
  decelerateHorizontal() {
    const t = this.parent.plugins.get("decelerate", true);
    this.horizontal && t && !this.options.noDecelerate && t.activate({ x: this.horizontal * this.options.speed * this.reverse / (1e3 / 60) });
  }
  decelerateVertical() {
    const t = this.parent.plugins.get("decelerate", true);
    this.vertical && t && !this.options.noDecelerate && t.activate({ y: this.vertical * this.options.speed * this.reverse / (1e3 / 60) });
  }
  up() {
    return this.paused || (this.horizontal && this.decelerateHorizontal(), this.vertical && this.decelerateVertical(), this.horizontal = this.vertical = null), false;
  }
  update() {
    if (!this.paused && (this.horizontal || this.vertical)) {
      const t = this.parent.center;
      this.horizontal && (t.x += this.horizontal * this.options.speed), this.vertical && (t.y += this.vertical * this.options.speed), this.parent.moveCenter(t), this.parent.emit("moved", { viewport: this.parent, type: "mouse-edges" });
    }
  }
};
var V = {
  noDrag: false,
  percent: 1,
  center: null,
  factor: 1,
  axis: "all"
};
var N = class extends u {
  /**
   * This is called by {@link Viewport.pinch}.
   */
  constructor(t, e = {}) {
    super(t), this.active = false, this.pinching = false, this.moved = false, this.options = Object.assign({}, V, e);
  }
  down() {
    return this.parent.input.count() >= 2 ? (this.active = true, true) : false;
  }
  isAxisX() {
    return ["all", "x"].includes(this.options.axis);
  }
  isAxisY() {
    return ["all", "y"].includes(this.options.axis);
  }
  move(t) {
    if (this.paused || !this.active)
      return false;
    const e = t.global.x, n = t.global.y, i = this.parent.input.touches;
    if (i.length >= 2) {
      const s = i[0], h = i[1], o = s.last && h.last ? Math.sqrt(Math.pow(h.last.x - s.last.x, 2) + Math.pow(h.last.y - s.last.y, 2)) : null;
      if (s.id === t.pointerId ? s.last = { x: e, y: n, data: t } : h.id === t.pointerId && (h.last = { x: e, y: n, data: t }), o) {
        let r;
        const a = new Point(
          s.last.x + (h.last.x - s.last.x) / 2,
          s.last.y + (h.last.y - s.last.y) / 2
        );
        this.options.center || (r = this.parent.toLocal(a));
        let p = Math.sqrt(Math.pow(
          h.last.x - s.last.x,
          2
        ) + Math.pow(h.last.y - s.last.y, 2));
        p = p === 0 ? p = 1e-10 : p;
        const f = (1 - o / p) * this.options.percent * (this.isAxisX() ? this.parent.scale.x : this.parent.scale.y);
        this.isAxisX() && (this.parent.scale.x += f), this.isAxisY() && (this.parent.scale.y += f), this.parent.emit("zoomed", { viewport: this.parent, type: "pinch", center: a });
        const g = this.parent.plugins.get("clamp-zoom", true);
        if (g && g.clamp(), this.options.center)
          this.parent.moveCenter(this.options.center);
        else {
          const w = this.parent.toGlobal(r);
          this.parent.x += (a.x - w.x) * this.options.factor, this.parent.y += (a.y - w.y) * this.options.factor, this.parent.emit("moved", { viewport: this.parent, type: "pinch" });
        }
        !this.options.noDrag && this.lastCenter && (this.parent.x += (a.x - this.lastCenter.x) * this.options.factor, this.parent.y += (a.y - this.lastCenter.y) * this.options.factor, this.parent.emit("moved", { viewport: this.parent, type: "pinch" })), this.lastCenter = a, this.moved = true;
      } else
        this.pinching || (this.parent.emit("pinch-start", this.parent), this.pinching = true);
      return true;
    }
    return false;
  }
  up() {
    return this.pinching && this.parent.input.touches.length <= 1 ? (this.active = false, this.lastCenter = null, this.pinching = false, this.moved = false, this.parent.emit("pinch-end", this.parent), true) : false;
  }
};
var Z = {
  topLeft: false,
  friction: 0.8,
  time: 1e3,
  ease: "easeInOutSine",
  interrupt: true,
  removeOnComplete: false,
  removeOnInterrupt: false,
  forceStart: false
};
var j = class extends u {
  /**
   * This is called by {@link Viewport.snap}.
   */
  constructor(t, e, n, i = {}) {
    super(t), this.options = Object.assign({}, Z, i), this.ease = x(i.ease, "easeInOutSine"), this.x = e, this.y = n, this.options.forceStart && this.snapStart();
  }
  snapStart() {
    this.percent = 0, this.snapping = { time: 0 };
    const t = this.options.topLeft ? this.parent.corner : this.parent.center;
    this.deltaX = this.x - t.x, this.deltaY = this.y - t.y, this.startX = t.x, this.startY = t.y, this.parent.emit("snap-start", this.parent);
  }
  wheel() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("snap"), false;
  }
  down() {
    return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap") : this.options.interrupt && (this.snapping = null), false;
  }
  up() {
    if (this.parent.input.count() === 0) {
      const t = this.parent.plugins.get("decelerate", true);
      t && (t.x || t.y) && (t.percentChangeX = t.percentChangeY = this.options.friction);
    }
    return false;
  }
  update(t) {
    if (!this.paused && !(this.options.interrupt && this.parent.input.count() !== 0))
      if (this.snapping) {
        const e = this.snapping;
        e.time += t;
        let n, i, s;
        const h = this.startX, o = this.startY, r = this.deltaX, a = this.deltaY;
        if (e.time > this.options.time)
          n = true, i = h + r, s = o + a;
        else {
          const p = this.ease(e.time, 0, 1, this.options.time);
          i = h + r * p, s = o + a * p;
        }
        this.options.topLeft ? this.parent.moveCorner(i, s) : this.parent.moveCenter(i, s), this.parent.emit("moved", { viewport: this.parent, type: "snap" }), n && (this.options.removeOnComplete && this.parent.plugins.remove("snap"), this.parent.emit("snap-end", this.parent), this.snapping = null);
      } else {
        const e = this.options.topLeft ? this.parent.corner : this.parent.center;
        (e.x !== this.x || e.y !== this.y) && this.snapStart();
      }
  }
};
var R = {
  width: 0,
  height: 0,
  time: 1e3,
  ease: "easeInOutSine",
  center: null,
  interrupt: true,
  removeOnComplete: false,
  removeOnInterrupt: false,
  forceStart: false,
  noMove: false
};
var K = class extends u {
  /**
   * This is called by {@link Viewport.snapZoom}.
   */
  constructor(t, e = {}) {
    super(t), this.options = Object.assign({}, R, e), this.ease = x(this.options.ease), this.xIndependent = false, this.yIndependent = false, this.xScale = 0, this.yScale = 0, this.options.width > 0 && (this.xScale = t.screenWidth / this.options.width, this.xIndependent = true), this.options.height > 0 && (this.yScale = t.screenHeight / this.options.height, this.yIndependent = true), this.xScale = this.xIndependent ? this.xScale : this.yScale, this.yScale = this.yIndependent ? this.yScale : this.xScale, this.options.time === 0 ? (t.container.scale.x = this.xScale, t.container.scale.y = this.yScale, this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom")) : e.forceStart && this.createSnapping();
  }
  createSnapping() {
    const t = this.parent.worldScreenWidth, e = this.parent.worldScreenHeight, n = this.parent.screenWidth / this.xScale, i = this.parent.screenHeight / this.yScale;
    this.snapping = {
      time: 0,
      startX: t,
      startY: e,
      deltaX: n - t,
      deltaY: i - e
    }, this.parent.emit("snap-zoom-start", this.parent);
  }
  resize() {
    this.snapping = null, this.options.width > 0 && (this.xScale = this.parent.screenWidth / this.options.width), this.options.height > 0 && (this.yScale = this.parent.screenHeight / this.options.height), this.xScale = this.xIndependent ? this.xScale : this.yScale, this.yScale = this.yIndependent ? this.yScale : this.xScale;
  }
  wheel() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("snap-zoom"), false;
  }
  down() {
    return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap-zoom") : this.options.interrupt && (this.snapping = null), false;
  }
  update(t) {
    if (this.paused || this.options.interrupt && this.parent.input.count() !== 0)
      return;
    let e;
    if (!this.options.center && !this.options.noMove && (e = this.parent.center), !this.snapping)
      (this.parent.scale.x !== this.xScale || this.parent.scale.y !== this.yScale) && this.createSnapping();
    else if (this.snapping) {
      const n = this.snapping;
      if (n.time += t, n.time >= this.options.time)
        this.parent.scale.set(this.xScale, this.yScale), this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom"), this.parent.emit("snap-zoom-end", this.parent), this.snapping = null;
      else {
        const s = this.snapping, h = this.ease(s.time, s.startX, s.deltaX, this.options.time), o = this.ease(s.time, s.startY, s.deltaY, this.options.time);
        this.parent.scale.x = this.parent.screenWidth / h, this.parent.scale.y = this.parent.screenHeight / o;
      }
      const i = this.parent.plugins.get("clamp-zoom", true);
      i && i.clamp(), this.options.noMove || (this.options.center ? this.parent.moveCenter(this.options.center) : this.parent.moveCenter(e));
    }
  }
  resume() {
    this.snapping = null, super.resume();
  }
};
var q = {
  percent: 0.1,
  smooth: false,
  interrupt: true,
  reverse: false,
  center: null,
  lineHeight: 20,
  axis: "all",
  keyToPress: null,
  trackpadPinch: false,
  wheelZoom: true
};
var G = class extends u {
  /**
   * This is called by {@link Viewport.wheel}.
   */
  constructor(t, e = {}) {
    super(t), this.options = Object.assign({}, q, e), this.keyIsPressed = false, this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress);
  }
  /**
   * Handles keypress events and set the keyIsPressed boolean accordingly
   *
   * @param {array} codes - key codes that can be used to trigger zoom event
   */
  handleKeyPresses(t) {
    typeof window > "u" || (window.addEventListener("keydown", (e) => {
      t.includes(e.code) && (this.keyIsPressed = true);
    }), window.addEventListener("keyup", (e) => {
      t.includes(e.code) && (this.keyIsPressed = false);
    }));
  }
  checkKeyPress() {
    return !this.options.keyToPress || this.keyIsPressed;
  }
  down() {
    return this.options.interrupt && (this.smoothing = null), false;
  }
  isAxisX() {
    return ["all", "x"].includes(this.options.axis);
  }
  isAxisY() {
    return ["all", "y"].includes(this.options.axis);
  }
  update() {
    if (this.smoothing) {
      const t = this.smoothingCenter, e = this.smoothing;
      let n;
      this.options.center || (n = this.parent.toLocal(t)), this.isAxisX() && (this.parent.scale.x += e.x), this.isAxisY() && (this.parent.scale.y += e.y), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
      const i = this.parent.plugins.get("clamp-zoom", true);
      if (i && i.clamp(), this.options.center)
        this.parent.moveCenter(this.options.center);
      else {
        const s = this.parent.toGlobal(n);
        this.parent.x += t.x - s.x, this.parent.y += t.y - s.y;
      }
      this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.smoothingCount++, this.smoothingCount >= this.options.smooth && (this.smoothing = null);
    }
  }
  pinch(t) {
    if (this.paused)
      return;
    const e = this.parent.input.getPointerPosition(t), n = -t.deltaY * (t.deltaMode ? this.options.lineHeight : 1) / 200, i = Math.pow(2, (1 + this.options.percent) * n);
    let s;
    this.options.center || (s = this.parent.toLocal(e)), this.isAxisX() && (this.parent.scale.x *= i), this.isAxisY() && (this.parent.scale.y *= i), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
    const h = this.parent.plugins.get("clamp-zoom", true);
    if (h && h.clamp(), this.options.center)
      this.parent.moveCenter(this.options.center);
    else {
      const o = this.parent.toGlobal(s);
      this.parent.x += e.x - o.x, this.parent.y += e.y - o.y;
    }
    this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.emit(
      "wheel-start",
      { event: t, viewport: this.parent }
    );
  }
  wheel(t) {
    if (this.paused || !this.checkKeyPress())
      return false;
    if (t.ctrlKey && this.options.trackpadPinch)
      this.pinch(t);
    else if (this.options.wheelZoom) {
      const e = this.parent.input.getPointerPosition(t), i = (this.options.reverse ? -1 : 1) * -t.deltaY * (t.deltaMode ? this.options.lineHeight : 1) / 500, s = Math.pow(2, (1 + this.options.percent) * i);
      if (this.options.smooth) {
        const h = {
          x: this.smoothing ? this.smoothing.x * (this.options.smooth - this.smoothingCount) : 0,
          y: this.smoothing ? this.smoothing.y * (this.options.smooth - this.smoothingCount) : 0
        };
        this.smoothing = {
          x: ((this.parent.scale.x + h.x) * s - this.parent.scale.x) / this.options.smooth,
          y: ((this.parent.scale.y + h.y) * s - this.parent.scale.y) / this.options.smooth
        }, this.smoothingCount = 0, this.smoothingCenter = e;
      } else {
        let h;
        this.options.center || (h = this.parent.toLocal(e)), this.isAxisX() && (this.parent.scale.x *= s), this.isAxisY() && (this.parent.scale.y *= s), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
        const o = this.parent.plugins.get("clamp-zoom", true);
        if (o && o.clamp(), this.options.center)
          this.parent.moveCenter(this.options.center);
        else {
          const r = this.parent.toGlobal(h);
          this.parent.x += e.x - r.x, this.parent.y += e.y - r.y;
        }
      }
      this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.emit(
        "wheel-start",
        { event: t, viewport: this.parent }
      );
    }
    return !this.parent.options.passiveWheel;
  }
};
var Q = class {
  constructor(t) {
    this.viewport = t, this.touches = [], this.addListeners();
  }
  /** Add input listeners */
  addListeners() {
    this.viewport.eventMode = "static", this.viewport.forceHitArea || (this.viewport.hitArea = new Rectangle(0, 0, this.viewport.worldWidth, this.viewport.worldHeight)), this.viewport.on("pointerdown", this.down, this), this.viewport.options.allowPreserveDragOutside ? this.viewport.on("globalpointermove", this.move, this) : this.viewport.on("pointermove", this.move, this), this.viewport.on("pointerup", this.up, this), this.viewport.on("pointerupoutside", this.up, this), this.viewport.on("pointercancel", this.up, this), this.viewport.options.allowPreserveDragOutside || this.viewport.on("pointerleave", this.up, this), this.wheelFunction = (t) => this.handleWheel(t), this.viewport.options.events.domElement.addEventListener(
      "wheel",
      this.wheelFunction,
      { passive: this.viewport.options.passiveWheel }
    ), this.isMouseDown = false;
  }
  /**
   * Removes all event listeners from viewport
   * (useful for cleanup of wheel when removing viewport)
   */
  destroy() {
    this.viewport.options.events.domElement.removeEventListener("wheel", this.wheelFunction);
  }
  /**
   * handle down events for viewport
   *
   * @param {PIXI.FederatedPointerEvent} event
   */
  down(t) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    if (t.pointerType === "mouse" ? this.isMouseDown = true : this.get(t.pointerId) || this.touches.push({ id: t.pointerId, last: null }), this.count() === 1) {
      this.last = t.global.clone();
      const n = this.viewport.plugins.get("decelerate", true), i = this.viewport.plugins.get("bounce", true);
      (!n || !n.isActive()) && (!i || !i.isActive()) ? this.clickedAvailable = true : this.clickedAvailable = false;
    } else
      this.clickedAvailable = false;
    this.viewport.plugins.down(t) && this.viewport.options.stopPropagation && t.stopPropagation();
  }
  /** Clears all pointer events */
  clear() {
    this.isMouseDown = false, this.touches = [], this.last = null;
  }
  /**
   * @param {number} change
   * @returns whether change exceeds threshold
   */
  checkThreshold(t) {
    return Math.abs(t) >= this.viewport.threshold;
  }
  /** Handle move events for viewport */
  move(t) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    const e = this.viewport.plugins.move(t);
    if (this.clickedAvailable && this.last) {
      const n = t.global.x - this.last.x, i = t.global.y - this.last.y;
      (this.checkThreshold(n) || this.checkThreshold(i)) && (this.clickedAvailable = false);
    }
    e && this.viewport.options.stopPropagation && t.stopPropagation();
  }
  /** Handle up events for viewport */
  up(t) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    t.pointerType === "mouse" && (this.isMouseDown = false), t.pointerType !== "mouse" && this.remove(t.pointerId);
    const e = this.viewport.plugins.up(t);
    this.clickedAvailable && this.count() === 0 && this.last && (this.viewport.emit("clicked", {
      event: t,
      screen: this.last,
      world: this.viewport.toWorld(this.last),
      viewport: this.viewport
    }), this.clickedAvailable = false), e && this.viewport.options.stopPropagation && t.stopPropagation();
  }
  /** Gets pointer position if this.interaction is set */
  getPointerPosition(t) {
    const e = new Point();
    return this.viewport.options.events.mapPositionToPoint(e, t.clientX, t.clientY), e;
  }
  /** Handle wheel events */
  handleWheel(t) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    const e = this.viewport.toLocal(this.getPointerPosition(t));
    this.viewport.left <= e.x && e.x <= this.viewport.right && this.viewport.top <= e.y && e.y <= this.viewport.bottom && this.viewport.plugins.wheel(t) && !this.viewport.options.passiveWheel && t.preventDefault();
  }
  pause() {
    this.touches = [], this.isMouseDown = false;
  }
  /** Get touch by id */
  get(t) {
    for (const e of this.touches)
      if (e.id === t)
        return e;
    return null;
  }
  /** Remove touch by number */
  remove(t) {
    for (let e = 0; e < this.touches.length; e++)
      if (this.touches[e].id === t) {
        this.touches.splice(e, 1);
        return;
      }
  }
  /**
   * @returns {number} count of mouse/touch pointers that are down on the viewport
   */
  count() {
    return (this.isMouseDown ? 1 : 0) + this.touches.length;
  }
};
var m = [
  "drag",
  "pinch",
  "wheel",
  "follow",
  "mouse-edges",
  "decelerate",
  "animate",
  "bounce",
  "snap-zoom",
  "clamp-zoom",
  "snap",
  "clamp"
];
var J = class {
  /** This is called by {@link Viewport} to initialize the {@link Viewport.plugins plugins}. */
  constructor(t) {
    this.viewport = t, this.list = [], this.plugins = {};
  }
  /**
   * Inserts a named plugin or a user plugin into the viewport
   * default plugin order: 'drag', 'pinch', 'wheel', 'follow', 'mouse-edges', 'decelerate', 'bounce',
   * 'snap-zoom', 'clamp-zoom', 'snap', 'clamp'
   *
   * @param {string} name of plugin
   * @param {Plugin} plugin - instantiated Plugin class
   * @param {number} index to insert userPlugin (otherwise inserts it at the end)
   */
  add(t, e, n = m.length) {
    const i = this.plugins[t];
    i && i.destroy(), this.plugins[t] = e;
    const s = m.indexOf(t);
    s !== -1 && m.splice(s, 1), m.splice(n, 0, t), this.sort();
  }
  /**
   * Get plugin
   *
   * @param {string} name of plugin
   * @param {boolean} [ignorePaused] return null if plugin is paused
   */
  get(t, e) {
    var n;
    return e && (n = this.plugins[t]) != null && n.paused ? null : this.plugins[t];
  }
  /**
   * Update all active plugins
   *
   * @internal
   * @ignore
   * @param {number} elapsed type in milliseconds since last update
   */
  update(t) {
    for (const e of this.list)
      e.update(t);
  }
  /**
   * Resize all active plugins
   *
   * @internal
   * @ignore
   */
  resize() {
    for (const t of this.list)
      t.resize();
  }
  /** Clamps and resets bounce and decelerate (as needed) after manually moving viewport */
  reset() {
    for (const t of this.list)
      t.reset();
  }
  /** removes all installed plugins */
  removeAll() {
    this.list.forEach((t) => {
      t.destroy();
    }), this.plugins = {}, this.sort();
  }
  /**
   * Removes installed plugin
   *
   * @param {string} name of plugin (e.g., 'drag', 'pinch')
   */
  remove(t) {
    var e;
    this.plugins[t] && ((e = this.plugins[t]) == null || e.destroy(), delete this.plugins[t], this.viewport.emit("plugin-remove", t), this.sort());
  }
  /**
   * Pause plugin
   *
   * @param {string} name of plugin (e.g., 'drag', 'pinch')
   */
  pause(t) {
    var e;
    (e = this.plugins[t]) == null || e.pause();
  }
  /**
   * Resume plugin
   *
   * @param {string} name of plugin (e.g., 'drag', 'pinch')
   */
  resume(t) {
    var e;
    (e = this.plugins[t]) == null || e.resume();
  }
  /**
   * Sort plugins according to PLUGIN_ORDER
   *
   * @internal
   * @ignore
   */
  sort() {
    this.list = [];
    for (const t of m)
      this.plugins[t] && this.list.push(this.plugins[t]);
  }
  /**
   * Handle down for all plugins
   *
   * @internal
   * @ignore
   */
  down(t) {
    let e = false;
    for (const n of this.list)
      n.down(t) && (e = true);
    return e;
  }
  /**
   * Handle move for all plugins
   *
   * @internal
   * @ignore
   */
  move(t) {
    let e = false;
    for (const n of this.viewport.plugins.list)
      n.move(t) && (e = true);
    return e;
  }
  /**
   * Handle up for all plugins
   *
   * @internal
   * @ignore
   */
  up(t) {
    let e = false;
    for (const n of this.list)
      n.up(t) && (e = true);
    return e;
  }
  /**
   * Handle wheel event for all plugins
   *
   * @internal
   * @ignore
   */
  wheel(t) {
    let e = false;
    for (const n of this.list)
      n.wheel(t) && (e = true);
    return e;
  }
};
var $ = {
  screenWidth: typeof window > "u" ? 0 : window.innerWidth,
  screenHeight: typeof window > "u" ? 0 : window.innerHeight,
  worldWidth: null,
  worldHeight: null,
  threshold: 5,
  passiveWheel: true,
  stopPropagation: false,
  forceHitArea: null,
  noTicker: false,
  disableOnContextMenu: false,
  ticker: Ticker.shared,
  allowPreserveDragOutside: false
};
var et = class extends Container {
  /**
   * @param {IViewportOptions} ViewportOptions
   * @param {number} [options.screenWidth=window.innerWidth]
   * @param {number} [options.screenHeight=window.innerHeight]
   * @param {number} [options.worldWidth=this.width]
   * @param {number} [options.worldHeight=this.height]
   * @param {number} [options.threshold=5] number of pixels to move to trigger an input event (e.g., drag, pinch)
   * or disable a clicked event
   * @param {boolean} [options.passiveWheel=true] whether the 'wheel' event is set to passive (note: if false,
   * e.preventDefault() will be called when wheel is used over the viewport)
   * @param {boolean} [options.stopPropagation=false] whether to stopPropagation of events that impact the viewport
   * (except wheel events, see options.passiveWheel)
   * @param {HitArea} [options.forceHitArea] change the default hitArea from world size to a new value
   * @param {boolean} [options.noTicker] set this if you want to manually call update() function on each frame
   * @param {PIXI.Ticker} [options.ticker=PIXI.Ticker.shared] use this PIXI.ticker for updates
   * @param {PIXI.EventSystem} [options.events] EventSystem available from app.events or added manually and passed here
   * location on screen
   * @param {boolean} [options.disableOnContextMenu] remove oncontextmenu=() => {} from the pixi's events.domElement
   */
  constructor(t) {
    super(), this._disableOnContextMenu = (e) => e.preventDefault(), this.options = {
      ...$,
      ...t
    }, this.screenWidth = this.options.screenWidth, this.screenHeight = this.options.screenHeight, this._worldWidth = this.options.worldWidth, this._worldHeight = this.options.worldHeight, this.forceHitArea = this.options.forceHitArea, this.threshold = this.options.threshold, this.options.disableOnContextMenu && this.options.events.domElement.addEventListener("contextmenu", this._disableOnContextMenu), this.options.noTicker || (this.tickerFunction = () => this.update(this.options.ticker.elapsedMS), this.options.ticker.add(this.tickerFunction)), this.input = new Q(this), this.plugins = new J(this);
  }
  /** Overrides PIXI.Container's destroy to also remove the 'wheel' and PIXI.Ticker listeners */
  destroy(t) {
    !this.options.noTicker && this.tickerFunction && this.options.ticker.remove(this.tickerFunction), this.options.disableOnContextMenu && this.options.events.domElement.removeEventListener("contextmenu", this._disableOnContextMenu), this.input.destroy(), super.destroy(t);
  }
  /**
   * Update viewport on each frame.
   *
   * By default, you do not need to call this unless you set `options.noTicker=true`.
   *
   * @param {number} elapsed time in milliseconds since last update
   */
  update(t) {
    this.pause || (this.plugins.update(t), this.lastViewport && (this.lastViewport.x !== this.x || this.lastViewport.y !== this.y ? this.moving = true : this.moving && (this.emit("moved-end", this), this.moving = false), this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y ? this.zooming = true : this.zooming && (this.emit("zoomed-end", this), this.zooming = false)), this.forceHitArea || (this._hitAreaDefault = new Rectangle(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight), this.hitArea = this._hitAreaDefault), this._dirty = this._dirty || !this.lastViewport || this.lastViewport.x !== this.x || this.lastViewport.y !== this.y || this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y, this.lastViewport = {
      x: this.x,
      y: this.y,
      scaleX: this.scale.x,
      scaleY: this.scale.y
    }, this.emit("frame-end", this));
  }
  /**
   * Use this to set screen and world sizes, needed for pinch/wheel/clamp/bounce.
   * @param {number} screenWidth=window.innerWidth
   * @param {number} screenHeight=window.innerHeight
   * @param {number} [worldWidth]
   * @param {number} [worldHeight]
   */
  resize(t = typeof window > "u" ? 0 : window.innerWidth, e = typeof window > "u" ? 0 : window.innerHeight, n, i) {
    this.screenWidth = t, this.screenHeight = e, typeof n < "u" && (this._worldWidth = n), typeof i < "u" && (this._worldHeight = i), this.plugins.resize(), this.dirty = true;
  }
  /** World width, in pixels */
  get worldWidth() {
    return this._worldWidth ? this._worldWidth : this.width / this.scale.x;
  }
  set worldWidth(t) {
    this._worldWidth = t, this.plugins.resize();
  }
  /** World height, in pixels */
  get worldHeight() {
    return this._worldHeight ? this._worldHeight : this.height / this.scale.y;
  }
  set worldHeight(t) {
    this._worldHeight = t, this.plugins.resize();
  }
  /** Get visible world bounds of viewport */
  getVisibleBounds() {
    return new Rectangle(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight);
  }
  /**
   * Changes coordinate from screen to world
   * @param {number|PIXI.Point} x
   * @param {number} y
   * @returns {PIXI.Point}
   */
  toWorld(t, e) {
    return arguments.length === 2 ? this.toLocal(new Point(t, e)) : this.toLocal(t);
  }
  /**
   * Changes coordinate from world to screen
   * @param {number|PIXI.Point} x
   * @param {number} y
   * @returns {PIXI.Point}
   */
  toScreen(t, e) {
    return arguments.length === 2 ? this.toGlobal(new Point(t, e)) : this.toGlobal(t);
  }
  /** Screen width in world coordinates */
  get worldScreenWidth() {
    return this.screenWidth / this.scale.x;
  }
  /** Screen height in world coordinates */
  get worldScreenHeight() {
    return this.screenHeight / this.scale.y;
  }
  /** World width in screen coordinates */
  get screenWorldWidth() {
    return this.worldWidth * this.scale.x;
  }
  /** World height in screen coordinates */
  get screenWorldHeight() {
    return this.worldHeight * this.scale.y;
  }
  /** Center of screen in world coordinates */
  get center() {
    return new Point(
      this.worldScreenWidth / 2 - this.x / this.scale.x,
      this.worldScreenHeight / 2 - this.y / this.scale.y
    );
  }
  set center(t) {
    this.moveCenter(t);
  }
  /**
   * Move center of viewport to (x, y)
   * @param {number|PIXI.Point} x
   * @param {number} [y]
   * @return {Viewport}
   */
  moveCenter(...t) {
    let e, n;
    typeof t[0] == "number" ? (e = t[0], n = t[1]) : (e = t[0].x, n = t[0].y);
    const i = (this.worldScreenWidth / 2 - e) * this.scale.x, s = (this.worldScreenHeight / 2 - n) * this.scale.y;
    return (this.x !== i || this.y !== s) && (this.position.set(i, s), this.plugins.reset(), this.dirty = true), this;
  }
  /** Top-left corner of Viewport */
  get corner() {
    return new Point(-this.x / this.scale.x, -this.y / this.scale.y);
  }
  set corner(t) {
    this.moveCorner(t);
  }
  /**
   * MoveCorner
   * @param {number|PIXI.Point} x
   * @param {number} [y]
   * @returns {Viewport}
   */
  moveCorner(...t) {
    let e, n;
    return t.length === 1 ? (e = -t[0].x * this.scale.x, n = -t[0].y * this.scale.y) : (e = -t[0] * this.scale.x, n = -t[1] * this.scale.y), (e !== this.x || n !== this.y) && (this.position.set(e, n), this.plugins.reset(), this.dirty = true), this;
  }
  /** Get how many world pixels fit in screen's width */
  get screenWidthInWorldPixels() {
    return this.screenWidth / this.scale.x;
  }
  /** Get how many world pixels fit on screen's height */
  get screenHeightInWorldPixels() {
    return this.screenHeight / this.scale.y;
  }
  /**
   * Find the scale value that fits a world width on the screen
   * does not change the viewport (use fit... to change)
   *
   * @param width - Width in world pixels
   * @return - scale
   */
  findFitWidth(t) {
    return this.screenWidth / t;
  }
  /**
   * Finds the scale value that fits a world height on the screens
   * does not change the viewport (use fit... to change)
   *
   * @param height - Height in world pixels
   * @return - scale
   */
  findFitHeight(t) {
    return this.screenHeight / t;
  }
  /**
   * Finds the scale value that fits the smaller of a world width and world height on the screen
   * does not change the viewport (use fit... to change)
   *
   * @param {number} width in world pixels
   * @param {number} height in world pixels
   * @returns {number} scale
   */
  findFit(t, e) {
    const n = this.screenWidth / t, i = this.screenHeight / e;
    return Math.min(n, i);
  }
  /**
   * Finds the scale value that fits the larger of a world width and world height on the screen
   * does not change the viewport (use fit... to change)
   *
   * @param {number} width in world pixels
   * @param {number} height in world pixels
   * @returns {number} scale
   */
  findCover(t, e) {
    const n = this.screenWidth / t, i = this.screenHeight / e;
    return Math.max(n, i);
  }
  /**
   * Change zoom so the width fits in the viewport
   *
   * @param width - width in world coordinates
   * @param center - maintain the same center
   * @param scaleY - whether to set scaleY=scaleX
   * @param noClamp - whether to disable clamp-zoom
   * @returns {Viewport} this
   */
  fitWidth(t = this.worldWidth, e, n = true, i) {
    let s;
    e && (s = this.center), this.scale.x = this.screenWidth / t, n && (this.scale.y = this.scale.x);
    const h = this.plugins.get("clamp-zoom", true);
    return !i && h && h.clamp(), e && s && this.moveCenter(s), this;
  }
  /**
   * Change zoom so the height fits in the viewport
   *
   * @param {number} [height=this.worldHeight] in world coordinates
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @param {boolean} [scaleX=true] whether to set scaleX = scaleY
   * @param {boolean} [noClamp] whether to disable clamp-zoom
   * @returns {Viewport} this
   */
  fitHeight(t = this.worldHeight, e, n = true, i) {
    let s;
    e && (s = this.center), this.scale.y = this.screenHeight / t, n && (this.scale.x = this.scale.y);
    const h = this.plugins.get("clamp-zoom", true);
    return !i && h && h.clamp(), e && s && this.moveCenter(s), this;
  }
  /**
   * Change zoom so it fits the entire world in the viewport
   *
   * @param {boolean} center maintain the same center of the screen after zoom
   * @returns {Viewport} this
   */
  fitWorld(t) {
    let e;
    t && (e = this.center), this.scale.x = this.screenWidth / this.worldWidth, this.scale.y = this.screenHeight / this.worldHeight, this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y;
    const n = this.plugins.get("clamp-zoom", true);
    return n && n.clamp(), t && e && this.moveCenter(e), this;
  }
  /**
   * Change zoom so it fits the size or the entire world in the viewport
   *
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @param {number} [width=this.worldWidth] desired width
   * @param {number} [height=this.worldHeight] desired height
   * @returns {Viewport} this
   */
  fit(t, e = this.worldWidth, n = this.worldHeight) {
    let i;
    t && (i = this.center), this.scale.x = this.screenWidth / e, this.scale.y = this.screenHeight / n, this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y;
    const s = this.plugins.get("clamp-zoom", true);
    return s && s.clamp(), t && i && this.moveCenter(i), this;
  }
  /**
   * Zoom viewport to specific value.
   *
   * @param {number} scale value (e.g., 1 would be 100%, 0.25 would be 25%)
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @return {Viewport} this
   */
  setZoom(t, e) {
    let n;
    e && (n = this.center), this.scale.set(t);
    const i = this.plugins.get("clamp-zoom", true);
    return i && i.clamp(), e && n && this.moveCenter(n), this;
  }
  /**
   * Zoom viewport by a certain percent (in both x and y direction).
   *
   * @param {number} percent change (e.g., 0.25 would increase a starting scale of 1.0 to 1.25)
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @return {Viewport} this
   */
  zoomPercent(t, e) {
    return this.setZoom(this.scale.x + this.scale.x * t, e);
  }
  /**
   * Zoom viewport by increasing/decreasing width by a certain number of pixels.
   *
   * @param {number} change in pixels
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @return {Viewport} this
   */
  zoom(t, e) {
    return this.fitWidth(t + this.worldScreenWidth, e), this;
  }
  /** Changes scale of viewport and maintains center of viewport */
  get scaled() {
    return this.scale.x;
  }
  set scaled(t) {
    this.setZoom(t, true);
  }
  /**
   * Returns zoom to the desired scale
   *
   * @param {ISnapZoomOptions} options
   * @param {number} [options.width=0] - the desired width to snap (to maintain aspect ratio, choose width or height)
   * @param {number} [options.height=0] - the desired height to snap (to maintain aspect ratio, choose width or height)
   * @param {number} [options.time=1000] - time for snapping in ms
   * @param {(string|function)} [options.ease=easeInOutSine] ease function or name (see http://easings.net/
   *   for supported names)
   * @param {PIXI.Point} [options.center] - place this point at center during zoom instead of center of the viewport
   * @param {boolean} [options.interrupt=true] - pause snapping with any user input on the viewport
   * @param {boolean} [options.removeOnComplete] - removes this plugin after snapping is complete
   * @param {boolean} [options.removeOnInterrupt] - removes this plugin if interrupted by any user input
   * @param {boolean} [options.forceStart] - starts the snap immediately regardless of whether the viewport is at the
   *   desired zoom
   * @param {boolean} [options.noMove] - zoom but do not move
   */
  snapZoom(t) {
    return this.plugins.add("snap-zoom", new K(this, t)), this;
  }
  /** Is container out of world bounds */
  OOB() {
    return {
      left: this.left < 0,
      right: this.right > this.worldWidth,
      top: this.top < 0,
      bottom: this.bottom > this.worldHeight,
      cornerPoint: new Point(
        this.worldWidth * this.scale.x - this.screenWidth,
        this.worldHeight * this.scale.y - this.screenHeight
      )
    };
  }
  /** World coordinates of the right edge of the screen */
  get right() {
    return -this.x / this.scale.x + this.worldScreenWidth;
  }
  set right(t) {
    this.x = -t * this.scale.x + this.screenWidth, this.plugins.reset();
  }
  /** World coordinates of the left edge of the screen */
  get left() {
    return -this.x / this.scale.x;
  }
  set left(t) {
    this.x = -t * this.scale.x, this.plugins.reset();
  }
  /** World coordinates of the top edge of the screen */
  get top() {
    return -this.y / this.scale.y;
  }
  set top(t) {
    this.y = -t * this.scale.y, this.plugins.reset();
  }
  /** World coordinates of the bottom edge of the screen */
  get bottom() {
    return -this.y / this.scale.y + this.worldScreenHeight;
  }
  set bottom(t) {
    this.y = -t * this.scale.y + this.screenHeight, this.plugins.reset();
  }
  /**
   * Determines whether the viewport is dirty (i.e., needs to be rendered to the screen because of a change)
   */
  get dirty() {
    return !!this._dirty;
  }
  set dirty(t) {
    this._dirty = t;
  }
  /**
   * Permanently changes the Viewport's hitArea
   *
   * NOTE: if not set then hitArea = PIXI.Rectangle(Viewport.left, Viewport.top, Viewport.worldScreenWidth,
   * Viewport.worldScreenHeight)
   */
  get forceHitArea() {
    return this._forceHitArea;
  }
  set forceHitArea(t) {
    t ? (this._forceHitArea = t, this.hitArea = t) : (this._forceHitArea = null, this.hitArea = new Rectangle(0, 0, this.worldWidth, this.worldHeight));
  }
  /**
   * Enable one-finger touch to drag
   *
   * NOTE: if you expect users to use right-click dragging, you should enable `viewport.options.disableOnContextMenu`
   * to avoid the context menu popping up on each right-click drag.
   *
   * @param {IDragOptions} [options]
   * @param {string} [options.direction=all] direction to drag
   * @param {boolean} [options.pressDrag=true] whether click to drag is active
   * @param {boolean} [options.wheel=true] use wheel to scroll in direction (unless wheel plugin is active)
   * @param {number} [options.wheelScroll=1] number of pixels to scroll with each wheel spin
   * @param {boolean} [options.reverse] reverse the direction of the wheel scroll
   * @param {(boolean|string)} [options.clampWheel=false] clamp wheel(to avoid weird bounce with mouse wheel)
   * @param {string} [options.underflow=center] where to place world if too small for screen
   * @param {number} [options.factor=1] factor to multiply drag to increase the speed of movement
   * @param {string} [options.mouseButtons=all] changes which mouse buttons trigger drag, use: 'all', 'left',
   *  'right' 'middle', or some combination, like, 'middle-right'; you may want to set
   *   viewport.options.disableOnContextMenu if you want to use right-click dragging
   * @param {string[]} [options.keyToPress=null] - array containing
   *  {@link key|https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code} codes of keys that can be
   *  pressed for the drag to be triggered, e.g.: ['ShiftLeft', 'ShiftRight'}.
   * @param {boolean} [options.ignoreKeyToPressOnTouch=false] - ignore keyToPress for touch events
   * @param {number} [options.lineHeight=20] - scaling factor for non-DOM_DELTA_PIXEL scrolling events
   * @returns {Viewport} this
   */
  drag(t) {
    return this.plugins.add("drag", new D(this, t)), this;
  }
  /**
   * Clamp to world boundaries or other provided boundaries
   * There are three ways to clamp:
   * 1. direction: 'all' = the world is clamped to its world boundaries, ie, you cannot drag any part of offscreen
   *    direction: 'x' | 'y' = only the x or y direction is clamped to its world boundary
   * 2. left, right, top, bottom = true | number = the world is clamped to the world's pixel location for each side;
   *    if any of these are set to true, then the location is set to the boundary
   *    [0, viewport.worldWidth/viewport.worldHeight], eg: to allow the world to be completely dragged offscreen,
   *    set [-viewport.worldWidth, -viewport.worldHeight, viewport.worldWidth * 2, viewport.worldHeight * 2]
   *
   * Underflow determines what happens when the world is smaller than the viewport
   * 1. none = the world is clamped but there is no special behavior
   * 2. center = the world is centered on the viewport
   * 3. combination of top/bottom/center and left/right/center (case insensitive) = the world is stuck to the
   *     appropriate boundaries
   *
   * NOTES:
   *   clamp is disabled if called with no options; use { direction: 'all' } for all edge clamping
   *   screenWidth, screenHeight, worldWidth, and worldHeight needs to be set for this to work properly
   *
   * @param {object} [options]
   * @param {(number|boolean)} [options.left=false] - clamp left; true = 0
   * @param {(number|boolean)} [options.right=false] - clamp right; true = viewport.worldWidth
   * @param {(number|boolean)} [options.top=false] - clamp top; true = 0
   * @param {(number|boolean)} [options.bottom=false] - clamp bottom; true = viewport.worldHeight
   * @param {string} [direction] - (all, x, or y) using clamps of [0, viewport.worldWidth/viewport.worldHeight];
   *  replaces left/right/top/bottom if set
   * @param {string} [underflow=center] - where to place world if too small for screen (e.g., top-right, center,
   *  none, bottomLeft)     * @returns {Viewport} this
   */
  clamp(t) {
    return this.plugins.add("clamp", new X(this, t)), this;
  }
  /**
   * Decelerate after a move
   *
   * NOTE: this fires 'moved' event during deceleration
   *
   * @param {IDecelerateOptions} [options]
   * @param {number} [options.friction=0.95] - percent to decelerate after movement
   * @param {number} [options.bounce=0.8] - percent to decelerate when past boundaries (only applicable when
   *   viewport.bounce() is active)
   * @param {number} [options.minSpeed=0.01] - minimum velocity before stopping/reversing acceleration
   * @return {Viewport} this
   */
  decelerate(t) {
    return this.plugins.add("decelerate", new T(this, t)), this;
  }
  /**
   * Bounce on borders
   * NOTES:
   *    screenWidth, screenHeight, worldWidth, and worldHeight needs to be set for this to work properly
   *    fires 'moved', 'bounce-x-start', 'bounce-y-start', 'bounce-x-end', and 'bounce-y-end' events
   * @param {object} [options]
   * @param {string} [options.sides=all] - all, horizontal, vertical, or combination of top, bottom, right, left
   *  (e.g., 'top-bottom-right')
   * @param {number} [options.friction=0.5] - friction to apply to decelerate if active
   * @param {number} [options.time=150] - time in ms to finish bounce
   * @param {object} [options.bounceBox] - use this bounceBox instead of (0, 0, viewport.worldWidth, viewport.worldHeight)
   * @param {number} [options.bounceBox.x=0]
   * @param {number} [options.bounceBox.y=0]
   * @param {number} [options.bounceBox.width=viewport.worldWidth]
   * @param {number} [options.bounceBox.height=viewport.worldHeight]
   * @param {string|function} [options.ease=easeInOutSine] - ease function or name
   *  (see http://easings.net/ for supported names)
   * @param {string} [options.underflow=center] - (top/bottom/center and left/right/center, or center)
   *  where to place world if too small for screen
   * @return {Viewport} this
   */
  bounce(t) {
    return this.plugins.add("bounce", new k(this, t)), this;
  }
  /**
   * Enable pinch to zoom and two-finger touch to drag
   *
   * @param {PinchOptions} [options]
   * @param {boolean} [options.noDrag] - disable two-finger dragging
   * @param {number} [options.percent=1] - percent to modify pinch speed
   * @param {number} [options.factor=1] - factor to multiply two-finger drag to increase the speed of movement
   * @param {PIXI.Point} [options.center] - place this point at center during zoom instead of center of two fingers
   * @param {('all'|'x'|'y')} [options.axis=all] - axis to zoom
   * @return {Viewport} this
   */
  pinch(t) {
    return this.plugins.add("pinch", new N(this, t)), this;
  }
  /**
   * Snap to a point
   *
   * @param {number} x
   * @param {number} y
   * @param {ISnapOptions} [options]
   * @param {boolean} [options.topLeft] - snap to the top-left of viewport instead of center
   * @param {number} [options.friction=0.8] - friction/frame to apply if decelerate is active
   * @param {number} [options.time=1000] - time in ms to snap
   * @param {string|function} [options.ease=easeInOutSine] - ease function or name (see http://easings.net/
   *   for supported names)
   * @param {boolean} [options.interrupt=true] - pause snapping with any user input on the viewport
   * @param {boolean} [options.removeOnComplete] - removes this plugin after snapping is complete
   * @param {boolean} [options.removeOnInterrupt] - removes this plugin if interrupted by any user input
   * @param {boolean} [options.forceStart] - starts the snap immediately regardless of whether the viewport is at
   *   the desired location
   * @return {Viewport} this
   */
  snap(t, e, n) {
    return this.plugins.add("snap", new j(this, t, e, n)), this;
  }
  /**
   * Follow a target
   *
   * NOTES:
   *    uses the (x, y) as the center to follow; for PIXI.Sprite to work properly, use sprite.anchor.set(0.5)
   *    options.acceleration is not perfect as it doesn't know the velocity of the target. It adds acceleration
   *    to the start of movement and deceleration to the end of movement when the target is stopped.
   *    To cancel the follow, use: `viewport.plugins.remove('follow')`
   *
   * @fires 'moved' event
   *
   * @param {PIXI.DisplayObject} target to follow
   * @param {IFollowOptions} [options]
   * @param {number} [options.speed=0] - to follow in pixels/frame (0=teleport to location)
   * @param {number} [options.acceleration] - set acceleration to accelerate and decelerate at this rate; speed
   *   cannot be 0 to use acceleration
   * @param {number} [options.radius] - radius (in world coordinates) of center circle where movement is allowed
   *   without moving the viewport     * @returns {Viewport} this
   * @returns {Viewport} this
   */
  follow(t, e) {
    return this.plugins.add("follow", new U(this, t, e)), this;
  }
  /**
   * Zoom using mouse wheel
   *
   * NOTE: the default event listener for 'wheel' event is the options.events.domElement.
   *
   * @param {IWheelOptions} [options]
   * @param {number} [options.percent=0.1] - percent to scroll with each spin
   * @param {number} [options.smooth] - smooth the zooming by providing the number of frames to zoom between wheel spins
   * @param {boolean} [options.interrupt=true] - stop smoothing with any user input on the viewport
   * @param {boolean} [options.reverse] - reverse the direction of the scroll
   * @param {PIXI.Point} [options.center] - place this point at center during zoom instead of current mouse position
   * @param {number} [options.lineHeight=20] - scaling factor for non-DOM_DELTA_PIXEL scrolling events
   * @param {('all'|'x'|'y')} [options.axis=all] - axis to zoom
   * @return {Viewport} this
   */
  wheel(t) {
    return this.plugins.add("wheel", new G(this, t)), this;
  }
  /**
   * Animate the position and/or scale of the viewport
   * To set the zoom level, use: (1) scale, (2) scaleX and scaleY, or (3) width and/or height
   * @param {object} options
   * @param {number} [options.time=1000] - time to animate
   * @param {PIXI.Point} [options.position=viewport.center] - position to move viewport
   * @param {number} [options.width] - desired viewport width in world pixels (use instead of scale;
   *  aspect ratio is maintained if height is not provided)
   * @param {number} [options.height] - desired viewport height in world pixels (use instead of scale;
   *  aspect ratio is maintained if width is not provided)
   * @param {number} [options.scale] - scale to change zoom (scale.x = scale.y)
   * @param {number} [options.scaleX] - independently change zoom in x-direction
   * @param {number} [options.scaleY] - independently change zoom in y-direction
   * @param {(function|string)} [options.ease=linear] - easing function to use
   * @param {function} [options.callbackOnComplete]
   * @param {boolean} [options.removeOnInterrupt] removes this plugin if interrupted by any user input
   * @returns {Viewport} this
   */
  animate(t) {
    return this.plugins.add("animate", new C(this, t)), this;
  }
  /**
   * Enable clamping of zoom to constraints
   *
   * The minWidth/Height settings are how small the world can get (as it would appear on the screen)
   * before clamping. The maxWidth/maxHeight is how larger the world can scale (as it would appear on
   * the screen) before clamping.
   *
   * For example, if you have a world size of 1000 x 1000 and a screen size of 100 x 100, if you set
   * minWidth/Height = 100 then the world will not be able to zoom smaller than the screen size (ie,
   * zooming out so it appears smaller than the screen). Similarly, if you set maxWidth/Height = 100
   * the world will not be able to zoom larger than the screen size (ie, zooming in so it appears
   * larger than the screen).
   *
   * @param {object} [options]
   * @param {number} [options.minWidth] - minimum width
   * @param {number} [options.minHeight] - minimum height
   * @param {number} [options.maxWidth] - maximum width
   * @param {number} [options.maxHeight] - maximum height
   * @param {number} [options.minScale] - minimum scale
   * @param {number} [options.maxScale] - minimum scale
   * @return {Viewport} this
   */
  clampZoom(t) {
    return this.plugins.add("clamp-zoom", new A(this, t)), this;
  }
  /**
   * Scroll viewport when mouse hovers near one of the edges or radius-distance from center of screen.
   *
   * NOTES: fires 'moved' event; there's a known bug where the mouseEdges does not work properly with "windowed" viewports
   *
   * @param {IMouseEdgesOptions} [options]
   * @param {number} [options.radius] - distance from center of screen in screen pixels
   * @param {number} [options.distance] - distance from all sides in screen pixels
   * @param {number} [options.top] - alternatively, set top distance (leave unset for no top scroll)
   * @param {number} [options.bottom] - alternatively, set bottom distance (leave unset for no top scroll)
   * @param {number} [options.left] - alternatively, set left distance (leave unset for no top scroll)
   * @param {number} [options.right] - alternatively, set right distance (leave unset for no top scroll)
   * @param {number} [options.speed=8] - speed in pixels/frame to scroll viewport
   * @param {boolean} [options.reverse] - reverse direction of scroll
   * @param {boolean} [options.noDecelerate] - don't use decelerate plugin even if it's installed
   * @param {boolean} [options.linear] - if using radius, use linear movement (+/- 1, +/- 1) instead of angled
   *   movement (Math.cos(angle from center), Math.sin(angle from center))
   * @param {boolean} [options.allowButtons] allows plugin to continue working even when there's a mousedown event
   */
  mouseEdges(t) {
    return this.plugins.add("mouse-edges", new B(this, t)), this;
  }
  /** Pause viewport (including animation updates such as decelerate) */
  get pause() {
    return !!this._pause;
  }
  set pause(t) {
    this._pause = t, this.lastViewport = null, this.moving = false, this.zooming = false, t && this.input.pause();
  }
  /**
   * Move the viewport so the bounding box is visible
   *
   * @param x - left
   * @param y - top
   * @param width
   * @param height
   * @param resizeToFit - Resize the viewport so the box fits within the viewport
   */
  ensureVisible(t, e, n, i, s) {
    s && (n > this.worldScreenWidth || i > this.worldScreenHeight) && (this.fit(true, n, i), this.emit("zoomed", { viewport: this, type: "ensureVisible" }));
    let h = false;
    t < this.left ? (this.left = t, h = true) : t + n > this.right && (this.right = t + n, h = true), e < this.top ? (this.top = e, h = true) : e + i > this.bottom && (this.bottom = e + i, h = true), h && this.emit("moved", { viewport: this, type: "ensureVisible" });
  }
};

// ../../node_modules/.pnpm/pixi-cull@2.2.0_pixi.js@8.0.0-alpha.1/node_modules/pixi-cull/dist/pixi-cull.es.js
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var defaultSimpleOptions = {
  visible: "visible",
  dirtyTest: false
};
var Simple = (
  /** @class */
  function() {
    function Simple2(options) {
      if (options === void 0) {
        options = {};
      }
      options = __assign(__assign({}, defaultSimpleOptions), options);
      this.dirtyTest = typeof options.dirtyTest !== "undefined" ? options.dirtyTest : true;
      this.lists = [[]];
    }
    Simple2.prototype.addList = function(array, staticObject) {
      this.lists.push(array);
      if (staticObject) {
        array.staticObject = true;
      }
      var length = array.length;
      for (var i = 0; i < length; i++) {
        this.updateObject(array[i]);
      }
      return array;
    };
    Simple2.prototype.removeList = function(array) {
      var index = this.lists.indexOf(array);
      if (index === -1) {
        return array;
      }
      this.lists.splice(index, 1);
      return array;
    };
    Simple2.prototype.add = function(object, staticObject) {
      if (staticObject) {
        object.staticObject = true;
      }
      if (this.dirtyTest || staticObject) {
        this.updateObject(object);
      }
      this.lists[0].push(object);
      return object;
    };
    Simple2.prototype.remove = function(object) {
      var index = this.lists[0].indexOf(object);
      if (index === -1) {
        return object;
      }
      this.lists[0].splice(index, 1);
      return object;
    };
    Simple2.prototype.cull = function(bounds, skipUpdate) {
      if (!skipUpdate) {
        this.updateObjects();
      }
      for (var _i = 0, _a = this.lists; _i < _a.length; _i++) {
        var list = _a[_i];
        var length_1 = list.length;
        for (var i = 0; i < length_1; i++) {
          var object = list[i];
          var box = object.AABB;
          object.visible = box.x + box.width > bounds.x && box.x < bounds.x + bounds.width && box.y + box.height > bounds.y && box.y < bounds.y + bounds.height;
        }
      }
    };
    Simple2.prototype.updateObjects = function() {
      if (this.dirtyTest) {
        for (var _i = 0, _a = this.lists; _i < _a.length; _i++) {
          var list = _a[_i];
          if (!list.staticObject) {
            var length_2 = list.length;
            for (var i = 0; i < length_2; i++) {
              var object = list[i];
              if (!object.staticObject && object.dirty) {
                this.updateObject(object);
                object.dirty = false;
              }
            }
          }
        }
      } else {
        for (var _b = 0, _c = this.lists; _b < _c.length; _b++) {
          var list = _c[_b];
          if (!list.staticObject) {
            var length_3 = list.length;
            for (var i = 0; i < length_3; i++) {
              var object = list[i];
              if (!object.staticObject) {
                this.updateObject(object);
              }
            }
          }
        }
      }
    };
    Simple2.prototype.updateObject = function(object) {
      var box = object.getLocalBounds();
      object.AABB = object.AABB || { x: 0, y: 0, width: 0, height: 0 };
      object.AABB.x = object.x + (box.x - object.pivot.x) * Math.abs(object.scale.x);
      object.AABB.y = object.y + (box.y - object.pivot.y) * Math.abs(object.scale.y);
      object.AABB.width = box.width * Math.abs(object.scale.x);
      object.AABB.height = box.height * Math.abs(object.scale.y);
    };
    Simple2.prototype.query = function(bounds) {
      var results = [];
      for (var _i = 0, _a = this.lists; _i < _a.length; _i++) {
        var list = _a[_i];
        for (var _b = 0, list_1 = list; _b < list_1.length; _b++) {
          var object = list_1[_b];
          var box = object.AABB;
          if (box && box.x + box.width > bounds.x && box.x - box.width < bounds.x + bounds.width && box.y + box.height > bounds.y && box.y - box.height < bounds.y + bounds.height) {
            results.push(object);
          }
        }
      }
      return results;
    };
    Simple2.prototype.queryCallback = function(bounds, callback) {
      for (var _i = 0, _a = this.lists; _i < _a.length; _i++) {
        var list = _a[_i];
        for (var _b = 0, list_2 = list; _b < list_2.length; _b++) {
          var object = list_2[_b];
          var box = object.AABB;
          if (box && box.x + box.width > bounds.x && box.x - box.width < bounds.x + bounds.width && box.y + box.height > bounds.y && box.y - box.height < bounds.y + bounds.height) {
            if (callback(object)) {
              return true;
            }
          }
        }
      }
      return false;
    };
    Simple2.prototype.stats = function() {
      var visible = 0, count2 = 0;
      for (var _i = 0, _a = this.lists; _i < _a.length; _i++) {
        var list = _a[_i];
        list.forEach(function(object) {
          visible += object.visible ? 1 : 0;
          count2++;
        });
      }
      return { total: count2, visible, culled: count2 - visible };
    };
    return Simple2;
  }()
);
var SpatialHashDefaultOptions = {
  xSize: 1e3,
  ySize: 1e3,
  simpleTest: true,
  dirtyTest: true
};
var SpatialHash = (
  /** @class */
  function() {
    function SpatialHash3(options) {
      this.xSize = 1e3;
      this.ySize = 1e3;
      this.simpleTest = true;
      this.dirtyTest = true;
      options = __assign(__assign({}, SpatialHashDefaultOptions), options);
      if (options && typeof options.size !== "undefined") {
        this.xSize = this.ySize = options.size;
      } else {
        this.xSize = options.xSize;
        this.ySize = options.ySize;
      }
      this.simpleTest = options.simpleTest;
      this.dirtyTest = options.dirtyTest;
      this.width = this.height = 0;
      this.hash = {};
      this.containers = [];
      this.elements = [];
    }
    SpatialHash3.prototype.add = function(object, staticObject) {
      object.spatial = { hashes: [] };
      if (this.dirtyTest) {
        object.dirty = true;
      }
      if (staticObject) {
        object.staticObject = true;
      }
      this.updateObject(object);
      this.elements.push(object);
      return object;
    };
    SpatialHash3.prototype.remove = function(object) {
      this.elements.splice(this.elements.indexOf(object), 1);
      this.removeFromHash(object);
      return object;
    };
    SpatialHash3.prototype.addContainer = function(container, staticObject) {
      var _this = this;
      var added = function(object2) {
        object2.spatial = { hashes: [] };
        _this.updateObject(object2);
      };
      var removed = function(object2) {
        _this.removeFromHash(object2);
      };
      var length = container.children.length;
      for (var i = 0; i < length; i++) {
        var object = container.children[i];
        object.spatial = { hashes: [] };
        this.updateObject(object);
      }
      container.cull = {};
      this.containers.push(container);
      container.on("childAdded", added);
      container.on("childRemoved", removed);
      container.cull.added = added;
      container.cull.removed = removed;
      if (staticObject) {
        container.cull.static = true;
      }
    };
    SpatialHash3.prototype.removeContainer = function(container) {
      var _this = this;
      this.containers.splice(this.containers.indexOf(container), 1);
      container.children.forEach(function(object) {
        return _this.removeFromHash(object);
      });
      container.off("childAdded", container.cull.added);
      container.off("removedFrom", container.cull.removed);
      delete container.cull;
      return container;
    };
    SpatialHash3.prototype.cull = function(AABB, skipUpdate, callback) {
      if (!skipUpdate) {
        this.updateObjects();
      }
      this.invisible();
      var objects;
      if (callback) {
        objects = this.queryCallbackAll(AABB, this.simpleTest, callback);
      } else {
        objects = this.query(AABB, this.simpleTest);
      }
      objects.forEach(function(object) {
        return object.visible = true;
      });
      return this.lastBuckets;
    };
    SpatialHash3.prototype.invisible = function() {
      var length = this.elements.length;
      for (var i = 0; i < length; i++) {
        this.elements[i].visible = false;
      }
      for (var _i = 0, _a = this.containers; _i < _a.length; _i++) {
        var container = _a[_i];
        var length_1 = container.children.length;
        for (var i = 0; i < length_1; i++) {
          container.children[i].visible = false;
        }
      }
    };
    SpatialHash3.prototype.updateObjects = function() {
      if (this.dirtyTest) {
        var length_2 = this.elements.length;
        for (var i = 0; i < length_2; i++) {
          var object = this.elements[i];
          if (object.dirty) {
            this.updateObject(object);
            object.dirty = false;
          }
        }
        for (var _i = 0, _a = this.containers; _i < _a.length; _i++) {
          var container = _a[_i];
          if (!container.cull.static) {
            var length_3 = container.children.length;
            for (var i = 0; i < length_3; i++) {
              var object = container.children[i];
              if (object.dirty) {
                this.updateObject(object);
                object.dirty = false;
              }
            }
          }
        }
      } else {
        var length_4 = this.elements.length;
        for (var i = 0; i < length_4; i++) {
          var object = this.elements[i];
          if (!object.staticObject) {
            this.updateObject(object);
          }
        }
        for (var _b = 0, _c = this.containers; _b < _c.length; _b++) {
          var container = _c[_b];
          if (!container.cull.static) {
            var length_5 = container.children.length;
            for (var i = 0; i < length_5; i++) {
              this.updateObject(container.children[i]);
            }
          }
        }
      }
    };
    SpatialHash3.prototype.updateObject = function(object) {
      var AABB;
      var box = object.getLocalBounds();
      AABB = object.AABB = {
        x: object.x + (box.x - object.pivot.x) * object.scale.x,
        y: object.y + (box.y - object.pivot.y) * object.scale.y,
        width: box.width * object.scale.x,
        height: box.height * object.scale.y
      };
      var spatial = object.spatial;
      if (!spatial) {
        spatial = object.spatial = { hashes: [] };
      }
      var _a = this.getBounds(AABB), xStart = _a.xStart, yStart = _a.yStart, xEnd = _a.xEnd, yEnd = _a.yEnd;
      if (spatial.xStart !== xStart || spatial.yStart !== yStart || spatial.xEnd !== xEnd || spatial.yEnd !== yEnd) {
        if (spatial.hashes.length) {
          this.removeFromHash(object);
        }
        for (var y = yStart; y <= yEnd; y++) {
          for (var x2 = xStart; x2 <= xEnd; x2++) {
            var key = x2 + "," + y;
            this.insert(object, key);
            spatial.hashes.push(key);
          }
        }
        spatial.xStart = xStart;
        spatial.yStart = yStart;
        spatial.xEnd = xEnd;
        spatial.yEnd = yEnd;
      }
    };
    SpatialHash3.prototype.getBuckets = function(minimum) {
      if (minimum === void 0) {
        minimum = 1;
      }
      var hashes = [];
      for (var key in this.hash) {
        var hash = this.hash[key];
        if (hash.length >= minimum) {
          hashes.push(hash);
        }
      }
      return hashes;
    };
    SpatialHash3.prototype.getBounds = function(AABB) {
      var xStart = Math.floor(AABB.x / this.xSize);
      var yStart = Math.floor(AABB.y / this.ySize);
      var xEnd = Math.floor((AABB.x + AABB.width) / this.xSize);
      var yEnd = Math.floor((AABB.y + AABB.height) / this.ySize);
      return { xStart, yStart, xEnd, yEnd };
    };
    SpatialHash3.prototype.insert = function(object, key) {
      if (!this.hash[key]) {
        this.hash[key] = [object];
      } else {
        this.hash[key].push(object);
      }
    };
    SpatialHash3.prototype.removeFromHash = function(object) {
      var spatial = object.spatial;
      while (spatial.hashes.length) {
        var key = spatial.hashes.pop();
        var list = this.hash[key];
        list.splice(list.indexOf(object), 1);
      }
    };
    SpatialHash3.prototype.neighbors = function(object) {
      var _this = this;
      var results = [];
      object.spatial.hashes.forEach(function(key) {
        return results = results.concat(_this.hash[key]);
      });
      return results;
    };
    SpatialHash3.prototype.query = function(AABB, simpleTest) {
      if (simpleTest === void 0) {
        simpleTest = true;
      }
      var buckets = 0;
      var results = [];
      var _a = this.getBounds(AABB), xStart = _a.xStart, yStart = _a.yStart, xEnd = _a.xEnd, yEnd = _a.yEnd;
      for (var y = yStart; y <= yEnd; y++) {
        for (var x2 = xStart; x2 <= xEnd; x2++) {
          var entry = this.hash[x2 + "," + y];
          if (entry) {
            if (simpleTest) {
              var length_6 = entry.length;
              for (var i = 0; i < length_6; i++) {
                var object = entry[i];
                var box = object.AABB;
                if (box.x + box.width > AABB.x && box.x < AABB.x + AABB.width && box.y + box.height > AABB.y && box.y < AABB.y + AABB.height) {
                  results.push(object);
                }
              }
            } else {
              results = results.concat(entry);
            }
            buckets++;
          }
        }
      }
      this.lastBuckets = buckets;
      return results;
    };
    SpatialHash3.prototype.queryCallbackAll = function(AABB, simpleTest, callback) {
      if (simpleTest === void 0) {
        simpleTest = true;
      }
      var buckets = 0;
      var results = [];
      var _a = this.getBounds(AABB), xStart = _a.xStart, yStart = _a.yStart, xEnd = _a.xEnd, yEnd = _a.yEnd;
      for (var y = yStart; y <= yEnd; y++) {
        for (var x2 = xStart; x2 <= xEnd; x2++) {
          var entry = this.hash[x2 + "," + y];
          if (entry) {
            if (simpleTest) {
              var length_7 = entry.length;
              for (var i = 0; i < length_7; i++) {
                var object = entry[i];
                var box = object.AABB;
                if (box.x + box.width > AABB.x && box.x < AABB.x + AABB.width && box.y + box.height > AABB.y && box.y < AABB.y + AABB.height) {
                  results.push(object);
                  callback(object);
                }
              }
            } else {
              results = results.concat(entry);
              for (var _i = 0, entry_1 = entry; _i < entry_1.length; _i++) {
                var object = entry_1[_i];
                callback(object);
              }
            }
            buckets++;
          }
        }
      }
      this.lastBuckets = buckets;
      return results;
    };
    SpatialHash3.prototype.queryCallback = function(AABB, callback, simpleTest) {
      if (simpleTest === void 0) {
        simpleTest = true;
      }
      var _a = this.getBounds(AABB), xStart = _a.xStart, yStart = _a.yStart, xEnd = _a.xEnd, yEnd = _a.yEnd;
      for (var y = yStart; y <= yEnd; y++) {
        for (var x2 = xStart; x2 <= xEnd; x2++) {
          var entry = this.hash[x2 + "," + y];
          if (entry) {
            for (var i = 0; i < entry.length; i++) {
              var object = entry[i];
              if (simpleTest) {
                var AABB_1 = object.AABB;
                if (AABB_1.x + AABB_1.width > AABB_1.x && AABB_1.x < AABB_1.x + AABB_1.width && AABB_1.y + AABB_1.height > AABB_1.y && AABB_1.y < AABB_1.y + AABB_1.height) {
                  if (callback(object)) {
                    return true;
                  }
                }
              } else {
                if (callback(object)) {
                  return true;
                }
              }
            }
          }
        }
      }
      return false;
    };
    SpatialHash3.prototype.stats = function() {
      var visible = 0, count2 = 0;
      var length = this.elements.length;
      for (var i = 0; i < length; i++) {
        var object = this.elements[i];
        visible += object.visible ? 1 : 0;
        count2++;
      }
      for (var _i = 0, _a = this.containers; _i < _a.length; _i++) {
        var list = _a[_i];
        var length_8 = list.children.length;
        for (var i = 0; i < length_8; i++) {
          var object = list.children[i];
          visible += object.visible ? 1 : 0;
          count2++;
        }
      }
      return {
        buckets: this.lastBuckets,
        total: count2,
        visible,
        culled: count2 - visible
      };
    };
    SpatialHash3.prototype.getNumberOfBuckets = function() {
      return Object.keys(this.hash).length;
    };
    SpatialHash3.prototype.getAverageSize = function() {
      var total = 0;
      for (var key in this.hash) {
        total += this.hash[key].length;
      }
      return total / this.getBuckets().length;
    };
    SpatialHash3.prototype.getLargest = function() {
      var largest = 0;
      for (var key in this.hash) {
        if (this.hash[key].length > largest) {
          largest = this.hash[key].length;
        }
      }
      return largest;
    };
    SpatialHash3.prototype.getWorldBounds = function() {
      var xStart = Infinity, yStart = Infinity, xEnd = 0, yEnd = 0;
      for (var key in this.hash) {
        var split = key.split(",");
        var x2 = parseInt(split[0]);
        var y = parseInt(split[1]);
        xStart = x2 < xStart ? x2 : xStart;
        yStart = y < yStart ? y : yStart;
        xEnd = x2 > xEnd ? x2 : xEnd;
        yEnd = y > yEnd ? y : yEnd;
      }
      return { xStart, yStart, xEnd, yEnd };
    };
    SpatialHash3.prototype.getSparseness = function(AABB) {
      var count2 = 0, total = 0;
      var _a = AABB ? this.getBounds(AABB) : this.getWorldBounds(), xStart = _a.xStart, yStart = _a.yStart, xEnd = _a.xEnd, yEnd = _a.yEnd;
      for (var y = yStart; y < yEnd; y++) {
        for (var x2 = xStart; x2 < xEnd; x2++) {
          count2 += this.hash[x2 + "," + y] ? 1 : 0;
          total++;
        }
      }
      return count2 / total;
    };
    return SpatialHash3;
  }()
);

// src/frontend/game/UIElements.ts
var universeView;
var systemView;
var uiOverlay;
var currentCoordinate;
var fps;
var universeCuller;
var universeGraphics;
var universeGraphicsText;
var systemGraphics;
var systemGraphicsText;
var createUIElements = (app2) => {
  let pointerDownPlace;
  systemView = new et({
    screenWidth: window.innerWidth,
    screenHeight: window.innerHeight,
    worldWidth: 2e3,
    worldHeight: 2e3,
    events: app2.renderer.events
    // the interaction module is important for wheel to work properly when renderer.view is placed or scaled
  });
  systemView.on("pointerdown", (event) => {
    console.log("pointerdown");
    pointerDownPlace = new Point(event.globalX, event.globalY);
  });
  systemView.on("click", (event) => {
    console.log("click");
    if (pointerDownPlace) {
      const distance = Math.abs(pointerDownPlace.x - event.globalX) + Math.abs(pointerDownPlace.y - event.globalY);
      if (distance > 2) {
        console.log("cancelling drag event");
        event.stopPropagation();
      }
    }
  });
  systemGraphics = new Graphics();
  systemView.addChild(systemGraphics);
  systemGraphicsText = new Text({
    text: "",
    style: {
      fontFamily: "sans-serif",
      fontSize: 16,
      //tint: 0x0000FF,
      align: "right"
    }
  });
  systemView.addChild(systemGraphicsText);
  systemView.drag().pinch().wheel().decelerate();
  systemView.visible = false;
  systemView.moveCenter(1e3, 1e3);
  universeView = new et({
    screenWidth: window.innerWidth,
    screenHeight: window.innerHeight,
    worldWidth: totalSize,
    worldHeight: totalSize,
    events: app2.renderer.events
    // the interaction module is important for wheel to work properly when renderer.view is placed or scaled
  });
  universeView.on("pointerdown", (event) => {
    console.log("pointerdown");
    pointerDownPlace = new Point(event.globalX, event.globalY);
  });
  universeView.on("click", (event) => {
    console.log("click");
    if (pointerDownPlace) {
      const distance = Math.abs(pointerDownPlace.x - event.globalX) + Math.abs(pointerDownPlace.y - event.globalY);
      if (distance > 2) {
        console.log("cancelling drag event");
        event.stopPropagation();
      }
    }
  });
  universeView.drag().pinch().wheel().decelerate();
  universeView.moveCenter(totalSize / 2, totalSize / 2);
  const starContainer = new Container();
  starContainer.name = "stars";
  universeView.addChild(starContainer);
  universeCuller = new Simple();
  universeCuller.cull(universeView.getVisibleBounds());
  universeGraphics = new Graphics();
  universeView.addChild(universeGraphics);
  universeGraphicsText = new Text({
    text: "",
    style: {
      fontFamily: "sans-serif",
      fontSize: 16,
      //tint: 0x0000FF,
      align: "right"
    }
  });
  universeView.addChild(universeGraphicsText);
  uiOverlay = new Container();
  const popupOverlay = new Container();
  currentCoordinate = new Text({
    text: "0, 0",
    style: {
      fontFamily: "sans-serif",
      fontSize: 18,
      align: "right"
    }
  });
  currentCoordinate.x = gameWidth - 166;
  currentCoordinate.y = 16;
  currentCoordinate.maxWidth = 150;
  uiOverlay.addChild(currentCoordinate);
  fps = new Text({
    text: "FPS: 60",
    style: {
      fontFamily: "sans-serif",
      fontSize: 18,
      align: "right"
    }
  });
  fps.x = gameWidth - 166;
  fps.y = 40;
  fps.maxWidth = 150;
  uiOverlay.addChild(fps);
  const bgContainer = new TilingSprite(loadedAssets.bgTexture, 4096, 4096);
  app2.stage.addChild(bgContainer);
  app2.stage.addChild(universeView);
  app2.stage.addChild(systemView);
  app2.stage.addChild(uiOverlay);
  app2.stage.addChild(popupOverlay);
};

// src/frontend/game/positionShips.ts
var waypointShips = {};
function resetShipWaypoints() {
  waypointShips = {};
}
var planetOrbitSpeed = 2e4;
function positionWaypoint(waypoint, timeElapsed) {
  let x2, y;
  if (waypoint.orbitsSymbol) {
    const orbitData = GameState.waypointData[waypoint.orbitsSymbol];
    const orbitDistance = Math.sqrt(Math.pow(waypoint.x, 2) + Math.pow(waypoint.y, 2));
    const orbitalPeriod = orbitDistance * planetOrbitSpeed;
    const currentAngle = (timeElapsed % orbitalPeriod / orbitalPeriod + orbitData.offset) * Math.PI * 2;
    x2 = (Math.abs(systemCoordinates.minX) + Math.cos(currentAngle) * orbitDistance) * systemScale;
    y = (Math.abs(systemCoordinates.minY) + Math.sin(currentAngle) * orbitDistance) * systemScale;
    const ownOrbitalPeriod = 60 * 500;
    const ownAngle = (timeElapsed % ownOrbitalPeriod / ownOrbitalPeriod + waypoint.offset) * Math.PI * 2;
    const offsetX = Math.cos(ownAngle) * 60;
    const offsetY = Math.sin(ownAngle) * 60;
    x2 += offsetX;
    y += offsetY;
  } else {
    const orbitDistance = Math.sqrt(Math.pow(waypoint.x, 2) + Math.pow(waypoint.y, 2));
    const orbitalPeriod = orbitDistance * planetOrbitSpeed;
    const currentAngle = (timeElapsed % orbitalPeriod / orbitalPeriod + waypoint.offset) * Math.PI * 2;
    x2 = (Math.abs(systemCoordinates.minX) + Math.cos(currentAngle) * orbitDistance) * systemScale;
    y = (Math.abs(systemCoordinates.minY) + Math.sin(currentAngle) * orbitDistance) * systemScale;
  }
  return {
    x: x2,
    y
  };
}
function positionShip(ship) {
  let serverX, serverY, navRot, xOffset = 0, yOffset = 0;
  const arrivalOn = new Date(ship.arrivalOn);
  const departureOn = new Date(ship.departureOn);
  if (ship.destinationWaypoint.symbol !== ship.departureWaypoint.symbol && Date.now() < arrivalOn.getTime()) {
    const positionAlongPath = (Date.now() - departureOn.getTime()) / (arrivalOn.getTime() - departureOn.getTime());
    try {
      const from = GameState.waypoints[ship.departureWaypoint.symbol];
      const to = GameState.waypoints[ship.destinationWaypoint.symbol];
      serverX = from.x + (to.x - from.x) * positionAlongPath;
      serverY = from.y + (to.y - from.y) * positionAlongPath;
      navRot = Math.atan2(to.y - from.y, to.x - from.x) + Math.PI / 2;
    } catch (e) {
      serverX = 0;
      serverY = 0;
      navRot = 0;
    }
  } else {
    const orbitSymbol = ship.currentWaypoint.orbitsSymbol ? ship.currentWaypoint.orbitsSymbol : ship.currentWaypoint.symbol;
    if (waypointShips[orbitSymbol] === void 0) {
      waypointShips[orbitSymbol] = 0;
    } else {
      waypointShips[orbitSymbol]++;
    }
    const curr = GameState.waypoints[ship.currentWaypoint.symbol];
    if (curr) {
      serverX = curr.x;
      serverY = curr.y;
      xOffset = 32 * waypointShips[orbitSymbol];
      yOffset = 80;
    } else {
      serverX = 0;
      serverY = 0;
      navRot = 0;
    }
  }
  const x2 = serverX + xOffset;
  const y = serverY + yOffset;
  return {
    x: x2,
    y,
    navRot
  };
}
function positionUniverseShip(ship) {
  let serverX, serverY, navRot, xOffset = 0, yOffset = 0;
  const arrivalOn = new Date(ship.arrivalOn);
  const departureOn = new Date(ship.departureOn);
  const sizeMultiplier = universeView.worldScreenWidth / universeView.screenWidth;
  if (ship.destinationWaypoint.systemSymbol !== ship.departureWaypoint.systemSymbol && Date.now() < arrivalOn.getTime()) {
    const positionAlongPath = (Date.now() - departureOn.getTime()) / (arrivalOn.getTime() - departureOn.getTime());
    const departureSystem = GameState.systems[ship.departureWaypoint.systemSymbol];
    const destinationSystem = GameState.systems[ship.destinationWaypoint.systemSymbol];
    serverX = departureSystem.x + (destinationSystem.x - departureSystem.x) * positionAlongPath;
    serverY = departureSystem.y + (destinationSystem.y - departureSystem.y) * positionAlongPath;
    navRot = Math.atan2(destinationSystem.y - departureSystem.y, destinationSystem.x - departureSystem.x) + Math.PI / 2;
  } else {
    if (waypointShips[ship.currentWaypoint.systemSymbol] === void 0) {
      waypointShips[ship.currentWaypoint.systemSymbol] = 0;
    } else {
      waypointShips[ship.currentWaypoint.systemSymbol]++;
    }
    const currentSystem = GameState.systems[ship.currentWaypoint.systemSymbol];
    serverX = currentSystem.x;
    serverY = currentSystem.y;
    xOffset = 32 * waypointShips[ship.currentWaypoint.systemSymbol] * sizeMultiplier;
    yOffset = 80 * Math.min(sizeMultiplier, 8);
  }
  const x2 = serverX + xOffset;
  const y = serverY + yOffset;
  return {
    x: x2,
    y,
    navRot
  };
}

// src/frontend/game/loadSystem.ts
function createShipContainer(ship) {
  const shipGroup = new Container();
  const itemSprite = new Sprite(loadedAssets.spaceshipTextures[ship.frameSymbol] ? loadedAssets.spaceshipTextures[ship.frameSymbol] : loadedAssets.spaceshipTexture);
  itemSprite.name = "ship";
  itemSprite.pivot = {
    x: 32,
    y: 32
  };
  const navSprite = new Sprite(loadedAssets.navArrow);
  navSprite.pivot = {
    x: navSprite.width / 2,
    y: navSprite.height / 2
  };
  navSprite.name = "nav";
  navSprite.visible = false;
  shipGroup.addChild(navSprite);
  itemSprite.scale = { x: 0.5, y: 0.5 };
  const shipPosition = positionShip(ship);
  shipGroup.x = shipPosition.x;
  shipGroup.y = shipPosition.y;
  if (ship.agent !== GameState.agent.symbol) {
    itemSprite.tint = 14522777;
  }
  shipGroup.addChild(itemSprite);
  const text = new Text({
    text: ship.symbol + " - " + ship.role,
    renderMode: "bitmap",
    style: {
      fontFamily: "sans-serif",
      fontSize: 16,
      align: "right"
    }
  });
  text.visible = false;
  text.x = 0;
  text.y = 32;
  shipGroup.addChild(text);
  makeInteractiveAndSelectable(shipGroup, {
    onMouseOver: () => {
      text.visible = true;
    },
    onMouseOut: () => {
      text.visible = false;
    },
    onSelect: {
      type: "ship",
      symbol: ship.symbol
    }
  });
  return shipGroup;
}
function createOrbitGraphics(item) {
  const orbit = new Graphics();
  orbit.lineStyle({
    width: 2,
    color: 4473924
  });
  orbit.drawCircle(Math.abs(systemCoordinates.minX) * systemScale, Math.abs(systemCoordinates.minY) * systemScale, Math.sqrt(Math.pow(item.x * systemScale, 2) + Math.pow(item.y * systemScale, 2)));
  return orbit;
}
function addTraitIcons(item, container) {
  let xOffset = 0;
  item.traits.forEach((trait) => {
    if (trait.symbol === "MARKETPLACE") {
      const sprite = new Sprite(loadedAssets.market);
      sprite.pivot = {
        x: 32,
        y: 32
      };
      sprite.scale = { x: 0.25, y: 0.25 };
      sprite.x = xOffset - 16;
      sprite.y = 24;
      container.addChild(sprite);
      xOffset += 16;
    }
    if (trait.symbol === "SHIPYARD") {
      const sprite = new Sprite(loadedAssets.shipyard);
      sprite.pivot = {
        x: 32,
        y: 32
      };
      sprite.scale = { x: 0.25, y: 0.24 };
      sprite.x = xOffset - 16;
      sprite.y = 24;
      container.addChild(sprite);
      xOffset += 16;
    }
  });
}
function createSystemItem(data, scale3 = 1, index = 0) {
  const orbitingGroup = new Container();
  let orbitingSprite;
  orbitingSprite = new Sprite(loadedAssets.planetsheet.textures[`planets/tile/${data.waypoint.type}.png`]);
  orbitingSprite.pivot = {
    x: 32,
    y: 32
  };
  orbitingSprite.scale = { x: scale3, y: scale3 };
  if (data.parent) {
    orbitingGroup.x = data.parent.x * systemScale + 32 + Math.abs(systemCoordinates.minX) * systemScale;
    orbitingGroup.y = data.parent.y * systemScale + 48 + 64 * index + Math.abs(systemCoordinates.minY) * systemScale;
  } else {
    orbitingGroup.x = (data.waypoint.x + Math.abs(systemCoordinates.minX)) * systemScale;
    orbitingGroup.y = (data.waypoint.y + Math.abs(systemCoordinates.minY)) * systemScale;
  }
  orbitingGroup.addChild(orbitingSprite);
  const orbitingText = new Text({
    text: data.waypoint.symbol + " - " + data.waypoint.type,
    renderMode: "bitmap",
    style: {
      fontFamily: "sans-serif",
      fontSize: 16,
      align: "right"
    }
  });
  orbitingText.x = 24;
  orbitingText.y = -8;
  orbitingText.visible = false;
  orbitingGroup.addChild(orbitingText);
  makeInteractiveAndSelectable(orbitingGroup, {
    onMouseOver: () => {
      console.log("hovered", data.waypoint);
      GameState.hoveredWaypoint = data.waypoint;
      orbitingText.visible = true;
    },
    onMouseOut: () => {
      GameState.hoveredWaypoint = void 0;
      orbitingText.visible = false;
    },
    onSelect: {
      type: "waypoint",
      symbol: data.waypoint.symbol
    },
    onOrder: [
      {
        name: "navigate",
        withSelection: "ship",
        action: async (selectedSymbol) => {
          const res = await trpc.instructNavigate.mutate({
            shipSymbol: selectedSymbol,
            waypointSymbol: data.waypoint.symbol
          });
          GameState.shipData[res.symbol] = res;
          console.log("updated state for ship " + res.symbol);
        }
      }
    ]
  });
  addTraitIcons(data.waypoint, orbitingGroup);
  return orbitingGroup;
}
function clearSystem() {
  systemView.removeChildren();
  systemView.addChild(systemGraphics);
  systemView.addChild(systemGraphicsText);
}
function showSystemView() {
  universeView.visible = false;
  systemView.visible = true;
  GameState.currentView = "system";
}
async function loadSystem(systemSymbol, resetCamera = true) {
  Promise.all([
    trpc.shipsForSystem.query({
      system: systemSymbol
    }),
    trpc.waypointsForSystem.query({
      system: systemSymbol
    })
  ]).then(([ships, waypoints]) => {
    const starData = GameState.systemData[systemSymbol];
    ships.forEach((ship) => {
      GameState.shipData[ship.symbol] = ship;
    });
    waypoints.forEach((waypoint) => {
      GameState.waypointData[waypoint.symbol] = {
        ...waypoint,
        offset: Math.random()
      };
    });
    clearSystem();
    showSystemView();
    GameState.currentSystem = systemSymbol;
    systemCoordinates.minX = 0;
    systemCoordinates.minY = 0;
    waypoints.filter((item) => !item.orbitsSymbol).forEach((item) => {
      if (item.x < systemCoordinates.minX) {
        systemCoordinates.minX = item.x;
      }
      if (item.y < systemCoordinates.minY) {
        systemCoordinates.minY = item.y;
      }
    });
    let texture = loadedAssets.sheet.textures[`planets/tile/${starData.type}.png`];
    const star = new Sprite(texture);
    star.x = Math.abs(systemCoordinates.minX) * systemScale;
    star.y = Math.abs(systemCoordinates.minY) * systemScale;
    star.pivot = {
      x: 32,
      y: 32
    };
    systemView.addChild(star);
    resetShipWaypoints();
    GameState.systemShips = {};
    GameState.waypoints = {};
    Object.values(GameState.shipData).filter((ship) => ship.currentWaypoint.systemSymbol === starData.symbol).forEach((data) => {
      const ship = data;
      const shipGroup = createShipContainer(ship);
      systemView.addChild(shipGroup);
      GameState.systemShips[ship.symbol] = shipGroup;
    });
    waypoints.filter((item) => !item.orbitsSymbol && item.type !== "MOON" && item.type !== "ORBITAL_STATION").forEach((item) => {
      systemView.addChild(createOrbitGraphics(item));
      const itemGroup = createSystemItem({
        waypoint: item
      });
      waypoints.filter((orbitingThing) => orbitingThing.orbitsSymbol === item.symbol || orbitingThing.symbol !== item.symbol && orbitingThing.x == item.x && orbitingThing.y == item.y).forEach((orbitingThing, index) => {
        const orbitingGroup = createSystemItem({
          waypoint: orbitingThing,
          parent: item
        }, 0.5, index);
        GameState.waypoints[orbitingThing.symbol] = orbitingGroup;
        systemView.addChild(orbitingGroup);
      });
      GameState.waypoints[item.symbol] = itemGroup;
      systemView.addChild(itemGroup);
    });
    if (resetCamera) {
      systemView.moveCenter({
        x: Math.abs(systemCoordinates.minX) * systemScale,
        y: Math.abs(systemCoordinates.minY) * systemScale
      });
    }
  });
}

// src/common/lib/getDistance.ts
var getDistance = (pos1, pos2) => {
  return Math.sqrt(Math.pow(pos1.x - pos2.x, 2) + Math.pow(pos1.y - pos2.y, 2));
};

// src/frontend/game/util.ts
var convertToDisplayCoordinates = (position) => {
  return {
    x: (position.x + Math.abs(universeCoordinates.minX)) / (universeCoordinates.maxX - universeCoordinates.minX) * totalSize,
    y: (position.y + Math.abs(universeCoordinates.minY)) / (universeCoordinates.maxY - universeCoordinates.minY) * totalSize
  };
};

// src/frontend/game/highlightmodes.ts
var stringToColour = function(str) {
  var hash = 0;
  for (var i = 0; i < str.length; i++) {
    hash = str.charCodeAt(i) + ((hash << 5) - hash);
  }
  var colour = "#";
  for (var i = 0; i < 3; i++) {
    var value = hash >> i * 8 & 255;
    colour += ("00" + value.toString(16)).substr(-2);
  }
  return colour;
};
var highlightmodes = {
  Factions: (graphics) => {
    for (const starData of Object.values(GameState.systemData)) {
      if (starData.majorityFaction) {
        const isHeadquarters = GameState.factions[starData.majorityFaction].headquartersSymbol.includes(starData.symbol);
        const displayCoords = convertToDisplayCoordinates(starData);
        graphics.beginFill(stringToColour(starData.majorityFaction));
        graphics.drawCircle(displayCoords.x, displayCoords.y, isHeadquarters ? 4500 : 1500);
      }
    }
    const colorMatrix = new AlphaFilter();
    colorMatrix.alpha = 0.1;
    graphics.filters = [colorMatrix];
  },
  Shipyards: (graphics) => {
    for (const starData of Object.values(GameState.systemData)) {
      if (starData.hasShipyard) {
        const displayCoords = convertToDisplayCoordinates(starData);
        graphics.beginFill(255);
        graphics.drawCircle(displayCoords.x, displayCoords.y, 1500);
      }
    }
    const colorMatrix = new AlphaFilter();
    colorMatrix.alpha = 0.1;
    graphics.filters = [colorMatrix];
  },
  "Market Update": (graphics) => {
    for (const shipData of Object.values(GameState.shipData)) {
      if (shipData.currentBehavior === "EXPLORE_MARKETS" || shipData.currentBehavior === "UPDATE_MARKETS") {
        const homeSystem = GameState.systemData[shipData.homeSystemSymbol];
        const displayCoords = convertToDisplayCoordinates(homeSystem);
        const range = shipData.behaviorRange * scale.universe;
        graphics.beginFill(6750054);
        graphics.drawRect(displayCoords.x - range, displayCoords.y - range, range * 2, range * 2);
      }
    }
    const colorMatrix = new AlphaFilter();
    colorMatrix.alpha = 0.1;
    graphics.filters = [colorMatrix];
  }
};

// src/frontend/game/loadUniverse.ts
var addTraitIcons2 = (item, container) => {
  let xOffset = 0;
  if (item.hasMarket) {
    const sprite = new Sprite(loadedAssets.market);
    sprite.pivot = {
      x: 32,
      y: 32
    };
    sprite.scale = { x: 0.25, y: 0.25 };
    sprite.x = xOffset - 16;
    sprite.y = 24;
    container.addChild(sprite);
    xOffset += 16;
  }
  if (item.hasShipyard) {
    const sprite = new Sprite(loadedAssets.shipyard);
    sprite.pivot = {
      x: 32,
      y: 32
    };
    sprite.scale = { x: 0.25, y: 0.24 };
    sprite.x = xOffset - 16;
    sprite.y = 24;
    container.addChild(sprite);
    xOffset += 16;
  }
  if (item.hasBelt) {
    const sprite = new Sprite(loadedAssets.asteroidBelt);
    sprite.pivot = {
      x: 32,
      y: 32
    };
    sprite.scale = { x: 0.25, y: 0.24 };
    sprite.x = xOffset - 16;
    sprite.y = 24;
    container.addChild(sprite);
    xOffset += 16;
  }
  if (item.hasJumpGate) {
    const sprite = new Sprite(loadedAssets.jumpgate);
    sprite.pivot = {
      x: 32,
      y: 32
    };
    sprite.scale = { x: 0.25, y: 0.24 };
    sprite.x = xOffset - 16;
    sprite.y = 24;
    container.addChild(sprite);
    xOffset += 16;
  }
  if (item.hasStation && !item.hasShipyard) {
    const sprite = new Sprite(loadedAssets.station);
    sprite.pivot = {
      x: 32,
      y: 32
    };
    sprite.scale = { x: 0.25, y: 0.24 };
    sprite.x = xOffset - 16;
    sprite.y = 24;
    container.addChild(sprite);
    xOffset += 16;
  }
  if (item.hasUncharted) {
    const sprite = new Sprite(loadedAssets.treasure);
    sprite.pivot = {
      x: 32,
      y: 32
    };
    sprite.scale = { x: 0.25, y: 0.24 };
    sprite.x = xOffset - 16;
    sprite.y = 24;
    container.addChild(sprite);
    xOffset += 16;
  }
};
function createStar(starData) {
  let texture = loadedAssets.sheet.textures[`planets/tile/${starData.type}.png`];
  const star = new Sprite(texture);
  star.pivot = {
    x: 32,
    y: 32
  };
  const text = new Text({
    text: starData.name + "\n(" + starData.symbol + ")",
    renderMode: "bitmap",
    style: {
      fontFamily: "sans-serif",
      fontSize: 18,
      align: "left"
    }
  });
  text.name = "label";
  text.x = 0;
  text.y = 40;
  const starContainer = new Container();
  starContainer.addChild(star);
  starContainer.addChild(text);
  addTraitIcons2(starData, starContainer);
  makeInteractiveAndSelectable(starContainer, {
    onMouseOut: () => {
      GameState.hoveredSystem = void 0;
    },
    onMouseOver: () => {
      GameState.hoveredSystem = starData;
    },
    onOrder: [
      {
        name: "Travel",
        withSelection: "ship",
        isAvailable: async () => {
          return true;
        },
        action: async () => {
          await trpc.orderTravel.mutate({
            shipSymbol: GameState.selected.symbol,
            systemSymbol: starData.symbol
          });
        }
      },
      {
        name: "Warp",
        withSelection: "ship",
        isAvailable: async () => {
          const shipData = GameState.shipData[GameState.selected.symbol];
          const warpRange = shipData.modules.find((m2) => m2.effectName === "WARP_DRIVE")?.value;
          const currentSystem = GameState.systemData[shipData.currentWaypoint.systemSymbol];
          return getDistance(currentSystem, GameState.hoveredSystem) < warpRange;
        },
        action: async () => {
          const waypoints = await trpc.waypointsForSystem.query({
            system: starData.symbol
          });
          console.log("waypoints", waypoints);
          const bestWaypoint = waypoints.find((w) => w.traits.find((t) => t.symbol === "MARKETPLACE"))?.symbol ?? waypoints[0].symbol;
          if (bestWaypoint) {
            console.log("warping to ", bestWaypoint);
            const res = await trpc.instructWarp.mutate({
              shipSymbol: GameState.selected.symbol,
              waypointSymbol: bestWaypoint
            });
            GameState.shipData[res.symbol] = res;
          } else {
            alert("Cannot warp to system without waypoints, nothing to target");
          }
        }
      },
      {
        name: "Jump using gate",
        withSelection: "ship",
        isAvailable: async () => {
          const shipData = GameState.shipData[GameState.selected.symbol];
          const currentSystemWaypoints = await trpc.waypointsForSystem.query({
            system: shipData.currentWaypoint.systemSymbol
          });
          const jumpGate = currentSystemWaypoints.find((wp) => wp.type === "JUMP_GATE" && wp.symbol === shipData.currentWaypoint.symbol);
          console.log("deve", { currentSystemWaypoints, jumpGate });
          return !!jumpGate;
        },
        action: async () => {
          const res = await trpc.instructJump.mutate({
            shipSymbol: GameState.selected.symbol,
            systemSymbol: starData.symbol
          });
          GameState.shipData[res.symbol] = res;
        }
      },
      {
        name: "Jump",
        withSelection: "ship",
        isAvailable: async () => {
          const shipData = GameState.shipData[GameState.selected.symbol];
          const jumpRange = shipData.modules.find((m2) => m2.effectName === "JUMP_DRIVE")?.value;
          const currentSystem = GameState.systemData[shipData.currentWaypoint.systemSymbol];
          return !!GameState.selected?.symbol && getDistance(currentSystem, GameState.hoveredSystem) < jumpRange;
        },
        action: async () => {
          const res = await trpc.instructJump.mutate({
            shipSymbol: GameState.selected.symbol,
            systemSymbol: starData.symbol
          });
          GameState.shipData[res.symbol] = res;
        }
      },
      {
        name: "Set behavior",
        withSelection: "ship",
        isAvailable: async () => {
          return true;
        },
        action: async (selectedSymbol) => {
          behaviorWindow.show();
          behaviorWindow.setHome(starData.symbol);
          deselectListeners.once("deselect", () => {
            behaviorWindow.hide();
          });
        }
      }
    ]
  });
  starContainer.on("click", () => {
    loadSystem(starData.symbol);
  });
  const displayCoords = convertToDisplayCoordinates(starData);
  starContainer.x = displayCoords.x;
  starContainer.y = displayCoords.y;
  return starContainer;
}
var loadUniverse = async () => {
  const references = {};
  const systems3 = await trpc.getSystems.query();
  for (const starData of systems3) {
    GameState.systemData[starData.symbol] = starData;
    if (starData.x < universeCoordinates.minX)
      universeCoordinates.minX = starData.x;
    if (starData.x > universeCoordinates.maxX)
      universeCoordinates.maxX = starData.x;
    if (starData.y < universeCoordinates.minY)
      universeCoordinates.minY = starData.y;
    if (starData.y > universeCoordinates.maxY)
      universeCoordinates.maxY = starData.y;
  }
  GameState.systems = {};
  scale.universe = totalSize / (universeCoordinates.maxX - universeCoordinates.minX);
  const influenceGraphics = new Graphics();
  highlightmodes.Factions(influenceGraphics);
  influenceGraphics.name = "highlight";
  universeView.addChild(influenceGraphics);
  const jumpGraphics = new Graphics();
  for (const starData of systems3) {
    const jumpGate = starData.hasJumpGate;
    if (jumpGate && starData.jumpgateRange) {
      const validJumpTargets = systems3.filter((s) => getDistance(s, starData) <= starData.jumpgateRange && s.hasJumpGate && s.symbol !== starData.symbol);
      validJumpTargets.forEach((jumpTarget) => {
        const displayCoords = convertToDisplayCoordinates(starData);
        const targetCoords = convertToDisplayCoordinates(jumpTarget);
        jumpGraphics.stroke({
          width: starData.jumpgateRange / 250,
          color: 10066227,
          alpha: 0.1
        });
        jumpGraphics.moveTo(displayCoords.x, displayCoords.y);
        jumpGraphics.lineTo(targetCoords.x, targetCoords.y);
        jumpGraphics.closePath();
      });
    }
  }
  universeView.addChild(jumpGraphics);
  const routeGraphics = new Graphics();
  routeGraphics.name = "route";
  universeView.addChild(routeGraphics);
  const homeSystemGraphics = new Graphics();
  homeSystemGraphics.name = "homeSystem";
  universeView.addChild(homeSystemGraphics);
  const starsCont = new Container();
  for (const starData of systems3) {
    const starContainer = createStar(starData);
    GameState.systems[starData.symbol] = starContainer;
    starsCont.addChild(starContainer);
    references[starData.symbol] = starContainer;
  }
  universeView.addChild(starsCont);
  universeCuller.addList(starsCont.children);
  resetShipWaypoints();
  GameState.universeShips = {};
  Object.values(GameState.shipData).forEach((ship) => {
    const shipGroup = new Container();
    const itemSprite = new Sprite(loadedAssets.spaceshipTextures[ship.frameSymbol] ? loadedAssets.spaceshipTextures[ship.frameSymbol] : loadedAssets.spaceshipTexture);
    itemSprite.name = "ship";
    itemSprite.pivot = {
      x: 32,
      y: 32
    };
    const navSprite = new Sprite(loadedAssets.navArrow);
    navSprite.pivot = {
      x: navSprite.width / 2,
      y: navSprite.height / 2
    };
    navSprite.name = "nav";
    navSprite.visible = false;
    shipGroup.addChild(navSprite);
    itemSprite.scale = { x: 0.5, y: 0.5 };
    const shipPosition = positionUniverseShip(ship);
    shipGroup.x = shipPosition.x;
    shipGroup.y = shipPosition.y;
    shipGroup.addChild(itemSprite);
    const text = new BitmapText(ship.symbol + " - " + ship.role, {
      fontName: "sans-serif",
      fontSize: 16,
      align: "right"
    });
    text.visible = false;
    text.x = 0;
    text.y = 32;
    shipGroup.addChild(text);
    makeInteractiveAndSelectable(shipGroup, {
      onMouseOver: () => {
        text.visible = true;
      },
      onMouseOut: () => {
        text.visible = false;
      },
      onSelect: {
        type: "ship",
        symbol: ship.symbol
      }
    });
    universeView.addChild(shipGroup);
    GameState.universeShips[ship.symbol] = shipGroup;
  });
  const graphics = new Graphics();
  graphics.lineStyle({
    width: 15,
    color: 30719
  });
  const multiFactor = 5e3 / (universeCoordinates.maxX - universeCoordinates.minX) * totalSize;
  const commandShip = Object.values(GameState.shipData).find((ship) => ship.role === "COMMAND");
  const commandShipLocation = commandShip?.currentWaypoint.systemSymbol;
  universeView.addChild(graphics);
  if (commandShipLocation) {
    universeView.moveCenter(references[commandShipLocation].x, references[commandShipLocation].y);
  }
  return {
    systems: references
  };
};

// src/frontend/game/worldCoordinateToOriginal.ts
var worldCoordinateToOriginal = (point) => {
  const multiFactor = (universeCoordinates.maxX - universeCoordinates.minX) / totalSize;
  return {
    x: Math.round(universeCoordinates.minX + point.x * multiFactor),
    y: Math.round(universeCoordinates.minY + point.y * multiFactor)
  };
};
var systemCoordinateToOriginal = (point) => {
  return {
    x: Math.round(systemCoordinates.minX + point.x / systemScale),
    y: Math.round(systemCoordinates.minY + point.y / systemScale)
  };
};

// src/frontend/game/loadPlayerData.ts
async function loadPlayerData() {
  await trpc.updateAgentInfo.mutate();
  const ships = await trpc.getMyShips.query();
  console.log("my ships", ships);
  ships.forEach((ship) => {
    GameState.shipData[ship.symbol] = ship;
  });
  await updateCredits();
  const factions = await trpc.getFactions.query();
  GameState.factions = {};
  factions.forEach((faction) => {
    GameState.factions[faction.symbol] = faction;
  });
}
async function updateCredits() {
  const agent = await trpc.getAgentInfo.query();
  GameState.agent = agent;
}

// src/frontend/game/targetingLine.ts
var clearGraphics = () => {
  universeGraphics.clear();
  systemGraphics.clear();
  universeGraphicsText.text = "";
  systemGraphicsText.text = "";
};
var warpColor = 4491229;
var jumpColor = 10066227;
var universeTargetingLine = (sizeMultiplier) => {
  if (GameState.hoveredSystem && GameState.currentView == "universe" && GameState.selected?.type === "ship") {
    const selectedShip = GameState.shipData[GameState.selected?.symbol];
    const warpRange = selectedShip.modules.find((m2) => m2.effectName === "WARP_DRIVE")?.value;
    const jumpRange = selectedShip.modules.find((m2) => m2.effectName === "JUMP_DRIVE")?.value;
    const jumpGateRange = GameState.waypointData[selectedShip.currentWaypoint.symbol]?.jumpgate?.range;
    const currentSystemSymbol = GameState.shipData[GameState.selected.symbol].currentWaypoint.systemSymbol;
    const hoveredSystemSymbol = GameState.hoveredSystem.symbol;
    const fromContainer = GameState.systems[currentSystemSymbol];
    const toContainer = GameState.systems[hoveredSystemSymbol];
    if (!fromContainer || !toContainer)
      return;
    const fromData = GameState.systemData[currentSystemSymbol];
    const toData = GameState.systemData[hoveredSystemSymbol];
    const distance = Math.round(Math.sqrt(Math.pow(fromData.x - toData.x, 2) + Math.pow(fromData.y - toData.y, 2)));
    if (jumpRange && distance < (jumpGateRange ?? jumpRange)) {
      universeGraphics.stroke({
        color: jumpColor,
        width: sizeMultiplier
      });
    } else if (warpRange && distance < warpRange) {
      universeGraphics.stroke({
        color: warpColor,
        width: sizeMultiplier
      });
    } else {
      universeGraphics.stroke({
        color: 16711680,
        width: sizeMultiplier
      });
    }
    universeGraphics.moveTo(fromContainer.x, fromContainer.y);
    universeGraphics.lineTo(toContainer.x, toContainer.y);
    universeGraphicsText.x = (fromContainer.x + toContainer.x) / 2;
    universeGraphicsText.y = (fromContainer.y + toContainer.y) / 2 + 120;
    universeGraphicsText.text = `Distance ${distance}`;
    universeGraphicsText.scale = { x: sizeMultiplier, y: sizeMultiplier };
  }
  if (GameState.currentView === "universe" && GameState.selected?.type === "ship") {
    const currentSystemSymbol = GameState.shipData[GameState.selected.symbol].currentWaypoint.systemSymbol;
    const fromContainer = GameState.systems[currentSystemSymbol];
    const selectedShip = GameState.shipData[GameState.selected?.symbol];
    const warpRange = selectedShip.modules.find((m2) => m2.effectName === "WARP_DRIVE")?.value;
    const jumpRange = selectedShip.modules.find((m2) => m2.effectName === "JUMP_DRIVE")?.value;
    const jumpGateRange = GameState.waypointData[selectedShip.currentWaypoint.symbol]?.jumpgate?.range;
    console.log("jumpgate range", jumpGateRange);
    if (warpRange) {
      universeGraphics.stroke({
        color: warpColor,
        width: sizeMultiplier
      });
      universeGraphics.circle(fromContainer.x, fromContainer.y, warpRange * scale.universe);
    }
    if (jumpRange || jumpGateRange) {
      universeGraphics.stroke({
        color: jumpColor,
        width: sizeMultiplier
      });
      universeGraphics.circle(fromContainer.x, fromContainer.y, (jumpGateRange ?? jumpRange) * scale.universe);
    }
  }
};
var systemTargetingLine = () => {
  if (GameState.hoveredWaypoint && GameState.selected?.type === "ship" && GameState.hoveredWaypoint.symbol !== GameState.shipData[GameState.selected.symbol].currentWaypoint.symbol) {
    console.log("shiptargeting");
    systemGraphics.clear();
    systemGraphics.stroke({
      color: 5583871,
      width: 10
    });
    const currentWaypointSymbol = GameState.shipData[GameState.selected.symbol].currentWaypoint.symbol;
    const hoveredWaypointSymbol = GameState.hoveredWaypoint.symbol;
    const fromContainer = GameState.waypoints[currentWaypointSymbol];
    const toContainer = GameState.waypoints[hoveredWaypointSymbol];
    if (!fromContainer || !toContainer)
      return;
    systemGraphics.moveTo(fromContainer.x, fromContainer.y);
    systemGraphics.lineTo(toContainer.x, toContainer.y);
    const fromData = GameState.waypointData[currentWaypointSymbol];
    const toData = GameState.waypointData[hoveredWaypointSymbol];
    systemGraphicsText.x = (toContainer.x - fromContainer.x) / 2;
    systemGraphicsText.y = (toContainer.y - fromContainer.y) / 2 + 120;
    systemGraphicsText.text = `Distance ${Math.round(Math.sqrt(Math.pow(fromData.x - toData.x, 2) + Math.pow(fromData.y - toData.y, 2)))}`;
  }
};

// src/frontend/game/application.ts
var app = new Application();
app.init();

// src/frontend/index.ts
if (!localStorage.getItem("agent-token")) {
  const agentToken = prompt("Please enter your agent token");
  localStorage.setItem("agent-token", agentToken);
}
document.body.appendChild(app.canvas);
app.view.addEventListener("contextmenu", (e) => {
  e.preventDefault();
});
app.stage.interactive = true;
app.stage.hitArea = app.screen;
app.stage.on("click", (event) => {
  console.log(event);
  deselectListeners.emit("deselect");
  GameState.selected = void 0;
});
await loadAssets();
await createUIElements(app);
await loadPlayerData();
var loadedUniverse = await loadUniverse();
var format = Intl.NumberFormat("en");
var lastRefresh = Date.now();
var hidingLabels = false;
var currentRoute;
trpc.event.subscribe(void 0, {
  onData: (data) => {
    console.log("event", data);
    if (data.type == "NAVIGATE") {
      GameState.shipData[data.data.symbol] = data.data;
    }
  }
});
app.ticker.add((dt) => {
  const sizeMultiplier = Math.min(universeView.worldScreenWidth / universeView.screenWidth, 20);
  const shipSizeMultiplier = universeView.worldScreenWidth / universeView.screenWidth;
  credits.displayObject.bitmapText.text = `${format.format(GameState.agent.credits)}`;
  if (GameState.currentView == "universe") {
    Object.values(loadedUniverse.systems).forEach((ref) => {
      ref.scale = { x: sizeMultiplier, y: sizeMultiplier };
    });
    if (!hidingLabels && shipSizeMultiplier > 15) {
      hidingLabels = true;
      Object.values(loadedUniverse.systems).forEach((ref) => {
        ref.getChildByName("label").visible = false;
        ref.interactive = false;
      });
    } else if (hidingLabels && shipSizeMultiplier < 15) {
      hidingLabels = false;
      Object.values(loadedUniverse.systems).forEach((ref) => {
        ref.getChildByName("label").visible = true;
        ref.interactive = true;
      });
    }
    const worldCoordinates = worldCoordinateToOriginal(universeView.toWorld(app.renderer.plugins.interaction.rootPointerEvent.offset));
    currentCoordinate.text = worldCoordinates.x + ", " + worldCoordinates.y;
    resetShipWaypoints();
    Object.keys(GameState.universeShips).forEach((shipKey) => {
      const shipData = GameState.shipData[shipKey];
      const shipContainer = GameState.universeShips[shipKey];
      shipContainer.scale = { x: shipSizeMultiplier, y: shipSizeMultiplier };
      const shipPosition = positionUniverseShip(shipData);
      shipContainer.x = shipPosition.x;
      shipContainer.y = shipPosition.y;
      const nav = shipContainer.getChildByName("nav");
      if (nav) {
        if (shipPosition.navRot) {
          nav.visible = true;
          shipContainer.getChildByName("ship").rotation = shipPosition.navRot;
          shipContainer.getChildByName("nav").rotation = shipPosition.navRot;
        } else {
          nav.visible = false;
          shipContainer.getChildByName("ship").rotation = 0;
          shipContainer.getChildByName("nav").rotation = 0;
        }
      }
      if (shipData.navStatus === "IN_TRANSIT" && new Date(shipData.arrivalOn).getTime() < Date.now()) {
        shipData.navStatus = "IN_ORBIT";
      }
    });
  } else {
    const systemCoordinate = systemCoordinateToOriginal(systemView.toWorld(app.renderer.plugins.interaction.rootPointerEvent.offset));
    currentCoordinate.text = systemCoordinate.x + ", " + systemCoordinate.y;
    Object.keys(GameState.waypoints).forEach((waypointSymbol) => {
      const waypointItem = GameState.waypoints[waypointSymbol];
      const waypointData = GameState.waypointData[waypointSymbol];
      const newPosition = positionWaypoint(waypointData, Date.now());
      waypointItem.x = newPosition.x;
      waypointItem.y = newPosition.y;
    });
    resetShipWaypoints();
    Object.keys(GameState.systemShips).forEach((shipKey) => {
      const shipData = GameState.shipData[shipKey];
      const shipContainer = GameState.systemShips[shipKey];
      const shipPosition = positionShip(shipData);
      shipContainer.x = shipPosition.x;
      shipContainer.y = shipPosition.y;
      const nav = shipContainer.getChildByName("nav");
      if (nav) {
        if (shipPosition.navRot) {
          nav.visible = true;
          shipContainer.getChildByName("ship").rotation = shipPosition.navRot;
          shipContainer.getChildByName("nav").rotation = shipPosition.navRot;
        } else {
          nav.visible = false;
          shipContainer.getChildByName("ship").rotation = 0;
          shipContainer.getChildByName("nav").rotation = 0;
        }
      }
      if (shipData.navStatus === "IN_TRANSIT" && new Date(shipData.arrivalOn).getTime() < Date.now()) {
        shipData.navStatus = "IN_ORBIT";
      }
    });
  }
  clearGraphics();
  universeTargetingLine(sizeMultiplier);
  systemTargetingLine();
  const homeGraphics = universeView.getChildByName("homeSystem");
  if (GameState.selected) {
    if (GameState.selected.type === "ship") {
      const shipInfo = GameState.shipData[GameState.selected.symbol];
      cruiseModeSelect.displayObject.visible = true;
      if (shipInfo.flightMode && cruiseModeSelect.selectedValue !== shipInfo.flightMode) {
        cruiseModeSelect.setSelectedValue(shipInfo.flightMode);
      }
      const cooldownTime = new Date(shipInfo.reactorCooldownOn).getTime();
      const cooldownValue = cooldownTime > Date.now() ? Math.round((cooldownTime - Date.now()) / 1e3) + "s" : "Ready";
      const navTime = new Date(shipInfo.arrivalOn).getTime();
      const arrivalValue = navTime > Date.now() ? Math.round((navTime - Date.now()) / 1e3) + "s" : "Ready";
      if (GameState.agent.symbol === shipInfo.agent) {
        entityInfo.displayObject.bitmapText.text = `Entity Information
Symbol: ${shipInfo.symbol}
Location: ${shipInfo.currentWaypoint.symbol}
Fuel: ${shipInfo.fuelAvailable}/${shipInfo.fuelCapacity}
Cargo: ${shipInfo.cargoUsed}/${shipInfo.cargoCapacity}
Nav Status: ${shipInfo.navStatus} ${arrivalValue}
Reactor Cooldown: ${cooldownValue}
Action: ${shipInfo.overalGoal}`;
      } else {
        entityInfo.displayObject.bitmapText.text = `Entity Information
Symbol: ${shipInfo.symbol}
Location: ${shipInfo.currentWaypoint.symbol}
Owner: ${shipInfo.agent}
Nav Status: ${shipInfo.navStatus} ${arrivalValue}
Last update: ${Math.round((Date.now() - new Date(shipInfo.updatedAt).getTime()) / 1e3)}s ago`;
      }
      if (GameState.hoveredSystem) {
        if (currentRoute != GameState.hoveredSystem + GameState.selected.symbol) {
          currentRoute = GameState.hoveredSystem + GameState.selected.symbol;
          const route = trpc.getRoute.query({
            fromSystemSymbol: shipInfo.currentSystemSymbol,
            toSystemSymbol: GameState.hoveredSystem.symbol
          }).then((data) => {
            const graphics = universeView.getChildByName("route");
            graphics.clear();
            data.finalPath.forEach((item) => {
              const fromSystem = GameState.systemData[item.source];
              const toSystem = GameState.systemData[item.target];
              const displayCoords = convertToDisplayCoordinates(fromSystem);
              const targetCoords = convertToDisplayCoordinates(toSystem);
              graphics.lineStyle({
                width: 10,
                color: 65280,
                alpha: 0.25
              });
              graphics.moveTo(displayCoords.x, displayCoords.y);
              graphics.lineTo(targetCoords.x, targetCoords.y);
              graphics.closePath();
            });
          });
        }
      } else {
        currentRoute = "";
        const graphics = universeView.getChildByName("route");
        graphics.clear();
      }
      if (GameState.currentView == "universe" && shipInfo.currentBehavior) {
        homeGraphics.clear();
        const homeSystem = GameState.systemData[shipInfo.homeSystemSymbol];
        const shipCoordinates = GameState.universeShips[shipInfo.symbol].position;
        const displayCoordinates = convertToDisplayCoordinates(homeSystem);
        homeGraphics.lineStyle({
          width: 10 * sizeMultiplier,
          color: 65280,
          alpha: 0.5
        });
        homeGraphics.moveTo(shipCoordinates.x, shipCoordinates.y);
        homeGraphics.lineTo(displayCoordinates.x, displayCoordinates.y);
        homeGraphics.closePath();
        homeGraphics.lineStyle({
          width: 10 * sizeMultiplier,
          color: 16777215,
          alpha: 0.5
        });
        const range = shipInfo.behaviorRange * scale.universe;
        homeGraphics.drawRect(displayCoordinates.x - range, displayCoordinates.y - range, range * 2, range * 2);
        homeGraphics.closePath();
      } else {
        homeGraphics.clear();
      }
    } else if (GameState.selected.type === "waypoint") {
      const waypointInfo = GameState.waypointData[GameState.selected.symbol];
      entityInfo.displayObject.bitmapText.text = `Entity Information
Symbol: ${GameState.selected.symbol}
Kind: ${waypointInfo.type}
Traits: ${waypointInfo.traits.length == 0 ? "UNKNOWN" : waypointInfo.traits.map((t) => t.name).join(", ")}
Faction: ${waypointInfo.factionSymbol}
Chart: ${waypointInfo.chartSubmittedBy ? `${waypointInfo.chartSubmittedBy} at ${waypointInfo.chartSubmittedOn}` : "None"}`;
      if (waypointInfo.traits.find((t) => t.symbol === "MARKETPLACE") && GameState.displayedMarket !== GameState.selected.symbol) {
        GameState.displayedMarket = GameState.selected.symbol;
        trpc.getMarketInfo.query({
          waypoint: GameState.selected.symbol
        }).then((data) => {
          console.log("marketinfo", data);
          marketWindow.clearGoods();
          marketWindow.setGoods(data);
          marketWindow.container.displayObject.x = 400;
          marketWindow.container.displayObject.y = gameHeight - 300;
          marketWindow.container.displayObject.visible = true;
        });
      }
    }
  } else {
    currentRoute = "";
    const graphics = universeView.getChildByName("route");
    graphics.clear();
    homeGraphics.clear();
    GameState.displayedMarket = void 0;
    marketWindow.container.displayObject.visible = false;
    cruiseModeSelect.displayObject.visible = false;
    entityInfo.displayObject.bitmapText.text = `Entity Information`;
  }
  if (universeView.dirty) {
    universeCuller.cull(universeView.getVisibleBounds());
    universeView.dirty = false;
  }
  fps.text = `FPS: ${Math.round(app.ticker.FPS)}`;
});
/*! Bundled license information:

@trpc/client/dist/httpUtils-0cb58db4.mjs:
  (* istanbul ignore if -- @preserve *)

@trpc/client/dist/links/wsLink.mjs:
  (* istanbul ignore next -- @preserve *)

pixi-cull/dist/pixi-cull.es.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
