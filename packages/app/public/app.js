var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/point/Point.mjs
var Point, tempPoint;
var init_Point = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/point/Point.mjs"() {
    Point = class _Point {
      /**
       * Creates a new `Point`
       * @param {number} [x=0] - position of the point on the x axis
       * @param {number} [y=0] - position of the point on the y axis
       */
      constructor(x3 = 0, y2 = 0) {
        this.x = 0;
        this.y = 0;
        this.x = x3;
        this.y = y2;
      }
      /**
       * Creates a clone of this point
       * @returns A clone of this point
       */
      clone() {
        return new _Point(this.x, this.y);
      }
      /**
       * Copies `x` and `y` from the given point into this point
       * @param p - The point to copy from
       * @returns The point instance itself
       */
      copyFrom(p2) {
        this.set(p2.x, p2.y);
        return this;
      }
      /**
       * Copies this point's x and y into the given point (`p`).
       * @param p - The point to copy to. Can be any of type that is or extends `PointData`
       * @returns The point (`p`) with values updated
       */
      copyTo(p2) {
        p2.set(this.x, this.y);
        return p2;
      }
      /**
       * Accepts another point (`p`) and returns `true` if the given point is equal to this point
       * @param p - The point to check
       * @returns Returns `true` if both `x` and `y` are equal
       */
      equals(p2) {
        return p2.x === this.x && p2.y === this.y;
      }
      /**
       * Sets the point to a new `x` and `y` position.
       * If `y` is omitted, both `x` and `y` will be set to `x`.
       * @param {number} [x=0] - position of the point on the `x` axis
       * @param {number} [y=x] - position of the point on the `y` axis
       * @returns The point instance itself
       */
      set(x3 = 0, y2 = x3) {
        this.x = x3;
        this.y = y2;
        return this;
      }
      toString() {
        return `[@pixi/math:Point x=${this.x} y=${this.y}]`;
      }
      static get shared() {
        tempPoint.x = 0;
        tempPoint.y = 0;
        return tempPoint;
      }
    };
    tempPoint = new Point();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/FederatedEvent.mjs
var FederatedEvent;
var init_FederatedEvent = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/FederatedEvent.mjs"() {
    init_Point();
    FederatedEvent = class _FederatedEvent {
      /**
       * @param manager - The event boundary which manages this event. Propagation can only occur
       *  within the boundary's jurisdiction.
       */
      constructor(manager) {
        this.bubbles = true;
        this.cancelBubble = true;
        this.cancelable = false;
        this.composed = false;
        this.defaultPrevented = false;
        this.eventPhase = _FederatedEvent.prototype.NONE;
        this.propagationStopped = false;
        this.propagationImmediatelyStopped = false;
        this.layer = new Point();
        this.page = new Point();
        this.NONE = 0;
        this.CAPTURING_PHASE = 1;
        this.AT_TARGET = 2;
        this.BUBBLING_PHASE = 3;
        this.manager = manager;
      }
      /** @readonly */
      get layerX() {
        return this.layer.x;
      }
      /** @readonly */
      get layerY() {
        return this.layer.y;
      }
      /** @readonly */
      get pageX() {
        return this.page.x;
      }
      /** @readonly */
      get pageY() {
        return this.page.y;
      }
      /**
       * Fallback for the deprecated @code{InteractionEvent.data}.
       * @deprecated since 7.0.0
       */
      get data() {
        return this;
      }
      /** The propagation path for this event. Alias for {@link EventBoundary.propagationPath}. */
      composedPath() {
        if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
          this.path = this.target ? this.manager.propagationPath(this.target) : [];
        }
        return this.path;
      }
      /**
       * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw an {@code Error}.
       * @deprecated
       * @param _type
       * @param _bubbles
       * @param _cancelable
       */
      initEvent(_type, _bubbles, _cancelable) {
        throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
      }
      /**
       * Unimplemented method included for implementing the DOM interface {@code UIEvent}. It will throw an {@code Error}.
       * @deprecated
       * @param _typeArg
       * @param _bubblesArg
       * @param _cancelableArg
       * @param _viewArg
       * @param _detailArg
       */
      initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
        throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
      }
      /** Prevent default behavior of PixiJS and the user agent. */
      preventDefault() {
        if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
          this.nativeEvent.preventDefault();
        }
        this.defaultPrevented = true;
      }
      /**
       * Stop this event from propagating to any addition listeners, including on the
       * {@link FederatedEventTarget.currentTarget currentTarget} and also the following
       * event targets on the propagation path.
       */
      stopImmediatePropagation() {
        this.propagationImmediatelyStopped = true;
      }
      /**
       * Stop this event from propagating to the next {@link FederatedEventTarget}. The rest of the listeners
       * on the {@link FederatedEventTarget.currentTarget currentTarget} will still be notified.
       */
      stopPropagation() {
        this.propagationStopped = true;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/extensions/Extensions.mjs
var ExtensionType, normalizeExtension, normalizeExtensionPriority, extensions;
var init_Extensions = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/extensions/Extensions.mjs"() {
    ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
      ExtensionType2["Renderer"] = "renderer";
      ExtensionType2["Application"] = "application";
      ExtensionType2["WebGLPipes"] = "webgl-pipes";
      ExtensionType2["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";
      ExtensionType2["WebGLSystem"] = "webgl-system";
      ExtensionType2["WebGPUPipes"] = "webgpu-pipes";
      ExtensionType2["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";
      ExtensionType2["WebGPUSystem"] = "webgpu-system";
      ExtensionType2["CanvasSystem"] = "canvas-system";
      ExtensionType2["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";
      ExtensionType2["CanvasPipes"] = "canvas-pipes";
      ExtensionType2["Asset"] = "asset";
      ExtensionType2["LoadParser"] = "load-parser";
      ExtensionType2["ResolveParser"] = "resolve-parser";
      ExtensionType2["CacheParser"] = "cache-parser";
      ExtensionType2["DetectionParser"] = "detection-parser";
      ExtensionType2["MaskEffect"] = "mask-effect";
      ExtensionType2["BlendMode"] = "blend-mode";
      ExtensionType2["TextureSource"] = "texture-source";
      return ExtensionType2;
    })(ExtensionType || {});
    normalizeExtension = (ext) => {
      if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
        if (!ext.extension) {
          throw new Error("Extension class must have an extension object");
        }
        const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
        ext = { ...metadata, ref: ext };
      }
      if (typeof ext === "object") {
        ext = { ...ext };
      } else {
        throw new Error("Invalid extension type");
      }
      if (typeof ext.type === "string") {
        ext.type = [ext.type];
      }
      return ext;
    };
    normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;
    extensions = {
      /** @ignore */
      _addHandlers: {},
      /** @ignore */
      _removeHandlers: {},
      /** @ignore */
      _queue: {},
      /**
       * Remove extensions from PixiJS.
       * @param extensions - Extensions to be removed.
       * @returns {extensions} For chaining.
       */
      remove(...extensions2) {
        extensions2.map(normalizeExtension).forEach((ext) => {
          ext.type.forEach((type) => this._removeHandlers[type]?.(ext));
        });
        return this;
      },
      /**
       * Register new extensions with PixiJS.
       * @param extensions - The spread of extensions to add to PixiJS.
       * @returns {extensions} For chaining.
       */
      add(...extensions2) {
        extensions2.map(normalizeExtension).forEach((ext) => {
          ext.type.forEach((type) => {
            const handlers = this._addHandlers;
            const queue = this._queue;
            if (!handlers[type]) {
              queue[type] = queue[type] || [];
              queue[type].push(ext);
            } else {
              handlers[type](ext);
            }
          });
        });
        return this;
      },
      /**
       * Internal method to handle extensions by name.
       * @param type - The extension type.
       * @param onAdd  - Function for handling when extensions are added/registered passes {@link ExtensionFormat}.
       * @param onRemove  - Function for handling when extensions are removed/unregistered passes {@link ExtensionFormat}.
       * @returns {extensions} For chaining.
       */
      handle(type, onAdd, onRemove) {
        const addHandlers = this._addHandlers;
        const removeHandlers = this._removeHandlers;
        if (addHandlers[type] || removeHandlers[type]) {
          throw new Error(`Extension type ${type} already has a handler`);
        }
        addHandlers[type] = onAdd;
        removeHandlers[type] = onRemove;
        const queue = this._queue;
        if (queue[type]) {
          queue[type].forEach((ext) => onAdd(ext));
          delete queue[type];
        }
        return this;
      },
      /**
       * Handle a type, but using a map by `name` property.
       * @param type - Type of extension to handle.
       * @param map - The object map of named extensions.
       * @returns {extensions} For chaining.
       */
      handleByMap(type, map2) {
        return this.handle(
          type,
          (extension) => {
            map2[extension.name] = extension.ref;
          },
          (extension) => {
            delete map2[extension.name];
          }
        );
      },
      /**
       * Handle a type, but using a list of extensions with a `name` property.
       * @param type - Type of extension to handle.
       * @param map - The array of named extensions.
       * @param defaultPriority - Fallback priority if none is defined.
       * @returns {extensions} For chaining.
       */
      handleByNamedList(type, map2, defaultPriority = -1) {
        return this.handle(
          type,
          (extension) => {
            const index = map2.findIndex((item) => item.name === extension.name);
            if (index >= 0)
              return;
            map2.push({ name: extension.name, value: extension.ref });
            map2.sort((a2, b2) => normalizeExtensionPriority(b2.value, defaultPriority) - normalizeExtensionPriority(a2.value, defaultPriority));
          },
          (extension) => {
            const index = map2.findIndex((item) => item.name === extension.name);
            if (index !== -1) {
              map2.splice(index, 1);
            }
          }
        );
      },
      /**
       * Handle a type, but using a list of extensions.
       * @param type - Type of extension to handle.
       * @param list - The list of extensions.
       * @param defaultPriority - The default priority to use if none is specified.
       * @returns {extensions} For chaining.
       */
      handleByList(type, list, defaultPriority = -1) {
        return this.handle(
          type,
          (extension) => {
            if (list.includes(extension.ref)) {
              return;
            }
            list.push(extension.ref);
            list.sort((a2, b2) => normalizeExtensionPriority(b2, defaultPriority) - normalizeExtensionPriority(a2, defaultPriority));
          },
          (extension) => {
            const index = list.indexOf(extension.ref);
            if (index !== -1) {
              list.splice(index, 1);
            }
          }
        );
      }
    };
  }
});

// ../../node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "../../node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context2, once) {
      this.fn = fn;
      this.context = context2;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context2, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context2 || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter3.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
        ee[i2] = handlers[i2].fn;
      }
      return ee;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter3.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j3;
        for (i2 = 0; i2 < length; i2++) {
          if (listeners[i2].once)
            this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a2);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j3 = 1, args = new Array(len - 1); j3 < len; j3++) {
                  args[j3 - 1] = arguments[j3];
                }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on(event, fn, context2) {
      return addListener(this, event, fn, context2, false);
    };
    EventEmitter3.prototype.once = function once(event, fn, context2) {
      return addListener(this, event, fn, context2, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener(event, fn, context2, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context2 || listeners.context === context2)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
          if (listeners[i2].fn !== fn || once && !listeners[i2].once || context2 && listeners[i2].context !== context2) {
            events.push(listeners[i2]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter3;
    }
  }
});

// ../../node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.mjs
var import_index, eventemitter3_default;
var init_eventemitter3 = __esm({
  "../../node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.mjs"() {
    import_index = __toESM(require_eventemitter3(), 1);
    eventemitter3_default = import_index.default;
  }
});

// ../../node_modules/.pnpm/@pixi+colord@2.9.6/node_modules/@pixi/colord/index.mjs
var r, t, n, e, u, a, o, i, s, h, b, g, d, f, c, l, p, v, m, y, N, x, M, H, $, j, w, S, k;
var init_colord = __esm({
  "../../node_modules/.pnpm/@pixi+colord@2.9.6/node_modules/@pixi/colord/index.mjs"() {
    r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
    t = function(r2) {
      return "string" == typeof r2 ? r2.length > 0 : "number" == typeof r2;
    };
    n = function(r2, t2, n2) {
      return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
    };
    e = function(r2, t2, n2) {
      return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
    };
    u = function(r2) {
      return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
    };
    a = function(r2) {
      return { r: e(r2.r, 0, 255), g: e(r2.g, 0, 255), b: e(r2.b, 0, 255), a: e(r2.a) };
    };
    o = function(r2) {
      return { r: n(r2.r), g: n(r2.g), b: n(r2.b), a: n(r2.a, 3) };
    };
    i = /^#([0-9a-f]{3,8})$/i;
    s = function(r2) {
      var t2 = r2.toString(16);
      return t2.length < 2 ? "0" + t2 : t2;
    };
    h = function(r2) {
      var t2 = r2.r, n2 = r2.g, e2 = r2.b, u3 = r2.a, a2 = Math.max(t2, n2, e2), o2 = a2 - Math.min(t2, n2, e2), i2 = o2 ? a2 === t2 ? (n2 - e2) / o2 : a2 === n2 ? 2 + (e2 - t2) / o2 : 4 + (t2 - n2) / o2 : 0;
      return { h: 60 * (i2 < 0 ? i2 + 6 : i2), s: a2 ? o2 / a2 * 100 : 0, v: a2 / 255 * 100, a: u3 };
    };
    b = function(r2) {
      var t2 = r2.h, n2 = r2.s, e2 = r2.v, u3 = r2.a;
      t2 = t2 / 360 * 6, n2 /= 100, e2 /= 100;
      var a2 = Math.floor(t2), o2 = e2 * (1 - n2), i2 = e2 * (1 - (t2 - a2) * n2), s2 = e2 * (1 - (1 - t2 + a2) * n2), h2 = a2 % 6;
      return { r: 255 * [e2, i2, o2, o2, s2, e2][h2], g: 255 * [s2, e2, e2, i2, o2, o2][h2], b: 255 * [o2, o2, s2, e2, e2, i2][h2], a: u3 };
    };
    g = function(r2) {
      return { h: u(r2.h), s: e(r2.s, 0, 100), l: e(r2.l, 0, 100), a: e(r2.a) };
    };
    d = function(r2) {
      return { h: n(r2.h), s: n(r2.s), l: n(r2.l), a: n(r2.a, 3) };
    };
    f = function(r2) {
      return b((n2 = (t2 = r2).s, { h: t2.h, s: (n2 *= ((e2 = t2.l) < 50 ? e2 : 100 - e2) / 100) > 0 ? 2 * n2 / (e2 + n2) * 100 : 0, v: e2 + n2, a: t2.a }));
      var t2, n2, e2;
    };
    c = function(r2) {
      return { h: (t2 = h(r2)).h, s: (u3 = (200 - (n2 = t2.s)) * (e2 = t2.v) / 100) > 0 && u3 < 200 ? n2 * e2 / 100 / (u3 <= 100 ? u3 : 200 - u3) * 100 : 0, l: u3 / 2, a: t2.a };
      var t2, n2, e2, u3;
    };
    l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    y = { string: [[function(r2) {
      var t2 = i.exec(r2);
      return t2 ? (r2 = t2[1]).length <= 4 ? { r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: 4 === r2.length ? n(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1 } : 6 === r2.length || 8 === r2.length ? { r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: 8 === r2.length ? n(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
    }, "hex"], [function(r2) {
      var t2 = v.exec(r2) || m.exec(r2);
      return t2 ? t2[2] !== t2[4] || t2[4] !== t2[6] ? null : a({ r: Number(t2[1]) / (t2[2] ? 100 / 255 : 1), g: Number(t2[3]) / (t2[4] ? 100 / 255 : 1), b: Number(t2[5]) / (t2[6] ? 100 / 255 : 1), a: void 0 === t2[7] ? 1 : Number(t2[7]) / (t2[8] ? 100 : 1) }) : null;
    }, "rgb"], [function(t2) {
      var n2 = l.exec(t2) || p.exec(t2);
      if (!n2)
        return null;
      var e2, u3, a2 = g({ h: (e2 = n2[1], u3 = n2[2], void 0 === u3 && (u3 = "deg"), Number(e2) * (r[u3] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: void 0 === n2[5] ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
      return f(a2);
    }, "hsl"]], object: [[function(r2) {
      var n2 = r2.r, e2 = r2.g, u3 = r2.b, o2 = r2.a, i2 = void 0 === o2 ? 1 : o2;
      return t(n2) && t(e2) && t(u3) ? a({ r: Number(n2), g: Number(e2), b: Number(u3), a: Number(i2) }) : null;
    }, "rgb"], [function(r2) {
      var n2 = r2.h, e2 = r2.s, u3 = r2.l, a2 = r2.a, o2 = void 0 === a2 ? 1 : a2;
      if (!t(n2) || !t(e2) || !t(u3))
        return null;
      var i2 = g({ h: Number(n2), s: Number(e2), l: Number(u3), a: Number(o2) });
      return f(i2);
    }, "hsl"], [function(r2) {
      var n2 = r2.h, a2 = r2.s, o2 = r2.v, i2 = r2.a, s2 = void 0 === i2 ? 1 : i2;
      if (!t(n2) || !t(a2) || !t(o2))
        return null;
      var h2 = function(r3) {
        return { h: u(r3.h), s: e(r3.s, 0, 100), v: e(r3.v, 0, 100), a: e(r3.a) };
      }({ h: Number(n2), s: Number(a2), v: Number(o2), a: Number(s2) });
      return b(h2);
    }, "hsv"]] };
    N = function(r2, t2) {
      for (var n2 = 0; n2 < t2.length; n2++) {
        var e2 = t2[n2][0](r2);
        if (e2)
          return [e2, t2[n2][1]];
      }
      return [null, void 0];
    };
    x = function(r2) {
      return "string" == typeof r2 ? N(r2.trim(), y.string) : "object" == typeof r2 && null !== r2 ? N(r2, y.object) : [null, void 0];
    };
    M = function(r2, t2) {
      var n2 = c(r2);
      return { h: n2.h, s: e(n2.s + 100 * t2, 0, 100), l: n2.l, a: n2.a };
    };
    H = function(r2) {
      return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1e3 / 255;
    };
    $ = function(r2, t2) {
      var n2 = c(r2);
      return { h: n2.h, s: n2.s, l: e(n2.l + 100 * t2, 0, 100), a: n2.a };
    };
    j = function() {
      function r2(r3) {
        this.parsed = x(r3)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
      }
      return r2.prototype.isValid = function() {
        return null !== this.parsed;
      }, r2.prototype.brightness = function() {
        return n(H(this.rgba), 2);
      }, r2.prototype.isDark = function() {
        return H(this.rgba) < 0.5;
      }, r2.prototype.isLight = function() {
        return H(this.rgba) >= 0.5;
      }, r2.prototype.toHex = function() {
        return r3 = o(this.rgba), t2 = r3.r, e2 = r3.g, u3 = r3.b, i2 = (a2 = r3.a) < 1 ? s(n(255 * a2)) : "", "#" + s(t2) + s(e2) + s(u3) + i2;
        var r3, t2, e2, u3, a2, i2;
      }, r2.prototype.toRgb = function() {
        return o(this.rgba);
      }, r2.prototype.toRgbString = function() {
        return r3 = o(this.rgba), t2 = r3.r, n2 = r3.g, e2 = r3.b, (u3 = r3.a) < 1 ? "rgba(" + t2 + ", " + n2 + ", " + e2 + ", " + u3 + ")" : "rgb(" + t2 + ", " + n2 + ", " + e2 + ")";
        var r3, t2, n2, e2, u3;
      }, r2.prototype.toHsl = function() {
        return d(c(this.rgba));
      }, r2.prototype.toHslString = function() {
        return r3 = d(c(this.rgba)), t2 = r3.h, n2 = r3.s, e2 = r3.l, (u3 = r3.a) < 1 ? "hsla(" + t2 + ", " + n2 + "%, " + e2 + "%, " + u3 + ")" : "hsl(" + t2 + ", " + n2 + "%, " + e2 + "%)";
        var r3, t2, n2, e2, u3;
      }, r2.prototype.toHsv = function() {
        return r3 = h(this.rgba), { h: n(r3.h), s: n(r3.s), v: n(r3.v), a: n(r3.a, 3) };
        var r3;
      }, r2.prototype.invert = function() {
        return w({ r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a });
        var r3;
      }, r2.prototype.saturate = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, r3));
      }, r2.prototype.desaturate = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, -r3));
      }, r2.prototype.grayscale = function() {
        return w(M(this.rgba, -1));
      }, r2.prototype.lighten = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w($(this.rgba, r3));
      }, r2.prototype.darken = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w($(this.rgba, -r3));
      }, r2.prototype.rotate = function(r3) {
        return void 0 === r3 && (r3 = 15), this.hue(this.hue() + r3);
      }, r2.prototype.alpha = function(r3) {
        return "number" == typeof r3 ? w({ r: (t2 = this.rgba).r, g: t2.g, b: t2.b, a: r3 }) : n(this.rgba.a, 3);
        var t2;
      }, r2.prototype.hue = function(r3) {
        var t2 = c(this.rgba);
        return "number" == typeof r3 ? w({ h: r3, s: t2.s, l: t2.l, a: t2.a }) : n(t2.h);
      }, r2.prototype.isEqual = function(r3) {
        return this.toHex() === w(r3).toHex();
      }, r2;
    }();
    w = function(r2) {
      return r2 instanceof j ? r2 : new j(r2);
    };
    S = [];
    k = function(r2) {
      r2.forEach(function(r3) {
        S.indexOf(r3) < 0 && (r3(j, y), S.push(r3));
      });
    };
  }
});

// ../../node_modules/.pnpm/@pixi+colord@2.9.6/node_modules/@pixi/colord/plugins/names.mjs
function names_default(e2, f2) {
  var a2 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r2 = {};
  for (var d3 in a2)
    r2[a2[d3]] = d3;
  var l2 = {};
  e2.prototype.toName = function(f3) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
      return "transparent";
    var d4, i2, n2 = r2[this.toHex()];
    if (n2)
      return n2;
    if (null == f3 ? void 0 : f3.closest) {
      var o2 = this.toRgb(), t2 = 1 / 0, b2 = "black";
      if (!l2.length)
        for (var c2 in a2)
          l2[c2] = new e2(a2[c2]).toRgb();
      for (var g2 in a2) {
        var u3 = (d4 = o2, i2 = l2[g2], Math.pow(d4.r - i2.r, 2) + Math.pow(d4.g - i2.g, 2) + Math.pow(d4.b - i2.b, 2));
        u3 < t2 && (t2 = u3, b2 = g2);
      }
      return b2;
    }
  };
  f2.string.push([function(f3) {
    var r3 = f3.toLowerCase(), d4 = "transparent" === r3 ? "#0000" : a2[r3];
    return d4 ? new e2(d4).toRgb() : null;
  }, "name"]);
}
var init_names = __esm({
  "../../node_modules/.pnpm/@pixi+colord@2.9.6/node_modules/@pixi/colord/plugins/names.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/color/Color.mjs
var _Color, Color;
var init_Color = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/color/Color.mjs"() {
    init_colord();
    init_names();
    k([names_default]);
    _Color = class {
      /**
       * @param {ColorSource} value - Optional value to use, if not provided, white is used.
       */
      constructor(value = 16777215) {
        this._value = null;
        this._components = new Float32Array(4);
        this._components.fill(1);
        this._int = 16777215;
        this.value = value;
      }
      /** Get red component (0 - 1) */
      get red() {
        return this._components[0];
      }
      /** Get green component (0 - 1) */
      get green() {
        return this._components[1];
      }
      /** Get blue component (0 - 1) */
      get blue() {
        return this._components[2];
      }
      /** Get alpha component (0 - 1) */
      get alpha() {
        return this._components[3];
      }
      /**
       * Set the value, suitable for chaining
       * @param value
       * @see Color.value
       */
      setValue(value) {
        this.value = value;
        return this;
      }
      /**
       * The current color source.
       *
       * When setting:
       * - Setting to an instance of `Color` will copy its color source and components.
       * - Otherwise, `Color` will try to normalize the color source and set the components.
       *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.
       *
       * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter
       * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.
       *
       * When getting:
       * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},
       *   {@link Color.premultiply premultiply} or {@link Color.round round}).
       * - Otherwise, the color source used when setting is returned.
       * @type {ColorSource}
       */
      set value(value) {
        if (value instanceof _Color) {
          this._value = this._cloneSource(value._value);
          this._int = value._int;
          this._components.set(value._components);
        } else if (value === null) {
          throw new Error("Cannot set Color#value to null");
        } else if (this._value === null || !this._isSourceEqual(this._value, value)) {
          this._normalize(value);
          this._value = this._cloneSource(value);
        }
      }
      get value() {
        return this._value;
      }
      /**
       * Copy a color source internally.
       * @param value - Color source
       */
      _cloneSource(value) {
        if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
          return value;
        } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
          return value.slice(0);
        } else if (typeof value === "object" && value !== null) {
          return { ...value };
        }
        return value;
      }
      /**
       * Equality check for color sources.
       * @param value1 - First color source
       * @param value2 - Second color source
       * @returns `true` if the color sources are equal, `false` otherwise.
       */
      _isSourceEqual(value1, value2) {
        const type1 = typeof value1;
        const type2 = typeof value2;
        if (type1 !== type2) {
          return false;
        } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
          return value1 === value2;
        } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
          if (value1.length !== value2.length) {
            return false;
          }
          return value1.every((v3, i2) => v3 === value2[i2]);
        } else if (value1 !== null && value2 !== null) {
          const keys1 = Object.keys(value1);
          const keys2 = Object.keys(value2);
          if (keys1.length !== keys2.length) {
            return false;
          }
          return keys1.every((key) => value1[key] === value2[key]);
        }
        return value1 === value2;
      }
      /**
       * Convert to a RGBA color object.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }
       */
      toRgba() {
        const [r2, g2, b2, a2] = this._components;
        return { r: r2, g: g2, b: b2, a: a2 };
      }
      /**
       * Convert to a RGB color object.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }
       */
      toRgb() {
        const [r2, g2, b2] = this._components;
        return { r: r2, g: g2, b: b2 };
      }
      /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */
      toRgbaString() {
        const [r2, g2, b2] = this.toUint8RgbArray();
        return `rgba(${r2},${g2},${b2},${this.alpha})`;
      }
      toUint8RgbArray(out2) {
        const [r2, g2, b2] = this._components;
        if (!this._arrayRgb) {
          this._arrayRgb = [];
        }
        out2 = out2 || this._arrayRgb;
        out2[0] = Math.round(r2 * 255);
        out2[1] = Math.round(g2 * 255);
        out2[2] = Math.round(b2 * 255);
        return out2;
      }
      toArray(out2) {
        if (!this._arrayRgba) {
          this._arrayRgba = [];
        }
        out2 = out2 || this._arrayRgba;
        const [r2, g2, b2, a2] = this._components;
        out2[0] = r2;
        out2[1] = g2;
        out2[2] = b2;
        out2[3] = a2;
        return out2;
      }
      toRgbArray(out2) {
        if (!this._arrayRgb) {
          this._arrayRgb = [];
        }
        out2 = out2 || this._arrayRgb;
        const [r2, g2, b2] = this._components;
        out2[0] = r2;
        out2[1] = g2;
        out2[2] = b2;
        return out2;
      }
      /**
       * Convert to a hexadecimal number.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toNumber(); // returns 16777215
       */
      toNumber() {
        return this._int;
      }
      /**
       * Convert to a BGR number
       * @example
       * import { Color } from 'pixi.js';
       * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff
       */
      toBgrNumber() {
        const [r2, g2, b2] = this.toUint8RgbArray();
        return (b2 << 16) + (g2 << 8) + r2;
      }
      /**
       * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
       * @example
       * import { Color } from 'pixi.js';
       * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
       * @returns {number} - The color as a number in little endian format.
       */
      toLittleEndianNumber() {
        const value = this._int;
        return (value >> 16) + (value & 65280) + ((value & 255) << 16);
      }
      /**
       * Multiply with another color. This action is destructive, and will
       * override the previous `value` property to be `null`.
       * @param {ColorSource} value - The color to multiply by.
       */
      multiply(value) {
        const [r2, g2, b2, a2] = _Color._temp.setValue(value)._components;
        this._components[0] *= r2;
        this._components[1] *= g2;
        this._components[2] *= b2;
        this._components[3] *= a2;
        this._refreshInt();
        this._value = null;
        return this;
      }
      /**
       * Converts color to a premultiplied alpha format. This action is destructive, and will
       * override the previous `value` property to be `null`.
       * @param alpha - The alpha to multiply by.
       * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
       * @returns {Color} - Itself.
       */
      premultiply(alpha, applyToRGB = true) {
        if (applyToRGB) {
          this._components[0] *= alpha;
          this._components[1] *= alpha;
          this._components[2] *= alpha;
        }
        this._components[3] = alpha;
        this._refreshInt();
        this._value = null;
        return this;
      }
      /**
       * Premultiplies alpha with current color.
       * @param {number} alpha - The alpha to multiply by.
       * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
       * @returns {number} tint multiplied by alpha
       */
      toPremultiplied(alpha, applyToRGB = true) {
        if (alpha === 1) {
          return (255 << 24) + this._int;
        }
        if (alpha === 0) {
          return applyToRGB ? 0 : this._int;
        }
        let r2 = this._int >> 16 & 255;
        let g2 = this._int >> 8 & 255;
        let b2 = this._int & 255;
        if (applyToRGB) {
          r2 = r2 * alpha + 0.5 | 0;
          g2 = g2 * alpha + 0.5 | 0;
          b2 = b2 * alpha + 0.5 | 0;
        }
        return (alpha * 255 << 24) + (r2 << 16) + (g2 << 8) + b2;
      }
      /**
       * Convert to a hexidecimal string.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toHex(); // returns "#ffffff"
       */
      toHex() {
        const hexString = this._int.toString(16);
        return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
      }
      /**
       * Convert to a hexidecimal string with alpha.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toHexa(); // returns "#ffffffff"
       */
      toHexa() {
        const alphaValue = Math.round(this._components[3] * 255);
        const alphaString = alphaValue.toString(16);
        return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
      }
      /**
       * Set alpha, suitable for chaining.
       * @param alpha
       */
      setAlpha(alpha) {
        this._components[3] = this._clamp(alpha);
        return this;
      }
      /**
       * Normalize the input value into rgba
       * @param value - Input value
       */
      _normalize(value) {
        let r2;
        let g2;
        let b2;
        let a2;
        if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
          const int = value;
          r2 = (int >> 16 & 255) / 255;
          g2 = (int >> 8 & 255) / 255;
          b2 = (int & 255) / 255;
          a2 = 1;
        } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
          value = this._clamp(value);
          [r2, g2, b2, a2 = 1] = value;
        } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
          value = this._clamp(value, 0, 255);
          [r2, g2, b2, a2 = 255] = value;
          r2 /= 255;
          g2 /= 255;
          b2 /= 255;
          a2 /= 255;
        } else if (typeof value === "string" || typeof value === "object") {
          if (typeof value === "string") {
            const match = _Color.HEX_PATTERN.exec(value);
            if (match) {
              value = `#${match[2]}`;
            }
          }
          const color = w(value);
          if (color.isValid()) {
            ({ r: r2, g: g2, b: b2, a: a2 } = color.rgba);
            r2 /= 255;
            g2 /= 255;
            b2 /= 255;
          }
        }
        if (r2 !== void 0) {
          this._components[0] = r2;
          this._components[1] = g2;
          this._components[2] = b2;
          this._components[3] = a2;
          this._refreshInt();
        } else {
          throw new Error(`Unable to convert color ${value}`);
        }
      }
      /** Refresh the internal color rgb number */
      _refreshInt() {
        this._clamp(this._components);
        const [r2, g2, b2] = this._components;
        this._int = (r2 * 255 << 16) + (g2 * 255 << 8) + (b2 * 255 | 0);
      }
      /**
       * Clamps values to a range. Will override original values
       * @param value - Value(s) to clamp
       * @param min - Minimum value
       * @param max - Maximum value
       */
      _clamp(value, min = 0, max = 1) {
        if (typeof value === "number") {
          return Math.min(Math.max(value, min), max);
        }
        value.forEach((v3, i2) => {
          value[i2] = Math.min(Math.max(v3, min), max);
        });
        return value;
      }
      /**
       * Check if the value is a color-like object
       * @param value - Value to check
       * @returns True if the value is a color-like object
       * @static
       * @example
       * import { Color } from 'pixi.js';
       * Color.isColorLike('white'); // returns true
       * Color.isColorLike(0xffffff); // returns true
       * Color.isColorLike([1, 1, 1]); // returns true
       */
      static isColorLike(value) {
        return typeof value === "number" || typeof value === "string" || value instanceof Number || value instanceof _Color || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;
      }
    };
    Color = _Color;
    Color.shared = new _Color();
    Color._temp = new _Color();
    Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/misc/const.mjs
var PI_2, RAD_TO_DEG, DEG_TO_RAD;
var init_const = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/misc/const.mjs"() {
    PI_2 = Math.PI * 2;
    RAD_TO_DEG = 180 / Math.PI;
    DEG_TO_RAD = Math.PI / 180;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs
var Matrix, tempMatrix, identityMatrix;
var init_Matrix = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"() {
    init_const();
    init_Point();
    Matrix = class _Matrix {
      /**
       * @param a - x scale
       * @param b - y skew
       * @param c - x skew
       * @param d - y scale
       * @param tx - x translation
       * @param ty - y translation
       */
      constructor(a2 = 1, b2 = 0, c2 = 0, d3 = 1, tx = 0, ty = 0) {
        this.array = null;
        this.a = a2;
        this.b = b2;
        this.c = c2;
        this.d = d3;
        this.tx = tx;
        this.ty = ty;
      }
      /**
       * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
       *
       * a = array[0]
       * b = array[1]
       * c = array[3]
       * d = array[4]
       * tx = array[2]
       * ty = array[5]
       * @param array - The array that the matrix will be populated from.
       */
      fromArray(array) {
        this.a = array[0];
        this.b = array[1];
        this.c = array[3];
        this.d = array[4];
        this.tx = array[2];
        this.ty = array[5];
      }
      /**
       * Sets the matrix properties.
       * @param a - Matrix component
       * @param b - Matrix component
       * @param c - Matrix component
       * @param d - Matrix component
       * @param tx - Matrix component
       * @param ty - Matrix component
       * @returns This matrix. Good for chaining method calls.
       */
      set(a2, b2, c2, d3, tx, ty) {
        this.a = a2;
        this.b = b2;
        this.c = c2;
        this.d = d3;
        this.tx = tx;
        this.ty = ty;
        return this;
      }
      /**
       * Creates an array from the current Matrix object.
       * @param transpose - Whether we need to transpose the matrix or not
       * @param [out=new Float32Array(9)] - If provided the array will be assigned to out
       * @returns The newly created array which contains the matrix
       */
      toArray(transpose, out2) {
        if (!this.array) {
          this.array = new Float32Array(9);
        }
        const array = out2 || this.array;
        if (transpose) {
          array[0] = this.a;
          array[1] = this.b;
          array[2] = 0;
          array[3] = this.c;
          array[4] = this.d;
          array[5] = 0;
          array[6] = this.tx;
          array[7] = this.ty;
          array[8] = 1;
        } else {
          array[0] = this.a;
          array[1] = this.c;
          array[2] = this.tx;
          array[3] = this.b;
          array[4] = this.d;
          array[5] = this.ty;
          array[6] = 0;
          array[7] = 0;
          array[8] = 1;
        }
        return array;
      }
      /**
       * Get a new position with the current transformation applied.
       * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
       * @param pos - The origin
       * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
       * @returns {Point} The new point, transformed through this matrix
       */
      apply(pos, newPos) {
        newPos = newPos || new Point();
        const x3 = pos.x;
        const y2 = pos.y;
        newPos.x = this.a * x3 + this.c * y2 + this.tx;
        newPos.y = this.b * x3 + this.d * y2 + this.ty;
        return newPos;
      }
      /**
       * Get a new position with the inverse of the current transformation applied.
       * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
       * @param pos - The origin
       * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
       * @returns {Point} The new point, inverse-transformed through this matrix
       */
      applyInverse(pos, newPos) {
        newPos = newPos || new Point();
        const a2 = this.a;
        const b2 = this.b;
        const c2 = this.c;
        const d3 = this.d;
        const tx = this.tx;
        const ty = this.ty;
        const id = 1 / (a2 * d3 + c2 * -b2);
        const x3 = pos.x;
        const y2 = pos.y;
        newPos.x = d3 * id * x3 + -c2 * id * y2 + (ty * c2 - tx * d3) * id;
        newPos.y = a2 * id * y2 + -b2 * id * x3 + (-ty * a2 + tx * b2) * id;
        return newPos;
      }
      /**
       * Translates the matrix on the x and y.
       * @param x - How much to translate x by
       * @param y - How much to translate y by
       * @returns This matrix. Good for chaining method calls.
       */
      translate(x3, y2) {
        this.tx += x3;
        this.ty += y2;
        return this;
      }
      /**
       * Applies a scale transformation to the matrix.
       * @param x - The amount to scale horizontally
       * @param y - The amount to scale vertically
       * @returns This matrix. Good for chaining method calls.
       */
      scale(x3, y2) {
        this.a *= x3;
        this.d *= y2;
        this.c *= x3;
        this.b *= y2;
        this.tx *= x3;
        this.ty *= y2;
        return this;
      }
      /**
       * Applies a rotation transformation to the matrix.
       * @param angle - The angle in radians.
       * @returns This matrix. Good for chaining method calls.
       */
      rotate(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const a1 = this.a;
        const c1 = this.c;
        const tx1 = this.tx;
        this.a = a1 * cos - this.b * sin;
        this.b = a1 * sin + this.b * cos;
        this.c = c1 * cos - this.d * sin;
        this.d = c1 * sin + this.d * cos;
        this.tx = tx1 * cos - this.ty * sin;
        this.ty = tx1 * sin + this.ty * cos;
        return this;
      }
      /**
       * Appends the given Matrix to this Matrix.
       * @param matrix - The matrix to append.
       * @returns This matrix. Good for chaining method calls.
       */
      append(matrix) {
        const a1 = this.a;
        const b1 = this.b;
        const c1 = this.c;
        const d1 = this.d;
        this.a = matrix.a * a1 + matrix.b * c1;
        this.b = matrix.a * b1 + matrix.b * d1;
        this.c = matrix.c * a1 + matrix.d * c1;
        this.d = matrix.c * b1 + matrix.d * d1;
        this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
        this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
        return this;
      }
      /**
       * Appends two matrix's and sets the result to this matrix. AB = A * B
       * @param a - The matrix to append.
       * @param b - The matrix to append.
       * @returns This matrix. Good for chaining method calls.
       */
      appendFrom(a2, b2) {
        const a1 = a2.a;
        const b1 = a2.b;
        const c1 = a2.c;
        const d1 = a2.d;
        const tx = a2.tx;
        const ty = a2.ty;
        const a22 = b2.a;
        const b22 = b2.b;
        const c2 = b2.c;
        const d22 = b2.d;
        this.a = a1 * a22 + b1 * c2;
        this.b = a1 * b22 + b1 * d22;
        this.c = c1 * a22 + d1 * c2;
        this.d = c1 * b22 + d1 * d22;
        this.tx = tx * a22 + ty * c2 + b2.tx;
        this.ty = tx * b22 + ty * d22 + b2.ty;
        return this;
      }
      /**
       * Sets the matrix based on all the available properties
       * @param x - Position on the x axis
       * @param y - Position on the y axis
       * @param pivotX - Pivot on the x axis
       * @param pivotY - Pivot on the y axis
       * @param scaleX - Scale on the x axis
       * @param scaleY - Scale on the y axis
       * @param rotation - Rotation in radians
       * @param skewX - Skew on the x axis
       * @param skewY - Skew on the y axis
       * @returns This matrix. Good for chaining method calls.
       */
      setTransform(x3, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
        this.a = Math.cos(rotation + skewY) * scaleX;
        this.b = Math.sin(rotation + skewY) * scaleX;
        this.c = -Math.sin(rotation - skewX) * scaleY;
        this.d = Math.cos(rotation - skewX) * scaleY;
        this.tx = x3 - (pivotX * this.a + pivotY * this.c);
        this.ty = y2 - (pivotX * this.b + pivotY * this.d);
        return this;
      }
      /**
       * Prepends the given Matrix to this Matrix.
       * @param matrix - The matrix to prepend
       * @returns This matrix. Good for chaining method calls.
       */
      prepend(matrix) {
        const tx1 = this.tx;
        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
          const a1 = this.a;
          const c1 = this.c;
          this.a = a1 * matrix.a + this.b * matrix.c;
          this.b = a1 * matrix.b + this.b * matrix.d;
          this.c = c1 * matrix.a + this.d * matrix.c;
          this.d = c1 * matrix.b + this.d * matrix.d;
        }
        this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
        this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
        return this;
      }
      /**
       * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
       * @param transform - The transform to apply the properties to.
       * @returns The transform with the newly applied properties
       */
      decompose(transform2) {
        const a2 = this.a;
        const b2 = this.b;
        const c2 = this.c;
        const d3 = this.d;
        const pivot = transform2.pivot;
        const skewX = -Math.atan2(-c2, d3);
        const skewY = Math.atan2(b2, a2);
        const delta = Math.abs(skewX + skewY);
        if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
          transform2.rotation = skewY;
          transform2.skew.x = transform2.skew.y = 0;
        } else {
          transform2.rotation = 0;
          transform2.skew.x = skewX;
          transform2.skew.y = skewY;
        }
        transform2.scale.x = Math.sqrt(a2 * a2 + b2 * b2);
        transform2.scale.y = Math.sqrt(c2 * c2 + d3 * d3);
        transform2.position.x = this.tx + (pivot.x * a2 + pivot.y * c2);
        transform2.position.y = this.ty + (pivot.x * b2 + pivot.y * d3);
        return transform2;
      }
      /**
       * Inverts this matrix
       * @returns This matrix. Good for chaining method calls.
       */
      invert() {
        const a1 = this.a;
        const b1 = this.b;
        const c1 = this.c;
        const d1 = this.d;
        const tx1 = this.tx;
        const n2 = a1 * d1 - b1 * c1;
        this.a = d1 / n2;
        this.b = -b1 / n2;
        this.c = -c1 / n2;
        this.d = a1 / n2;
        this.tx = (c1 * this.ty - d1 * tx1) / n2;
        this.ty = -(a1 * this.ty - b1 * tx1) / n2;
        return this;
      }
      /** Checks if this matrix is an identity matrix */
      isIdentity() {
        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
      }
      /**
       * Resets this Matrix to an identity (default) matrix.
       * @returns This matrix. Good for chaining method calls.
       */
      identity() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
        return this;
      }
      /**
       * Creates a new Matrix object with the same values as this one.
       * @returns A copy of this matrix. Good for chaining method calls.
       */
      clone() {
        const matrix = new _Matrix();
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      }
      /**
       * Changes the values of the given matrix to be the same as the ones in this matrix
       * @param matrix - The matrix to copy to.
       * @returns The matrix given in parameter with its values updated.
       */
      copyTo(matrix) {
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      }
      /**
       * Changes the values of the matrix to be the same as the ones in given matrix
       * @param matrix - The matrix to copy from.
       * @returns this
       */
      copyFrom(matrix) {
        this.a = matrix.a;
        this.b = matrix.b;
        this.c = matrix.c;
        this.d = matrix.d;
        this.tx = matrix.tx;
        this.ty = matrix.ty;
        return this;
      }
      toString() {
        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
      }
      /**
       * A default (identity) matrix
       * @readonly
       */
      static get IDENTITY() {
        return identityMatrix.identity();
      }
      /**
       * A temp matrix
       * @readonly
       */
      static get shared() {
        return tempMatrix.identity();
      }
    };
    tempMatrix = new Matrix();
    identityMatrix = new Matrix();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs
var ObservablePoint;
var init_ObservablePoint = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs"() {
    ObservablePoint = class _ObservablePoint {
      /**
       * Creates a new `ObservablePoint`
       * @param observer - Observer to pass to listen for change events.
       * @param {number} [x=0] - position of the point on the x axis
       * @param {number} [y=0] - position of the point on the y axis
       */
      constructor(observer, x3, y2) {
        this._x = x3 || 0;
        this._y = y2 || 0;
        this._observer = observer;
      }
      /**
       * Creates a clone of this point.
       * @param observer - Optional observer to pass to the new observable point.
       * @returns a copy of this observable point
       */
      clone(observer) {
        return new _ObservablePoint(observer ?? this._observer, this._x, this._y);
      }
      /**
       * Sets the point to a new `x` and `y` position.
       * If `y` is omitted, both `x` and `y` will be set to `x`.
       * @param {number} [x=0] - position of the point on the x axis
       * @param {number} [y=x] - position of the point on the y axis
       * @returns The observable point instance itself
       */
      set(x3 = 0, y2 = x3) {
        if (this._x !== x3 || this._y !== y2) {
          this._x = x3;
          this._y = y2;
          this._observer.onUpdate();
        }
        return this;
      }
      /**
       * Copies x and y from the given point (`p`)
       * @param p - The point to copy from. Can be any of type that is or extends `PointData`
       * @returns The observable point instance itself
       */
      copyFrom(p2) {
        if (this._x !== p2.x || this._y !== p2.y) {
          this._x = p2.x;
          this._y = p2.y;
          this._observer.onUpdate();
        }
        return this;
      }
      /**
       * Copies this point's x and y into that of the given point (`p`)
       * @param p - The point to copy to. Can be any of type that is or extends `PointData`
       * @returns The point (`p`) with values updated
       */
      copyTo(p2) {
        p2.set(this._x, this._y);
        return p2;
      }
      /**
       * Accepts another point (`p`) and returns `true` if the given point is equal to this point
       * @param p - The point to check
       * @returns Returns `true` if both `x` and `y` are equal
       */
      equals(p2) {
        return p2.x === this._x && p2.y === this._y;
      }
      toString() {
        return `[@pixi/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;
      }
      /** Position of the observable point on the x axis. */
      get x() {
        return this._x;
      }
      set x(value) {
        if (this._x !== value) {
          this._x = value;
          this._observer.onUpdate(this);
        }
      }
      /** Position of the observable point on the y axis. */
      get y() {
        return this._y;
      }
      set y(value) {
        if (this._y !== value) {
          this._y = value;
          this._observer.onUpdate(this);
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/data/uid.mjs
function uid(name = "default") {
  if (uidCache[name] === void 0) {
    uidCache[name] = -1;
  }
  return ++uidCache[name];
}
var uidCache;
var init_uid = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/data/uid.mjs"() {
    uidCache = {
      default: -1
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/logging/deprecation.mjs
function deprecation(version, message, ignoreDepth = 3) {
  if (warnings[message]) {
    return;
  }
  let stack = new Error().stack;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (console.groupCollapsed) {
      console.groupCollapsed(
        "%cPixiJS Deprecation Warning: %c%s",
        "color:#614108;background:#fffbe6",
        "font-weight:normal;color:#614108;background:#fffbe6",
        `${message}
Deprecated since v${version}`
      );
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
      console.warn(stack);
    }
  }
  warnings[message] = true;
}
var warnings, v8_0_0;
var init_deprecation = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/logging/deprecation.mjs"() {
    warnings = {};
    v8_0_0 = "8.0.0";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/data/removeItems.mjs
function removeItems(arr, startIdx, removeCount) {
  const length = arr.length;
  let i2;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  const len = length - removeCount;
  for (i2 = startIdx; i2 < len; ++i2) {
    arr[i2] = arr[i2 + removeCount];
  }
  arr.length = len;
}
var init_removeItems = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/data/removeItems.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs
var childrenHelperMixin;
var init_childrenHelperMixin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs"() {
    init_removeItems();
    init_deprecation();
    childrenHelperMixin = {
      allowChildren: true,
      /**
       * Removes all children from this container that are within the begin and end indexes.
       * @param beginIndex - The beginning position.
       * @param endIndex - The ending position. Default value is size of the container.
       * @returns - List of removed children
       * @memberof Container#
       */
      removeChildren(beginIndex = 0, endIndex) {
        const end = endIndex ?? this.children.length;
        const range = end - beginIndex;
        const removed = [];
        if (range > 0 && range <= end) {
          for (let i2 = end - 1; i2 >= beginIndex; i2--) {
            const child = this.children[i2];
            if (!child)
              continue;
            if (this.layerGroup) {
              this.layerGroup.removeChild(child);
            }
            removed.push(child);
            child.parent = null;
          }
          removeItems(this.children, beginIndex, end);
          for (let i2 = 0; i2 < removed.length; ++i2) {
            this.emit("childRemoved", removed[i2], this, i2);
            removed[i2].emit("removed", this);
          }
          return removed;
        } else if (range === 0 && this.children.length === 0) {
          return removed;
        }
        throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
      },
      /**
       * Removes a child from the specified index position.
       * @param index - The index to get the child from
       * @returns The child that was removed.
       * @memberof Container#
       */
      removeChildAt(index) {
        const child = this.getChildAt(index);
        return this.removeChild(child);
      },
      /**
       * Returns the child at the specified index
       * @param index - The index to get the child at
       * @returns - The child at the given index, if any.
       * @memberof Container#
       */
      getChildAt(index) {
        if (index < 0 || index >= this.children.length) {
          throw new Error(`getChildAt: Index (${index}) does not exist.`);
        }
        return this.children[index];
      },
      /**
       * Changes the position of an existing child in the container container
       * @param child - The child Container instance for which you want to change the index number
       * @param index - The resulting index number for the child container
       * @memberof Container#
       */
      setChildIndex(child, index) {
        if (index < 0 || index >= this.children.length) {
          throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
        }
        this.getChildIndex(child);
        this.addChildAt(child, index);
      },
      /**
       * Returns the index position of a child Container instance
       * @param child - The Container instance to identify
       * @returns - The index position of the child container to identify
       * @memberof Container#
       */
      getChildIndex(child) {
        const index = this.children.indexOf(child);
        if (index === -1) {
          throw new Error("The supplied Container must be a child of the caller");
        }
        return index;
      },
      /**
       * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.
       * If the child is already in this container, it will be moved to the specified index.
       * @param {Container} child - The child to add.
       * @param {number} index - The absolute index where the child will be positioned at the end of the operation.
       * @returns {Container} The child that was added.
       * @memberof Container#
       */
      addChildAt(child, index) {
        if (!this.allowChildren) {
          deprecation(v8_0_0, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
        }
        const { children } = this;
        if (index < 0 || index > children.length) {
          throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);
        }
        if (child.parent) {
          const currentIndex = child.parent.children.indexOf(child);
          if (child.parent === this && currentIndex === index) {
            return child;
          }
          if (currentIndex !== -1) {
            child.parent.children.splice(currentIndex, 1);
          }
        }
        if (index === children.length) {
          children.push(child);
        } else {
          children.splice(index, 0, child);
        }
        child.parent = this;
        child.didChange = true;
        child.didViewUpdate = false;
        child._updateFlags = 15;
        if (this.layerGroup) {
          this.layerGroup.addChild(child);
        }
        if (this.sortableChildren)
          this.sortDirty = true;
        this.emit("childAdded", child, this, index);
        child.emit("added", this);
        return child;
      },
      /**
       * Swaps the position of 2 Containers within this container.
       * @param child - First container to swap
       * @param child2 - Second container to swap
       */
      swapChildren(child, child2) {
        if (child === child2) {
          return;
        }
        const index1 = this.getChildIndex(child);
        const index2 = this.getChildIndex(child2);
        this.children[index1] = child2;
        this.children[index2] = child;
      },
      /** Remove the Container from its parent Container. If the Container has no parent, do nothing. */
      removeFromParent() {
        this.parent?.removeChild(this);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/FilterEffect.mjs
function getFilterEffect(filters) {
  const filterEffect = filterEffectsPool.pop() || new FilterEffect();
  filterEffect.filters = filters;
  return filterEffect;
}
function returnFilterEffect(effect) {
  effect.filters = null;
  filterEffectsPool.push(effect);
}
var FilterEffect, filterEffectsPool;
var init_FilterEffect = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/FilterEffect.mjs"() {
    FilterEffect = class {
      constructor(options) {
        this.pipe = "filter";
        this.priority = 1;
        this.filters = options?.filters;
      }
      destroy() {
        for (let i2 = 0; i2 < this.filters.length; i2++) {
          this.filters[i2].destroy();
        }
        this.filters = null;
      }
    };
    filterEffectsPool = [];
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/pool/Pool.mjs
var Pool;
var init_Pool = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/pool/Pool.mjs"() {
    Pool = class {
      constructor(ClassType, initialSize) {
        this._pool = [];
        this._count = 0;
        this._index = 0;
        this._classType = ClassType;
        if (initialSize) {
          this.prepopulate(initialSize);
        }
      }
      prepopulate(total) {
        for (let i2 = 0; i2 < total; i2++) {
          this._pool[this._index++] = new this._classType();
        }
        this._count += total;
      }
      get(data) {
        let item;
        if (this._index > 0) {
          item = this._pool[--this._index];
        } else {
          item = new this._classType();
        }
        item.init?.(data);
        return item;
      }
      return(item) {
        item.reset?.();
        this._pool[this._index++] = item;
      }
      get totalSize() {
        return this._count;
      }
      get totalFree() {
        return this._pool.length;
      }
      get totalUsed() {
        return this._count - this._pool.length;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs
var PoolGroupClass, BigPool;
var init_PoolGroup = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"() {
    init_Pool();
    PoolGroupClass = class {
      constructor() {
        this._poolsByClass = /* @__PURE__ */ new Map();
      }
      prepopulate(Class, total) {
        const classPool = this.getPool(Class);
        classPool.prepopulate(total);
      }
      get(Class, data) {
        const pool = this.getPool(Class);
        return pool.get(data);
      }
      return(item) {
        const pool = this.getPool(item.constructor);
        pool.return(item);
      }
      getPool(ClassType) {
        if (!this._poolsByClass.has(ClassType)) {
          this._poolsByClass.set(ClassType, new Pool(ClassType));
        }
        return this._poolsByClass.get(ClassType);
      }
      /** gets the usage stats of each pool in the system */
      stats() {
        const stats = {};
        this._poolsByClass.forEach((pool) => {
          const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;
          stats[name] = {
            free: pool.totalFree,
            used: pool.totalUsed,
            size: pool.totalSize
          };
        });
        return stats;
      }
    };
    BigPool = new PoolGroupClass();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs
var MaskEffectManagerClass, MaskEffectManager;
var init_MaskEffectManager = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs"() {
    init_Extensions();
    init_PoolGroup();
    MaskEffectManagerClass = class {
      constructor() {
        this._effectClasses = [];
        this._tests = [];
        this._initialized = false;
      }
      init() {
        if (this._initialized)
          return;
        this._initialized = true;
        this._effectClasses.forEach((test) => {
          this.add({
            test: test.test,
            maskClass: test
          });
        });
      }
      add(test) {
        this._tests.push(test);
      }
      getMaskEffect(item) {
        if (!this._initialized)
          this.init();
        for (let i2 = 0; i2 < this._tests.length; i2++) {
          const test = this._tests[i2];
          if (test.test(item)) {
            return BigPool.get(test.maskClass, item);
          }
        }
        return item;
      }
      returnMaskEffect(effect) {
        BigPool.return(effect);
      }
    };
    MaskEffectManager = new MaskEffectManagerClass();
    extensions.handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs
var effectsMixin;
var init_effectsMixin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs"() {
    init_FilterEffect();
    init_MaskEffectManager();
    effectsMixin = {
      _mask: null,
      _filters: null,
      effects: [],
      addEffect(effect) {
        const index = this.effects.indexOf(effect);
        if (index !== -1)
          return;
        this.effects.push(effect);
        this.effects.sort((a2, b2) => a2.priority - b2.priority);
        if (!this.isLayerRoot && this.layerGroup) {
          this.layerGroup.structureDidChange = true;
        }
        this._updateIsSimple();
      },
      removeEffect(effect) {
        const index = this.effects.indexOf(effect);
        if (index === -1)
          return;
        this.effects.splice(index, 1);
        if (!this.isLayerRoot && this.layerGroup) {
          this.layerGroup.structureDidChange = true;
        }
        this._updateIsSimple();
      },
      set mask(value) {
        this._mask || (this._mask = { mask: null, effect: null });
        if (this._mask.mask === value)
          return;
        if (this._mask.effect) {
          this.removeEffect(this._mask.effect);
          MaskEffectManager.returnMaskEffect(this._mask.effect);
          this._mask.effect = null;
        }
        this._mask.mask = value;
        if (value === null || value === void 0)
          return;
        const effect = MaskEffectManager.getMaskEffect(value);
        this._mask.effect = effect;
        this.addEffect(effect);
      },
      get mask() {
        return this._mask?.mask;
      },
      set filters(value) {
        if (!Array.isArray(value) && value !== null)
          value = [value];
        this._filters || (this._filters = { filters: null, effect: null });
        if (this._filters.filters === value)
          return;
        if (this._filters.effect) {
          this.removeEffect(this._filters.effect);
          returnFilterEffect(this._filters.effect);
          this._filters.effect = null;
        }
        this._filters.filters = value;
        if (!value)
          return;
        const effect = getFilterEffect(value);
        this._filters.effect = effect;
        this.addEffect(effect);
      },
      get filters() {
        return this._filters?.filters;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs
var findMixin;
var init_findMixin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs"() {
    init_deprecation();
    findMixin = {
      label: null,
      /** @deprecated since 8.0.0 */
      get name() {
        deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
        return this.label;
      },
      /** @deprecated since 8.0.0 */
      set name(value) {
        deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
        this.label = value;
      },
      /**
       * @method getChildByName
       * @memberof Container#
       * @deprecated since 8.0.0
       * @see Container#getChildByLabel
       * @param {string} name - Instance name.
       * @param {boolean}[deep=false] - Whether to search recursively
       * @returns {Container} The child with the specified name.
       */
      getChildByName(name, deep = false) {
        return this.getChildByLabel(name, deep);
      },
      /**
       * Returns the first child in the container with the specified label.
       *
       * Recursive searches are done in a pre-order traversal.
       * @method getChildByLabel
       * @memberof Container#
       * @param {string|RegExp} label - Instance label.
       * @param {boolean}[deep=false] - Whether to search recursively
       * @returns {Container} The child with the specified label.
       */
      getChildByLabel(label, deep = false) {
        const children = this.children;
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          if (child.label === label || label instanceof RegExp && label.test(child.label))
            return child;
        }
        if (deep) {
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            const found = child.getChildByLabel(label, true);
            if (found) {
              return found;
            }
          }
        }
        return null;
      },
      /**
       * Returns all children in the container with the specified label.
       * @method getChildrenByLabel
       * @memberof Container#
       * @param {string|RegExp} label - Instance label.
       * @param {boolean}[deep=false] - Whether to search recursively
       * @param {Container[]} [out=[]] - The array to store matching children in.
       * @returns {Container[]} An array of children with the specified label.
       */
      getChildrenByLabel(label, deep = false, out2 = []) {
        const children = this.children;
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          if (child.label === label || label instanceof RegExp && label.test(child.label)) {
            out2.push(child);
          }
        }
        if (deep) {
          for (let i2 = 0; i2 < children.length; i2++) {
            children[i2].getChildrenByLabel(label, true, out2);
          }
        }
        return out2;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs
var tempPoints, Rectangle;
var init_Rectangle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs"() {
    init_Point();
    tempPoints = [new Point(), new Point(), new Point(), new Point()];
    Rectangle = class _Rectangle {
      /**
       * @param x - The X coordinate of the upper-left corner of the rectangle
       * @param y - The Y coordinate of the upper-left corner of the rectangle
       * @param width - The overall width of the rectangle
       * @param height - The overall height of the rectangle
       */
      constructor(x3 = 0, y2 = 0, width = 0, height = 0) {
        this.type = "rectangle";
        this.x = Number(x3);
        this.y = Number(y2);
        this.width = Number(width);
        this.height = Number(height);
      }
      /** Returns the left edge of the rectangle. */
      get left() {
        return this.x;
      }
      /** Returns the right edge of the rectangle. */
      get right() {
        return this.x + this.width;
      }
      /** Returns the top edge of the rectangle. */
      get top() {
        return this.y;
      }
      /** Returns the bottom edge of the rectangle. */
      get bottom() {
        return this.y + this.height;
      }
      /** A constant empty rectangle. */
      static get EMPTY() {
        return new _Rectangle(0, 0, 0, 0);
      }
      /**
       * Creates a clone of this Rectangle
       * @returns a copy of the rectangle
       */
      clone() {
        return new _Rectangle(this.x, this.y, this.width, this.height);
      }
      /**
       * Converts a Bounds object to a Rectangle object.
       * @param bounds - The bounds to copy and convert to a rectangle.
       * @returns Returns itself.
       */
      copyFromBounds(bounds) {
        this.x = bounds.minX;
        this.y = bounds.minY;
        this.width = bounds.maxX - bounds.minX;
        this.height = bounds.maxY - bounds.minY;
        return this;
      }
      /**
       * Copies another rectangle to this one.
       * @param rectangle - The rectangle to copy from.
       * @returns Returns itself.
       */
      copyFrom(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
      }
      /**
       * Copies this rectangle to another one.
       * @param rectangle - The rectangle to copy to.
       * @returns Returns given parameter.
       */
      copyTo(rectangle) {
        rectangle.copyFrom(this);
        return rectangle;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this Rectangle
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coordinates are within this Rectangle
       */
      contains(x3, y2) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x3 >= this.x && x3 < this.x + this.width) {
          if (y2 >= this.y && y2 < this.y + this.height) {
            return true;
          }
        }
        return false;
      }
      /**
       * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
       * Returns true only if the area of the intersection is >0, this means that Rectangles
       * sharing a side are not overlapping. Another side effect is that an arealess rectangle
       * (width or height equal to zero) can't intersect any other rectangle.
       * @param {Rectangle} other - The Rectangle to intersect with `this`.
       * @param {Matrix} transform - The transformation matrix of `other`.
       * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
       */
      intersects(other, transform2) {
        if (!transform2) {
          const x02 = this.x < other.x ? other.x : this.x;
          const x12 = this.right > other.right ? other.right : this.right;
          if (x12 <= x02) {
            return false;
          }
          const y02 = this.y < other.y ? other.y : this.y;
          const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
          return y12 > y02;
        }
        const x0 = this.left;
        const x1 = this.right;
        const y0 = this.top;
        const y1 = this.bottom;
        if (x1 <= x0 || y1 <= y0) {
          return false;
        }
        const lt = tempPoints[0].set(other.left, other.top);
        const lb = tempPoints[1].set(other.left, other.bottom);
        const rt = tempPoints[2].set(other.right, other.top);
        const rb = tempPoints[3].set(other.right, other.bottom);
        if (rt.x <= lt.x || lb.y <= lt.y) {
          return false;
        }
        const s2 = Math.sign(transform2.a * transform2.d - transform2.b * transform2.c);
        if (s2 === 0) {
          return false;
        }
        transform2.apply(lt, lt);
        transform2.apply(lb, lb);
        transform2.apply(rt, rt);
        transform2.apply(rb, rb);
        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
          return false;
        }
        const nx = s2 * (lb.y - lt.y);
        const ny = s2 * (lt.x - lb.x);
        const n00 = nx * x0 + ny * y0;
        const n10 = nx * x1 + ny * y0;
        const n01 = nx * x0 + ny * y1;
        const n11 = nx * x1 + ny * y1;
        if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
          return false;
        }
        const mx = s2 * (lt.y - rt.y);
        const my = s2 * (rt.x - lt.x);
        const m00 = mx * x0 + my * y0;
        const m10 = mx * x1 + my * y0;
        const m01 = mx * x0 + my * y1;
        const m11 = mx * x1 + my * y1;
        if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
          return false;
        }
        return true;
      }
      /**
       * Pads the rectangle making it grow in all directions.
       * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
       * @param paddingX - The horizontal padding amount.
       * @param paddingY - The vertical padding amount.
       * @returns Returns itself.
       */
      pad(paddingX = 0, paddingY = paddingX) {
        this.x -= paddingX;
        this.y -= paddingY;
        this.width += paddingX * 2;
        this.height += paddingY * 2;
        return this;
      }
      /**
       * Fits this rectangle around the passed one.
       * @param rectangle - The rectangle to fit.
       * @returns Returns itself.
       */
      fit(rectangle) {
        const x1 = Math.max(this.x, rectangle.x);
        const x22 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
        const y1 = Math.max(this.y, rectangle.y);
        const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = Math.max(x22 - x1, 0);
        this.y = y1;
        this.height = Math.max(y2 - y1, 0);
        return this;
      }
      /**
       * Enlarges rectangle that way its corners lie on grid
       * @param resolution - resolution
       * @param eps - precision
       * @returns Returns itself.
       */
      ceil(resolution = 1, eps = 1e-3) {
        const x22 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
        const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
        this.x = Math.floor((this.x + eps) * resolution) / resolution;
        this.y = Math.floor((this.y + eps) * resolution) / resolution;
        this.width = x22 - this.x;
        this.height = y2 - this.y;
        return this;
      }
      /**
       * Enlarges this rectangle to include the passed rectangle.
       * @param rectangle - The rectangle to include.
       * @returns Returns itself.
       */
      enlarge(rectangle) {
        const x1 = Math.min(this.x, rectangle.x);
        const x22 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
        const y1 = Math.min(this.y, rectangle.y);
        const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = x22 - x1;
        this.y = y1;
        this.height = y2 - y1;
        return this;
      }
      /**
       * Returns the framing rectangle of the rectangle as a Rectangle object
       * @param out - optional rectangle to store the result
       * @returns The framing rectangle
       */
      getBounds(out2) {
        out2 = out2 || new _Rectangle();
        out2.copyFrom(this);
        return out2;
      }
      toString() {
        return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs
var Bounds;
var init_Bounds = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs"() {
    init_Matrix();
    init_Rectangle();
    Bounds = class _Bounds {
      constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
        this._matrixStack = [];
        this.matrix = new Matrix();
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      }
      get rectangle() {
        if (!this._rectangle) {
          this._rectangle = new Rectangle();
        }
        const rectangle = this._rectangle;
        if (this.minX > this.maxX || this.minY > this.maxY) {
          rectangle.x = 0;
          rectangle.y = 0;
          rectangle.width = 0;
          rectangle.height = 0;
        } else {
          rectangle.copyFromBounds(this);
        }
        return rectangle;
      }
      clear() {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
        this._matrixStack.length = 0;
        this.matrix.identity();
      }
      pushMatrix(matrix) {
        this._matrixStack.push(matrix);
        if (this._matrixStack.length > 1) {
          this.matrix.copyFrom(this._matrixStack[this._matrixStack.length - 2]);
          this.matrix.append(matrix);
        } else {
          this.matrix.copyFrom(matrix);
        }
      }
      popMatrix() {
        this._matrixStack.pop();
        if (this._matrixStack.length > 1) {
          this.matrix.copyFrom(this._matrixStack[this._matrixStack.length - 2]);
          this.matrix.append(this._matrixStack[this._matrixStack.length - 1]);
        } else if (this._matrixStack.length === 1) {
          this.matrix.copyFrom(this._matrixStack[0]);
        } else {
          this.matrix.identity();
        }
      }
      setMatrix(matrix) {
        this.matrix.copyFrom(matrix);
      }
      set(x0, y0, x1, y1) {
        this.minX = x0;
        this.minY = y0;
        this.maxX = x1;
        this.maxY = y1;
      }
      /**
       * Adds sprite frame
       * @param x0 - left X of frame
       * @param y0 - top Y of frame
       * @param x1 - right X of frame
       * @param y1 - bottom Y of frame
       */
      addFrame(x0, y0, x1, y1) {
        const matrix = this.matrix;
        const a2 = matrix.a;
        const b2 = matrix.b;
        const c2 = matrix.c;
        const d3 = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        let minX = this.minX;
        let minY = this.minY;
        let maxX = this.maxX;
        let maxY = this.maxY;
        let x3 = a2 * x0 + c2 * y0 + tx;
        let y2 = b2 * x0 + d3 * y0 + ty;
        minX = x3 < minX ? x3 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x3 > maxX ? x3 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x3 = a2 * x1 + c2 * y0 + tx;
        y2 = b2 * x1 + d3 * y0 + ty;
        minX = x3 < minX ? x3 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x3 > maxX ? x3 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x3 = a2 * x0 + c2 * y1 + tx;
        y2 = b2 * x0 + d3 * y1 + ty;
        minX = x3 < minX ? x3 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x3 > maxX ? x3 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x3 = a2 * x1 + c2 * y1 + tx;
        y2 = b2 * x1 + d3 * y1 + ty;
        minX = x3 < minX ? x3 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x3 > maxX ? x3 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      }
      addRect(rect) {
        this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height);
      }
      addBounds(bounds) {
        this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
      }
      addBoundsMask(mask) {
        this.minX = this.minX > mask.minX ? this.minX : mask.minX;
        this.minY = this.minY > mask.minY ? this.minY : mask.minY;
        this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;
        this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;
      }
      applyMatrix(matrix) {
        const minX = this.minX;
        const minY = this.minY;
        const maxX = this.maxX;
        const maxY = this.maxY;
        const { a: a2, b: b2, c: c2, d: d3, tx, ty } = matrix;
        let x3 = a2 * minX + c2 * minY + tx;
        let y2 = b2 * minX + d3 * minY + ty;
        this.minX = x3;
        this.minY = y2;
        this.maxX = x3;
        this.maxY = y2;
        x3 = a2 * maxX + c2 * minY + tx;
        y2 = b2 * maxX + d3 * minY + ty;
        this.minX = x3 < this.minX ? x3 : this.minX;
        this.minY = y2 < this.minY ? y2 : this.minY;
        this.maxX = x3 > this.maxX ? x3 : this.maxX;
        this.maxY = y2 > this.maxY ? y2 : this.maxY;
        x3 = a2 * minX + c2 * maxY + tx;
        y2 = b2 * minX + d3 * maxY + ty;
        this.minX = x3 < this.minX ? x3 : this.minX;
        this.minY = y2 < this.minY ? y2 : this.minY;
        this.maxX = x3 > this.maxX ? x3 : this.maxX;
        this.maxY = y2 > this.maxY ? y2 : this.maxY;
        x3 = a2 * maxX + c2 * maxY + tx;
        y2 = b2 * maxX + d3 * maxY + ty;
        this.minX = x3 < this.minX ? x3 : this.minX;
        this.minY = y2 < this.minY ? y2 : this.minY;
        this.maxX = x3 > this.maxX ? x3 : this.maxX;
        this.maxY = y2 > this.maxY ? y2 : this.maxY;
      }
      fit(rect) {
        if (this.minX < rect.left)
          this.minX = rect.left;
        if (this.maxX > rect.right)
          this.maxX = rect.right;
        if (this.minY < rect.top)
          this.minY = rect.top;
        if (this.maxY > rect.bottom)
          this.maxY = rect.bottom;
        return this;
      }
      pad(paddingX, paddingY = paddingX) {
        this.minX -= paddingX;
        this.maxX += paddingX;
        this.minY -= paddingY;
        this.maxY += paddingY;
        return this;
      }
      ceil() {
        this.minX = Math.floor(this.minX);
        this.minY = Math.floor(this.minY);
        this.maxX = Math.ceil(this.maxX);
        this.maxY = Math.ceil(this.maxY);
        return this;
      }
      clone() {
        return new _Bounds(this.minX, this.minY, this.maxX, this.maxY);
      }
      scale(x3, y2 = x3) {
        this.minX *= x3;
        this.minY *= y2;
        this.maxX *= x3;
        this.maxY *= y2;
        return this;
      }
      get x() {
        return this.minX;
      }
      get y() {
        return this.minY;
      }
      get width() {
        return this.maxX - this.minX;
      }
      get height() {
        return this.maxY - this.minY;
      }
      get isPositive() {
        return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
      }
      get isValid() {
        return this.minX + this.minY !== Infinity;
      }
      /**
       * Adds screen vertices from array
       * @param vertexData - calculated vertices
       * @param beginOffset - begin offset
       * @param endOffset - end offset, excluded
       */
      addVertexData(vertexData, beginOffset, endOffset) {
        let minX = this.minX;
        let minY = this.minY;
        let maxX = this.maxX;
        let maxY = this.maxY;
        const matrix = this.matrix;
        const a2 = matrix.a;
        const b2 = matrix.b;
        const c2 = matrix.c;
        const d3 = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        for (let i2 = beginOffset; i2 < endOffset; i2 += 2) {
          const localX = vertexData[i2];
          const localY = vertexData[i2 + 1];
          const x3 = a2 * localX + c2 * localY + tx;
          const y2 = b2 * localX + d3 * localY + ty;
          minX = x3 < minX ? x3 : minX;
          minY = y2 < minY ? y2 : minY;
          maxX = x3 > maxX ? x3 : maxX;
          maxY = y2 > maxY ? y2 : maxY;
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      }
      toString() {
        return `[@pixi:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/utils/updateLocalTransform.mjs
function updateLocalTransform(lt, container) {
  const scale3 = container._scale;
  const pivot = container._pivot;
  const position = container._position;
  const sx = scale3._x;
  const sy = scale3._y;
  const px = pivot._x;
  const py = pivot._y;
  lt.a = container._cx * sx;
  lt.b = container._sx * sx;
  lt.c = container._cy * sy;
  lt.d = container._sy * sy;
  lt.tx = position._x - (px * lt.a + py * lt.c);
  lt.ty = position._y - (px * lt.b + py * lt.d);
}
var init_updateLocalTransform = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/utils/updateLocalTransform.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs
function getGlobalBounds(target, skipUpdateTransform, bounds) {
  bounds.clear();
  let parentTransform;
  if (target.parent) {
    if (!skipUpdateTransform) {
      parentTransform = updateTransformBackwards(target, new Matrix());
    } else {
      parentTransform = target.parent.worldTransform;
    }
  } else {
    parentTransform = Matrix.IDENTITY;
  }
  _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  return bounds;
}
function _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {
  if (!target.visible || !target.measurable)
    return;
  let worldTransform;
  if (!skipUpdateTransform) {
    if (target.didChange) {
      updateLocalTransform(target.localTransform, target);
    }
    worldTransform = Matrix.shared.appendFrom(target.localTransform, parentTransform).clone();
  } else {
    worldTransform = target.worldTransform;
  }
  const parentBounds = bounds;
  const preserveBounds = !!target.effects.length;
  if (preserveBounds) {
    bounds = bounds.clone();
  }
  if (target.view) {
    bounds.setMatrix(worldTransform);
    target.view.addBounds(bounds);
  }
  for (let i2 = 0; i2 < target.children.length; i2++) {
    _getGlobalBounds(target.children[i2], bounds, worldTransform, skipUpdateTransform);
  }
  if (preserveBounds) {
    for (let i2 = 0; i2 < target.effects.length; i2++) {
      target.effects[i2].addBounds?.(bounds);
    }
    parentBounds.setMatrix(Matrix.IDENTITY);
    parentBounds.addBounds(bounds);
  }
}
function updateTransformBackwards(target, parentTransform) {
  const parent = target.parent;
  if (parent) {
    updateTransformBackwards(parent, parentTransform);
    if (parent.didChange) {
      updateLocalTransform(parent.localTransform, parent);
    }
    parentTransform.append(parent.localTransform);
  }
  return parentTransform;
}
var init_getGlobalBounds = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs"() {
    init_Matrix();
    init_updateLocalTransform();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/logging/warn.mjs
function warn(...args) {
  if (warnCount === maxWarnings)
    return;
  warnCount++;
  if (warnCount === maxWarnings) {
    console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");
  } else {
    console.warn("PixiJS Warning: ", ...args);
  }
}
var warnCount, maxWarnings;
var init_warn = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/logging/warn.mjs"() {
    warnCount = 0;
    maxWarnings = 500;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs
function getLocalBounds(target, bounds, relativeMatrix) {
  bounds.clear();
  relativeMatrix || (relativeMatrix = new Matrix());
  if (target.view) {
    bounds.setMatrix(relativeMatrix);
    target.view.addBounds(bounds);
  }
  for (let i2 = 0; i2 < target.children.length; i2++) {
    _getLocalBounds(target.children[i2], bounds, relativeMatrix, target);
  }
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  return bounds;
}
function _getLocalBounds(target, bounds, parentTransform, rootContainer) {
  if (!target.visible || !target.measurable)
    return;
  if (target.didChange) {
    updateLocalTransform(target.localTransform, target);
  }
  const localTransform = target.localTransform;
  const relativeTransform = Matrix.shared.appendFrom(localTransform, parentTransform).clone();
  const parentBounds = bounds;
  const preserveBounds = !!target.effects.length;
  if (preserveBounds) {
    bounds = new Bounds();
  }
  if (target.view) {
    bounds.setMatrix(relativeTransform);
    target.view.addBounds(bounds);
  }
  for (let i2 = 0; i2 < target.children.length; i2++) {
    _getLocalBounds(target.children[i2], bounds, relativeTransform, rootContainer);
  }
  if (preserveBounds) {
    for (let i2 = 0; i2 < target.effects.length; i2++) {
      target.effects[i2].addLocalBounds?.(bounds, rootContainer);
    }
    parentBounds.setMatrix(Matrix.IDENTITY);
    parentBounds.addBounds(bounds);
  }
}
var init_getLocalBounds = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs"() {
    init_Matrix();
    init_updateLocalTransform();
    init_Bounds();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs
var tempBounds, tempMatrix2, measureMixin;
var init_measureMixin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs"() {
    init_Matrix();
    init_Bounds();
    init_getGlobalBounds();
    init_getLocalBounds();
    tempBounds = new Bounds();
    tempMatrix2 = new Matrix();
    measureMixin = {
      get width() {
        return Math.abs(this.scale.x * getLocalBounds(this, tempBounds, tempMatrix2).width);
      },
      set width(value) {
        const localWidth = getLocalBounds(this, tempBounds, tempMatrix2).width;
        if (localWidth !== 0) {
          this.scale.x = value / localWidth;
        } else {
          this.scale.x = 1;
        }
      },
      get height() {
        return Math.abs(this.scale.y * getLocalBounds(this, tempBounds, tempMatrix2).height);
      },
      set height(value) {
        const localHeight = getLocalBounds(this, tempBounds, tempMatrix2).height;
        if (localHeight !== 0) {
          this.scale.y = value / localHeight;
        } else {
          this.scale.y = 1;
        }
      },
      /**
       * Retrieves the local bounds of the container as a Bounds object.
       * @param rect - Optional rectangle to store the result of the bounds calculation.
       * @returns - The bounding area.
       */
      getLocalBounds(rect) {
        const bounds = getLocalBounds(this, new Bounds(), tempMatrix2);
        return rect ? rect.copyFromBounds(bounds) : bounds.rectangle.clone();
      },
      /**
       * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.
       * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from
       *  being updated. This means the calculation returned MAY be out of date BUT will give you a
       *  nice performance boost.
       * @param rect - Optional rectangle to store the result of the bounds calculation.
       * @returns - The minimum axis-aligned rectangle in world space that fits around this object.
       */
      getBounds(skipUpdate, rect) {
        const bounds = getGlobalBounds(this, skipUpdate, tempBounds);
        return rect ? rect.copyFromBounds(bounds) : bounds.rectangle.clone();
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs
var onRenderMixin;
var init_onRenderMixin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs"() {
    onRenderMixin = {
      _onRender: null,
      set onRender(func) {
        const layerGroup = this.layerGroup;
        if (!func) {
          if (this._onRender) {
            layerGroup?.removeOnRender(this);
          }
          this._onRender = null;
          return;
        }
        if (!this._onRender) {
          layerGroup?.addOnRender(this);
        }
        this._onRender = func;
      },
      get onRender() {
        return this._onRender;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs
function sortChildren(a2, b2) {
  return a2._zIndex - b2._zIndex;
}
var sortMixin;
var init_sortMixin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs"() {
    sortMixin = {
      _zIndex: 0,
      sortDirty: false,
      sortableChildren: false,
      get zIndex() {
        return this._zIndex;
      },
      /** The depth of the object. Setting this value, will automatically set the parent to be sortable */
      set zIndex(value) {
        if (this._zIndex === value)
          return;
        this._zIndex = value;
        this.depthOfChildModified();
      },
      depthOfChildModified() {
        if (this.parent) {
          this.parent.sortableChildren = true;
          this.parent.sortDirty = true;
        }
        if (this.layerGroup && !this.isLayerRoot) {
          this.layerGroup.structureDidChange = true;
        }
      },
      sortChildren() {
        if (!this.sortDirty)
          return;
        this.sortDirty = false;
        this.children.sort(sortChildren);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs
var toLocalGlobalMixin;
var init_toLocalGlobalMixin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs"() {
    init_Matrix();
    init_Point();
    init_getGlobalBounds();
    init_updateLocalTransform();
    toLocalGlobalMixin = {
      /**
       * Returns the global position of the container.
       * @param point - The optional point to write the global value to.
       * @param skipUpdate - Should we skip the update transform.
       * @returns - The updated point.
       * @memberof Container#
       */
      getGlobalPosition(point = new Point(), skipUpdate = false) {
        if (this.parent) {
          this.parent.toGlobal(this._position, point, skipUpdate);
        } else {
          point.x = this._position.x;
          point.y = this._position.y;
        }
        return point;
      },
      /**
       * Calculates the global position of the container.
       * @param position - The world origin to calculate from.
       * @param point - A Point object in which to store the value, optional
       *  (otherwise will create a new Point).
       * @param skipUpdate - Should we skip the update transform.
       * @returns - A point object representing the position of this object.
       * @memberof Container#
       */
      toGlobal(position, point, skipUpdate = false) {
        if (!skipUpdate) {
          if (this.didChange) {
            updateLocalTransform(this.localTransform, this);
          }
          const globalMatrix = updateTransformBackwards(this, new Matrix());
          globalMatrix.append(this.localTransform);
          return globalMatrix.apply(position, point);
        }
        return this.worldTransform.apply(position, point);
      },
      /**
       * Calculates the local position of the container relative to another point.
       * @param position - The world origin to calculate from.
       * @param from - The Container to calculate the global position from.
       * @param point - A Point object in which to store the value, optional
       *  (otherwise will create a new Point).
       * @param skipUpdate - Should we skip the update transform
       * @returns - A point object representing the position of this object
       * @memberof Container#
       */
      toLocal(position, from, point, skipUpdate) {
        if (from) {
          position = from.toGlobal(position, point, skipUpdate);
        }
        if (!skipUpdate) {
          if (this.didChange) {
            updateLocalTransform(this.localTransform, this);
          }
          const globalMatrix = updateTransformBackwards(this, new Matrix());
          globalMatrix.append(this.localTransform);
          return globalMatrix.applyInverse(position, point);
        }
        return this.worldTransform.applyInverse(position, point);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs
var InstructionSet;
var init_InstructionSet = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs"() {
    init_uid();
    InstructionSet = class {
      constructor() {
        this.uid = uid("instructionSet");
        this.instructions = [];
        this.instructionSize = 0;
      }
      reset() {
        this.instructionSize = 0;
      }
      add(instruction) {
        this.instructions[this.instructionSize++] = instruction;
      }
      log() {
        this.instructions.length = this.instructionSize;
        console.table(this.instructions, ["type", "action"]);
      }
      lastInstruction() {
        return this.instructions[this.instructionSize - 1];
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/LayerGroup.mjs
var LayerGroup;
var init_LayerGroup = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/LayerGroup.mjs"() {
    init_Matrix();
    init_InstructionSet();
    LayerGroup = class {
      constructor(root) {
        this.type = "layer";
        this.root = null;
        this.canBundle = false;
        this.layerGroupParent = null;
        this.layerGroupChildren = [];
        this._children = [];
        this.worldTransform = new Matrix();
        this.worldColor = 4294967295;
        this.childrenToUpdate = /* @__PURE__ */ Object.create(null);
        this.updateTick = 0;
        this.childrenRenderablesToUpdate = { list: [], index: 0 };
        this.structureDidChange = true;
        this.instructionSet = new InstructionSet();
        this._onRenderContainers = [];
        this.root = root;
        this.addChild(root);
      }
      get localTransform() {
        return this.root.localTransform;
      }
      get layerTransform() {
        return this.root.layerTransform;
      }
      addLayerGroupChild(layerGroupChild) {
        if (layerGroupChild.layerGroupParent) {
          layerGroupChild.layerGroupParent._removeLayerGroupChild(layerGroupChild);
        }
        layerGroupChild.layerGroupParent = this;
        this.onChildUpdate(layerGroupChild.root);
        this.layerGroupChildren.push(layerGroupChild);
      }
      _removeLayerGroupChild(layerGroupChild) {
        if (layerGroupChild.root.didChange) {
          this._removeChildFromUpdate(layerGroupChild.root);
        }
        const index = this.layerGroupChildren.indexOf(layerGroupChild);
        if (index > -1) {
          this.layerGroupChildren.splice(index, 1);
        }
        layerGroupChild.layerGroupParent = null;
      }
      addChild(child) {
        this.structureDidChange = true;
        if (child !== this.root) {
          this._children.push(child);
          child.updateTick = -1;
          if (child.parent === this.root) {
            child.relativeLayerDepth = 1;
          } else {
            child.relativeLayerDepth = child.parent.relativeLayerDepth + 1;
          }
          if (child._onRender) {
            this.addOnRender(child);
          }
        }
        if (child.layerGroup) {
          if (child.layerGroup.root === child) {
            this.addLayerGroupChild(child.layerGroup);
            return;
          }
        } else {
          child.layerGroup = this;
          child.didChange = true;
        }
        const children = child.children;
        if (!child.isLayerRoot) {
          this.onChildUpdate(child);
        }
        for (let i2 = 0; i2 < children.length; i2++) {
          this.addChild(children[i2]);
        }
      }
      removeChild(child) {
        this.structureDidChange = true;
        if (child._onRender) {
          this.removeOnRender(child);
        }
        if (child.layerGroup.root !== child) {
          const children = child.children;
          for (let i2 = 0; i2 < children.length; i2++) {
            this.removeChild(children[i2]);
          }
          if (child.didChange) {
            child.layerGroup._removeChildFromUpdate(child);
          }
          child.layerGroup = null;
        } else {
          this._removeLayerGroupChild(child.layerGroup);
        }
        const index = this._children.indexOf(child);
        if (index > -1) {
          this._children.splice(index, 1);
        }
      }
      onChildUpdate(child) {
        let childrenToUpdate = this.childrenToUpdate[child.relativeLayerDepth];
        if (!childrenToUpdate) {
          childrenToUpdate = this.childrenToUpdate[child.relativeLayerDepth] = {
            index: 0,
            list: []
          };
        }
        childrenToUpdate.list[childrenToUpdate.index++] = child;
      }
      // SHOULD THIS BE HERE?
      updateRenderable(container) {
        if (container.layerVisibleRenderable < 3)
          return;
        container.didViewUpdate = false;
        this.instructionSet.renderPipes[container.view.renderPipeId].updateRenderable(container);
      }
      onChildViewUpdate(child) {
        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;
      }
      _removeChildFromUpdate(child) {
        const childrenToUpdate = this.childrenToUpdate[child.relativeLayerDepth];
        if (!childrenToUpdate) {
          return;
        }
        const index = childrenToUpdate.list.indexOf(child);
        if (index > -1) {
          childrenToUpdate.list.splice(index, 1);
        }
        childrenToUpdate.index--;
      }
      get isRenderable() {
        const worldAlpha = this.worldColor >> 24 & 255;
        return this.root.localVisibleRenderable === 3 && worldAlpha > 0;
      }
      /**
       * adding a container to the onRender list will make sure the user function
       * passed in to the user defined 'onRender` callBack
       * @param container - the container to add to the onRender list
       */
      addOnRender(container) {
        this._onRenderContainers.push(container);
      }
      removeOnRender(container) {
        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);
      }
      runOnRender() {
        this._onRenderContainers.forEach((container) => {
          container._onRender();
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs
function definedProps(obj) {
  return Object.fromEntries(
    Object.entries(obj).filter(([_k, v3]) => v3 !== void 0)
  );
}
var init_definedProps = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/Container.mjs
var defaultSkew, defaultPivot, defaultScale, UPDATE_COLOR, UPDATE_BLEND, UPDATE_VISIBLE, Container;
var init_Container = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/Container.mjs"() {
    init_eventemitter3();
    init_Color();
    init_Matrix();
    init_const();
    init_ObservablePoint();
    init_uid();
    init_deprecation();
    init_childrenHelperMixin();
    init_effectsMixin();
    init_findMixin();
    init_measureMixin();
    init_onRenderMixin();
    init_sortMixin();
    init_toLocalGlobalMixin();
    init_LayerGroup();
    init_definedProps();
    defaultSkew = new ObservablePoint(null);
    defaultPivot = new ObservablePoint(null);
    defaultScale = new ObservablePoint(null, 1, 1);
    UPDATE_COLOR = 1;
    UPDATE_BLEND = 2;
    UPDATE_VISIBLE = 4;
    Container = class _Container extends eventemitter3_default {
      constructor(options = {}) {
        super();
        this.uid = uid("renderable");
        this._updateFlags = 15;
        this.isLayerRoot = false;
        this.layerGroup = null;
        this.didChange = false;
        this.didViewUpdate = false;
        this.relativeLayerDepth = 0;
        this.children = [];
        this.parent = null;
        this.includeInBuild = true;
        this.measurable = true;
        this.isSimple = true;
        this.updateTick = -1;
        this.localTransform = new Matrix();
        this.layerTransform = new Matrix();
        this.destroyed = false;
        this._position = new ObservablePoint(this, 0, 0);
        this._scale = defaultScale;
        this._pivot = defaultPivot;
        this._skew = defaultSkew;
        this._cx = 1;
        this._sx = 0;
        this._cy = 0;
        this._sy = 1;
        this._rotation = 0;
        this.localColor = 4294967295;
        this.layerColor = 4294967295;
        this.localBlendMode = "inherit";
        this.layerBlendMode = "normal";
        this.localVisibleRenderable = 3;
        this.layerVisibleRenderable = 3;
        if (options.view) {
          this.view = options.view;
          this.view.owner = this;
          options.view = void 0;
        }
        Object.assign(this, definedProps(options));
        this.children = [];
        options.children?.forEach((child) => this.addChild(child));
        this.effects = [];
        options.effects?.forEach((effect) => this.addEffect(effect));
      }
      /**
       * Mixes all enumerable properties and methods from a source object to Container.
       * @param source - The source of properties and methods to mix in.
       */
      static mixin(source3) {
        Object.defineProperties(_Container.prototype, Object.getOwnPropertyDescriptors(source3));
      }
      /**
       * Adds one or more children to the container.
       *
       * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
       * @param {...Container} children - The Container(s) to add to the container
       * @returns {Container} - The first child that was added.
       */
      addChild(...children) {
        if (!this.allowChildren) {
          deprecation(v8_0_0, "addChild: Only Containers will be allowed to add children in v8.0.0");
        }
        if (children.length > 1) {
          for (let i2 = 0; i2 < children.length; i2++) {
            this.addChild(children[i2]);
          }
          return children[0];
        }
        const child = children[0];
        if (child.parent === this) {
          this.children.splice(this.children.indexOf(child), 1);
          this.children.push(child);
          if (this.layerGroup && !this.isLayerRoot) {
            this.layerGroup.structureDidChange = true;
          }
          return child;
        }
        if (child.parent) {
          child.parent.removeChild(child);
        }
        this.children.push(child);
        if (this.sortableChildren)
          this.sortDirty = true;
        child.parent = this;
        child.didChange = true;
        child.didViewUpdate = false;
        child._updateFlags = 15;
        if (this.layerGroup) {
          this.layerGroup.addChild(child);
        }
        this.emit("childAdded", child, this, this.children.length - 1);
        child.emit("added", this);
        if (child._zIndex !== 0) {
          child.depthOfChildModified();
        }
        return child;
      }
      /**
       * Removes one or more children from the container.
       * @param {...Container} children - The Container(s) to remove
       * @returns {Container} The first child that was removed.
       */
      removeChild(...children) {
        if (children.length > 1) {
          for (let i2 = 0; i2 < children.length; i2++) {
            this.removeChild(children[i2]);
          }
          return children[0];
        }
        const child = children[0];
        const index = this.children.indexOf(child);
        if (index > -1) {
          this.children.splice(index, 1);
          if (this.layerGroup) {
            this.layerGroup.removeChild(child);
          }
        }
        child.parent = null;
        this.emit("childRemoved", child, this, index);
        child.emit("removed", this);
        return child;
      }
      /**
       * @param point
       * @internal
       */
      onUpdate(point) {
        if (point) {
          if (point === this._skew) {
            this._updateSkew();
          }
        }
        if (this.didChange)
          return;
        this.didChange = true;
        if (this.isLayerRoot) {
          const layerGroupParent = this.layerGroup.layerGroupParent;
          if (layerGroupParent) {
            layerGroupParent.onChildUpdate(this);
          }
        } else if (this.layerGroup) {
          this.layerGroup.onChildUpdate(this);
        }
      }
      /** @internal */
      onViewUpdate() {
        if (this.didViewUpdate)
          return;
        this.didViewUpdate = true;
        if (this.layerGroup) {
          this.layerGroup.onChildViewUpdate(this);
        }
      }
      set layer(value) {
        if (this.isLayerRoot && value === false) {
          throw new Error("[Pixi] cannot undo a layer just yet");
        }
        if (value) {
          this.enableLayer();
        }
      }
      get layer() {
        return this.isLayerRoot;
      }
      enableLayer() {
        if (this.layerGroup && this.layerGroup.root === this)
          return;
        this.isLayerRoot = true;
        const parentLayerGroup = this.layerGroup;
        if (parentLayerGroup) {
          parentLayerGroup.removeChild(this);
        }
        this.layerGroup = new LayerGroup(this);
        if (parentLayerGroup) {
          for (let i2 = 0; i2 < parentLayerGroup.layerGroupChildren.length; i2++) {
            const childLayerGroup = parentLayerGroup.layerGroupChildren[i2];
            let parent = childLayerGroup.root;
            while (parent) {
              if (parent === this) {
                this.layerGroup.addLayerGroupChild(childLayerGroup);
                break;
              }
              parent = parent.parent;
            }
          }
          parentLayerGroup.addLayerGroupChild(this.layerGroup);
        }
        this._updateIsSimple();
      }
      /**
       * @ignore
       */
      _updateIsSimple() {
        this.isSimple = !this.isLayerRoot && this.effects.length === 0;
      }
      get worldTransform() {
        this._worldTransform || (this._worldTransform = new Matrix());
        if (this.layerGroup) {
          if (this.isLayerRoot) {
            this._worldTransform.copyFrom(this.layerGroup.worldTransform);
          } else {
            this._worldTransform.appendFrom(this.layerTransform, this.layerGroup.worldTransform);
          }
        }
        return this._worldTransform;
      }
      /// ////// transform related stuff
      /**
       * The position of the container on the x axis relative to the local coordinates of the parent.
       * An alias to position.x
       */
      get x() {
        return this._position.x;
      }
      set x(value) {
        this._position.x = value;
      }
      /**
       * The position of the container on the y axis relative to the local coordinates of the parent.
       * An alias to position.y
       */
      get y() {
        return this._position.y;
      }
      set y(value) {
        this._position.y = value;
      }
      get position() {
        return this._position;
      }
      set position(value) {
        this._position.copyFrom(value);
      }
      /**
       * The rotation of the object in radians.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get rotation() {
        return this._rotation;
      }
      set rotation(value) {
        if (this._rotation !== value) {
          this._rotation = value;
          this.onUpdate(this._skew);
        }
      }
      /**
       * The angle of the object in degrees.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get angle() {
        return this.rotation * RAD_TO_DEG;
      }
      set angle(value) {
        this.rotation = value * DEG_TO_RAD;
      }
      get pivot() {
        if (this._pivot === defaultPivot) {
          this._pivot = new ObservablePoint(this, 0, 0);
        }
        return this._pivot;
      }
      set pivot(value) {
        if (this._pivot === defaultPivot) {
          this._pivot = new ObservablePoint(this, 0, 0);
        }
        this._pivot.copyFrom(value);
      }
      get skew() {
        if (this._skew === defaultSkew) {
          this._skew = new ObservablePoint(this, 0, 0);
        }
        return this._skew;
      }
      get scale() {
        if (this._scale === defaultScale) {
          this._scale = new ObservablePoint(this, 1, 1);
        }
        return this._scale;
      }
      set scale(value) {
        if (this._scale === defaultScale) {
          this._scale = new ObservablePoint(this, 0, 0);
        }
        this._scale.copyFrom(value);
      }
      /** Called when the skew or the rotation changes. */
      _updateSkew() {
        const rotation = this._rotation;
        const skew = this._skew;
        this._cx = Math.cos(rotation + skew._y);
        this._sx = Math.sin(rotation + skew._y);
        this._cy = -Math.sin(rotation - skew._x);
        this._sy = Math.cos(rotation - skew._x);
      }
      /// ///// color related stuff
      set alpha(value) {
        value = value * 255 | 0;
        if (value === (this.localColor >> 24 & 255))
          return;
        this.localColor = this.localColor & 16777215 | value << 24;
        this._updateFlags |= UPDATE_COLOR;
        this.onUpdate();
      }
      get alpha() {
        return (this.localColor >> 24 & 255) / 255;
      }
      set tint(value) {
        const tempColor = Color.shared.setValue(value);
        const bgr = tempColor.toBgrNumber();
        if (bgr === (this.localColor & 16777215))
          return;
        this.localColor = this.localColor & 4278190080 | bgr & 16777215;
        this._updateFlags |= UPDATE_COLOR;
        this.onUpdate();
      }
      get tint() {
        const bgr = this.localColor & 16777215;
        return ((bgr & 255) << 16) + (bgr & 65280) + (bgr >> 16 & 255);
      }
      /// //////////////// blend related stuff
      set blendMode(value) {
        if (this.localBlendMode === value)
          return;
        if (this.layerGroup && !this.isLayerRoot) {
          this.layerGroup.structureDidChange = true;
        }
        this._updateFlags |= UPDATE_BLEND;
        this.localBlendMode = value;
        this.onUpdate();
      }
      get blendMode() {
        return this.localBlendMode;
      }
      /// ///////// VISIBILITY / RENDERABLE /////////////////
      get visible() {
        return !!(this.localVisibleRenderable & 2);
      }
      // visible -  the renderable is not shown, also the transform is not updated
      set visible(value) {
        const valueNumber = value ? 1 : 0;
        if ((this.localVisibleRenderable & 2) >> 1 === valueNumber)
          return;
        if (this.layerGroup && !this.isLayerRoot) {
          this.layerGroup.structureDidChange = true;
        }
        this._updateFlags |= UPDATE_VISIBLE;
        this.localVisibleRenderable = this.localVisibleRenderable & 1 | valueNumber << 1;
        this.onUpdate();
      }
      get renderable() {
        return !!(this.localVisibleRenderable & 1);
      }
      set renderable(value) {
        const valueNumber = value ? 1 : 0;
        if ((this.localVisibleRenderable & 1) === valueNumber)
          return;
        this.localVisibleRenderable = this.localVisibleRenderable & 2 | valueNumber;
        this._updateFlags |= UPDATE_VISIBLE;
        if (this.layerGroup && !this.isLayerRoot) {
          this.layerGroup.structureDidChange = true;
        }
        this.onUpdate();
      }
      get isRenderable() {
        const worldAlpha = this.layerColor >> 24 & 255;
        return this.localVisibleRenderable === 3 && worldAlpha > 0;
      }
      /**
       * Removes all internal references and listeners as well as removes children from the display list.
       * Do not use a Container after calling `destroy`.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
       *  method called as well. 'options' will be passed on to those calls.
       * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children
       * is set to true it should destroy the texture of the child sprite
       * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
       * If options.children is set to true it should destroy the texture source of the child sprite
       * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
       * If options.children is set to true it should destroy the context of the child graphics
       */
      destroy(options = false) {
        if (this.destroyed)
          return;
        this.destroyed = true;
        this.removeFromParent();
        this.parent = null;
        this._mask = null;
        this._filters = null;
        this.effects = null;
        this._position = null;
        this._scale = null;
        this._pivot = null;
        this._skew = null;
        this.emit("destroyed");
        this.removeAllListeners();
        const destroyChildren = typeof options === "boolean" ? options : options?.children;
        const oldChildren = this.removeChildren(0, this.children.length);
        if (destroyChildren) {
          for (let i2 = 0; i2 < oldChildren.length; ++i2) {
            oldChildren[i2].destroy(options);
          }
        }
        if (this.view) {
          this.view.destroy(options);
          this.view.owner = null;
        }
      }
    };
    Container.mixin(childrenHelperMixin);
    Container.mixin(toLocalGlobalMixin);
    Container.mixin(onRenderMixin);
    Container.mixin(measureMixin);
    Container.mixin(effectsMixin);
    Container.mixin(findMixin);
    Container.mixin(sortMixin);
  }
});

// ../../node_modules/.pnpm/ismobilejs@1.1.1/node_modules/ismobilejs/esm/isMobile.js
function createMatch(userAgent) {
  return function(regex) {
    return regex.test(userAgent);
  };
}
function isMobile(param) {
  var nav = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  if (!param && typeof navigator !== "undefined") {
    nav = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      maxTouchPoints: navigator.maxTouchPoints || 0
    };
  } else if (typeof param === "string") {
    nav.userAgent = param;
  } else if (param && param.userAgent) {
    nav = {
      userAgent: param.userAgent,
      platform: param.platform,
      maxTouchPoints: param.maxTouchPoints || 0
    };
  }
  var userAgent = nav.userAgent;
  var tmp = userAgent.split("[FBAN");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  tmp = userAgent.split("Twitter");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  var match = createMatch(userAgent);
  var result = {
    apple: {
      phone: match(appleIphone) && !match(windowsPhone),
      ipod: match(appleIpod),
      tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
      universal: match(appleUniversal),
      device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
    },
    amazon: {
      phone: match(amazonPhone),
      tablet: !match(amazonPhone) && match(amazonTablet),
      device: match(amazonPhone) || match(amazonTablet)
    },
    android: {
      phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
      tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
      device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
    },
    windows: {
      phone: match(windowsPhone),
      tablet: match(windowsTablet),
      device: match(windowsPhone) || match(windowsTablet)
    },
    other: {
      blackberry: match(otherBlackBerry),
      blackberry10: match(otherBlackBerry10),
      opera: match(otherOpera),
      firefox: match(otherFirefox),
      chrome: match(otherChrome),
      device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
    },
    any: false,
    phone: false,
    tablet: false
  };
  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
  result.phone = result.apple.phone || result.android.phone || result.windows.phone;
  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
  return result;
}
var appleIphone, appleIpod, appleTablet, appleUniversal, androidPhone, androidTablet, amazonPhone, amazonTablet, windowsPhone, windowsTablet, otherBlackBerry, otherBlackBerry10, otherOpera, otherChrome, otherFirefox, isAppleTabletOnIos13;
var init_isMobile = __esm({
  "../../node_modules/.pnpm/ismobilejs@1.1.1/node_modules/ismobilejs/esm/isMobile.js"() {
    appleIphone = /iPhone/i;
    appleIpod = /iPod/i;
    appleTablet = /iPad/i;
    appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
    androidPhone = /\bAndroid(?:.+)Mobile\b/i;
    androidTablet = /Android/i;
    amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
    amazonTablet = /Silk/i;
    windowsPhone = /Windows Phone/i;
    windowsTablet = /\bWindows(?:.+)ARM\b/i;
    otherBlackBerry = /BlackBerry/i;
    otherBlackBerry10 = /BB10/i;
    otherOpera = /Opera Mini/i;
    otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
    otherFirefox = /Mobile(?:.+)Firefox\b/i;
    isAppleTabletOnIos13 = function(navigator2) {
      return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
    };
  }
});

// ../../node_modules/.pnpm/ismobilejs@1.1.1/node_modules/ismobilejs/esm/index.js
var init_esm = __esm({
  "../../node_modules/.pnpm/ismobilejs@1.1.1/node_modules/ismobilejs/esm/index.js"() {
    init_isMobile();
    init_isMobile();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/settings/utils/isMobile.mjs
var isMobileCall, isMobile2;
var init_isMobile2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/settings/utils/isMobile.mjs"() {
    init_esm();
    isMobileCall = isMobile.default ?? isMobile;
    isMobile2 = isMobileCall(globalThis.navigator);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs
var accessibilityTarget;
var init_accessibilityTarget = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs"() {
    accessibilityTarget = {
      /**
       *  Flag for if the object is accessible. If true AccessibilityManager will overlay a
       *   shadow div with attributes set
       * @member {boolean}
       * @memberof Container#
       */
      accessible: false,
      /**
       * Sets the title attribute of the shadow div
       * If accessibleTitle AND accessibleHint has not been this will default to 'container [tabIndex]'
       * @member {?string}
       * @memberof Container#
       */
      accessibleTitle: null,
      /**
       * Sets the aria-label attribute of the shadow div
       * @member {string}
       * @memberof Container#
       */
      accessibleHint: null,
      /**
       * @member {number}
       * @memberof Container#
       * @private
       * @todo Needs docs.
       */
      tabIndex: 0,
      /**
       * @member {boolean}
       * @memberof Container#
       * @todo Needs docs.
       */
      _accessibleActive: false,
      /**
       * @member {boolean}
       * @memberof Container#
       * @todo Needs docs.
       */
      _accessibleDiv: null,
      /**
       * Specify the type of div the accessible layer is. Screen readers treat the element differently
       * depending on this type. Defaults to button.
       * @member {string}
       * @memberof Container#
       * @default 'button'
       */
      accessibleType: "button",
      /**
       * Specify the pointer-events the accessible div will use
       * Defaults to auto.
       * @member {string}
       * @memberof Container#
       * @default 'auto'
       */
      accessiblePointerEvents: "auto",
      /**
       * Setting to false will prevent any children inside this container to
       * be accessible. Defaults to true.
       * @member {boolean}
       * @memberof Container#
       * @default true
       */
      accessibleChildren: true,
      renderId: -1
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs
var KEY_CODE_TAB, DIV_TOUCH_SIZE, DIV_TOUCH_POS_X, DIV_TOUCH_POS_Y, DIV_TOUCH_ZINDEX, DIV_HOOK_SIZE, DIV_HOOK_POS_X, DIV_HOOK_POS_Y, DIV_HOOK_ZINDEX, AccessibilitySystem;
var init_AccessibilitySystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs"() {
    init_FederatedEvent();
    init_Extensions();
    init_Container();
    init_isMobile2();
    init_removeItems();
    init_accessibilityTarget();
    Container.mixin(accessibilityTarget);
    KEY_CODE_TAB = 9;
    DIV_TOUCH_SIZE = 100;
    DIV_TOUCH_POS_X = 0;
    DIV_TOUCH_POS_Y = 0;
    DIV_TOUCH_ZINDEX = 2;
    DIV_HOOK_SIZE = 1;
    DIV_HOOK_POS_X = -1e3;
    DIV_HOOK_POS_Y = -1e3;
    DIV_HOOK_ZINDEX = 2;
    AccessibilitySystem = class {
      // 2fps
      // eslint-disable-next-line jsdoc/require-param
      /**
       * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer
       */
      // eslint-disable-next-line @typescript-eslint/no-parameter-properties
      constructor(renderer, _mobileInfo = isMobile2) {
        this._mobileInfo = _mobileInfo;
        this.debug = false;
        this._isActive = false;
        this._isMobileAccessibility = false;
        this._pool = [];
        this._renderId = 0;
        this._children = [];
        this._androidUpdateCount = 0;
        this._androidUpdateFrequency = 500;
        this._hookDiv = null;
        if (_mobileInfo.tablet || _mobileInfo.phone) {
          this._createTouchHook();
        }
        const div = document.createElement("div");
        div.style.width = `${DIV_TOUCH_SIZE}px`;
        div.style.height = `${DIV_TOUCH_SIZE}px`;
        div.style.position = "absolute";
        div.style.top = `${DIV_TOUCH_POS_X}px`;
        div.style.left = `${DIV_TOUCH_POS_Y}px`;
        div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
        this._div = div;
        this._renderer = renderer;
        this._onKeyDown = this._onKeyDown.bind(this);
        this._onMouseMove = this._onMouseMove.bind(this);
        globalThis.addEventListener("keydown", this._onKeyDown, false);
      }
      /**
       * Value of `true` if accessibility is currently active and accessibility layers are showing.
       * @member {boolean}
       * @readonly
       */
      get isActive() {
        return this._isActive;
      }
      /**
       * Value of `true` if accessibility is enabled for touch devices.
       * @member {boolean}
       * @readonly
       */
      get isMobileAccessibility() {
        return this._isMobileAccessibility;
      }
      get hookDiv() {
        return this._hookDiv;
      }
      /**
       * Creates the touch hooks.
       * @private
       */
      _createTouchHook() {
        const hookDiv = document.createElement("button");
        hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
        hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
        hookDiv.style.position = "absolute";
        hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
        hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
        hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
        hookDiv.style.backgroundColor = "#FF0000";
        hookDiv.title = "select to enable accessibility for this content";
        hookDiv.addEventListener("focus", () => {
          this._isMobileAccessibility = true;
          this._activate();
          this._destroyTouchHook();
        });
        document.body.appendChild(hookDiv);
        this._hookDiv = hookDiv;
      }
      /**
       * Destroys the touch hooks.
       * @private
       */
      _destroyTouchHook() {
        if (!this._hookDiv) {
          return;
        }
        document.body.removeChild(this._hookDiv);
        this._hookDiv = null;
      }
      /**
       * Activating will cause the Accessibility layer to be shown.
       * This is called when a user presses the tab key.
       * @private
       */
      _activate() {
        if (this._isActive) {
          return;
        }
        this._isActive = true;
        globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
        globalThis.removeEventListener("keydown", this._onKeyDown, false);
        this._renderer.runners.postrender.add(this);
        this._renderer.view.canvas.parentNode?.appendChild(this._div);
      }
      /**
       * Deactivating will cause the Accessibility layer to be hidden.
       * This is called when a user moves the mouse.
       * @private
       */
      _deactivate() {
        if (!this._isActive || this._isMobileAccessibility) {
          return;
        }
        this._isActive = false;
        globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
        globalThis.addEventListener("keydown", this._onKeyDown, false);
        this._renderer.runners.postrender.remove(this);
        this._div.parentNode?.removeChild(this._div);
      }
      /**
       * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
       * @private
       * @param {Container} container - The Container to check.
       */
      _updateAccessibleObjects(container) {
        if (!container.visible || !container.accessibleChildren) {
          return;
        }
        if (container.accessible && container.isInteractive()) {
          if (!container._accessibleActive) {
            this._addChild(container);
          }
          container.renderId = this._renderId;
        }
        const children = container.children;
        if (children) {
          for (let i2 = 0; i2 < children.length; i2++) {
            this._updateAccessibleObjects(children[i2]);
          }
        }
      }
      /**
       * Runner init called, view is available at this point.
       * @ignore
       */
      init(options) {
        this.debug = options?.debug ?? this.debug;
        this._renderer.runners.postrender.remove(this);
      }
      /**
       * Runner postrender was called, ensure that all divs are mapped correctly to their DisplayObjects.
       * Only fires while active.
       * @ignore
       */
      postrender() {
        const now = performance.now();
        if (this._mobileInfo.android.device && now < this._androidUpdateCount) {
          return;
        }
        this._androidUpdateCount = now + this._androidUpdateFrequency;
        if (!this._renderer.renderingToScreen || !this._renderer.view.canvas) {
          return;
        }
        if (this._renderer.lastObjectRendered) {
          this._updateAccessibleObjects(this._renderer.lastObjectRendered);
        }
        const { x: x3, y: y2, width, height } = this._renderer.view.canvas.getBoundingClientRect();
        const { width: viewWidth, height: viewHeight, resolution } = this._renderer;
        const sx = width / viewWidth * resolution;
        const sy = height / viewHeight * resolution;
        let div = this._div;
        div.style.left = `${x3}px`;
        div.style.top = `${y2}px`;
        div.style.width = `${viewWidth}px`;
        div.style.height = `${viewHeight}px`;
        for (let i2 = 0; i2 < this._children.length; i2++) {
          const child = this._children[i2];
          if (child.renderId !== this._renderId) {
            child._accessibleActive = false;
            removeItems(this._children, i2, 1);
            this._div.removeChild(child._accessibleDiv);
            this._pool.push(child._accessibleDiv);
            child._accessibleDiv = null;
            i2--;
          } else {
            div = child._accessibleDiv;
            let hitArea = child.hitArea;
            const wt = child.worldTransform;
            if (child.hitArea) {
              div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;
              div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;
              div.style.width = `${hitArea.width * wt.a * sx}px`;
              div.style.height = `${hitArea.height * wt.d * sy}px`;
            } else {
              hitArea = child.getBounds();
              this.capHitArea(hitArea);
              div.style.left = `${hitArea.x * sx}px`;
              div.style.top = `${hitArea.y * sy}px`;
              div.style.width = `${hitArea.width * sx}px`;
              div.style.height = `${hitArea.height * sy}px`;
              if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
                div.title = child.accessibleTitle;
              }
              if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
                div.setAttribute("aria-label", child.accessibleHint);
              }
            }
            if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
              div.title = child.accessibleTitle;
              div.tabIndex = child.tabIndex;
              if (this.debug) {
                this.updateDebugHTML(div);
              }
            }
          }
        }
        this._renderId++;
      }
      /**
       * private function that will visually add the information to the
       * accessibility div
       * @param {HTMLElement} div -
       */
      updateDebugHTML(div) {
        div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
      }
      /**
       * Adjust the hit area based on the bounds of a display object
       * @param {Rectangle} hitArea - Bounds of the child
       */
      capHitArea(hitArea) {
        if (hitArea.x < 0) {
          hitArea.width += hitArea.x;
          hitArea.x = 0;
        }
        if (hitArea.y < 0) {
          hitArea.height += hitArea.y;
          hitArea.y = 0;
        }
        const { width: viewWidth, height: viewHeight } = this._renderer;
        if (hitArea.x + hitArea.width > viewWidth) {
          hitArea.width = viewWidth - hitArea.x;
        }
        if (hitArea.y + hitArea.height > viewHeight) {
          hitArea.height = viewHeight - hitArea.y;
        }
      }
      /**
       * Adds a Container to the accessibility manager
       * @private
       * @param {Container} container - The child to make accessible.
       */
      _addChild(container) {
        let div = this._pool.pop();
        if (!div) {
          div = document.createElement("button");
          div.style.width = `${DIV_TOUCH_SIZE}px`;
          div.style.height = `${DIV_TOUCH_SIZE}px`;
          div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
          div.style.position = "absolute";
          div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
          div.style.borderStyle = "none";
          if (navigator.userAgent.toLowerCase().includes("chrome")) {
            div.setAttribute("aria-live", "off");
          } else {
            div.setAttribute("aria-live", "polite");
          }
          if (navigator.userAgent.match(/rv:.*Gecko\//)) {
            div.setAttribute("aria-relevant", "additions");
          } else {
            div.setAttribute("aria-relevant", "text");
          }
          div.addEventListener("click", this._onClick.bind(this));
          div.addEventListener("focus", this._onFocus.bind(this));
          div.addEventListener("focusout", this._onFocusOut.bind(this));
        }
        div.style.pointerEvents = container.accessiblePointerEvents;
        div.type = container.accessibleType;
        if (container.accessibleTitle && container.accessibleTitle !== null) {
          div.title = container.accessibleTitle;
        } else if (!container.accessibleHint || container.accessibleHint === null) {
          div.title = `container ${container.tabIndex}`;
        }
        if (container.accessibleHint && container.accessibleHint !== null) {
          div.setAttribute("aria-label", container.accessibleHint);
        }
        if (this.debug) {
          this.updateDebugHTML(div);
        }
        container._accessibleActive = true;
        container._accessibleDiv = div;
        div.container = container;
        this._children.push(container);
        this._div.appendChild(container._accessibleDiv);
        container._accessibleDiv.tabIndex = container.tabIndex;
      }
      /**
       * Dispatch events with the EventSystem.
       * @param e
       * @param type
       * @private
       */
      _dispatchEvent(e2, type) {
        const { container: target } = e2.target;
        const boundary = this._renderer.events.rootBoundary;
        const event = Object.assign(new FederatedEvent(boundary), { target });
        boundary.rootTarget = this._renderer.lastObjectRendered;
        type.forEach((type2) => boundary.dispatchEvent(event, type2));
      }
      /**
       * Maps the div button press to pixi's EventSystem (click)
       * @private
       * @param {MouseEvent} e - The click event.
       */
      _onClick(e2) {
        this._dispatchEvent(e2, ["click", "pointertap", "tap"]);
      }
      /**
       * Maps the div focus events to pixi's EventSystem (mouseover)
       * @private
       * @param {FocusEvent} e - The focus event.
       */
      _onFocus(e2) {
        if (!e2.target.getAttribute("aria-live")) {
          e2.target.setAttribute("aria-live", "assertive");
        }
        this._dispatchEvent(e2, ["mouseover"]);
      }
      /**
       * Maps the div focus events to pixi's EventSystem (mouseout)
       * @private
       * @param {FocusEvent} e - The focusout event.
       */
      _onFocusOut(e2) {
        if (!e2.target.getAttribute("aria-live")) {
          e2.target.setAttribute("aria-live", "polite");
        }
        this._dispatchEvent(e2, ["mouseout"]);
      }
      /**
       * Is called when a key is pressed
       * @private
       * @param {KeyboardEvent} e - The keydown event.
       */
      _onKeyDown(e2) {
        if (e2.keyCode !== KEY_CODE_TAB) {
          return;
        }
        this._activate();
      }
      /**
       * Is called when the mouse moves across the renderer element
       * @private
       * @param {MouseEvent} e - The mouse event.
       */
      _onMouseMove(e2) {
        if (e2.movementX === 0 && e2.movementY === 0) {
          return;
        }
        this._deactivate();
      }
      /** Destroys the accessibility manager */
      destroy() {
        this._destroyTouchHook();
        this._div = null;
        globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
        globalThis.removeEventListener("keydown", this._onKeyDown);
        this._pool = null;
        this._children = null;
        this._renderer = null;
      }
    };
    AccessibilitySystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "accessibility"
    };
    extensions.add(AccessibilitySystem);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/accessibility/init.mjs
var init_init = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/accessibility/init.mjs"() {
    init_Extensions();
    init_Container();
    init_AccessibilitySystem();
    init_accessibilityTarget();
    extensions.add(AccessibilitySystem);
    Container.mixin(accessibilityTarget);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/ticker/const.mjs
var UPDATE_PRIORITY;
var init_const2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/ticker/const.mjs"() {
    UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
      return UPDATE_PRIORITY2;
    })(UPDATE_PRIORITY || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/ticker/TickerListener.mjs
var TickerListener;
var init_TickerListener = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/ticker/TickerListener.mjs"() {
    TickerListener = class {
      /**
       * Constructor
       * @private
       * @param fn - The listener function to be added for one update
       * @param context - The listener context
       * @param priority - The priority for emitting
       * @param once - If the handler should fire once
       */
      constructor(fn, context2 = null, priority = 0, once = false) {
        this.next = null;
        this.previous = null;
        this._destroyed = false;
        this._fn = fn;
        this._context = context2;
        this.priority = priority;
        this._once = once;
      }
      /**
       * Simple compare function to figure out if a function and context match.
       * @param fn - The listener function to be added for one update
       * @param context - The listener context
       * @returns `true` if the listener match the arguments
       */
      match(fn, context2 = null) {
        return this._fn === fn && this._context === context2;
      }
      /**
       * Emit by calling the current function.
       * @param ticker - The ticker emitting.
       * @returns Next ticker
       */
      emit(ticker) {
        if (this._fn) {
          if (this._context) {
            this._fn.call(this._context, ticker);
          } else {
            this._fn(ticker);
          }
        }
        const redirect = this.next;
        if (this._once) {
          this.destroy(true);
        }
        if (this._destroyed) {
          this.next = null;
        }
        return redirect;
      }
      /**
       * Connect to the list.
       * @param previous - Input node, previous listener
       */
      connect(previous) {
        this.previous = previous;
        if (previous.next) {
          previous.next.previous = this;
        }
        this.next = previous.next;
        previous.next = this;
      }
      /**
       * Destroy and don't use after this.
       * @param hard - `true` to remove the `next` reference, this
       *        is considered a hard destroy. Soft destroy maintains the next reference.
       * @returns The listener to redirect while emitting or removing.
       */
      destroy(hard = false) {
        this._destroyed = true;
        this._fn = null;
        this._context = null;
        if (this.previous) {
          this.previous.next = this.next;
        }
        if (this.next) {
          this.next.previous = this.previous;
        }
        const redirect = this.next;
        this.next = hard ? null : redirect;
        this.previous = null;
        return redirect;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/ticker/Ticker.mjs
var _Ticker, Ticker;
var init_Ticker = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/ticker/Ticker.mjs"() {
    init_const2();
    init_TickerListener();
    _Ticker = class {
      constructor() {
        this.autoStart = false;
        this.deltaTime = 1;
        this.lastTime = -1;
        this.speed = 1;
        this.started = false;
        this._requestId = null;
        this._maxElapsedMS = 100;
        this._minElapsedMS = 0;
        this._protected = false;
        this._lastFrame = -1;
        this._head = new TickerListener(null, null, Infinity);
        this.deltaMS = 1 / _Ticker.targetFPMS;
        this.elapsedMS = 1 / _Ticker.targetFPMS;
        this._tick = (time) => {
          this._requestId = null;
          if (this.started) {
            this.update(time);
            if (this.started && this._requestId === null && this._head.next) {
              this._requestId = requestAnimationFrame(this._tick);
            }
          }
        };
      }
      /**
       * Conditionally requests a new animation frame.
       * If a frame has not already been requested, and if the internal
       * emitter has listeners, a new frame is requested.
       * @private
       */
      _requestIfNeeded() {
        if (this._requestId === null && this._head.next) {
          this.lastTime = performance.now();
          this._lastFrame = this.lastTime;
          this._requestId = requestAnimationFrame(this._tick);
        }
      }
      /**
       * Conditionally cancels a pending animation frame.
       * @private
       */
      _cancelIfNeeded() {
        if (this._requestId !== null) {
          cancelAnimationFrame(this._requestId);
          this._requestId = null;
        }
      }
      /**
       * Conditionally requests a new animation frame.
       * If the ticker has been started it checks if a frame has not already
       * been requested, and if the internal emitter has listeners. If these
       * conditions are met, a new frame is requested. If the ticker has not
       * been started, but autoStart is `true`, then the ticker starts now,
       * and continues with the previous conditions to request a new frame.
       * @private
       */
      _startIfPossible() {
        if (this.started) {
          this._requestIfNeeded();
        } else if (this.autoStart) {
          this.start();
        }
      }
      /**
       * Register a handler for tick events. Calls continuously unless
       * it is removed or the ticker is stopped.
       * @param fn - The listener function to be added for updates
       * @param context - The listener context
       * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
       * @returns This instance of a ticker
       */
      add(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
        return this._addListener(new TickerListener(fn, context2, priority));
      }
      /**
       * Add a handler for the tick event which is only execute once.
       * @param fn - The listener function to be added for one update
       * @param context - The listener context
       * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
       * @returns This instance of a ticker
       */
      addOnce(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
        return this._addListener(new TickerListener(fn, context2, priority, true));
      }
      /**
       * Internally adds the event handler so that it can be sorted by priority.
       * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
       * before the rendering.
       * @private
       * @param listener - Current listener being added.
       * @returns This instance of a ticker
       */
      _addListener(listener) {
        let current = this._head.next;
        let previous = this._head;
        if (!current) {
          listener.connect(previous);
        } else {
          while (current) {
            if (listener.priority > current.priority) {
              listener.connect(previous);
              break;
            }
            previous = current;
            current = current.next;
          }
          if (!listener.previous) {
            listener.connect(previous);
          }
        }
        this._startIfPossible();
        return this;
      }
      /**
       * Removes any handlers matching the function and context parameters.
       * If no handlers are left after removing, then it cancels the animation frame.
       * @param fn - The listener function to be removed
       * @param context - The listener context to be removed
       * @returns This instance of a ticker
       */
      remove(fn, context2) {
        let listener = this._head.next;
        while (listener) {
          if (listener.match(fn, context2)) {
            listener = listener.destroy();
          } else {
            listener = listener.next;
          }
        }
        if (!this._head.next) {
          this._cancelIfNeeded();
        }
        return this;
      }
      /**
       * The number of listeners on this ticker, calculated by walking through linked list
       * @readonly
       * @member {number}
       */
      get count() {
        if (!this._head) {
          return 0;
        }
        let count2 = 0;
        let current = this._head;
        while (current = current.next) {
          count2++;
        }
        return count2;
      }
      /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */
      start() {
        if (!this.started) {
          this.started = true;
          this._requestIfNeeded();
        }
      }
      /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */
      stop() {
        if (this.started) {
          this.started = false;
          this._cancelIfNeeded();
        }
      }
      /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */
      destroy() {
        if (!this._protected) {
          this.stop();
          let listener = this._head.next;
          while (listener) {
            listener = listener.destroy(true);
          }
          this._head.destroy();
          this._head = null;
        }
      }
      /**
       * Triggers an update. An update entails setting the
       * current {@link Ticker#elapsedMS},
       * the current {@link Ticker#deltaTime},
       * invoking all listeners with current deltaTime,
       * and then finally setting {@link Ticker#lastTime}
       * with the value of currentTime that was provided.
       * This method will be called automatically by animation
       * frame callbacks if the ticker instance has been started
       * and listeners are added.
       * @param {number} [currentTime=performance.now()] - the current time of execution
       */
      update(currentTime = performance.now()) {
        let elapsedMS;
        if (currentTime > this.lastTime) {
          elapsedMS = this.elapsedMS = currentTime - this.lastTime;
          if (elapsedMS > this._maxElapsedMS) {
            elapsedMS = this._maxElapsedMS;
          }
          elapsedMS *= this.speed;
          if (this._minElapsedMS) {
            const delta = currentTime - this._lastFrame | 0;
            if (delta < this._minElapsedMS) {
              return;
            }
            this._lastFrame = currentTime - delta % this._minElapsedMS;
          }
          this.deltaMS = elapsedMS;
          this.deltaTime = this.deltaMS * _Ticker.targetFPMS;
          const head = this._head;
          let listener = head.next;
          while (listener) {
            listener = listener.emit(this);
          }
          if (!head.next) {
            this._cancelIfNeeded();
          }
        } else {
          this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        }
        this.lastTime = currentTime;
      }
      /**
       * The frames per second at which this ticker is running.
       * The default is approximately 60 in most modern browsers.
       * **Note:** This does not factor in the value of
       * {@link Ticker#speed}, which is specific
       * to scaling {@link Ticker#deltaTime}.
       * @member {number}
       * @readonly
       */
      get FPS() {
        return 1e3 / this.elapsedMS;
      }
      /**
       * Manages the maximum amount of milliseconds allowed to
       * elapse between invoking {@link Ticker#update}.
       * This value is used to cap {@link Ticker#deltaTime},
       * but does not effect the measured value of {@link Ticker#FPS}.
       * When setting this property it is clamped to a value between
       * `0` and `Ticker.targetFPMS * 1000`.
       * @member {number}
       * @default 10
       */
      get minFPS() {
        return 1e3 / this._maxElapsedMS;
      }
      set minFPS(fps2) {
        const minFPS = Math.min(this.maxFPS, fps2);
        const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);
        this._maxElapsedMS = 1 / minFPMS;
      }
      /**
       * Manages the minimum amount of milliseconds required to
       * elapse between invoking {@link Ticker#update}.
       * This will effect the measured value of {@link Ticker#FPS}.
       * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
       * Otherwise it will be at least `minFPS`
       * @member {number}
       * @default 0
       */
      get maxFPS() {
        if (this._minElapsedMS) {
          return Math.round(1e3 / this._minElapsedMS);
        }
        return 0;
      }
      set maxFPS(fps2) {
        if (fps2 === 0) {
          this._minElapsedMS = 0;
        } else {
          const maxFPS = Math.max(this.minFPS, fps2);
          this._minElapsedMS = 1 / (maxFPS / 1e3);
        }
      }
      /**
       * The shared ticker instance used by {@link AnimatedSprite} and by
       * {@link VideoResource} to update animation frames / video textures.
       *
       * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.
       *
       * The property {@link Ticker#autoStart} is set to `true` for this instance.
       * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
       * @example
       * import { Ticker } from 'pixi.js';
       *
       * const ticker = Ticker.shared;
       * // Set this to prevent starting this ticker when listeners are added.
       * // By default this is true only for the Ticker.shared instance.
       * ticker.autoStart = false;
       *
       * // FYI, call this to ensure the ticker is stopped. It should be stopped
       * // if you have not attempted to render anything yet.
       * ticker.stop();
       *
       * // Call this when you are ready for a running shared ticker.
       * ticker.start();
       * @example
       * import { autoDetectRenderer, Container } from 'pixi.js';
       *
       * // You may use the shared ticker to render...
       * const renderer = autoDetectRenderer();
       * const stage = new Container();
       * document.body.appendChild(renderer.view);
       * ticker.add((time) => renderer.render(stage));
       *
       * // Or you can just update it manually.
       * ticker.autoStart = false;
       * ticker.stop();
       * const animate = (time) => {
       *     ticker.update(time);
       *     renderer.render(stage);
       *     requestAnimationFrame(animate);
       * };
       * animate(performance.now());
       * @member {Ticker}
       * @static
       */
      static get shared() {
        if (!_Ticker._shared) {
          const shared = _Ticker._shared = new _Ticker();
          shared.autoStart = true;
          shared._protected = true;
        }
        return _Ticker._shared;
      }
      /**
       * The system ticker instance used by {@link BasePrepare} for core timing
       * functionality that shouldn't usually need to be paused, unlike the `shared`
       * ticker which drives visual animations and rendering which may want to be paused.
       *
       * The property {@link Ticker#autoStart} is set to `true` for this instance.
       * @member {Ticker}
       * @static
       */
      static get system() {
        if (!_Ticker._system) {
          const system = _Ticker._system = new _Ticker();
          system.autoStart = true;
          system._protected = true;
        }
        return _Ticker._system;
      }
    };
    Ticker = _Ticker;
    Ticker.targetFPMS = 0.06;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/ticker/TickerPlugin.mjs
var TickerPlugin;
var init_TickerPlugin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/ticker/TickerPlugin.mjs"() {
    init_Extensions();
    init_const2();
    init_Ticker();
    TickerPlugin = class {
      /**
       * Initialize the plugin with scope of application instance
       * @static
       * @private
       * @param {object} [options] - See application options
       */
      static init(options) {
        options = Object.assign({
          autoStart: true,
          sharedTicker: false
        }, options);
        Object.defineProperty(
          this,
          "ticker",
          {
            set(ticker) {
              if (this._ticker) {
                this._ticker.remove(this.render, this);
              }
              this._ticker = ticker;
              if (ticker) {
                ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
              }
            },
            get() {
              return this._ticker;
            }
          }
        );
        this.stop = () => {
          this._ticker.stop();
        };
        this.start = () => {
          this._ticker.start();
        };
        this._ticker = null;
        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
        if (options.autoStart) {
          this.start();
        }
      }
      /**
       * Clean up the ticker, scoped to application.
       * @static
       * @private
       */
      static destroy() {
        if (this._ticker) {
          const oldTicker = this._ticker;
          this.ticker = null;
          oldTicker.destroy();
        }
      }
    };
    TickerPlugin.extension = ExtensionType.Application;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/app/ResizePlugin.mjs
var ResizePlugin;
var init_ResizePlugin = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/app/ResizePlugin.mjs"() {
    init_Extensions();
    ResizePlugin = class {
      /**
       * Initialize the plugin with scope of application instance
       * @static
       * @private
       * @param {object} [options] - See application options
       */
      static init(options) {
        Object.defineProperty(
          this,
          "resizeTo",
          /**
           * The HTML element or window to automatically resize the
           * renderer's view element to match width and height.
           * @member {Window|HTMLElement}
           * @name resizeTo
           * @memberof Application#
           */
          {
            set(dom) {
              globalThis.removeEventListener("resize", this.queueResize);
              this._resizeTo = dom;
              if (dom) {
                globalThis.addEventListener("resize", this.queueResize);
                this.resize();
              }
            },
            get() {
              return this._resizeTo;
            }
          }
        );
        this.queueResize = () => {
          if (!this._resizeTo) {
            return;
          }
          this._cancelResize();
          this._resizeId = requestAnimationFrame(() => this.resize());
        };
        this._cancelResize = () => {
          if (this._resizeId) {
            cancelAnimationFrame(this._resizeId);
            this._resizeId = null;
          }
        };
        this.resize = () => {
          if (!this._resizeTo) {
            return;
          }
          this._cancelResize();
          let width;
          let height;
          if (this._resizeTo === globalThis.window) {
            width = globalThis.innerWidth;
            height = globalThis.innerHeight;
          } else {
            const { clientWidth, clientHeight } = this._resizeTo;
            width = clientWidth;
            height = clientHeight;
          }
          this.renderer.resize(width, height);
          this.render();
        };
        this._resizeId = null;
        this._resizeTo = null;
        this.resizeTo = options.resizeTo || null;
      }
      /**
       * Clean up the ticker, scoped to application
       * @static
       * @private
       */
      static destroy() {
        globalThis.removeEventListener("resize", this.queueResize);
        this._cancelResize();
        this._cancelResize = null;
        this.queueResize = null;
        this.resizeTo = null;
        this.resize = null;
      }
    };
    ResizePlugin.extension = ExtensionType.Application;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/app/init.mjs
var init_init2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/app/init.mjs"() {
    init_Extensions();
    init_TickerPlugin();
    init_ResizePlugin();
    extensions.add(ResizePlugin);
    extensions.add(TickerPlugin);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs
var LoaderParserPriority;
var init_LoaderParser = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs"() {
    LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
      LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
      LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
      LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
      return LoaderParserPriority2;
    })(LoaderParserPriority || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs
var copySearchParams;
var init_copySearchParams = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs"() {
    copySearchParams = (targetUrl, sourceUrl) => {
      const searchParams = sourceUrl.split("?")[1];
      if (searchParams) {
        targetUrl += `?${searchParams}`;
      }
      return targetUrl;
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/settings/adapter/adapter.mjs
var BrowserAdapter, currentAdapter, DOMAdapter;
var init_adapter = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/settings/adapter/adapter.mjs"() {
    BrowserAdapter = {
      /**
       * Creates a canvas element of the given size.
       * This canvas is created using the browser's native canvas element.
       * @param width - width of the canvas
       * @param height - height of the canvas
       */
      createCanvas: (width, height) => {
        const canvas2 = document.createElement("canvas");
        canvas2.width = width;
        canvas2.height = height;
        return canvas2;
      },
      getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
      getWebGLRenderingContext: () => WebGLRenderingContext,
      getNavigator: () => navigator,
      getBaseUrl: () => document.baseURI ?? window.location.href,
      getFontFaceSet: () => document.fonts,
      fetch: (url, options) => fetch(url, options),
      parseXML: (xml) => {
        const parser = new DOMParser();
        return parser.parseFromString(xml, "text/xml");
      }
    };
    currentAdapter = BrowserAdapter;
    DOMAdapter = {
      get() {
        return currentAdapter;
      },
      set(adapter) {
        currentAdapter = adapter;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/path.mjs
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
  }
}
function removeUrlParams(url) {
  const re = url.split("?")[0];
  return re.split("#")[0];
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll(str, find, replace) {
  return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
}
function normalizeStringPosix(path2, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = -1;
  for (let i2 = 0; i2 <= path2.length; ++i2) {
    if (i2 < path2.length) {
      code = path2.charCodeAt(i2);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === i2 - 1 || dots === 1) {
      } else if (lastSlash !== i2 - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i2;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path2.slice(lastSlash + 1, i2)}`;
        } else {
          res = path2.slice(lastSlash + 1, i2);
        }
        lastSegmentLength = i2 - lastSlash - 1;
      }
      lastSlash = i2;
      dots = 0;
    } else if (code === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
var path;
var init_path = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/path.mjs"() {
    init_adapter();
    path = {
      /**
       * Converts a path to posix format.
       * @param path - The path to convert to posix
       */
      toPosix(path2) {
        return replaceAll(path2, "\\", "/");
      },
      /**
       * Checks if the path is a URL e.g. http://, https://
       * @param path - The path to check
       */
      isUrl(path2) {
        return /^https?:/.test(this.toPosix(path2));
      },
      /**
       * Checks if the path is a data URL
       * @param path - The path to check
       */
      isDataUrl(path2) {
        return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
      },
      /**
       * Checks if the path is a blob URL
       * @param path - The path to check
       */
      isBlobUrl(path2) {
        return path2.startsWith("blob:");
      },
      /**
       * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
       * This will return true for windows file paths
       * @param path - The path to check
       */
      hasProtocol(path2) {
        return /^[^/:]+:/.test(this.toPosix(path2));
      },
      /**
       * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
       * @param path - The path to get the protocol from
       */
      getProtocol(path2) {
        assertPath(path2);
        path2 = this.toPosix(path2);
        const matchFile = /^file:\/\/\//.exec(path2);
        if (matchFile) {
          return matchFile[0];
        }
        const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path2);
        if (matchProtocol) {
          return matchProtocol[0];
        }
        return "";
      },
      /**
       * Converts URL to an absolute path.
       * When loading from a Web Worker, we must use absolute paths.
       * If the URL is already absolute we return it as is
       * If it's not, we convert it
       * @param url - The URL to test
       * @param customBaseUrl - The base URL to use
       * @param customRootUrl - The root URL to use
       */
      toAbsolute(url, customBaseUrl, customRootUrl) {
        assertPath(url);
        if (this.isDataUrl(url) || this.isBlobUrl(url))
          return url;
        const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));
        const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
        url = this.toPosix(url);
        if (url.startsWith("/")) {
          return path.join(rootUrl, url.slice(1));
        }
        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);
        return absolutePath;
      },
      /**
       * Normalizes the given path, resolving '..' and '.' segments
       * @param path - The path to normalize
       */
      normalize(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        if (this.isDataUrl(path2) || this.isBlobUrl(path2))
          return path2;
        path2 = this.toPosix(path2);
        let protocol = "";
        const isAbsolute = path2.startsWith("/");
        if (this.hasProtocol(path2)) {
          protocol = this.rootname(path2);
          path2 = path2.slice(protocol.length);
        }
        const trailingSeparator = path2.endsWith("/");
        path2 = normalizeStringPosix(path2, false);
        if (path2.length > 0 && trailingSeparator)
          path2 += "/";
        if (isAbsolute)
          return `/${path2}`;
        return protocol + path2;
      },
      /**
       * Determines if path is an absolute path.
       * Absolute paths can be urls, data urls, or paths on disk
       * @param path - The path to test
       */
      isAbsolute(path2) {
        assertPath(path2);
        path2 = this.toPosix(path2);
        if (this.hasProtocol(path2))
          return true;
        return path2.startsWith("/");
      },
      /**
       * Joins all given path segments together using the platform-specific separator as a delimiter,
       * then normalizes the resulting path
       * @param segments - The segments of the path to join
       */
      join(...segments) {
        if (segments.length === 0) {
          return ".";
        }
        let joined;
        for (let i2 = 0; i2 < segments.length; ++i2) {
          const arg = segments[i2];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else {
              const prevArg = segments[i2 - 1] ?? "";
              if (this.extname(prevArg)) {
                joined += `/../${arg}`;
              } else {
                joined += `/${arg}`;
              }
            }
          }
        }
        if (joined === void 0) {
          return ".";
        }
        return this.normalize(joined);
      },
      /**
       * Returns the directory name of a path
       * @param path - The path to parse
       */
      dirname(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        path2 = this.toPosix(path2);
        let code = path2.charCodeAt(0);
        const hasRoot = code === 47;
        let end = -1;
        let matchedSlash = true;
        const proto = this.getProtocol(path2);
        const origpath = path2;
        path2 = path2.slice(proto.length);
        for (let i2 = path2.length - 1; i2 >= 1; --i2) {
          code = path2.charCodeAt(i2);
          if (code === 47) {
            if (!matchedSlash) {
              end = i2;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
        if (hasRoot && end === 1)
          return "//";
        return proto + path2.slice(0, end);
      },
      /**
       * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
       * @param path - The path to parse
       */
      rootname(path2) {
        assertPath(path2);
        path2 = this.toPosix(path2);
        let root = "";
        if (path2.startsWith("/"))
          root = "/";
        else {
          root = this.getProtocol(path2);
        }
        if (this.isUrl(path2)) {
          const index = path2.indexOf("/", root.length);
          if (index !== -1) {
            root = path2.slice(0, index);
          } else
            root = path2;
          if (!root.endsWith("/"))
            root += "/";
        }
        return root;
      },
      /**
       * Returns the last portion of a path
       * @param path - The path to test
       * @param ext - Optional extension to remove
       */
      basename(path2, ext) {
        assertPath(path2);
        if (ext)
          assertPath(ext);
        path2 = removeUrlParams(this.toPosix(path2));
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i2;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
          if (ext.length === path2.length && ext === path2)
            return "";
          let extIdx = ext.length - 1;
          let firstNonSlashEnd = -1;
          for (i2 = path2.length - 1; i2 >= 0; --i2) {
            const code = path2.charCodeAt(i2);
            if (code === 47) {
              if (!matchedSlash) {
                start = i2 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i2 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i2;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path2.length;
          return path2.slice(start, end);
        }
        for (i2 = path2.length - 1; i2 >= 0; --i2) {
          if (path2.charCodeAt(i2) === 47) {
            if (!matchedSlash) {
              start = i2 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
          }
        }
        if (end === -1)
          return "";
        return path2.slice(start, end);
      },
      /**
       * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
       * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
       * the first character of the basename of path, an empty string is returned.
       * @param path - The path to parse
       */
      extname(path2) {
        assertPath(path2);
        path2 = removeUrlParams(this.toPosix(path2));
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        for (let i2 = path2.length - 1; i2 >= 0; --i2) {
          const code = path2.charCodeAt(i2);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i2 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i2;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path2.slice(startDot, end);
      },
      /**
       * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
       * @param path - The path to parse
       */
      parse(path2) {
        assertPath(path2);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path2.length === 0)
          return ret;
        path2 = removeUrlParams(this.toPosix(path2));
        let code = path2.charCodeAt(0);
        const isAbsolute = this.isAbsolute(path2);
        let start;
        const protocol = "";
        ret.root = this.rootname(path2);
        if (isAbsolute || this.hasProtocol(path2)) {
          start = 1;
        } else {
          start = 0;
        }
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let i2 = path2.length - 1;
        let preDotState = 0;
        for (; i2 >= start; --i2) {
          code = path2.charCodeAt(i2);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i2 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i2;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute)
              ret.base = ret.name = path2.slice(1, end);
            else
              ret.base = ret.name = path2.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path2.slice(1, startDot);
            ret.base = path2.slice(1, end);
          } else {
            ret.name = path2.slice(startPart, startDot);
            ret.base = path2.slice(startPart, end);
          }
          ret.ext = path2.slice(startDot, end);
        }
        ret.dir = this.dirname(path2);
        if (protocol)
          ret.dir = protocol + ret.dir;
        return ret;
      },
      sep: "/",
      delimiter: ":"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/convertToList.mjs
var convertToList;
var init_convertToList = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/convertToList.mjs"() {
    convertToList = (input, transform2, forceTransform = false) => {
      if (!Array.isArray(input)) {
        input = [input];
      }
      if (!transform2) {
        return input;
      }
      return input.map((item) => {
        if (typeof item === "string" || forceTransform) {
          return transform2(item);
        }
        return item;
      });
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/cache/Cache.mjs
var CacheClass, Cache;
var init_Cache = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/cache/Cache.mjs"() {
    init_warn();
    init_convertToList();
    CacheClass = class {
      constructor() {
        this._parsers = [];
        this._cache = /* @__PURE__ */ new Map();
        this._cacheMap = /* @__PURE__ */ new Map();
      }
      /** Clear all entries. */
      reset() {
        this._cacheMap.clear();
        this._cache.clear();
      }
      /**
       * Check if the key exists
       * @param key - The key to check
       */
      has(key) {
        return this._cache.has(key);
      }
      /**
       * Fetch entry by key
       * @param key - The key of the entry to get
       */
      get(key) {
        const result = this._cache.get(key);
        if (!result) {
          warn(`[Assets] Asset id ${key} was not found in the Cache`);
        }
        return result;
      }
      /**
       * Set a value by key or keys name
       * @param key - The key or keys to set
       * @param value - The value to store in the cache or from which cacheable assets will be derived.
       */
      set(key, value) {
        const keys = convertToList(key);
        let cacheableAssets;
        for (let i2 = 0; i2 < this.parsers.length; i2++) {
          const parser = this.parsers[i2];
          if (parser.test(value)) {
            cacheableAssets = parser.getCacheableAssets(keys, value);
            break;
          }
        }
        const cacheableMap = new Map(Object.entries(cacheableAssets || {}));
        if (!cacheableAssets) {
          keys.forEach((key2) => {
            cacheableMap.set(key2, value);
          });
        }
        const cacheKeys = [...cacheableMap.keys()];
        const cachedAssets = {
          cacheKeys,
          keys
        };
        keys.forEach((key2) => {
          this._cacheMap.set(key2, cachedAssets);
        });
        cacheKeys.forEach((key2) => {
          if (this._cache.has(key2) && this._cache.get(key2) !== value) {
            warn("[Cache] already has key:", key2);
          }
          this._cache.set(key2, cacheableMap.get(key2));
        });
      }
      /**
       * Remove entry by key
       *
       * This function will also remove any associated alias from the cache also.
       * @param key - The key of the entry to remove
       */
      remove(key) {
        if (!this._cacheMap.has(key)) {
          warn(`[Assets] Asset id ${key} was not found in the Cache`);
          return;
        }
        const cacheMap2 = this._cacheMap.get(key);
        const cacheKeys = cacheMap2.cacheKeys;
        cacheKeys.forEach((key2) => {
          this._cache.delete(key2);
        });
        cacheMap2.keys.forEach((key2) => {
          this._cacheMap.delete(key2);
        });
      }
      /** All loader parsers registered */
      get parsers() {
        return this._parsers;
      }
    };
    Cache = new CacheClass();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/NOOP.mjs
var NOOP;
var init_NOOP = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/NOOP.mjs"() {
    NOOP = () => {
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/resourceToTexture.mjs
function autoDetectSource(options = {}) {
  for (let i2 = 0; i2 < sources.length; i2++) {
    const Source = sources[i2];
    if (Source.test(options.resource)) {
      return new Source(options);
    }
  }
  throw new Error(`Could not find a source type for resource: ${options.resource}`);
}
function resourceToTexture(options = {}, skipCache = false) {
  const { resource } = options;
  if (!skipCache && Cache.has(resource)) {
    return Cache.get(resource);
  }
  const texture = new Texture({ source: autoDetectSource(options) });
  texture.on("destroy", () => {
    if (Cache.has(resource)) {
      Cache.remove(resource);
    }
  });
  if (!skipCache) {
    Cache.set(resource, texture);
  }
  return texture;
}
var sources;
var init_resourceToTexture = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/resourceToTexture.mjs"() {
    init_Cache();
    init_Extensions();
    init_Texture();
    sources = [];
    extensions.handleByList(ExtensionType.TextureSource, sources);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs
function createIdFromString(value, groupId) {
  let id = idHash[value];
  if (id === void 0) {
    if (idCounts[groupId] === void 0) {
      idCounts[groupId] = 1;
    }
    idHash[value] = id = idCounts[groupId]++;
  }
  return id;
}
var idCounts, idHash;
var init_createIdFromString = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs"() {
    idCounts = /* @__PURE__ */ Object.create(null);
    idHash = /* @__PURE__ */ Object.create(null);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs
var _TextureStyle, TextureStyle;
var init_TextureStyle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs"() {
    init_eventemitter3();
    init_deprecation();
    init_createIdFromString();
    _TextureStyle = class extends eventemitter3_default {
      constructor(options = {}) {
        super();
        this.resourceType = "textureSampler";
        this.touched = 0;
        this._maxAnisotropy = 1;
        options = { ..._TextureStyle.defaultOptions, ...options };
        this.addressMode = options.addressMode;
        this.addressModeU = options.addressModeU ?? this.addressModeU;
        this.addressModeV = options.addressModeV ?? this.addressModeV;
        this.addressModeW = options.addressModeW ?? this.addressModeW;
        this.scaleMode = options.scaleMode;
        this.magFilter = options.magFilter ?? this.magFilter;
        this.minFilter = options.minFilter ?? this.minFilter;
        this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;
        this.lodMinClamp = options.lodMinClamp;
        this.lodMaxClamp = options.lodMaxClamp;
        this.compare = options.compare;
        this.maxAnisotropy = options.maxAnisotropy ?? 1;
      }
      set addressMode(value) {
        this.addressModeU = value;
        this.addressModeV = value;
        this.addressModeW = value;
      }
      get addressMode() {
        return this.addressModeU;
      }
      set wrapMode(value) {
        deprecation("8", "TextureStyle.wrapMode is now TextureStyle.addressMode");
        this.addressMode = value;
      }
      get wrapMode() {
        return this.addressMode;
      }
      set scaleMode(value) {
        this.magFilter = value;
        this.minFilter = value;
        this.mipmapFilter = value;
      }
      get scaleMode() {
        return this.magFilter;
      }
      set maxAnisotropy(value) {
        this._maxAnisotropy = Math.min(value, 16);
        if (this._maxAnisotropy > 1) {
          this.scaleMode = "linear";
        }
      }
      get maxAnisotropy() {
        return this._maxAnisotropy;
      }
      // TODO - move this to WebGL?
      get resourceId() {
        return this._resourceId || this._generateResourceId();
      }
      update() {
        this.emit("change", this);
        this._resourceId = null;
      }
      _generateResourceId() {
        const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
        this._resourceId = createIdFromString(bigKey, "sampler");
        return this._resourceId;
      }
      /** Destroys the style */
      destroy() {
        this.emit("destroy", this);
        this.removeAllListeners();
      }
    };
    TextureStyle = _TextureStyle;
    TextureStyle.defaultOptions = {
      addressMode: "clamp-to-edge",
      scaleMode: "linear"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs
var _TextureSource, TextureSource;
var init_TextureSource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs"() {
    init_eventemitter3();
    init_uid();
    init_deprecation();
    init_TextureStyle();
    _TextureSource = class extends eventemitter3_default {
      // eslint-disable-next-line @typescript-eslint/no-parameter-properties
      constructor(options = {}) {
        super();
        this.options = options;
        this.uid = uid("textureSource");
        this.resourceType = "textureSource";
        this.resourceId = uid("textureResource");
        this.uploadMethodId = "unknown";
        this._resolution = 1;
        this.pixelWidth = 1;
        this.pixelHeight = 1;
        this.width = 1;
        this.height = 1;
        this.sampleCount = 1;
        this.mipLevelCount = 1;
        this.autoGenerateMipmaps = false;
        this.format = "rgba8unorm-srgb";
        this.dimension = "2d";
        this.antialias = false;
        this.depthStencil = true;
        this.touched = 0;
        this._batchTick = -1;
        this._textureBindLocation = -1;
        options = { ..._TextureSource.defaultOptions, ...options };
        this.resource = options.resource;
        this._resolution = options.resolution;
        if (options.width) {
          this.pixelWidth = options.width * this._resolution;
        } else {
          this.pixelWidth = options.resource?.width ?? 1;
        }
        if (options.height) {
          this.pixelHeight = options.height * this._resolution;
        } else {
          this.pixelHeight = options.resource?.height ?? 1;
        }
        this.width = this.pixelWidth / this._resolution;
        this.height = this.pixelHeight / this._resolution;
        this.format = options.format;
        this.dimension = options.dimensions;
        this.mipLevelCount = options.mipLevelCount;
        this.autoGenerateMipmaps = options.autoGenerateMipmaps;
        this.sampleCount = options.sampleCount;
        this.antialias = options.antialias;
        this.alphaMode = options.alphaMode;
        const style = options.style ?? {};
        this.style = style instanceof TextureStyle ? style : new TextureStyle(style);
        this.destroyed = false;
      }
      get source() {
        return this;
      }
      get style() {
        return this._style;
      }
      set style(value) {
        if (this.style === value)
          return;
        this._style?.off("change", this._onStyleChange, this);
        this._style = value;
        this._style?.on("change", this._onStyleChange, this);
        this._onStyleChange();
      }
      _onStyleChange() {
        this.emit("styleChange", this);
      }
      update() {
        this.emit("update", this);
      }
      /** Destroys this texture source */
      destroy() {
        this.destroyed = true;
        this.emit("destroy", this);
        if (this._style) {
          this._style.destroy();
          this._style = null;
        }
        this.uploadMethodId = null;
        this.resource = null;
        this.removeAllListeners();
      }
      unload() {
        this.resourceId++;
        this.emit("change", this);
        this.emit("unload", this);
      }
      get resourceWidth() {
        const { resource } = this;
        return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;
      }
      get resourceHeight() {
        const { resource } = this;
        return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;
      }
      get resolution() {
        return this._resolution;
      }
      set resolution(resolution) {
        if (this._resolution === resolution)
          return;
        this._resolution = resolution;
        this.width = this.pixelWidth / resolution;
        this.height = this.pixelHeight / resolution;
      }
      resize(width, height, resolution) {
        resolution = resolution || this._resolution;
        width = width || this.width;
        height = height || this.height;
        const newPixelWidth = Math.round(width * resolution);
        const newPixelHeight = Math.round(height * resolution);
        this.width = newPixelWidth / resolution;
        this.height = newPixelHeight / resolution;
        this._resolution = resolution;
        if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {
          return;
        }
        this.pixelWidth = newPixelWidth;
        this.pixelHeight = newPixelHeight;
        this.emit("resize", this);
        this.resourceId++;
        this.emit("change", this);
      }
      /** @deprecated since 8.0.0 */
      set wrapMode(value) {
        deprecation(v8_0_0, "TextureSource.wrapMode property has been deprecated. Use TextureSource.style.addressMode instead.");
        this._style.wrapMode = value;
      }
      /** @deprecated since 8.0.0 */
      get wrapMode() {
        deprecation(v8_0_0, "TextureSource.wrapMode property has been deprecated. Use TextureSource.style.addressMode instead.");
        return this._style.wrapMode;
      }
      /** @deprecated since 8.0.0 */
      set scaleMode(value) {
        deprecation(v8_0_0, "TextureSource.scaleMode property has been deprecated. Use TextureSource.style.scaleMode instead.");
        this._style.scaleMode = value;
      }
      /** @deprecated since 8.0.0 */
      get scaleMode() {
        deprecation(v8_0_0, "TextureSource.scaleMode property has been deprecated. Use TextureSource.style.scaleMode instead.");
        return this._style.scaleMode;
      }
      static test(_resource) {
        throw new Error("Unimplemented");
      }
    };
    TextureSource = _TextureSource;
    TextureSource.defaultOptions = {
      resolution: 1,
      format: "bgra8unorm",
      alphaMode: "no-premultiply-alpha",
      dimensions: "2d",
      mipLevelCount: 1,
      autoGenerateMipmaps: false,
      sampleCount: 1,
      antialias: false,
      style: {}
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/matrix/groupD8.mjs
function init() {
  for (let i2 = 0; i2 < 16; i2++) {
    const row = [];
    rotationCayley.push(row);
    for (let j3 = 0; j3 < 16; j3++) {
      const _ux = signum(ux[i2] * ux[j3] + vx[i2] * uy[j3]);
      const _uy = signum(uy[i2] * ux[j3] + vy[i2] * uy[j3]);
      const _vx = signum(ux[i2] * vx[j3] + vx[i2] * vy[j3]);
      const _vy = signum(uy[i2] * vx[j3] + vy[i2] * vy[j3]);
      for (let k3 = 0; k3 < 16; k3++) {
        if (ux[k3] === _ux && uy[k3] === _uy && vx[k3] === _vx && vy[k3] === _vy) {
          row.push(k3);
          break;
        }
      }
    }
  }
  for (let i2 = 0; i2 < 16; i2++) {
    const mat = new Matrix();
    mat.set(ux[i2], uy[i2], vx[i2], vy[i2], 0, 0);
    rotationMatrices.push(mat);
  }
}
var ux, uy, vx, vy, rotationCayley, rotationMatrices, signum, groupD8;
var init_groupD8 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/matrix/groupD8.mjs"() {
    init_Matrix();
    ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
    uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
    vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
    vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
    rotationCayley = [];
    rotationMatrices = [];
    signum = Math.sign;
    init();
    groupD8 = {
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 0°       | East      |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      E: 0,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 45°↻     | Southeast |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      SE: 1,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 90°↻     | South     |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      S: 2,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 135°↻    | Southwest |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      SW: 3,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 180°     | West      |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      W: 4,
      /**
       * | Rotation    | Direction    |
       * |-------------|--------------|
       * | -135°/225°↻ | Northwest    |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      NW: 5,
      /**
       * | Rotation    | Direction    |
       * |-------------|--------------|
       * | -90°/270°↻  | North        |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      N: 6,
      /**
       * | Rotation    | Direction    |
       * |-------------|--------------|
       * | -45°/315°↻  | Northeast    |
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      NE: 7,
      /**
       * Reflection about Y-axis.
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      MIRROR_VERTICAL: 8,
      /**
       * Reflection about the main diagonal.
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      MAIN_DIAGONAL: 10,
      /**
       * Reflection about X-axis.
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      MIRROR_HORIZONTAL: 12,
      /**
       * Reflection about reverse diagonal.
       * @memberof groupD8
       * @constant {GD8Symmetry}
       */
      REVERSE_DIAGONAL: 14,
      /**
       * @memberof groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The X-component of the U-axis
       *    after rotating the axes.
       */
      uX: (ind) => ux[ind],
      /**
       * @memberof groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The Y-component of the U-axis
       *    after rotating the axes.
       */
      uY: (ind) => uy[ind],
      /**
       * @memberof groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The X-component of the V-axis
       *    after rotating the axes.
       */
      vX: (ind) => vx[ind],
      /**
       * @memberof groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The Y-component of the V-axis
       *    after rotating the axes.
       */
      vY: (ind) => vy[ind],
      /**
       * @memberof groupD8
       * @param {GD8Symmetry} rotation - symmetry whose opposite
       *   is needed. Only rotations have opposite symmetries while
       *   reflections don't.
       * @returns {GD8Symmetry} The opposite symmetry of `rotation`
       */
      inv: (rotation) => {
        if (rotation & 8) {
          return rotation & 15;
        }
        return -rotation & 7;
      },
      /**
       * Composes the two D8 operations.
       *
       * Taking `^` as reflection:
       *
       * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
       * |-------|-----|-----|-----|-----|------|-------|-------|-------|
       * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
       * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
       * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
       * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
       * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
       * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
       * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
       * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
       *
       * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
       * @memberof groupD8
       * @param {GD8Symmetry} rotationSecond - Second operation, which
       *   is the row in the above cayley table.
       * @param {GD8Symmetry} rotationFirst - First operation, which
       *   is the column in the above cayley table.
       * @returns {GD8Symmetry} Composed operation
       */
      add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
      /**
       * Reverse of `add`.
       * @memberof groupD8
       * @param {GD8Symmetry} rotationSecond - Second operation
       * @param {GD8Symmetry} rotationFirst - First operation
       * @returns {GD8Symmetry} Result
       */
      sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
      /**
       * Adds 180 degrees to rotation, which is a commutative
       * operation.
       * @memberof groupD8
       * @param {number} rotation - The number to rotate.
       * @returns {number} Rotated number
       */
      rotate180: (rotation) => rotation ^ 4,
      /**
       * Checks if the rotation angle is vertical, i.e. south
       * or north. It doesn't work for reflections.
       * @memberof groupD8
       * @param {GD8Symmetry} rotation - The number to check.
       * @returns {boolean} Whether or not the direction is vertical
       */
      isVertical: (rotation) => (rotation & 3) === 2,
      // rotation % 4 === 2
      /**
       * Approximates the vector `V(dx,dy)` into one of the
       * eight directions provided by `groupD8`.
       * @memberof groupD8
       * @param {number} dx - X-component of the vector
       * @param {number} dy - Y-component of the vector
       * @returns {GD8Symmetry} Approximation of the vector into
       *  one of the eight symmetries.
       */
      byDirection: (dx, dy) => {
        if (Math.abs(dx) * 2 <= Math.abs(dy)) {
          if (dy >= 0) {
            return groupD8.S;
          }
          return groupD8.N;
        } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
          if (dx > 0) {
            return groupD8.E;
          }
          return groupD8.W;
        } else if (dy > 0) {
          if (dx > 0) {
            return groupD8.SE;
          }
          return groupD8.SW;
        } else if (dx > 0) {
          return groupD8.NE;
        }
        return groupD8.NW;
      },
      /**
       * Helps sprite to compensate texture packer rotation.
       * @memberof groupD8
       * @param {Matrix} matrix - sprite world matrix
       * @param {GD8Symmetry} rotation - The rotation factor to use.
       * @param {number} tx - sprite anchoring
       * @param {number} ty - sprite anchoring
       */
      matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
        const mat = rotationMatrices[groupD8.inv(rotation)];
        mat.tx = tx;
        mat.ty = ty;
        matrix.append(mat);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureLayout.mjs
var TextureLayout;
var init_TextureLayout = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureLayout.mjs"() {
    init_eventemitter3();
    init_groupD8();
    init_Rectangle();
    TextureLayout = class extends eventemitter3_default {
      constructor(options = {}) {
        super();
        this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };
        this.frame = options.frame || new Rectangle(0, 0, 1, 1);
        this.orig = options.orig || this.frame;
        this.rotate = options.rotate ?? 0;
        this.trim = options.trim;
        this.defaultAnchor = options.defaultAnchor;
        this.defaultBorders = options.defaultBorders;
        this.updateUvs();
      }
      updateUvs() {
        const uvs = this.uvs;
        const frame = this.frame;
        let rotate = this.rotate;
        if (rotate) {
          const w2 = frame.width / 2;
          const h2 = frame.height / 2;
          const cX = frame.x + w2;
          const cY = frame.y + h2;
          rotate = groupD8.add(rotate, groupD8.NW);
          uvs.x0 = cX + w2 * groupD8.uX(rotate);
          uvs.y0 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          uvs.x1 = cX + w2 * groupD8.uX(rotate);
          uvs.y1 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          uvs.x2 = cX + w2 * groupD8.uX(rotate);
          uvs.y2 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          uvs.x3 = cX + w2 * groupD8.uX(rotate);
          uvs.y3 = cY + h2 * groupD8.uY(rotate);
        } else {
          uvs.x0 = frame.x;
          uvs.y0 = frame.y;
          uvs.x1 = frame.x + frame.width;
          uvs.y1 = frame.y;
          uvs.x2 = frame.x + frame.width;
          uvs.y2 = frame.y + frame.height;
          uvs.x3 = frame.x;
          uvs.y3 = frame.y + frame.height;
        }
      }
      update() {
        this.updateUvs();
        this.emit("update", this);
      }
      /** Destroys this TextureLayout */
      destroy() {
        this.emit("destroy", this);
        this.removeAllListeners();
        this.frame = null;
        this.orig = null;
        this.trim = null;
        this.defaultAnchor = null;
        this.uvs = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs
var tempMat, TextureMatrix;
var init_TextureMatrix = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs"() {
    init_Matrix();
    tempMat = new Matrix();
    TextureMatrix = class {
      /**
       * @param texture - observed texture
       * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
       */
      constructor(texture, clampMargin) {
        this.mapCoord = new Matrix();
        this.uClampFrame = new Float32Array(4);
        this.uClampOffset = new Float32Array(2);
        this._textureID = -1;
        this._updateID = 0;
        this.clampOffset = 0;
        this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
        this.isSimple = false;
        this.texture = texture;
      }
      /** Texture property. */
      get texture() {
        return this._texture;
      }
      set texture(value) {
        if (this.texture === value)
          return;
        this._texture?.removeListener("update", this.update, this);
        this._texture = value;
        this._texture.addListener("update", this.update, this);
        this.update();
      }
      /**
       * Multiplies uvs array to transform
       * @param uvs - mesh uvs
       * @param [out=uvs] - output
       * @returns - output
       */
      multiplyUvs(uvs, out2) {
        if (out2 === void 0) {
          out2 = uvs;
        }
        const mat = this.mapCoord;
        for (let i2 = 0; i2 < uvs.length; i2 += 2) {
          const x3 = uvs[i2];
          const y2 = uvs[i2 + 1];
          out2[i2] = x3 * mat.a + y2 * mat.c + mat.tx;
          out2[i2 + 1] = x3 * mat.b + y2 * mat.d + mat.ty;
        }
        return out2;
      }
      update() {
        const tex = this._texture;
        this._updateID++;
        const uvs = tex.layout.uvs;
        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
        const orig = tex.layout.orig;
        const trim = tex.layout.trim;
        if (trim) {
          tempMat.set(
            orig.width / trim.width,
            0,
            0,
            orig.height / trim.height,
            -trim.x / trim.width,
            -trim.y / trim.height
          );
          this.mapCoord.append(tempMat);
        }
        const texBase = tex.source;
        const frame = this.uClampFrame;
        const margin = this.clampMargin / texBase._resolution;
        const offset = this.clampOffset;
        frame[0] = (tex.frameX + margin + offset) / texBase.width;
        frame[1] = (tex.frameY + margin + offset) / texBase.height;
        frame[2] = (tex.frameX + tex.frameWidth - margin + offset) / texBase.width;
        frame[3] = (tex.frameY + tex.frameHeight - margin + offset) / texBase.height;
        this.uClampOffset[0] = offset / texBase.pixelWidth;
        this.uClampOffset[1] = offset / texBase.pixelHeight;
        this.isSimple = tex.frameWidth === texBase.width && tex.frameHeight === texBase.height && tex.layout.rotate === 0;
        return true;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs
var Texture;
var init_Texture = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"() {
    init_eventemitter3();
    init_Cache();
    init_uid();
    init_deprecation();
    init_NOOP();
    init_resourceToTexture();
    init_TextureSource();
    init_TextureLayout();
    init_TextureMatrix();
    Texture = class _Texture extends eventemitter3_default {
      constructor({ source: source3, layout, label, frame } = {}) {
        super();
        this.id = uid("texture");
        this.styleSourceKey = 0;
        this.label = label;
        this.source = source3?.source ?? new TextureSource();
        layout = layout instanceof TextureLayout ? layout : new TextureLayout(layout);
        if (frame) {
          const { width, height } = this._source;
          layout.frame.x = frame.x / width;
          layout.frame.y = frame.y / height;
          layout.frame.width = frame.width / width;
          layout.frame.height = frame.height / height;
          layout.updateUvs();
        }
        this.layout = layout;
        this.destroyed = false;
      }
      static from(id, skipCache = false) {
        if (typeof id === "string") {
          return Cache.get(id);
        } else if (id instanceof TextureSource) {
          return new _Texture({ source: id });
        }
        return resourceToTexture(id, skipCache);
      }
      set source(value) {
        if (this._source) {
          this._source.off("resize", this.onUpdate, this);
        }
        this._source = value;
        value.on("resize", this.onUpdate, this);
        this.emit("update", this);
      }
      get source() {
        return this._source;
      }
      get layout() {
        return this._layout;
      }
      set layout(value) {
        this._layout?.off("update", this.onUpdate, this);
        this._layout = value;
        value.on("update", this.onUpdate, this);
        this.emit("update", this);
      }
      get textureMatrix() {
        if (!this._textureMatrix) {
          this._textureMatrix = new TextureMatrix(this);
        }
        return this._textureMatrix;
      }
      set frameWidth(value) {
        this._layout.frame.width = value / this._source.width;
      }
      get frameWidth() {
        return this._source.pixelWidth / this._source._resolution * this._layout.frame.width;
      }
      set frameHeight(value) {
        this._layout.frame.height = value / this._source.height;
      }
      get frameHeight() {
        return this._source.pixelHeight / this._source._resolution * this._layout.frame.height;
      }
      set frameX(value) {
        if (value === 0) {
          this._layout.frame.x = 0;
          return;
        }
        this._layout.frame.x = this._source.width / value;
      }
      get frameX() {
        return this._source.width * this._layout.frame.x;
      }
      set frameY(value) {
        if (value === 0) {
          this._layout.frame.y = 0;
          return;
        }
        this._layout.frame.y = this._source.height / value;
      }
      get frameY() {
        return this._source.height * this._layout.frame.y;
      }
      /** The width of the Texture in pixels. */
      get width() {
        return this._source.width * this._layout.orig.width;
      }
      /** The height of the Texture in pixels. */
      get height() {
        return this._source.height * this._layout.orig.height;
      }
      /**
       * Destroys this texture
       * @param destroySource - Destroy the source when the texture is destroyed.
       */
      destroy(destroySource = false) {
        if (this._layout) {
          this._layout.destroy();
          this._layout = null;
        }
        if (this._source) {
          if (destroySource) {
            this._source.destroy();
            this._source = null;
          }
        }
        this._textureMatrix = null;
        this.destroyed = true;
        this.emit("destroy", this);
        this.removeAllListeners();
      }
      /**
       * @internal
       */
      onUpdate() {
        this.emit("update", this);
      }
      /** @deprecated since 8.0.0 */
      get baseTexture() {
        deprecation(v8_0_0, "Texture.baseTexture is now Texture.source");
        return this._source;
      }
    };
    Texture.EMPTY = new Texture({});
    Texture.EMPTY.label = "EMPTY";
    Texture.EMPTY.destroy = NOOP;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/AbstractBitmapFont.mjs
var AbstractBitmapFont;
var init_AbstractBitmapFont = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/AbstractBitmapFont.mjs"() {
    init_eventemitter3();
    init_deprecation();
    AbstractBitmapFont = class extends eventemitter3_default {
      constructor() {
        super(...arguments);
        this.chars = /* @__PURE__ */ Object.create(null);
        this.lineHeight = 0;
        this.fontFamily = "";
        this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };
        this.baseLineOffset = 0;
        this.distanceField = { type: "none", range: 0 };
        this.pages = [];
        this.baseMeasurementFontSize = 100;
        this.baseRenderedFontSize = 100;
      }
      /**
       * @deprecated since 8.0.0
       * The name of the font face.
       */
      get font() {
        deprecation(v8_0_0, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");
        return this.fontFamily;
      }
      /** @deprecated since 8.0.0 */
      get pageTextures() {
        deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
        return this.pages;
      }
      /**
       * @deprecated since 8.0.0
       * The size of the font face in pixels.
       */
      get size() {
        deprecation(v8_0_0, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");
        return this.fontMetrics.fontSize;
      }
      /**
       * @deprecated since 8.0.0
       * The kind of distance field for this font or "none".
       */
      get distanceFieldRange() {
        deprecation(v8_0_0, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");
        return this.distanceField.range;
      }
      /**
       * @deprecated since 8.0.0
       * The range of the distance field in pixels.
       */
      get distanceFieldType() {
        deprecation(v8_0_0, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");
        return this.distanceField.type;
      }
      destroy() {
        this.emit("destroy", this);
        this.removeAllListeners();
        for (const i2 in this.chars) {
          this.chars[i2].texture.destroy();
        }
        this.chars = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/BitmapFont.mjs
var BitmapFont;
var init_BitmapFont = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/BitmapFont.mjs"() {
    init_Rectangle();
    init_Texture();
    init_AbstractBitmapFont();
    BitmapFont = class extends AbstractBitmapFont {
      constructor(options) {
        super();
        const { textures, data } = options;
        Object.keys(data.pages).forEach((key) => {
          const pageData = data.pages[parseInt(key, 10)];
          const texture = textures[pageData.id];
          this.pages.push({ texture });
        });
        Object.keys(data.chars).forEach((key) => {
          const charData = data.chars[key];
          const textureSource = textures[charData.page].source;
          const frame = new Rectangle(
            charData.x / textureSource.width,
            charData.y / textureSource.height,
            charData.width / textureSource.width,
            charData.height / textureSource.height
          );
          const texture = new Texture({
            source: textureSource,
            layout: {
              frame
            }
          });
          this.chars[key] = {
            id: key.codePointAt(0),
            xOffset: charData.xOffset,
            yOffset: charData.yOffset,
            xAdvance: charData.xAdvance,
            kerning: charData.kerning ?? {},
            texture
          };
        });
        this.baseRenderedFontSize = data.fontSize;
        const writable = this;
        writable.baseMeasurementFontSize = data.fontSize;
        writable.fontMetrics = {
          ascent: 0,
          descent: 0,
          fontSize: data.fontSize
        };
        writable.baseLineOffset = data.baseLineOffset;
        writable.lineHeight = data.lineHeight;
        writable.fontFamily = data.fontFamily;
        writable.distanceField = data.distanceField ?? {
          type: "none",
          range: 0
        };
      }
      destroy() {
        super.destroy();
        for (let i2 = 0; i2 < this.pages.length; i2++) {
          const { texture } = this.pages[i2];
          texture.destroy(true);
        }
        this.pages = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/asset/textFormat.mjs
var TextFormat;
var init_textFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/asset/textFormat.mjs"() {
    TextFormat = {
      test(data) {
        return typeof data === "string" && data.startsWith("info face=");
      },
      parse(txt) {
        const items = txt.match(/^[a-z]+\s+.+$/gm);
        const rawData = {
          info: [],
          common: [],
          page: [],
          char: [],
          chars: [],
          kerning: [],
          kernings: [],
          distanceField: []
        };
        for (const i2 in items) {
          const name = items[i2].match(/^[a-z]+/gm)[0];
          const attributeList = items[i2].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
          const itemData = {};
          for (const i22 in attributeList) {
            const split = attributeList[i22].split("=");
            const key = split[0];
            const strValue = split[1].replace(/"/gm, "");
            const floatValue = parseFloat(strValue);
            const value = isNaN(floatValue) ? strValue : floatValue;
            itemData[key] = value;
          }
          rawData[name].push(itemData);
        }
        const font = {
          chars: {},
          pages: [],
          lineHeight: 0,
          fontSize: 0,
          fontFamily: "",
          distanceField: null,
          baseLineOffset: 0
        };
        const [info] = rawData.info;
        const [common] = rawData.common;
        const [distanceField] = rawData.distanceField ?? [];
        if (distanceField) {
          font.distanceField = {
            range: parseInt(distanceField.distanceRange, 10),
            type: distanceField.fieldType
          };
        }
        font.fontSize = parseInt(info.size, 10);
        font.fontFamily = info.face;
        font.lineHeight = parseInt(common.lineHeight, 10);
        const page = rawData.page;
        for (let i2 = 0; i2 < page.length; i2++) {
          font.pages.push({
            id: parseInt(page[i2].id, 10) || 0,
            file: page[i2].file
          });
        }
        const map2 = {};
        font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);
        const char = rawData.char;
        for (let i2 = 0; i2 < char.length; i2++) {
          const charNode = char[i2];
          const id = parseInt(charNode.id, 10);
          let letter = charNode.letter ?? charNode.char;
          if (letter === "space")
            letter = " ";
          map2[id] = letter;
          font.chars[letter] = {
            id,
            // texture deets..
            page: parseInt(charNode.page, 10) || 0,
            x: parseInt(charNode.x, 10),
            y: parseInt(charNode.y, 10),
            width: parseInt(charNode.width, 10),
            height: parseInt(charNode.height, 10),
            xOffset: parseInt(charNode.xoffset, 10),
            yOffset: parseInt(charNode.yoffset, 10),
            xAdvance: parseInt(charNode.xadvance, 10),
            kerning: {}
          };
        }
        const kerning = rawData.kerning || [];
        for (let i2 = 0; i2 < kerning.length; i2++) {
          const first = parseInt(kerning[i2].first, 10);
          const second = parseInt(kerning[i2].second, 10);
          const amount = parseInt(kerning[i2].amount, 10);
          font.chars[map2[second]].kerning[map2[first]] = amount;
        }
        return font;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/asset/xmlFormat.mjs
var XMLFormat;
var init_xmlFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/asset/xmlFormat.mjs"() {
    XMLFormat = {
      test(data) {
        const xml = data;
        return typeof xml !== "string" && "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
      },
      parse(xml) {
        const data = {
          chars: {},
          pages: [],
          lineHeight: 0,
          fontSize: 0,
          fontFamily: "",
          distanceField: null,
          baseLineOffset: 0
        };
        const info = xml.getElementsByTagName("info")[0];
        const common = xml.getElementsByTagName("common")[0];
        const distanceField = xml.getElementsByTagName("distanceField")[0];
        if (distanceField) {
          data.distanceField = {
            type: distanceField.getAttribute("fieldType"),
            range: parseInt(distanceField.getAttribute("distanceRange"), 10)
          };
        }
        const page = xml.getElementsByTagName("page");
        const char = xml.getElementsByTagName("char");
        const kerning = xml.getElementsByTagName("kerning");
        data.fontSize = parseInt(info.getAttribute("size"), 10);
        data.fontFamily = info.getAttribute("face");
        data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10);
        for (let i2 = 0; i2 < page.length; i2++) {
          data.pages.push({
            id: parseInt(page[i2].getAttribute("id"), 10) || 0,
            file: page[i2].getAttribute("file")
          });
        }
        const map2 = {};
        data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute("base"), 10);
        for (let i2 = 0; i2 < char.length; i2++) {
          const charNode = char[i2];
          const id = parseInt(charNode.getAttribute("id"), 10);
          let letter = charNode.getAttribute("letter") ?? charNode.getAttribute("char");
          if (letter === "space")
            letter = " ";
          map2[id] = letter;
          data.chars[letter] = {
            id,
            // texture deets..
            page: parseInt(charNode.getAttribute("page"), 10) || 0,
            x: parseInt(charNode.getAttribute("x"), 10),
            y: parseInt(charNode.getAttribute("y"), 10),
            width: parseInt(charNode.getAttribute("width"), 10),
            height: parseInt(charNode.getAttribute("height"), 10),
            // render deets..
            xOffset: parseInt(charNode.getAttribute("xoffset"), 10),
            yOffset: parseInt(charNode.getAttribute("yoffset"), 10),
            // + baseLineOffset,
            xAdvance: parseInt(charNode.getAttribute("xadvance"), 10),
            kerning: {}
          };
        }
        for (let i2 = 0; i2 < kerning.length; i2++) {
          const first = parseInt(kerning[i2].getAttribute("first"), 10);
          const second = parseInt(kerning[i2].getAttribute("second"), 10);
          const amount = parseInt(kerning[i2].getAttribute("amount"), 10);
          data.chars[map2[second]].kerning[map2[first]] = amount;
        }
        return data;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/asset/xmlStringFormat.mjs
var XMLStringFormat;
var init_xmlStringFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/asset/xmlStringFormat.mjs"() {
    init_adapter();
    init_xmlFormat();
    XMLStringFormat = {
      test(data) {
        if (typeof data === "string" && data.includes("<font>")) {
          return XMLFormat.test(DOMAdapter.get().parseXML(data));
        }
        return false;
      },
      parse(data) {
        return XMLFormat.parse(DOMAdapter.get().parseXML(data));
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/asset/loadBitmapFont.mjs
var validExtensions, bitmapFontCachePlugin, xmlBitmapFontLoader;
var init_loadBitmapFont = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/asset/loadBitmapFont.mjs"() {
    init_LoaderParser();
    init_copySearchParams();
    init_Extensions();
    init_adapter();
    init_path();
    init_BitmapFont();
    init_textFormat();
    init_xmlStringFormat();
    validExtensions = [".xml", ".fnt"];
    bitmapFontCachePlugin = {
      extension: ExtensionType.CacheParser,
      test: (asset) => asset instanceof BitmapFont,
      getCacheableAssets(keys, asset) {
        const out2 = {};
        keys.forEach((key) => {
          out2[key] = asset;
        });
        out2[asset.fontFamily] = asset;
        return out2;
      }
    };
    xmlBitmapFontLoader = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Normal
      },
      test(url) {
        return validExtensions.includes(path.extname(url).toLowerCase());
      },
      async testParse(data) {
        return TextFormat.test(data) || XMLStringFormat.test(data);
      },
      async parse(asset, data, loader) {
        const bitmapFontData = TextFormat.test(asset) ? TextFormat.parse(asset) : XMLStringFormat.parse(asset);
        const { src } = data;
        const { pages } = bitmapFontData;
        const textureUrls = [];
        for (let i2 = 0; i2 < pages.length; ++i2) {
          const pageFile = pages[i2].file;
          let imagePath = path.join(path.dirname(src), pageFile);
          imagePath = copySearchParams(imagePath, src);
          textureUrls.push(imagePath);
        }
        const loadedTextures = await loader.load(textureUrls);
        const textures = textureUrls.map((url) => loadedTextures[url]);
        const bitmapFont = new BitmapFont({
          data: bitmapFontData,
          textures
        });
        return bitmapFont;
      },
      async load(url, _options) {
        const response = await DOMAdapter.get().fetch(url);
        return await response.text();
      },
      unload(bitmapFont) {
        bitmapFont.destroy();
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs
var cacheTextureArray;
var init_cacheTextureArray = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs"() {
    init_Extensions();
    init_Texture();
    cacheTextureArray = {
      extension: ExtensionType.CacheParser,
      test: (asset) => Array.isArray(asset) && asset.every((t2) => t2 instanceof Texture),
      getCacheableAssets: (keys, asset) => {
        const out2 = {};
        keys.forEach((key) => {
          asset.forEach((item, i2) => {
            out2[key + (i2 === 0 ? "" : i2 + 1)] = item;
          });
        });
        return out2;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs
async function testImageFormat(imageData) {
  if ("Image" in globalThis) {
    return new Promise((resolve) => {
      const image = new Image();
      image.onload = () => {
        resolve(true);
      };
      image.onerror = () => {
        resolve(false);
      };
      image.src = imageData;
    });
  }
  if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
    try {
      const blob = await (await fetch(imageData)).blob();
      await createImageBitmap(blob);
    } catch (e2) {
      return false;
    }
    return true;
  }
  return false;
}
var init_testImageFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs
var detectAvif;
var init_detectAvif = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs"() {
    init_Extensions();
    init_testImageFormat();
    detectAvif = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 1
      },
      test: async () => testImageFormat(
        // eslint-disable-next-line max-len
        "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
      ),
      add: async (formats) => [...formats, "avif"],
      remove: async (formats) => formats.filter((f2) => f2 !== "avif")
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs
var imageFormats, detectDefaults;
var init_detectDefaults = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs"() {
    init_Extensions();
    imageFormats = ["png", "jpg", "jpeg"];
    detectDefaults = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: -1
      },
      test: () => Promise.resolve(true),
      add: async (formats) => [...formats, ...imageFormats],
      remove: async (formats) => formats.filter((f2) => !imageFormats.includes(f2))
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs
function testVideoFormat(mimeType) {
  if (inWorker) {
    return false;
  }
  const video = document.createElement("video");
  return video.canPlayType(mimeType) !== "";
}
var inWorker;
var init_testVideoFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs"() {
    inWorker = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs
var detectMp4;
var init_detectMp4 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs"() {
    init_Extensions();
    init_testVideoFormat();
    detectMp4 = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 0
      },
      test: async () => testVideoFormat("video/mp4"),
      add: async (formats) => [...formats, "mp4", "m4v"],
      remove: async (formats) => formats.filter((f2) => f2 !== "mp4" && f2 !== "m4v")
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs
var detectOgv;
var init_detectOgv = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs"() {
    init_Extensions();
    init_testVideoFormat();
    detectOgv = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 0
      },
      test: async () => testVideoFormat("video/ogg"),
      add: async (formats) => [...formats, "ogv"],
      remove: async (formats) => formats.filter((f2) => f2 !== "ogv")
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs
var detectWebm;
var init_detectWebm = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs"() {
    init_Extensions();
    init_testVideoFormat();
    detectWebm = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 0
      },
      test: async () => testVideoFormat("video/webm"),
      add: async (formats) => [...formats, "webm"],
      remove: async (formats) => formats.filter((f2) => f2 !== "webm")
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs
var detectWebp;
var init_detectWebp = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs"() {
    init_Extensions();
    init_testImageFormat();
    detectWebp = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 0
      },
      test: async () => testImageFormat(
        "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="
      ),
      add: async (formats) => [...formats, "webp"],
      remove: async (formats) => formats.filter((f2) => f2 !== "webp")
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs
function checkDataUrl(url, mimes) {
  if (Array.isArray(mimes)) {
    for (const mime of mimes) {
      if (url.startsWith(`data:${mime}`))
        return true;
    }
    return false;
  }
  return url.startsWith(`data:${mimes}`);
}
var init_checkDataUrl = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/checkExtension.mjs
function checkExtension(url, extension) {
  const tempURL = url.split("?")[0];
  const ext = path.extname(tempURL).toLowerCase();
  if (Array.isArray(extension)) {
    return extension.includes(ext);
  }
  return ext === extension;
}
var init_checkExtension = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/checkExtension.mjs"() {
    init_path();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs
var validJSONExtension, validJSONMIME, loadJson;
var init_loadJson = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs"() {
    init_Extensions();
    init_adapter();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    validJSONExtension = ".json";
    validJSONMIME = "application/json";
    loadJson = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Low
      },
      name: "loadJson",
      test(url) {
        return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);
      },
      async load(url) {
        const response = await DOMAdapter.get().fetch(url);
        const json = await response.json();
        return json;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs
var validTXTExtension, validTXTMIME, loadTxt;
var init_loadTxt = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs"() {
    init_Extensions();
    init_adapter();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    validTXTExtension = ".txt";
    validTXTMIME = "text/plain";
    loadTxt = {
      name: "loadTxt",
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Low
      },
      test(url) {
        return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);
      },
      async load(url) {
        const response = await DOMAdapter.get().fetch(url);
        const txt = await response.text();
        return txt;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs
function getFontFamilyName(url) {
  const ext = path.extname(url);
  const name = path.basename(url, ext);
  const nameWithSpaces = name.replace(/(-|_)/g, " ");
  const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
  let valid = nameTokens.length > 0;
  for (const token of nameTokens) {
    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
      valid = false;
      break;
    }
  }
  let fontFamilyName = nameTokens.join(" ");
  if (!valid) {
    fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`;
  }
  return fontFamilyName;
}
function encodeURIWhenNeeded(uri) {
  if (validURICharactersRegex.test(uri)) {
    return uri;
  }
  return encodeURI(uri);
}
var validWeights, validFontExtensions, validFontMIMEs, CSS_IDENT_TOKEN_REGEX, validURICharactersRegex, loadWebFont;
var init_loadWebFont = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs"() {
    init_Extensions();
    init_adapter();
    init_warn();
    init_path();
    init_Cache();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    validWeights = [
      "normal",
      "bold",
      "100",
      "200",
      "300",
      "400",
      "500",
      "600",
      "700",
      "800",
      "900"
    ];
    validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];
    validFontMIMEs = [
      "font/ttf",
      "font/otf",
      "font/woff",
      "font/woff2"
    ];
    CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
    validURICharactersRegex = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
    loadWebFont = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Low
      },
      name: "loadWebFont",
      test(url) {
        return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);
      },
      async load(url, options) {
        const fonts = DOMAdapter.get().getFontFaceSet();
        if (fonts) {
          const fontFaces = [];
          const name = options.data?.family ?? getFontFamilyName(url);
          const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"];
          const data = options.data ?? {};
          for (let i2 = 0; i2 < weights.length; i2++) {
            const weight = weights[i2];
            const font = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {
              ...data,
              weight
            });
            await font.load();
            fonts.add(font);
            fontFaces.push(font);
          }
          Cache.set(name, {
            url,
            fontFaces
          });
          return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
        }
        warn("[loadWebFont] FontFace API is not supported. Skipping loading font");
        return null;
      },
      unload(font) {
        (Array.isArray(font) ? font : [font]).forEach((t2) => {
          Cache.remove(t2.family);
          DOMAdapter.get().getFontFaceSet().delete(t2);
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs
function SVGToGraphicsPath(svgPath, path2) {
  const commands = svgPath.match(/[a-df-z][^a-df-z]*/gi);
  const data = svgPath.match(/[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/g)?.map(parseFloat);
  const betterCommands = [];
  commands.forEach((command) => {
    const data2 = command.match(/[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/g)?.map(parseFloat);
    const type = command[0];
    let totalInstructions = 1;
    if (data2) {
      totalInstructions = data2.length / commandSizeMap[type.toLowerCase()];
    }
    for (let i2 = 0; i2 < totalInstructions; i2++) {
      betterCommands.push(type);
    }
  });
  let dataIndex = 0;
  let lastX = 0;
  let lastY = 0;
  for (let i2 = 0; i2 < betterCommands.length; i2++) {
    const type = betterCommands[i2];
    switch (type) {
      case "M":
        lastX = data[dataIndex++];
        lastY = data[dataIndex++];
        path2.moveTo(lastX, lastY);
        break;
      case "m":
        lastX += data[dataIndex++];
        lastY += data[dataIndex++];
        path2.moveTo(lastX, lastY);
        break;
      case "H":
        lastX = data[dataIndex++];
        path2.lineTo(lastX, lastY);
        break;
      case "h":
        lastX += data[dataIndex++];
        path2.lineTo(lastX, lastY);
        break;
      case "V":
        lastY = data[dataIndex++];
        path2.lineTo(lastX, lastY);
        break;
      case "v":
        lastY += data[dataIndex++];
        path2.lineTo(lastX, lastY);
        break;
      case "L":
        lastX = data[dataIndex++];
        lastY = data[dataIndex++];
        path2.lineTo(lastX, lastY);
        break;
      case "l":
        lastX += data[dataIndex++];
        lastY += data[dataIndex++];
        path2.lineTo(lastX, lastY);
        break;
      case "C":
        lastX = data[dataIndex + 4];
        lastY = data[dataIndex + 5];
        path2.bezierCurveTo(
          data[dataIndex],
          data[dataIndex + 1],
          data[dataIndex + 2],
          data[dataIndex + 3],
          lastX,
          lastY
        );
        dataIndex += 6;
        break;
      case "c":
        path2.bezierCurveTo(
          lastX + data[dataIndex],
          lastY + data[dataIndex + 1],
          lastX + data[dataIndex + 2],
          lastY + data[dataIndex + 3],
          lastX + data[dataIndex + 4],
          lastY + data[dataIndex + 5]
        );
        lastX += data[dataIndex + 4];
        lastY += data[dataIndex + 5];
        dataIndex += 6;
        break;
      case "S":
        lastX = data[dataIndex + 2];
        lastY = data[dataIndex + 3];
        path2.bezierCurveToShort(
          data[dataIndex],
          data[dataIndex + 1],
          lastX,
          lastY
        );
        dataIndex += 4;
        break;
      case "s":
        path2.bezierCurveToShort(
          lastX + data[dataIndex],
          lastY + data[dataIndex + 1],
          lastX + data[dataIndex + 2],
          lastY + data[dataIndex + 3]
        );
        lastX += data[dataIndex + 2];
        lastY += data[dataIndex + 3];
        dataIndex += 4;
        break;
      case "Q":
        lastX = data[dataIndex + 2];
        lastY = data[dataIndex + 3];
        path2.quadraticCurveTo(
          data[dataIndex],
          data[dataIndex + 1],
          lastX,
          lastY
        );
        dataIndex += 4;
        break;
      case "q":
        path2.quadraticCurveTo(
          lastX + data[dataIndex],
          lastY + data[dataIndex + 1],
          lastX + data[dataIndex + 2],
          lastY + data[dataIndex + 3]
        );
        lastX += data[dataIndex + 2];
        lastY += data[dataIndex + 3];
        dataIndex += 4;
        break;
      case "T":
        lastX = data[dataIndex++];
        lastY = data[dataIndex++];
        path2.quadraticCurveToShort(
          lastX,
          lastY
        );
        break;
      case "t":
        lastX += data[dataIndex++];
        lastY += data[dataIndex++];
        path2.quadraticCurveToShort(
          lastX,
          lastY
        );
        break;
      case "A":
        lastX = data[dataIndex + 5];
        lastY = data[dataIndex + 6];
        path2.arcToSvg(
          data[dataIndex],
          data[dataIndex + 1],
          data[dataIndex + 2],
          data[dataIndex + 3],
          data[dataIndex + 4],
          lastX,
          lastY
        );
        dataIndex += 7;
        break;
      case "a":
        lastX += data[dataIndex + 5];
        lastY += data[dataIndex + 6];
        path2.arcToSvg(
          data[dataIndex],
          data[dataIndex + 1],
          data[dataIndex + 2],
          data[dataIndex + 3],
          data[dataIndex + 4],
          lastX,
          lastY
        );
        dataIndex += 7;
        break;
      case "Z":
      case "z":
        path2.closePath();
        break;
      default:
        warn(`Unknown SVG path command: ${type}`);
    }
  }
  return path2;
}
var commandSizeMap;
var init_SVGToGraphicsPath = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs"() {
    init_warn();
    commandSizeMap = {
      a: 7,
      c: 6,
      h: 1,
      l: 2,
      m: 2,
      q: 4,
      s: 4,
      t: 2,
      v: 1,
      z: 0
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/shapes/Circle.mjs
var Circle;
var init_Circle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/shapes/Circle.mjs"() {
    init_Rectangle();
    Circle = class _Circle {
      /**
       * @param x - The X coordinate of the center of this circle
       * @param y - The Y coordinate of the center of this circle
       * @param radius - The radius of the circle
       */
      constructor(x3 = 0, y2 = 0, radius = 0) {
        this.type = "circle";
        this.x = x3;
        this.y = y2;
        this.radius = radius;
      }
      /**
       * Creates a clone of this Circle instance
       * @returns A copy of the Circle
       */
      clone() {
        return new _Circle(this.x, this.y, this.radius);
      }
      /**
       * Checks whether the x and y coordinates given are contained within this circle
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coordinates are within this Circle
       */
      contains(x3, y2) {
        if (this.radius <= 0) {
          return false;
        }
        const r2 = this.radius * this.radius;
        let dx = this.x - x3;
        let dy = this.y - y2;
        dx *= dx;
        dy *= dy;
        return dx + dy <= r2;
      }
      /**
       * Returns the framing rectangle of the circle as a Rectangle object
       * @param out
       * @returns The framing rectangle
       */
      getBounds(out2) {
        out2 = out2 || new Rectangle();
        out2.x = this.x - this.radius;
        out2.y = this.y - this.radius;
        out2.width = this.radius * 2;
        out2.height = this.radius * 2;
        return out2;
      }
      /**
       * Copies another circle to this one.
       * @param circle - The circle to copy from.
       * @returns Returns itself.
       */
      copyFrom(circle) {
        this.x = circle.x;
        this.y = circle.y;
        this.radius = circle.radius;
        return this;
      }
      /**
       * Copies this circle to another one.
       * @param circle - The circle to copy to.
       * @returns Returns given parameter.
       */
      copyTo(circle) {
        circle.copyFrom(this);
        return circle;
      }
      toString() {
        return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs
var Ellipse;
var init_Ellipse = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs"() {
    init_Rectangle();
    Ellipse = class _Ellipse {
      /**
       * @param x - The X coordinate of the center of this ellipse
       * @param y - The Y coordinate of the center of this ellipse
       * @param halfWidth - The half width of this ellipse
       * @param halfHeight - The half height of this ellipse
       */
      constructor(x3 = 0, y2 = 0, halfWidth = 0, halfHeight = 0) {
        this.type = "ellipse";
        this.x = x3;
        this.y = y2;
        this.halfWidth = halfWidth;
        this.halfHeight = halfHeight;
      }
      /**
       * Creates a clone of this Ellipse instance
       * @returns {Ellipse} A copy of the ellipse
       */
      clone() {
        return new _Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);
      }
      /**
       * Checks whether the x and y coordinates given are contained within this ellipse
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coords are within this ellipse
       */
      contains(x3, y2) {
        if (this.halfWidth <= 0 || this.halfHeight <= 0) {
          return false;
        }
        let normx = (x3 - this.x) / this.halfWidth;
        let normy = (y2 - this.y) / this.halfHeight;
        normx *= normx;
        normy *= normy;
        return normx + normy <= 1;
      }
      /**
       * Returns the framing rectangle of the ellipse as a Rectangle object
       * @returns The framing rectangle
       */
      getBounds() {
        return new Rectangle(this.x - this.halfWidth, this.y - this.halfHeight, this.halfWidth * 2, this.halfHeight * 2);
      }
      /**
       * Copies another ellipse to this one.
       * @param ellipse - The ellipse to copy from.
       * @returns Returns itself.
       */
      copyFrom(ellipse) {
        this.x = ellipse.x;
        this.y = ellipse.y;
        this.halfWidth = ellipse.halfWidth;
        this.halfHeight = ellipse.halfHeight;
        return this;
      }
      /**
       * Copies this ellipse to another one.
       * @param ellipse - The ellipse to copy to.
       * @returns Returns given parameter.
       */
      copyTo(ellipse) {
        ellipse.copyFrom(this);
        return ellipse;
      }
      toString() {
        return `[@pixi/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/shapes/Polygon.mjs
var Polygon;
var init_Polygon = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/shapes/Polygon.mjs"() {
    init_Rectangle();
    Polygon = class _Polygon {
      /**
       * @param {PointData[]|number[]} points - This can be an array of Points
       *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
       *  the arguments passed can be all the points of the polygon e.g.
       *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
       *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
       */
      constructor(...points) {
        this.type = "polygon";
        let flat = Array.isArray(points[0]) ? points[0] : points;
        if (typeof flat[0] !== "number") {
          const p2 = [];
          for (let i2 = 0, il = flat.length; i2 < il; i2++) {
            p2.push(flat[i2].x, flat[i2].y);
          }
          flat = p2;
        }
        this.points = flat;
        this.closePath = true;
      }
      /**
       * Creates a clone of this polygon.
       * @returns - A copy of the polygon.
       */
      clone() {
        const points = this.points.slice();
        const polygon = new _Polygon(points);
        polygon.closePath = this.closePath;
        return polygon;
      }
      /**
       * Checks whether the x and y coordinates passed to this function are contained within this polygon.
       * @param x - The X coordinate of the point to test.
       * @param y - The Y coordinate of the point to test.
       * @returns - Whether the x/y coordinates are within this polygon.
       */
      contains(x3, y2) {
        let inside = false;
        const length = this.points.length / 2;
        for (let i2 = 0, j3 = length - 1; i2 < length; j3 = i2++) {
          const xi = this.points[i2 * 2];
          const yi = this.points[i2 * 2 + 1];
          const xj = this.points[j3 * 2];
          const yj = this.points[j3 * 2 + 1];
          const intersect = yi > y2 !== yj > y2 && x3 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi;
          if (intersect) {
            inside = !inside;
          }
        }
        return inside;
      }
      /**
       * Returns the framing rectangle of the polygon as a Rectangle object
       * @param out - optional rectangle to store the result
       * @returns The framing rectangle
       */
      getBounds(out2) {
        out2 = out2 || new Rectangle();
        const points = this.points;
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        for (let i2 = 0, n2 = points.length; i2 < n2; i2 += 2) {
          const x3 = points[i2];
          const y2 = points[i2 + 1];
          minX = x3 < minX ? x3 : minX;
          maxX = x3 > maxX ? x3 : maxX;
          minY = y2 < minY ? y2 : minY;
          maxY = y2 > maxY ? y2 : maxY;
        }
        out2.x = minX;
        out2.width = maxX - minX;
        out2.y = minY;
        out2.height = maxY - minY;
        return out2;
      }
      /**
       * Copies another polygon to this one.
       * @param polygon - The polygon to copy from.
       * @returns Returns itself.
       */
      copyFrom(polygon) {
        this.points = polygon.points.slice();
        this.closePath = polygon.closePath;
        return this;
      }
      /**
       * Copies this polygon to another one.
       * @param polygon - The polygon to copy to.
       * @returns Returns given parameter.
       */
      copyTo(polygon) {
        polygon.copyFrom(this);
        return polygon;
      }
      toString() {
        return `[@pixi/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
      }
      /**
       * Get the last X coordinate of the polygon
       * @readonly
       */
      get lastX() {
        return this.points[this.points.length - 2];
      }
      /**
       * Get the last Y coordinate of the polygon
       * @readonly
       */
      get lastY() {
        return this.points[this.points.length - 1];
      }
      /**
       * Get the first X coordinate of the polygon
       * @readonly
       */
      get x() {
        return this.points[this.points.length - 2];
      }
      /**
       * Get the first Y coordinate of the polygon
       * @readonly
       */
      get y() {
        return this.points[this.points.length - 1];
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs
var RoundedRectangle;
var init_RoundedRectangle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs"() {
    init_Rectangle();
    RoundedRectangle = class _RoundedRectangle {
      /**
       * @param x - The X coordinate of the upper-left corner of the rounded rectangle
       * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
       * @param width - The overall width of this rounded rectangle
       * @param height - The overall height of this rounded rectangle
       * @param radius - Controls the radius of the rounded corners
       */
      constructor(x3 = 0, y2 = 0, width = 0, height = 0, radius = 20) {
        this.type = "roundedRectangle";
        this.x = x3;
        this.y = y2;
        this.width = width;
        this.height = height;
        this.radius = radius;
      }
      /**
       * Returns the framing rectangle of the rounded rectangle as a Rectangle object
       * @param out - optional rectangle to store the result
       * @returns The framing rectangle
       */
      getBounds(out2) {
        out2 = out2 || new Rectangle();
        out2.x = this.x;
        out2.y = this.y;
        out2.width = this.width;
        out2.height = this.height;
        return out2;
      }
      /**
       * Creates a clone of this Rounded Rectangle.
       * @returns - A copy of the rounded rectangle.
       */
      clone() {
        return new _RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
      }
      /**
       * Copies another rectangle to this one.
       * @param rectangle - The rectangle to copy from.
       * @returns Returns itself.
       */
      copyFrom(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
      }
      /**
       * Copies this rectangle to another one.
       * @param rectangle - The rectangle to copy to.
       * @returns Returns given parameter.
       */
      copyTo(rectangle) {
        rectangle.copyFrom(this);
        return rectangle;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
       * @param x - The X coordinate of the point to test.
       * @param y - The Y coordinate of the point to test.
       * @returns - Whether the x/y coordinates are within this Rounded Rectangle.
       */
      contains(x3, y2) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x3 >= this.x && x3 <= this.x + this.width) {
          if (y2 >= this.y && y2 <= this.y + this.height) {
            const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
            if (y2 >= this.y + radius && y2 <= this.y + this.height - radius || x3 >= this.x + radius && x3 <= this.x + this.width - radius) {
              return true;
            }
            let dx = x3 - (this.x + radius);
            let dy = y2 - (this.y + radius);
            const radius2 = radius * radius;
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dx = x3 - (this.x + this.width - radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dy = y2 - (this.y + this.height - radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dx = x3 - (this.x + radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
          }
        }
        return false;
      }
      toString() {
        return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs
function buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY) {
  const scale3 = 1;
  let distanceTolerance = PATH_DISTANCE_EPSILON / scale3;
  distanceTolerance *= distanceTolerance;
  begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);
  return points;
}
function begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {
  recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);
  points.push(eX, eY);
}
function recursive(x1, y1, x22, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
  if (level > RECURSION_LIMIT) {
    return;
  }
  const pi = Math.PI;
  const x12 = (x1 + x22) / 2;
  const y12 = (y1 + y2) / 2;
  const x23 = (x22 + x3) / 2;
  const y23 = (y2 + y3) / 2;
  const x34 = (x3 + x4) / 2;
  const y34 = (y3 + y4) / 2;
  const x123 = (x12 + x23) / 2;
  const y123 = (y12 + y23) / 2;
  const x234 = (x23 + x34) / 2;
  const y234 = (y23 + y34) / 2;
  const x1234 = (x123 + x234) / 2;
  const y1234 = (y123 + y234) / 2;
  if (level > 0) {
    let dx = x4 - x1;
    let dy = y4 - y1;
    const d22 = Math.abs((x22 - x4) * dy - (y2 - y4) * dx);
    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);
    let da1;
    let da2;
    if (d22 > FLT_EPSILON && d3 > FLT_EPSILON) {
      if ((d22 + d3) * (d22 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        const a23 = Math.atan2(y3 - y2, x3 - x22);
        da1 = Math.abs(a23 - Math.atan2(y2 - y1, x22 - x1));
        da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da2 >= pi)
          da2 = 2 * pi - da2;
        if (da1 + da2 < mAngleTolerance) {
          points.push(x1234, y1234);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x22, y2);
            return;
          }
          if (da2 > mCuspLimit) {
            points.push(x3, y3);
            return;
          }
        }
      }
    } else if (d22 > FLT_EPSILON) {
      if (d22 * d22 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x22) - Math.atan2(y2 - y1, x22 - x1));
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da1 < mAngleTolerance) {
          points.push(x22, y2);
          points.push(x3, y3);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x22, y2);
            return;
          }
        }
      }
    } else if (d3 > FLT_EPSILON) {
      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x22));
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da1 < mAngleTolerance) {
          points.push(x22, y2);
          points.push(x3, y3);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x3, y3);
            return;
          }
        }
      }
    } else {
      dx = x1234 - (x1 + x4) / 2;
      dy = y1234 - (y1 + y4) / 2;
      if (dx * dx + dy * dy <= distanceTolerance) {
        points.push(x1234, y1234);
        return;
      }
    }
  }
  recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);
  recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);
}
var RECURSION_LIMIT, FLT_EPSILON, PATH_DISTANCE_EPSILON, curveAngleToleranceEpsilon, mAngleTolerance, mCuspLimit;
var init_buildAdaptiveBezier = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs"() {
    RECURSION_LIMIT = 8;
    FLT_EPSILON = 11920929e-14;
    PATH_DISTANCE_EPSILON = 1;
    curveAngleToleranceEpsilon = 0.01;
    mAngleTolerance = 0;
    mCuspLimit = 0;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs
function buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY) {
  const scale3 = 1;
  let distanceTolerance = PATH_DISTANCE_EPSILON2 / scale3;
  distanceTolerance *= distanceTolerance;
  begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);
  return points;
}
function begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {
  recursive2(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);
  points.push(eX, eY);
}
function recursive2(points, x1, y1, x22, y2, x3, y3, distanceTolerance, level) {
  if (level > RECURSION_LIMIT2) {
    return;
  }
  const pi = Math.PI;
  const x12 = (x1 + x22) / 2;
  const y12 = (y1 + y2) / 2;
  const x23 = (x22 + x3) / 2;
  const y23 = (y2 + y3) / 2;
  const x123 = (x12 + x23) / 2;
  const y123 = (y12 + y23) / 2;
  let dx = x3 - x1;
  let dy = y3 - y1;
  const d3 = Math.abs((x22 - x3) * dy - (y2 - y3) * dx);
  if (d3 > FLT_EPSILON2) {
    if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
      if (mAngleTolerance2 < curveAngleToleranceEpsilon2) {
        points.push(x123, y123);
        return;
      }
      let da = Math.abs(Math.atan2(y3 - y2, x3 - x22) - Math.atan2(y2 - y1, x22 - x1));
      if (da >= pi)
        da = 2 * pi - da;
      if (da < mAngleTolerance2) {
        points.push(x123, y123);
        return;
      }
    }
  } else {
    dx = x123 - (x1 + x3) / 2;
    dy = y123 - (y1 + y3) / 2;
    if (dx * dx + dy * dy <= distanceTolerance) {
      points.push(x123, y123);
      return;
    }
  }
  recursive2(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);
  recursive2(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);
}
var RECURSION_LIMIT2, FLT_EPSILON2, PATH_DISTANCE_EPSILON2, curveAngleToleranceEpsilon2, mAngleTolerance2;
var init_buildAdaptiveQuadratic = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs"() {
    RECURSION_LIMIT2 = 8;
    FLT_EPSILON2 = 11920929e-14;
    PATH_DISTANCE_EPSILON2 = 1;
    curveAngleToleranceEpsilon2 = 0.01;
    mAngleTolerance2 = 0;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs
function buildArc(points, x3, y2, radius, start, end, clockwise, steps) {
  let dist = Math.abs(start - end);
  if (!clockwise && start > end) {
    dist = 2 * Math.PI - dist;
  } else if (clockwise && end > start) {
    dist = 2 * Math.PI - dist;
  }
  steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI)));
  steps = Math.max(steps, 3);
  let f2 = dist / steps;
  let t2 = start;
  f2 *= clockwise ? -1 : 1;
  for (let i2 = 0; i2 < steps + 1; i2++) {
    const cs = Math.cos(t2);
    const sn = Math.sin(t2);
    const nx = x3 + cs * radius;
    const ny = y2 + sn * radius;
    points.push(nx, ny);
    t2 += f2;
  }
}
var init_buildArc = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs
function buildArcTo(points, x1, y1, x22, y2, radius) {
  const fromX = points[points.length - 2];
  const fromY = points[points.length - 1];
  const a1 = fromY - y1;
  const b1 = fromX - x1;
  const a2 = y2 - y1;
  const b2 = x22 - x1;
  const mm = Math.abs(a1 * b2 - b1 * a2);
  if (mm < 1e-8 || radius === 0) {
    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
      points.push(x1, y1);
    }
    return;
  }
  const dd = a1 * a1 + b1 * b1;
  const cc = a2 * a2 + b2 * b2;
  const tt = a1 * a2 + b1 * b2;
  const k1 = radius * Math.sqrt(dd) / mm;
  const k22 = radius * Math.sqrt(cc) / mm;
  const j1 = k1 * tt / dd;
  const j22 = k22 * tt / cc;
  const cx = k1 * b2 + k22 * b1;
  const cy = k1 * a2 + k22 * a1;
  const px = b1 * (k22 + j1);
  const py = a1 * (k22 + j1);
  const qx = b2 * (k1 + j22);
  const qy = a2 * (k1 + j22);
  const startAngle = Math.atan2(py - cy, px - cx);
  const endAngle = Math.atan2(qy - cy, qx - cx);
  buildArc(
    points,
    cx + x1,
    cy + y1,
    radius,
    startAngle,
    endAngle,
    b1 * a2 > b2 * a1
  );
}
var init_buildArcTo = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs"() {
    init_buildArc();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs
function approxUnitArc(ang1, ang2) {
  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  const a2 = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;
  const x1 = Math.cos(ang1);
  const y1 = Math.sin(ang1);
  const x22 = Math.cos(ang1 + ang2);
  const y2 = Math.sin(ang1 + ang2);
  return [
    {
      x: x1 - y1 * a2,
      y: y1 + x1 * a2
    },
    {
      x: x22 + y2 * a2,
      y: y2 - x22 * a2
    },
    {
      x: x22,
      y: y2
    }
  ];
}
function buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {
  if (rx === 0 || ry === 0) {
    return;
  }
  const sinPhi = Math.sin(xAxisRotation * TAU / 360);
  const cosPhi = Math.cos(xAxisRotation * TAU / 360);
  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;
  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;
  if (pxp === 0 && pyp === 0) {
    return;
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  getArcCenter(
    px,
    py,
    cx,
    cy,
    rx,
    ry,
    largeArcFlag,
    sweepFlag,
    sinPhi,
    cosPhi,
    pxp,
    pyp,
    out
  );
  let { ang1, ang2 } = out;
  const { centerX, centerY } = out;
  let ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  const segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  let lastX = points[points.length - 2];
  let lastY = points[points.length - 1];
  const outCurvePoint = { x: 0, y: 0 };
  for (let i2 = 0; i2 < segments; i2++) {
    const curve = approxUnitArc(ang1, ang2);
    const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    const { x: x22, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    const { x: x3, y: y3 } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    buildAdaptiveBezier(
      points,
      lastX,
      lastY,
      x1,
      y1,
      x22,
      y2,
      x3,
      y3
    );
    lastX = x3;
    lastY = y3;
    ang1 += ang2;
  }
}
var TAU, out, mapToEllipse, vectorAngle, getArcCenter;
var init_buildArcToSvg = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs"() {
    init_buildAdaptiveBezier();
    TAU = Math.PI * 2;
    out = {
      centerX: 0,
      centerY: 0,
      ang1: 0,
      ang2: 0
    };
    mapToEllipse = ({ x: x3, y: y2 }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {
      x3 *= rx;
      y2 *= ry;
      const xp = cosPhi * x3 - sinPhi * y2;
      const yp = sinPhi * x3 + cosPhi * y2;
      out2.x = xp + centerX;
      out2.y = yp + centerY;
      return out2;
    };
    vectorAngle = (ux2, uy2, vx2, vy2) => {
      const sign = ux2 * vy2 - uy2 * vx2 < 0 ? -1 : 1;
      let dot = ux2 * vx2 + uy2 * vy2;
      if (dot > 1) {
        dot = 1;
      }
      if (dot < -1) {
        dot = -1;
      }
      return sign * Math.acos(dot);
    };
    getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {
      const rxSq = Math.pow(rx, 2);
      const rySq = Math.pow(ry, 2);
      const pxpSq = Math.pow(pxp, 2);
      const pypSq = Math.pow(pyp, 2);
      let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;
      if (radicant < 0) {
        radicant = 0;
      }
      radicant /= rxSq * pypSq + rySq * pxpSq;
      radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
      const centerXp = radicant * rx / ry * pyp;
      const centerYp = radicant * -ry / rx * pxp;
      const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;
      const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;
      const vx1 = (pxp - centerXp) / rx;
      const vy1 = (pyp - centerYp) / ry;
      const vx2 = (-pxp - centerXp) / rx;
      const vy2 = (-pyp - centerYp) / ry;
      const ang1 = vectorAngle(1, 0, vx1, vy1);
      let ang2 = vectorAngle(vx1, vy1, vx2, vy2);
      if (sweepFlag === 0 && ang2 > 0) {
        ang2 -= TAU;
      }
      if (sweepFlag === 1 && ang2 < 0) {
        ang2 += TAU;
      }
      out2.centerX = centerX;
      out2.centerY = centerY;
      out2.ang1 = ang1;
      out2.ang2 = ang2;
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs
var tempRectangle, ShapePath;
var init_ShapePath = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs"() {
    init_Circle();
    init_Ellipse();
    init_Polygon();
    init_Rectangle();
    init_RoundedRectangle();
    init_Bounds();
    init_buildAdaptiveBezier();
    init_buildAdaptiveQuadratic();
    init_buildArc();
    init_buildArcTo();
    init_buildArcToSvg();
    tempRectangle = new Rectangle();
    ShapePath = class {
      constructor(graphicsPath2D) {
        this.shapePrimitives = [];
        this._currentPoly = null;
        this._bounds = new Bounds();
        this._graphicsPath2D = graphicsPath2D;
      }
      moveTo(x3, y2) {
        this.startPoly(x3, y2);
        return this;
      }
      lineTo(x3, y2) {
        this._ensurePoly();
        const points = this._currentPoly.points;
        const fromX = points[points.length - 2];
        const fromY = points[points.length - 1];
        if (fromX !== x3 || fromY !== y2) {
          points.push(x3, y2);
        }
        return this;
      }
      arc(x3, y2, radius, startAngle, endAngle, anticlockwise) {
        this._ensurePoly(false);
        const points = this._currentPoly.points;
        buildArc(points, x3, y2, radius, startAngle, endAngle, anticlockwise);
        return this;
      }
      arcTo(x1, y1, x22, y2, radius) {
        this._ensurePoly();
        const points = this._currentPoly.points;
        buildArcTo(points, x1, y1, x22, y2, radius);
        return this;
      }
      arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x3, y2) {
        const points = this._currentPoly.points;
        buildArcToSvg(
          points,
          this._currentPoly.lastX,
          this._currentPoly.lastY,
          x3,
          y2,
          rx,
          ry,
          xAxisRotation,
          largeArcFlag,
          sweepFlag
        );
        return this;
      }
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x3, y2) {
        this._ensurePoly();
        const currentPoly = this._currentPoly;
        buildAdaptiveBezier(
          this._currentPoly.points,
          currentPoly.lastX,
          currentPoly.lastY,
          cp1x,
          cp1y,
          cp2x,
          cp2y,
          x3,
          y2
        );
        return this;
      }
      quadraticCurveTo(cp1x, cp1y, x3, y2) {
        this._ensurePoly();
        const currentPoly = this._currentPoly;
        buildAdaptiveQuadratic(
          this._currentPoly.points,
          currentPoly.lastX,
          currentPoly.lastY,
          cp1x,
          cp1y,
          x3,
          y2
        );
        return this;
      }
      closePath() {
        this.endPoly(true);
        return this;
      }
      addPath(path2, transform2) {
        this.endPoly();
        if (transform2 && !transform2.isIdentity()) {
          path2 = path2.clone(true);
          path2.transform(transform2);
        }
        for (let i2 = 0; i2 < path2.instructions.length; i2++) {
          const instruction = path2.instructions[i2];
          this[instruction.action](...instruction.data);
        }
        return this;
      }
      finish(closePath = false) {
        this.endPoly(closePath);
      }
      rect(x3, y2, w2, h2, transform2) {
        this.drawShape(new Rectangle(x3, y2, w2, h2), transform2);
        return this;
      }
      circle(x3, y2, radius, transform2) {
        this.drawShape(new Circle(x3, y2, radius), transform2);
        return this;
      }
      poly(points, close, transform2) {
        const polygon = new Polygon(points);
        polygon.closePath = close;
        this.drawShape(polygon, transform2);
      }
      ellipse(x3, y2, radiusX, radiusY, transform2) {
        this.drawShape(new Ellipse(x3, y2, radiusX, radiusY), transform2);
        return this;
      }
      roundRect(x3, y2, w2, h2, radii, transform2) {
        this.drawShape(new RoundedRectangle(x3, y2, w2, h2, radii), transform2);
        return this;
      }
      drawShape(shape, matrix) {
        this.endPoly();
        this.shapePrimitives.push({ shape, transform: matrix });
        return this;
      }
      startPoly(x3, y2) {
        let currentPoly = this._currentPoly;
        if (currentPoly) {
          this.endPoly();
        }
        currentPoly = new Polygon();
        currentPoly.points.push(x3, y2);
        this._currentPoly = currentPoly;
        return this;
      }
      endPoly(closePath = false) {
        const shape = this._currentPoly;
        if (shape && shape.points.length > 2) {
          shape.closePath = closePath;
          this.shapePrimitives.push({ shape });
        }
        this._currentPoly = null;
        return this;
      }
      _ensurePoly(start = true) {
        if (this._currentPoly)
          return;
        this._currentPoly = new Polygon();
        if (start) {
          const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];
          if (lastShape) {
            let lx = lastShape.shape.x;
            let ly = lastShape.shape.y;
            if (lastShape.transform.isIdentity()) {
              const t2 = lastShape.transform;
              const tempX = lx;
              lx = t2.a * lx + t2.c * ly + t2.tx;
              ly = t2.b * tempX + t2.d * ly + t2.ty;
            }
            this._currentPoly.points.push(lx, lx);
          } else {
            this._currentPoly.points.push(0, 0);
          }
        }
      }
      buildPath() {
        const path2 = this._graphicsPath2D;
        this.shapePrimitives.length = 0;
        this._currentPoly = null;
        for (let i2 = 0; i2 < path2.instructions.length; i2++) {
          const instruction = path2.instructions[i2];
          this[instruction.action](...instruction.data);
        }
        this.finish();
      }
      get bounds() {
        const bounds = this._bounds;
        bounds.clear();
        const shapePrimitives = this.shapePrimitives;
        for (let i2 = 0; i2 < shapePrimitives.length; i2++) {
          const shapePrimitive = shapePrimitives[i2];
          const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);
          if (shapePrimitive.transform) {
            bounds.pushMatrix(shapePrimitive.transform);
            bounds.addRect(boundsRect);
            bounds.popMatrix();
          } else {
            bounds.addRect(boundsRect);
          }
        }
        return bounds;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs
function adjustTransform(currentMatrix, transform2) {
  if (currentMatrix) {
    return currentMatrix.prepend(transform2);
  }
  return transform2.clone();
}
var GraphicsPath;
var init_GraphicsPath = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs"() {
    init_Point();
    init_uid();
    init_warn();
    init_SVGToGraphicsPath();
    init_ShapePath();
    GraphicsPath = class _GraphicsPath {
      constructor(instructions) {
        this.instructions = [];
        this.uid = uid("graphicsPath");
        this._dirty = true;
        if (typeof instructions === "string") {
          SVGToGraphicsPath(instructions, this);
        } else {
          this.instructions = instructions?.slice() ?? [];
        }
      }
      get shapePath() {
        if (!this._shapePath) {
          this._shapePath = new ShapePath(this);
        }
        if (this._dirty) {
          this._dirty = false;
          this._shapePath.buildPath();
        }
        return this._shapePath;
      }
      addPath(path2, transform2) {
        path2 = path2.clone();
        this.instructions.push({ action: "addPath", data: [path2, transform2] });
        this._dirty = true;
        return this;
      }
      arc(...args) {
        this.instructions.push({ action: "arc", data: args });
        this._dirty = true;
        return this;
      }
      arcTo(...args) {
        this.instructions.push({ action: "arcTo", data: args });
        this._dirty = true;
        return this;
      }
      arcToSvg(...args) {
        this.instructions.push({ action: "arcToSvg", data: args });
        this._dirty = true;
        return this;
      }
      bezierCurveTo(...args) {
        this.instructions.push({ action: "bezierCurveTo", data: args });
        this._dirty = true;
        return this;
      }
      bezierCurveToShort(cp2x, cp2y, x3, y2) {
        const last = this.instructions[this.instructions.length - 1];
        const lastPoint = this._getLastPoint(Point.shared);
        let cp1x = 0;
        let cp1y = 0;
        if (!last || last.action !== "bezierCurveTo") {
          cp1x = lastPoint.x;
          cp1y = lastPoint.y;
        } else {
          cp1x = last.data[2];
          cp1y = last.data[3];
          const currentX = lastPoint.x;
          const currentY = lastPoint.y;
          cp1x = currentX + (currentX - cp1x);
          cp1y = currentY + (currentY - cp1y);
        }
        this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x3, y2] });
        this._dirty = true;
        return this;
      }
      closePath() {
        this.instructions.push({ action: "closePath", data: [] });
        this._dirty = true;
        return this;
      }
      ellipse(...args) {
        this.instructions.push({ action: "ellipse", data: args });
        this._dirty = true;
        return this;
      }
      lineTo(...args) {
        this.instructions.push({ action: "lineTo", data: args });
        this._dirty = true;
        return this;
      }
      moveTo(...args) {
        this.instructions.push({ action: "moveTo", data: args });
        return this;
      }
      quadraticCurveTo(...args) {
        this.instructions.push({ action: "quadraticCurveTo", data: args });
        this._dirty = true;
        return this;
      }
      quadraticCurveToShort(x3, y2) {
        const last = this.instructions[this.instructions.length - 1];
        const lastPoint = this._getLastPoint(Point.shared);
        let cpx1 = 0;
        let cpy1 = 0;
        if (!last || last.action !== "quadraticCurveTo") {
          cpx1 = lastPoint.x;
          cpy1 = lastPoint.y;
        } else {
          cpx1 = last.data[0];
          cpy1 = last.data[1];
          const currentX = lastPoint.x;
          const currentY = lastPoint.y;
          cpx1 = currentX + (currentX - cpx1);
          cpy1 = currentY + (currentY - cpy1);
        }
        this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x3, y2] });
        this._dirty = true;
        return this;
      }
      rect(x3, y2, w2, h2, transform2) {
        this.instructions.push({ action: "rect", data: [x3, y2, w2, h2, transform2] });
        this._dirty = true;
        return this;
      }
      circle(x3, y2, radius, transform2) {
        this.instructions.push({ action: "circle", data: [x3, y2, radius, transform2] });
        this._dirty = true;
        return this;
      }
      roundRect(...args) {
        this.instructions.push({ action: "roundRect", data: args });
        this._dirty = true;
        return this;
      }
      poly(...args) {
        this.instructions.push({ action: "poly", data: args });
        this._dirty = true;
        return this;
      }
      // eslint-disable-next-line max-len
      star(x3, y2, points, radius, innerRadius, rotation = 0, transform2) {
        innerRadius = innerRadius || radius / 2;
        const startAngle = -1 * Math.PI / 2 + rotation;
        const len = points * 2;
        const delta = Math.PI * 2 / len;
        const polygon = [];
        for (let i2 = 0; i2 < len; i2++) {
          const r2 = i2 % 2 ? innerRadius : radius;
          const angle = i2 * delta + startAngle;
          polygon.push(
            x3 + r2 * Math.cos(angle),
            y2 + r2 * Math.sin(angle)
          );
        }
        this.poly(polygon, true, transform2);
        return this;
      }
      clone(deep = false) {
        const newGraphicsPath2D = new _GraphicsPath();
        if (!deep) {
          newGraphicsPath2D.instructions = this.instructions.slice();
        } else {
          for (let i2 = 0; i2 < this.instructions.length; i2++) {
            const instruction = this.instructions[i2];
            newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });
          }
        }
        return newGraphicsPath2D;
      }
      clear() {
        this.instructions.length = 0;
        this._dirty = true;
        return this;
      }
      transform(matrix) {
        if (matrix.isIdentity())
          return this;
        const a2 = matrix.a;
        const b2 = matrix.b;
        const c2 = matrix.c;
        const d3 = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        let x3 = 0;
        let y2 = 0;
        let cpx1 = 0;
        let cpy1 = 0;
        let cpx2 = 0;
        let cpy2 = 0;
        let rx = 0;
        let ry = 0;
        for (let i2 = 0; i2 < this.instructions.length; i2++) {
          const instruction = this.instructions[i2];
          const data = instruction.data;
          switch (instruction.action) {
            case "moveTo":
            case "lineTo":
              x3 = data[0];
              y2 = data[1];
              data[0] = a2 * x3 + c2 * y2 + tx;
              data[1] = b2 * x3 + d3 * y2 + ty;
              break;
            case "bezierCurveTo":
              cpx1 = data[0];
              cpy1 = data[1];
              cpx2 = data[2];
              cpy2 = data[3];
              x3 = data[4];
              y2 = data[5];
              data[0] = a2 * cpx1 + c2 * cpy1 + tx;
              data[1] = b2 * cpx1 + d3 * cpy1 + ty;
              data[2] = a2 * cpx2 + c2 * cpy2 + tx;
              data[3] = b2 * cpx2 + d3 * cpy2 + ty;
              data[4] = a2 * x3 + c2 * y2 + tx;
              data[5] = b2 * x3 + d3 * y2 + ty;
              break;
            case "quadraticCurveTo":
              cpx1 = data[0];
              cpy1 = data[1];
              x3 = data[2];
              y2 = data[3];
              data[0] = a2 * cpx1 + c2 * cpy1 + tx;
              data[1] = b2 * cpx1 + d3 * cpy1 + ty;
              data[2] = a2 * x3 + c2 * y2 + tx;
              data[3] = b2 * x3 + d3 * y2 + ty;
              break;
            case "arcToSvg":
              x3 = data[5];
              y2 = data[6];
              rx = data[0];
              ry = data[1];
              data[0] = a2 * rx + c2 * ry;
              data[1] = b2 * rx + d3 * ry;
              data[5] = a2 * x3 + c2 * y2 + tx;
              data[6] = b2 * x3 + d3 * y2 + ty;
              break;
            case "rect":
              data[4] = adjustTransform(data[4], matrix);
              break;
            case "ellipse":
              data[8] = adjustTransform(data[8], matrix);
              break;
            case "roundRect":
              data[5] = adjustTransform(data[5], matrix);
              break;
            case "addPath":
              data[0].transform(matrix);
              break;
            default:
              warn("unknown transform action", instruction.action);
              break;
          }
        }
        this._dirty = true;
        return this;
      }
      get bounds() {
        return this.shapePath.bounds;
      }
      _getLastPoint(out2) {
        let index = this.instructions.length - 1;
        let lastInstruction = this.instructions[index];
        if (!lastInstruction) {
          out2.x = 0;
          out2.y = 0;
          return out2;
        }
        while (lastInstruction.action === "closePath") {
          index--;
          if (index < 0) {
            out2.x = 0;
            out2.y = 0;
            return out2;
          }
          lastInstruction = this.instructions[index];
        }
        let x3;
        let y2;
        let transform2;
        switch (lastInstruction.action) {
          case "moveTo":
          case "lineTo":
            out2.x = lastInstruction.data[0];
            out2.y = lastInstruction.data[1];
            break;
          case "quadraticCurveTo":
            out2.x = lastInstruction.data[2];
            out2.y = lastInstruction.data[3];
            break;
          case "bezierCurveTo":
            out2.x = lastInstruction.data[4];
            out2.y = lastInstruction.data[5];
            break;
          case "arc":
          case "arcToSvg":
            out2.x = lastInstruction.data[5];
            out2.y = lastInstruction.data[6];
            break;
          case "addPath":
            out2.x = lastInstruction.data[0].lastX;
            out2.y = lastInstruction.data[2].lastY;
            break;
          case "rect":
            transform2 = lastInstruction.data[4];
            x3 = lastInstruction.data[0];
            y2 = lastInstruction.data[1];
            if (transform2) {
              const { a: a2, b: b2, c: c2, d: d3, tx, ty } = transform2;
              out2.x = a2 * x3 + c2 * y2 + tx;
              out2.y = b2 * x3 + d3 * y2 + ty;
            } else {
              out2.x = x3;
              out2.y = y2;
            }
            break;
          default:
            warn(`${lastInstruction.action} is not supported yet`);
            break;
        }
        return out2;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs
function SVGParser(svg, graphicsContext) {
  if (typeof svg === "string") {
    const div = document.createElement("div");
    div.innerHTML = svg.trim();
    svg = div.querySelector("svg");
  }
  const session = {
    context: graphicsContext,
    path: new GraphicsPath()
  };
  renderChildren(svg, session, null, null);
  return graphicsContext;
}
function renderChildren(svg, session, fillStyle, strokeStyle) {
  const children = svg.children;
  const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);
  if (f1 && fillStyle) {
    fillStyle = { ...fillStyle, ...f1 };
  } else if (f1) {
    fillStyle = f1;
  }
  if (s1 && strokeStyle) {
    strokeStyle = { ...strokeStyle, ...s1 };
  } else if (s1) {
    strokeStyle = s1;
  }
  session.context.fillStyle = fillStyle;
  session.context.strokeStyle = strokeStyle;
  let x3;
  let y2;
  let x1;
  let y1;
  let x22;
  let y22;
  let cx;
  let cy;
  let r2;
  let rx;
  let ry;
  let points;
  let pointsString;
  let d3;
  let graphicsPath;
  let width;
  let height;
  switch (svg.nodeName.toLowerCase()) {
    case "path":
      d3 = svg.getAttribute("d");
      graphicsPath = new GraphicsPath(d3);
      session.context.path(graphicsPath);
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "circle":
      cx = parseFloatAttribute(svg, "cx", 0);
      cy = parseFloatAttribute(svg, "cy", 0);
      r2 = parseFloatAttribute(svg, "r", 0);
      session.context.ellipse(cx, cy, r2, r2);
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "rect":
      x3 = parseFloatAttribute(svg, "x", 0);
      y2 = parseFloatAttribute(svg, "y", 0);
      width = parseFloatAttribute(svg, "width", 0);
      height = parseFloatAttribute(svg, "height", 0);
      rx = parseFloatAttribute(svg, "rx", 0);
      ry = parseFloatAttribute(svg, "ry", 0);
      if (rx || ry) {
        session.context.roundRect(x3, y2, width, height, rx || ry);
      } else {
        session.context.rect(x3, y2, width, height);
      }
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "ellipse":
      cx = parseFloatAttribute(svg, "cx", 0);
      cy = parseFloatAttribute(svg, "cy", 0);
      rx = parseFloatAttribute(svg, "rx", 0);
      ry = parseFloatAttribute(svg, "ry", 0);
      session.context.beginPath();
      session.context.ellipse(cx, cy, rx, ry);
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "line":
      x1 = parseFloatAttribute(svg, "x1", 0);
      y1 = parseFloatAttribute(svg, "y1", 0);
      x22 = parseFloatAttribute(svg, "x2", 0);
      y22 = parseFloatAttribute(svg, "y2", 0);
      session.context.beginPath();
      session.context.moveTo(x1, y1);
      session.context.lineTo(x22, y22);
      if (strokeStyle)
        session.context.stroke();
      break;
    case "polygon":
      pointsString = svg.getAttribute("points");
      points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
      session.context.poly(points, true);
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "polyline":
      pointsString = svg.getAttribute("points");
      points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
      session.context.poly(points, false);
      if (strokeStyle)
        session.context.stroke();
      break;
    case "g":
    case "svg":
      break;
    default: {
      console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);
      break;
    }
  }
  for (let i2 = 0; i2 < children.length; i2++) {
    renderChildren(children[i2], session, fillStyle, strokeStyle);
  }
}
function parseFloatAttribute(svg, id, defaultValue2) {
  const value = svg.getAttribute(id);
  return value ? Number(value) : defaultValue2;
}
function parseStyle(svg) {
  const style = svg.getAttribute("style");
  const strokeStyle = {};
  const fillStyle = {};
  let useFill = false;
  let useStroke = false;
  if (style) {
    const styleParts = style.split(";");
    for (let i2 = 0; i2 < styleParts.length; i2++) {
      const stylePart = styleParts[i2];
      const [key, value] = stylePart.split(":");
      switch (key) {
        case "stroke":
          if (value !== "none") {
            strokeStyle.color = Color.shared.setValue(value).toNumber();
            useStroke = true;
          }
          break;
        case "stroke-width":
          strokeStyle.width = Number(value);
          break;
        case "fill":
          if (value !== "none") {
            useFill = true;
            fillStyle.color = Color.shared.setValue(value).toNumber();
          }
          break;
        case "fill-opacity":
          fillStyle.alpha = Number(value);
          break;
        case "stroke-opacity":
          strokeStyle.alpha = Number(value);
          break;
        case "opacity":
          fillStyle.alpha = Number(value);
          strokeStyle.alpha = Number(value);
          break;
      }
    }
  } else {
    const stroke = svg.getAttribute("stroke");
    if (stroke && stroke !== "none") {
      useStroke = true;
      strokeStyle.color = Color.shared.setValue(stroke).toNumber();
      strokeStyle.width = parseFloatAttribute(svg, "stroke-width", 1);
    }
    const fill = svg.getAttribute("fill");
    if (fill && fill !== "none") {
      useFill = true;
      fillStyle.color = Color.shared.setValue(fill).toNumber();
    }
  }
  return {
    strokeStyle: useStroke ? strokeStyle : null,
    fillStyle: useFill ? fillStyle : null
  };
}
var init_SVGParser = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs"() {
    init_Color();
    init_GraphicsPath();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs
var ImageSource, canvas, size, ctx;
var init_ImageSource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs"() {
    init_Extensions();
    init_adapter();
    init_NOOP();
    init_Texture();
    init_TextureSource();
    ImageSource = class extends TextureSource {
      constructor() {
        super(...arguments);
        this.uploadMethodId = "image";
      }
      static test(resource) {
        return typeof HTMLImageElement !== "undefined" && resource instanceof HTMLImageElement || typeof ImageBitmap !== "undefined" && resource instanceof ImageBitmap;
      }
    };
    ImageSource.extension = ExtensionType.TextureSource;
    canvas = DOMAdapter.get().createCanvas();
    size = 1;
    canvas.width = size;
    canvas.height = size;
    ctx = canvas.getContext("2d");
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, size, size);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(size, 0);
    ctx.lineTo(size, size);
    ctx.closePath();
    ctx.fillStyle = "#ffffff";
    ctx.fill();
    Texture.WHITE = new Texture({
      source: new ImageSource({
        resource: canvas
      })
    });
    Texture.WHITE.label = "WHITE";
    Texture.WHITE.destroy = NOOP;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs
var _FillGradient, FillGradient;
var init_FillGradient = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs"() {
    init_Color();
    init_Matrix();
    init_ImageSource();
    init_Texture();
    init_adapter();
    init_uid();
    _FillGradient = class {
      constructor(x0, y0, x1, y1) {
        this.uid = uid("fillGradient");
        this.type = "linear";
        this.gradientStops = [];
        this.x0 = x0;
        this.y0 = y0;
        this.x1 = x1;
        this.y1 = y1;
      }
      addColorStop(offset, color) {
        this.gradientStops.push({ offset, color: Color.shared.setValue(color).toHex() });
        return this;
      }
      // TODO move to the system!
      buildLinearGradient() {
        const defaultSize = _FillGradient.defaultTextureSize;
        const { gradientStops } = this;
        const canvas2 = DOMAdapter.get().createCanvas();
        canvas2.width = defaultSize;
        canvas2.height = defaultSize;
        const ctx2 = canvas2.getContext("2d");
        const gradient = ctx2.createLinearGradient(0, 0, _FillGradient.defaultTextureSize, 1);
        for (let i2 = 0; i2 < gradientStops.length; i2++) {
          const stop = gradientStops[i2];
          gradient.addColorStop(stop.offset, stop.color);
        }
        ctx2.fillStyle = gradient;
        ctx2.fillRect(0, 0, defaultSize, defaultSize);
        this.texture = new Texture({
          source: new ImageSource({
            resource: canvas2,
            style: {
              addressModeU: "clamp-to-edge",
              addressModeV: "repeat"
            }
          })
        });
        const { x0, y0, x1, y1 } = this;
        const m3 = new Matrix();
        const dx = x1 - x0;
        const dy = y1 - y0;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        m3.translate(-x0, -y0);
        m3.scale(1 / defaultSize, 1 / defaultSize);
        m3.rotate(-angle);
        m3.scale(256 / dist, 1);
        this.transform = m3;
      }
    };
    FillGradient = _FillGradient;
    FillGradient.defaultTextureSize = 256;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs
var repetitionMap, FillPattern;
var init_FillPattern = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs"() {
    init_Matrix();
    init_uid();
    repetitionMap = {
      repeat: {
        addressModeU: "repeat",
        addressModeV: "repeat"
      },
      "repeat-x": {
        addressModeU: "repeat",
        addressModeV: "clamp-to-edge"
      },
      "repeat-y": {
        addressModeU: "clamp-to-edge",
        addressModeV: "repeat"
      },
      "no-repeat": {
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      }
    };
    FillPattern = class {
      constructor(texture, repetition) {
        this.uid = uid("fillPattern");
        this.transform = new Matrix();
        this.texture = texture;
        this.transform.scale(
          1 / texture.frameWidth,
          1 / texture.frameHeight
        );
        if (repetition) {
          texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;
          texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;
        }
      }
      setTransform(transform2) {
        const texture = this.texture;
        this.transform.copyFrom(transform2);
        this.transform.invert();
        this.transform.scale(
          1 / texture.frameWidth,
          1 / texture.frameHeight
        );
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs
function convertFillInputToFillStyle(value, defaultStyle) {
  if (!value) {
    return null;
  }
  let fillStyleToParse;
  let styleToMerge;
  if (value?.fill) {
    styleToMerge = value.fill;
    fillStyleToParse = { ...defaultStyle, ...value };
  } else {
    styleToMerge = value;
    fillStyleToParse = defaultStyle;
  }
  if (Color.isColorLike(styleToMerge)) {
    const temp = Color.shared.setValue(styleToMerge ?? 0);
    const opts = {
      ...fillStyleToParse,
      color: temp.toNumber(),
      alpha: temp.alpha === 1 ? fillStyleToParse.alpha : temp.alpha,
      texture: Texture.WHITE
    };
    return opts;
  } else if (styleToMerge instanceof FillPattern) {
    const pattern = styleToMerge;
    return {
      ...fillStyleToParse,
      color: 16777215,
      texture: pattern.texture,
      matrix: pattern.transform,
      fill: fillStyleToParse.fill ?? null
    };
  } else if (styleToMerge instanceof FillGradient) {
    const gradient = styleToMerge;
    gradient.buildLinearGradient();
    return {
      ...fillStyleToParse,
      color: 16777215,
      texture: gradient.texture,
      matrix: gradient.transform
    };
  }
  const style = { ...defaultStyle, ...value };
  if (style.texture !== Texture.WHITE) {
    const m3 = style.matrix || new Matrix();
    m3.scale(1 / style.texture.frameWidth, 1 / style.texture.frameHeight);
    style.matrix = m3;
    style.color = 16777215;
  }
  style.color = Color.shared.setValue(style.color).toNumber();
  return style;
}
var init_convertFillInputToFillStyle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs"() {
    init_Color();
    init_Matrix();
    init_Texture();
    init_FillGradient();
    init_FillPattern();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs
var tmpPoint, tempMatrix3, _GraphicsContext, GraphicsContext;
var init_GraphicsContext = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs"() {
    init_eventemitter3();
    init_Color();
    init_Matrix();
    init_Point();
    init_Texture();
    init_uid();
    init_deprecation();
    init_Bounds();
    init_GraphicsPath();
    init_SVGParser();
    init_convertFillInputToFillStyle();
    tmpPoint = new Point();
    tempMatrix3 = new Matrix();
    _GraphicsContext = class extends eventemitter3_default {
      constructor() {
        super(...arguments);
        this.uid = uid("graphicsContext");
        this.dirty = true;
        this.batchMode = "auto";
        this.instructions = [];
        this._activePath = new GraphicsPath();
        this._transform = new Matrix();
        this._fillStyle = { ..._GraphicsContext.defaultFillStyle };
        this._strokeStyle = { ..._GraphicsContext.defaultStrokeStyle };
        this._stateStack = [];
        this._tick = 0;
        this._bounds = new Bounds();
        this._boundsDirty = true;
      }
      get fillStyle() {
        return this._fillStyle;
      }
      set fillStyle(value) {
        this._fillStyle = convertFillInputToFillStyle(value, _GraphicsContext.defaultFillStyle);
      }
      get strokeStyle() {
        return this._strokeStyle;
      }
      set strokeStyle(value) {
        this._strokeStyle = convertFillInputToFillStyle(value, _GraphicsContext.defaultStrokeStyle);
      }
      texture(texture, tint, dx, dy, dw, dh) {
        this.instructions.push({
          action: "texture",
          data: {
            image: texture,
            dx: dx || 0,
            dy: dy || 0,
            dw: dw || texture.frameWidth,
            dh: dh || texture.frameHeight,
            transform: this._transform.clone(),
            alpha: this._fillStyle.alpha,
            style: tint ? Color.shared.setValue(tint).toNumber() : 0
          }
        });
        this.onUpdate();
        return this;
      }
      beginPath() {
        this._activePath = new GraphicsPath();
        return this;
      }
      fill(style, alpha) {
        let path2;
        const lastInstruction = this.instructions[this.instructions.length - 1];
        if (this._tick === 0 && lastInstruction && lastInstruction.action === "stroke") {
          path2 = lastInstruction.data.path;
        } else {
          path2 = this._activePath.clone();
        }
        if (!path2)
          return this;
        if (style) {
          if (alpha !== void 0 && typeof style === "number") {
            deprecation("8.0.0", "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");
            style = { color: style, alpha };
          }
          this._fillStyle = convertFillInputToFillStyle(style, _GraphicsContext.defaultFillStyle);
        }
        this.instructions.push({
          action: "fill",
          // TODO copy fill style!
          data: { style: this.fillStyle, path: path2 }
        });
        this.onUpdate();
        this._activePath.instructions.length = 0;
        this._tick = 0;
        return this;
      }
      stroke(style) {
        let path2;
        const lastInstruction = this.instructions[this.instructions.length - 1];
        if (this._tick === 0 && lastInstruction && lastInstruction.action === "fill") {
          path2 = lastInstruction.data.path;
        } else {
          path2 = this._activePath.clone();
        }
        if (!path2)
          return this;
        if (style) {
          this._strokeStyle = convertFillInputToFillStyle(style, _GraphicsContext.defaultStrokeStyle);
        }
        this.instructions.push({
          action: "stroke",
          // TODO copy fill style!
          data: { style: this.strokeStyle, path: path2 }
        });
        this.onUpdate();
        this._activePath.instructions.length = 0;
        this._tick = 0;
        return this;
      }
      cut() {
        for (let i2 = 0; i2 < 2; i2++) {
          const lastInstruction = this.instructions[this.instructions.length - 1 - i2];
          const holePath = this._activePath.clone();
          if (lastInstruction) {
            if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {
              lastInstruction.data.hole = holePath;
            }
          }
        }
        this._activePath.instructions.length = 0;
        return this;
      }
      arc(x3, y2, radius, startAngle, endAngle, counterclockwise) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.arc(
          t2.a * x3 + t2.c * y2 + t2.tx,
          t2.b * x3 + t2.d * y2 + t2.ty,
          radius,
          startAngle,
          endAngle,
          counterclockwise
        );
        return this;
      }
      arcTo(x1, y1, x22, y2, radius) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.arcTo(
          t2.a * x1 + t2.c * y1 + t2.tx,
          t2.b * x1 + t2.d * y1 + t2.ty,
          t2.a * x22 + t2.c * y2 + t2.tx,
          t2.b * x22 + t2.d * y2 + t2.ty,
          radius
        );
        return this;
      }
      arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x3, y2) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.arcToSvg(
          rx,
          ry,
          xAxisRotation,
          // should we rotate this with transform??
          largeArcFlag,
          sweepFlag,
          t2.a * x3 + t2.c * y2 + t2.tx,
          t2.b * x3 + t2.d * y2 + t2.ty
        );
        return this;
      }
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x3, y2) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.bezierCurveTo(
          t2.a * cp1x + t2.c * cp1y + t2.tx,
          t2.b * cp1x + t2.d * cp1y + t2.ty,
          t2.a * cp2x + t2.c * cp2y + t2.tx,
          t2.b * cp2x + t2.d * cp2y + t2.ty,
          t2.a * x3 + t2.c * y2 + t2.tx,
          t2.b * x3 + t2.d * y2 + t2.ty
        );
        return this;
      }
      closePath() {
        this._tick++;
        this._activePath?.closePath();
        return this;
      }
      ellipse(x3, y2, radiusX, radiusY) {
        this._tick++;
        this._activePath.ellipse(x3, y2, radiusX, radiusY, this._transform.clone());
        return this;
      }
      circle(x3, y2, radius) {
        this._tick++;
        this._activePath.circle(x3, y2, radius, this._transform.clone());
        return this;
      }
      path(path2) {
        this._tick++;
        this._activePath.addPath(path2, this._transform.clone());
        return this;
      }
      lineTo(x3, y2) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.lineTo(
          t2.a * x3 + t2.c * y2 + t2.tx,
          t2.b * x3 + t2.d * y2 + t2.ty
        );
        return this;
      }
      moveTo(x3, y2) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.moveTo(
          t2.a * x3 + t2.c * y2 + t2.tx,
          t2.b * x3 + t2.d * y2 + t2.ty
        );
        return this;
      }
      quadraticCurveTo(cpx, cpy, x3, y2) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.quadraticCurveTo(
          t2.a * cpx + t2.c * cpy + t2.tx,
          t2.b * cpx + t2.d * cpy + t2.ty,
          t2.a * x3 + t2.c * y2 + t2.tx,
          t2.b * x3 + t2.d * y2 + t2.ty
        );
      }
      rect(x3, y2, w2, h2) {
        this._tick++;
        this._activePath.rect(x3, y2, w2, h2, this._transform.clone());
        return this;
      }
      roundRect(x3, y2, w2, h2, radii) {
        this._tick++;
        this._activePath.roundRect(x3, y2, w2, h2, radii, this._transform.clone());
        return this;
      }
      poly(points, close) {
        this._tick++;
        this._activePath.poly(points, close, this._transform.clone());
        return this;
      }
      star(x3, y2, points, radius, innerRadius, rotation) {
        this._tick++;
        this._activePath.star(x3, y2, points, radius, innerRadius, rotation, this._transform.clone());
        return this;
      }
      svg(svg) {
        this._tick++;
        SVGParser(svg, this);
      }
      restore() {
        const state = this._stateStack.pop();
        if (state) {
          this._transform = state.transform;
          this._fillStyle = state.fillStyle;
          this._strokeStyle = state.strokeStyle;
        }
      }
      save() {
        this._stateStack.push({
          transform: this._transform.clone(),
          fillStyle: { ...this._fillStyle },
          strokeStyle: { ...this._strokeStyle }
        });
      }
      getTransform() {
        return this._transform;
      }
      resetTransform() {
        this._transform.identity();
        return this;
      }
      rotate(angle) {
        this._transform.rotate(angle);
        return this;
      }
      scale(x3, y2 = x3) {
        this._transform.scale(x3, y2);
        return this;
      }
      setTransform(a2, b2, c2, d3, dx, dy) {
        if (a2 instanceof Matrix) {
          this._transform.set(a2.a, a2.b, a2.c, a2.d, a2.tx, a2.ty);
          return this;
        }
        this._transform.set(a2, b2, c2, d3, dx, dy);
        return this;
      }
      transform(a2, b2, c2, d3, dx, dy) {
        if (a2 instanceof Matrix) {
          this._transform.append(a2);
          return this;
        }
        tempMatrix3.set(a2, b2, c2, d3, dx, dy);
        this._transform.append(tempMatrix3);
        return this;
      }
      translate(x3, y2) {
        this._transform.translate(x3, y2);
        return this;
      }
      clear() {
        this.instructions.length = 0;
        this.resetTransform();
        this.onUpdate();
        return this;
      }
      onUpdate() {
        if (this.dirty)
          return;
        this.emit("update", this, 16);
        this.dirty = true;
        this._boundsDirty = true;
      }
      get bounds() {
        if (!this._boundsDirty)
          return this._bounds;
        const bounds = this._bounds;
        bounds.clear();
        for (let i2 = 0; i2 < this.instructions.length; i2++) {
          const instruction = this.instructions[i2];
          const action = instruction.action;
          if (action === "fill") {
            const data = instruction.data;
            bounds.addBounds(data.path.bounds);
          } else if (action === "texture") {
            const data = instruction.data;
            bounds.pushMatrix(data.transform);
            bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh);
            bounds.popMatrix();
          }
        }
        return bounds;
      }
      /**
       * Check to see if a point is contained within this geometry.
       * @param point - Point to check if it's contained.
       * @returns {boolean} `true` if the point is contained within geometry.
       */
      containsPoint(point) {
        const instructions = this.instructions;
        let hasHit = false;
        instructions.forEach((instruction) => {
          const data = instruction.data;
          const path2 = data.path;
          if (!instruction.action || !path2)
            return;
          const style = data.style;
          const shapes = path2.shapePath?.shapePrimitives;
          this._forEachShape(shapes, (shape) => {
            if (!style || !shape)
              return;
            if (typeof style !== "number" && style.matrix) {
              style.matrix.applyInverse(point, tmpPoint);
            } else {
              tmpPoint.copyFrom(point);
            }
            hasHit = shape.contains(tmpPoint.x, tmpPoint.y);
            const holes = data.hole;
            if (!holes)
              return;
            const holeShapes = holes.shapePath?.shapePrimitives;
            if (!holeShapes)
              return;
            this._forEachShape(holeShapes, (hole) => {
              if (hole.contains(tmpPoint.x, tmpPoint.y)) {
                hasHit = false;
              }
            });
          });
        });
        return hasHit;
      }
      _forEachShape(shapes, callback) {
        shapes?.forEach((shapePrimitive) => {
          const shape = shapePrimitive?.shape;
          if (shape) {
            callback(shape);
          }
        });
      }
      /**
       * Destroys the GraphicsData object.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?
       * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?
       */
      destroy(options = false) {
        this._stateStack.length = 0;
        this._transform = null;
        this.emit("destroy", this);
        this.removeAllListeners();
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          if (this._fillStyle.texture) {
            this._fillStyle.texture.destroy(destroyTextureSource);
          }
          if (this._strokeStyle.texture) {
            this._strokeStyle.texture.destroy(destroyTextureSource);
          }
        }
        this._fillStyle = null;
        this._strokeStyle = null;
        this.instructions = null;
        this._activePath = null;
        this._bounds = null;
        this._stateStack = null;
        this.customShader = null;
        this._transform = null;
      }
    };
    GraphicsContext = _GraphicsContext;
    GraphicsContext.defaultFillStyle = {
      color: 0,
      alpha: 1,
      texture: Texture.WHITE,
      matrix: null,
      fill: null
    };
    GraphicsContext.defaultStrokeStyle = {
      width: 1,
      color: 0,
      alpha: 1,
      alignment: 0.5,
      miterLimit: 10,
      cap: "butt",
      join: "miter",
      texture: Texture.WHITE,
      matrix: null,
      fill: null
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs
var SVG_XML, validSVGExtension, validSVGMIME, loadSvg;
var init_loadSVG = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs"() {
    init_Extensions();
    init_GraphicsContext();
    init_adapter();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
    validSVGExtension = ".svg";
    validSVGMIME = "image/svg+xml";
    loadSvg = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Low
      },
      name: "loadSVG",
      test(url) {
        return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);
      },
      async testParse(data) {
        return typeof data === "string" && data.startsWith("data:image/svg+xml") || typeof data === "string" && SVG_XML.test(data);
      },
      async parse(asset) {
        const context2 = new GraphicsContext();
        context2.svg(asset);
        return context2;
      },
      async load(url) {
        const response = await DOMAdapter.get().fetch(url);
        return response.text();
      },
      unload(asset) {
        asset.destroy(true);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs
function processX(base, ids, depth, result, tags) {
  const id = ids[depth];
  for (let i2 = 0; i2 < id.length; i2++) {
    const value = id[i2];
    if (depth < ids.length - 1) {
      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);
    } else {
      tags.push(base.replace(result[depth], value));
    }
  }
}
function createStringVariations(string) {
  const regex = /\{(.*?)\}/g;
  const result = string.match(regex);
  const tags = [];
  if (result) {
    const ids = [];
    result.forEach((vars) => {
      const split = vars.substring(1, vars.length - 1).split(",");
      ids.push(split);
    });
    processX(string, ids, 0, result, tags);
  } else {
    tags.push(string);
  }
  return tags;
}
var init_createStringVariations = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs
var isSingleItem;
var init_isSingleItem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs"() {
    isSingleItem = (item) => !Array.isArray(item);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/resolver/Resolver.mjs
var Resolver;
var init_Resolver = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/resolver/Resolver.mjs"() {
    init_warn();
    init_path();
    init_convertToList();
    init_createStringVariations();
    init_isSingleItem();
    Resolver = class {
      constructor() {
        this._defaultBundleIdentifierOptions = {
          connector: "-",
          createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
          extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
        };
        this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
        this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
        this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
        this._assetMap = {};
        this._preferredOrder = [];
        this._parsers = [];
        this._resolverHash = {};
        this._bundles = {};
      }
      /**
       * Override how the resolver deals with generating bundle ids.
       * must be called before any bundles are added
       * @param bundleIdentifier - the bundle identifier options
       */
      setBundleIdentifier(bundleIdentifier) {
        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
        if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
          throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
        }
      }
      /**
       * Let the resolver know which assets you prefer to use when resolving assets.
       * Multiple prefer user defined rules can be added.
       * @example
       * resolver.prefer({
       *     // first look for something with the correct format, and then then correct resolution
       *     priority: ['format', 'resolution'],
       *     params:{
       *         format:'webp', // prefer webp images
       *         resolution: 2, // prefer a resolution of 2
       *     }
       * })
       * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
       * resolver.resolveUrl('foo') // => 'bar@2x.webp'
       * @param preferOrders - the prefer options
       */
      prefer(...preferOrders) {
        preferOrders.forEach((prefer) => {
          this._preferredOrder.push(prefer);
          if (!prefer.priority) {
            prefer.priority = Object.keys(prefer.params);
          }
        });
        this._resolverHash = {};
      }
      /**
       * Set the base path to prepend to all urls when resolving
       * @example
       * resolver.basePath = 'https://home.com/';
       * resolver.add('foo', 'bar.ong');
       * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
       * @param basePath - the base path to use
       */
      set basePath(basePath) {
        this._basePath = basePath;
      }
      get basePath() {
        return this._basePath;
      }
      /**
       * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
       * default value for browsers is `window.location.origin`
       * @example
       * // Application hosted on https://home.com/some-path/index.html
       * resolver.basePath = 'https://home.com/some-path/';
       * resolver.rootPath = 'https://home.com/';
       * resolver.add('foo', '/bar.png');
       * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
       * @param rootPath - the root path to use
       */
      set rootPath(rootPath) {
        this._rootPath = rootPath;
      }
      get rootPath() {
        return this._rootPath;
      }
      /**
       * All the active URL parsers that help the parser to extract information and create
       * an asset object-based on parsing the URL itself.
       *
       * Can be added using the extensions API
       * @example
       * resolver.add('foo', [
       *     {
       *         resolution: 2,
       *         format: 'png',
       *         src: 'image@2x.png',
       *     },
       *     {
       *         resolution:1,
       *         format:'png',
       *         src: 'image.png',
       *     },
       * ]);
       *
       * // With a url parser the information such as resolution and file format could extracted from the url itself:
       * extensions.add({
       *     extension: ExtensionType.ResolveParser,
       *     test: loadTextures.test, // test if url ends in an image
       *     parse: (value: string) =>
       *     ({
       *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
       *         format: value.split('.').pop(),
       *         src: value,
       *     }),
       * });
       *
       * // Now resolution and format can be extracted from the url
       * resolver.add('foo', [
       *     'image@2x.png',
       *     'image.png',
       * ]);
       */
      get parsers() {
        return this._parsers;
      }
      /** Used for testing, this resets the resolver to its initial state */
      reset() {
        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
        this._assetMap = {};
        this._preferredOrder = [];
        this._resolverHash = {};
        this._rootPath = null;
        this._basePath = null;
        this._manifest = null;
        this._bundles = {};
        this._defaultSearchParams = null;
      }
      /**
       * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.
       * @param searchParams - the default url parameters to append when resolving urls
       */
      setDefaultSearchParams(searchParams) {
        if (typeof searchParams === "string") {
          this._defaultSearchParams = searchParams;
        } else {
          const queryValues = searchParams;
          this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
        }
      }
      /**
       * Returns the aliases for a given asset
       * @param asset - the asset to get the aliases for
       */
      getAlias(asset) {
        const { alias, name, src, srcs } = asset;
        const aliasesToUse = convertToList(
          alias || name || src || srcs,
          (value) => {
            if (typeof value === "string")
              return value;
            if (Array.isArray(value))
              return value.map((v3) => v3?.src ?? v3?.srcs ?? v3);
            if (value?.src || value?.srcs)
              return value.src ?? value.srcs;
            return value;
          },
          true
        );
        return aliasesToUse;
      }
      /**
       * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
       * generally a manifest would be built using a tool.
       * @param manifest - the manifest to add to the resolver
       */
      addManifest(manifest) {
        if (this._manifest) {
          warn("[Resolver] Manifest already exists, this will be overwritten");
        }
        this._manifest = manifest;
        manifest.bundles.forEach((bundle) => {
          this.addBundle(bundle.name, bundle.assets);
        });
      }
      /**
       * This adds a bundle of assets in one go so that you can resolve them as a group.
       * For example you could add a bundle for each screen in you pixi app
       * @example
       * resolver.addBundle('animals', {
       *     bunny: 'bunny.png',
       *     chicken: 'chicken.png',
       *     thumper: 'thumper.png',
       * });
       *
       * const resolvedAssets = await resolver.resolveBundle('animals');
       * @param bundleId - The id of the bundle to add
       * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
       */
      addBundle(bundleId, assets) {
        const assetNames = [];
        if (Array.isArray(assets)) {
          assets.forEach((asset) => {
            const srcs = asset.src ?? asset.srcs;
            const aliases = asset.alias ?? asset.name;
            let ids;
            if (typeof aliases === "string") {
              const bundleAssetId = this._createBundleAssetId(bundleId, aliases);
              assetNames.push(bundleAssetId);
              ids = [aliases, bundleAssetId];
            } else {
              const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));
              assetNames.push(...bundleIds);
              ids = [...aliases, ...bundleIds];
            }
            this.add({
              ...asset,
              ...{
                alias: ids,
                src: srcs
              }
            });
          });
        } else {
          Object.keys(assets).forEach((key) => {
            const aliases = [key, this._createBundleAssetId(bundleId, key)];
            if (typeof assets[key] === "string") {
              this.add({
                alias: aliases,
                src: assets[key]
              });
            } else if (Array.isArray(assets[key])) {
              this.add({
                alias: aliases,
                src: assets[key]
              });
            } else {
              const asset = assets[key];
              const assetSrc = asset.src ?? asset.srcs;
              this.add({
                ...asset,
                ...{
                  alias: aliases,
                  src: Array.isArray(assetSrc) ? assetSrc : [assetSrc]
                }
              });
            }
            assetNames.push(...aliases);
          });
        }
        this._bundles[bundleId] = assetNames;
      }
      /**
       * Tells the resolver what keys are associated with witch asset.
       * The most important thing the resolver does
       * @example
       * // Single key, single asset:
       * resolver.add({alias: 'foo', src: 'bar.png');
       * resolver.resolveUrl('foo') // => 'bar.png'
       *
       * // Multiple keys, single asset:
       * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});
       * resolver.resolveUrl('foo') // => 'bar.png'
       * resolver.resolveUrl('boo') // => 'bar.png'
       *
       * // Multiple keys, multiple assets:
       * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});
       * resolver.resolveUrl('foo') // => 'bar.png'
       *
       * // Add custom data attached to the resolver
       * Resolver.add({
       *     alias: 'bunnyBooBooSmooth',
       *     src: 'bunny{png,webp}',
       *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options
       * });
       *
       * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }
       * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver
       */
      add(aliases) {
        const assets = [];
        if (Array.isArray(aliases)) {
          assets.push(...aliases);
        } else {
          assets.push(aliases);
        }
        let keyCheck;
        keyCheck = (key) => {
          if (this.hasKey(key)) {
            warn(`[Resolver] already has key: ${key} overwriting`);
          }
        };
        const assetArray = convertToList(assets);
        assetArray.forEach((asset) => {
          const { src, srcs } = asset;
          let { data, format: format2, loadParser } = asset;
          const srcsToUse = convertToList(src || srcs).map((src2) => {
            if (typeof src2 === "string") {
              return createStringVariations(src2);
            }
            return Array.isArray(src2) ? src2 : [src2];
          });
          const aliasesToUse = this.getAlias(asset);
          Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
          const resolvedAssets = [];
          srcsToUse.forEach((srcs2) => {
            srcs2.forEach((src2) => {
              let formattedAsset = {};
              if (typeof src2 !== "object") {
                formattedAsset.src = src2;
                for (let i2 = 0; i2 < this._parsers.length; i2++) {
                  const parser = this._parsers[i2];
                  if (parser.test(src2)) {
                    formattedAsset = parser.parse(src2);
                    break;
                  }
                }
              } else {
                data = src2.data ?? data;
                format2 = src2.format ?? format2;
                loadParser = src2.loadParser ?? loadParser;
                formattedAsset = {
                  ...formattedAsset,
                  ...src2
                };
              }
              if (!aliasesToUse) {
                throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
              }
              formattedAsset = this._buildResolvedAsset(formattedAsset, {
                aliases: aliasesToUse,
                data,
                format: format2,
                loadParser
              });
              resolvedAssets.push(formattedAsset);
            });
          });
          aliasesToUse.forEach((alias) => {
            this._assetMap[alias] = resolvedAssets;
          });
        });
      }
      // TODO: this needs an overload like load did in Assets
      /**
       * If the resolver has had a manifest set via setManifest, this will return the assets urls for
       * a given bundleId or bundleIds.
       * @example
       * // Manifest Example
       * const manifest = {
       *     bundles: [
       *         {
       *             name: 'load-screen',
       *             assets: [
       *                 {
       *                     alias: 'background',
       *                     src: 'sunset.png',
       *                 },
       *                 {
       *                     alias: 'bar',
       *                     src: 'load-bar.{png,webp}',
       *                 },
       *             ],
       *         },
       *         {
       *             name: 'game-screen',
       *             assets: [
       *                 {
       *                     alias: 'character',
       *                     src: 'robot.png',
       *                 },
       *                 {
       *                     alias: 'enemy',
       *                     src: 'bad-guy.png',
       *                 },
       *             ],
       *         },
       *     ]
       * };
       *
       * resolver.setManifest(manifest);
       * const resolved = resolver.resolveBundle('load-screen');
       * @param bundleIds - The bundle ids to resolve
       * @returns All the bundles assets or a hash of assets for each bundle specified
       */
      resolveBundle(bundleIds) {
        const singleAsset = isSingleItem(bundleIds);
        bundleIds = convertToList(bundleIds);
        const out2 = {};
        bundleIds.forEach((bundleId) => {
          const assetNames = this._bundles[bundleId];
          if (assetNames) {
            const results = this.resolve(assetNames);
            const assets = {};
            for (const key in results) {
              const asset = results[key];
              assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
            }
            out2[bundleId] = assets;
          }
        });
        return singleAsset ? out2[bundleIds[0]] : out2;
      }
      /**
       * Does exactly what resolve does, but returns just the URL rather than the whole asset object
       * @param key - The key or keys to resolve
       * @returns - The URLs associated with the key(s)
       */
      resolveUrl(key) {
        const result = this.resolve(key);
        if (typeof key !== "string") {
          const out2 = {};
          for (const i2 in result) {
            out2[i2] = result[i2].src;
          }
          return out2;
        }
        return result.src;
      }
      resolve(keys) {
        const singleAsset = isSingleItem(keys);
        keys = convertToList(keys);
        const result = {};
        keys.forEach((key) => {
          if (!this._resolverHash[key]) {
            if (this._assetMap[key]) {
              let assets = this._assetMap[key];
              const bestAsset = assets[0];
              const preferredOrder = this._getPreferredOrder(assets);
              preferredOrder?.priority.forEach((priorityKey) => {
                preferredOrder.params[priorityKey].forEach((value) => {
                  const filteredAssets = assets.filter((asset) => {
                    if (asset[priorityKey]) {
                      return asset[priorityKey] === value;
                    }
                    return false;
                  });
                  if (filteredAssets.length) {
                    assets = filteredAssets;
                  }
                });
              });
              this._resolverHash[key] = assets[0] ?? bestAsset;
            } else {
              this._resolverHash[key] = this._buildResolvedAsset({
                alias: [key],
                src: key
              }, {});
            }
          }
          result[key] = this._resolverHash[key];
        });
        return singleAsset ? result[keys[0]] : result;
      }
      /**
       * Checks if an asset with a given key exists in the resolver
       * @param key - The key of the asset
       */
      hasKey(key) {
        return !!this._assetMap[key];
      }
      /**
       * Checks if a bundle with the given key exists in the resolver
       * @param key - The key of the bundle
       */
      hasBundle(key) {
        return !!this._bundles[key];
      }
      /**
       * Internal function for figuring out what prefer criteria an asset should use.
       * @param assets
       */
      _getPreferredOrder(assets) {
        for (let i2 = 0; i2 < assets.length; i2++) {
          const asset = assets[0];
          const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
          if (preferred) {
            return preferred;
          }
        }
        return this._preferredOrder[0];
      }
      /**
       * Appends the default url parameters to the url
       * @param url - The url to append the default parameters to
       * @returns - The url with the default parameters appended
       */
      _appendDefaultSearchParams(url) {
        if (!this._defaultSearchParams)
          return url;
        const paramConnector = /\?/.test(url) ? "&" : "?";
        return `${url}${paramConnector}${this._defaultSearchParams}`;
      }
      _buildResolvedAsset(formattedAsset, data) {
        const { aliases, data: assetData, loadParser, format: format2 } = data;
        if (this._basePath || this._rootPath) {
          formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
        }
        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];
        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
        formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };
        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;
        formattedAsset.format = format2 ?? formattedAsset.src.split(".").pop();
        formattedAsset.srcs = formattedAsset.src;
        formattedAsset.name = formattedAsset.alias;
        return formattedAsset;
      }
    };
    Resolver.RETINA_PREFIX = /@([0-9\.]+)x/;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs
function getResolutionOfUrl(url, defaultValue2 = 1) {
  const resolution = Resolver.RETINA_PREFIX?.exec(url);
  if (resolution) {
    return parseFloat(resolution[1]);
  }
  return defaultValue2;
}
var init_getResolutionOfUrl = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs"() {
    init_Resolver();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/WorkerManager.mjs
var UUID, MAX_WORKERS, WHITE_PNG, checkImageBitmapCode, workerCode, workerURL, WorkerManagerClass, WorkerManager;
var init_WorkerManager = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/WorkerManager.mjs"() {
    UUID = 0;
    WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    checkImageBitmapCode = {
      id: "checkImageBitmap",
      code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${WHITE_PNG}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
    };
    workerCode = {
      id: "loadImageBitmap",
      code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
    };
    WorkerManagerClass = class {
      constructor() {
        this._initialized = false;
        this._createdWorkers = 0;
        this._workerPool = [];
        this._queue = [];
        this._resolveHash = {};
      }
      isImageBitmapSupported() {
        if (this._isImageBitmapSupported !== void 0)
          return this._isImageBitmapSupported;
        this._isImageBitmapSupported = new Promise((resolve) => {
          const workerURL2 = URL.createObjectURL(new Blob(
            [checkImageBitmapCode.code],
            { type: "application/javascript" }
          ));
          const worker = new Worker(workerURL2);
          worker.addEventListener("message", (event) => {
            worker.terminate();
            URL.revokeObjectURL(workerURL2);
            resolve(event.data);
          });
        });
        return this._isImageBitmapSupported;
      }
      loadImageBitmap(src) {
        return this._run("loadImageBitmap", [src]);
      }
      async _initWorkers() {
        if (this._initialized)
          return;
        this._initialized = true;
      }
      _getWorker() {
        if (MAX_WORKERS === void 0) {
          MAX_WORKERS = navigator.hardwareConcurrency || 4;
        }
        let worker = this._workerPool.pop();
        if (!worker && this._createdWorkers < MAX_WORKERS) {
          if (!workerURL) {
            workerURL = URL.createObjectURL(new Blob([workerCode.code], { type: "application/javascript" }));
          }
          this._createdWorkers++;
          worker = new Worker(workerURL);
          worker.addEventListener("message", (event) => {
            this._complete(event.data);
            this._returnWorker(event.target);
            this._next();
          });
        }
        return worker;
      }
      _returnWorker(worker) {
        this._workerPool.push(worker);
      }
      _complete(data) {
        if (data.error !== void 0) {
          this._resolveHash[data.uuid].reject(data.error);
        } else {
          this._resolveHash[data.uuid].resolve(data.data);
        }
        this._resolveHash[data.uuid] = null;
      }
      async _run(id, args) {
        await this._initWorkers();
        const promise2 = new Promise((resolve, reject) => {
          this._queue.push({ id, arguments: args, resolve, reject });
        });
        this._next();
        return promise2;
      }
      _next() {
        if (!this._queue.length)
          return;
        const worker = this._getWorker();
        if (!worker) {
          return;
        }
        const toDo = this._queue.pop();
        const id = toDo.id;
        this._resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };
        worker.postMessage({
          data: toDo.arguments,
          uuid: UUID++,
          id
        });
      }
    };
    WorkerManager = new WorkerManagerClass();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs
function createTexture(source3, loader, url) {
  const texture = new Texture({
    source: source3,
    label: url
  });
  const unload = () => {
    delete loader.promiseCache[url];
    if (Cache.has(url)) {
      Cache.remove(url);
    }
  };
  texture.once("destroy", () => {
    if (url in loader.promiseCache) {
      warn("[Assets] A BaseTexture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the BaseTexture.");
      unload();
    }
  });
  texture.source.once("destroy", () => {
    if (!source3.destroyed) {
      warn("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.");
      unload();
    }
  });
  return texture;
}
var init_createTexture = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs"() {
    init_Texture();
    init_warn();
    init_Cache();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs
async function loadImageBitmap(url) {
  const response = await DOMAdapter.get().fetch(url);
  if (!response.ok) {
    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);
  }
  const imageBlob = await response.blob();
  const imageBitmap = await createImageBitmap(imageBlob);
  return imageBitmap;
}
var validImageExtensions, validImageMIMEs, loadTextures;
var init_loadTextures = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs"() {
    init_Extensions();
    init_ImageSource();
    init_adapter();
    init_getResolutionOfUrl();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    init_WorkerManager();
    init_createTexture();
    validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
    validImageMIMEs = [
      "image/jpeg",
      "image/png",
      "image/webp",
      "image/avif"
    ];
    loadTextures = {
      name: "loadTextures",
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.High
      },
      config: {
        preferWorkers: true,
        preferCreateImageBitmap: true,
        crossOrigin: "anonymous"
      },
      test(url) {
        return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);
      },
      async load(url, asset, loader) {
        let src = null;
        if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {
          if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {
            src = await WorkerManager.loadImageBitmap(url);
          } else {
            src = await loadImageBitmap(url);
          }
        } else {
          src = await new Promise((resolve) => {
            src = new Image();
            src.crossOrigin = this.config.crossOrigin;
            src.src = url;
            if (src.complete) {
              resolve(src);
            } else {
              src.onload = () => {
                resolve(src);
              };
            }
          });
        }
        const base = new ImageSource({
          resource: src,
          alphaMode: "premultiply-alpha-on-upload",
          resolution: asset.data?.resolution || getResolutionOfUrl(url),
          ...asset.data
        });
        return createTexture(base, loader, url);
      },
      unload(texture) {
        texture.destroy(true);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs
async function detectVideoAlphaMode() {
  promise ?? (promise = (async () => {
    const canvas2 = document.createElement("canvas");
    const gl = canvas2.getContext("webgl");
    if (!gl) {
      return "premultiply-alpha-on-upload";
    }
    const video = await new Promise((resolve) => {
      const video2 = document.createElement("video");
      video2.onloadeddata = () => resolve(video2);
      video2.onerror = () => resolve(null);
      video2.autoplay = false;
      video2.crossOrigin = "anonymous";
      video2.preload = "auto";
      video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";
      video2.load();
    });
    if (!video) {
      return "premultiply-alpha-on-upload";
    }
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    const framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      texture,
      0
    );
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
    const pixel = new Uint8Array(4);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
    gl.deleteFramebuffer(framebuffer);
    gl.deleteTexture(texture);
    gl.getExtension("WEBGL_lose_context")?.loseContext();
    return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
  })());
  return promise;
}
var promise;
var init_detectVideoAlphaMode = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs
var _VideoSource, VideoSource;
var init_VideoSource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs"() {
    init_Extensions();
    init_Ticker();
    init_detectVideoAlphaMode();
    init_TextureSource();
    _VideoSource = class extends TextureSource {
      constructor(options) {
        super(options);
        this.isReady = false;
        this.uploadMethodId = "video";
        options = {
          ..._VideoSource.defaultOptions,
          ...options
        };
        this._autoUpdate = true;
        this._isConnectedToTicker = false;
        this._updateFPS = options.updateFPS || 0;
        this._msToNextUpdate = 0;
        this.autoPlay = options.autoPlay !== false;
        this.alphaMode = options.alphaMode ?? "premultiply-alpha-on-upload";
        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);
        this._videoFrameRequestCallbackHandle = null;
        this._load = null;
        this._resolve = null;
        this._reject = null;
        this._onCanPlay = this._onCanPlay.bind(this);
        this._onError = this._onError.bind(this);
        this._onPlayStart = this._onPlayStart.bind(this);
        this._onPlayStop = this._onPlayStop.bind(this);
        this._onSeeked = this._onSeeked.bind(this);
        if (options.autoLoad !== false) {
          void this.load();
        }
      }
      /** Update the video frame if the source is not destroyed and meets certain conditions. */
      updateFrame() {
        if (this.destroyed) {
          return;
        }
        if (this._updateFPS) {
          const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;
          this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
        }
        if (!this._updateFPS || this._msToNextUpdate <= 0) {
          this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
        }
        if (this.isValid) {
          this.update();
        }
      }
      /** Callback to update the video frame and potentially request the next frame update. */
      _videoFrameRequestCallback() {
        this.updateFrame();
        if (this.destroyed) {
          this._videoFrameRequestCallbackHandle = null;
        } else {
          this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(
            this._videoFrameRequestCallback
          );
        }
      }
      /**
       * Checks if the resource has valid dimensions.
       * @returns {boolean} True if width and height are set, otherwise false.
       */
      get isValid() {
        return !!this.resource.videoWidth && !!this.resource.videoHeight;
      }
      /**
       * Start preloading the video resource.
       * @returns {Promise<this>} Handle the validate event
       */
      async load() {
        if (this._load) {
          return this._load;
        }
        const source3 = this.resource;
        if ((source3.readyState === source3.HAVE_ENOUGH_DATA || source3.readyState === source3.HAVE_FUTURE_DATA) && source3.width && source3.height) {
          source3.complete = true;
        }
        source3.addEventListener("play", this._onPlayStart);
        source3.addEventListener("pause", this._onPlayStop);
        source3.addEventListener("seeked", this._onSeeked);
        if (!this._isSourceReady()) {
          const options = this.options;
          if (!options.preload) {
            source3.addEventListener("canplay", this._onCanPlay);
          }
          source3.addEventListener("canplaythrough", this._onCanPlay);
          source3.addEventListener("error", this._onError, true);
        } else {
          this._onCanPlay();
        }
        this.alphaMode = await detectVideoAlphaMode();
        this._load = new Promise((resolve, reject) => {
          if (this.isValid) {
            resolve(this);
          } else {
            this._resolve = resolve;
            this._reject = reject;
            source3.load();
          }
        });
        return this._load;
      }
      /**
       * Handle video error events.
       * @param event - The error event
       */
      _onError(event) {
        this.resource.removeEventListener("error", this._onError, true);
        this.emit("error", event);
        if (this._reject) {
          this._reject(event);
          this._reject = null;
          this._resolve = null;
        }
      }
      /**
       * Checks if the underlying source is playing.
       * @returns True if playing.
       */
      _isSourcePlaying() {
        const source3 = this.resource;
        return !source3.paused && !source3.ended;
      }
      /**
       * Checks if the underlying source is ready for playing.
       * @returns True if ready.
       */
      _isSourceReady() {
        const source3 = this.resource;
        return source3.readyState > 2;
      }
      /** Runs the update loop when the video is ready to play. */
      _onPlayStart() {
        if (!this.isValid) {
          this._onCanPlay();
        }
        this._configureAutoUpdate();
      }
      /** Stops the update loop when a pause event is triggered. */
      _onPlayStop() {
        this._configureAutoUpdate();
      }
      /** Handles behavior when the video completes seeking to the current playback position. */
      _onSeeked() {
        if (this._autoUpdate && !this._isSourcePlaying()) {
          this._msToNextUpdate = 0;
          this.updateFrame();
          this._msToNextUpdate = 0;
        }
      }
      /** Fired when the video is loaded and ready to play. */
      _onCanPlay() {
        const source3 = this.resource;
        source3.removeEventListener("canplay", this._onCanPlay);
        source3.removeEventListener("canplaythrough", this._onCanPlay);
        if (this.isValid) {
          this.isReady = true;
          this.resize(source3.videoWidth, source3.videoHeight);
        }
        this._msToNextUpdate = 0;
        this.updateFrame();
        this._msToNextUpdate = 0;
        if (this._resolve) {
          this._resolve(this);
          this._resolve = null;
          this._reject = null;
        }
        if (this._isSourcePlaying()) {
          this._onPlayStart();
        } else if (this.autoPlay) {
          void this.resource.play();
        }
      }
      /** Cleans up resources and event listeners associated with this texture. */
      destroy() {
        this._configureAutoUpdate();
        const source3 = this.resource;
        if (source3) {
          source3.removeEventListener("play", this._onPlayStart);
          source3.removeEventListener("pause", this._onPlayStop);
          source3.removeEventListener("seeked", this._onSeeked);
          source3.removeEventListener("canplay", this._onCanPlay);
          source3.removeEventListener("canplaythrough", this._onCanPlay);
          source3.removeEventListener("error", this._onError, true);
          source3.pause();
          source3.src = "";
          source3.load();
        }
        super.destroy();
      }
      /** Should the base texture automatically update itself, set to true by default. */
      get autoUpdate() {
        return this._autoUpdate;
      }
      set autoUpdate(value) {
        if (value !== this._autoUpdate) {
          this._autoUpdate = value;
          this._configureAutoUpdate();
        }
      }
      /**
       * How many times a second to update the texture from the video.
       * Leave at 0 to update at every render.
       * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
       */
      get updateFPS() {
        return this._updateFPS;
      }
      set updateFPS(value) {
        if (value !== this._updateFPS) {
          this._updateFPS = value;
          this._configureAutoUpdate();
        }
      }
      /**
       * Configures the updating mechanism based on the current state and settings.
       *
       * This method decides between using the browser's native video frame callback or a custom ticker
       * for updating the video frame. It ensures optimal performance and responsiveness
       * based on the video's state, playback status, and the desired frames-per-second setting.
       *
       * - If `_autoUpdate` is enabled and the video source is playing:
       *   - It will prefer the native video frame callback if available and no specific FPS is set.
       *   - Otherwise, it will use a custom ticker for manual updates.
       * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.
       */
      _configureAutoUpdate() {
        if (this._autoUpdate && this._isSourcePlaying()) {
          if (!this._updateFPS && this.source.requestVideoFrameCallback) {
            if (this._isConnectedToTicker) {
              Ticker.shared.remove(this.updateFrame, this);
              this._isConnectedToTicker = false;
              this._msToNextUpdate = 0;
            }
            if (this._videoFrameRequestCallbackHandle === null) {
              this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(
                this._videoFrameRequestCallback
              );
            }
          } else {
            if (this._videoFrameRequestCallbackHandle !== null) {
              this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
              this._videoFrameRequestCallbackHandle = null;
            }
            if (!this._isConnectedToTicker) {
              Ticker.shared.add(this.updateFrame, this);
              this._isConnectedToTicker = true;
              this._msToNextUpdate = 0;
            }
          }
        } else {
          if (this._videoFrameRequestCallbackHandle !== null) {
            this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
            this._videoFrameRequestCallbackHandle = null;
          }
          if (this._isConnectedToTicker) {
            Ticker.shared.remove(this.updateFrame, this);
            this._isConnectedToTicker = false;
            this._msToNextUpdate = 0;
          }
        }
      }
      static test(resource) {
        return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement || globalThis.VideoFrame && resource instanceof VideoFrame;
      }
    };
    VideoSource = _VideoSource;
    VideoSource.extension = ExtensionType.TextureSource;
    VideoSource.defaultOptions = {
      ...TextureSource.defaultOptions,
      autoLoad: true,
      autoPlay: true,
      updateFPS: 0,
      crossorigin: true,
      loop: false,
      muted: true,
      playsinline: true,
      preload: false
    };
    VideoSource.MIME_TYPES = {
      ogv: "video/ogg",
      mov: "video/quicktime",
      m4v: "video/mp4"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs
function crossOrigin(element, url, crossorigin) {
  if (crossorigin === void 0 && !url.startsWith("data:")) {
    element.crossOrigin = determineCrossOrigin(url);
  } else if (crossorigin !== false) {
    element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
  }
}
function determineCrossOrigin(url, loc = globalThis.location) {
  if (url.startsWith("data:")) {
    return "";
  }
  loc = loc || globalThis.location;
  const parsedUrl = new URL(url, document.baseURI);
  if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {
    return "anonymous";
  }
  return "";
}
var validVideoExtensions, validVideoMIMEs, loadVideoTextures;
var init_loadVideoTextures = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs"() {
    init_Extensions();
    init_VideoSource();
    init_detectVideoAlphaMode();
    init_getResolutionOfUrl();
    init_checkDataUrl();
    init_checkExtension();
    init_createTexture();
    validVideoExtensions = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"];
    validVideoMIMEs = validVideoExtensions.map((ext) => `video/${ext.substring(1)}`);
    loadVideoTextures = {
      name: "loadVideo",
      extension: {
        type: ExtensionType.LoadParser
      },
      config: null,
      test(url) {
        const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);
        const isValidExtension = checkExtension(url, validVideoExtensions);
        return isValidDataUrl || isValidExtension;
      },
      async load(url, asset, loader) {
        const options = {
          ...VideoSource.defaultOptions,
          resolution: asset.data?.resolution || getResolutionOfUrl(url),
          alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode(),
          ...asset.data
        };
        const videoElement = document.createElement("video");
        const attributeMap = {
          preload: options.autoLoad !== false ? "auto" : void 0,
          "webkit-playsinline": options.playsinline !== false ? "" : void 0,
          playsinline: options.playsinline !== false ? "" : void 0,
          muted: options.muted === true ? "" : void 0,
          loop: options.loop === true ? "" : void 0,
          autoplay: options.autoPlay !== false ? "" : void 0
        };
        Object.keys(attributeMap).forEach((key) => {
          const value = attributeMap[key];
          if (value !== void 0)
            videoElement.setAttribute(key, value);
        });
        if (options.muted === true) {
          videoElement.muted = true;
        }
        crossOrigin(videoElement, url, options.crossorigin);
        const sourceElement = document.createElement("source");
        let mime;
        if (url.startsWith("data:")) {
          mime = url.slice(5, url.indexOf(";"));
        } else if (!url.startsWith("blob:")) {
          const ext = url.split("?")[0].slice(url.lastIndexOf(".") + 1).toLowerCase();
          mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;
        }
        sourceElement.src = url;
        if (mime) {
          sourceElement.type = mime;
        }
        videoElement.appendChild(sourceElement);
        const base = new VideoSource({ ...options, resource: videoElement });
        return createTexture(base, loader, url);
      },
      unload(texture) {
        texture.destroy(true);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs
var resolveTextureUrl;
var init_resolveTextureUrl = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs"() {
    init_Extensions();
    init_loadTextures();
    init_Resolver();
    resolveTextureUrl = {
      extension: ExtensionType.ResolveParser,
      test: loadTextures.test,
      parse: (value) => ({
        resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
        format: value.split(".").pop(),
        src: value
      })
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/init.mjs
var assetKeyMap;
var init_init3 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/init.mjs"() {
    init_Extensions();
    init_loadBitmapFont();
    init_cacheTextureArray();
    init_detectAvif();
    init_detectDefaults();
    init_detectMp4();
    init_detectOgv();
    init_detectWebm();
    init_detectWebp();
    init_loadJson();
    init_loadTxt();
    init_loadWebFont();
    init_loadSVG();
    init_loadTextures();
    init_loadVideoTextures();
    init_resolveTextureUrl();
    extensions.add(
      cacheTextureArray,
      detectDefaults,
      detectAvif,
      detectWebp,
      detectMp4,
      detectOgv,
      detectWebm,
      loadJson,
      loadTxt,
      loadWebFont,
      loadSvg,
      loadTextures,
      loadVideoTextures,
      resolveTextureUrl,
      // TODO: these should probably be moved to its own init, along with splitting out all the
      // text pipeline stuff
      xmlBitmapFontLoader,
      bitmapFontCachePlugin
    );
    assetKeyMap = {
      loader: ExtensionType.LoadParser,
      resolver: ExtensionType.ResolveParser,
      cache: ExtensionType.CacheParser,
      detection: ExtensionType.DetectionParser
    };
    extensions.handle(ExtensionType.Asset, (extension) => {
      const ref = extension.ref;
      Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => extensions.add(Object.assign(
        ref[key],
        // Allow the function to optionally define it's own
        // ExtensionMetadata, the use cases here is priority for LoaderParsers
        { extension: ref[key].extension ?? type }
      )));
    }, (extension) => {
      const ref = extension.ref;
      Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => extensions.remove(ref[key]));
    });
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/EventTicker.mjs
var EventsTickerClass, EventsTicker;
var init_EventTicker = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/EventTicker.mjs"() {
    init_const2();
    init_Ticker();
    EventsTickerClass = class {
      constructor() {
        this.interactionFrequency = 10;
        this._deltaTime = 0;
        this._didMove = false;
        this._tickerAdded = false;
        this._pauseUpdate = true;
      }
      /**
       * Initializes the event ticker.
       * @param events - The event system.
       */
      init(events) {
        this.removeTickerListener();
        this.events = events;
        this.interactionFrequency = 10;
        this._deltaTime = 0;
        this._didMove = false;
        this._tickerAdded = false;
        this._pauseUpdate = true;
      }
      /** Whether to pause the update checks or not. */
      get pauseUpdate() {
        return this._pauseUpdate;
      }
      set pauseUpdate(paused) {
        this._pauseUpdate = paused;
      }
      /** Adds the ticker listener. */
      addTickerListener() {
        if (this._tickerAdded || !this.domElement) {
          return;
        }
        Ticker.system.add(this._tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
        this._tickerAdded = true;
      }
      /** Removes the ticker listener. */
      removeTickerListener() {
        if (!this._tickerAdded) {
          return;
        }
        Ticker.system.remove(this._tickerUpdate, this);
        this._tickerAdded = false;
      }
      /** Sets flag to not fire extra events when the user has already moved there mouse */
      pointerMoved() {
        this._didMove = true;
      }
      /** Updates the state of interactive objects. */
      _update() {
        if (!this.domElement || this._pauseUpdate) {
          return;
        }
        if (this._didMove) {
          this._didMove = false;
          return;
        }
        const rootPointerEvent = this.events["_rootPointerEvent"];
        if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
          return;
        }
        globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
          clientX: rootPointerEvent.clientX,
          clientY: rootPointerEvent.clientY
        }));
      }
      /**
       * Updates the state of interactive objects if at least {@link interactionFrequency}
       * milliseconds have passed since the last invocation.
       *
       * Invoked by a throttled ticker update from {@link Ticker.system}.
       * @param ticker - The throttled ticker.
       */
      _tickerUpdate(ticker) {
        this._deltaTime += ticker.deltaTime;
        if (this._deltaTime < this.interactionFrequency) {
          return;
        }
        this._deltaTime = 0;
        this._update();
      }
    };
    EventsTicker = new EventsTickerClass();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs
var FederatedMouseEvent;
var init_FederatedMouseEvent = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs"() {
    init_Point();
    init_FederatedEvent();
    FederatedMouseEvent = class extends FederatedEvent {
      constructor() {
        super(...arguments);
        this.client = new Point();
        this.movement = new Point();
        this.offset = new Point();
        this.global = new Point();
        this.screen = new Point();
      }
      /** @readonly */
      get clientX() {
        return this.client.x;
      }
      /** @readonly */
      get clientY() {
        return this.client.y;
      }
      /**
       * Alias for {@link FederatedMouseEvent.clientX this.clientX}.
       * @readonly
       */
      get x() {
        return this.clientX;
      }
      /**
       * Alias for {@link FederatedMouseEvent.clientY this.clientY}.
       * @readonly
       */
      get y() {
        return this.clientY;
      }
      /** @readonly */
      get movementX() {
        return this.movement.x;
      }
      /** @readonly */
      get movementY() {
        return this.movement.y;
      }
      /** @readonly */
      get offsetX() {
        return this.offset.x;
      }
      /** @readonly */
      get offsetY() {
        return this.offset.y;
      }
      /** @readonly */
      get globalX() {
        return this.global.x;
      }
      /** @readonly */
      get globalY() {
        return this.global.y;
      }
      /**
       * The pointer coordinates in the renderer's screen. Alias for {@code screen.x}.
       * @readonly
       */
      get screenX() {
        return this.screen.x;
      }
      /**
       * The pointer coordinates in the renderer's screen. Alias for {@code screen.y}.
       * @readonly
       */
      get screenY() {
        return this.screen.y;
      }
      /**
       * This will return the local coordinates of the specified container for this InteractionData
       * @param {Container} container - The Container that you would like the local
       *  coords off
       * @param {PointData} point - A Point object in which to store the value, optional (otherwise
       *  will create a new point)
       * @param {PointData} globalPos - A Point object containing your custom global coords, optional
       *  (otherwise will use the current global coords)
       * @returns - A point containing the coordinates of the InteractionData position relative
       *  to the Container
       */
      getLocalPosition(container, point, globalPos) {
        return container.worldTransform.applyInverse(globalPos || this.global, point);
      }
      /**
       * Whether the modifier key was pressed when this event natively occurred.
       * @param key - The modifier key.
       */
      getModifierState(key) {
        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
      }
      /**
       * Not supported.
       * @param _typeArg
       * @param _canBubbleArg
       * @param _cancelableArg
       * @param _viewArg
       * @param _detailArg
       * @param _screenXArg
       * @param _screenYArg
       * @param _clientXArg
       * @param _clientYArg
       * @param _ctrlKeyArg
       * @param _altKeyArg
       * @param _shiftKeyArg
       * @param _metaKeyArg
       * @param _buttonArg
       * @param _relatedTargetArg
       * @deprecated since 7.0.0
       */
      // eslint-disable-next-line max-params
      initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
        throw new Error("Method not implemented.");
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs
var FederatedPointerEvent;
var init_FederatedPointerEvent = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs"() {
    init_FederatedMouseEvent();
    FederatedPointerEvent = class extends FederatedMouseEvent {
      constructor() {
        super(...arguments);
        this.width = 0;
        this.height = 0;
        this.isPrimary = false;
      }
      // Only included for completeness for now
      getCoalescedEvents() {
        if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
          return [this];
        }
        return [];
      }
      // Only included for completeness for now
      getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!");
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs
var FederatedWheelEvent;
var init_FederatedWheelEvent = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs"() {
    init_FederatedMouseEvent();
    FederatedWheelEvent = class extends FederatedMouseEvent {
      constructor() {
        super(...arguments);
        this.DOM_DELTA_PIXEL = 0;
        this.DOM_DELTA_LINE = 1;
        this.DOM_DELTA_PAGE = 2;
      }
    };
    FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
    FederatedWheelEvent.DOM_DELTA_LINE = 1;
    FederatedWheelEvent.DOM_DELTA_PAGE = 2;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/EventBoundary.mjs
var PROPAGATION_LIMIT, tempHitLocation, tempLocalMapping, EventBoundary;
var init_EventBoundary = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/EventBoundary.mjs"() {
    init_eventemitter3();
    init_Point();
    init_warn();
    init_EventTicker();
    init_FederatedMouseEvent();
    init_FederatedPointerEvent();
    init_FederatedWheelEvent();
    PROPAGATION_LIMIT = 2048;
    tempHitLocation = new Point();
    tempLocalMapping = new Point();
    EventBoundary = class {
      /**
       * @param rootTarget - The holder of the event boundary.
       */
      constructor(rootTarget) {
        this.dispatch = new eventemitter3_default();
        this.moveOnAll = false;
        this.enableGlobalMoveEvents = true;
        this.mappingState = {
          trackingData: {}
        };
        this.eventPool = /* @__PURE__ */ new Map();
        this._allInteractiveElements = [];
        this._hitElements = [];
        this._isPointerMoveEvent = false;
        this.rootTarget = rootTarget;
        this.hitPruneFn = this.hitPruneFn.bind(this);
        this.hitTestFn = this.hitTestFn.bind(this);
        this.mapPointerDown = this.mapPointerDown.bind(this);
        this.mapPointerMove = this.mapPointerMove.bind(this);
        this.mapPointerOut = this.mapPointerOut.bind(this);
        this.mapPointerOver = this.mapPointerOver.bind(this);
        this.mapPointerUp = this.mapPointerUp.bind(this);
        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
        this.mapWheel = this.mapWheel.bind(this);
        this.mappingTable = {};
        this.addEventMapping("pointerdown", this.mapPointerDown);
        this.addEventMapping("pointermove", this.mapPointerMove);
        this.addEventMapping("pointerout", this.mapPointerOut);
        this.addEventMapping("pointerleave", this.mapPointerOut);
        this.addEventMapping("pointerover", this.mapPointerOver);
        this.addEventMapping("pointerup", this.mapPointerUp);
        this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
        this.addEventMapping("wheel", this.mapWheel);
      }
      /**
       * Adds an event mapping for the event `type` handled by `fn`.
       *
       * Event mappings can be used to implement additional or custom events. They take an event
       * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events
       * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.
       *
       * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden
       * instead.
       * @param type - The type of upstream event to map.
       * @param fn - The mapping method. The context of this function must be bound manually, if desired.
       */
      addEventMapping(type, fn) {
        if (!this.mappingTable[type]) {
          this.mappingTable[type] = [];
        }
        this.mappingTable[type].push({
          fn,
          priority: 0
        });
        this.mappingTable[type].sort((a2, b2) => a2.priority - b2.priority);
      }
      /**
       * Dispatches the given event
       * @param e
       * @param type
       */
      dispatchEvent(e2, type) {
        e2.propagationStopped = false;
        e2.propagationImmediatelyStopped = false;
        this.propagate(e2, type);
        this.dispatch.emit(type || e2.type, e2);
      }
      /**
       * Maps the given upstream event through the event boundary and propagates it downstream.
       * @param e
       */
      mapEvent(e2) {
        if (!this.rootTarget) {
          return;
        }
        const mappers = this.mappingTable[e2.type];
        if (mappers) {
          for (let i2 = 0, j3 = mappers.length; i2 < j3; i2++) {
            mappers[i2].fn(e2);
          }
        } else {
          warn(`[EventBoundary]: Event mapping not defined for ${e2.type}`);
        }
      }
      /**
       * Finds the Container that is the target of a event at the given coordinates.
       *
       * The passed (x,y) coordinates are in the world space above this event boundary.
       * @param x
       * @param y
       */
      hitTest(x3, y2) {
        EventsTicker.pauseUpdate = true;
        const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
        const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
        const invertedPath = this[fn](
          this.rootTarget,
          this.rootTarget.eventMode,
          tempHitLocation.set(x3, y2),
          this.hitTestFn,
          this.hitPruneFn
        );
        return invertedPath && invertedPath[0];
      }
      /**
       * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its
       * target {@code e.target}.
       * @param e - The event to propagate.
       * @param type
       */
      propagate(e2, type) {
        if (!e2.target) {
          return;
        }
        const composedPath = e2.composedPath();
        e2.eventPhase = e2.CAPTURING_PHASE;
        for (let i2 = 0, j3 = composedPath.length - 1; i2 < j3; i2++) {
          e2.currentTarget = composedPath[i2];
          this.notifyTarget(e2, type);
          if (e2.propagationStopped || e2.propagationImmediatelyStopped)
            return;
        }
        e2.eventPhase = e2.AT_TARGET;
        e2.currentTarget = e2.target;
        this.notifyTarget(e2, type);
        if (e2.propagationStopped || e2.propagationImmediatelyStopped)
          return;
        e2.eventPhase = e2.BUBBLING_PHASE;
        for (let i2 = composedPath.length - 2; i2 >= 0; i2--) {
          e2.currentTarget = composedPath[i2];
          this.notifyTarget(e2, type);
          if (e2.propagationStopped || e2.propagationImmediatelyStopped)
            return;
        }
      }
      /**
       * Emits the event {@code e} to all interactive containers. The event is propagated in the bubbling phase always.
       *
       * This is used in the `globalpointermove` event.
       * @param e - The emitted event.
       * @param type - The listeners to notify.
       * @param targets - The targets to notify.
       */
      all(e2, type, targets = this._allInteractiveElements) {
        if (targets.length === 0)
          return;
        e2.eventPhase = e2.BUBBLING_PHASE;
        const events = Array.isArray(type) ? type : [type];
        for (let i2 = targets.length - 1; i2 >= 0; i2--) {
          events.forEach((event) => {
            e2.currentTarget = targets[i2];
            this.notifyTarget(e2, event);
          });
        }
      }
      /**
       * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed
       * {@code target}. The last element in the path is {@code target}.
       * @param target
       */
      propagationPath(target) {
        const propagationPath = [target];
        for (let i2 = 0; i2 < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i2++) {
          if (!target.parent) {
            throw new Error("Cannot find propagation path to disconnected target");
          }
          propagationPath.push(target.parent);
          target = target.parent;
        }
        propagationPath.reverse();
        return propagationPath;
      }
      hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
        let shouldReturn = false;
        if (this._interactivePrune(currentTarget))
          return null;
        if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
          EventsTicker.pauseUpdate = false;
        }
        if (currentTarget.interactiveChildren && currentTarget.children) {
          const children = currentTarget.children;
          for (let i2 = children.length - 1; i2 >= 0; i2--) {
            const child = children[i2];
            const nestedHit = this.hitTestMoveRecursive(
              child,
              this._isInteractive(eventMode) ? eventMode : child.eventMode,
              location,
              testFn,
              pruneFn,
              ignore || pruneFn(currentTarget, location)
            );
            if (nestedHit) {
              if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                continue;
              }
              const isInteractive = currentTarget.isInteractive();
              if (nestedHit.length > 0 || isInteractive) {
                if (isInteractive)
                  this._allInteractiveElements.push(currentTarget);
                nestedHit.push(currentTarget);
              }
              if (this._hitElements.length === 0)
                this._hitElements = nestedHit;
              shouldReturn = true;
            }
          }
        }
        const isInteractiveMode = this._isInteractive(eventMode);
        const isInteractiveTarget = currentTarget.isInteractive();
        if (isInteractiveTarget && isInteractiveTarget)
          this._allInteractiveElements.push(currentTarget);
        if (ignore || this._hitElements.length > 0)
          return null;
        if (shouldReturn)
          return this._hitElements;
        if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {
          return isInteractiveTarget ? [currentTarget] : [];
        }
        return null;
      }
      /**
       * Recursive implementation for {@link EventBoundary.hitTest hitTest}.
       * @param currentTarget - The Container that is to be hit tested.
       * @param eventMode - The event mode for the `currentTarget` or one of its parents.
       * @param location - The location that is being tested for overlap.
       * @param testFn - Callback that determines whether the target passes hit testing. This callback
       *  can assume that `pruneFn` failed to prune the container.
       * @param pruneFn - Callback that determiness whether the target and all of its children
       *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees
       *  of the scene graph.
       * @returns An array holding the hit testing target and all its ancestors in order. The first element
       *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite
       *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.
       */
      hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
        if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
          return null;
        }
        if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
          EventsTicker.pauseUpdate = false;
        }
        if (currentTarget.interactiveChildren && currentTarget.children) {
          const children = currentTarget.children;
          const relativeLocation = location;
          for (let i2 = children.length - 1; i2 >= 0; i2--) {
            const child = children[i2];
            const nestedHit = this.hitTestRecursive(
              child,
              this._isInteractive(eventMode) ? eventMode : child.eventMode,
              relativeLocation,
              testFn,
              pruneFn
            );
            if (nestedHit) {
              if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                continue;
              }
              const isInteractive = currentTarget.isInteractive();
              if (nestedHit.length > 0 || isInteractive)
                nestedHit.push(currentTarget);
              return nestedHit;
            }
          }
        }
        const isInteractiveMode = this._isInteractive(eventMode);
        const isInteractiveTarget = currentTarget.isInteractive();
        if (isInteractiveMode && testFn(currentTarget, location)) {
          return isInteractiveTarget ? [currentTarget] : [];
        }
        return null;
      }
      _isInteractive(int) {
        return int === "static" || int === "dynamic";
      }
      _interactivePrune(container) {
        if (!container || !container.visible || !container.renderable) {
          return true;
        }
        if (container.eventMode === "none") {
          return true;
        }
        if (container.eventMode === "passive" && !container.interactiveChildren) {
          return true;
        }
        return false;
      }
      /**
       * Checks whether the container or any of its children cannot pass the hit test at all.
       *
       * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}
       * and {@link Container._mask} for pruning.
       * @param container
       * @param location
       */
      hitPruneFn(container, location) {
        if (container.hitArea) {
          container.worldTransform.applyInverse(location, tempLocalMapping);
          if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
            return true;
          }
        }
        if (container.effects && container.effects.length) {
          for (let i2 = 0; i2 < container.effects.length; i2++) {
            const effect = container.effects[i2];
            if (effect.containsPoint) {
              const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);
              if (!effectContainsPoint) {
                return true;
              }
            }
          }
        }
        return false;
      }
      /**
       * Checks whether the container passes hit testing for the given location.
       * @param container
       * @param location
       * @returns - Whether `container` passes hit testing for `location`.
       */
      hitTestFn(container, location) {
        if (container.hitArea) {
          return true;
        }
        if (container.view?.containsPoint) {
          container.worldTransform.applyInverse(location, tempLocalMapping);
          return container.view.containsPoint(tempLocalMapping);
        }
        return false;
      }
      /**
       * Notify all the listeners to the event's `currentTarget`.
       *
       * If the `currentTarget` contains the property `on<type>`, then it is called here,
       * simulating the behavior from version 6.x and prior.
       * @param e - The event passed to the target.
       * @param type
       */
      notifyTarget(e2, type) {
        type = type ?? e2.type;
        const handlerKey = `on${type}`;
        e2.currentTarget[handlerKey]?.(e2);
        const key = e2.eventPhase === e2.CAPTURING_PHASE || e2.eventPhase === e2.AT_TARGET ? `${type}capture` : type;
        this._notifyListeners(e2, key);
        if (e2.eventPhase === e2.AT_TARGET) {
          this._notifyListeners(e2, type);
        }
      }
      /**
       * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.
       *
       * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.
       * @param from
       */
      mapPointerDown(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const e2 = this.createPointerEvent(from);
        this.dispatchEvent(e2, "pointerdown");
        if (e2.pointerType === "touch") {
          this.dispatchEvent(e2, "touchstart");
        } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
          const isRightButton = e2.button === 2;
          this.dispatchEvent(e2, isRightButton ? "rightdown" : "mousedown");
        }
        const trackingData = this.trackingData(from.pointerId);
        trackingData.pressTargetsByButton[from.button] = e2.composedPath();
        this.freeEvent(e2);
      }
      /**
       * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.
       *
       * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,
       * `mousemove`, and `touchmove` events are fired as well for specific pointer types.
       * @param from - The upstream `pointermove` event.
       */
      mapPointerMove(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        this._allInteractiveElements.length = 0;
        this._hitElements.length = 0;
        this._isPointerMoveEvent = true;
        const e2 = this.createPointerEvent(from);
        this._isPointerMoveEvent = false;
        const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
        const trackingData = this.trackingData(from.pointerId);
        const outTarget = this.findMountedTarget(trackingData.overTargets);
        if (trackingData.overTargets?.length > 0 && outTarget !== e2.target) {
          const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
          const outEvent = this.createPointerEvent(from, outType, outTarget);
          this.dispatchEvent(outEvent, "pointerout");
          if (isMouse)
            this.dispatchEvent(outEvent, "mouseout");
          if (!e2.composedPath().includes(outTarget)) {
            const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
            leaveEvent.eventPhase = leaveEvent.AT_TARGET;
            while (leaveEvent.target && !e2.composedPath().includes(leaveEvent.target)) {
              leaveEvent.currentTarget = leaveEvent.target;
              this.notifyTarget(leaveEvent);
              if (isMouse)
                this.notifyTarget(leaveEvent, "mouseleave");
              leaveEvent.target = leaveEvent.target.parent;
            }
            this.freeEvent(leaveEvent);
          }
          this.freeEvent(outEvent);
        }
        if (outTarget !== e2.target) {
          const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
          const overEvent = this.clonePointerEvent(e2, overType);
          this.dispatchEvent(overEvent, "pointerover");
          if (isMouse)
            this.dispatchEvent(overEvent, "mouseover");
          let overTargetAncestor = outTarget?.parent;
          while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
            if (overTargetAncestor === e2.target)
              break;
            overTargetAncestor = overTargetAncestor.parent;
          }
          const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
          if (didPointerEnter) {
            const enterEvent = this.clonePointerEvent(e2, "pointerenter");
            enterEvent.eventPhase = enterEvent.AT_TARGET;
            while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
              enterEvent.currentTarget = enterEvent.target;
              this.notifyTarget(enterEvent);
              if (isMouse)
                this.notifyTarget(enterEvent, "mouseenter");
              enterEvent.target = enterEvent.target.parent;
            }
            this.freeEvent(enterEvent);
          }
          this.freeEvent(overEvent);
        }
        const allMethods = [];
        const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
        this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e2, "pointermove");
        allowGlobalPointerEvents && allMethods.push("globalpointermove");
        if (e2.pointerType === "touch") {
          this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e2, "touchmove");
          allowGlobalPointerEvents && allMethods.push("globaltouchmove");
        }
        if (isMouse) {
          this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e2, "mousemove");
          allowGlobalPointerEvents && allMethods.push("globalmousemove");
          this.cursor = e2.target?.cursor;
        }
        if (allMethods.length > 0) {
          this.all(e2, allMethods);
        }
        this._allInteractiveElements.length = 0;
        this._hitElements.length = 0;
        trackingData.overTargets = e2.composedPath();
        this.freeEvent(e2);
      }
      /**
       * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.
       *
       * The tracking data for the specific pointer gets a new `overTarget`.
       * @param from - The upstream `pointerover` event.
       */
      mapPointerOver(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const trackingData = this.trackingData(from.pointerId);
        const e2 = this.createPointerEvent(from);
        const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
        this.dispatchEvent(e2, "pointerover");
        if (isMouse)
          this.dispatchEvent(e2, "mouseover");
        if (e2.pointerType === "mouse")
          this.cursor = e2.target?.cursor;
        const enterEvent = this.clonePointerEvent(e2, "pointerenter");
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
          enterEvent.currentTarget = enterEvent.target;
          this.notifyTarget(enterEvent);
          if (isMouse)
            this.notifyTarget(enterEvent, "mouseenter");
          enterEvent.target = enterEvent.target.parent;
        }
        trackingData.overTargets = e2.composedPath();
        this.freeEvent(e2);
        this.freeEvent(enterEvent);
      }
      /**
       * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.
       *
       * The tracking data for the specific pointer is cleared of a `overTarget`.
       * @param from - The upstream `pointerout` event.
       */
      mapPointerOut(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const trackingData = this.trackingData(from.pointerId);
        if (trackingData.overTargets) {
          const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
          const outTarget = this.findMountedTarget(trackingData.overTargets);
          const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
          this.dispatchEvent(outEvent);
          if (isMouse)
            this.dispatchEvent(outEvent, "mouseout");
          const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
          leaveEvent.eventPhase = leaveEvent.AT_TARGET;
          while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
            leaveEvent.currentTarget = leaveEvent.target;
            this.notifyTarget(leaveEvent);
            if (isMouse)
              this.notifyTarget(leaveEvent, "mouseleave");
            leaveEvent.target = leaveEvent.target.parent;
          }
          trackingData.overTargets = null;
          this.freeEvent(outEvent);
          this.freeEvent(leaveEvent);
        }
        this.cursor = null;
      }
      /**
       * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,
       * and `click`/`rightclick`/`pointertap` events, in that order.
       *
       * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific
       * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,
       * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for
       * specific pointer types.
       * @param from - The upstream `pointerup` event.
       */
      mapPointerUp(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const now = performance.now();
        const e2 = this.createPointerEvent(from);
        this.dispatchEvent(e2, "pointerup");
        if (e2.pointerType === "touch") {
          this.dispatchEvent(e2, "touchend");
        } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
          const isRightButton = e2.button === 2;
          this.dispatchEvent(e2, isRightButton ? "rightup" : "mouseup");
        }
        const trackingData = this.trackingData(from.pointerId);
        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        let clickTarget = pressTarget;
        if (pressTarget && !e2.composedPath().includes(pressTarget)) {
          let currentTarget = pressTarget;
          while (currentTarget && !e2.composedPath().includes(currentTarget)) {
            e2.currentTarget = currentTarget;
            this.notifyTarget(e2, "pointerupoutside");
            if (e2.pointerType === "touch") {
              this.notifyTarget(e2, "touchendoutside");
            } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
              const isRightButton = e2.button === 2;
              this.notifyTarget(e2, isRightButton ? "rightupoutside" : "mouseupoutside");
            }
            currentTarget = currentTarget.parent;
          }
          delete trackingData.pressTargetsByButton[from.button];
          clickTarget = currentTarget;
        }
        if (clickTarget) {
          const clickEvent = this.clonePointerEvent(e2, "click");
          clickEvent.target = clickTarget;
          clickEvent.path = null;
          if (!trackingData.clicksByButton[from.button]) {
            trackingData.clicksByButton[from.button] = {
              clickCount: 0,
              target: clickEvent.target,
              timeStamp: now
            };
          }
          const clickHistory = trackingData.clicksByButton[from.button];
          if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
            ++clickHistory.clickCount;
          } else {
            clickHistory.clickCount = 1;
          }
          clickHistory.target = clickEvent.target;
          clickHistory.timeStamp = now;
          clickEvent.detail = clickHistory.clickCount;
          if (clickEvent.pointerType === "mouse") {
            const isRightButton = clickEvent.button === 2;
            this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
          } else if (clickEvent.pointerType === "touch") {
            this.dispatchEvent(clickEvent, "tap");
          }
          this.dispatchEvent(clickEvent, "pointertap");
          this.freeEvent(clickEvent);
        }
        this.freeEvent(e2);
      }
      /**
       * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original
       * `pointerdown` target to `rootTarget`.
       *
       * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the
       * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)
       *
       * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer
       * types. The tracking data for the specific pointer is cleared of a `pressTarget`.
       * @param from - The upstream `pointerupoutside` event.
       */
      mapPointerUpOutside(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const trackingData = this.trackingData(from.pointerId);
        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        const e2 = this.createPointerEvent(from);
        if (pressTarget) {
          let currentTarget = pressTarget;
          while (currentTarget) {
            e2.currentTarget = currentTarget;
            this.notifyTarget(e2, "pointerupoutside");
            if (e2.pointerType === "touch") {
              this.notifyTarget(e2, "touchendoutside");
            } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
              this.notifyTarget(e2, e2.button === 2 ? "rightupoutside" : "mouseupoutside");
            }
            currentTarget = currentTarget.parent;
          }
          delete trackingData.pressTargetsByButton[from.button];
        }
        this.freeEvent(e2);
      }
      /**
       * Maps the upstream `wheel` event to a downstream `wheel` event.
       * @param from - The upstream `wheel` event.
       */
      mapWheel(from) {
        if (!(from instanceof FederatedWheelEvent)) {
          warn("EventBoundary cannot map a non-wheel event as a wheel event");
          return;
        }
        const wheelEvent = this.createWheelEvent(from);
        this.dispatchEvent(wheelEvent);
        this.freeEvent(wheelEvent);
      }
      /**
       * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.
       *
       * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`
       * or `pointerover` target was unmounted from the scene graph.
       * @param propagationPath - The propagation path was valid in the past.
       * @returns - The most specific event-target still mounted at the same location in the scene graph.
       */
      findMountedTarget(propagationPath) {
        if (!propagationPath) {
          return null;
        }
        let currentTarget = propagationPath[0];
        for (let i2 = 1; i2 < propagationPath.length; i2++) {
          if (propagationPath[i2].parent === currentTarget) {
            currentTarget = propagationPath[i2];
          } else {
            break;
          }
        }
        return currentTarget;
      }
      /**
       * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.
       *
       * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
       * @param from - The {@code originalEvent} for the returned event.
       * @param [type=from.type] - The type of the returned event.
       * @param target - The target of the returned event.
       */
      createPointerEvent(from, type, target) {
        const event = this.allocateEvent(FederatedPointerEvent);
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
        if (typeof type === "string") {
          event.type = type;
        }
        return event;
      }
      /**
       * Creates a wheel event whose {@code originalEvent} is {@code from}.
       *
       * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
       * @param from - The upstream wheel event.
       */
      createWheelEvent(from) {
        const event = this.allocateEvent(FederatedWheelEvent);
        this.copyWheelData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        event.target = this.hitTest(event.global.x, event.global.y);
        return event;
      }
      /**
       * Clones the event {@code from}, with an optional {@code type} override.
       *
       * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
       * @param from - The event to clone.
       * @param [type=from.type] - The type of the returned event.
       */
      clonePointerEvent(from, type) {
        const event = this.allocateEvent(FederatedPointerEvent);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from.originalEvent;
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.target = from.target;
        event.path = from.composedPath().slice();
        event.type = type ?? event.type;
        return event;
      }
      /**
       * Copies wheel {@link FederatedWheelEvent} data from {@code from} into {@code to}.
       *
       * The following properties are copied:
       * + deltaMode
       * + deltaX
       * + deltaY
       * + deltaZ
       * @param from
       * @param to
       */
      copyWheelData(from, to) {
        to.deltaMode = from.deltaMode;
        to.deltaX = from.deltaX;
        to.deltaY = from.deltaY;
        to.deltaZ = from.deltaZ;
      }
      /**
       * Copies pointer {@link FederatedPointerEvent} data from {@code from} into {@code to}.
       *
       * The following properties are copied:
       * + pointerId
       * + width
       * + height
       * + isPrimary
       * + pointerType
       * + pressure
       * + tangentialPressure
       * + tiltX
       * + tiltY
       * @param from
       * @param to
       */
      copyPointerData(from, to) {
        if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))
          return;
        to.pointerId = from.pointerId;
        to.width = from.width;
        to.height = from.height;
        to.isPrimary = from.isPrimary;
        to.pointerType = from.pointerType;
        to.pressure = from.pressure;
        to.tangentialPressure = from.tangentialPressure;
        to.tiltX = from.tiltX;
        to.tiltY = from.tiltY;
        to.twist = from.twist;
      }
      /**
       * Copies mouse {@link FederatedMouseEvent} data from {@code from} to {@code to}.
       *
       * The following properties are copied:
       * + altKey
       * + button
       * + buttons
       * + clientX
       * + clientY
       * + metaKey
       * + movementX
       * + movementY
       * + pageX
       * + pageY
       * + x
       * + y
       * + screen
       * + shiftKey
       * + global
       * @param from
       * @param to
       */
      copyMouseData(from, to) {
        if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))
          return;
        to.altKey = from.altKey;
        to.button = from.button;
        to.buttons = from.buttons;
        to.client.copyFrom(from.client);
        to.ctrlKey = from.ctrlKey;
        to.metaKey = from.metaKey;
        to.movement.copyFrom(from.movement);
        to.screen.copyFrom(from.screen);
        to.shiftKey = from.shiftKey;
        to.global.copyFrom(from.global);
      }
      /**
       * Copies base {@link FederatedEvent} data from {@code from} into {@code to}.
       *
       * The following properties are copied:
       * + isTrusted
       * + srcElement
       * + timeStamp
       * + type
       * @param from - The event to copy data from.
       * @param to - The event to copy data into.
       */
      copyData(from, to) {
        to.isTrusted = from.isTrusted;
        to.srcElement = from.srcElement;
        to.timeStamp = performance.now();
        to.type = from.type;
        to.detail = from.detail;
        to.view = from.view;
        to.which = from.which;
        to.layer.copyFrom(from.layer);
        to.page.copyFrom(from.page);
      }
      /**
       * @param id - The pointer ID.
       * @returns The tracking data stored for the given pointer. If no data exists, a blank
       *  state will be created.
       */
      trackingData(id) {
        if (!this.mappingState.trackingData[id]) {
          this.mappingState.trackingData[id] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null
          };
        }
        return this.mappingState.trackingData[id];
      }
      /**
       * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.
       *
       * This allocation is constructor-agnostic, as long as it only takes one argument - this event
       * boundary.
       * @param constructor - The event's constructor.
       */
      allocateEvent(constructor) {
        if (!this.eventPool.has(constructor)) {
          this.eventPool.set(constructor, []);
        }
        const event = this.eventPool.get(constructor).pop() || new constructor(this);
        event.eventPhase = event.NONE;
        event.currentTarget = null;
        event.path = null;
        event.target = null;
        return event;
      }
      /**
       * Frees the event and puts it back into the event pool.
       *
       * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.
       *
       * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}
       * not be freed. This is because of the possibility that the same event is freed twice, which can cause
       * it to be allocated twice & result in overwriting.
       * @param event - The event to be freed.
       * @throws Error if the event is managed by another event boundary.
       */
      freeEvent(event) {
        if (event.manager !== this)
          throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        const constructor = event.constructor;
        if (!this.eventPool.has(constructor)) {
          this.eventPool.set(constructor, []);
        }
        this.eventPool.get(constructor).push(event);
      }
      /**
       * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag
       * is set on the event.
       * @param e - The event to call each listener with.
       * @param type - The event key.
       */
      _notifyListeners(e2, type) {
        const listeners = e2.currentTarget._events[type];
        if (!listeners)
          return;
        if (!e2.currentTarget.isInteractive())
          return;
        if ("fn" in listeners) {
          if (listeners.once)
            e2.currentTarget.removeListener(type, listeners.fn, void 0, true);
          listeners.fn.call(listeners.context, e2);
        } else {
          for (let i2 = 0, j3 = listeners.length; i2 < j3 && !e2.propagationImmediatelyStopped; i2++) {
            if (listeners[i2].once)
              e2.currentTarget.removeListener(type, listeners[i2].fn, void 0, true);
            listeners[i2].fn.call(listeners[i2].context, e2);
          }
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/EventSystem.mjs
var MOUSE_POINTER_ID, TOUCH_TO_POINTER, _EventSystem, EventSystem;
var init_EventSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/EventSystem.mjs"() {
    init_Extensions();
    init_EventBoundary();
    init_EventTicker();
    init_FederatedPointerEvent();
    init_FederatedWheelEvent();
    MOUSE_POINTER_ID = 1;
    TOUCH_TO_POINTER = {
      touchstart: "pointerdown",
      touchend: "pointerup",
      touchendoutside: "pointerupoutside",
      touchmove: "pointermove",
      touchcancel: "pointercancel"
    };
    _EventSystem = class {
      /**
       * @param {Renderer} renderer
       */
      constructor(renderer) {
        this.supportsTouchEvents = "ontouchstart" in globalThis;
        this.supportsPointerEvents = !!globalThis.PointerEvent;
        this.domElement = null;
        this.resolution = 1;
        this.renderer = renderer;
        this.rootBoundary = new EventBoundary(null);
        EventsTicker.init(this);
        this.autoPreventDefault = true;
        this._eventsAdded = false;
        this._rootPointerEvent = new FederatedPointerEvent(null);
        this._rootWheelEvent = new FederatedWheelEvent(null);
        this.cursorStyles = {
          default: "inherit",
          pointer: "pointer"
        };
        this.features = new Proxy({ ..._EventSystem.defaultEventFeatures }, {
          set: (target, key, value) => {
            if (key === "globalMove") {
              this.rootBoundary.enableGlobalMoveEvents = value;
            }
            target[key] = value;
            return true;
          }
        });
        this._onPointerDown = this._onPointerDown.bind(this);
        this._onPointerMove = this._onPointerMove.bind(this);
        this._onPointerUp = this._onPointerUp.bind(this);
        this._onPointerOverOut = this._onPointerOverOut.bind(this);
        this.onWheel = this.onWheel.bind(this);
      }
      /**
       * The default interaction mode for all display objects.
       * @see Container.eventMode
       * @type {EventMode}
       * @readonly
       * @since 7.2.0
       */
      static get defaultEventMode() {
        return this._defaultEventMode;
      }
      /**
       * Runner init called, view is available at this point.
       * @ignore
       */
      init(options) {
        const { canvas: canvas2, resolution } = this.renderer;
        this.setTargetElement(canvas2);
        this.resolution = resolution;
        _EventSystem._defaultEventMode = options.eventMode ?? "passive";
        Object.assign(this.features, options.eventFeatures ?? {});
        this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
      }
      /**
       * Handle changing resolution.
       * @ignore
       */
      resolutionChange(resolution) {
        this.resolution = resolution;
      }
      /** Destroys all event listeners and detaches the renderer. */
      destroy() {
        this.setTargetElement(null);
        this.renderer = null;
        this._currentCursor = null;
      }
      /**
       * Sets the current cursor mode, handling any callbacks or CSS style changes.
       * @param mode - cursor mode, a key from the cursorStyles dictionary
       */
      setCursor(mode) {
        mode = mode || "default";
        let applyStyles = true;
        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
          applyStyles = false;
        }
        if (this._currentCursor === mode) {
          return;
        }
        this._currentCursor = mode;
        const style = this.cursorStyles[mode];
        if (style) {
          switch (typeof style) {
            case "string":
              if (applyStyles) {
                this.domElement.style.cursor = style;
              }
              break;
            case "function":
              style(mode);
              break;
            case "object":
              if (applyStyles) {
                Object.assign(this.domElement.style, style);
              }
              break;
          }
        } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
          this.domElement.style.cursor = mode;
        }
      }
      /**
       * The global pointer event.
       * Useful for getting the pointer position without listening to events.
       * @since 7.2.0
       */
      get pointer() {
        return this._rootPointerEvent;
      }
      /**
       * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch event.
       */
      _onPointerDown(nativeEvent) {
        if (!this.features.click)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const events = this._normalizeToPointerData(nativeEvent);
        if (this.autoPreventDefault && events[0].isNormalized) {
          const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
          if (cancelable) {
            nativeEvent.preventDefault();
          }
        }
        for (let i2 = 0, j3 = events.length; i2 < j3; i2++) {
          const nativeEvent2 = events[i2];
          const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);
          this.rootBoundary.mapEvent(federatedEvent);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch events.
       */
      _onPointerMove(nativeEvent) {
        if (!this.features.move)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        EventsTicker.pointerMoved();
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for (let i2 = 0, j3 = normalizedEvents.length; i2 < j3; i2++) {
          const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
          this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch event.
       */
      _onPointerUp(nativeEvent) {
        if (!this.features.click)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        let target = nativeEvent.target;
        if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
          target = nativeEvent.composedPath()[0];
        }
        const outside = target !== this.domElement ? "outside" : "";
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for (let i2 = 0, j3 = normalizedEvents.length; i2 < j3; i2++) {
          const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
          event.type += outside;
          this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch event.
       */
      _onPointerOverOut(nativeEvent) {
        if (!this.features.click)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for (let i2 = 0, j3 = normalizedEvents.length; i2 < j3; i2++) {
          const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
          this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.
       * @param nativeEvent - The native wheel event.
       */
      onWheel(nativeEvent) {
        if (!this.features.wheel)
          return;
        const wheelEvent = this.normalizeWheelEvent(nativeEvent);
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        this.rootBoundary.mapEvent(wheelEvent);
      }
      /**
       * Sets the {@link EventSystem#domElement domElement} and binds event listeners.
       *
       * To deregister the current DOM element without setting a new one, pass {@code null}.
       * @param element - The new DOM element.
       */
      setTargetElement(element) {
        this._removeEvents();
        this.domElement = element;
        EventsTicker.domElement = element;
        this._addEvents();
      }
      /** Register event listeners on {@link Renderer#domElement this.domElement}. */
      _addEvents() {
        if (this._eventsAdded || !this.domElement) {
          return;
        }
        EventsTicker.addTickerListener();
        const style = this.domElement.style;
        if (style) {
          if (globalThis.navigator.msPointerEnabled) {
            style.msContentZooming = "none";
            style.msTouchAction = "none";
          } else if (this.supportsPointerEvents) {
            style.touchAction = "none";
          }
        }
        if (this.supportsPointerEvents) {
          globalThis.document.addEventListener("pointermove", this._onPointerMove, true);
          this.domElement.addEventListener("pointerdown", this._onPointerDown, true);
          this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true);
          this.domElement.addEventListener("pointerover", this._onPointerOverOut, true);
          globalThis.addEventListener("pointerup", this._onPointerUp, true);
        } else {
          globalThis.document.addEventListener("mousemove", this._onPointerMove, true);
          this.domElement.addEventListener("mousedown", this._onPointerDown, true);
          this.domElement.addEventListener("mouseout", this._onPointerOverOut, true);
          this.domElement.addEventListener("mouseover", this._onPointerOverOut, true);
          globalThis.addEventListener("mouseup", this._onPointerUp, true);
          if (this.supportsTouchEvents) {
            this.domElement.addEventListener("touchstart", this._onPointerDown, true);
            this.domElement.addEventListener("touchend", this._onPointerUp, true);
            this.domElement.addEventListener("touchmove", this._onPointerMove, true);
          }
        }
        this.domElement.addEventListener("wheel", this.onWheel, {
          passive: true,
          capture: true
        });
        this._eventsAdded = true;
      }
      /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */
      _removeEvents() {
        if (!this._eventsAdded || !this.domElement) {
          return;
        }
        EventsTicker.removeTickerListener();
        const style = this.domElement.style;
        if (globalThis.navigator.msPointerEnabled) {
          style.msContentZooming = "";
          style.msTouchAction = "";
        } else if (this.supportsPointerEvents) {
          style.touchAction = "";
        }
        if (this.supportsPointerEvents) {
          globalThis.document.removeEventListener("pointermove", this._onPointerMove, true);
          this.domElement.removeEventListener("pointerdown", this._onPointerDown, true);
          this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true);
          this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true);
          globalThis.removeEventListener("pointerup", this._onPointerUp, true);
        } else {
          globalThis.document.removeEventListener("mousemove", this._onPointerMove, true);
          this.domElement.removeEventListener("mousedown", this._onPointerDown, true);
          this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true);
          this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true);
          globalThis.removeEventListener("mouseup", this._onPointerUp, true);
          if (this.supportsTouchEvents) {
            this.domElement.removeEventListener("touchstart", this._onPointerDown, true);
            this.domElement.removeEventListener("touchend", this._onPointerUp, true);
            this.domElement.removeEventListener("touchmove", this._onPointerMove, true);
          }
        }
        this.domElement.removeEventListener("wheel", this.onWheel, true);
        this.domElement = null;
        this._eventsAdded = false;
      }
      /**
       * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The
       * resulting value is stored in the point. This takes into account the fact that the DOM
       * element could be scaled and positioned anywhere on the screen.
       * @param  {PointData} point - the point that the result will be stored in
       * @param  {number} x - the x coord of the position to map
       * @param  {number} y - the y coord of the position to map
       */
      mapPositionToPoint(point, x3, y2) {
        const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
          x: 0,
          y: 0,
          width: this.domElement.width,
          height: this.domElement.height,
          left: 0,
          top: 0
        };
        const resolutionMultiplier = 1 / this.resolution;
        point.x = (x3 - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
        point.y = (y2 - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
      }
      /**
       * Ensures that the original event object contains all data that a regular pointer event would have
       * @param event - The original event data from a touch or mouse event
       * @returns An array containing a single normalized pointer event, in the case of a pointer
       *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
       */
      _normalizeToPointerData(event) {
        const normalizedEvents = [];
        if (this.supportsTouchEvents && event instanceof TouchEvent) {
          for (let i2 = 0, li = event.changedTouches.length; i2 < li; i2++) {
            const touch = event.changedTouches[i2];
            if (typeof touch.button === "undefined")
              touch.button = 0;
            if (typeof touch.buttons === "undefined")
              touch.buttons = 1;
            if (typeof touch.isPrimary === "undefined") {
              touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
            }
            if (typeof touch.width === "undefined")
              touch.width = touch.radiusX || 1;
            if (typeof touch.height === "undefined")
              touch.height = touch.radiusY || 1;
            if (typeof touch.tiltX === "undefined")
              touch.tiltX = 0;
            if (typeof touch.tiltY === "undefined")
              touch.tiltY = 0;
            if (typeof touch.pointerType === "undefined")
              touch.pointerType = "touch";
            if (typeof touch.pointerId === "undefined")
              touch.pointerId = touch.identifier || 0;
            if (typeof touch.pressure === "undefined")
              touch.pressure = touch.force || 0.5;
            if (typeof touch.twist === "undefined")
              touch.twist = 0;
            if (typeof touch.tangentialPressure === "undefined")
              touch.tangentialPressure = 0;
            if (typeof touch.layerX === "undefined")
              touch.layerX = touch.offsetX = touch.clientX;
            if (typeof touch.layerY === "undefined")
              touch.layerY = touch.offsetY = touch.clientY;
            touch.isNormalized = true;
            touch.type = event.type;
            normalizedEvents.push(touch);
          }
        } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
          const tempEvent = event;
          if (typeof tempEvent.isPrimary === "undefined")
            tempEvent.isPrimary = true;
          if (typeof tempEvent.width === "undefined")
            tempEvent.width = 1;
          if (typeof tempEvent.height === "undefined")
            tempEvent.height = 1;
          if (typeof tempEvent.tiltX === "undefined")
            tempEvent.tiltX = 0;
          if (typeof tempEvent.tiltY === "undefined")
            tempEvent.tiltY = 0;
          if (typeof tempEvent.pointerType === "undefined")
            tempEvent.pointerType = "mouse";
          if (typeof tempEvent.pointerId === "undefined")
            tempEvent.pointerId = MOUSE_POINTER_ID;
          if (typeof tempEvent.pressure === "undefined")
            tempEvent.pressure = 0.5;
          if (typeof tempEvent.twist === "undefined")
            tempEvent.twist = 0;
          if (typeof tempEvent.tangentialPressure === "undefined")
            tempEvent.tangentialPressure = 0;
          tempEvent.isNormalized = true;
          normalizedEvents.push(tempEvent);
        } else {
          normalizedEvents.push(event);
        }
        return normalizedEvents;
      }
      /**
       * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.
       *
       * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across
       * multiple native wheel events.
       * @param nativeEvent - The native wheel event that occurred on the canvas.
       * @returns A federated wheel event.
       */
      normalizeWheelEvent(nativeEvent) {
        const event = this._rootWheelEvent;
        this._transferMouseData(event, nativeEvent);
        event.deltaX = nativeEvent.deltaX;
        event.deltaY = nativeEvent.deltaY;
        event.deltaZ = nativeEvent.deltaZ;
        event.deltaMode = nativeEvent.deltaMode;
        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
        event.global.copyFrom(event.screen);
        event.offset.copyFrom(event.screen);
        event.nativeEvent = nativeEvent;
        event.type = nativeEvent.type;
        return event;
      }
      /**
       * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.
       * @param event
       * @param nativeEvent
       */
      _bootstrapEvent(event, nativeEvent) {
        event.originalEvent = null;
        event.nativeEvent = nativeEvent;
        event.pointerId = nativeEvent.pointerId;
        event.width = nativeEvent.width;
        event.height = nativeEvent.height;
        event.isPrimary = nativeEvent.isPrimary;
        event.pointerType = nativeEvent.pointerType;
        event.pressure = nativeEvent.pressure;
        event.tangentialPressure = nativeEvent.tangentialPressure;
        event.tiltX = nativeEvent.tiltX;
        event.tiltY = nativeEvent.tiltY;
        event.twist = nativeEvent.twist;
        this._transferMouseData(event, nativeEvent);
        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
        event.global.copyFrom(event.screen);
        event.offset.copyFrom(event.screen);
        event.isTrusted = nativeEvent.isTrusted;
        if (event.type === "pointerleave") {
          event.type = "pointerout";
        }
        if (event.type.startsWith("mouse")) {
          event.type = event.type.replace("mouse", "pointer");
        }
        if (event.type.startsWith("touch")) {
          event.type = TOUCH_TO_POINTER[event.type] || event.type;
        }
        return event;
      }
      /**
       * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.
       * @param event
       * @param nativeEvent
       */
      _transferMouseData(event, nativeEvent) {
        event.isTrusted = nativeEvent.isTrusted;
        event.srcElement = nativeEvent.srcElement;
        event.timeStamp = performance.now();
        event.type = nativeEvent.type;
        event.altKey = nativeEvent.altKey;
        event.button = nativeEvent.button;
        event.buttons = nativeEvent.buttons;
        event.client.x = nativeEvent.clientX;
        event.client.y = nativeEvent.clientY;
        event.ctrlKey = nativeEvent.ctrlKey;
        event.metaKey = nativeEvent.metaKey;
        event.movement.x = nativeEvent.movementX;
        event.movement.y = nativeEvent.movementY;
        event.page.x = nativeEvent.pageX;
        event.page.y = nativeEvent.pageY;
        event.relatedTarget = null;
        event.shiftKey = nativeEvent.shiftKey;
      }
    };
    EventSystem = _EventSystem;
    EventSystem.extension = {
      name: "events",
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.CanvasSystem,
        ExtensionType.WebGPUSystem
      ],
      priority: -1
    };
    EventSystem.defaultEventFeatures = {
      move: true,
      globalMove: true,
      click: true,
      wheel: true
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/FederatedEventTarget.mjs
var FederatedContainer;
var init_FederatedEventTarget = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/FederatedEventTarget.mjs"() {
    init_EventSystem();
    init_FederatedEvent();
    FederatedContainer = {
      /**
       * Property-based event handler for the `click` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onclick = (event) => {
       *  //some function here that happens on click
       * }
       */
      onclick: null,
      /**
       * Property-based event handler for the `mousedown` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmousedown = (event) => {
       *  //some function here that happens on mousedown
       * }
       */
      onmousedown: null,
      /**
       * Property-based event handler for the `mouseenter` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmouseenter = (event) => {
       *  //some function here that happens on mouseenter
       * }
       */
      onmouseenter: null,
      /**
       * Property-based event handler for the `mouseleave` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmouseleave = (event) => {
       *  //some function here that happens on mouseleave
       * }
       */
      onmouseleave: null,
      /**
       * Property-based event handler for the `mousemove` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmousemove = (event) => {
       *  //some function here that happens on mousemove
       * }
       */
      onmousemove: null,
      /**
       * Property-based event handler for the `globalmousemove` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onglobalmousemove = (event) => {
       *  //some function here that happens on globalmousemove
       * }
       */
      onglobalmousemove: null,
      /**
       * Property-based event handler for the `mouseout` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmouseout = (event) => {
       *  //some function here that happens on mouseout
       * }
       */
      onmouseout: null,
      /**
       * Property-based event handler for the `mouseover` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmouseover = (event) => {
       *  //some function here that happens on mouseover
       * }
       */
      onmouseover: null,
      /**
       * Property-based event handler for the `mouseup` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmouseup = (event) => {
       *  //some function here that happens on mouseup
       * }
       */
      onmouseup: null,
      /**
       * Property-based event handler for the `mouseupoutside` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onmouseupoutside = (event) => {
       *  //some function here that happens on mouseupoutside
       * }
       */
      onmouseupoutside: null,
      /**
       * Property-based event handler for the `pointercancel` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointercancel = (event) => {
       *  //some function here that happens on pointercancel
       * }
       */
      onpointercancel: null,
      /**
       * Property-based event handler for the `pointerdown` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointerdown = (event) => {
       *  //some function here that happens on pointerdown
       * }
       */
      onpointerdown: null,
      /**
       * Property-based event handler for the `pointerenter` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointerenter = (event) => {
       *  //some function here that happens on pointerenter
       * }
       */
      onpointerenter: null,
      /**
       * Property-based event handler for the `pointerleave` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointerleave = (event) => {
       *  //some function here that happens on pointerleave
       * }
       */
      onpointerleave: null,
      /**
       * Property-based event handler for the `pointermove` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointermove = (event) => {
       *  //some function here that happens on pointermove
       * }
       */
      onpointermove: null,
      /**
       * Property-based event handler for the `globalpointermove` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onglobalpointermove = (event) => {
       *  //some function here that happens on globalpointermove
       * }
       */
      onglobalpointermove: null,
      /**
       * Property-based event handler for the `pointerout` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointerout = (event) => {
       *  //some function here that happens on pointerout
       * }
       */
      onpointerout: null,
      /**
       * Property-based event handler for the `pointerover` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointerover = (event) => {
       *  //some function here that happens on pointerover
       * }
       */
      onpointerover: null,
      /**
       * Property-based event handler for the `pointertap` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointertap = (event) => {
       *  //some function here that happens on pointertap
       * }
       */
      onpointertap: null,
      /**
       * Property-based event handler for the `pointerup` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointerup = (event) => {
       *  //some function here that happens on pointerup
       * }
       */
      onpointerup: null,
      /**
       * Property-based event handler for the `pointerupoutside` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onpointerupoutside = (event) => {
       *  //some function here that happens on pointerupoutside
       * }
       */
      onpointerupoutside: null,
      /**
       * Property-based event handler for the `rightclick` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onrightclick = (event) => {
       *  //some function here that happens on rightclick
       * }
       */
      onrightclick: null,
      /**
       * Property-based event handler for the `rightdown` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onrightdown = (event) => {
       *  //some function here that happens on rightdown
       * }
       */
      onrightdown: null,
      /**
       * Property-based event handler for the `rightup` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onrightup = (event) => {
       *  //some function here that happens on rightup
       * }
       */
      onrightup: null,
      /**
       * Property-based event handler for the `rightupoutside` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onrightupoutside = (event) => {
       *  //some function here that happens on rightupoutside
       * }
       */
      onrightupoutside: null,
      /**
       * Property-based event handler for the `tap` event.
       * @memberof Container#
       * @default null
       * @example
       * this.ontap = (event) => {
       *  //some function here that happens on tap
       * }
       */
      ontap: null,
      /**
       * Property-based event handler for the `touchcancel` event.
       * @memberof Container#
       * @default null
       * @example
       * this.ontouchcancel = (event) => {
       *  //some function here that happens on touchcancel
       * }
       */
      ontouchcancel: null,
      /**
       * Property-based event handler for the `touchend` event.
       * @memberof Container#
       * @default null
       * @example
       * this.ontouchend = (event) => {
       *  //some function here that happens on touchend
       * }
       */
      ontouchend: null,
      /**
       * Property-based event handler for the `touchendoutside` event.
       * @memberof Container#
       * @default null
       * @example
       * this.ontouchendoutside = (event) => {
       *  //some function here that happens on touchendoutside
       * }
       */
      ontouchendoutside: null,
      /**
       * Property-based event handler for the `touchmove` event.
       * @memberof Container#
       * @default null
       * @example
       * this.ontouchmove = (event) => {
       *  //some function here that happens on touchmove
       * }
       */
      ontouchmove: null,
      /**
       * Property-based event handler for the `globaltouchmove` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onglobaltouchmove = (event) => {
       *  //some function here that happens on globaltouchmove
       * }
       */
      onglobaltouchmove: null,
      /**
       * Property-based event handler for the `touchstart` event.
       * @memberof Container#
       * @default null
       * @example
       * this.ontouchstart = (event) => {
       *  //some function here that happens on touchstart
       * }
       */
      ontouchstart: null,
      /**
       * Property-based event handler for the `wheel` event.
       * @memberof Container#
       * @default null
       * @example
       * this.onwheel = (event) => {
       *  //some function here that happens on wheel
       * }
       */
      onwheel: null,
      /**
       * Enable interaction events for the Container. Touch, pointer and mouse
       * @memberof Container#
       */
      get interactive() {
        return this.eventMode === "dynamic" || this.eventMode === "static";
      },
      set interactive(value) {
        this.eventMode = value ? "static" : "passive";
      },
      /**
       * @ignore
       */
      _internalEventMode: void 0,
      /**
       * Enable interaction events for the Container. Touch, pointer and mouse.
       * This now replaces the `interactive` property.
       * There are 5 types of interaction settings:
       * - `'none'`: Ignores all interaction events, even on its children.
       * - `'passive'`: Does not emit events and ignores all hit testing on itself and non-interactive children.
       * Interactive children will still emit events.
       * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7
       * - `'static'`: Emit events and is hit tested. Same as `interaction = true` in v7
       * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from a ticker to
       * allow for interaction when the mouse isn't moving
       * @example
       * import { Sprite } from 'pixi.js';
       *
       * const sprite = new Sprite(texture);
       * sprite.eventMode = 'static';
       * sprite.on('tap', (event) => {
       *     // Handle event
       * });
       * @memberof Container#
       * @since 7.2.0
       */
      get eventMode() {
        return this._internalEventMode ?? EventSystem.defaultEventMode;
      },
      set eventMode(value) {
        this._internalEventMode = value;
      },
      /**
       * Determines if the container is interactive or not
       * @returns {boolean} Whether the container is interactive or not
       * @memberof Container#
       * @since 7.2.0
       * @example
       * import { Sprite } from 'pixi.js';
       * const sprite = new Sprite(texture);
       * sprite.eventMode = 'static';
       * sprite.isInteractive(); // true
       *
       * sprite.eventMode = 'dynamic';
       * sprite.isInteractive(); // true
       *
       * sprite.eventMode = 'none';
       * sprite.isInteractive(); // false
       *
       * sprite.eventMode = 'passive';
       * sprite.isInteractive(); // false
       *
       * sprite.eventMode = 'auto';
       * sprite.isInteractive(); // false
       */
      isInteractive() {
        return this.eventMode === "static" || this.eventMode === "dynamic";
      },
      /**
       * Determines if the children to the container can be clicked/touched
       * Setting this to false allows PixiJS to bypass a recursive `hitTest` function
       * @memberof Container#
       */
      interactiveChildren: true,
      /**
       * Interaction shape. Children will be hit first, then this shape will be checked.
       * Setting this will cause this shape to be checked in hit tests rather than the container's bounds.
       * @example
       * import { Rectangle, Sprite } from 'pixi.js';
       *
       * const sprite = new Sprite(texture);
       * sprite.interactive = true;
       * sprite.hitArea = new Rectangle(0, 0, 100, 100);
       * @member {IHitArea}
       * @memberof Container#
       */
      hitArea: null,
      /**
       * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`
       * seeks to be compatible with the DOM's `addEventListener` with support for options.
       * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.
       * @memberof Container
       * @param type - The type of event to listen to.
       * @param listener - The listener callback or object.
       * @param options - Listener options, used for capture phase.
       * @example
       * // Tell the user whether they did a single, double, triple, or nth click.
       * button.addEventListener('click', {
       *     handleEvent(e): {
       *         let prefix;
       *
       *         switch (e.detail) {
       *             case 1: prefix = 'single'; break;
       *             case 2: prefix = 'double'; break;
       *             case 3: prefix = 'triple'; break;
       *             default: prefix = e.detail + 'th'; break;
       *         }
       *
       *         console.log('That was a ' + prefix + 'click');
       *     }
       * });
       *
       * // But skip the first click!
       * button.parent.addEventListener('click', function blockClickOnce(e) {
       *     e.stopImmediatePropagation();
       *     button.parent.removeEventListener('click', blockClickOnce, true);
       * }, {
       *     capture: true,
       * });
       */
      addEventListener(type, listener, options) {
        const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
        const context2 = typeof listener === "function" ? void 0 : listener;
        type = capture ? `${type}capture` : type;
        listener = typeof listener === "function" ? listener : listener.handleEvent;
        this.on(type, listener, context2);
      },
      /**
       * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`
       * seeks to be compatible with the DOM's `removeEventListener` with support for options.
       * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.
       * @memberof Container
       * @param type - The type of event the listener is bound to.
       * @param listener - The listener callback or object.
       * @param options - The original listener options. This is required to deregister a capture phase listener.
       */
      removeEventListener(type, listener, options) {
        const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
        const context2 = typeof listener === "function" ? void 0 : listener;
        type = capture ? `${type}capture` : type;
        listener = typeof listener === "function" ? listener : listener.handleEvent;
        this.off(type, listener, context2);
      },
      /**
       * Dispatch the event on this {@link Container} using the event's {@link EventBoundary}.
       *
       * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.
       *
       * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.
       * @memberof Container
       * @param e - The event to dispatch.
       * @returns Whether the {@link FederatedEvent.preventDefault preventDefault}() method was not invoked.
       * @example
       * // Reuse a click event!
       * button.dispatchEvent(clickEvent);
       */
      dispatchEvent(e2) {
        if (!(e2 instanceof FederatedEvent)) {
          throw new Error("Container cannot propagate events outside of the Federated Events API");
        }
        e2.defaultPrevented = false;
        e2.path = null;
        e2.target = this;
        e2.manager.dispatchEvent(e2);
        return !e2.defaultPrevented;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/init.mjs
var init_init4 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/events/init.mjs"() {
    init_Extensions();
    init_Container();
    init_EventSystem();
    init_FederatedEventTarget();
    extensions.add(EventSystem);
    Container.mixin(FederatedContainer);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs
var _Spritesheet, Spritesheet;
var init_Spritesheet = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs"() {
    init_Rectangle();
    init_Texture();
    _Spritesheet = class {
      /**
       * @param texture - Reference to the source BaseTexture object.
       * @param {object} data - Spritesheet image data.
       */
      constructor(texture, data) {
        this.linkedSheets = [];
        this._texture = texture instanceof Texture ? texture : null;
        this.textureSource = texture.source;
        this.textures = {};
        this.animations = {};
        this.data = data;
        const metaResolution = parseFloat(data.meta.scale);
        if (metaResolution) {
          this.resolution = metaResolution;
          texture.source.resolution = this.resolution;
        } else {
          this.resolution = texture.source._resolution;
        }
        this._frames = this.data.frames;
        this._frameKeys = Object.keys(this._frames);
        this._batchIndex = 0;
        this._callback = null;
      }
      /**
       * Parser spritesheet from loaded data. This is done asynchronously
       * to prevent creating too many Texture within a single process.
       * @method Spritesheet#parse
       */
      parse() {
        return new Promise((resolve) => {
          this._callback = resolve;
          this._batchIndex = 0;
          if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {
            this._processFrames(0);
            this._processAnimations();
            this._parseComplete();
          } else {
            this._nextBatch();
          }
        });
      }
      /**
       * Process a batch of frames
       * @param initialFrameIndex - The index of frame to start.
       */
      _processFrames(initialFrameIndex) {
        let frameIndex = initialFrameIndex;
        const maxFrames = _Spritesheet.BATCH_SIZE;
        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
          const i2 = this._frameKeys[frameIndex];
          const data = this._frames[i2];
          const rect = data.frame;
          if (rect) {
            let frame = null;
            let trim = null;
            const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
            const orig = new Rectangle(
              0,
              0,
              Math.floor(sourceSize.w) / this.resolution,
              Math.floor(sourceSize.h) / this.resolution
            );
            if (data.rotated) {
              frame = new Rectangle(
                Math.floor(rect.x) / this.resolution,
                Math.floor(rect.y) / this.resolution,
                Math.floor(rect.h) / this.resolution,
                Math.floor(rect.w) / this.resolution
              );
            } else {
              frame = new Rectangle(
                Math.floor(rect.x) / this.resolution,
                Math.floor(rect.y) / this.resolution,
                Math.floor(rect.w) / this.resolution,
                Math.floor(rect.h) / this.resolution
              );
            }
            if (data.trimmed !== false && data.spriteSourceSize) {
              trim = new Rectangle(
                Math.floor(data.spriteSourceSize.x) / this.resolution,
                Math.floor(data.spriteSourceSize.y) / this.resolution,
                Math.floor(rect.w) / this.resolution,
                Math.floor(rect.h) / this.resolution
              );
              trim.x /= this.textureSource.width;
              trim.y /= this.textureSource.height;
              trim.width /= this.textureSource.width;
              trim.height /= this.textureSource.height;
            }
            frame.x /= this.textureSource.width;
            frame.y /= this.textureSource.height;
            frame.width /= this.textureSource.width;
            frame.height /= this.textureSource.height;
            orig.x /= this.textureSource.width;
            orig.y /= this.textureSource.height;
            orig.width /= this.textureSource.width;
            orig.height /= this.textureSource.height;
            this.textures[i2] = new Texture({
              source: this.textureSource,
              layout: {
                frame,
                orig,
                trim,
                rotate: data.rotated ? 2 : 0,
                defaultAnchor: data.anchor,
                defaultBorders: data.borders
              },
              label: i2.toString()
            });
          }
          frameIndex++;
        }
      }
      /** Parse animations config. */
      _processAnimations() {
        const animations = this.data.animations || {};
        for (const animName in animations) {
          this.animations[animName] = [];
          for (let i2 = 0; i2 < animations[animName].length; i2++) {
            const frameName = animations[animName][i2];
            this.animations[animName].push(this.textures[frameName]);
          }
        }
      }
      /** The parse has completed. */
      _parseComplete() {
        const callback = this._callback;
        this._callback = null;
        this._batchIndex = 0;
        callback.call(this, this.textures);
      }
      /** Begin the next batch of textures. */
      _nextBatch() {
        this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);
        this._batchIndex++;
        setTimeout(() => {
          if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {
            this._nextBatch();
          } else {
            this._processAnimations();
            this._parseComplete();
          }
        }, 0);
      }
      /**
       * Destroy Spritesheet and don't use after this.
       * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
       */
      destroy(destroyBase = false) {
        for (const i2 in this.textures) {
          this.textures[i2].destroy();
        }
        this._frames = null;
        this._frameKeys = null;
        this.data = null;
        this.textures = null;
        if (destroyBase) {
          this._texture?.destroy();
          this.textureSource.destroy();
        }
        this._texture = null;
        this.textureSource = null;
        this.linkedSheets = [];
      }
    };
    Spritesheet = _Spritesheet;
    Spritesheet.BATCH_SIZE = 1e3;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs
function getCacheableAssets(keys, asset, ignoreMultiPack) {
  const out2 = {};
  keys.forEach((key) => {
    out2[key] = asset;
  });
  Object.keys(asset.textures).forEach((key) => {
    out2[key] = asset.textures[key];
  });
  if (!ignoreMultiPack) {
    const basePath = path.dirname(keys[0]);
    asset.linkedSheets.forEach((item, i2) => {
      const out22 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i2]}`], item, true);
      Object.assign(out2, out22);
    });
  }
  return out2;
}
var validImages, spritesheetAsset;
var init_spritesheetAsset = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs"() {
    init_LoaderParser();
    init_Resolver();
    init_copySearchParams();
    init_Extensions();
    init_path();
    init_Spritesheet();
    validImages = ["jpg", "png", "jpeg", "avif", "webp"];
    spritesheetAsset = {
      extension: ExtensionType.Asset,
      /** Handle the caching of the related Spritesheet Textures */
      cache: {
        test: (asset) => asset instanceof Spritesheet,
        getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
      },
      /** Resolve the the resolution of the asset. */
      resolver: {
        test: (value) => {
          const tempURL = value.split("?")[0];
          const split = tempURL.split(".");
          const extension = split.pop();
          const format2 = split.pop();
          return extension === "json" && validImages.includes(format2);
        },
        parse: (value) => {
          const split = value.split(".");
          return {
            resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
            format: split[split.length - 2],
            src: value
          };
        }
      },
      /**
       * Loader plugin that parses sprite sheets!
       * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
       * If it is, we load the spritesheets image and parse the data into Spritesheet
       * All textures in the sprite sheet are then added to the cache
       * @ignore
       */
      loader: {
        name: "spritesheetLoader",
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Normal
        },
        async testParse(asset, options) {
          return path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
        },
        async parse(asset, options, loader) {
          let basePath = path.dirname(options.src);
          if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
            basePath += "/";
          }
          let imagePath = basePath + asset.meta.image;
          imagePath = copySearchParams(imagePath, options.src);
          const assets = await loader.load([imagePath]);
          const texture = assets[imagePath];
          const spritesheet = new Spritesheet(
            texture.source,
            asset
          );
          await spritesheet.parse();
          const multiPacks = asset?.meta?.related_multi_packs;
          if (Array.isArray(multiPacks)) {
            const promises = [];
            for (const item of multiPacks) {
              if (typeof item !== "string") {
                continue;
              }
              let itemUrl = basePath + item;
              if (options.data?.ignoreMultiPack) {
                continue;
              }
              itemUrl = copySearchParams(itemUrl, options.src);
              promises.push(loader.load({
                src: itemUrl,
                data: {
                  ignoreMultiPack: true
                }
              }));
            }
            const res = await Promise.all(promises);
            spritesheet.linkedSheets = res;
            res.forEach((item) => {
              item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
            });
          }
          return spritesheet;
        },
        unload(spritesheet) {
          spritesheet.destroy(true);
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/spritesheet/init.mjs
var init_init5 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/spritesheet/init.mjs"() {
    init_Extensions();
    init_spritesheetAsset();
    extensions.add(spritesheetAsset);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/view/View.mjs
var emptyViewObserver;
var init_View = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/view/View.mjs"() {
    emptyViewObserver = {
      onViewUpdate: () => {
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/updateQuadBounds.mjs
function updateQuadBounds(bounds, anchor, texture, padding) {
  const textureSource = texture._source;
  const layout = texture.layout;
  const orig = layout.orig;
  const trim = layout.trim;
  const textureSourceWidth = textureSource.width;
  const textureSourceHeight = textureSource.height;
  const width = textureSourceWidth * orig.width;
  const height = textureSourceHeight * orig.height;
  if (trim) {
    const sourceWidth = textureSourceWidth * trim.width;
    const sourceHeight = textureSourceHeight * trim.height;
    bounds[0] = trim.x * textureSourceWidth - anchor._x * width - padding;
    bounds[1] = bounds[0] + sourceWidth;
    bounds[2] = trim.y * textureSourceHeight - anchor._y * height - padding;
    bounds[3] = bounds[2] + sourceHeight;
  } else {
    bounds[0] = -anchor._x * width - padding;
    bounds[1] = bounds[0] + width;
    bounds[2] = -anchor._y * height - padding;
    bounds[3] = bounds[2] + height;
  }
  return;
}
var init_updateQuadBounds = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/updateQuadBounds.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite/SpriteView.mjs
var SpriteView;
var init_SpriteView = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite/SpriteView.mjs"() {
    init_ObservablePoint();
    init_Texture();
    init_View();
    init_uid();
    init_updateQuadBounds();
    SpriteView = class {
      constructor(texture) {
        this.renderPipeId = "sprite";
        this.owner = emptyViewObserver;
        this.uid = uid("spriteView");
        this.batched = true;
        this._didUpdate = false;
        this._bounds = [0, 1, 0, 0];
        this._sourceBounds = [0, 1, 0, 0];
        this._boundsDirty = true;
        this._sourceBoundsDirty = true;
        this.roundPixels = 0;
        this.anchor = new ObservablePoint(
          this,
          texture.layout.defaultAnchor?.x || 0,
          texture.layout.defaultAnchor?.y || 0
        );
        this.texture = texture;
      }
      set texture(value) {
        value || (value = Texture.EMPTY);
        if (this._texture === value)
          return;
        if (this._texture) {
          this._texture.off("update", this.onUpdate, this);
        }
        value.on("update", this.onUpdate, this);
        this._texture = value;
        this.onUpdate();
      }
      get texture() {
        return this._texture;
      }
      get bounds() {
        if (this._boundsDirty) {
          this._updateBounds();
          this._boundsDirty = false;
        }
        return this._bounds;
      }
      get sourceBounds() {
        if (this._sourceBoundsDirty) {
          this._updateSourceBounds();
          this._sourceBoundsDirty = false;
        }
        return this._sourceBounds;
      }
      // passed local space..
      containsPoint(point) {
        const width = this._texture.frameWidth;
        const height = this._texture.frameHeight;
        const x1 = -width * this.anchor.x;
        let y1 = 0;
        if (point.x >= x1 && point.x < x1 + width) {
          y1 = -height * this.anchor.y;
          if (point.y >= y1 && point.y < y1 + height) {
            return true;
          }
        }
        return false;
      }
      addBounds(bounds) {
        const trim = this._texture._layout.trim;
        if (trim) {
          const sourceBounds = this.sourceBounds;
          bounds.addFrame(sourceBounds[0], sourceBounds[2], sourceBounds[1], sourceBounds[3]);
        } else {
          const _bounds = this.bounds;
          bounds.addFrame(_bounds[0], _bounds[2], _bounds[1], _bounds[3]);
        }
      }
      /**
       * @internal
       */
      onUpdate() {
        this._didUpdate = true;
        this._sourceBoundsDirty = this._boundsDirty = true;
        this.owner.onViewUpdate();
      }
      _updateBounds() {
        updateQuadBounds(this._bounds, this.anchor, this._texture, 0);
      }
      _updateSourceBounds() {
        const anchor = this.anchor;
        const texture = this._texture;
        const textureSource = texture._source;
        const layout = texture.layout;
        const orig = layout.orig;
        const sourceBounds = this._sourceBounds;
        const width = textureSource.width * orig.width;
        const height = textureSource.height * orig.height;
        sourceBounds[1] = -anchor._x * width;
        sourceBounds[0] = sourceBounds[1] + width;
        sourceBounds[3] = -anchor._y * height;
        sourceBounds[2] = sourceBounds[3] + height;
      }
      /**
       * Destroys this sprite renderable and optionally its texture.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
       * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
       */
      destroy(options = false) {
        this.anchor = null;
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          this._texture.destroy(destroyTextureSource);
        }
        this._texture = null;
        this._bounds = null;
        this._sourceBounds = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite/Sprite.mjs
var Sprite;
var init_Sprite = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite/Sprite.mjs"() {
    init_Cache();
    init_Texture();
    init_Container();
    init_SpriteView();
    Sprite = class _Sprite extends Container {
      static from(id) {
        if (typeof id === "string") {
          return new _Sprite(Cache.get(id));
        }
        return new _Sprite(id);
      }
      constructor(options = Texture.EMPTY) {
        if (options instanceof Texture) {
          options = { texture: options };
        }
        const { texture, ...rest } = options;
        super({
          view: new SpriteView(texture ?? Texture.EMPTY),
          label: "Sprite",
          ...rest
        });
        this.allowChildren = false;
      }
      get anchor() {
        return this.view.anchor;
      }
      set anchor(value) {
        this.view.anchor.x = value.x;
        this.view.anchor.y = value.y;
      }
      get texture() {
        return this.view.texture;
      }
      set texture(value) {
        this.view.texture = value;
      }
      get roundPixels() {
        return !!this.view.roundPixels;
      }
      set roundPixels(value) {
        this.view.roundPixels = value ? 1 : 0;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs
function addMaskBounds(mask, bounds, skipUpdateTransform) {
  const boundsToMask = tempBounds2;
  mask.measurable = true;
  getGlobalBounds(mask, skipUpdateTransform, boundsToMask);
  bounds.addBoundsMask(boundsToMask);
  mask.measurable = false;
}
var tempBounds2;
var init_addMaskBounds = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs"() {
    init_Bounds();
    init_getGlobalBounds();
    tempBounds2 = new Bounds();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs
function addMaskLocalBounds(mask, bounds, localRoot) {
  const boundsToMask = new Bounds();
  mask.measurable = true;
  const relativeMask = getMatrixRelativeToParent(mask, localRoot, new Matrix());
  getLocalBounds(mask, boundsToMask, relativeMask);
  mask.measurable = false;
  bounds.addBoundsMask(boundsToMask);
}
function getMatrixRelativeToParent(target, root, matrix) {
  if (!target) {
    warn("Item is not inside the root container");
    return matrix;
  }
  if (target !== root) {
    getMatrixRelativeToParent(target.parent, root, matrix);
    if (target.didChange) {
      updateLocalTransform(target.localTransform, target);
    }
    matrix.append(target.localTransform);
  }
  return matrix;
}
var init_addMaskLocalBounds = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs"() {
    init_Matrix();
    init_Bounds();
    init_getLocalBounds();
    init_updateLocalTransform();
    init_warn();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs
var AlphaMask;
var init_AlphaMask = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs"() {
    init_Extensions();
    init_Sprite();
    init_addMaskBounds();
    init_addMaskLocalBounds();
    AlphaMask = class {
      constructor(options) {
        this.priority = 0;
        this.pipe = "alphaMask";
        if (options?.mask) {
          this.init(options.mask);
        }
      }
      init(mask) {
        this.mask = mask;
        this.renderMaskToTexture = !(mask instanceof Sprite);
        this.mask.renderable = this.renderMaskToTexture;
        this.mask.includeInBuild = !this.renderMaskToTexture;
        this.mask.measurable = false;
      }
      reset() {
        this.mask.measurable = true;
        this.mask = null;
      }
      addBounds(bounds, skipUpdateTransform) {
        addMaskBounds(this.mask, bounds, skipUpdateTransform);
      }
      addLocalBounds(bounds, localRoot) {
        addMaskLocalBounds(this.mask, bounds, localRoot);
      }
      containsPoint(point, hitTestFn) {
        const mask = this.mask;
        return hitTestFn(mask, point);
      }
      destroy() {
        this.reset();
      }
      static test(mask) {
        return mask instanceof Sprite;
      }
    };
    AlphaMask.extension = ExtensionType.MaskEffect;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs
var ColorMask;
var init_ColorMask = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs"() {
    init_Extensions();
    ColorMask = class {
      constructor(options) {
        this.priority = 0;
        this.pipe = "colorMask";
        if (options?.mask) {
          this.init(options.mask);
        }
      }
      init(mask) {
        this.mask = mask;
      }
      destroy() {
      }
      static test(mask) {
        return typeof mask === "number";
      }
    };
    ColorMask.extension = ExtensionType.MaskEffect;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs
var StencilMask;
var init_StencilMask = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs"() {
    init_Extensions();
    init_Container();
    init_addMaskBounds();
    init_addMaskLocalBounds();
    StencilMask = class {
      constructor(options) {
        this.priority = 0;
        this.pipe = "stencilMask";
        if (options?.mask) {
          this.init(options.mask);
        }
      }
      init(mask) {
        this.mask = mask;
        this.mask.includeInBuild = false;
        this.mask.measurable = false;
      }
      reset() {
        this.mask.measurable = true;
        this.mask.includeInBuild = true;
        this.mask = null;
      }
      addBounds(bounds, skipUpdateTransform) {
        addMaskBounds(this.mask, bounds, skipUpdateTransform);
      }
      addLocalBounds(bounds, localRoot) {
        addMaskLocalBounds(this.mask, bounds, localRoot);
      }
      containsPoint(point, hitTestFn) {
        const mask = this.mask;
        return hitTestFn(mask, point);
      }
      destroy() {
        this.reset();
      }
      static test(mask) {
        return mask instanceof Container;
      }
    };
    StencilMask.extension = ExtensionType.MaskEffect;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs
var BufferImageSource;
var init_BufferImageSource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs"() {
    init_Extensions();
    init_TextureSource();
    BufferImageSource = class extends TextureSource {
      constructor(options) {
        const buffer = options.resource || new Float32Array(options.width * options.height * 4);
        let format2 = options.format;
        if (!format2) {
          if (buffer instanceof Float32Array) {
            format2 = "rgba32float";
          } else if (buffer instanceof Int32Array) {
            format2 = "rgba32uint";
          } else if (buffer instanceof Uint32Array) {
            format2 = "rgba32uint";
          } else if (buffer instanceof Int16Array) {
            format2 = "rgba16uint";
          } else if (buffer instanceof Uint16Array) {
            format2 = "rgba16uint";
          } else if (buffer instanceof Int8Array) {
            format2 = "bgra8unorm";
          } else {
            format2 = "bgra8unorm";
          }
        }
        super({
          ...options,
          format: format2
        });
        this.uploadMethodId = "buffer";
      }
      static test(resource) {
        return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;
      }
    };
    BufferImageSource.extension = ExtensionType.TextureSource;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs
var CanvasSource;
var init_CanvasSource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs"() {
    init_Extensions();
    init_adapter();
    init_TextureSource();
    CanvasSource = class extends TextureSource {
      constructor(options) {
        if (!options.resource) {
          options.resource = DOMAdapter.get().createCanvas();
        }
        if (!options.width) {
          options.width = options.resource.width;
          if (!options.autoDensity) {
            options.width /= options.resolution;
          }
        }
        if (!options.height) {
          options.height = options.resource.height;
          if (!options.autoDensity) {
            options.height /= options.resolution;
          }
        }
        options.alphaMode ?? (options.alphaMode = "premultiply-alpha-on-upload");
        super(options);
        this.uploadMethodId = "image";
        this.autoDensity = options.autoDensity;
        const canvas2 = options.resource;
        if (this.pixelWidth !== canvas2.width || this.pixelWidth !== canvas2.height) {
          this.resizeCanvas();
        }
      }
      resizeCanvas() {
        if (this.autoDensity) {
          this.resource.style.width = `${this.width}px`;
          this.resource.style.height = `${this.height}px`;
        }
        this.resource.width = this.pixelWidth;
        this.resource.height = this.pixelHeight;
      }
      resize(width = this.width, height = this.height, resolution = this._resolution) {
        super.resize(width, height, resolution);
        this.resizeCanvas();
      }
      static test(resource) {
        return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;
      }
    };
    CanvasSource.extension = ExtensionType.TextureSource;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/init.mjs
var init_init6 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/init.mjs"() {
    init_Extensions();
    init_AlphaMask();
    init_ColorMask();
    init_StencilMask();
    init_BufferImageSource();
    init_CanvasSource();
    init_ImageSource();
    init_VideoSource();
    extensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/all.mjs
var all_exports = {};
var init_all = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/all.mjs"() {
    init_init2();
    init_init3();
    init_init4();
    init_init5();
    init_init6();
    init_init();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs
var SystemRunner;
var init_SystemRunner = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs"() {
    SystemRunner = class {
      /**
       * @param name - The function name that will be executed on the listeners added to this Runner.
       */
      constructor(name) {
        this.items = [];
        this._name = name;
      }
      /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */
      /**
       * Dispatch/Broadcast Runner to all listeners added to the queue.
       * @param {...any} params - (optional) parameters to pass to each listener
       */
      /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */
      emit(a0, a1, a2, a3, a4, a5, a6, a7) {
        const { name, items } = this;
        for (let i2 = 0, len = items.length; i2 < len; i2++) {
          items[i2][name](a0, a1, a2, a3, a4, a5, a6, a7);
        }
        return this;
      }
      /**
       * Add a listener to the Runner
       *
       * Runners do not need to have scope or functions passed to them.
       * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
       * as the name provided to the Runner when it was created.
       *
       * Eg A listener passed to this Runner will require a 'complete' function.
       *
       * ```
       * import { Runner } from '@pixi/runner';
       *
       * const complete = new Runner('complete');
       * ```
       *
       * The scope used will be the object itself.
       * @param {any} item - The object that will be listening.
       */
      add(item) {
        if (item[this._name]) {
          this.remove(item);
          this.items.push(item);
        }
        return this;
      }
      /**
       * Remove a single listener from the dispatch queue.
       * @param {any} item - The listener that you would like to remove.
       */
      remove(item) {
        const index = this.items.indexOf(item);
        if (index !== -1) {
          this.items.splice(index, 1);
        }
        return this;
      }
      /**
       * Check to see if the listener is already in the Runner
       * @param {any} item - The listener that you would like to check.
       */
      contains(item) {
        return this.items.indexOf(item) !== -1;
      }
      /** Remove all listeners from the Runner */
      removeAll() {
        this.items.length = 0;
        return this;
      }
      /** Remove all references, don't use after this. */
      destroy() {
        this.removeAll();
        this.items = null;
        this._name = null;
      }
      /**
       * `true` if there are no this Runner contains no listeners
       * @readonly
       */
      get empty() {
        return this.items.length === 0;
      }
      /**
       * The name of the runner.
       * @readonly
       */
      get name() {
        return this._name;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs
var defaultRunners, _AbstractRenderer, AbstractRenderer;
var init_AbstractRenderer = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs"() {
    init_Color();
    init_Container();
    init_deprecation();
    init_SystemRunner();
    defaultRunners = [
      "init",
      "destroy",
      "contextChange",
      "resolutionChange",
      "reset",
      "renderEnd",
      "renderStart",
      "render",
      "update",
      "postrender",
      "prerender"
    ];
    _AbstractRenderer = class {
      /**
       * Set up a system with a collection of SystemClasses and runners.
       * Systems are attached dynamically to this class when added.
       * @param config - the config for the system manager
       */
      constructor(config) {
        this.runners = /* @__PURE__ */ Object.create(null);
        this.renderPipes = /* @__PURE__ */ Object.create(null);
        this._systemsHash = /* @__PURE__ */ Object.create(null);
        this.type = config.type;
        this.name = config.name;
        const combinedRunners = [...defaultRunners, ...config.runners ?? []];
        this._addRunners(...combinedRunners);
        this._addSystems(config.systems);
        this._addPipes(config.renderPipes, config.renderPipeAdaptors);
      }
      /**
       * Initialize the renderer.
       * @param options - The options to use to create the renderer.
       */
      async init(options = {}) {
        for (const systemName in this._systemsHash) {
          const system = this._systemsHash[systemName];
          const defaultSystemOptions = system.constructor.defaultOptions;
          options = { ...defaultSystemOptions, ...options };
        }
        options = { ..._AbstractRenderer.defaultOptions, ...options };
        this._roundPixels = options.roundPixels ? 1 : 0;
        for (let i2 = 0; i2 < this.runners.init.items.length; i2++) {
          await this.runners.init.items[i2].init(options);
        }
      }
      render(args, deprecated) {
        let options = args;
        if (options instanceof Container) {
          options = { container: options };
          if (deprecated) {
            deprecation(v8_0_0, "passing a second argument is deprecated, please use render options instead");
            options.target = deprecated.renderTexture;
          }
        }
        options.target || (options.target = this.view.texture);
        if (options.target === this.view.texture) {
          this._lastObjectRendered = options.container;
        }
        if (options.clearColor) {
          const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;
          options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();
        }
        this.runners.prerender.emit(options);
        this.runners.renderStart.emit(options);
        this.runners.render.emit(options);
        this.runners.renderEnd.emit(options);
        this.runners.postrender.emit(options);
      }
      /**
       * Resizes the WebGL view to the specified width and height.
       * @param desiredScreenWidth - The desired width of the screen.
       * @param desiredScreenHeight - The desired height of the screen.
       * @param resolution - The resolution / device pixel ratio of the renderer.
       */
      resize(desiredScreenWidth, desiredScreenHeight, resolution) {
        this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);
      }
      /** The resolution / device pixel ratio of the renderer. */
      get resolution() {
        return this.view.resolution;
      }
      set resolution(value) {
        this.view.resolution = value;
        this.runners.resolutionChange.emit(value);
      }
      /**
       * Same as view.width, actual number of pixels in the canvas by horizontal.
       * @member {number}
       * @readonly
       * @default 800
       */
      get width() {
        return this.view.texture.frameWidth;
      }
      /**
       * Same as view.height, actual number of pixels in the canvas by vertical.
       * @default 600
       */
      get height() {
        return this.view.texture.frameHeight;
      }
      // NOTE: this was `view` in v7
      /** The canvas element that everything is drawn to.*/
      get canvas() {
        return this.view.canvas;
      }
      /**
       * the last object rendered by the renderer. Useful for other plugins like interaction managers
       * @readonly
       */
      get lastObjectRendered() {
        return this._lastObjectRendered;
      }
      /**
       * Flag if we are rendering to the screen vs renderTexture
       * @readonly
       * @default true
       */
      get renderingToScreen() {
        const renderer = this;
        return renderer.renderTarget.renderingToScreen;
      }
      /**
       * Measurements of the screen. (0, 0, screenWidth, screenHeight).
       *
       * Its safe to use as filterArea or hitArea for the whole stage.
       * @member {Rectangle}
       */
      get screen() {
        return this.view.screen;
      }
      /**
       * Create a bunch of runners based of a collection of ids
       * @param runnerIds - the runner ids to add
       */
      _addRunners(...runnerIds) {
        runnerIds.forEach((runnerId) => {
          this.runners[runnerId] = new SystemRunner(runnerId);
        });
      }
      _addSystems(systems3) {
        let i2;
        for (i2 in systems3) {
          const val = systems3[i2];
          this._addSystem(val.value, val.name);
        }
      }
      /**
       * Add a new system to the renderer.
       * @param ClassRef - Class reference
       * @param name - Property name for system, if not specified
       *        will use a static `name` property on the class itself. This
       *        name will be assigned as s property on the Renderer so make
       *        sure it doesn't collide with properties on Renderer.
       * @returns Return instance of renderer
       */
      _addSystem(ClassRef, name) {
        const system = new ClassRef(this);
        if (this[name]) {
          throw new Error(`Whoops! The name "${name}" is already in use`);
        }
        this[name] = system;
        this._systemsHash[name] = system;
        for (const i2 in this.runners) {
          this.runners[i2].add(system);
        }
        return this;
      }
      _addPipes(pipes, pipeAdaptors) {
        const adaptors = pipeAdaptors.reduce((acc, adaptor) => {
          acc[adaptor.name] = adaptor.value;
          return acc;
        }, {});
        pipes.forEach((pipe) => {
          const PipeClass = pipe.value;
          const name = pipe.name;
          const Adaptor = adaptors[name];
          this.renderPipes[name] = new PipeClass(
            this,
            Adaptor ? new Adaptor() : null
          );
        });
      }
      destroy(options = false) {
        const writeable = this;
        this.runners.destroy.items.reverse();
        this.runners.destroy.emit(options);
        Object.values(this.runners).forEach((runner) => {
          runner.destroy();
        });
        writeable.runners = null;
        this._systemsHash = null;
        writeable.renderPipes = null;
      }
      /**
       * @deprecated since 8.0.0
       * @param options - options or container target to use when generating the texture
       * @returns a texture
       */
      generateTexture(options) {
        return this.textureGenerator.generateTexture(options);
      }
      /**
       * Whether the renderer will round coordinates to whole pixels when rendering.
       * Can be overridden on a per scene item basis.
       */
      get roundPixels() {
        return !!this._roundPixels;
      }
    };
    AbstractRenderer = _AbstractRenderer;
    AbstractRenderer.defaultOptions = {
      /**
       * Default resolution / device pixel ratio of the renderer.
       * @default 1
       */
      resolution: 1,
      /**
       * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`
       * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be
       * performance issues when using WebGL.
       *
       * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many
       * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or
       * driver version blacklisted by the
       * browser.
       *
       * If your application requires high performance rendering, you may wish to set this to false.
       * We recommend one of two options if you decide to set this flag to false:
       *
       * 1: Use the Canvas renderer as a fallback in case high performance WebGL is
       *    not supported.
       *
       * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a
       *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their
       *    device & browser combination does not support high performance WebGL.
       *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.
       * @default false
       */
      failIfMajorPerformanceCaveat: false,
      /**
       * Should round pixels be forced when rendering?
       * @default false
       */
      roundPixels: false
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs
var BindGroup;
var init_BindGroup = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs"() {
    BindGroup = class {
      constructor(resources) {
        this.resources = /* @__PURE__ */ Object.create(null);
        this._dirty = true;
        let index = 0;
        for (const i2 in resources) {
          const resource = resources[i2];
          this.setResource(resource, index++);
        }
        this.updateKey();
      }
      update() {
        this.updateKey();
      }
      updateKey() {
        if (!this._dirty)
          return;
        this._dirty = false;
        const keyParts = [];
        let index = 0;
        for (const i2 in this.resources) {
          keyParts[index++] = this.resources[i2].resourceId;
        }
        this.key = keyParts.join("|");
      }
      setResource(resource, index) {
        const currentResource = this.resources[index];
        if (resource === currentResource)
          return;
        if (currentResource) {
          resource.off?.("change", this.onResourceChange, this);
        }
        resource.on?.("change", this.onResourceChange, this);
        this.resources[index] = resource;
        this._dirty = true;
      }
      getResource(index) {
        return this.resources[index];
      }
      touch(tick) {
        const resources = this.resources;
        for (const i2 in resources) {
          resources[i2].touched = tick;
        }
      }
      destroy() {
        const resources = this.resources;
        for (const i2 in resources) {
          const resource = resources[i2];
          resource.off?.("change", this.onResourceChange, this);
        }
        this.resources = null;
      }
      onResourceChange() {
        this._dirty = true;
        this.update();
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/batcher/shared/const.mjs
var MAX_TEXTURES;
var init_const3 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/batcher/shared/const.mjs"() {
    MAX_TEXTURES = 16;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs
function getTextureBatchBindGroup(textures, size2) {
  let uid2 = 0;
  for (let i2 = 0; i2 < size2; i2++) {
    uid2 = uid2 * 31 + textures[i2].uid >>> 0;
  }
  return cachedGroups[uid2] || generateTextureBatchBindGroup(textures, uid2);
}
function generateTextureBatchBindGroup(textures, key) {
  const bindGroupResources = {};
  let bindIndex = 0;
  for (let i2 = 0; i2 < MAX_TEXTURES; i2++) {
    const texture = i2 < textures.length ? textures[i2] : Texture.EMPTY.source;
    bindGroupResources[bindIndex++] = texture.source;
    bindGroupResources[bindIndex++] = texture.style;
  }
  const bindGroup = new BindGroup(bindGroupResources);
  cachedGroups[key] = bindGroup;
  return bindGroup;
}
var cachedGroups;
var init_getTextureBatchBindGroup = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs"() {
    init_BindGroup();
    init_Texture();
    init_const3();
    cachedGroups = {};
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensurePrecision.mjs
function ensurePrecision(src, options, isFragment) {
  const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;
  if (src.substring(0, 9) !== "precision") {
    let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;
    if (precision === "highp" && maxSupportedPrecision !== "highp") {
      precision = "mediump";
    }
    if (src.substring(0, 8) !== "#version") {
      return `precision ${precision} float;
${src}`;
    }
    const firstLineBreak = src.indexOf("\n");
    return `${src.substring(0, firstLineBreak + 1)}precision ${precision} float;
${src.substring(firstLineBreak + 1)}`;
  } else if (maxSupportedPrecision !== "highp" && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}
var init_ensurePrecision = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensurePrecision.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs
function getTestContext() {
  if (context === unknownContext || context?.isContextLost()) {
    const canvas2 = DOMAdapter.get().createCanvas();
    context = canvas2.getContext("webgl2", {});
  }
  return context;
}
var unknownContext, context;
var init_getTestContext = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs"() {
    init_adapter();
    unknownContext = {};
    context = unknownContext;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = "mediump";
    const gl = getTestContext();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? "highp" : "mediump";
      }
    }
  }
  return maxFragmentPrecision;
}
var maxFragmentPrecision;
var init_getMaxFragmentPrecision = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs"() {
    init_getTestContext();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/setProgramName.mjs
function setProgramName(src, { name = `pixi-program` }, isFragment = true) {
  name = name.replace(/\s+/g, "-");
  name += isFragment ? "-fragment" : "-vertex";
  const nameCache = isFragment ? fragmentNameCache : VertexNameCache;
  if (nameCache[name]) {
    nameCache[name]++;
    name += `-${nameCache[name]}`;
  } else {
    nameCache[name] = 1;
  }
  if (src.indexOf("#define SHADER_NAME") !== -1)
    return src;
  const shaderName = `#define SHADER_NAME ${name}`;
  if (src.substring(0, 8) !== "#version") {
    return `${shaderName}
${src}`;
  }
  const firstLineBreak = src.indexOf("\n");
  return `${src.substring(0, firstLineBreak + 1)}${shaderName}
${src.substring(firstLineBreak + 1)}`;
}
var fragmentNameCache, VertexNameCache;
var init_setProgramName = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/setProgramName.mjs"() {
    fragmentNameCache = {};
    VertexNameCache = {};
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/setProgramVersion.mjs
function setProgramVersion(src, { version = "300 es" }) {
  if (src.substring(0, 8) === "#version")
    return src;
  return `#version ${version}
${src}`;
}
var init_setProgramVersion = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/setProgramVersion.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs
var processes, _GlProgram, GlProgram;
var init_GlProgram = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs"() {
    init_ensurePrecision();
    init_getMaxFragmentPrecision();
    init_setProgramName();
    init_setProgramVersion();
    processes = {
      ensurePrecision,
      setProgramName,
      setProgramVersion
    };
    _GlProgram = class {
      constructor(options) {
        options = { ..._GlProgram.defaultOptions, ...options };
        const preprocessorOptions = {
          ensurePrecision: {
            requestedFragmentPrecision: options.preferredFragmentPrecision,
            requestedVertexPrecision: options.preferredVertexPrecision,
            maxSupportedVertexPrecision: "highp",
            maxSupportedFragmentPrecision: getMaxFragmentPrecision()
          },
          setProgramName: {
            name: options.name
          },
          setProgramVersion: {
            version: "300 es"
          }
        };
        let fragment2 = options.fragment;
        let vertex2 = options.vertex;
        Object.keys(processes).forEach((processKey) => {
          const processOptions = preprocessorOptions[processKey] ?? {};
          fragment2 = processes[processKey](fragment2, processOptions, true);
          vertex2 = processes[processKey](vertex2, processOptions, false);
        });
        this.fragment = fragment2;
        this.vertex = vertex2;
        this.key = `${this.vertex}:${this.fragment}`;
      }
      destroy() {
        this.fragment = null;
        this.vertex = null;
        this.attributeData = null;
        this.uniformData = null;
        this.uniformBlockData = null;
        this.transformFeedbackVaryings = null;
      }
      static from(options) {
        const key = `${options.vertex}:${options.fragment}`;
        if (!_GlProgram.programCached[key]) {
          _GlProgram.programCached[key] = new _GlProgram(options);
        }
        return _GlProgram.programCached[key];
      }
    };
    GlProgram = _GlProgram;
    GlProgram.defaultOptions = {
      preferredVertexPrecision: "highp",
      preferredFragmentPrecision: "mediump"
    };
    GlProgram.programCached = /* @__PURE__ */ Object.create(null);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/extractStructAndGroups.mjs
function extractStructAndGroups(wgsl) {
  const linePattern = /(?<!\/\/.*)@(group|binding)\(\d+\)[^;]+;/g;
  const groupPattern = /@group\((\d+)\)/;
  const bindingPattern = /@binding\((\d+)\)/;
  const namePattern = /var(<[^>]+>)? (\w+)/;
  const typePattern = /:\s*(\w+)/;
  const structPattern = /struct\s+(\w+)\s*{([^}]+)}/g;
  const structMemberPattern = /(\w+)\s*:\s*([\w\<\>]+)/g;
  const structName = /struct\s+(\w+)/;
  const groups = wgsl.match(linePattern)?.map((item) => ({
    group: parseInt(item.match(groupPattern)[1], 10),
    binding: parseInt(item.match(bindingPattern)[1], 10),
    name: item.match(namePattern)[2],
    isUniform: item.match(namePattern)[1] === "<uniform>",
    type: item.match(typePattern)[1]
  }));
  if (!groups) {
    return {
      groups: [],
      structs: []
    };
  }
  const structs = wgsl.match(structPattern)?.map((struct) => {
    const name = struct.match(structName)[1];
    const members = struct.match(structMemberPattern).reduce((acc, member) => {
      const [name2, type] = member.split(":");
      acc[name2.trim()] = type.trim();
      return acc;
    }, {});
    if (!members) {
      return null;
    }
    return { name, members };
  }).filter(({ name }) => groups.some((group) => group.type === name)) ?? [];
  return {
    groups,
    structs
  };
}
var init_extractStructAndGroups = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/extractStructAndGroups.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs
var ShaderStage;
var init_const4 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs"() {
    ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {
      ShaderStage2[ShaderStage2["VERTEX"] = 1] = "VERTEX";
      ShaderStage2[ShaderStage2["FRAGMENT"] = 2] = "FRAGMENT";
      ShaderStage2[ShaderStage2["COMPUTE"] = 4] = "COMPUTE";
      return ShaderStage2;
    })(ShaderStage || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/generateGpuLayoutGroups.mjs
function generateGpuLayoutGroups({ groups }) {
  const layout = [];
  for (let i2 = 0; i2 < groups.length; i2++) {
    const group = groups[i2];
    if (!layout[group.group]) {
      layout[group.group] = [];
    }
    if (group.isUniform) {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,
        buffer: {
          type: "uniform"
        }
      });
    } else if (group.type === "sampler") {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.FRAGMENT,
        sampler: {
          type: "filtering"
        }
      });
    } else if (group.type === "texture_2d") {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.FRAGMENT,
        texture: {
          sampleType: "float",
          viewDimension: "2d",
          multisampled: false
        }
      });
    }
  }
  return layout;
}
var init_generateGpuLayoutGroups = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/generateGpuLayoutGroups.mjs"() {
    init_const4();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/generateLayoutHash.mjs
function generateLayoutHash({ groups }) {
  const layout = [];
  for (let i2 = 0; i2 < groups.length; i2++) {
    const group = groups[i2];
    if (!layout[group.group]) {
      layout[group.group] = {};
    }
    layout[group.group][group.name] = group.binding;
  }
  return layout;
}
var init_generateLayoutHash = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/generateLayoutHash.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/removeStructAndGroupDuplicates.mjs
function removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {
  const structNameSet = /* @__PURE__ */ new Set();
  const dupeGroupKeySet = /* @__PURE__ */ new Set();
  const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {
    if (structNameSet.has(struct.name)) {
      return false;
    }
    structNameSet.add(struct.name);
    return true;
  });
  const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {
    const key = `${group.name}-${group.binding}`;
    if (dupeGroupKeySet.has(key)) {
      return false;
    }
    dupeGroupKeySet.add(key);
    return true;
  });
  return { structs, groups };
}
var init_removeStructAndGroupDuplicates = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/removeStructAndGroupDuplicates.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs
var _GpuProgram, GpuProgram;
var init_GpuProgram = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs"() {
    init_extractStructAndGroups();
    init_generateGpuLayoutGroups();
    init_generateLayoutHash();
    init_removeStructAndGroupDuplicates();
    _GpuProgram = class {
      constructor({ fragment: fragment2, vertex: vertex2, layout, gpuLayout, name }) {
        this._layoutKey = 0;
        this.name = name;
        this.fragment = fragment2;
        this.vertex = vertex2;
        if (fragment2.source === vertex2.source) {
          const structsAndGroups = extractStructAndGroups(fragment2.source);
          this.structsAndGroups = structsAndGroups;
        } else {
          const vertexStructsAndGroups = extractStructAndGroups(vertex2.source);
          const fragmentStructsAndGroups = extractStructAndGroups(fragment2.source);
          this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);
        }
        this.layout = layout ?? generateLayoutHash(this.structsAndGroups);
        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);
      }
      destroy() {
        this._gpuLayout = null;
        this.gpuLayout = null;
        this.layout = null;
        this.structsAndGroups = null;
        this.fragment = null;
        this.vertex = null;
      }
      static from(options) {
        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;
        if (!_GpuProgram.programCached[key]) {
          _GpuProgram.programCached[key] = new _GpuProgram(options);
        }
        return _GpuProgram.programCached[key];
      }
    };
    GpuProgram = _GpuProgram;
    GpuProgram.programCached = /* @__PURE__ */ Object.create(null);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs
function addBits(srcParts, parts, name) {
  if (srcParts) {
    for (const i2 in srcParts) {
      const id = i2.toLocaleLowerCase();
      const part = parts[id];
      if (part) {
        let sanitisedPart = srcParts[i2];
        if (i2 === "header") {
          sanitisedPart = sanitisedPart.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "");
        }
        if (name) {
          part.push(`//----${name}----//`);
        }
        part.push(sanitisedPart);
      } else {
        warn(`${i2} placement hook does not exist in shader`);
      }
    }
  }
}
var init_addBits = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs"() {
    init_warn();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs
function compileHooks(programSrc) {
  const parts = {};
  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, "")) ?? [];
  partMatches.forEach((hook) => {
    parts[hook] = [];
  });
  return parts;
}
var findHooksRx;
var init_compileHooks = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs"() {
    findHooksRx = /\{\{(.*?)\}\}/g;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs
function extractInputs(fragmentSource, out2) {
  let match;
  const regex = /@in\s+([^;]+);/g;
  while ((match = regex.exec(fragmentSource)) !== null) {
    out2.push(match[1]);
  }
}
function compileInputs(fragments, template, sort = false) {
  const results = [];
  extractInputs(template, results);
  fragments.forEach((fragment2) => {
    if (fragment2.header) {
      extractInputs(fragment2.header, results);
    }
  });
  const mainInput = results;
  if (sort) {
    mainInput.sort();
  }
  const finalString = mainInput.map((inValue, i2) => `       @location(${i2}) ${inValue},`).join("\n");
  let cleanedString = template.replace(/@in\s+[^;]+;\s*/g, "");
  cleanedString = cleanedString.replace("{{in}}", `
${finalString}
`);
  return cleanedString;
}
var init_compileInputs = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs
function extractOutputs(fragmentSource, out2) {
  let match;
  const regex = /@out\s+([^;]+);/g;
  while ((match = regex.exec(fragmentSource)) !== null) {
    out2.push(match[1]);
  }
}
function extractVariableName(value) {
  const regex = /\b(\w+)\s*:/g;
  const match = regex.exec(value);
  return match ? match[1] : "";
}
function stripVariable(value) {
  const regex = /@.*?\s+/g;
  return value.replace(regex, "");
}
function compileOutputs(fragments, template) {
  const results = [];
  extractOutputs(template, results);
  fragments.forEach((fragment2) => {
    if (fragment2.header) {
      extractOutputs(fragment2.header, results);
    }
  });
  let index = 0;
  const mainStruct = results.sort().map((inValue) => {
    if (inValue.indexOf("builtin") > -1) {
      return inValue;
    }
    return `@location(${index++}) ${inValue}`;
  }).join(",\n");
  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join("\n");
  const mainEnd = `return VSOutput(
                ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(",\n")});`;
  let compiledCode = template.replace(/@out\s+[^;]+;\s*/g, "");
  compiledCode = compiledCode.replace("{{struct}}", `
${mainStruct}
`);
  compiledCode = compiledCode.replace("{{start}}", `
${mainStart}
`);
  compiledCode = compiledCode.replace("{{return}}", `
${mainEnd}
`);
  return compiledCode;
}
var init_compileOutputs = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs
function injectBits(templateSrc, fragmentParts) {
  let out2 = templateSrc;
  for (const i2 in fragmentParts) {
    const parts = fragmentParts[i2];
    const toInject = parts.join("\n");
    if (toInject.length) {
      out2 = out2.replace(`{{${i2}}}`, `//-----${i2} START-----//
${parts.join("\n")}
//----${i2} FINISH----//`);
    } else {
      out2 = out2.replace(`{{${i2}}}`, "");
    }
  }
  return out2;
}
var init_injectBits = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs
function compileHighShader({
  template,
  bits
}) {
  const cacheId = generateCacheId(template, bits);
  if (cacheMap[cacheId])
    return cacheMap[cacheId];
  const { vertex: vertex2, fragment: fragment2 } = compileInputsAndOutputs(template, bits);
  cacheMap[cacheId] = compileBits(vertex2, fragment2, bits);
  return cacheMap[cacheId];
}
function compileHighShaderGl({
  template,
  bits
}) {
  const cacheId = generateCacheId(template, bits);
  if (cacheMap[cacheId])
    return cacheMap[cacheId];
  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);
  return cacheMap[cacheId];
}
function compileInputsAndOutputs(template, bits) {
  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v3) => !!v3);
  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v3) => !!v3);
  let compiledVertex = compileInputs(vertexFragments, template.vertex);
  compiledVertex = compileOutputs(vertexFragments, compiledVertex);
  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);
  return {
    vertex: compiledVertex,
    fragment: compiledFragment
  };
}
function generateCacheId(template, bits) {
  return bits.map((highFragment) => {
    if (!bitCacheMap.has(highFragment)) {
      bitCacheMap.set(highFragment, CACHE_UID++);
    }
    return bitCacheMap.get(highFragment);
  }).sort((a2, b2) => a2 - b2).join("-") + template.vertex + template.fragment;
}
function compileBits(vertex2, fragment2, bits) {
  const vertexParts = compileHooks(vertex2);
  const fragmentParts = compileHooks(fragment2);
  bits.forEach((shaderBit) => {
    addBits(shaderBit.vertex, vertexParts, shaderBit.name);
    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);
  });
  return {
    vertex: injectBits(vertex2, vertexParts),
    fragment: injectBits(fragment2, fragmentParts)
  };
}
var cacheMap, bitCacheMap, CACHE_UID;
var init_compileHighShader = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs"() {
    init_addBits();
    init_compileHooks();
    init_compileInputs();
    init_compileOutputs();
    init_injectBits();
    cacheMap = /* @__PURE__ */ Object.create(null);
    bitCacheMap = /* @__PURE__ */ new Map();
    CACHE_UID = 0;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs
var vertexGPUTemplate, fragmentGPUTemplate, vertexGlTemplate, fragmentGlTemplate;
var init_defaultProgramTemplate = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs"() {
    vertexGPUTemplate = /* wgsl */
    `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.worldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);
        vUV = aUV;

        {{main}}

        var modelViewProjectionMatrix = globalUniforms.projectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.worldAlpha;

        {{end}}

        {{return}}
    };
`;
    fragmentGPUTemplate = /* wgsl */
    `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        return outColor * vColor;
      };
`;
    vertexGlTemplate = /* glsl */
    `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = worldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;

        {{start}}
        
        vColor = vec4(1.);
        vUV = aUV;

        {{main}}

        mat3 modelViewProjectionMatrix = projectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= worldAlpha;

        {{end}}
    }
`;
    fragmentGlTemplate = /* glsl */
    `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
    }
`;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs
var globalUniformsBit, globalUniformsBitGl;
var init_globalUniformsBit = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs"() {
    globalUniformsBit = {
      name: "global-uniforms-bit",
      vertex: {
        header: (
          /* wgsl */
          `
        struct GlobalUniforms {
            projectionMatrix:mat3x3<f32>,
            worldTransformMatrix:mat3x3<f32>,
            worldAlpha: f32,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
        )
      }
    };
    globalUniformsBitGl = {
      name: "global-uniforms-bit",
      vertex: {
        header: (
          /* glsl */
          `
          uniform globalUniforms {
            mat3 projectionMatrix;
            mat3 worldTransformMatrix;
            float worldAlpha;
            vec2 uResolution;
          };
        `
        )
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs
function compileHighShaderGpuProgram({ bits, name }) {
  const source3 = compileHighShader({
    template: {
      fragment: fragmentGPUTemplate,
      vertex: vertexGPUTemplate
    },
    bits: [
      globalUniformsBit,
      ...bits
    ]
  });
  return new GpuProgram({
    name,
    vertex: {
      source: source3.vertex,
      entryPoint: "main"
    },
    fragment: {
      source: source3.fragment,
      entryPoint: "main"
    }
  });
}
function compileHighShaderGlProgram({ bits, name }) {
  return new GlProgram({
    name,
    ...compileHighShaderGl({
      template: {
        vertex: vertexGlTemplate,
        fragment: fragmentGlTemplate
      },
      bits: [
        globalUniformsBitGl,
        ...bits
      ]
    })
  });
}
var init_compileHighShaderToProgram = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs"() {
    init_GlProgram();
    init_GpuProgram();
    init_compileHighShader();
    init_defaultProgramTemplate();
    init_globalUniformsBit();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs
var colorBit, colorBitGl;
var init_colorBit = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs"() {
    colorBit = {
      name: "color-bit",
      vertex: {
        header: (
          /* wgsl */
          `
            @in aColor: vec4<f32>;
        `
        ),
        main: (
          /* wgsl */
          `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
        )
      }
    };
    colorBitGl = {
      name: "color-bit",
      vertex: {
        header: (
          /* glsl */
          `
            in vec4 aColor;
        `
        ),
        main: (
          /* glsl */
          `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
        )
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs
function generateBindingSrc(maxTextures) {
  const src = [];
  if (maxTextures === 1) {
    src.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;");
    src.push("@group(1) @binding(1) var textureSampler1: sampler;");
  } else {
    let bindingIndex = 0;
    for (let i2 = 0; i2 < maxTextures; i2++) {
      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i2 + 1}: texture_2d<f32>;`);
      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i2 + 1}: sampler;`);
    }
  }
  return src.join("\n");
}
function generateSampleSrc(maxTextures) {
  const src = [];
  if (maxTextures === 1) {
    src.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
  } else {
    src.push("switch vTextureId {");
    for (let i2 = 0; i2 < maxTextures; i2++) {
      if (i2 === maxTextures - 1) {
        src.push(`  default:{`);
      } else {
        src.push(`  case ${i2}:{`);
      }
      src.push(`      outColor = textureSampleGrad(textureSource${i2 + 1}, textureSampler${i2 + 1}, vUV, uvDx, uvDy);`);
      src.push(`      break;}`);
    }
    src.push(`}`);
  }
  return src.join("\n");
}
function generateTextureBatchBit(maxTextures) {
  if (!textureBatchBitGpuCache[maxTextures]) {
    textureBatchBitGpuCache[maxTextures] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
      },
      fragment: {
        header: `
                @in @interpolate(flat) vTextureId: u32;
    
                ${generateBindingSrc(16)}
            `,
        main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);
    
                ${generateSampleSrc(16)}
            `
      }
    };
  }
  return textureBatchBitGpuCache[maxTextures];
}
function generateSampleGlSrc(maxTextures) {
  const src = [];
  for (let i2 = 0; i2 < maxTextures; i2++) {
    if (i2 > 0) {
      src.push("else");
    }
    if (i2 < maxTextures - 1) {
      src.push(`if(vTextureId < ${i2}.5)`);
    }
    src.push("{");
    src.push(`	outColor = texture(uSamplers[${i2}], vUV);`);
    src.push("}");
  }
  return src.join("\n");
}
function generateTextureBatchBitGl(maxTextures) {
  if (!textureBatchBitGlCache[maxTextures]) {
    textureBatchBitGlCache[maxTextures] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;
              
            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
      },
      fragment: {
        header: `
                in float vTextureId;
    
                uniform sampler2D uSamplers[${maxTextures}];
              
            `,
        main: `
    
                ${generateSampleGlSrc(16)}
            `
      }
    };
  }
  return textureBatchBitGlCache[maxTextures];
}
var textureBatchBitGpuCache, textureBatchBitGlCache;
var init_generateTextureBatchBit = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs"() {
    textureBatchBitGpuCache = {};
    textureBatchBitGlCache = {};
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs
var localUniformBit, localUniformBitGroup2, localUniformBitGl;
var init_localUniformBit = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs"() {
    localUniformBit = {
      name: "local-uniform-bit",
      vertex: {
        header: (
          /* wgsl */
          `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
        ),
        main: (
          /* wgsl */
          `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
        ),
        end: (
          /* wgsl */
          `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        )
      }
    };
    localUniformBitGroup2 = {
      ...localUniformBit,
      vertex: {
        ...localUniformBit.vertex,
        // replace the group!
        header: localUniformBit.vertex.header.replace("group(1)", "group(2)")
      }
    };
    localUniformBitGl = {
      name: "local-uniform-bit",
      vertex: {
        header: (
          /* glsl */
          `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
        ),
        main: (
          /* glsl */
          `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `
        ),
        end: (
          /* glsl */
          `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
        )
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs
var roundPixelsBit, roundPixelsBitGl;
var init_roundPixelsBit = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs"() {
    roundPixelsBit = {
      name: "round-pixels-bit",
      vertex: {
        header: (
          /* wgsl */
          `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;
            }
        `
        )
      }
    };
    roundPixelsBitGl = {
      name: "round-pixels-bit",
      vertex: {
        header: (
          /* glsl */
          `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;
            }
        `
        )
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/types.mjs
var RendererType;
var init_types = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/types.mjs"() {
    RendererType = /* @__PURE__ */ ((RendererType2) => {
      RendererType2[RendererType2["WEBGL"] = 1] = "WEBGL";
      RendererType2[RendererType2["WEBGPU"] = 2] = "WEBGPU";
      return RendererType2;
    })(RendererType || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/defaultUniformValue.mjs
function defaultUniformValue(type, size2) {
  switch (type) {
    case "f32":
      return 0;
    case "vec2<f32>":
      return new Float32Array(2 * size2);
    case "vec3<f32>":
      return new Float32Array(3 * size2);
    case "vec4<f32>":
      return new Float32Array(4 * size2);
    case "mat2x2<f32>":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3x3<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4x4<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var init_defaultUniformValue = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/defaultUniformValue.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs
var _UniformGroup, UniformGroup;
var init_UniformGroup = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"() {
    init_uid();
    init_defaultUniformValue();
    _UniformGroup = class {
      constructor(uniformStructures, options) {
        this.touched = 0;
        this.uid = uid("uniform");
        this.resourceType = "uniformGroup";
        this.resourceId = this.uid;
        this.isUniformGroup = true;
        this.dirtyId = 0;
        options = { ..._UniformGroup.DEFAULT, ...options };
        this.uniformStructures = uniformStructures;
        const uniforms = {};
        for (const i2 in uniformStructures) {
          const uniformData = uniformStructures[i2];
          uniformData.name = i2;
          uniformData.size = uniformData.size ?? 1;
          uniformData.value ?? (uniformData.value = defaultUniformValue(uniformData.type, uniformData.size));
          uniforms[i2] = uniformData.value;
        }
        this.uniforms = uniforms;
        this.dirtyId = 1;
        this.ubo = options.ubo;
        this.isStatic = options.isStatic;
        this.signature = Object.keys(uniforms).map(
          (i2) => `${i2}-${uniformStructures[i2].type}`
        ).join("-");
      }
      update() {
        this.dirtyId++;
      }
    };
    UniformGroup = _UniformGroup;
    UniformGroup.DEFAULT = {
      ubo: false,
      isStatic: false
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs
var Shader;
var init_Shader = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs"() {
    init_eventemitter3();
    init_BindGroup();
    init_types();
    init_UniformGroup();
    Shader = class extends eventemitter3_default {
      constructor({ gpuProgram, glProgram, groups, resources, groupMap, compatibleRenderers }) {
        super();
        this.uniformBindMap = /* @__PURE__ */ Object.create(null);
        this.gpuProgram = gpuProgram;
        this.glProgram = glProgram;
        if (compatibleRenderers === void 0) {
          compatibleRenderers = 0;
          if (gpuProgram)
            compatibleRenderers |= RendererType.WEBGPU;
          if (glProgram)
            compatibleRenderers |= RendererType.WEBGL;
        }
        this.compatibleRenderers = compatibleRenderers;
        const nameHash = {};
        if (resources && groups) {
          throw new Error("[Shader] Cannot have both resources and groups");
        } else if (!resources && !groups) {
          throw new Error("[Shader] Must provide either resources or groups descriptor");
        } else if (!gpuProgram && groups && !groupMap) {
          throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
        } else if (!gpuProgram && groups && groupMap) {
          for (const i2 in groupMap) {
            for (const j3 in groupMap[i2]) {
              const uniformName = groupMap[i2][j3];
              nameHash[uniformName] = {
                group: i2,
                binding: j3,
                name: uniformName
              };
            }
          }
        } else if (gpuProgram && groups && !groupMap) {
          const groupData = gpuProgram.structsAndGroups.groups;
          groupMap = {};
          groupData.forEach((data) => {
            groupMap[data.group] = groupMap[data.group] || {};
            groupMap[data.group][data.binding] = data.name;
            nameHash[data.name] = data;
          });
        } else if (resources) {
          if (!gpuProgram) {
            groupMap = {};
            groups = {
              99: new BindGroup()
            };
            let bindTick = 0;
            for (const i2 in resources) {
              nameHash[i2] = { group: 99, binding: bindTick, name: i2 };
              groupMap[99] = groupMap[99] || {};
              groupMap[99][bindTick] = i2;
              bindTick++;
            }
          } else {
            const groupData = gpuProgram.structsAndGroups.groups;
            groupMap = {};
            groupData.forEach((data) => {
              groupMap[data.group] = groupMap[data.group] || {};
              groupMap[data.group][data.binding] = data.name;
              nameHash[data.name] = data;
            });
          }
          groups = {};
          for (const i2 in resources) {
            const name = i2;
            let value = resources[i2];
            if (!value.source && !value.resourceType) {
              value = new UniformGroup(value);
            }
            const data = nameHash[name];
            if (data) {
              groups[data.group] = groups[data.group] || new BindGroup();
              groups[data.group].setResource(value, data.binding);
            }
          }
        }
        this.groups = groups;
        this.uniformBindMap = groupMap;
        this.resources = this._buildResourceAccessor(groups, nameHash);
      }
      addResource(name, groupIndex, bindIndex) {
        var _a, _b;
        (_a = this.uniformBindMap)[groupIndex] || (_a[groupIndex] = {});
        (_b = this.uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);
      }
      _buildResourceAccessor(groups, nameHash) {
        const uniformsOut = {};
        for (const i2 in nameHash) {
          const data = nameHash[i2];
          Object.defineProperty(uniformsOut, data.name, {
            get() {
              return groups[data.group].getResource(data.binding);
            },
            set(value) {
              groups[data.group].setResource(value, data.binding);
            }
          });
        }
        return uniformsOut;
      }
      destroy(destroyProgram = false) {
        this.emit("destroy", this);
        if (destroyProgram) {
          this.gpuProgram?.destroy();
          this.glProgram?.destroy();
        }
        this.gpuProgram = null;
        this.glProgram = null;
        this.groups = null;
        this.removeAllListeners();
        this.uniformBindMap = null;
        this.resources = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs
var GpuGraphicsAdaptor;
var init_GpuGraphicsAdaptor = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs"() {
    init_Extensions();
    init_Matrix();
    init_getTextureBatchBindGroup();
    init_const3();
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_localUniformBit();
    init_roundPixelsBit();
    init_Shader();
    init_UniformGroup();
    GpuGraphicsAdaptor = class {
      init() {
        const localUniforms = new UniformGroup({
          uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          uRound: { value: 0, type: "f32" }
        });
        const gpuProgram = compileHighShaderGpuProgram({
          name: "graphics",
          bits: [
            colorBit,
            generateTextureBatchBit(MAX_TEXTURES),
            localUniformBitGroup2,
            roundPixelsBit
          ]
        });
        this.shader = new Shader({
          gpuProgram,
          resources: {
            // added on the fly!
            localUniforms
          }
        });
        this.shader.addResource("globalUniforms", 0, 0);
      }
      execute(graphicsPipe, renderable) {
        const context2 = renderable.view.context;
        const shader = context2.customShader || this.shader;
        const renderer = graphicsPipe.renderer;
        const contextSystem = renderer.graphicsContext;
        const {
          geometry,
          instructions
        } = contextSystem.getContextRenderData(context2);
        const encoder = renderer.encoder;
        encoder.setPipelineFromGeometryProgramAndState(
          geometry,
          shader.gpuProgram,
          graphicsPipe.state
        );
        encoder.setGeometry(geometry);
        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
        encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);
        const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);
        encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);
        const batches = instructions.instructions;
        for (let i2 = 0; i2 < instructions.instructionSize; i2++) {
          const batch = batches[i2];
          shader.groups[1] = batch.bindGroup;
          if (!batch.gpuBindGroup) {
            const textureBatch = batch.textures;
            batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);
            batch.gpuBindGroup = renderer.bindGroup.getBindGroup(
              batch.bindGroup,
              shader.gpuProgram,
              1
            );
          }
          encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);
          encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
        }
      }
      destroy() {
        this.shader.destroy(true);
        this.shader = null;
      }
    };
    GpuGraphicsAdaptor.extension = {
      type: [
        ExtensionType.WebGPUPipesAdaptor
      ],
      name: "graphics"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs
var textureBit, textureBitGl;
var init_textureBit = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs"() {
    textureBit = {
      name: "texture-bit",
      fragment: {
        header: (
          /* wgsl */
          `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `
        ),
        main: (
          /* wgsl */
          `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
        )
      }
    };
    textureBitGl = {
      name: "texture-bit",
      fragment: {
        header: (
          /* wgsl */
          `
        uniform sampler2D uTexture;

         
        `
        ),
        main: (
          /* wgsl */
          `
            outColor = texture(uTexture, vUV);
        `
        )
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs
var GpuMeshAdapter;
var init_GpuMeshAdapter = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs"() {
    init_Extensions();
    init_compileHighShaderToProgram();
    init_localUniformBit();
    init_roundPixelsBit();
    init_textureBit();
    init_Shader();
    init_Texture();
    GpuMeshAdapter = class {
      init() {
        const gpuProgram = compileHighShaderGpuProgram({
          name: "mesh",
          bits: [
            localUniformBit,
            textureBit,
            roundPixelsBit
          ]
        });
        this._shader = new Shader({
          gpuProgram,
          resources: {
            uTexture: Texture.EMPTY._source,
            uSampler: Texture.EMPTY._source.style
          }
        });
      }
      execute(meshPipe, renderable) {
        const renderer = meshPipe.renderer;
        const view = renderable.view;
        let shader = view._shader;
        if (!shader) {
          shader = this._shader;
          shader.groups[2] = renderer.texture.getTextureBindGroup(view.texture);
        }
        shader.groups[0] = renderer.globalUniforms.bindGroup;
        const localUniforms = meshPipe.localUniforms;
        shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);
        renderer.encoder.draw({
          geometry: view._geometry,
          shader,
          state: view.state
        });
      }
      destroy() {
        this._shader.destroy(true);
        this._shader = null;
      }
    };
    GpuMeshAdapter.extension = {
      type: [
        ExtensionType.WebGPUPipesAdaptor
      ],
      name: "mesh"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs
var blendModeIds, BLEND, OFFSET, CULLING, DEPTH_TEST, WINDING, DEPTH_MASK, State;
var init_State = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs"() {
    blendModeIds = {
      normal: 0,
      additive: 1,
      multiply: 2,
      screen: 3,
      overlay: 4,
      erase: 5
    };
    BLEND = 0;
    OFFSET = 1;
    CULLING = 2;
    DEPTH_TEST = 3;
    WINDING = 4;
    DEPTH_MASK = 5;
    State = class _State {
      constructor() {
        this.data = 0;
        this.blendMode = "normal";
        this.polygonOffset = 0;
        this.blend = true;
        this.depthMask = true;
      }
      /**
       * Activates blending of the computed fragment color values.
       * @default true
       */
      get blend() {
        return !!(this.data & 1 << BLEND);
      }
      set blend(value) {
        if (!!(this.data & 1 << BLEND) !== value) {
          this.data ^= 1 << BLEND;
        }
      }
      /**
       * Activates adding an offset to depth values of polygon's fragments
       * @default false
       */
      get offsets() {
        return !!(this.data & 1 << OFFSET);
      }
      set offsets(value) {
        if (!!(this.data & 1 << OFFSET) !== value) {
          this.data ^= 1 << OFFSET;
        }
      }
      set cullMode(value) {
        if (value === "none") {
          this.culling = false;
          return;
        }
        this.culling = true;
        this.clockwiseFrontFace = value === "front";
      }
      get cullMode() {
        if (!this.culling) {
          return "none";
        }
        return this.clockwiseFrontFace ? "front" : "back";
      }
      /**
       * Activates culling of polygons.
       * @default false
       */
      get culling() {
        return !!(this.data & 1 << CULLING);
      }
      set culling(value) {
        if (!!(this.data & 1 << CULLING) !== value) {
          this.data ^= 1 << CULLING;
        }
      }
      /**
       * Activates depth comparisons and updates to the depth buffer.
       * @default false
       */
      get depthTest() {
        return !!(this.data & 1 << DEPTH_TEST);
      }
      set depthTest(value) {
        if (!!(this.data & 1 << DEPTH_TEST) !== value) {
          this.data ^= 1 << DEPTH_TEST;
        }
      }
      /**
       * Enables or disables writing to the depth buffer.
       * @default true
       */
      get depthMask() {
        return !!(this.data & 1 << DEPTH_MASK);
      }
      set depthMask(value) {
        if (!!(this.data & 1 << DEPTH_MASK) !== value) {
          this.data ^= 1 << DEPTH_MASK;
        }
      }
      /**
       * Specifies whether or not front or back-facing polygons can be culled.
       * @default false
       */
      get clockwiseFrontFace() {
        return !!(this.data & 1 << WINDING);
      }
      set clockwiseFrontFace(value) {
        if (!!(this.data & 1 << WINDING) !== value) {
          this.data ^= 1 << WINDING;
        }
      }
      /**
       * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.
       * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
       * @default 'normal'
       */
      get blendMode() {
        return this._blendMode;
      }
      set blendMode(value) {
        this.blend = value !== "none";
        this._blendMode = value;
        this._blendModeId = blendModeIds[value] || 0;
      }
      /**
       * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
       * @default 0
       */
      get polygonOffset() {
        return this._polygonOffset;
      }
      set polygonOffset(value) {
        this.offsets = !!value;
        this._polygonOffset = value;
      }
      toString() {
        return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
      }
      static for2d() {
        const state = new _State();
        state.depthTest = false;
        state.blend = true;
        return state;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs
var tempState, GpuBatchAdaptor;
var init_GpuBatchAdaptor = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs"() {
    init_Extensions();
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_roundPixelsBit();
    init_Shader();
    init_State();
    init_const3();
    init_getTextureBatchBindGroup();
    tempState = State.for2d();
    GpuBatchAdaptor = class {
      init() {
        const gpuProgram = compileHighShaderGpuProgram({
          name: "batch",
          bits: [
            colorBit,
            generateTextureBatchBit(MAX_TEXTURES),
            roundPixelsBit
          ]
        });
        this._shader = new Shader({
          gpuProgram,
          groups: {
            // these will be dynamically allocated
          }
        });
      }
      start(batchPipe, geometry) {
        const renderer = batchPipe.renderer;
        const encoder = renderer.encoder;
        const program = this._shader.gpuProgram;
        this._geometry = geometry;
        encoder.setGeometry(geometry);
        tempState.blendMode = "normal";
        renderer.pipeline.getPipeline(
          geometry,
          program,
          tempState
        );
        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
        encoder.setBindGroup(0, globalUniformsBindGroup, program);
      }
      execute(batchPipe, batch) {
        const program = this._shader.gpuProgram;
        const renderer = batchPipe.renderer;
        const encoder = renderer.encoder;
        if (!batch.bindGroup) {
          const textureBatch = batch.textures;
          batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);
        }
        tempState.blendMode = batch.blendMode;
        const gpuBindGroup = renderer.bindGroup.getBindGroup(
          batch.bindGroup,
          program,
          1
        );
        const pipeline = renderer.pipeline.getPipeline(
          this._geometry,
          program,
          tempState
        );
        batch.bindGroup.touch(renderer.textureGC.count);
        encoder.setPipeline(pipeline);
        encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);
        encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
      }
      destroy() {
        this._shader.destroy(true);
        this._shader = null;
      }
    };
    GpuBatchAdaptor.extension = {
      type: [
        ExtensionType.WebGPUPipesAdaptor
      ],
      name: "batch"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/FilterPipe.mjs
var FilterPipe;
var init_FilterPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/FilterPipe.mjs"() {
    init_Extensions();
    FilterPipe = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      push(filterEffect, container, instructionSet) {
        const renderPipes3 = this._renderer.renderPipes;
        renderPipes3.batch.break(instructionSet);
        instructionSet.add({
          type: "filter",
          canBundle: false,
          action: "pushFilter",
          container,
          filterEffect
        });
      }
      pop(_filterEffect, _container, instructionSet) {
        this._renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          type: "filter",
          action: "popFilter",
          canBundle: false
        });
      }
      execute(instruction) {
        if (instruction.action === "pushFilter") {
          this._renderer.filter.push(instruction);
        } else if (instruction.action === "popFilter") {
          this._renderer.filter.pop();
        }
      }
      destroy() {
        this._renderer = null;
      }
    };
    FilterPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "filter"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs
var Buffer2;
var init_Buffer = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs"() {
    init_eventemitter3();
    init_uid();
    Buffer2 = class extends eventemitter3_default {
      constructor({ data, size: size2, usage, label }) {
        super();
        this.resourceType = "buffer";
        this.resourceId = uid("bufferResource");
        this.touched = 0;
        this.uid = uid("buffer");
        this._updateID = 1;
        if (data instanceof Array) {
          data = new Float32Array(data);
        }
        this._data = data;
        size2 = size2 ?? data?.byteLength;
        const mappedAtCreation = !!data;
        this.descriptor = {
          size: size2,
          usage,
          mappedAtCreation,
          label
        };
      }
      get data() {
        return this._data;
      }
      set data(value) {
        if (this._data !== value) {
          const oldData = this._data;
          this._data = value;
          if (oldData.length !== value.length) {
            this.descriptor.size = value.byteLength;
            this.resourceId = uid("bufferResource");
            this.emit("change", this);
          } else {
            this.emit("update", this);
          }
        }
      }
      update(sizeInBytes) {
        this._updateSize = sizeInBytes || this.descriptor.size;
        this._updateID++;
        this.emit("update", this);
      }
      destroy() {
        this.emit("destroy", this);
        this._data = null;
        this.descriptor = null;
        this.removeAllListeners();
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs
var BufferUsage;
var init_const5 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs"() {
    BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {
      BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";
      BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";
      BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";
      BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";
      BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";
      BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";
      BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";
      BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";
      BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";
      BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";
      BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";
      return BufferUsage2;
    })(BufferUsage || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs
function ensureIsBuffer(buffer, index) {
  if (!(buffer instanceof Buffer2)) {
    let usage = index ? BufferUsage.INDEX : BufferUsage.VERTEX;
    if (buffer instanceof Array) {
      if (index) {
        buffer = new Uint32Array(buffer);
        usage = BufferUsage.INDEX | BufferUsage.COPY_DST;
      } else {
        buffer = new Float32Array(buffer);
        usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;
      }
    }
    buffer = new Buffer2({
      data: buffer,
      label: "index-mesh-buffer",
      usage
    });
  }
  return buffer;
}
var init_ensureIsBuffer = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs"() {
    init_Buffer();
    init_const5();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs
var Geometry;
var init_Geometry = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs"() {
    init_eventemitter3();
    init_uid();
    init_ensureIsBuffer();
    Geometry = class extends eventemitter3_default {
      constructor({ attributes, indexBuffer, topology }) {
        super();
        this.uid = uid("geometry");
        this._layoutKey = 0;
        this.attributes = attributes;
        this.buffers = [];
        for (const i2 in attributes) {
          const attribute = attributes[i2];
          attribute.buffer = ensureIsBuffer(attribute.buffer, false);
          const bufferIndex = this.buffers.indexOf(attribute.buffer);
          if (bufferIndex === -1) {
            this.buffers.push(attribute.buffer);
            attribute.buffer.on("update", this.onBufferUpdate, this);
          }
        }
        if (indexBuffer) {
          this.indexBuffer = ensureIsBuffer(indexBuffer, true);
          this.buffers.push(this.indexBuffer);
        }
        this.topology = topology || "triangle-list";
      }
      onBufferUpdate() {
        this.emit("update", this);
      }
      /**
       * Returns the requested attribute.
       * @param id - The name of the attribute required
       * @returns - The attribute requested.
       */
      getAttribute(id) {
        return this.attributes[id];
      }
      /**
       * Returns the index buffer
       * @returns - The index buffer.
       */
      getIndex() {
        return this.indexBuffer;
      }
      /**
       * Returns the requested buffer.
       * @param id - The name of the buffer required.
       * @returns - The buffer requested.
       */
      getBuffer(id) {
        return this.getAttribute(id).buffer;
      }
      getSize() {
        for (const i2 in this.attributes) {
          const attribute = this.attributes[i2];
          const buffer = this.getBuffer(i2);
          return buffer.data.length / (attribute.stride / 4 || attribute.size);
        }
        return 0;
      }
      destroy(destroyBuffers = false) {
        this.emit("destroy", this);
        this.removeAllListeners();
        if (destroyBuffers) {
          this.buffers.forEach((buffer) => buffer.destroy());
        }
        this.attributes = null;
        this.buffers = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/misc/pow2.mjs
function nextPow2(v3) {
  v3 += v3 === 0 ? 1 : 0;
  --v3;
  v3 |= v3 >>> 1;
  v3 |= v3 >>> 2;
  v3 |= v3 >>> 4;
  v3 |= v3 >>> 8;
  v3 |= v3 >>> 16;
  return v3 + 1;
}
var init_pow2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/maths/misc/pow2.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs
var count, TexturePoolClass, TexturePool;
var init_TexturePool = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs"() {
    init_pow2();
    init_TextureSource();
    init_Texture();
    count = 0;
    TexturePoolClass = class {
      /**
       * @param textureOptions - options that will be passed to BaseRenderTexture constructor
       * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.
       */
      constructor(textureOptions) {
        this._poolKeyHash = /* @__PURE__ */ Object.create(null);
        this._texturePool = {};
        this.textureOptions = textureOptions || {};
        this.enableFullScreen = false;
      }
      /**
       * Creates texture with params that were specified in pool constructor.
       * @param pixelWidth - Width of texture in pixels.
       * @param pixelHeight - Height of texture in pixels.
       * @param antialias
       */
      createTexture(pixelWidth, pixelHeight, antialias) {
        const textureSource = new TextureSource({
          ...this.textureOptions,
          width: pixelWidth,
          height: pixelHeight,
          resolution: 1,
          antialias
        });
        return new Texture({
          source: textureSource,
          label: `texturePool_${count++}`
        });
      }
      /**
       * Gets a Power-of-Two render texture or fullScreen texture
       * @param frameWidth - The minimum width of the render texture.
       * @param frameHeight - The minimum height of the render texture.
       * @param resolution - The resolution of the render texture.
       * @param antialias
       * @returns The new render texture.
       */
      getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {
        let po2Width = Math.ceil(frameWidth * resolution - 1e-6);
        let po2Height = Math.ceil(frameHeight * resolution - 1e-6);
        po2Width = nextPow2(po2Width);
        po2Height = nextPow2(po2Height);
        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);
        if (!this._texturePool[key]) {
          this._texturePool[key] = [];
        }
        let texture = this._texturePool[key].pop();
        if (!texture) {
          texture = this.createTexture(po2Width, po2Height, antialias);
        }
        texture.source._resolution = resolution;
        texture.source.width = po2Width / resolution;
        texture.source.height = po2Height / resolution;
        texture.source.pixelWidth = po2Width;
        texture.source.pixelHeight = po2Height;
        texture.frameX = 0;
        texture.frameY = 0;
        texture.frameWidth = frameWidth;
        texture.frameHeight = frameHeight;
        texture.layout.update();
        this._poolKeyHash[texture.id] = key;
        return texture;
      }
      getSameSizeTexture(texture, antialias = false) {
        const source3 = texture.source;
        return this.getOptimalTexture(texture.width, texture.height, source3._resolution, antialias);
      }
      /**
       * Place a render texture back into the pool.
       * @param renderTexture - The renderTexture to free
       */
      returnTexture(renderTexture) {
        const key = this._poolKeyHash[renderTexture.id];
        this._texturePool[key].push(renderTexture);
      }
      /**
       * Clears the pool.
       * @param destroyTextures - Destroy all stored textures.
       */
      clear(destroyTextures) {
        destroyTextures = destroyTextures !== false;
        if (destroyTextures) {
          for (const i2 in this._texturePool) {
            const textures = this._texturePool[i2];
            if (textures) {
              for (let j3 = 0; j3 < textures.length; j3++) {
                textures[j3].destroy(true);
              }
            }
          }
        }
        this._texturePool = {};
      }
    };
    TexturePool = new TexturePoolClass();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs
function getGlobalRenderableBounds(renderables, bounds) {
  bounds.clear();
  const tempMatrix4 = bounds.matrix;
  for (let i2 = 0; i2 < renderables.length; i2++) {
    const renderable = renderables[i2];
    if (renderable.layerVisibleRenderable < 3) {
      continue;
    }
    bounds.matrix = renderable.worldTransform;
    renderable.view.addBounds(bounds);
  }
  bounds.matrix = tempMatrix4;
  return bounds;
}
var init_getRenderableBounds = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/FilterSystem.mjs
var quadGeometry, FilterSystem;
var init_FilterSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/FilterSystem.mjs"() {
    init_Extensions();
    init_Matrix();
    init_Point();
    init_BindGroup();
    init_Geometry();
    init_UniformGroup();
    init_Texture();
    init_TexturePool();
    init_Bounds();
    init_getGlobalBounds();
    init_getRenderableBounds();
    init_warn();
    quadGeometry = new Geometry({
      attributes: {
        aPosition: {
          buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
          shaderLocation: 0,
          format: "float32x2",
          stride: 2 * 4,
          offset: 0
        }
      },
      indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])
    });
    FilterSystem = class {
      constructor(renderer) {
        this._filterStackIndex = 0;
        this._filterStack = [];
        this._filterGlobalUniforms = new UniformGroup({
          inputSize: { value: new Float32Array(4), type: "vec4<f32>" },
          inputPixel: { value: new Float32Array(4), type: "vec4<f32>" },
          inputClamp: { value: new Float32Array(4), type: "vec4<f32>" },
          outputFrame: { value: new Float32Array(4), type: "vec4<f32>" },
          globalFrame: { value: new Float32Array(4), type: "vec4<f32>" },
          outputTexture: { value: new Float32Array(4), type: "vec4<f32>" }
        });
        this._globalFilterBindGroup = new BindGroup({});
        this.renderer = renderer;
      }
      push(instruction) {
        const renderer = this.renderer;
        const filters = instruction.filterEffect.filters;
        if (!this._filterStack[this._filterStackIndex]) {
          this._filterStack[this._filterStackIndex] = this._getFilterData();
        }
        const filterData = this._filterStack[this._filterStackIndex];
        this._filterStackIndex++;
        const bounds = filterData.bounds;
        if (instruction.renderables) {
          getGlobalRenderableBounds(instruction.renderables, bounds);
        } else {
          getGlobalBounds(instruction.container, true, bounds);
        }
        if (filters.length === 0) {
          filterData.skip = true;
          return;
        }
        let resolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;
        let padding = 0;
        let antialias = renderer.renderTarget.rootRenderTarget.colorTexture.source.antialias;
        let blendRequired = false;
        let enabled = false;
        for (let i2 = 0; i2 < filters.length; i2++) {
          const filter = filters[i2];
          resolution = Math.min(resolution, filter.resolution);
          padding += filter.padding;
          if (filter.antialias !== "inherit") {
            if (filter.antialias === "on") {
              antialias = true;
            } else {
              antialias = false;
            }
          }
          const isCompatible = !!(filter.compatibleRenderers & renderer.type);
          if (!isCompatible) {
            enabled = false;
            break;
          }
          if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {
            warn("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.");
            enabled = false;
            break;
          }
          enabled = filter.enabled || enabled;
          blendRequired = blendRequired || filter.blendRequired;
        }
        if (!enabled) {
          filterData.skip = true;
          return;
        }
        bounds.scale(resolution).fit(renderer.renderTarget.rootRenderTarget.viewport).scale(1 / resolution).pad(padding).ceil();
        if (!bounds.isPositive) {
          filterData.skip = true;
          return;
        }
        filterData.skip = false;
        filterData.bounds = bounds;
        filterData.blendRequired = blendRequired;
        filterData.container = instruction.container;
        filterData.filterEffect = instruction.filterEffect;
        filterData.previousRenderSurface = renderer.renderTarget.renderTarget;
        filterData.inputTexture = TexturePool.getOptimalTexture(
          bounds.width,
          bounds.height,
          resolution,
          antialias
        );
        renderer.renderTarget.bind(filterData.inputTexture, true);
        renderer.globalUniforms.push({
          offset: bounds
        });
      }
      pop() {
        const renderer = this.renderer;
        this._filterStackIndex--;
        const filterData = this._filterStack[this._filterStackIndex];
        if (filterData.skip) {
          return;
        }
        this._activeFilterData = filterData;
        const inputTexture = filterData.inputTexture;
        const bounds = filterData.bounds;
        let backTexture = Texture.EMPTY;
        renderer.renderTarget.finishRenderPass?.();
        if (filterData.blendRequired) {
          renderer.encoder.finishRenderPass();
          const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;
          backTexture = this.getBackTexture(filterData.previousRenderSurface, bounds, previousBounds);
        }
        filterData.backTexture = backTexture;
        const filters = filterData.filterEffect.filters;
        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);
        this._globalFilterBindGroup.setResource(backTexture.source, 3);
        renderer.globalUniforms.pop();
        if (filters.length === 1) {
          filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);
          TexturePool.returnTexture(inputTexture);
        } else {
          let flip = filterData.inputTexture;
          let flop = TexturePool.getOptimalTexture(
            bounds.width,
            bounds.height,
            flip.source._resolution,
            false
          );
          let i2 = 0;
          for (i2 = 0; i2 < filters.length - 1; ++i2) {
            const filter = filters[i2];
            filter.apply(this, flip, flop, true);
            const t2 = flip;
            flip = flop;
            flop = t2;
          }
          filters[i2].apply(this, flip, filterData.previousRenderSurface, false);
          TexturePool.returnTexture(flip);
          TexturePool.returnTexture(flop);
        }
        if (filterData.blendRequired) {
          TexturePool.returnTexture(backTexture);
        }
      }
      getBackTexture(lastRenderSurface, bounds, previousBounds) {
        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;
        const backTexture = TexturePool.getOptimalTexture(
          bounds.width,
          bounds.height,
          backgroundResolution,
          false
        );
        let x3 = bounds.minX;
        let y2 = bounds.minY;
        if (previousBounds) {
          x3 -= previousBounds.minX;
          y2 -= previousBounds.minY;
        }
        x3 = Math.floor(x3 * backgroundResolution);
        y2 = Math.floor(y2 * backgroundResolution);
        const width = Math.ceil(bounds.width * backgroundResolution);
        const height = Math.ceil(bounds.height * backgroundResolution);
        this.renderer.renderTarget.copyToTexture(
          lastRenderSurface,
          backTexture,
          { x: x3, y: y2 },
          { width, height }
        );
        return backTexture;
      }
      applyFilter(filter, input, output, clear) {
        const renderer = this.renderer;
        const filterData = this._filterStack[this._filterStackIndex];
        const bounds = filterData.bounds;
        const offset = Point.shared;
        const previousRenderSurface = filterData.previousRenderSurface;
        const isFinalTarget = previousRenderSurface === this.renderer.renderTarget.getRenderTarget(output);
        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;
        if (this._filterStackIndex > 0) {
          resolution = this._filterStack[this._filterStackIndex - 1].inputTexture.source._resolution;
        }
        const filterUniforms = this._filterGlobalUniforms;
        const uniforms = filterUniforms.uniforms;
        const outputFrame = uniforms.outputFrame;
        const inputSize = uniforms.inputSize;
        const inputPixel = uniforms.inputPixel;
        const inputClamp = uniforms.inputClamp;
        const globalFrame = uniforms.globalFrame;
        const outputTexture = uniforms.outputTexture;
        if (isFinalTarget) {
          if (this._filterStackIndex > 0) {
            offset.x = this._filterStack[this._filterStackIndex - 1].bounds.minX;
            offset.y = this._filterStack[this._filterStackIndex - 1].bounds.minY;
          }
          outputFrame[0] = bounds.minX - offset.x;
          outputFrame[1] = bounds.minY - offset.y;
        } else {
          outputFrame[0] = 0;
          outputFrame[1] = 0;
        }
        outputFrame[2] = input.frameWidth;
        outputFrame[3] = input.frameHeight;
        inputSize[0] = input.source.width;
        inputSize[1] = input.source.height;
        inputSize[2] = 1 / inputSize[0];
        inputSize[3] = 1 / inputSize[1];
        inputPixel[0] = input.source.pixelWidth;
        inputPixel[1] = input.source.pixelHeight;
        inputPixel[2] = 1 / inputPixel[0];
        inputPixel[3] = 1 / inputPixel[1];
        inputClamp[0] = 0.5 * inputPixel[2];
        inputClamp[1] = 0.5 * inputPixel[3];
        inputClamp[2] = input.frameWidth * inputSize[2] - 0.5 * inputPixel[2];
        inputClamp[3] = input.frameHeight * inputSize[3] - 0.5 * inputPixel[3];
        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;
        globalFrame[0] = offset.x * resolution;
        globalFrame[1] = offset.y * resolution;
        globalFrame[2] = rootTexture.source.width * resolution;
        globalFrame[3] = rootTexture.source.height * resolution;
        const renderSurface = this.renderer.renderTarget.getRenderTarget(output);
        outputTexture[0] = renderSurface.colorTexture.frameWidth;
        outputTexture[1] = renderSurface.colorTexture.frameHeight;
        outputTexture[2] = renderSurface.isRoot ? -1 : 1;
        filterUniforms.update();
        if (renderer.renderPipes.uniformBatch) {
          const batchUniforms = renderer.renderPipes.uniformBatch.getUniformBufferResource(this._filterGlobalUniforms);
          this._globalFilterBindGroup.setResource(batchUniforms, 0);
        } else {
          this._globalFilterBindGroup.setResource(filterUniforms, 0);
        }
        this._globalFilterBindGroup.setResource(input.source, 1);
        this._globalFilterBindGroup.setResource(input.source.style, 2);
        renderer.renderTarget.bind(output, !!clear);
        filter.groups[0] = this._globalFilterBindGroup;
        renderer.encoder.draw({
          geometry: quadGeometry,
          shader: filter,
          state: filter._state,
          topology: "triangle-list"
        });
      }
      _getFilterData() {
        return {
          skip: false,
          inputTexture: null,
          bounds: new Bounds(),
          container: null,
          filterEffect: null,
          blendRequired: false,
          previousRenderSurface: null
        };
      }
      /**
       * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.
       *
       * Use `outputMatrix * vTextureCoord` in the shader.
       * @param outputMatrix - The matrix to output to.
       * @param {Sprite} sprite - The sprite to map to.
       * @returns The mapped matrix.
       */
      calculateSpriteMatrix(outputMatrix, sprite) {
        const data = this._activeFilterData;
        const mappedMatrix = outputMatrix.set(
          data.inputTexture._source.width,
          0,
          0,
          data.inputTexture._source.height,
          data.bounds.minX,
          data.bounds.minY
        );
        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);
        worldTransform.invert();
        mappedMatrix.prepend(worldTransform);
        mappedMatrix.scale(1 / sprite.texture.frameWidth, 1 / sprite.texture.frameHeight);
        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
        return mappedMatrix;
      }
    };
    FilterSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "filter"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs
function executeInstructions(layerGroup, renderer) {
  const instructionSet = layerGroup.instructionSet;
  const instructions = instructionSet.instructions;
  for (let i2 = 0; i2 < instructionSet.instructionSize; i2++) {
    const instruction = instructions[i2];
    renderer[instruction.type].execute(instruction);
  }
}
var init_executeInstructions = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/LayerPipe.mjs
var LayerPipe;
var init_LayerPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/LayerPipe.mjs"() {
    init_Extensions();
    init_executeInstructions();
    LayerPipe = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      addLayerGroup(layerGroup, instructionSet) {
        this._renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add(layerGroup);
      }
      execute(layerGroup) {
        if (!layerGroup.isRenderable)
          return;
        this._renderer.globalUniforms.push({
          projectionData: this._renderer.renderTarget.renderTarget,
          worldTransformMatrix: layerGroup.worldTransform,
          worldColor: layerGroup.worldColor
        });
        executeInstructions(layerGroup, this._renderer.renderPipes);
        this._renderer.globalUniforms.pop();
      }
      destroy() {
        this._renderer = null;
      }
    };
    LayerPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "layer"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/LayerRenderable.mjs
var LayerRenderable;
var init_LayerRenderable = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/LayerRenderable.mjs"() {
    init_eventemitter3();
    init_Matrix();
    init_uid();
    LayerRenderable = class extends eventemitter3_default {
      constructor({ original, view }) {
        super();
        this.uid = uid("renderable");
        this.view = view;
        this._original = original;
        this.layerTransform = new Matrix();
        this.layerColor = 4294967295;
        this.layerVisibleRenderable = 3;
        this.view.owner = this;
      }
      get layerBlendMode() {
        return this._original.layerBlendMode;
      }
      onViewUpdate() {
        this.didViewUpdate = true;
        this._original.layerGroup.onChildViewUpdate(this);
      }
      get isRenderable() {
        return this._original.isRenderable;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/utils/buildInstructions.mjs
function buildInstructions(layerGroup, renderPipes3) {
  const root = layerGroup.root;
  const instructionSet = layerGroup.instructionSet;
  instructionSet.reset();
  renderPipes3.batch.buildStart(instructionSet);
  renderPipes3.blendMode.buildStart();
  renderPipes3.colorMask.buildStart();
  if (root.sortableChildren) {
    root.sortChildren();
  }
  collectAllRenderablesAdvanced(root, instructionSet, renderPipes3, true);
  renderPipes3.batch.buildEnd(instructionSet);
  renderPipes3.blendMode.buildEnd(instructionSet);
}
function collectAllRenderables(container, instructionSet, rendererPipes) {
  if (container.layerVisibleRenderable < 3 || !container.includeInBuild)
    return;
  if (container.sortableChildren) {
    container.sortChildren();
  }
  if (container.isSimple) {
    collectAllRenderablesSimple(container, instructionSet, rendererPipes);
  } else {
    collectAllRenderablesAdvanced(container, instructionSet, rendererPipes, false);
  }
}
function collectAllRenderablesSimple(container, instructionSet, renderPipes3) {
  const view = container.view;
  if (view) {
    renderPipes3.blendMode.setBlendMode(container, container.layerBlendMode, instructionSet);
    container.didViewUpdate = false;
    const rp = renderPipes3;
    rp[view.renderPipeId].addRenderable(container, instructionSet);
  }
  if (!container.isLayerRoot) {
    const children = container.children;
    const length = children.length;
    for (let i2 = 0; i2 < length; i2++) {
      collectAllRenderables(children[i2], instructionSet, renderPipes3);
    }
  }
}
function collectAllRenderablesAdvanced(container, instructionSet, renderPipes3, isRoot) {
  if (isRoot) {
    const layerGroup = container.layerGroup;
    if (layerGroup.root.view) {
      const proxyRenderable = layerGroup.proxyRenderable ?? initProxyRenderable(layerGroup);
      if (proxyRenderable) {
        renderPipes3.blendMode.setBlendMode(proxyRenderable, proxyRenderable.layerBlendMode, instructionSet);
        renderPipes3[proxyRenderable.view.renderPipeId].addRenderable(proxyRenderable, instructionSet);
      }
    }
  } else {
    for (let i2 = 0; i2 < container.effects.length; i2++) {
      const effect = container.effects[i2];
      const pipe = renderPipes3[effect.pipe];
      pipe.push(effect, container, instructionSet);
    }
  }
  if (!isRoot && container.isLayerRoot) {
    renderPipes3.layer.addLayerGroup(container.layerGroup, instructionSet);
  } else {
    const view = container.view;
    if (view) {
      renderPipes3.blendMode.setBlendMode(container, container.layerBlendMode, instructionSet);
      container.didViewUpdate = false;
      const pipe = renderPipes3[view.renderPipeId];
      pipe.addRenderable(container, instructionSet);
    }
    const children = container.children;
    if (children.length) {
      for (let i2 = 0; i2 < children.length; i2++) {
        collectAllRenderables(children[i2], instructionSet, renderPipes3);
      }
    }
  }
  if (!isRoot) {
    for (let i2 = container.effects.length - 1; i2 >= 0; i2--) {
      const effect = container.effects[i2];
      const pipe = renderPipes3[effect.pipe];
      pipe.pop(effect, container, instructionSet);
    }
  }
}
function initProxyRenderable(layerGroup) {
  const root = layerGroup.root;
  layerGroup.proxyRenderable = new LayerRenderable({
    original: root,
    view: root.view
  });
}
var init_buildInstructions = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/utils/buildInstructions.mjs"() {
    init_LayerRenderable();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/utils/collectLayerGroups.mjs
function collectLayerGroups(renderGroup, out2 = []) {
  out2.push(renderGroup);
  for (let i2 = 0; i2 < renderGroup.layerGroupChildren.length; i2++) {
    collectLayerGroups(renderGroup.layerGroupChildren[i2], out2);
  }
  return out2;
}
var init_collectLayerGroups = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/utils/collectLayerGroups.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs
function mixHexColors(color1, color2, ratio) {
  const r1 = color1 >> 16 & 255;
  const g1 = color1 >> 8 & 255;
  const b1 = color1 & 255;
  const r2 = color2 >> 16 & 255;
  const g2 = color2 >> 8 & 255;
  const b2 = color2 & 255;
  const r3 = r1 + (r2 - r1) * ratio;
  const g3 = g1 + (g2 - g1) * ratio;
  const b3 = b1 + (b2 - b1) * ratio;
  return (r3 << 16) + (g3 << 8) + b3;
}
var init_mixHexColors = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/utils/mixColors.mjs
function mixColors(localColor, parentColor) {
  const localAlpha = (localColor >> 24 & 255) / 255;
  const parentAlpha = (parentColor >> 24 & 255) / 255;
  const globalAlpha = localAlpha * parentAlpha * 255;
  const localBGRColor = localColor & 16777215;
  const parentBGRColor = parentColor & 16777215;
  let sharedBGRColor = 16777215;
  if (localBGRColor + (parentBGRColor << 32) !== WHITE_WHITE) {
    if (localBGRColor === 16777215) {
      sharedBGRColor = parentBGRColor;
    } else if (parentBGRColor === 16777215) {
      sharedBGRColor = localBGRColor;
    } else {
      sharedBGRColor = mixHexColors(localBGRColor, parentBGRColor, 0.5);
    }
  }
  return sharedBGRColor + (globalAlpha << 24);
}
var WHITE_WHITE;
var init_mixColors = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/utils/mixColors.mjs"() {
    init_mixHexColors();
    WHITE_WHITE = 16777215 + (16777215 << 32);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/utils/updateLayerGroupTransforms.mjs
function updateLayerGroupTransforms(layerGroup, updateChildRenderGroups = false) {
  updateLayerTransform(layerGroup);
  const childrenToUpdate = layerGroup.childrenToUpdate;
  const updateTick = layerGroup.updateTick;
  layerGroup.updateTick++;
  for (const j3 in childrenToUpdate) {
    const childrenAtDepth = childrenToUpdate[j3];
    const list = childrenAtDepth.list;
    const index = childrenAtDepth.index;
    for (let i2 = 0; i2 < index; i2++) {
      updateTransformAndChildren(list[i2], updateTick, 0);
    }
    childrenAtDepth.index = 0;
  }
  if (updateChildRenderGroups) {
    for (let i2 = 0; i2 < layerGroup.layerGroupChildren.length; i2++) {
      updateLayerGroupTransforms(layerGroup.layerGroupChildren[i2], updateChildRenderGroups);
    }
  }
}
function updateLayerTransform(layerGroup) {
  if (layerGroup.layerGroupParent) {
    layerGroup.worldTransform.appendFrom(
      layerGroup.root.layerTransform,
      layerGroup.layerGroupParent.worldTransform
    );
    layerGroup.worldColor = mixColors(
      layerGroup.root.layerColor,
      layerGroup.layerGroupParent.worldColor
    );
  } else {
    layerGroup.worldTransform.copyFrom(layerGroup.root.layerTransform);
    layerGroup.worldColor = layerGroup.root.localColor;
  }
}
function updateTransformAndChildren(container, updateTick, updateFlags) {
  if (updateTick === container.updateTick)
    return;
  container.updateTick = updateTick;
  container.didChange = false;
  const localTransform = container.localTransform;
  updateLocalTransform(localTransform, container);
  const parent = container.parent;
  if (parent && !parent.isLayerRoot) {
    updateFlags = updateFlags | container._updateFlags;
    container.layerTransform.appendFrom(
      localTransform,
      parent.layerTransform
    );
    if (updateFlags) {
      updateColorBlendVisibility(container, parent, updateFlags);
    }
  } else {
    updateFlags = container._updateFlags;
    container.layerTransform.copyFrom(localTransform);
    if (updateFlags) {
      updateColorBlendVisibility(container, tempContainer, updateFlags);
    }
  }
  if (!container.isLayerRoot) {
    const children = container.children;
    const length = children.length;
    for (let i2 = 0; i2 < length; i2++) {
      updateTransformAndChildren(children[i2], updateTick, updateFlags);
    }
    const layerGroup = container.layerGroup;
    if (container.view && !layerGroup.structureDidChange) {
      layerGroup.updateRenderable(container);
    }
  }
}
function updateColorBlendVisibility(container, parent, updateFlags) {
  if (updateFlags & UPDATE_COLOR) {
    container.layerColor = mixColors(container.localColor, parent.layerColor);
  }
  if (updateFlags & UPDATE_BLEND) {
    container.layerBlendMode = container.localBlendMode === "inherit" ? parent.layerBlendMode : container.localBlendMode;
  }
  if (updateFlags & UPDATE_VISIBLE) {
    container.layerVisibleRenderable = container.localVisibleRenderable & parent.layerVisibleRenderable;
  }
  container._updateFlags = 0;
}
var tempContainer;
var init_updateLayerGroupTransforms = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/utils/updateLayerGroupTransforms.mjs"() {
    init_Container();
    init_mixColors();
    init_updateLocalTransform();
    tempContainer = new Container();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs
function validateRenderables(layerGroup, renderPipes3) {
  const { list, index } = layerGroup.childrenRenderablesToUpdate;
  let rebuildRequired = false;
  for (let i2 = 0; i2 < index; i2++) {
    const container = list[i2];
    const renderable = container.view;
    const pipe = renderPipes3[renderable.renderPipeId];
    rebuildRequired = pipe.validateRenderable(container);
    if (rebuildRequired) {
      break;
    }
  }
  layerGroup.structureDidChange = rebuildRequired;
  if (rebuildRequired) {
    layerGroup.childrenRenderablesToUpdate.index = 0;
  }
  return rebuildRequired;
}
var init_validateRenderables = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/LayerSystem.mjs
function updateRenderables(layerGroup) {
  const { list, index } = layerGroup.childrenRenderablesToUpdate;
  for (let i2 = 0; i2 < index; i2++) {
    const container = list[i2];
    if (container.didViewUpdate) {
      layerGroup.updateRenderable(container);
    }
  }
  layerGroup.childrenRenderablesToUpdate.index = 0;
}
var LayerSystem;
var init_LayerSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/container/LayerSystem.mjs"() {
    init_Extensions();
    init_buildInstructions();
    init_collectLayerGroups();
    init_executeInstructions();
    init_updateLayerGroupTransforms();
    init_validateRenderables();
    LayerSystem = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      render({ container, transform: transform2 }) {
        container.layer = true;
        const renderer = this._renderer;
        const layerGroups = collectLayerGroups(container.layerGroup, []);
        const renderPipes3 = renderer.renderPipes;
        for (let i2 = 0; i2 < layerGroups.length; i2++) {
          const layerGroup = layerGroups[i2];
          layerGroup.runOnRender();
          layerGroup.instructionSet.renderPipes = renderPipes3;
          if (!layerGroup.structureDidChange) {
            validateRenderables(layerGroup, renderPipes3);
          }
          updateLayerGroupTransforms(layerGroup);
          if (layerGroup.structureDidChange) {
            layerGroup.structureDidChange = false;
            buildInstructions(layerGroup, renderPipes3);
          } else {
            updateRenderables(layerGroup);
          }
          renderer.renderPipes.batch.upload(layerGroup.instructionSet);
        }
        if (transform2) {
          container.layerGroup.worldTransform.copyFrom(transform2);
        }
        renderer.globalUniforms.start(
          {
            projectionData: renderer.renderTarget.rootRenderTarget,
            worldTransformMatrix: container.layerGroup.worldTransform
          }
        );
        executeInstructions(container.layerGroup, renderPipes3);
        if (renderPipes3.uniformBatch) {
          renderPipes3.uniformBatch.renderEnd();
          renderPipes3.uniformBuffer.renderEnd();
        }
      }
      destroy() {
        const writeable = this;
        writeable._renderer = null;
      }
    };
    LayerSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "layer"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/batcher/gpu/BatchGeometry.mjs
var placeHolderBufferData, placeHolderIndexData, BatchGeometry;
var init_BatchGeometry = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/batcher/gpu/BatchGeometry.mjs"() {
    init_Buffer();
    init_const5();
    init_Geometry();
    placeHolderBufferData = new Float32Array(1);
    placeHolderIndexData = new Uint32Array(1);
    BatchGeometry = class extends Geometry {
      constructor() {
        const vertexSize = 6;
        const attributeBuffer = new Buffer2({
          data: placeHolderBufferData,
          label: "attribute-batch-buffer",
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
        });
        const indexBuffer = new Buffer2({
          data: placeHolderIndexData,
          label: "index-batch-buffer",
          usage: BufferUsage.INDEX | BufferUsage.COPY_DST
          // | BufferUsage.STATIC,
        });
        const stride = vertexSize * 4;
        super({
          attributes: {
            aPosition: {
              buffer: attributeBuffer,
              shaderLocation: 0,
              format: "float32x2",
              stride,
              offset: 0
            },
            aUV: {
              buffer: attributeBuffer,
              shaderLocation: 1,
              format: "float32x2",
              stride,
              offset: 2 * 4
            },
            aColor: {
              buffer: attributeBuffer,
              shaderLocation: 2,
              format: "unorm8x4",
              stride,
              offset: 4 * 4
            },
            aTextureIdAndRound: {
              buffer: attributeBuffer,
              shaderLocation: 3,
              format: "uint16x2",
              stride,
              offset: 5 * 4
            }
          },
          indexBuffer
        });
      }
      reset() {
        this.indexBuffer.data = placeHolderIndexData;
        this.buffers[0].data = placeHolderBufferData;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/ViewableBuffer.mjs
var ViewableBuffer;
var init_ViewableBuffer = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/ViewableBuffer.mjs"() {
    ViewableBuffer = class {
      constructor(sizeOrBuffer) {
        if (typeof sizeOrBuffer === "number") {
          this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
        } else if (sizeOrBuffer instanceof Uint8Array) {
          this.rawBinaryData = sizeOrBuffer.buffer;
        } else {
          this.rawBinaryData = sizeOrBuffer;
        }
        this.uint32View = new Uint32Array(this.rawBinaryData);
        this.float32View = new Float32Array(this.rawBinaryData);
        this.size = this.rawBinaryData.byteLength;
      }
      /** View on the raw binary data as a `Int8Array`. */
      get int8View() {
        if (!this._int8View) {
          this._int8View = new Int8Array(this.rawBinaryData);
        }
        return this._int8View;
      }
      /** View on the raw binary data as a `Uint8Array`. */
      get uint8View() {
        if (!this._uint8View) {
          this._uint8View = new Uint8Array(this.rawBinaryData);
        }
        return this._uint8View;
      }
      /**  View on the raw binary data as a `Int16Array`. */
      get int16View() {
        if (!this._int16View) {
          this._int16View = new Int16Array(this.rawBinaryData);
        }
        return this._int16View;
      }
      /** View on the raw binary data as a `Int32Array`. */
      get int32View() {
        if (!this._int32View) {
          this._int32View = new Int32Array(this.rawBinaryData);
        }
        return this._int32View;
      }
      get float64View() {
        if (!this._float64Array) {
          this._float64Array = new Float64Array(this.rawBinaryData);
        }
        return this._float64Array;
      }
      get bigUint64View() {
        if (!this._bigUint64Array) {
          this._bigUint64Array = new BigUint64Array(this.rawBinaryData);
        }
        return this._bigUint64Array;
      }
      /**
       * Returns the view of the given type.
       * @param type - One of `int8`, `uint8`, `int16`,
       *    `uint16`, `int32`, `uint32`, and `float32`.
       * @returns - typed array of given type
       */
      view(type) {
        return this[`${type}View`];
      }
      /** Destroys all buffer references. Do not use after calling this. */
      destroy() {
        this.rawBinaryData = null;
        this._int8View = null;
        this._uint8View = null;
        this._int16View = null;
        this.uint16View = null;
        this._int32View = null;
        this.uint32View = null;
        this.float32View = null;
      }
      static sizeOf(type) {
        switch (type) {
          case "int8":
          case "uint8":
            return 1;
          case "int16":
          case "uint16":
            return 2;
          case "int32":
          case "uint32":
          case "float32":
            return 4;
          default:
            throw new Error(`${type} isn't a valid view type`);
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs
function fastCopy(sourceBuffer, destinationBuffer) {
  const lengthDouble = sourceBuffer.byteLength / 8 | 0;
  const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);
  const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);
  for (let i2 = 0; i2 < lengthDouble; i2++) {
    destinationFloat64View[i2] = sourceFloat64View[i2];
  }
  const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8);
  const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8);
  for (let i2 = 0; i2 < sourceUint8View.length; i2++) {
    destinationUint8View[i2] = sourceUint8View[i2];
  }
}
var init_fastCopy = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs
var BatchTextureArray;
var init_BatchTextureArray = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs"() {
    BatchTextureArray = class {
      constructor() {
        this.ids = /* @__PURE__ */ Object.create(null);
        this.textures = [];
        this.count = 0;
      }
      clear() {
        for (let i2 = 0; i2 < this.count; i2++) {
          const t2 = this.textures[i2];
          this.textures[i2] = null;
          this.ids[t2.uid] = null;
        }
        this.count = 0;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs
var Batch, BATCH_TICK, Batcher;
var init_Batcher = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs"() {
    init_uid();
    init_ViewableBuffer();
    init_fastCopy();
    init_BatchTextureArray();
    init_const3();
    Batch = class {
      constructor() {
        this.type = "batch";
        this.action = "startBatch";
        this.start = 0;
        this.size = 0;
        this.blendMode = "normal";
        this.canBundle = true;
      }
      destroy() {
        this.textures = null;
        this.gpuBindGroup = null;
        this.bindGroup = null;
        this.batcher = null;
      }
    };
    BATCH_TICK = 0;
    Batcher = class {
      constructor(vertexSize = 4, indexSize = 6) {
        this.uid = uid("batcher");
        this.dirty = true;
        this.batchIndex = 0;
        this.batches = [];
        this._vertexSize = 6;
        this._elements = [];
        this._batchPool = [];
        this._batchPoolIndex = 0;
        this._textureBatchPool = [];
        this._textureBatchPoolIndex = 0;
        this.attributeBuffer = new ViewableBuffer(vertexSize * this._vertexSize * 4);
        this.indexBuffer = new Uint32Array(indexSize);
      }
      begin() {
        this.batchIndex = 0;
        this.elementSize = 0;
        this.elementStart = 0;
        this.indexSize = 0;
        this.attributeSize = 0;
        this._batchPoolIndex = 0;
        this._textureBatchPoolIndex = 0;
        this._batchIndexStart = 0;
        this._batchIndexSize = 0;
        this.dirty = true;
      }
      add(batchableObject) {
        this._elements[this.elementSize++] = batchableObject;
        batchableObject.indexStart = this.indexSize;
        batchableObject.location = this.attributeSize;
        batchableObject.batcher = this;
        this.indexSize += batchableObject.indexSize;
        this.attributeSize += batchableObject.vertexSize * this._vertexSize;
      }
      checkAndUpdateTexture(batchableObject, texture) {
        const textureId = batchableObject.batch.textures.ids[texture._source.uid];
        if (!textureId && textureId !== 0)
          return false;
        batchableObject.textureId = textureId;
        batchableObject.texture = texture;
        return true;
      }
      updateElement(batchableObject) {
        this.dirty = true;
        batchableObject.packAttributes(
          this.attributeBuffer.float32View,
          this.attributeBuffer.uint32View,
          batchableObject.location,
          batchableObject.textureId
        );
      }
      /**
       * breaks the batcher. This happens when a batch gets too big,
       * or we need to switch to a different type of rendering (a filter for example)
       * @param instructionSet
       */
      break(instructionSet) {
        const elements = this._elements;
        let textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();
        textureBatch.clear();
        if (!elements[this.elementStart])
          return;
        let blendMode = elements[this.elementStart].blendMode;
        if (this.attributeSize * 4 > this.attributeBuffer.size) {
          this._resizeAttributeBuffer(this.attributeSize * 4);
        }
        if (this.indexSize > this.indexBuffer.length) {
          this._resizeIndexBuffer(this.indexSize);
        }
        const f32 = this.attributeBuffer.float32View;
        const u32 = this.attributeBuffer.uint32View;
        const iBuffer = this.indexBuffer;
        let size2 = this._batchIndexSize;
        let start = this._batchIndexStart;
        let action = "startBatch";
        let batch = this._batchPool[this._batchPoolIndex++] || new Batch();
        for (let i2 = this.elementStart; i2 < this.elementSize; ++i2) {
          const element = elements[i2];
          elements[i2] = null;
          const texture = element.texture;
          const source3 = texture._source;
          const blendModeChange = blendMode !== element.blendMode;
          if (source3._batchTick === BATCH_TICK && !blendModeChange) {
            element.textureId = source3._textureBindLocation;
            size2 += element.indexSize;
            element.packAttributes(f32, u32, element.location, element.textureId);
            element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);
            element.batch = batch;
            continue;
          }
          source3._batchTick = BATCH_TICK;
          if (textureBatch.count >= MAX_TEXTURES || blendModeChange) {
            this._finishBatch(
              batch,
              start,
              size2 - start,
              textureBatch,
              blendMode,
              instructionSet,
              action
            );
            action = "renderBatch";
            start = size2;
            blendMode = element.blendMode;
            textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();
            textureBatch.clear();
            batch = this._batchPool[this._batchPoolIndex++] || new Batch();
            ++BATCH_TICK;
          }
          element.textureId = source3._textureBindLocation = textureBatch.count;
          textureBatch.ids[source3.uid] = textureBatch.count;
          textureBatch.textures[textureBatch.count++] = source3;
          element.batch = batch;
          size2 += element.indexSize;
          element.packAttributes(f32, u32, element.location, element.textureId);
          element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);
        }
        if (textureBatch.count > 0) {
          this._finishBatch(
            batch,
            start,
            size2 - start,
            textureBatch,
            blendMode,
            instructionSet,
            action
          );
          start = size2;
          ++BATCH_TICK;
        }
        this.elementStart = this.elementSize;
        this._batchIndexStart = start;
        this._batchIndexSize = size2;
      }
      _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {
        batch.gpuBindGroup = null;
        batch.action = action;
        batch.batcher = this;
        batch.textures = textureBatch;
        batch.blendMode = blendMode;
        batch.start = indexStart;
        batch.size = indexSize;
        ++BATCH_TICK;
        instructionSet.add(batch);
      }
      finish(instructionSet) {
        this.break(instructionSet);
      }
      ensureAttributeBuffer(size2) {
        if (size2 * 4 < this.attributeBuffer.size)
          return;
        this._resizeAttributeBuffer(size2 * 4);
      }
      ensureIndexBuffer(size2) {
        if (size2 < this.indexBuffer.length)
          return;
        this._resizeIndexBuffer(size2);
      }
      _resizeAttributeBuffer(size2) {
        const newSize = Math.max(size2, this.attributeBuffer.size * 2);
        const newArrayBuffer = new ViewableBuffer(newSize);
        fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);
        this.attributeBuffer = newArrayBuffer;
      }
      _resizeIndexBuffer(size2) {
        const indexBuffer = this.indexBuffer;
        const newSize = Math.max(size2, indexBuffer.length * 2);
        const newIndexBuffer = new Uint32Array(newSize);
        fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);
        this.indexBuffer = newIndexBuffer;
      }
      destroy() {
        for (let i2 = 0; i2 < this.batches.length; i2++) {
          this.batches[i2].destroy();
        }
        this.batches = null;
        for (let i2 = 0; i2 < this._elements.length; i2++) {
          this._elements[i2].batch = null;
        }
        this._elements = null;
        this.indexBuffer = null;
        this.attributeBuffer.destroy();
        this.attributeBuffer = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs
function buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size2, matrix = null) {
  let index = 0;
  verticesOffset *= verticesStride;
  uvsOffset *= uvsStride;
  const a2 = matrix.a;
  const b2 = matrix.b;
  const c2 = matrix.c;
  const d3 = matrix.d;
  const tx = matrix.tx;
  const ty = matrix.ty;
  while (index < size2) {
    const x3 = vertices[verticesOffset];
    const y2 = vertices[verticesOffset + 1];
    uvs[uvsOffset] = a2 * x3 + c2 * y2 + tx;
    uvs[uvsOffset + 1] = b2 * x3 + d3 * y2 + ty;
    uvsOffset += uvsStride;
    verticesOffset += verticesStride;
    index++;
  }
}
function buildSimpleUvs(uvs, uvsOffset, uvsStride, size2) {
  let index = 0;
  uvsOffset *= uvsStride;
  while (index < size2) {
    uvs[uvsOffset] = 0;
    uvs[uvsOffset + 1] = 0;
    uvsOffset += uvsStride;
    index++;
  }
}
var init_buildUvs = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs
function transformVertices(vertices, m3, offset, stride, size2) {
  const a2 = m3.a;
  const b2 = m3.b;
  const c2 = m3.c;
  const d3 = m3.d;
  const tx = m3.tx;
  const ty = m3.ty;
  offset = offset || 0;
  stride = stride || 2;
  size2 = size2 || vertices.length / stride - offset;
  let index = offset * stride;
  for (let i2 = 0; i2 < size2; i2++) {
    const x3 = vertices[index];
    const y2 = vertices[index + 1];
    vertices[index] = a2 * x3 + c2 * y2 + tx;
    vertices[index + 1] = b2 * x3 + d3 * y2 + ty;
    index += stride;
  }
}
var init_transformVertices = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs
var BatchableGraphics;
var init_BatchableGraphics = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs"() {
    init_mixColors();
    BatchableGraphics = class {
      constructor() {
        this.batcher = null;
        this.batch = null;
        this.applyTransform = true;
        this.roundPixels = 0;
      }
      get blendMode() {
        if (this.applyTransform) {
          return this.renderable.layerBlendMode;
        }
        return "normal";
      }
      packIndex(indexBuffer, index, indicesOffset) {
        const indices = this.geometryData.indices;
        for (let i2 = 0; i2 < this.indexSize; i2++) {
          indexBuffer[index++] = indices[i2 + this.indexOffset] + indicesOffset - this.vertexOffset;
        }
      }
      packAttributes(float32View, uint32View, index, textureId) {
        const geometry = this.geometryData;
        const graphics = this.renderable;
        const positions = geometry.vertices;
        const uvs = geometry.uvs;
        const offset = this.vertexOffset * 2;
        const vertSize = (this.vertexOffset + this.vertexSize) * 2;
        const rgb = this.color;
        const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;
        if (this.applyTransform) {
          const argb = mixColors(bgr + (this.alpha * 255 << 24), graphics.layerColor);
          const wt = graphics.layerTransform;
          const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;
          const a2 = wt.a;
          const b2 = wt.b;
          const c2 = wt.c;
          const d3 = wt.d;
          const tx = wt.tx;
          const ty = wt.ty;
          for (let i2 = offset; i2 < vertSize; i2 += 2) {
            const x3 = positions[i2];
            const y2 = positions[i2 + 1];
            float32View[index] = a2 * x3 + c2 * y2 + tx;
            float32View[index + 1] = b2 * x3 + d3 * y2 + ty;
            float32View[index + 2] = uvs[i2];
            float32View[index + 3] = uvs[i2 + 1];
            uint32View[index + 4] = argb;
            uint32View[index + 5] = textureIdAndRound;
            index += 6;
          }
        } else {
          const argb = bgr + (this.alpha * 255 << 24);
          for (let i2 = offset; i2 < vertSize; i2 += 2) {
            float32View[index] = positions[i2];
            float32View[index + 1] = positions[i2 + 1];
            float32View[index + 2] = uvs[i2];
            float32View[index + 3] = uvs[i2 + 1];
            uint32View[index + 4] = argb;
            uint32View[index + 5] = textureId;
            index += 6;
          }
        }
      }
      // TODO rename to vertexSize
      get vertSize() {
        return this.vertexSize;
      }
      copyTo(gpuBuffer) {
        gpuBuffer.indexOffset = this.indexOffset;
        gpuBuffer.indexSize = this.indexSize;
        gpuBuffer.vertexOffset = this.vertexOffset;
        gpuBuffer.vertexSize = this.vertexSize;
        gpuBuffer.color = this.color;
        gpuBuffer.alpha = this.alpha;
        gpuBuffer.texture = this.texture;
        gpuBuffer.geometryData = this.geometryData;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs
var buildCircle;
var init_buildCircle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs"() {
    buildCircle = {
      build(shape, points) {
        let x3;
        let y2;
        let dx;
        let dy;
        let rx;
        let ry;
        if (shape.type === "circle") {
          const circle = shape;
          x3 = circle.x;
          y2 = circle.y;
          rx = ry = circle.radius;
          dx = dy = 0;
        } else if (shape.type === "ellipse") {
          const ellipse = shape;
          x3 = ellipse.x;
          y2 = ellipse.y;
          rx = ellipse.halfWidth;
          ry = ellipse.halfHeight;
          dx = dy = 0;
        } else {
          const roundedRect = shape;
          const halfWidth = roundedRect.width / 2;
          const halfHeight = roundedRect.height / 2;
          x3 = roundedRect.x + halfWidth;
          y2 = roundedRect.y + halfHeight;
          rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
          dx = halfWidth - rx;
          dy = halfHeight - ry;
        }
        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
          return points;
        }
        const n2 = Math.ceil(2.3 * Math.sqrt(rx + ry));
        const m3 = n2 * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
        if (m3 === 0) {
          return points;
        }
        if (n2 === 0) {
          points[0] = points[6] = x3 + dx;
          points[1] = points[3] = y2 + dy;
          points[2] = points[4] = x3 - dx;
          points[5] = points[7] = y2 - dy;
          return points;
        }
        let j1 = 0;
        let j22 = n2 * 4 + (dx ? 2 : 0) + 2;
        let j3 = j22;
        let j4 = m3;
        let x0 = dx + rx;
        let y0 = dy;
        let x1 = x3 + x0;
        let x22 = x3 - x0;
        let y1 = y2 + y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j22] = y1;
        points[--j22] = x22;
        if (dy) {
          const y222 = y2 - y0;
          points[j3++] = x22;
          points[j3++] = y222;
          points[--j4] = y222;
          points[--j4] = x1;
        }
        for (let i2 = 1; i2 < n2; i2++) {
          const a2 = Math.PI / 2 * (i2 / n2);
          const x02 = dx + Math.cos(a2) * rx;
          const y02 = dy + Math.sin(a2) * ry;
          const x12 = x3 + x02;
          const x222 = x3 - x02;
          const y12 = y2 + y02;
          const y222 = y2 - y02;
          points[j1++] = x12;
          points[j1++] = y12;
          points[--j22] = y12;
          points[--j22] = x222;
          points[j3++] = x222;
          points[j3++] = y222;
          points[--j4] = y222;
          points[--j4] = x12;
        }
        x0 = dx;
        y0 = dy + ry;
        x1 = x3 + x0;
        x22 = x3 - x0;
        y1 = y2 + y0;
        const y22 = y2 - y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j4] = y22;
        points[--j4] = x1;
        if (dx) {
          points[j1++] = x22;
          points[j1++] = y1;
          points[--j4] = y22;
          points[--j4] = x22;
        }
        return points;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        if (points.length === 0) {
          return;
        }
        let x3 = 0;
        let y2 = 0;
        const div = points.length / 4;
        x3 += points[0];
        y2 += points[1];
        x3 += points[div | 0];
        y2 += points[(div | 0) + 1];
        x3 += points[div * 2 | 0];
        y2 += points[(div * 2 | 0) + 1];
        x3 += points[div * 3 | 0];
        y2 += points[(div * 3 | 0) + 1];
        x3 /= 4;
        y2 /= 4;
        let count2 = verticesOffset;
        vertices[count2 * verticesStride] = x3;
        vertices[count2 * verticesStride + 1] = y2;
        count2++;
        const center = verticesOffset;
        vertices[count2 * verticesStride] = points[0];
        vertices[count2 * verticesStride + 1] = points[1];
        count2++;
        for (let i2 = 2; i2 < points.length; i2 += 2) {
          vertices[count2 * verticesStride] = points[i2];
          vertices[count2 * verticesStride + 1] = points[i2 + 1];
          indices[indicesOffset++] = count2;
          indices[indicesOffset++] = center;
          indices[indicesOffset++] = count2 - 1;
          count2++;
        }
        indices[indicesOffset++] = count2 - 1;
        indices[indicesOffset++] = center;
        indices[indicesOffset++] = center + 1;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/const.mjs
var closePointEps, curveEps;
var init_const6 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/const.mjs"() {
    closePointEps = 1e-4;
    curveEps = 1e-4;
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs
function getOrientationOfPoints(points) {
  const m3 = points.length;
  if (m3 < 6) {
    return 1;
  }
  let area = 0;
  for (let i2 = 0, x1 = points[m3 - 2], y1 = points[m3 - 1]; i2 < m3; i2 += 2) {
    const x22 = points[i2];
    const y2 = points[i2 + 1];
    area += (x22 - x1) * (y2 + y1);
    x1 = x22;
    y1 = y2;
  }
  if (area < 0) {
    return -1;
  }
  return 1;
}
var init_getOrientationOfPoints = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs
function square(x3, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  const ix = x3 - nx * innerWeight;
  const iy = y2 - ny * innerWeight;
  const ox = x3 + nx * outerWeight;
  const oy = y2 + ny * outerWeight;
  let exx;
  let eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  const eix = ix + exx;
  const eiy = iy + eyy;
  const eox = ox + exx;
  const eoy = oy + eyy;
  verts.push(eix, eiy);
  verts.push(eox, eoy);
  return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  const cx2p0x = sx - cx;
  const cy2p0y = sy - cy;
  let angle0 = Math.atan2(cx2p0x, cy2p0y);
  let angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  let startAngle = angle0;
  const angleDiff = angle1 - angle0;
  const absAngleDiff = Math.abs(angleDiff);
  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  const angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy);
    verts.push(sx, sy);
    for (let i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
      verts.push(cx, cy);
      verts.push(
        cx + Math.sin(angle) * radius,
        cy + Math.cos(angle) * radius
      );
    }
    verts.push(cx, cy);
    verts.push(ex, ey);
  } else {
    verts.push(sx, sy);
    verts.push(cx, cy);
    for (let i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
      verts.push(
        cx + Math.sin(angle) * radius,
        cy + Math.cos(angle) * radius
      );
      verts.push(cx, cy);
    }
    verts.push(ex, ey);
    verts.push(cx, cy);
  }
  return segCount * 2;
}
function buildLine(points, lineStyle, flipAlignment, closed, vertices, _verticesStride, _verticesOffset, indices, _indicesOffset) {
  const eps = closePointEps;
  if (points.length === 0) {
    return;
  }
  const style = lineStyle;
  let alignment = style.alignment;
  if (lineStyle.alignment !== 0.5) {
    let orientation = getOrientationOfPoints(points);
    if (flipAlignment)
      orientation *= -1;
    alignment = (alignment - 0.5) * orientation + 0.5;
  }
  const firstPoint = new Point(points[0], points[1]);
  const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
  const closedShape = closed;
  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  const verts = vertices;
  const length = points.length / 2;
  let indexCount = points.length;
  const indexStart = verts.length / 2;
  const width = style.width / 2;
  const widthSquared = width * width;
  const miterLimitSquared = style.miterLimit * style.miterLimit;
  let x0 = points[0];
  let y0 = points[1];
  let x1 = points[2];
  let y1 = points[3];
  let x22 = 0;
  let y2 = 0;
  let perpX = -(y0 - y1);
  let perpY = x0 - x1;
  let perp1x = 0;
  let perp1y = 0;
  let dist = Math.sqrt(perpX * perpX + perpY * perpY);
  perpX /= dist;
  perpY /= dist;
  perpX *= width;
  perpY *= width;
  const ratio = alignment;
  const innerWeight = (1 - ratio) * 2;
  const outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === "round") {
      indexCount += round(
        x0 - perpX * (innerWeight - outerWeight) * 0.5,
        y0 - perpY * (innerWeight - outerWeight) * 0.5,
        x0 - perpX * innerWeight,
        y0 - perpY * innerWeight,
        x0 + perpX * outerWeight,
        y0 + perpY * outerWeight,
        verts,
        true
      ) + 2;
    } else if (style.cap === "square") {
      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(
    x0 - perpX * innerWeight,
    y0 - perpY * innerWeight
  );
  verts.push(
    x0 + perpX * outerWeight,
    y0 + perpY * outerWeight
  );
  for (let i2 = 1; i2 < length - 1; ++i2) {
    x0 = points[(i2 - 1) * 2];
    y0 = points[(i2 - 1) * 2 + 1];
    x1 = points[i2 * 2];
    y1 = points[i2 * 2 + 1];
    x22 = points[(i2 + 1) * 2];
    y2 = points[(i2 + 1) * 2 + 1];
    perpX = -(y0 - y1);
    perpY = x0 - x1;
    dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    perp1x = -(y1 - y2);
    perp1y = x1 - x22;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    const dx0 = x1 - x0;
    const dy0 = y0 - y1;
    const dx1 = x1 - x22;
    const dy1 = y2 - y1;
    const dot = dx0 * dx1 + dy0 * dy1;
    const cross = dy0 * dx1 - dy1 * dx0;
    const clockwise = cross < 0;
    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
      verts.push(
        x1 - perpX * innerWeight,
        y1 - perpY * innerWeight
      );
      verts.push(
        x1 + perpX * outerWeight,
        y1 + perpY * outerWeight
      );
      if (dot >= 0) {
        if (style.join === "round") {
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 4;
        } else {
          indexCount += 2;
        }
        verts.push(
          x1 - perp1x * outerWeight,
          y1 - perp1y * outerWeight
        );
        verts.push(
          x1 + perp1x * innerWeight,
          y1 + perp1y * innerWeight
        );
      }
      continue;
    }
    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);
    const c2 = (-perp1x + x22) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
    const px = (dx0 * c2 - dx1 * c1) / cross;
    const py = (dy1 * c1 - dy0 * c2) / cross;
    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    const imx = x1 + (px - x1) * innerWeight;
    const imy = y1 + (py - y1) * innerWeight;
    const omx = x1 - (px - x1) * outerWeight;
    const omy = y1 - (py - y1) * outerWeight;
    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    const insideWeight = clockwise ? innerWeight : outerWeight;
    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    const insideMiterOk = pDist <= smallerInsideDiagonalSq;
    if (insideMiterOk) {
      if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
          verts.push(omx, omy);
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
        indexCount += 2;
      } else if (style.join === "round") {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
          indexCount += round(
            x1,
            y1,
            x1 + perpX * outerWeight,
            y1 + perpY * outerWeight,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight,
            verts,
            true
          ) + 4;
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
          verts.push(omx, omy);
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 4;
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
      } else {
        verts.push(imx, imy);
        verts.push(omx, omy);
      }
    } else {
      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
      if (style.join === "round") {
        if (clockwise) {
          indexCount += round(
            x1,
            y1,
            x1 + perpX * outerWeight,
            y1 + perpY * outerWeight,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight,
            verts,
            true
          ) + 2;
        } else {
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 2;
        }
      } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {
        if (clockwise) {
          verts.push(omx, omy);
          verts.push(omx, omy);
        } else {
          verts.push(imx, imy);
          verts.push(imx, imy);
        }
        indexCount += 2;
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length - 2) * 2];
  y0 = points[(length - 2) * 2 + 1];
  x1 = points[(length - 1) * 2];
  y1 = points[(length - 1) * 2 + 1];
  perpX = -(y0 - y1);
  perpY = x0 - x1;
  dist = Math.sqrt(perpX * perpX + perpY * perpY);
  perpX /= dist;
  perpY /= dist;
  perpX *= width;
  perpY *= width;
  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
  if (!closedShape) {
    if (style.cap === "round") {
      indexCount += round(
        x1 - perpX * (innerWeight - outerWeight) * 0.5,
        y1 - perpY * (innerWeight - outerWeight) * 0.5,
        x1 - perpX * innerWeight,
        y1 - perpY * innerWeight,
        x1 + perpX * outerWeight,
        y1 + perpY * outerWeight,
        verts,
        false
      ) + 2;
    } else if (style.cap === "square") {
      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);
    }
  }
  const eps2 = curveEps * curveEps;
  for (let i2 = indexStart; i2 < indexCount + indexStart - 2; ++i2) {
    x0 = verts[i2 * 2];
    y0 = verts[i2 * 2 + 1];
    x1 = verts[(i2 + 1) * 2];
    y1 = verts[(i2 + 1) * 2 + 1];
    x22 = verts[(i2 + 2) * 2];
    y2 = verts[(i2 + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x22 * (y0 - y1)) < eps2) {
      continue;
    }
    indices.push(i2, i2 + 1, i2 + 2);
  }
}
var init_buildLine = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs"() {
    init_Point();
    init_const6();
    init_getOrientationOfPoints();
  }
});

// ../../node_modules/.pnpm/earcut@2.2.4/node_modules/earcut/src/earcut.js
var require_earcut = __commonJS({
  "../../node_modules/.pnpm/earcut@2.2.4/node_modules/earcut/src/earcut.js"(exports, module) {
    "use strict";
    module.exports = earcut2;
    module.exports.default = earcut2;
    function earcut2(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev)
        return triangles;
      var minX, minY, maxX, maxY, x3, y2, invSize;
      if (hasHoles)
        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i2 = dim; i2 < outerLen; i2 += dim) {
          x3 = data[i2];
          y2 = data[i2 + 1];
          if (x3 < minX)
            minX = x3;
          if (y2 < minY)
            minY = y2;
          if (x3 > maxX)
            maxX = x3;
          if (y2 > maxY)
            maxY = y2;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
      return triangles;
    }
    function linkedList(data, start, end, dim, clockwise) {
      var i2, last;
      if (clockwise === signedArea(data, start, end, dim) > 0) {
        for (i2 = start; i2 < end; i2 += dim)
          last = insertNode(i2, data[i2], data[i2 + 1], last);
      } else {
        for (i2 = end - dim; i2 >= start; i2 -= dim)
          last = insertNode(i2, data[i2], data[i2 + 1], last);
      }
      if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints(start, end) {
      if (!start)
        return start;
      if (!end)
        end = start;
      var p2 = start, again;
      do {
        again = false;
        if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
          removeNode(p2);
          p2 = end = p2.prev;
          if (p2 === p2.next)
            break;
          again = true;
        } else {
          p2 = p2.next;
        }
      } while (again || p2 !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear)
        return;
      if (!pass && invSize)
        indexCurve(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev.i / dim | 0);
          triangles.push(ear.i / dim | 0);
          triangles.push(next.i / dim | 0);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      var a2 = ear.prev, b2 = ear, c2 = ear.next;
      if (area(a2, b2, c2) >= 0)
        return false;
      var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var p2 = c2.next;
      while (p2 !== a2) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
          return false;
        p2 = p2.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      var a2 = ear.prev, b2 = ear, c2 = ear.next;
      if (area(a2, b2, c2) >= 0)
        return false;
      var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
      var p2 = ear.prevZ, n2 = ear.nextZ;
      while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
          return false;
        p2 = p2.prevZ;
        if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
          return false;
        n2 = n2.nextZ;
      }
      while (p2 && p2.z >= minZ) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
          return false;
        p2 = p2.prevZ;
      }
      while (n2 && n2.z <= maxZ) {
        if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
          return false;
        n2 = n2.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      var p2 = start;
      do {
        var a2 = p2.prev, b2 = p2.next.next;
        if (!equals(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
          triangles.push(a2.i / dim | 0);
          triangles.push(p2.i / dim | 0);
          triangles.push(b2.i / dim | 0);
          removeNode(p2);
          removeNode(p2.next);
          p2 = start = b2;
        }
        p2 = p2.next;
      } while (p2 !== start);
      return filterPoints(p2);
    }
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
      var a2 = start;
      do {
        var b2 = a2.next.next;
        while (b2 !== a2.prev) {
          if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
            var c2 = splitPolygon(a2, b2);
            a2 = filterPoints(a2, a2.next);
            c2 = filterPoints(c2, c2.next);
            earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
            earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
            return;
          }
          b2 = b2.next;
        }
        a2 = a2.next;
      } while (a2 !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [], i2, len, start, end, list;
      for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
        start = holeIndices[i2] * dim;
        end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next)
          list.steiner = true;
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i2 = 0; i2 < queue.length; i2++) {
        outerNode = eliminateHole(queue[i2], outerNode);
      }
      return outerNode;
    }
    function compareX(a2, b2) {
      return a2.x - b2.x;
    }
    function eliminateHole(hole, outerNode) {
      var bridge = findHoleBridge(hole, outerNode);
      if (!bridge) {
        return outerNode;
      }
      var bridgeReverse = splitPolygon(bridge, hole);
      filterPoints(bridgeReverse, bridgeReverse.next);
      return filterPoints(bridge, bridge.next);
    }
    function findHoleBridge(hole, outerNode) {
      var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m3;
      do {
        if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
          var x3 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
          if (x3 <= hx && x3 > qx) {
            qx = x3;
            m3 = p2.x < p2.next.x ? p2 : p2.next;
            if (x3 === hx)
              return m3;
          }
        }
        p2 = p2.next;
      } while (p2 !== outerNode);
      if (!m3)
        return null;
      var stop = m3, mx = m3.x, my = m3.y, tanMin = Infinity, tan;
      p2 = m3;
      do {
        if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
          tan = Math.abs(hy - p2.y) / (hx - p2.x);
          if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m3.x || p2.x === m3.x && sectorContainsSector(m3, p2)))) {
            m3 = p2;
            tanMin = tan;
          }
        }
        p2 = p2.next;
      } while (p2 !== stop);
      return m3;
    }
    function sectorContainsSector(m3, p2) {
      return area(m3.prev, m3, p2.prev) < 0 && area(p2.next, m3, m3.next) < 0;
    }
    function indexCurve(start, minX, minY, invSize) {
      var p2 = start;
      do {
        if (p2.z === 0)
          p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
        p2.prevZ = p2.prev;
        p2.nextZ = p2.next;
        p2 = p2.next;
      } while (p2 !== start);
      p2.prevZ.nextZ = null;
      p2.prevZ = null;
      sortLinked(p2);
    }
    function sortLinked(list) {
      var i2, p2, q2, e2, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p2 = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p2) {
          numMerges++;
          q2 = p2;
          pSize = 0;
          for (i2 = 0; i2 < inSize; i2++) {
            pSize++;
            q2 = q2.nextZ;
            if (!q2)
              break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q2) {
            if (pSize !== 0 && (qSize === 0 || !q2 || p2.z <= q2.z)) {
              e2 = p2;
              p2 = p2.nextZ;
              pSize--;
            } else {
              e2 = q2;
              q2 = q2.nextZ;
              qSize--;
            }
            if (tail)
              tail.nextZ = e2;
            else
              list = e2;
            e2.prevZ = tail;
            tail = e2;
          }
          p2 = q2;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x3, y2, minX, minY, invSize) {
      x3 = (x3 - minX) * invSize | 0;
      y2 = (y2 - minY) * invSize | 0;
      x3 = (x3 | x3 << 8) & 16711935;
      x3 = (x3 | x3 << 4) & 252645135;
      x3 = (x3 | x3 << 2) & 858993459;
      x3 = (x3 | x3 << 1) & 1431655765;
      y2 = (y2 | y2 << 8) & 16711935;
      y2 = (y2 | y2 << 4) & 252645135;
      y2 = (y2 | y2 << 2) & 858993459;
      y2 = (y2 | y2 << 1) & 1431655765;
      return x3 | y2 << 1;
    }
    function getLeftmost(start) {
      var p2 = start, leftmost = start;
      do {
        if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
          leftmost = p2;
        p2 = p2.next;
      } while (p2 !== start);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }
    function isValidDiagonal(a2, b2) {
      return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && // dones't intersect other edges
      (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && // locally visible
      (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || // does not create opposite-facing sectors
      equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
    }
    function area(p2, q2, r2) {
      return (q2.y - p2.y) * (r2.x - q2.x) - (q2.x - p2.x) * (r2.y - q2.y);
    }
    function equals(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      var o1 = sign(area(p1, q1, p2));
      var o2 = sign(area(p1, q1, q2));
      var o3 = sign(area(p2, q2, p1));
      var o4 = sign(area(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4)
        return true;
      if (o1 === 0 && onSegment(p1, p2, q1))
        return true;
      if (o2 === 0 && onSegment(p1, q2, q1))
        return true;
      if (o3 === 0 && onSegment(p2, p1, q2))
        return true;
      if (o4 === 0 && onSegment(p2, q1, q2))
        return true;
      return false;
    }
    function onSegment(p2, q2, r2) {
      return q2.x <= Math.max(p2.x, r2.x) && q2.x >= Math.min(p2.x, r2.x) && q2.y <= Math.max(p2.y, r2.y) && q2.y >= Math.min(p2.y, r2.y);
    }
    function sign(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon(a2, b2) {
      var p2 = a2;
      do {
        if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2))
          return true;
        p2 = p2.next;
      } while (p2 !== a2);
      return false;
    }
    function locallyInside(a2, b2) {
      return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
    }
    function middleInside(a2, b2) {
      var p2 = a2, inside = false, px = (a2.x + b2.x) / 2, py = (a2.y + b2.y) / 2;
      do {
        if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
          inside = !inside;
        p2 = p2.next;
      } while (p2 !== a2);
      return inside;
    }
    function splitPolygon(a2, b2) {
      var a22 = new Node(a2.i, a2.x, a2.y), b22 = new Node(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
      a2.next = b2;
      b2.prev = a2;
      a22.next = an;
      an.prev = a22;
      b22.next = a22;
      a22.prev = b22;
      bp.next = b22;
      b22.prev = bp;
      return b22;
    }
    function insertNode(i2, x3, y2, last) {
      var p2 = new Node(i2, x3, y2);
      if (!last) {
        p2.prev = p2;
        p2.next = p2;
      } else {
        p2.next = last.next;
        p2.prev = last;
        last.next.prev = p2;
        last.next = p2;
      }
      return p2;
    }
    function removeNode(p2) {
      p2.next.prev = p2.prev;
      p2.prev.next = p2.next;
      if (p2.prevZ)
        p2.prevZ.nextZ = p2.nextZ;
      if (p2.nextZ)
        p2.nextZ.prevZ = p2.prevZ;
    }
    function Node(i2, x3, y2) {
      this.i = i2;
      this.x = x3;
      this.y = y2;
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut2.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) {
        for (var i2 = 0, len = holeIndices.length; i2 < len; i2++) {
          var start = holeIndices[i2] * dim;
          var end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
          polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
      }
      var trianglesArea = 0;
      for (i2 = 0; i2 < triangles.length; i2 += 3) {
        var a2 = triangles[i2] * dim;
        var b2 = triangles[i2 + 1] * dim;
        var c2 = triangles[i2 + 2] * dim;
        trianglesArea += Math.abs(
          (data[a2] - data[c2]) * (data[b2 + 1] - data[a2 + 1]) - (data[a2] - data[b2]) * (data[c2 + 1] - data[a2 + 1])
        );
      }
      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data, start, end, dim) {
      var sum = 0;
      for (var i2 = start, j3 = end - dim; i2 < end; i2 += dim) {
        sum += (data[j3] - data[i2]) * (data[i2 + 1] + data[j3 + 1]);
        j3 = i2;
      }
      return sum;
    }
    earcut2.flatten = function(data) {
      var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i2 = 0; i2 < data.length; i2++) {
        for (var j3 = 0; j3 < data[i2].length; j3++) {
          for (var d3 = 0; d3 < dim; d3++)
            result.vertices.push(data[i2][j3][d3]);
        }
        if (i2 > 0) {
          holeIndex += data[i2 - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs
function triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
  const triangles = (0, import_earcut.default)(points, holes, 2);
  if (!triangles) {
    return;
  }
  for (let i2 = 0; i2 < triangles.length; i2 += 3) {
    indices[indicesOffset++] = triangles[i2] + verticesOffset;
    indices[indicesOffset++] = triangles[i2 + 1] + verticesOffset;
    indices[indicesOffset++] = triangles[i2 + 2] + verticesOffset;
  }
  let index = verticesOffset * verticesStride;
  for (let i2 = 0; i2 < points.length; i2 += 2) {
    vertices[index] = points[i2];
    vertices[index + 1] = points[i2 + 1];
    index += verticesStride;
  }
}
var import_earcut;
var init_triangulateWithHoles = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs"() {
    import_earcut = __toESM(require_earcut(), 1);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs
var emptyArray, buildPolygon;
var init_buildPolygon = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs"() {
    init_triangulateWithHoles();
    emptyArray = [];
    buildPolygon = {
      build(shape, points) {
        for (let i2 = 0; i2 < shape.points.length; i2++) {
          points[i2] = shape.points[i2];
        }
        return points;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs
var buildRectangle;
var init_buildRectangle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs"() {
    buildRectangle = {
      build(shape, points) {
        const rectData = shape;
        const x3 = rectData.x;
        const y2 = rectData.y;
        const width = rectData.width;
        const height = rectData.height;
        if (!(width >= 0 && height >= 0)) {
          return points;
        }
        points[0] = x3;
        points[1] = y2;
        points[2] = x3 + width;
        points[3] = y2;
        points[4] = x3 + width;
        points[5] = y2 + height;
        points[6] = x3;
        points[7] = y2 + height;
        return points;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        let count2 = 0;
        verticesOffset *= verticesStride;
        vertices[verticesOffset + count2] = points[0];
        vertices[verticesOffset + count2 + 1] = points[1];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[2];
        vertices[verticesOffset + count2 + 1] = points[3];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[6];
        vertices[verticesOffset + count2 + 1] = points[7];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[4];
        vertices[verticesOffset + count2 + 1] = points[5];
        count2 += verticesStride;
        const verticesIndex = verticesOffset / verticesStride;
        indices[indicesOffset++] = verticesIndex;
        indices[indicesOffset++] = verticesIndex + 1;
        indices[indicesOffset++] = verticesIndex + 2;
        indices[indicesOffset++] = verticesIndex + 1;
        indices[indicesOffset++] = verticesIndex + 3;
        indices[indicesOffset++] = verticesIndex + 2;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs
var buildTriangle;
var init_buildTriangle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs"() {
    buildTriangle = {
      build(shape, points) {
        points[0] = shape.x;
        points[1] = shape.y;
        points[2] = shape.x2;
        points[3] = shape.y2;
        points[4] = shape.x3;
        points[5] = shape.y3;
        return points;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        let count2 = 0;
        verticesOffset *= verticesStride;
        vertices[verticesOffset + count2] = points[0];
        vertices[verticesOffset + count2 + 1] = points[1];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[2];
        vertices[verticesOffset + count2 + 1] = points[3];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[4];
        vertices[verticesOffset + count2 + 1] = points[5];
        const verticesIndex = verticesOffset / verticesStride;
        indices[indicesOffset++] = verticesIndex;
        indices[indicesOffset++] = verticesIndex + 1;
        indices[indicesOffset++] = verticesIndex + 2;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs
function buildContextBatches(context2) {
  const vertices = [];
  const uvs = [];
  const indices = [];
  const geometryData = {
    vertices,
    uvs,
    indices
  };
  const batches = [];
  for (let i2 = 0; i2 < context2.instructions.length; i2++) {
    const instruction = context2.instructions[i2];
    if (instruction.action === "texture") {
      addTextureToGeometryData(instruction.data, batches, geometryData);
    } else if (instruction.action === "fill" || instruction.action === "stroke") {
      const isStroke = instruction.action === "stroke";
      const shapePath = instruction.data.path.shapePath;
      const style = instruction.data.style;
      const hole = instruction.data.hole;
      if (isStroke && hole) {
        addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);
      }
      addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);
    }
  }
  return batches;
}
function addTextureToGeometryData(data, batches, geometryData) {
  const { vertices, uvs, indices } = geometryData;
  const indexOffset = indices.length;
  const vertOffset = vertices.length / 2;
  const points = [];
  const build = buildMap.rectangle;
  const rect = tempRect;
  const texture = data.image;
  rect.x = data.dx;
  rect.y = data.dy;
  rect.width = data.dw;
  rect.height = data.dh;
  const matrix = data.transform;
  build.build(rect, points);
  if (matrix) {
    transformVertices(points, matrix);
  }
  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
  const textureUvs = texture.layout.uvs;
  uvs.push(
    textureUvs.x0,
    textureUvs.y0,
    textureUvs.x1,
    textureUvs.y1,
    textureUvs.x3,
    textureUvs.y3,
    textureUvs.x2,
    textureUvs.y2
  );
  const graphicsBatch = BigPool.get(BatchableGraphics);
  graphicsBatch.indexOffset = indexOffset;
  graphicsBatch.indexSize = indices.length - indexOffset;
  graphicsBatch.vertexOffset = vertOffset;
  graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;
  graphicsBatch.color = data.style;
  graphicsBatch.alpha = data.alpha;
  graphicsBatch.texture = texture;
  graphicsBatch.geometryData = geometryData;
  batches.push(graphicsBatch);
}
function addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {
  const { vertices, uvs, indices } = geometryData;
  const lastIndex = shapePath.shapePrimitives.length - 1;
  shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i2) => {
    const indexOffset = indices.length;
    const vertOffset = vertices.length / 2;
    const points = [];
    const build = buildMap[shape.type];
    build.build(shape, points);
    if (matrix) {
      transformVertices(points, matrix);
    }
    if (!isStroke) {
      if (hole && lastIndex === i2) {
        if (lastIndex !== 0) {
          console.warn("[Pixi Graphics] only the last shape have be cut out");
        }
        const holeIndices = [];
        const otherPoints = points.slice();
        const holeArrays = getHoleArrays(hole.shapePath);
        holeArrays.forEach((holePoints) => {
          holeIndices.push(otherPoints.length / 2);
          otherPoints.push(...holePoints);
        });
        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);
      } else {
        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
      }
    } else {
      const close = shape.closePath ?? true;
      const lineStyle = style;
      buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);
    }
    const uvsOffset = uvs.length / 2;
    const texture = style.texture;
    if (texture !== Texture.WHITE) {
      const textureMatrix = style.matrix;
      if (matrix) {
        textureMatrix.append(matrix.clone().invert());
      }
      buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
    } else {
      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
    }
    const graphicsBatch = BigPool.get(BatchableGraphics);
    graphicsBatch.indexOffset = indexOffset;
    graphicsBatch.indexSize = indices.length - indexOffset;
    graphicsBatch.vertexOffset = vertOffset;
    graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;
    graphicsBatch.color = style.color;
    graphicsBatch.alpha = style.alpha;
    graphicsBatch.texture = texture;
    graphicsBatch.geometryData = geometryData;
    batches.push(graphicsBatch);
  });
}
function getHoleArrays(shape) {
  if (!shape)
    return [];
  const holePrimitives = shape.shapePrimitives;
  const holeArrays = [];
  for (let k3 = 0; k3 < holePrimitives.length; k3++) {
    const holePrimitive = holePrimitives[k3].shape;
    const holePoints = [];
    const holeBuilder = buildMap[holePrimitive.type];
    holeBuilder.build(holePrimitive, holePoints);
    holeArrays.push(holePoints);
  }
  return holeArrays;
}
var buildMap, tempRect;
var init_buildContextBatches = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs"() {
    init_Rectangle();
    init_buildUvs();
    init_transformVertices();
    init_Texture();
    init_PoolGroup();
    init_BatchableGraphics();
    init_buildCircle();
    init_buildLine();
    init_buildPolygon();
    init_buildRectangle();
    init_buildTriangle();
    init_triangulateWithHoles();
    buildMap = {
      rectangle: buildRectangle,
      polygon: buildPolygon,
      triangle: buildTriangle,
      circle: buildCircle,
      ellipse: buildCircle,
      roundedRectangle: buildCircle
    };
    tempRect = new Rectangle();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs
var GpuGraphicsContext, GraphicsContextRenderData, GraphicsContextSystem;
var init_GraphicsContextSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs"() {
    init_Extensions();
    init_BatchGeometry();
    init_getTextureBatchBindGroup();
    init_Batcher();
    init_InstructionSet();
    init_PoolGroup();
    init_buildContextBatches();
    GpuGraphicsContext = class {
    };
    GraphicsContextRenderData = class {
      constructor() {
        this.geometry = new BatchGeometry();
        this.instructions = new InstructionSet();
      }
      init() {
        this.geometry.reset();
        this.instructions.reset();
      }
    };
    GraphicsContextSystem = class {
      constructor() {
        this._activeBatchers = [];
        this._gpuContextHash = {};
        this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);
        this._needsContextNeedsRebuild = [];
      }
      prerender() {
        this._returnActiveBatchers();
      }
      getContextRenderData(context2) {
        return this._graphicsDataContextHash[context2.uid] || this._initContextRenderData(context2);
      }
      // Context management functions
      updateGpuContext(context2) {
        let gpuContext = this._gpuContextHash[context2.uid] || this._initContext(context2);
        if (context2.dirty) {
          if (gpuContext) {
            this._cleanGraphicsContextData(context2);
          } else {
            gpuContext = this._initContext(context2);
          }
          const contextBatches = buildContextBatches(context2);
          let size2 = 0;
          const batchMode = context2.batchMode;
          let isBatchable = true;
          if (context2.customShader || batchMode === "no-batch") {
            isBatchable = false;
          } else if (batchMode === "auto") {
            for (let i2 = 0; i2 < contextBatches.length; i2++) {
              size2 += contextBatches[i2].vertexSize;
              if (size2 > 400) {
                isBatchable = false;
                break;
              }
            }
          }
          gpuContext = this._gpuContextHash[context2.uid] = {
            isBatchable,
            batches: contextBatches
          };
          context2.dirty = false;
        }
        return gpuContext;
      }
      getGpuContext(context2) {
        return this._gpuContextHash[context2.uid] || this._initContext(context2);
      }
      _returnActiveBatchers() {
        for (let i2 = 0; i2 < this._activeBatchers.length; i2++) {
          BigPool.return(this._activeBatchers[i2]);
        }
        this._activeBatchers.length = 0;
      }
      _initContextRenderData(context2) {
        const graphicsData = BigPool.get(GraphicsContextRenderData);
        const batches = this._gpuContextHash[context2.uid].batches;
        let vertexSize = 0;
        let indexSize = 0;
        batches.forEach((batch) => {
          batch.applyTransform = false;
          vertexSize += batch.geometryData.vertices.length;
          indexSize += batch.geometryData.indices.length;
        });
        const batcher = BigPool.get(Batcher);
        this._activeBatchers.push(batcher);
        batcher.ensureAttributeBuffer(vertexSize);
        batcher.ensureIndexBuffer(indexSize);
        batcher.begin();
        for (let i2 = 0; i2 < batches.length; i2++) {
          const batch = batches[i2];
          batcher.add(batch);
        }
        batcher.finish(graphicsData.instructions);
        const geometry = graphicsData.geometry;
        geometry.indexBuffer.data = batcher.indexBuffer;
        geometry.buffers[0].data = batcher.attributeBuffer.float32View;
        geometry.indexBuffer.update(batcher.indexSize * 4);
        geometry.buffers[0].update(batcher.attributeSize * 4);
        const drawBatches = batcher.batches;
        for (let i2 = 0; i2 < drawBatches.length; i2++) {
          const batch = drawBatches[i2];
          batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);
        }
        this._graphicsDataContextHash[context2.uid] = graphicsData;
        return graphicsData;
      }
      _initContext(context2) {
        const gpuContext = new GpuGraphicsContext();
        this._gpuContextHash[context2.uid] = gpuContext;
        context2.on("update", this.onGraphicsContextUpdate, this);
        context2.on("destroy", this.onGraphicsContextDestroy, this);
        return this._gpuContextHash[context2.uid];
      }
      onGraphicsContextUpdate(context2) {
        this._needsContextNeedsRebuild.push(context2);
      }
      onGraphicsContextDestroy(context2) {
        this._cleanGraphicsContextData(context2);
        this._gpuContextHash[context2.uid] = null;
      }
      _cleanGraphicsContextData(context2) {
        const gpuContext = this._gpuContextHash[context2.uid];
        if (!gpuContext.isBatchable) {
          if (this._graphicsDataContextHash[context2.uid]) {
            BigPool.return(this.getContextRenderData(context2));
            this._graphicsDataContextHash[context2.uid] = null;
          }
        }
        if (gpuContext.batches) {
          gpuContext.batches.forEach((batch) => {
            BigPool.return(batch);
          });
        }
      }
      destroy() {
        for (const context2 of this._needsContextNeedsRebuild) {
          this._cleanGraphicsContextData(context2);
          this._gpuContextHash[context2.uid] = null;
        }
        this._needsContextNeedsRebuild.length = 0;
      }
    };
    GraphicsContextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "graphicsContext"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs
function color32BitToUniform(abgr, out2, offset) {
  out2[offset++] = (abgr & 255) / 255;
  out2[offset++] = (abgr >> 8 & 255) / 255;
  out2[offset++] = (abgr >> 16 & 255) / 255;
  out2[offset++] = (abgr >> 24 & 255) / 255;
}
var init_colorToUniform = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs
var GraphicsPipe;
var init_GraphicsPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs"() {
    init_Extensions();
    init_State();
    init_PoolGroup();
    init_colorToUniform();
    init_BatchableGraphics();
    GraphicsPipe = class {
      constructor(renderer, adaptor) {
        this.state = State.for2d();
        this._renderableBatchesHash = /* @__PURE__ */ Object.create(null);
        this.renderer = renderer;
        this._adaptor = adaptor;
        this._adaptor.init();
      }
      validateRenderable(renderable) {
        const context2 = renderable.view.context;
        const wasBatched = !!this._renderableBatchesHash[renderable.uid];
        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context2);
        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {
          return true;
        }
        return false;
      }
      addRenderable(renderable, instructionSet) {
        const gpuContext = this.renderer.graphicsContext.updateGpuContext(renderable.view.context);
        if (renderable.view._didUpdate) {
          renderable.view._didUpdate = false;
          this._rebuild(renderable);
        }
        if (gpuContext.isBatchable) {
          this._addToBatcher(renderable, instructionSet);
        } else {
          this.renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            type: "graphics",
            renderable
          });
        }
      }
      updateRenderable(renderable) {
        const batches = this._renderableBatchesHash[renderable.uid];
        if (batches) {
          for (let i2 = 0; i2 < batches.length; i2++) {
            const batch = batches[i2];
            batch.batcher.updateElement(batch);
          }
        }
      }
      destroyRenderable(renderable) {
        this._removeBatchForRenderable(renderable.uid);
      }
      execute({ renderable }) {
        if (!renderable.isRenderable)
          return;
        const renderer = this.renderer;
        const context2 = renderable.view.context;
        const contextSystem = renderer.graphicsContext;
        if (!contextSystem.getGpuContext(context2).batches.length) {
          return;
        }
        const shader = context2.customShader || this._adaptor.shader;
        this.state.blendMode = renderable.layerBlendMode;
        const localUniforms = shader.resources.localUniforms.uniforms;
        localUniforms.uTransformMatrix = renderable.layerTransform;
        localUniforms.uRound = renderer._roundPixels | renderable.view.roundPixels;
        color32BitToUniform(
          renderable.layerColor,
          localUniforms.uColor,
          0
        );
        this._adaptor.execute(this, renderable);
      }
      _rebuild(renderable) {
        const wasBatched = !!this._renderableBatchesHash[renderable.uid];
        const gpuContext = this.renderer.graphicsContext.updateGpuContext(renderable.view.context);
        if (wasBatched) {
          this._removeBatchForRenderable(renderable.uid);
        }
        if (gpuContext.isBatchable) {
          this._initBatchesForRenderable(renderable);
        }
        renderable.view.batched = gpuContext.isBatchable;
      }
      _addToBatcher(renderable, instructionSet) {
        const batchPipe = this.renderer.renderPipes.batch;
        const batches = this._getBatchesForRenderable(renderable);
        for (let i2 = 0; i2 < batches.length; i2++) {
          const batch = batches[i2];
          batchPipe.addToBatch(batch, instructionSet);
        }
      }
      _getBatchesForRenderable(renderable) {
        return this._renderableBatchesHash[renderable.uid] || this._initBatchesForRenderable(renderable);
      }
      _initBatchesForRenderable(renderable) {
        const context2 = renderable.view.context;
        const gpuContext = this.renderer.graphicsContext.getGpuContext(context2);
        const roundPixels = this.renderer._roundPixels | renderable.view.roundPixels;
        const batches = gpuContext.batches.map((batch) => {
          const batchClone = BigPool.get(BatchableGraphics);
          batch.copyTo(batchClone);
          batchClone.renderable = renderable;
          batchClone.roundPixels = roundPixels;
          return batchClone;
        });
        this._renderableBatchesHash[renderable.uid] = batches;
        renderable.on("destroyed", () => {
          this.destroyRenderable(renderable);
        });
        return batches;
      }
      _removeBatchForRenderable(renderableUid) {
        this._renderableBatchesHash[renderableUid].forEach((batch) => {
          BigPool.return(batch);
        });
        this._renderableBatchesHash[renderableUid] = null;
      }
      destroy() {
        this.renderer = null;
        this._adaptor.destroy();
        this._adaptor = null;
        this.state = null;
        for (const i2 in this._renderableBatchesHash) {
          this._removeBatchForRenderable(i2);
        }
        this._renderableBatchesHash = null;
      }
    };
    GraphicsPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "graphics"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs
var BatchableMesh;
var init_BatchableMesh = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs"() {
    BatchableMesh = class {
      constructor() {
        this.batcher = null;
        this.batch = null;
        this.roundPixels = 0;
      }
      get blendMode() {
        return this.renderable.layerBlendMode;
      }
      reset() {
        this.renderable = null;
        this.texture = null;
        this.batcher = null;
        this.batch = null;
      }
      packIndex(indexBuffer, index, indicesOffset) {
        const indices = this.renderable.view.geometry.indices;
        for (let i2 = 0; i2 < indices.length; i2++) {
          indexBuffer[index++] = indices[i2] + indicesOffset;
        }
      }
      packAttributes(float32View, uint32View, index, textureId) {
        const renderable = this.renderable;
        const view = this.renderable.view;
        const geometry = view.geometry;
        const wt = renderable.layerTransform;
        const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;
        const a2 = wt.a;
        const b2 = wt.b;
        const c2 = wt.c;
        const d3 = wt.d;
        const tx = wt.tx;
        const ty = wt.ty;
        const positions = geometry.positions;
        const uvs = geometry.uvs;
        const abgr = renderable.layerColor;
        for (let i2 = 0; i2 < positions.length; i2 += 2) {
          const x3 = positions[i2];
          const y2 = positions[i2 + 1];
          float32View[index] = a2 * x3 + c2 * y2 + tx;
          float32View[index + 1] = b2 * x3 + d3 * y2 + ty;
          float32View[index + 2] = uvs[i2];
          float32View[index + 3] = uvs[i2 + 1];
          uint32View[index + 4] = abgr;
          uint32View[index + 5] = textureIdAndRound;
          index += 6;
        }
      }
      get vertexSize() {
        return this.renderable.view.geometry.positions.length / 2;
      }
      get indexSize() {
        return this.renderable.view.geometry.indices.length;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs
var MeshPipe;
var init_MeshPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs"() {
    init_Extensions();
    init_Matrix();
    init_BindGroup();
    init_UniformGroup();
    init_PoolGroup();
    init_colorToUniform();
    init_BatchableMesh();
    MeshPipe = class {
      constructor(renderer, adaptor) {
        this.localUniforms = new UniformGroup({
          uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          uRound: { value: 0, type: "f32" }
        });
        this.localUniformsBindGroup = new BindGroup({
          0: this.localUniforms
        });
        this._renderableHash = /* @__PURE__ */ Object.create(null);
        this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null);
        this.renderer = renderer;
        this._adaptor = adaptor;
        this._adaptor.init();
      }
      validateRenderable(renderable) {
        const renderableData = this._getRenderableData(renderable);
        const wasBatched = renderableData.batched;
        const isBatched = renderable.view.batched;
        renderableData.batched = isBatched;
        if (wasBatched !== isBatched) {
          return true;
        } else if (isBatched) {
          const geometry = renderable.view._geometry;
          if (geometry.indices.length !== renderableData.indexSize || geometry.positions.length !== renderableData.vertexSize) {
            renderableData.indexSize = geometry.indices.length;
            renderableData.vertexSize = geometry.positions.length;
            return true;
          }
          const batchableMesh = this._getBatchableMesh(renderable);
          const texture = renderable.view.texture;
          if (batchableMesh.texture._source !== texture._source) {
            if (batchableMesh.texture._source !== texture._source) {
              return batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);
            }
          }
        }
        return false;
      }
      addRenderable(renderable, instructionSet) {
        const batcher = this.renderer.renderPipes.batch;
        const { batched } = this._getRenderableData(renderable);
        if (batched) {
          const gpuBatchableMesh = this._getBatchableMesh(renderable);
          gpuBatchableMesh.texture = renderable.view._texture;
          batcher.addToBatch(gpuBatchableMesh);
        } else {
          batcher.break(instructionSet);
          instructionSet.add({
            type: "mesh",
            renderable
          });
        }
      }
      updateRenderable(renderable) {
        if (renderable.view.batched) {
          const gpuBatchableMesh = this._gpuBatchableMeshHash[renderable.uid];
          gpuBatchableMesh.texture = renderable.view._texture;
          gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);
        }
      }
      destroyRenderable(renderable) {
        this._renderableHash[renderable.uid] = null;
        const gpuMesh = this._gpuBatchableMeshHash[renderable.uid];
        BigPool.return(gpuMesh);
        this._gpuBatchableMeshHash[renderable.uid] = null;
      }
      execute({ renderable }) {
        if (!renderable.isRenderable)
          return;
        const view = renderable.view;
        view.state.blendMode = renderable.layerBlendMode;
        const localUniforms = this.localUniforms;
        localUniforms.uniforms.uTransformMatrix = renderable.layerTransform;
        localUniforms.uniforms.uRound = this.renderer._roundPixels | renderable.view.roundPixels;
        localUniforms.update();
        color32BitToUniform(
          renderable.layerColor,
          localUniforms.uniforms.uColor,
          0
        );
        this._adaptor.execute(this, renderable);
      }
      _getRenderableData(renderable) {
        return this._renderableHash[renderable.uid] || this._initRenderableData(renderable);
      }
      _initRenderableData(renderable) {
        const view = renderable.view;
        this._renderableHash[renderable.uid] = {
          batched: view.batched,
          indexSize: view._geometry.indices.length,
          vertexSize: view._geometry.positions.length
        };
        renderable.on("destroyed", () => {
          this.destroyRenderable(renderable);
        });
        return this._renderableHash[renderable.uid];
      }
      _getBatchableMesh(renderable) {
        return this._gpuBatchableMeshHash[renderable.uid] || this._initBatchableMesh(renderable);
      }
      _initBatchableMesh(renderable) {
        const gpuMesh = BigPool.get(BatchableMesh);
        gpuMesh.renderable = renderable;
        gpuMesh.texture = renderable.view._texture;
        gpuMesh.roundPixels = this.renderer._roundPixels | renderable.view.roundPixels;
        this._gpuBatchableMeshHash[renderable.uid] = gpuMesh;
        gpuMesh.renderable = renderable;
        return gpuMesh;
      }
      destroy() {
        for (const i2 in this._gpuBatchableMeshHash) {
          if (this._gpuBatchableMeshHash[i2]) {
            BigPool.return(this._gpuBatchableMeshHash[i2]);
          }
        }
        this._gpuBatchableMeshHash = null;
        this._renderableHash = null;
        this.localUniforms = null;
        this.localUniformsBindGroup = null;
        this._adaptor.destroy();
        this._adaptor = null;
        this.renderer = null;
      }
    };
    MeshPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "mesh"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs
var BatchableSprite;
var init_BatchableSprite = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs"() {
    BatchableSprite = class {
      constructor() {
        this.vertexSize = 4;
        this.indexSize = 6;
        this.location = 0;
        this.batcher = null;
        this.batch = null;
        this.roundPixels = 0;
      }
      get blendMode() {
        return this.renderable.layerBlendMode;
      }
      packAttributes(float32View, uint32View, index, textureId) {
        const sprite = this.renderable;
        const texture = this.texture;
        const wt = sprite.layerTransform;
        const a2 = wt.a;
        const b2 = wt.b;
        const c2 = wt.c;
        const d3 = wt.d;
        const tx = wt.tx;
        const ty = wt.ty;
        const bounds = this.bounds;
        const w0 = bounds[1];
        const w1 = bounds[0];
        const h0 = bounds[3];
        const h1 = bounds[2];
        const uvs = texture._layout.uvs;
        const argb = sprite.layerColor;
        const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;
        float32View[index + 0] = a2 * w1 + c2 * h1 + tx;
        float32View[index + 1] = d3 * h1 + b2 * w1 + ty;
        float32View[index + 2] = uvs.x0;
        float32View[index + 3] = uvs.y0;
        uint32View[index + 4] = argb;
        uint32View[index + 5] = textureIdAndRound;
        float32View[index + 6] = a2 * w0 + c2 * h1 + tx;
        float32View[index + 7] = d3 * h1 + b2 * w0 + ty;
        float32View[index + 8] = uvs.x1;
        float32View[index + 9] = uvs.y1;
        uint32View[index + 10] = argb;
        uint32View[index + 11] = textureIdAndRound;
        float32View[index + 12] = a2 * w0 + c2 * h0 + tx;
        float32View[index + 13] = d3 * h0 + b2 * w0 + ty;
        float32View[index + 14] = uvs.x2;
        float32View[index + 15] = uvs.y2;
        uint32View[index + 16] = argb;
        uint32View[index + 17] = textureIdAndRound;
        float32View[index + 18] = a2 * w1 + c2 * h0 + tx;
        float32View[index + 19] = d3 * h0 + b2 * w1 + ty;
        float32View[index + 20] = uvs.x3;
        float32View[index + 21] = uvs.y3;
        uint32View[index + 22] = argb;
        uint32View[index + 23] = textureIdAndRound;
      }
      packIndex(indexBuffer, index, indicesOffset) {
        indexBuffer[index] = indicesOffset + 0;
        indexBuffer[index + 1] = indicesOffset + 1;
        indexBuffer[index + 2] = indicesOffset + 2;
        indexBuffer[index + 3] = indicesOffset + 0;
        indexBuffer[index + 4] = indicesOffset + 2;
        indexBuffer[index + 5] = indicesOffset + 3;
      }
      reset() {
        this.renderable = null;
        this.texture = null;
        this.batcher = null;
        this.batch = null;
        this.bounds = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs
var gpuSpriteHash, SpritePipe;
var init_SpritePipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs"() {
    init_Extensions();
    init_PoolGroup();
    init_BatchableSprite();
    SpritePipe = class {
      constructor(renderer) {
        this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
        gpuSpriteHash = this._gpuSpriteHash;
      }
      addRenderable(renderable, _instructionSet) {
        const gpuSprite = this._getGpuSprite(renderable);
        if (renderable.view._didUpdate)
          this._updateBatchableSprite(renderable, gpuSprite);
        this._renderer.renderPipes.batch.addToBatch(gpuSprite);
      }
      updateRenderable(renderable) {
        const gpuSprite = gpuSpriteHash[renderable.uid];
        if (renderable.view._didUpdate)
          this._updateBatchableSprite(renderable, gpuSprite);
        gpuSprite.batcher.updateElement(gpuSprite);
      }
      validateRenderable(renderable) {
        const texture = renderable.view._texture;
        const gpuSprite = this._getGpuSprite(renderable);
        if (gpuSprite.texture._source !== texture._source) {
          return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);
        }
        return false;
      }
      destroyRenderable(renderable) {
        const batchableSprite = gpuSpriteHash[renderable.uid];
        BigPool.return(batchableSprite);
        gpuSpriteHash[renderable.uid] = null;
      }
      _updateBatchableSprite(renderable, batchableSprite) {
        const view = renderable.view;
        view._didUpdate = false;
        batchableSprite.bounds = view.bounds;
        batchableSprite.texture = view._texture;
      }
      _getGpuSprite(renderable) {
        return gpuSpriteHash[renderable.uid] || this._initGPUSprite(renderable);
      }
      _initGPUSprite(renderable) {
        const batchableSprite = BigPool.get(BatchableSprite);
        batchableSprite.renderable = renderable;
        const view = renderable.view;
        batchableSprite.texture = view._texture;
        batchableSprite.bounds = view.bounds;
        batchableSprite.roundPixels = this._renderer._roundPixels | view.roundPixels;
        gpuSpriteHash[renderable.uid] = batchableSprite;
        renderable.view._didUpdate = false;
        renderable.on("destroyed", () => {
          this.destroyRenderable(renderable);
        });
        return batchableSprite;
      }
      destroy() {
        for (const i2 in this._gpuSpriteHash) {
          BigPool.return(this._gpuSpriteHash[i2]);
        }
        this._gpuSpriteHash = null;
        this._renderer = null;
      }
    };
    SpritePipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "sprite"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/ProxyRenderable.mjs
var ProxyRenderable;
var init_ProxyRenderable = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/ProxyRenderable.mjs"() {
    init_eventemitter3();
    init_uid();
    ProxyRenderable = class extends eventemitter3_default {
      constructor({ original, view }) {
        super();
        this.uid = uid("renderable");
        this.didViewUpdate = false;
        this.view = view;
        if (original) {
          this.init(original);
        }
      }
      init(original) {
        this._original = original;
        this.layerTransform = original.layerTransform;
      }
      get layerColor() {
        return this._original.layerColor;
      }
      get layerBlendMode() {
        return this._original.layerBlendMode;
      }
      get layerVisibleRenderable() {
        return this._original.layerVisibleRenderable;
      }
      get isRenderable() {
        return this._original.isRenderable;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/mesh/shared/MeshView.mjs
var tempPolygon, MeshView;
var init_MeshView = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/mesh/shared/MeshView.mjs"() {
    init_Polygon();
    init_State();
    init_Texture();
    init_View();
    init_uid();
    tempPolygon = new Polygon();
    MeshView = class {
      constructor(options) {
        this.uid = uid("meshView");
        this.renderPipeId = "mesh";
        this.canBundle = true;
        this.owner = emptyViewObserver;
        this.state = State.for2d();
        this.roundPixels = 0;
        this.shader = options.shader;
        this.texture = options.texture ?? this.shader?.texture ?? Texture.WHITE;
        this._geometry = options.geometry;
        this._geometry.on("update", this.onUpdate, this);
      }
      set shader(value) {
        if (this._shader === value)
          return;
        this._shader = value;
        this.onUpdate();
      }
      get shader() {
        return this._shader;
      }
      set geometry(value) {
        if (this._geometry === value)
          return;
        this._geometry?.off("update", this.onUpdate, this);
        value.on("update", this.onUpdate, this);
        this._geometry = value;
        this.onUpdate();
      }
      get geometry() {
        return this._geometry;
      }
      set texture(value) {
        if (this._texture === value)
          return;
        if (this.shader) {
          this.shader.texture = value;
        }
        this._texture = value;
        this.onUpdate();
      }
      get texture() {
        return this._texture;
      }
      get batched() {
        if (this._shader)
          return false;
        if (this._geometry.batchMode === "auto") {
          return this._geometry.positions.length / 2 <= 100;
        }
        return this._geometry.batchMode === "batch";
      }
      addBounds(bounds) {
        bounds.addVertexData(this.geometry.positions, 0, this.geometry.positions.length);
      }
      containsPoint(point) {
        const { x: x3, y: y2 } = point;
        const vertices = this.geometry.getBuffer("aPosition").data;
        const points = tempPolygon.points;
        const indices = this.geometry.getIndex().data;
        const len = indices.length;
        const step = this.geometry.topology === "triangle-strip" ? 3 : 1;
        for (let i2 = 0; i2 + 2 < len; i2 += step) {
          const ind0 = indices[i2] * 2;
          const ind1 = indices[i2 + 1] * 2;
          const ind2 = indices[i2 + 2] * 2;
          points[0] = vertices[ind0];
          points[1] = vertices[ind0 + 1];
          points[2] = vertices[ind1];
          points[3] = vertices[ind1 + 1];
          points[4] = vertices[ind2];
          points[5] = vertices[ind2 + 1];
          if (tempPolygon.contains(x3, y2)) {
            return true;
          }
        }
        return false;
      }
      /** Called when the geometry is updated. */
      onUpdate() {
        this.owner.onViewUpdate();
      }
      /**
       * Destroys this sprite renderable and optionally its texture.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
       * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
       */
      destroy(options = false) {
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          this._texture.destroy(destroyTextureSource);
        }
        this._texture = null;
        this._geometry = null;
        this._shader = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs
var _MeshGeometry, MeshGeometry;
var init_MeshGeometry = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs"() {
    init_Buffer();
    init_const5();
    init_Geometry();
    init_deprecation();
    _MeshGeometry = class extends Geometry {
      constructor(...args) {
        let options = args[0] ?? {};
        if (options instanceof Float32Array) {
          deprecation(v8_0_0, "use new MeshGeometry({ positions, uvs, indices }) instead");
          options = {
            positions: options,
            uvs: args[1],
            indices: args[2]
          };
        }
        options = { ..._MeshGeometry.defaultOptions, ...options };
        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
        const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);
        const positionBuffer = new Buffer2({
          data: positions,
          label: "attribute-mesh-positions",
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
        });
        const uvBuffer = new Buffer2({
          data: uvs,
          label: "attribute-mesh-uvs",
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
        });
        const indexBuffer = new Buffer2({
          data: indices,
          label: "index-mesh-buffer",
          usage: BufferUsage.INDEX | BufferUsage.COPY_DST
        });
        super({
          attributes: {
            aPosition: {
              buffer: positionBuffer,
              shaderLocation: 0,
              format: "float32x2",
              stride: 2 * 4,
              offset: 0
            },
            aUV: {
              buffer: uvBuffer,
              shaderLocation: 1,
              format: "float32x2",
              stride: 2 * 4,
              offset: 0
            }
          },
          indexBuffer,
          topology: options.topology
        });
        this.batchMode = "auto";
      }
      get positions() {
        return this.attributes.aPosition.buffer.data;
      }
      set positions(value) {
        this.attributes.aPosition.buffer.data = value;
      }
      get uvs() {
        return this.attributes.aUV.buffer.data;
      }
      set uvs(value) {
        this.attributes.aUV.buffer.data = value;
      }
      get indices() {
        return this.indexBuffer.data;
      }
      set indices(value) {
        this.indexBuffer.data = value;
      }
    };
    MeshGeometry = _MeshGeometry;
    MeshGeometry.defaultOptions = {
      topology: "triangle-list"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite-tiling/QuadGeometry.mjs
var QuadGeometry;
var init_QuadGeometry = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite-tiling/QuadGeometry.mjs"() {
    init_MeshGeometry();
    QuadGeometry = class extends MeshGeometry {
      constructor() {
        super({
          positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
          uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
          indices: new Uint32Array([0, 1, 2, 0, 2, 3])
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs
var tilingBit, tilingBitGl;
var init_tilingBit = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs"() {
    tilingBit = {
      name: "tiling-bit",
      vertex: {
        header: (
          /* wgsl */
          `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
        ),
        main: (
          /* wgsl */
          `
            vUV = (tilingUniforms.uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
        )
      },
      fragment: {
        header: (
          /* wgsl */
          `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
        ),
        main: (
          /* wgsl */
          `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
        )
      }
    };
    tilingBitGl = {
      name: "tiling-bit",
      vertex: {
        header: (
          /* glsl */
          `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `
        ),
        main: (
          /* glsl */
          `
            vUV = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
        )
      },
      fragment: {
        header: (
          /* glsl */
          `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `
        ),
        main: (
          /* glsl */
          `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0
    
        `
        )
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs
var TilingSpriteShader;
var init_TilingSpriteShader = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs"() {
    init_Matrix();
    init_compileHighShaderToProgram();
    init_localUniformBit();
    init_roundPixelsBit();
    init_Shader();
    init_UniformGroup();
    init_tilingBit();
    TilingSpriteShader = class extends Shader {
      constructor(options) {
        const gpuProgram = compileHighShaderGpuProgram({
          name: "tiling-sprite-shader",
          bits: [
            localUniformBit,
            tilingBit,
            roundPixelsBit
          ]
        });
        const glProgram = compileHighShaderGlProgram({
          name: "tiling-sprite-shader",
          bits: [
            localUniformBitGl,
            tilingBitGl,
            roundPixelsBitGl
          ]
        });
        const tilingUniforms = new UniformGroup({
          uMapCoord: { value: new Matrix(), type: "mat3x3<f32>" },
          uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },
          uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },
          uTextureTransform: { value: new Matrix(), type: "mat3x3<f32>" },
          uSizeAnchor: { value: new Float32Array([100, 200, 0.5, 0.5]), type: "vec4<f32>" }
        });
        super({
          glProgram,
          gpuProgram,
          resources: {
            tilingUniforms,
            uTexture: options.texture.source,
            uSampler: options.texture.source.style
          }
        });
      }
      get texture() {
        return this._texture;
      }
      set texture(value) {
        if (this._texture === value)
          return;
        this._texture = value;
        this.resources.uTexture = value.source;
        this.resources.uSampler = value.source.style;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs
function applyMatrix(array, stride, offset, matrix) {
  let index = 0;
  const size2 = array.length / (stride || 2);
  const a2 = matrix.a;
  const b2 = matrix.b;
  const c2 = matrix.c;
  const d3 = matrix.d;
  const tx = matrix.tx;
  const ty = matrix.ty;
  offset *= stride;
  while (index < size2) {
    const x3 = array[offset];
    const y2 = array[offset + 1];
    array[offset] = a2 * x3 + c2 * y2 + tx;
    array[offset + 1] = b2 * x3 + d3 * y2 + ty;
    offset += stride;
    index++;
  }
}
var sharedQuad, TilingSpritePipe;
var init_TilingSpritePipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs"() {
    init_Extensions();
    init_Matrix();
    init_ProxyRenderable();
    init_MeshView();
    init_QuadGeometry();
    init_TilingSpriteShader();
    sharedQuad = new QuadGeometry();
    TilingSpritePipe = class {
      constructor(renderer) {
        this._renderableHash = /* @__PURE__ */ Object.create(null);
        this._gpuBatchedTilingSprite = /* @__PURE__ */ Object.create(null);
        this._gpuTilingSprite = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      validateRenderable(renderable) {
        const textureMatrix = renderable.view.texture.textureMatrix;
        let rebuild = false;
        const renderableData = this._getRenderableData(renderable);
        if (renderableData.batched !== textureMatrix.isSimple) {
          renderableData.batched = textureMatrix.isSimple;
          rebuild = true;
        }
        return rebuild;
      }
      addRenderable(renderable, instructionSet) {
        if (renderable.view._didUpdate) {
          renderable.view._didUpdate = false;
          this._rebuild(renderable);
        }
        const { batched } = this._getRenderableData(renderable);
        if (batched) {
          const batchableTilingSprite = this._getBatchedTilingSprite(renderable);
          this._renderer.renderPipes.mesh.addRenderable(batchableTilingSprite, instructionSet);
        } else {
          const gpuTilingSprite = this._getGpuTilingSprite(renderable);
          this._renderer.renderPipes.mesh.addRenderable(gpuTilingSprite.meshRenderable, instructionSet);
        }
      }
      updateRenderable(renderable) {
        if (renderable.view._didUpdate) {
          renderable.view._didUpdate = false;
          this._rebuild(renderable);
        }
        const { batched } = this._getRenderableData(renderable);
        if (batched) {
          const batchableTilingSprite = this._getBatchedTilingSprite(renderable);
          this._renderer.renderPipes.mesh.updateRenderable(batchableTilingSprite);
        } else {
          const gpuTilingSprite = this._getGpuTilingSprite(renderable);
          this._renderer.renderPipes.mesh.updateRenderable(gpuTilingSprite.meshRenderable);
        }
      }
      destroyRenderable(renderable) {
        this._renderableHash[renderable.uid] = null;
        this._gpuTilingSprite[renderable.uid] = null;
        this._gpuBatchedTilingSprite[renderable.uid] = null;
      }
      _getRenderableData(renderable) {
        return this._renderableHash[renderable.uid] || this._initRenderableData(renderable);
      }
      _initRenderableData(renderable) {
        const renderableData = {
          batched: true
        };
        this._renderableHash[renderable.uid] = renderableData;
        this.validateRenderable(renderable);
        renderable.on("destroyed", () => {
          this.destroyRenderable(renderable);
        });
        return renderableData;
      }
      _rebuild(renderable) {
        const renderableData = this._getRenderableData(renderable);
        const view = renderable.view;
        const textureMatrix = view.texture.textureMatrix;
        if (renderableData.batched) {
          const batchedMesh = this._getBatchedTilingSprite(renderable);
          batchedMesh.view.texture = view.texture;
          const style = view.texture.source.style;
          if (style.addressMode !== "repeat") {
            style.addressMode = "repeat";
            style.update();
          }
          this._updateBatchPositions(renderable);
          this._updateBatchUvs(renderable);
        } else {
          const gpuTilingSprite = this._getGpuTilingSprite(renderable);
          const { meshRenderable } = gpuTilingSprite;
          const meshView = meshRenderable.view;
          meshView.shader.texture = view.texture;
          const tilingUniforms = meshView.shader.resources.tilingUniforms;
          const originalWidth = view.width;
          const originalHeight = view.height;
          const tilingSpriteWidth = view.texture.width;
          const tilingSpriteHeight = view.texture.height;
          const matrix = view._tileTransform.matrix;
          const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;
          uTextureTransform.set(
            matrix.a * tilingSpriteWidth / originalWidth,
            matrix.b * tilingSpriteWidth / originalHeight,
            matrix.c * tilingSpriteHeight / originalWidth,
            matrix.d * tilingSpriteHeight / originalHeight,
            matrix.tx / originalWidth,
            matrix.ty / originalHeight
          );
          uTextureTransform.invert();
          tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;
          tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;
          tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;
          tilingUniforms.uniforms.uTextureTransform = uTextureTransform;
          tilingUniforms.uniforms.uSizeAnchor[0] = originalWidth;
          tilingUniforms.uniforms.uSizeAnchor[1] = originalHeight;
          tilingUniforms.uniforms.uSizeAnchor[2] = renderable.view.anchor.x;
          tilingUniforms.uniforms.uSizeAnchor[3] = renderable.view.anchor.y;
          tilingUniforms.update();
        }
      }
      _getGpuTilingSprite(renderable) {
        return this._gpuTilingSprite[renderable.uid] || this._initGpuTilingSprite(renderable);
      }
      _initGpuTilingSprite(renderable) {
        const view = renderable.view;
        const style = view.texture.source.style;
        style.addressMode = "repeat";
        style.update();
        const meshView = new MeshView({
          geometry: sharedQuad,
          shader: new TilingSpriteShader({
            texture: view.texture
          })
        });
        const meshRenderable = new ProxyRenderable({
          original: renderable,
          view: meshView
        });
        const textureMatrix = new Matrix();
        const gpuTilingSpriteData = {
          meshRenderable,
          textureMatrix
        };
        this._gpuTilingSprite[renderable.uid] = gpuTilingSpriteData;
        return gpuTilingSpriteData;
      }
      _getBatchedTilingSprite(renderable) {
        return this._gpuBatchedTilingSprite[renderable.uid] || this._initBatchedTilingSprite(renderable);
      }
      _initBatchedTilingSprite(renderable) {
        const meshView = new MeshView({
          geometry: new QuadGeometry(),
          texture: renderable.view.texture
        });
        meshView.roundPixels = this._renderer._roundPixels | renderable.view.roundPixels;
        const batchableMeshRenderable = new ProxyRenderable({
          original: renderable,
          view: meshView
        });
        this._gpuBatchedTilingSprite[renderable.uid] = batchableMeshRenderable;
        return batchableMeshRenderable;
      }
      _updateBatchPositions(renderable) {
        const meshRenderable = this._getBatchedTilingSprite(renderable);
        const view = renderable.view;
        const positionBuffer = meshRenderable.view.geometry.getBuffer("aPosition");
        const positions = positionBuffer.data;
        const anchorX = view.anchor.x;
        const anchorY = view.anchor.y;
        positions[0] = -anchorX * view.width;
        positions[1] = -anchorY * view.height;
        positions[2] = (1 - anchorX) * view.width;
        positions[3] = -anchorY * view.height;
        positions[4] = (1 - anchorX) * view.width;
        positions[5] = (1 - anchorY) * view.height;
        positions[6] = -anchorX * view.width;
        positions[7] = (1 - anchorY) * view.height;
      }
      _updateBatchUvs(renderable) {
        const view = renderable.view;
        const width = view.texture.frameWidth;
        const height = view.texture.frameHeight;
        const meshRenderable = this._getBatchedTilingSprite(renderable);
        const uvBuffer = meshRenderable.view.geometry.getBuffer("aUV");
        const uvs = uvBuffer.data;
        let anchorX = 0;
        let anchorY = 0;
        if (view._applyAnchorToTexture) {
          anchorX = view.anchor.x;
          anchorY = view.anchor.y;
        }
        uvs[0] = uvs[6] = -anchorX;
        uvs[2] = uvs[4] = 1 - anchorX;
        uvs[1] = uvs[3] = -anchorY;
        uvs[5] = uvs[7] = 1 - anchorY;
        const textureMatrix = Matrix.shared;
        textureMatrix.copyFrom(view._tileTransform.matrix);
        textureMatrix.tx /= view.width;
        textureMatrix.ty /= view.height;
        textureMatrix.invert();
        textureMatrix.scale(view.width / width, view.height / height);
        applyMatrix(uvs, 2, 0, textureMatrix);
      }
      destroy() {
        this._renderableHash = null;
        this._gpuTilingSprite = null;
        this._gpuBatchedTilingSprite = null;
        this._renderer = null;
      }
    };
    TilingSpritePipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "tilingSprite"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsView.mjs
var GraphicsView;
var init_GraphicsView = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsView.mjs"() {
    init_View();
    init_uid();
    init_GraphicsContext();
    GraphicsView = class {
      constructor(graphicsContext) {
        this.uid = uid("graphicsView");
        this.canBundle = true;
        this.owner = emptyViewObserver;
        this.renderPipeId = "graphics";
        this.roundPixels = 0;
        this._context = graphicsContext || new GraphicsContext();
        this._context.on("update", this.onGraphicsContextUpdate, this);
      }
      set context(context2) {
        if (context2 === this._context)
          return;
        this._context.off("update", this.onGraphicsContextUpdate, this);
        this._context = context2;
        this._context.on("update", this.onGraphicsContextUpdate, this);
        this.onGraphicsContextUpdate();
      }
      get context() {
        return this._context;
      }
      addBounds(bounds) {
        bounds.addBounds(this._context.bounds);
      }
      containsPoint(point) {
        return this._context.containsPoint(point);
      }
      onGraphicsContextUpdate() {
        this._didUpdate = true;
        this.owner.onViewUpdate();
      }
      /**
       * Destroys this graphics renderable and optionally its context.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context
       * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context
       * @param {boolean} [options.context=false] - Should destroy the context
       */
      destroy(options = false) {
        this.owner = null;
        const destroyContext = typeof options === "boolean" ? options : options?.context;
        if (destroyContext) {
          this._context.destroy(options);
        }
        this._context = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/batchSamplersUniformGroup.mjs
var sampleValues, batchSamplersUniformGroup;
var init_batchSamplersUniformGroup = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/batchSamplersUniformGroup.mjs"() {
    init_const3();
    init_UniformGroup();
    sampleValues = new Int32Array(MAX_TEXTURES);
    for (let i2 = 0; i2 < MAX_TEXTURES; i2++) {
      sampleValues[i2] = i2;
    }
    batchSamplersUniformGroup = new UniformGroup({
      uSamplers: { value: sampleValues, type: `u32`, size: MAX_TEXTURES }
    }, { isStatic: true });
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs
var localUniformMSDFBit;
var init_localUniformMSDFBit = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs"() {
    localUniformMSDFBit = {
      name: "local-uniform-msdf-bit",
      vertex: {
        header: (
          /* wgsl */
          `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
        ),
        main: (
          /* wgsl */
          `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
        ),
        end: (
          /* wgsl */
          `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        )
      },
      fragment: {
        header: (
          /* wgsl */
          `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `
        ),
        main: (
          /* wgsl */
          ` 
            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);
        `
        )
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs
var mSDFBit, mSDFBitGl;
var init_mSDFBit = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs"() {
    mSDFBit = {
      name: "msdf-bit",
      fragment: {
        header: (
          /* wgsl */
          `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                return alpha;
            }
        `
        )
      }
    };
    mSDFBitGl = {
      name: "msdf-bit",
      fragment: {
        header: (
          /* glsl */
          `
            float calculateMSDFAlpha(vec4 msdfColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                return alpha;
            }

            uniform float uDistance;
        `
        ),
        main: (
          /* glsl */
          `

            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);
        `
        )
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs
var SdfShader;
var init_SdfShader = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs"() {
    init_Matrix();
    init_const3();
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_localUniformBit();
    init_roundPixelsBit();
    init_batchSamplersUniformGroup();
    init_Shader();
    init_UniformGroup();
    init_localUniformMSDFBit();
    init_mSDFBit();
    SdfShader = class extends Shader {
      constructor() {
        const uniforms = new UniformGroup({
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uDistance: { value: 4, type: "f32" },
          uRound: { value: 0, type: "f32" }
        });
        const gpuProgram = compileHighShaderGpuProgram({
          name: "sdf-shader",
          bits: [
            colorBit,
            generateTextureBatchBit(MAX_TEXTURES),
            localUniformMSDFBit,
            mSDFBit,
            roundPixelsBit
          ]
        });
        const glProgram = compileHighShaderGlProgram({
          name: "sdf-shader",
          bits: [
            colorBitGl,
            generateTextureBatchBitGl(MAX_TEXTURES),
            localUniformBitGl,
            mSDFBitGl,
            roundPixelsBitGl
          ]
        });
        super({
          glProgram,
          gpuProgram,
          resources: {
            localUniforms: uniforms,
            batchSamplers: batchSamplersUniformGroup
          }
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs
function generateTextStyleKey(style) {
  const key = [];
  let index = 0;
  for (let i2 = 0; i2 < valuesToIterateForKeys.length; i2++) {
    const prop = valuesToIterateForKeys[i2];
    key[index++] = style[prop];
  }
  index = addFillStyleKey(style._fill, key, index);
  index = addStokeStyleKey(style._stroke, key, index);
  return key.join("-");
}
function addFillStyleKey(fillStyle, key, index) {
  if (!fillStyle)
    return index;
  key[index++] = fillStyle.color;
  key[index++] = fillStyle.alpha;
  key[index++] = fillStyle.fill?.uid;
  return index;
}
function addStokeStyleKey(strokeStyle, key, index) {
  if (!strokeStyle)
    return index;
  index = addFillStyleKey(strokeStyle, key, index);
  key[index++] = strokeStyle.width;
  key[index++] = strokeStyle.alignment;
  key[index++] = strokeStyle.cap;
  key[index++] = strokeStyle.join;
  key[index++] = strokeStyle.miterLimit;
  return index;
}
var valuesToIterateForKeys;
var init_generateTextStyleKey = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs"() {
    valuesToIterateForKeys = [
      "_fontFamily",
      "_fontStyle",
      "_fontVariant",
      "_fontWeight",
      "_breakWords",
      "_align",
      "_leading",
      "_letterSpacing",
      "_lineHeight",
      "_textBaseline",
      "_whiteSpace",
      "_wordWrap",
      "_wordWrapWidth",
      "_padding",
      "_cssOverrides"
    ];
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/TextStyle.mjs
function convertV7Tov8Style(style) {
  const oldStyle = style;
  if (typeof oldStyle.dropShadow === "boolean") {
    deprecation(v8_0_0, "dropShadow is now an object, not a boolean");
    style.dropShadow = {
      alpha: oldStyle.dropShadowAlpha ?? 1,
      angle: oldStyle.dropShadowAngle,
      blur: oldStyle.dropShadowBlur ?? 0,
      color: oldStyle.dropShadowColor,
      distance: oldStyle.dropShadowDistance
    };
  }
  if (oldStyle.strokeThickness) {
    deprecation(v8_0_0, "strokeThickness is now a part of stroke");
    const color = oldStyle.stroke;
    style.stroke = {
      color,
      width: oldStyle.strokeThickness
    };
  }
  if (Array.isArray(oldStyle.fill)) {
    deprecation(v8_0_0, "gradient fill is now a fill pattern: `new FillGradient(...)`");
    const gradientFill = new FillGradient(0, 0, 0, style.fontSize * 1.7);
    const fills = oldStyle.fill.map((color) => Color.shared.setValue(color).toNumber());
    fills.forEach((number, index) => {
      const ratio = oldStyle.fillGradientStops[index] ?? index / fills.length;
      gradientFill.addColorStop(ratio, number);
    });
    style.fill = {
      fill: gradientFill
    };
  }
}
var _TextStyle, TextStyle;
var init_TextStyle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/TextStyle.mjs"() {
    init_eventemitter3();
    init_Color();
    init_deprecation();
    init_FillGradient();
    init_GraphicsContext();
    init_convertFillInputToFillStyle();
    init_generateTextStyleKey();
    _TextStyle = class extends eventemitter3_default {
      constructor(style = {}) {
        super();
        convertV7Tov8Style(style);
        const fullStyle = { ..._TextStyle.defaultTextStyle, ...style };
        for (const key in _TextStyle.defaultTextStyle) {
          const thisKey = key;
          this[thisKey] = fullStyle[key];
        }
        this.dropShadow = null;
        if (typeof fullStyle.fill === "string") {
          this.fontSize = parseInt(fullStyle.fontSize, 10);
        } else {
          this.fontSize = fullStyle.fontSize;
        }
        if (style.dropShadow) {
          if (style.dropShadow instanceof Boolean) {
            if (style.dropShadow === true) {
              this.dropShadow = {
                ..._TextStyle.defaultTextStyle.dropShadow
              };
            }
          } else {
            this.dropShadow = {
              ..._TextStyle.defaultTextStyle.dropShadow,
              ...style.dropShadow
            };
          }
        }
        this.update();
      }
      get align() {
        return this._align;
      }
      set align(value) {
        this._align = value;
        this.update();
      }
      get breakWords() {
        return this._breakWords;
      }
      set breakWords(value) {
        this._breakWords = value;
        this.update();
      }
      get dropShadow() {
        return this._dropShadow;
      }
      set dropShadow(value) {
        this._dropShadow = value;
        this.update();
      }
      get fontFamily() {
        return this._fontFamily;
      }
      set fontFamily(value) {
        this._fontFamily = value;
        this.update();
      }
      get fontSize() {
        return this._fontSize;
      }
      set fontSize(value) {
        this._fontSize = value;
        this.update();
      }
      get fontStyle() {
        return this._fontStyle;
      }
      set fontStyle(value) {
        this._fontStyle = value;
        this.update();
      }
      get fontVariant() {
        return this._fontVariant;
      }
      set fontVariant(value) {
        this._fontVariant = value;
        this.update();
      }
      get fontWeight() {
        return this._fontWeight;
      }
      set fontWeight(value) {
        this._fontWeight = value;
        this.update();
      }
      get leading() {
        return this._leading;
      }
      set leading(value) {
        this._leading = value;
        this.update();
      }
      get letterSpacing() {
        return this._letterSpacing;
      }
      set letterSpacing(value) {
        this._letterSpacing = value;
        this.update();
      }
      get lineHeight() {
        return this._lineHeight;
      }
      set lineHeight(value) {
        this._lineHeight = value;
        this.update();
      }
      get padding() {
        return this._padding;
      }
      set padding(value) {
        this._padding = value;
        this.update();
      }
      get textBaseline() {
        return this._textBaseline;
      }
      set textBaseline(value) {
        this._textBaseline = value;
        this.update();
      }
      get whiteSpace() {
        return this._whiteSpace;
      }
      set whiteSpace(value) {
        this._whiteSpace = value;
        this.update();
      }
      get wordWrap() {
        return this._wordWrap;
      }
      set wordWrap(value) {
        this._wordWrap = value;
        this.update();
      }
      get wordWrapWidth() {
        return this._wordWrapWidth;
      }
      set wordWrapWidth(value) {
        this._wordWrapWidth = value;
        this.update();
      }
      get fill() {
        return this._originalFill;
      }
      set fill(value) {
        if (value === this._originalFill)
          return;
        this._originalFill = value;
        this._fill = convertFillInputToFillStyle(value, GraphicsContext.defaultFillStyle);
        this.update();
      }
      get stroke() {
        return this._originalStroke;
      }
      set stroke(value) {
        if (value === this._originalFill)
          return;
        this._originalFill = value;
        this._stroke = convertFillInputToFillStyle(value, GraphicsContext.defaultStrokeStyle);
        this.update();
      }
      _generateKey() {
        this._styleKey = generateTextStyleKey(this);
        return this._styleKey;
      }
      update() {
        this._styleKey = null;
        this.emit("update", this);
      }
      get styleKey() {
        return this._styleKey || this._generateKey();
      }
      clone() {
        return new _TextStyle({
          align: this.align,
          breakWords: this.breakWords,
          dropShadow: this.dropShadow,
          fill: this._fill,
          fontFamily: this.fontFamily,
          fontSize: this.fontSize,
          fontStyle: this.fontStyle,
          fontVariant: this.fontVariant,
          fontWeight: this.fontWeight,
          leading: this.leading,
          letterSpacing: this.letterSpacing,
          lineHeight: this.lineHeight,
          padding: this.padding,
          stroke: this._stroke,
          textBaseline: this.textBaseline,
          whiteSpace: this.whiteSpace,
          wordWrap: this.wordWrap,
          wordWrapWidth: this.wordWrapWidth
        });
      }
      /**
       * Destroys this text style.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style
       * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style
       */
      destroy(options = false) {
        this.removeAllListeners();
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          if (this._fill?.texture) {
            this._fill.texture.destroy(destroyTextureSource);
          }
          if (this._originalFill?.texture) {
            this._originalFill.texture.destroy(destroyTextureSource);
          }
          if (this._stroke?.texture) {
            this._stroke.texture.destroy(destroyTextureSource);
          }
          if (this._originalStroke?.texture) {
            this._originalStroke.texture.destroy(destroyTextureSource);
          }
        }
        this._fill = null;
        this._stroke = null;
        this.dropShadow = null;
        this._originalStroke = null;
        this._originalFill = null;
      }
    };
    TextStyle = _TextStyle;
    TextStyle.defaultTextStyle = {
      /**
       * See {@link TextStyle.align}
       * @type {'left'|'center'|'right'|'justify'}
       */
      align: "left",
      /** See {@link TextStyle.breakWords} */
      breakWords: false,
      /** See {@link TextStyle.dropShadow} */
      dropShadow: {
        alpha: 1,
        angle: Math.PI / 6,
        blur: 0,
        color: "black",
        distance: 5
      },
      /**
       * See {@link TextStyle.fill}
       * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
       */
      fill: "black",
      /**
       * See {@link TextStyle.fontFamily}
       * @type {string|string[]}
       */
      fontFamily: "Arial",
      /**
       * See {@link TextStyle.fontSize}
       * @type {number|string}
       */
      fontSize: 26,
      /**
       * See {@link TextStyle.fontStyle}
       * @type {'normal'|'italic'|'oblique'}
       */
      fontStyle: "normal",
      /**
       * See {@link TextStyle.fontVariant}
       * @type {'normal'|'small-caps'}
       */
      fontVariant: "normal",
      /**
       * See {@link TextStyle.fontWeight}
       * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
       */
      fontWeight: "normal",
      /** See {@link TextStyle.leading} */
      leading: 0,
      /** See {@link TextStyle.letterSpacing} */
      letterSpacing: 0,
      /** See {@link TextStyle.lineHeight} */
      lineHeight: 0,
      /** See {@link TextStyle.padding} */
      padding: 0,
      /**
       * See {@link TextStyle.stroke}
       * @type {string|number}
       */
      stroke: null,
      /**
       * See {@link TextStyle.textBaseline}
       * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
       */
      textBaseline: "alphabetic",
      /** See {@link TextStyle.trim} */
      trim: false,
      /**
       * See {@link TextStyle.whiteSpace}
       * @type {'normal'|'pre'|'pre-line'}
       */
      whiteSpace: "pre",
      /** See {@link TextStyle.wordWrap} */
      wordWrap: false,
      /** See {@link TextStyle.wordWrapWidth} */
      wordWrapWidth: 100
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs
var CanvasPoolClass, CanvasPool;
var init_CanvasPool = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs"() {
    init_pow2();
    init_adapter();
    CanvasPoolClass = class {
      constructor(canvasOptions) {
        this._canvasPool = /* @__PURE__ */ Object.create(null);
        this.canvasOptions = canvasOptions || {};
        this.enableFullScreen = false;
      }
      /**
       * Creates texture with params that were specified in pool constructor.
       * @param pixelWidth - Width of texture in pixels.
       * @param pixelHeight - Height of texture in pixels.
       */
      _createCanvasAndContext(pixelWidth, pixelHeight) {
        const canvas2 = DOMAdapter.get().createCanvas();
        canvas2.width = pixelWidth;
        canvas2.height = pixelHeight;
        const context2 = canvas2.getContext("2d");
        return { canvas: canvas2, context: context2 };
      }
      /**
       * Gets a Power-of-Two render texture or fullScreen texture
       * @param minWidth - The minimum width of the render texture.
       * @param minHeight - The minimum height of the render texture.
       * @param resolution - The resolution of the render texture.
       * @returns The new render texture.
       */
      getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {
        minWidth = Math.ceil(minWidth * resolution - 1e-6);
        minHeight = Math.ceil(minHeight * resolution - 1e-6);
        minWidth = nextPow2(minWidth);
        minHeight = nextPow2(minHeight);
        const key = (minWidth << 17) + (minHeight << 1);
        if (!this._canvasPool[key]) {
          this._canvasPool[key] = [];
        }
        let canvasAndContext = this._canvasPool[key].pop();
        if (!canvasAndContext) {
          canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);
        }
        return canvasAndContext;
      }
      /**
       * Place a render texture back into the pool.
       * @param canvasAndContext
       */
      returnCanvasAndContext(canvasAndContext) {
        const { width, height } = canvasAndContext.canvas;
        const key = (width << 17) + (height << 1);
        this._canvasPool[key].push(canvasAndContext);
      }
      clear() {
        this._canvasPool = {};
      }
    };
    CanvasPool = new CanvasPoolClass();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs
function fontStringFromTextStyle(style) {
  const fontSizeString = typeof style.fontSize === "number" ? `${style.fontSize}px` : style.fontSize;
  let fontFamilies = style.fontFamily;
  if (!Array.isArray(style.fontFamily)) {
    fontFamilies = style.fontFamily.split(",");
  }
  for (let i2 = fontFamilies.length - 1; i2 >= 0; i2--) {
    let fontFamily = fontFamilies[i2].trim();
    if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
      fontFamily = `"${fontFamily}"`;
    }
    fontFamilies[i2] = fontFamily;
  }
  return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
}
var genericFontFamilies;
var init_fontStringFromTextStyle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs"() {
    genericFontFamilies = [
      "serif",
      "sans-serif",
      "monospace",
      "cursive",
      "fantasy",
      "system-ui"
    ];
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs
var contextSettings, _CanvasTextMetrics, CanvasTextMetrics;
var init_CanvasTextMetrics = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs"() {
    init_adapter();
    init_fontStringFromTextStyle();
    contextSettings = {
      // TextMetrics requires getImageData readback for measuring fonts.
      willReadFrequently: true
    };
    _CanvasTextMetrics = class {
      /**
       * Checking that we can use modern canvas 2D API.
       *
       * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.
       * @see TextMetrics.experimentalLetterSpacing
       * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing
       * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441
       */
      static get experimentalLetterSpacingSupported() {
        let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;
        if (result !== void 0) {
          const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;
          result = _CanvasTextMetrics._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
        }
        return result;
      }
      /**
       * @param text - the text that was measured
       * @param style - the style that was measured
       * @param width - the measured width of the text
       * @param height - the measured height of the text
       * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style
       * @param lineWidths - an array of the line widths for each line matched to `lines`
       * @param lineHeight - the measured line height for this style
       * @param maxLineWidth - the maximum line width for all measured lines
       * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont
       */
      constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
        this.text = text;
        this.style = style;
        this.width = width;
        this.height = height;
        this.lines = lines;
        this.lineWidths = lineWidths;
        this.lineHeight = lineHeight;
        this.maxLineWidth = maxLineWidth;
        this.fontProperties = fontProperties;
      }
      /**
       * Measures the supplied string of text and returns a Rectangle.
       * @param text - The text to measure.
       * @param style - The text style to use for measuring
       * @param canvas - optional specification of the canvas to use for measuring.
       * @param wordWrap
       * @returns Measured width and height of the text.
       */
      static measureText(text = " ", style, canvas2 = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {
        const textKey = `${text}:${style.styleKey}`;
        if (_CanvasTextMetrics._measurementCache[textKey])
          return _CanvasTextMetrics._measurementCache[textKey];
        const font = fontStringFromTextStyle(style);
        const fontProperties = _CanvasTextMetrics.measureFont(font);
        if (fontProperties.fontSize === 0) {
          fontProperties.fontSize = style.fontSize;
          fontProperties.ascent = style.fontSize;
        }
        const context2 = _CanvasTextMetrics.__context;
        context2.font = font;
        const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas2) : text;
        const lines = outputText.split(/(?:\r\n|\r|\n)/);
        const lineWidths = new Array(lines.length);
        let maxLineWidth = 0;
        for (let i2 = 0; i2 < lines.length; i2++) {
          const lineWidth = _CanvasTextMetrics._measureText(lines[i2], style.letterSpacing, context2);
          lineWidths[i2] = lineWidth;
          maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        const strokeWidth = style._stroke?.width || 0;
        let width = maxLineWidth + strokeWidth;
        if (style.dropShadow) {
          width += style.dropShadow.distance;
        }
        const lineHeight = style.lineHeight || fontProperties.fontSize + strokeWidth;
        let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth * 2) + (lines.length - 1) * (lineHeight + style.leading);
        if (style.dropShadow) {
          height += style.dropShadow.distance;
        }
        const measurements = new _CanvasTextMetrics(
          text,
          style,
          width,
          height,
          lines,
          lineWidths,
          lineHeight + style.leading,
          maxLineWidth,
          fontProperties
        );
        return measurements;
      }
      static _measureText(text, letterSpacing, context2) {
        let useExperimentalLetterSpacing = false;
        if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {
          if (_CanvasTextMetrics.experimentalLetterSpacing) {
            context2.letterSpacing = `${letterSpacing}px`;
            context2.textLetterSpacing = `${letterSpacing}px`;
            useExperimentalLetterSpacing = true;
          } else {
            context2.letterSpacing = "0px";
            context2.textLetterSpacing = "0px";
          }
        }
        let width = context2.measureText(text).width;
        if (width > 0) {
          if (useExperimentalLetterSpacing) {
            width -= letterSpacing;
          } else {
            width += (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;
          }
        }
        return width;
      }
      /**
       * Applies newlines to a string to have it optimally fit into the horizontal
       * bounds set by the Text object's wordWrapWidth property.
       * @param text - String to apply word wrapping to
       * @param style - the style to use when wrapping
       * @param canvas - optional specification of the canvas to use for measuring.
       * @returns New string with new lines applied where required
       */
      static _wordWrap(text, style, canvas2 = _CanvasTextMetrics._canvas) {
        const context2 = canvas2.getContext("2d", contextSettings);
        let width = 0;
        let line = "";
        let lines = "";
        const cache = /* @__PURE__ */ Object.create(null);
        const { letterSpacing, whiteSpace } = style;
        const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);
        const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);
        let canPrependSpaces = !collapseSpaces;
        const wordWrapWidth = style.wordWrapWidth + letterSpacing;
        const tokens = _CanvasTextMetrics._tokenize(text);
        for (let i2 = 0; i2 < tokens.length; i2++) {
          let token = tokens[i2];
          if (_CanvasTextMetrics._isNewline(token)) {
            if (!collapseNewlines) {
              lines += _CanvasTextMetrics._addLine(line);
              canPrependSpaces = !collapseSpaces;
              line = "";
              width = 0;
              continue;
            }
            token = " ";
          }
          if (collapseSpaces) {
            const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);
            const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);
            if (currIsBreakingSpace && lastIsBreakingSpace) {
              continue;
            }
          }
          const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context2);
          if (tokenWidth > wordWrapWidth) {
            if (line !== "") {
              lines += _CanvasTextMetrics._addLine(line);
              line = "";
              width = 0;
            }
            if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {
              const characters = _CanvasTextMetrics.wordWrapSplit(token);
              for (let j3 = 0; j3 < characters.length; j3++) {
                let char = characters[j3];
                let lastChar = char;
                let k3 = 1;
                while (characters[j3 + k3]) {
                  const nextChar = characters[j3 + k3];
                  if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j3, style.breakWords)) {
                    char += nextChar;
                  } else {
                    break;
                  }
                  lastChar = nextChar;
                  k3++;
                }
                j3 += k3 - 1;
                const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context2);
                if (characterWidth + width > wordWrapWidth) {
                  lines += _CanvasTextMetrics._addLine(line);
                  canPrependSpaces = false;
                  line = "";
                  width = 0;
                }
                line += char;
                width += characterWidth;
              }
            } else {
              if (line.length > 0) {
                lines += _CanvasTextMetrics._addLine(line);
                line = "";
                width = 0;
              }
              const isLastToken = i2 === tokens.length - 1;
              lines += _CanvasTextMetrics._addLine(token, !isLastToken);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
          } else {
            if (tokenWidth + width > wordWrapWidth) {
              canPrependSpaces = false;
              lines += _CanvasTextMetrics._addLine(line);
              line = "";
              width = 0;
            }
            if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {
              line += token;
              width += tokenWidth;
            }
          }
        }
        lines += _CanvasTextMetrics._addLine(line, false);
        return lines;
      }
      /**
       * Convienience function for logging each line added during the wordWrap method.
       * @param line    - The line of text to add
       * @param newLine - Add new line character to end
       * @returns A formatted line
       */
      static _addLine(line, newLine = true) {
        line = _CanvasTextMetrics._trimRight(line);
        line = newLine ? `${line}
` : line;
        return line;
      }
      /**
       * Gets & sets the widths of calculated characters in a cache object
       * @param key            - The key
       * @param letterSpacing  - The letter spacing
       * @param cache          - The cache
       * @param context        - The canvas context
       * @returns The from cache.
       */
      static _getFromCache(key, letterSpacing, cache, context2) {
        let width = cache[key];
        if (typeof width !== "number") {
          width = _CanvasTextMetrics._measureText(key, letterSpacing, context2) + letterSpacing;
          cache[key] = width;
        }
        return width;
      }
      /**
       * Determines whether we should collapse breaking spaces.
       * @param whiteSpace - The TextStyle property whiteSpace
       * @returns Should collapse
       */
      static _collapseSpaces(whiteSpace) {
        return whiteSpace === "normal" || whiteSpace === "pre-line";
      }
      /**
       * Determines whether we should collapse newLine chars.
       * @param whiteSpace - The white space
       * @returns should collapse
       */
      static _collapseNewlines(whiteSpace) {
        return whiteSpace === "normal";
      }
      /**
       * Trims breaking whitespaces from string.
       * @param text - The text
       * @returns Trimmed string
       */
      static _trimRight(text) {
        if (typeof text !== "string") {
          return "";
        }
        for (let i2 = text.length - 1; i2 >= 0; i2--) {
          const char = text[i2];
          if (!_CanvasTextMetrics.isBreakingSpace(char)) {
            break;
          }
          text = text.slice(0, -1);
        }
        return text;
      }
      /**
       * Determines if char is a newline.
       * @param char - The character
       * @returns True if newline, False otherwise.
       */
      static _isNewline(char) {
        if (typeof char !== "string") {
          return false;
        }
        return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));
      }
      /**
       * Determines if char is a breaking whitespace.
       *
       * It allows one to determine whether char should be a breaking whitespace
       * For example certain characters in CJK langs or numbers.
       * It must return a boolean.
       * @param char - The character
       * @param [_nextChar] - The next character
       * @returns True if whitespace, False otherwise.
       */
      static isBreakingSpace(char, _nextChar) {
        if (typeof char !== "string") {
          return false;
        }
        return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));
      }
      /**
       * Splits a string into words, breaking-spaces and newLine characters
       * @param text - The text
       * @returns A tokenized array
       */
      static _tokenize(text) {
        const tokens = [];
        let token = "";
        if (typeof text !== "string") {
          return tokens;
        }
        for (let i2 = 0; i2 < text.length; i2++) {
          const char = text[i2];
          const nextChar = text[i2 + 1];
          if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {
            if (token !== "") {
              tokens.push(token);
              token = "";
            }
            tokens.push(char);
            continue;
          }
          token += char;
        }
        if (token !== "") {
          tokens.push(token);
        }
        return tokens;
      }
      /**
       * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
       *
       * It allows one to customise which words should break
       * Examples are if the token is CJK or numbers.
       * It must return a boolean.
       * @param _token - The token
       * @param breakWords - The style attr break words
       * @returns Whether to break word or not
       */
      static canBreakWords(_token, breakWords) {
        return breakWords;
      }
      /**
       * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
       *
       * It allows one to determine whether a pair of characters
       * should be broken by newlines
       * For example certain characters in CJK langs or numbers.
       * It must return a boolean.
       * @param _char - The character
       * @param _nextChar - The next character
       * @param _token - The token/word the characters are from
       * @param _index - The index in the token of the char
       * @param _breakWords - The style attr break words
       * @returns whether to break word or not
       */
      static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
        return true;
      }
      /**
       * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
       *
       * It is called when a token (usually a word) has to be split into separate pieces
       * in order to determine the point to break a word.
       * It must return an array of characters.
       * @param token - The token to split
       * @returns The characters of the token
       * @see CanvasTextMetrics.graphemeSegmenter
       */
      static wordWrapSplit(token) {
        return _CanvasTextMetrics.graphemeSegmenter(token);
      }
      /**
       * Calculates the ascent, descent and fontSize of a given font-style
       * @param font - String representing the style of the font
       * @returns Font properties object
       */
      static measureFont(font) {
        if (_CanvasTextMetrics._fonts[font]) {
          return _CanvasTextMetrics._fonts[font];
        }
        const context2 = _CanvasTextMetrics._context;
        context2.font = font;
        const metrics = context2.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);
        const properties = {
          ascent: metrics.actualBoundingBoxAscent,
          descent: metrics.actualBoundingBoxDescent,
          fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
        };
        _CanvasTextMetrics._fonts[font] = properties;
        return properties;
      }
      /**
       * Clear font metrics in metrics cache.
       * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
       */
      static clearMetrics(font = "") {
        if (font) {
          delete _CanvasTextMetrics._fonts[font];
        } else {
          _CanvasTextMetrics._fonts = {};
        }
      }
      /**
       * Cached canvas element for measuring text
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      static get _canvas() {
        if (!_CanvasTextMetrics.__canvas) {
          let canvas2;
          try {
            const c2 = new OffscreenCanvas(0, 0);
            const context2 = c2.getContext("2d", contextSettings);
            if (context2?.measureText) {
              _CanvasTextMetrics.__canvas = c2;
              return c2;
            }
            canvas2 = DOMAdapter.get().createCanvas();
          } catch (ex) {
            canvas2 = DOMAdapter.get().createCanvas();
          }
          canvas2.width = canvas2.height = 10;
          _CanvasTextMetrics.__canvas = canvas2;
        }
        return _CanvasTextMetrics.__canvas;
      }
      /**
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      static get _context() {
        if (!_CanvasTextMetrics.__context) {
          _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext("2d", contextSettings);
        }
        return _CanvasTextMetrics.__context;
      }
    };
    CanvasTextMetrics = _CanvasTextMetrics;
    CanvasTextMetrics.METRICS_STRING = "|\xC9q\xC5";
    CanvasTextMetrics.BASELINE_SYMBOL = "M";
    CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;
    CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;
    CanvasTextMetrics.graphemeSegmenter = (() => {
      if (typeof Intl?.Segmenter === "function") {
        const segmenter = new Intl.Segmenter();
        return (s2) => [...segmenter.segment(s2)].map((x3) => x3.segment);
      }
      return (s2) => [...s2];
    })();
    CanvasTextMetrics.experimentalLetterSpacing = false;
    CanvasTextMetrics._fonts = {};
    CanvasTextMetrics._newlines = [
      10,
      // line feed
      13
      // carriage return
    ];
    CanvasTextMetrics._breakingSpaces = [
      9,
      // character tabulation
      32,
      // space
      8192,
      // en quad
      8193,
      // em quad
      8194,
      // en space
      8195,
      // em space
      8196,
      // three-per-em space
      8197,
      // four-per-em space
      8198,
      // six-per-em space
      8200,
      // punctuation space
      8201,
      // thin space
      8202,
      // hair space
      8287,
      // medium mathematical space
      12288
      // ideographic space
    ];
    CanvasTextMetrics._measurementCache = {};
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs
function getCanvasFillStyle(fillStyle, context2) {
  if (fillStyle.texture === Texture.WHITE && !fillStyle.fill) {
    return Color.shared.setValue(fillStyle.color).toHex();
  } else if (!fillStyle.fill) {
    const pattern = context2.createPattern(fillStyle.texture.source.resource, "repeat");
    const tempMatrix4 = fillStyle.matrix.copyTo(Matrix.shared);
    tempMatrix4.scale(fillStyle.texture.frameWidth, fillStyle.texture.frameHeight);
    pattern.setTransform(tempMatrix4);
    return pattern;
  } else if (fillStyle.fill instanceof FillPattern) {
    const fillPattern = fillStyle.fill;
    const pattern = context2.createPattern(fillPattern.texture.source.resource, "repeat");
    const tempMatrix4 = fillPattern.transform.copyTo(Matrix.shared);
    tempMatrix4.scale(fillPattern.texture.frameWidth, fillPattern.texture.frameHeight);
    pattern.setTransform(tempMatrix4);
    return pattern;
  } else if (fillStyle.fill instanceof FillGradient) {
    const fillGradient = fillStyle.fill;
    if (fillGradient.type === "linear") {
      const gradient = context2.createLinearGradient(
        fillGradient.x0,
        fillGradient.y0,
        fillGradient.x1,
        fillGradient.y1
      );
      fillGradient.gradientStops.forEach((stop) => {
        gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());
      });
      return gradient;
    }
  }
  warn("FillStyle not recognised", fillStyle);
  return "red";
}
var init_getCanvasFillStyle = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs"() {
    init_Color();
    init_Matrix();
    init_Texture();
    init_warn();
    init_FillGradient();
    init_FillPattern();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/utils/resolveCharacters.mjs
function resolveCharacters(chars) {
  if (chars === "") {
    return [];
  }
  if (typeof chars === "string") {
    chars = [chars];
  }
  const result = [];
  for (let i2 = 0, j3 = chars.length; i2 < j3; i2++) {
    const item = chars[i2];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
      }
      if (item[0].length === 0 || item[1].length === 0) {
        throw new Error("[BitmapFont]: Invalid character delimiter.");
      }
      const startCode = item[0].charCodeAt(0);
      const endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (let i22 = startCode, j22 = endCode; i22 <= j22; i22++) {
        result.push(String.fromCharCode(i22));
      }
    } else {
      result.push(...Array.from(item));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
}
var init_resolveCharacters = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/utils/resolveCharacters.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/DynamicBitmapFont.mjs
var DynamicBitmapFont;
var init_DynamicBitmapFont = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/DynamicBitmapFont.mjs"() {
    init_Color();
    init_Rectangle();
    init_CanvasPool();
    init_ImageSource();
    init_Texture();
    init_deprecation();
    init_CanvasTextMetrics();
    init_fontStringFromTextStyle();
    init_getCanvasFillStyle();
    init_AbstractBitmapFont();
    init_resolveCharacters();
    DynamicBitmapFont = class extends AbstractBitmapFont {
      constructor(options) {
        super();
        this.resolution = 1;
        this.pages = [];
        this._padding = 4;
        this._measureCache = /* @__PURE__ */ Object.create(null);
        this._currentChars = [];
        this._currentX = 0;
        this._currentY = 0;
        this._currentPageIndex = -1;
        this._skipKerning = false;
        const dynamicOptions = options;
        const style = dynamicOptions.style.clone();
        style.fontSize = this.baseMeasurementFontSize;
        if (dynamicOptions.overrideFill) {
          style._fill.color = 16777215;
          style._fill.alpha = 1;
          style._fill.texture = Texture.WHITE;
          style._fill.fill = null;
        }
        this._style = style;
        this._skipKerning = dynamicOptions.skipKerning ?? false;
        this.resolution = dynamicOptions.resolution ?? 1;
        this._padding = dynamicOptions.padding ?? 4;
        const font = fontStringFromTextStyle(style);
        const writable = this;
        writable.fontMetrics = CanvasTextMetrics.measureFont(font);
        writable.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;
      }
      ensureCharacters(chars) {
        const charList = resolveCharacters(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self2) => self2.indexOf(char) === index);
        if (!charList.length)
          return;
        this._currentChars = [...this._currentChars, ...charList];
        let pageData;
        if (this._currentPageIndex === -1) {
          pageData = this._nextPage();
        } else {
          pageData = this.pages[this._currentPageIndex];
        }
        let { canvas: canvas2, context: context2 } = pageData.canvasAndContext;
        let textureSource = pageData.texture.source;
        const style = this._style;
        let currentX = this._currentX;
        let currentY = this._currentY;
        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;
        const padding = this._padding * fontScale;
        const widthScale = style.fontStyle === "italic" ? 2 : 1;
        let maxCharHeight = 0;
        let skipTexture = false;
        for (let i2 = 0; i2 < charList.length; i2++) {
          const char = charList[i2];
          const metrics = CanvasTextMetrics.measureText(char, style, canvas2, false);
          const width = widthScale * metrics.width * fontScale;
          const height = metrics.height * fontScale;
          const paddedWidth = width + padding * 2;
          const paddedHeight = height + padding * 2;
          skipTexture = false;
          if (char !== "\n" && char !== "\r" && char !== "	" && char !== " ") {
            skipTexture = true;
            maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));
          }
          if (currentX + paddedWidth > 512) {
            currentY += maxCharHeight;
            maxCharHeight = paddedHeight;
            currentX = 0;
            if (currentY + maxCharHeight > 512) {
              textureSource.update();
              const pageData2 = this._nextPage();
              canvas2 = pageData2.canvasAndContext.canvas;
              context2 = pageData2.canvasAndContext.context;
              textureSource = pageData2.texture.source;
              currentY = 0;
            }
          }
          const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);
          this.chars[char] = {
            id: char.codePointAt(0),
            xOffset: -this._padding,
            yOffset: -this._padding,
            xAdvance,
            kerning: {}
          };
          if (skipTexture) {
            this._drawGlyph(
              context2,
              metrics,
              currentX + padding,
              currentY + padding,
              fontScale,
              style
            );
            const px = textureSource.width * fontScale;
            const py = textureSource.height * fontScale;
            const frame = new Rectangle(
              currentX / px,
              currentY / py,
              paddedWidth / px,
              paddedHeight / py
            );
            this.chars[char].texture = new Texture({
              source: textureSource,
              layout: {
                frame
              }
            });
            currentX += Math.ceil(paddedWidth);
          }
        }
        textureSource.update();
        this._currentX = currentX;
        this._currentY = currentY;
        this._skipKerning && this._applyKerning(charList, context2);
      }
      /**
       * @deprecated since 8.0.0
       * The map of base page textures (i.e., sheets of glyphs).
       */
      get pageTextures() {
        deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
        return this.pages;
      }
      _applyKerning(newChars, context2) {
        const measureCache = this._measureCache;
        for (let i2 = 0; i2 < newChars.length; i2++) {
          const first = newChars[i2];
          for (let j3 = 0; j3 < this._currentChars.length; j3++) {
            const second = this._currentChars[j3];
            let c1 = measureCache[first];
            if (!c1)
              c1 = measureCache[first] = context2.measureText(first).width;
            let c2 = measureCache[second];
            if (!c2)
              c2 = measureCache[second] = context2.measureText(second).width;
            let total = context2.measureText(first + second).width;
            let amount = total - (c1 + c2);
            if (amount) {
              this.chars[first].kerning[second] = amount;
            }
            total = context2.measureText(first + second).width;
            amount = total - (c1 + c2);
            if (amount) {
              this.chars[second].kerning[first] = amount;
            }
          }
        }
      }
      _nextPage() {
        this._currentPageIndex++;
        const textureResolution = this.resolution;
        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(512, 512, textureResolution);
        this._setupContext(canvasAndContext.context, this._style, textureResolution);
        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);
        const texture = new Texture({
          source: new ImageSource({
            resource: canvasAndContext.canvas,
            resolution,
            alphaMode: "premultiply-alpha-on-upload"
          })
        });
        const pageData = {
          canvasAndContext,
          texture
        };
        this.pages[this._currentPageIndex] = pageData;
        return pageData;
      }
      // canvas style!
      _setupContext(context2, style, resolution) {
        style.fontSize = this.baseRenderedFontSize;
        context2.scale(resolution, resolution);
        context2.font = fontStringFromTextStyle(style);
        style.fontSize = this.baseMeasurementFontSize;
        context2.textBaseline = style.textBaseline;
        const stroke = style._stroke;
        const strokeThickness = stroke?.width ?? 0;
        if (stroke) {
          context2.lineWidth = strokeThickness;
          context2.lineJoin = stroke.join;
          context2.miterLimit = stroke.miterLimit;
          context2.strokeStyle = getCanvasFillStyle(stroke, context2);
        }
        if (style._fill) {
          context2.fillStyle = getCanvasFillStyle(style._fill, context2);
        }
        if (style.dropShadow) {
          const shadowOptions = style.dropShadow;
          const rgb = Color.shared.setValue(shadowOptions.color).toArray();
          const dropShadowBlur = shadowOptions.blur * resolution;
          const dropShadowDistance = shadowOptions.distance * resolution;
          context2.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;
          context2.shadowBlur = dropShadowBlur;
          context2.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
          context2.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;
        } else {
          context2.shadowColor = "black";
          context2.shadowBlur = 0;
          context2.shadowOffsetX = 0;
          context2.shadowOffsetY = 0;
        }
      }
      _drawGlyph(context2, metrics, x3, y2, fontScale, style) {
        const char = metrics.text;
        const fontProperties = metrics.fontProperties;
        const stroke = style._stroke;
        const strokeThickness = (stroke?.width ?? 0) * fontScale;
        const tx = x3 + strokeThickness / 2;
        const ty = y2 - strokeThickness / 2;
        const descent = fontProperties.descent * fontScale;
        const lineHeight = metrics.lineHeight * fontScale;
        if (style.stroke && strokeThickness) {
          context2.strokeText(char, tx, ty + lineHeight - descent);
        }
        if (style._fill) {
          context2.fillText(char, tx, ty + lineHeight - descent);
        }
      }
      destroy() {
        super.destroy();
        for (let i2 = 0; i2 < this.pages.length; i2++) {
          const { canvasAndContext, texture } = this.pages[i2];
          CanvasPool.returnCanvasAndContext(canvasAndContext);
          texture.destroy(true);
        }
        this.pages = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/utils/getBitmapTextLayout.mjs
function getBitmapTextLayout(chars, style, font) {
  const layoutData = {
    width: 0,
    height: 0,
    offsetY: 0,
    scale: style.fontSize / font.baseMeasurementFontSize,
    lines: [{
      width: 0,
      charPositions: [],
      spaceWidth: 0,
      spacesIndex: [],
      chars: []
    }]
  };
  layoutData.offsetY = font.baseLineOffset;
  let currentLine = layoutData.lines[0];
  let previousChar = null;
  let firstWord = true;
  const currentWord = {
    spaceWord: false,
    width: 0,
    start: 0,
    index: 0,
    // use index to not modify the array as we use it a lot!
    positions: [],
    chars: []
  };
  const nextWord = (word) => {
    const start = currentLine.width;
    for (let j3 = 0; j3 < currentWord.index; j3++) {
      const position = word.positions[j3];
      currentLine.chars.push(word.chars[j3]);
      currentLine.charPositions.push(position + start);
    }
    currentLine.width += word.width;
    firstWord = false;
    currentWord.width = 0;
    currentWord.index = 0;
    currentWord.chars.length = 0;
  };
  const nextLine = () => {
    let index = currentLine.chars.length - 1;
    let lastChar = currentLine.chars[index];
    while (lastChar === " ") {
      currentLine.width -= font.chars[lastChar].xAdvance;
      lastChar = currentLine.chars[--index];
    }
    layoutData.width = Math.max(layoutData.width, currentLine.width);
    currentLine = {
      width: 0,
      charPositions: [],
      chars: [],
      spaceWidth: 0,
      spacesIndex: []
    };
    firstWord = true;
    layoutData.lines.push(currentLine);
    layoutData.height += font.lineHeight;
  };
  const scale3 = font.baseMeasurementFontSize / style.fontSize;
  const adjustedLetterSpacing = style.letterSpacing * scale3;
  const adjustedWordWrapWidth = style.wordWrapWidth * scale3;
  for (let i2 = 0; i2 < chars.length + 1; i2++) {
    let char;
    const isEnd = i2 === chars.length;
    if (!isEnd) {
      char = chars[i2];
    }
    const charData = font.chars[char];
    const isSpace = /(?:\s)/.test(char);
    const isWordBreak = isSpace || char === "\r" || char === "\n" || isEnd;
    if (isWordBreak) {
      const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;
      if (addWordToNextLine) {
        nextLine();
        nextWord(currentWord);
        if (!isEnd) {
          currentLine.charPositions.push(0);
        }
      } else {
        currentWord.start = currentLine.width;
        nextWord(currentWord);
        if (!isEnd) {
          currentLine.charPositions.push(0);
        }
      }
      if (char === "\r" || char === "\n") {
        if (currentLine.width !== 0) {
          nextLine();
        }
      } else if (!isEnd) {
        const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;
        currentLine.width += spaceWidth;
        currentLine.spaceWidth = spaceWidth;
        currentLine.spacesIndex.push(currentLine.charPositions.length);
        currentLine.chars.push(char);
      }
    } else {
      const kerning = charData.kerning[previousChar] || 0;
      const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;
      currentWord.positions[currentWord.index++] = currentWord.width + kerning;
      currentWord.chars.push(char);
      currentWord.width += nextCharWidth;
    }
    previousChar = char;
  }
  nextLine();
  if (style.align === "center") {
    alignCenter(layoutData);
  } else if (style.align === "right") {
    alignRight(layoutData);
  } else if (style.align === "justify") {
    alignJustify(layoutData);
  }
  return layoutData;
}
function alignCenter(measurementData) {
  for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
    const line = measurementData.lines[i2];
    const offset = measurementData.width / 2 - line.width / 2;
    for (let j3 = 0; j3 < line.charPositions.length; j3++) {
      line.charPositions[j3] += offset;
    }
  }
}
function alignRight(measurementData) {
  for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
    const line = measurementData.lines[i2];
    const offset = measurementData.width - line.width;
    for (let j3 = 0; j3 < line.charPositions.length; j3++) {
      line.charPositions[j3] += offset;
    }
  }
}
function alignJustify(measurementData) {
  const width = measurementData.width;
  for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
    const line = measurementData.lines[i2];
    let indy = 0;
    let spaceIndex = line.spacesIndex[indy++];
    let offset = 0;
    const totalSpaces = line.spacesIndex.length;
    const newSpaceWidth = (width - line.width) / totalSpaces;
    const spaceWidth = newSpaceWidth;
    for (let j3 = 0; j3 < line.charPositions.length; j3++) {
      if (j3 === spaceIndex) {
        spaceIndex = line.spacesIndex[indy++];
        offset += spaceWidth;
      }
      line.charPositions[j3] += offset;
    }
  }
}
var init_getBitmapTextLayout = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/utils/getBitmapTextLayout.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/BitmapFontManager.mjs
var BitmapFontManagerClass, BitmapFontManager;
var init_BitmapFontManager = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/BitmapFontManager.mjs"() {
    init_Cache();
    init_TextStyle();
    init_DynamicBitmapFont();
    init_getBitmapTextLayout();
    init_resolveCharacters();
    BitmapFontManagerClass = class {
      constructor() {
        this.ALPHA = [["a", "z"], ["A", "Z"], " "];
        this.NUMERIC = [["0", "9"]];
        this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
        this.ASCII = [[" ", "~"]];
        this.defaultOptions = {
          chars: this.ALPHANUMERIC,
          resolution: 1,
          padding: 4,
          skipKerning: false
        };
      }
      getFont(text, style) {
        let fontFamilyKey = style.fontFamily;
        let overrideFill = true;
        if (style._fill.fill) {
          fontFamilyKey += style._fill.fill.uid;
          overrideFill = false;
        }
        if (!Cache.has(fontFamilyKey)) {
          Cache.set(
            fontFamilyKey,
            new DynamicBitmapFont({
              style,
              overrideFill,
              ...this.defaultOptions
            })
          );
        }
        const dynamicFont = Cache.get(fontFamilyKey);
        dynamicFont.ensureCharacters?.(text);
        return dynamicFont;
      }
      getLayout(text, style) {
        const bitmapFont = this.getFont(text, style);
        return getBitmapTextLayout(text.split(""), style, bitmapFont);
      }
      measureText(text, style) {
        return this.getLayout(text, style);
      }
      /**
       * Generates a bitmap-font for the given style and character set
       * @param name - The name of the custom font to use with BitmapText.
       * @param textStyle - Style options to render with BitmapFont.
       * @param options - Setup options for font or name of the font.
       * @returns Font generated by style options.
       * @example
       * import { BitmapFontManager, BitmapText } from 'pixi.js';
       *
       * BitmapFontManager.install('TitleFont', {
       *     fontFamily: 'Arial',
       *     fontSize: 12,
       *     strokeThickness: 2,
       *     fill: 'purple',
       * });
       *
       * const title = new Text({ text: 'This is the title', fontFamily: 'TitleFont', renderMode: 'bitmap' });
       */
      install(name, textStyle, options) {
        if (!name) {
          throw new Error("[BitmapFontManager] Property `name` is required.");
        }
        options = { ...this.defaultOptions, ...options };
        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
        const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;
        const font = new DynamicBitmapFont({
          style,
          overrideFill,
          skipKerning: options.skipKerning,
          padding: options.padding,
          resolution: options.resolution
        });
        const flatChars = resolveCharacters(options.chars);
        font.ensureCharacters(flatChars.join(""));
        Cache.set(name, font);
        return font;
      }
    };
    BitmapFontManager = new BitmapFontManagerClass();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/BitmapTextPipe.mjs
var GraphicsProxyRenderable, BitmapTextPipe;
var init_BitmapTextPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/bitmap/BitmapTextPipe.mjs"() {
    init_Cache();
    init_Extensions();
    init_ProxyRenderable();
    init_PoolGroup();
    init_GraphicsView();
    init_SdfShader();
    init_BitmapFontManager();
    init_getBitmapTextLayout();
    GraphicsProxyRenderable = class extends ProxyRenderable {
      constructor() {
        super({
          view: new GraphicsView()
        });
      }
    };
    BitmapTextPipe = class {
      constructor(renderer) {
        this._gpuBitmapText = {};
        this._renderer = renderer;
      }
      validateRenderable(renderable) {
        const graphicsRenderable = this._getGpuBitmapText(renderable);
        if (renderable.view._didUpdate) {
          renderable.view._didUpdate = false;
          this._updateContext(renderable, graphicsRenderable.view.context);
        }
        const rebuild = this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);
        return rebuild;
      }
      addRenderable(renderable, instructionSet) {
        const graphicsRenderable = this._getGpuBitmapText(renderable);
        if (renderable.view._didUpdate) {
          renderable.view._didUpdate = false;
          this._updateContext(renderable, graphicsRenderable.view.context);
        }
        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);
        if (graphicsRenderable.view.context.customShader) {
          this._updateDistanceField(renderable);
        }
      }
      destroyRenderable(renderable) {
        this._destroyRenderableByUid(renderable.uid);
      }
      _destroyRenderableByUid(renderableUid) {
        BigPool.return(this._gpuBitmapText[renderableUid]);
        this._gpuBitmapText[renderableUid] = null;
      }
      updateRenderable(renderable) {
        const graphicsRenderable = this._getGpuBitmapText(renderable);
        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);
        if (graphicsRenderable.view.context.customShader) {
          this._updateDistanceField(renderable);
        }
      }
      _updateContext(renderable, context2) {
        const view = renderable.view;
        const bitmapFont = BitmapFontManager.getFont(view.text, view._style);
        context2.clear();
        if (bitmapFont.distanceField.type !== "none") {
          if (!context2.customShader) {
            if (!this._sdfShader) {
              this._sdfShader = new SdfShader();
            }
            context2.customShader = this._sdfShader;
          }
        }
        const chars = Array.from(view.text);
        const style = view._style;
        let currentY = (style._stroke?.width || 0) / 2;
        currentY += bitmapFont.baseLineOffset;
        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont);
        let index = 0;
        const padding = style.padding;
        const scale3 = bitmapTextLayout.scale;
        context2.translate(
          -view.anchor._x * bitmapTextLayout.width - padding,
          -view.anchor._y * (bitmapTextLayout.height + bitmapTextLayout.offsetY) - padding
        ).scale(scale3, scale3);
        const tint = style._fill.color;
        for (let i2 = 0; i2 < bitmapTextLayout.lines.length; i2++) {
          const line = bitmapTextLayout.lines[i2];
          for (let j3 = 0; j3 < line.charPositions.length; j3++) {
            const char = chars[index++];
            const charData = bitmapFont.chars[char];
            if (charData?.texture) {
              context2.texture(
                charData.texture,
                tint,
                Math.round(line.charPositions[j3] + charData.xOffset),
                Math.round(currentY + charData.yOffset)
              );
            }
          }
          currentY += bitmapFont.lineHeight;
        }
      }
      _getGpuBitmapText(renderable) {
        return this._gpuBitmapText[renderable.uid] || this._initGpuText(renderable);
      }
      _initGpuText(renderable) {
        renderable.view._style.update();
        const proxyRenderable = BigPool.get(GraphicsProxyRenderable, renderable);
        this._gpuBitmapText[renderable.uid] = proxyRenderable;
        proxyRenderable.view.roundPixels = this._renderer._roundPixels | renderable.view.roundPixels;
        this._updateContext(renderable, proxyRenderable.view.context);
        renderable.on("destroyed", () => {
          this.destroyRenderable(renderable);
        });
        return this._gpuBitmapText[renderable.uid];
      }
      _updateDistanceField(renderable) {
        const context2 = this._getGpuBitmapText(renderable).view.context;
        const view = renderable.view;
        const fontFamily = view._style.fontFamily;
        const dynamicFont = Cache.get(fontFamily);
        const { a: a2, b: b2, c: c2, d: d3 } = renderable.layerTransform;
        const dx = Math.sqrt(a2 * a2 + b2 * b2);
        const dy = Math.sqrt(c2 * c2 + d3 * d3);
        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
        const fontScale = dynamicFont.baseRenderedFontSize / view._style.fontSize;
        const resolution = view.resolution ?? this._renderer.resolution;
        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale) * resolution;
        context2.customShader.resources.localUniforms.uniforms.uDistance = distance;
      }
      destroy() {
        for (const uid2 in this._gpuBitmapText) {
          this._destroyRenderableByUid(uid2);
        }
        this._gpuBitmapText = null;
        this._sdfShader?.destroy(true);
        this._sdfShader = null;
        this._renderer = null;
      }
    };
    BitmapTextPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "bitmapText"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs
var CanvasTextPipe;
var init_CanvasTextPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs"() {
    init_Extensions();
    init_PoolGroup();
    init_updateQuadBounds();
    init_BatchableSprite();
    CanvasTextPipe = class {
      constructor(renderer) {
        this._gpuText = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      validateRenderable(renderable) {
        const gpuText = this._getGpuText(renderable);
        const newKey = renderable.view._getKey();
        if (gpuText.currentKey !== newKey) {
          const view = renderable.view;
          const resolution = view.resolution ?? this._renderer.resolution;
          const { width, height } = this._renderer.canvasText.getTextureSize(
            view.text,
            resolution,
            view._style
          );
          if (
            // is only being used by this text:
            this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1 && width === gpuText.texture._source.width && height === gpuText.texture._source.height
          ) {
            return false;
          }
          return true;
        }
        return false;
      }
      addRenderable(renderable, _instructionSet) {
        const gpuText = this._getGpuText(renderable);
        const batchableSprite = gpuText.batchableSprite;
        if (renderable.view._didUpdate) {
          this._updateText(renderable);
        }
        this._renderer.renderPipes.batch.addToBatch(batchableSprite);
      }
      updateRenderable(renderable) {
        const gpuText = this._getGpuText(renderable);
        const batchableSprite = gpuText.batchableSprite;
        if (renderable.view._didUpdate) {
          this._updateText(renderable);
        }
        batchableSprite.batcher.updateElement(batchableSprite);
      }
      destroyRenderable(renderable) {
        this._destroyRenderableById(renderable.uid);
      }
      _destroyRenderableById(renderableUid) {
        const gpuText = this._gpuText[renderableUid];
        this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
        BigPool.return(gpuText.batchableSprite);
        this._gpuText[renderableUid] = null;
      }
      _updateText(renderable) {
        const newKey = renderable.view._getKey();
        const gpuText = this._getGpuText(renderable);
        const batchableSprite = gpuText.batchableSprite;
        if (gpuText.currentKey !== newKey) {
          this._updateGpuText(renderable);
        }
        renderable.view._didUpdate = false;
        const padding = renderable.view._style.padding;
        updateQuadBounds(batchableSprite.bounds, renderable.view.anchor, batchableSprite.texture, padding);
      }
      _updateGpuText(renderable) {
        const gpuText = this._getGpuText(renderable);
        const batchableSprite = gpuText.batchableSprite;
        const view = renderable.view;
        if (gpuText.texture) {
          this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
        }
        const resolution = view.resolution ?? this._renderer.resolution;
        gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getTexture(
          view.text,
          resolution,
          view._style,
          view._getKey()
        );
        gpuText.currentKey = view._getKey();
        batchableSprite.texture = gpuText.texture;
      }
      _getGpuText(renderable) {
        return this._gpuText[renderable.uid] || this._initGpuText(renderable);
      }
      _initGpuText(renderable) {
        const view = renderable.view;
        view._style.update();
        const gpuTextData = {
          texture: null,
          currentKey: "--",
          batchableSprite: BigPool.get(BatchableSprite)
        };
        gpuTextData.batchableSprite.renderable = renderable;
        gpuTextData.batchableSprite.bounds = [0, 1, 0, 0];
        gpuTextData.batchableSprite.roundPixels = this._renderer._roundPixels | renderable.view.roundPixels;
        this._gpuText[renderable.uid] = gpuTextData;
        this._updateText(renderable);
        renderable.on("destroyed", () => {
          this.destroyRenderable(renderable);
        });
        return gpuTextData;
      }
      destroy() {
        for (const i2 in this._gpuText) {
          this._destroyRenderableById(i2);
        }
        this._gpuText = null;
        this._renderer = null;
      }
    };
    CanvasTextPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "text"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/utils/getPo2TextureFromSource.mjs
function getPo2TextureFromSource(image, width, height, resolution) {
  const bounds = tempBounds3;
  bounds.minX = 0;
  bounds.minY = 0;
  bounds.maxX = image.width / resolution | 0;
  bounds.maxY = image.height / resolution | 0;
  const texture = TexturePool.getOptimalTexture(
    bounds.width,
    bounds.height,
    resolution,
    false
  );
  texture.source.uploadMethodId = "image";
  texture.source.resource = image;
  texture.source.alphaMode = "premultiply-alpha-on-upload";
  texture.frameWidth = width / resolution;
  texture.frameHeight = height / resolution;
  texture.source.update();
  texture.layout.updateUvs();
  return texture;
}
var tempBounds3;
var init_getPo2TextureFromSource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/utils/getPo2TextureFromSource.mjs"() {
    init_TexturePool();
    init_Bounds();
    tempBounds3 = new Bounds();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs
var CanvasTextSystem;
var init_CanvasTextSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs"() {
    init_Color();
    init_Extensions();
    init_pow2();
    init_CanvasPool();
    init_TexturePool();
    init_getPo2TextureFromSource();
    init_CanvasTextMetrics();
    init_fontStringFromTextStyle();
    init_getCanvasFillStyle();
    CanvasTextSystem = class {
      constructor() {
        this._activeTextures = {};
      }
      getTextureSize(text, resolution, style) {
        const measured = CanvasTextMetrics.measureText(text || " ", style);
        let width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
        let height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
        width = Math.ceil(width - 1e-6);
        height = Math.ceil(height - 1e-6);
        width = nextPow2(width);
        height = nextPow2(height);
        return { width, height };
      }
      getTexture(text, resolution, style, textKey) {
        if (this._activeTextures[textKey]) {
          this._increaseReferenceCount(textKey);
          return this._activeTextures[textKey].texture;
        }
        const measured = CanvasTextMetrics.measureText(text || " ", style);
        const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
        const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);
        const { canvas: canvas2 } = canvasAndContext;
        this.renderTextToCanvas(text, style, resolution, canvasAndContext);
        const texture = getPo2TextureFromSource(canvas2, width, height, resolution);
        this._activeTextures[textKey] = {
          canvasAndContext,
          texture,
          usageCount: 1
        };
        return texture;
      }
      _increaseReferenceCount(textKey) {
        this._activeTextures[textKey].usageCount++;
      }
      decreaseReferenceCount(textKey) {
        const activeTexture = this._activeTextures[textKey];
        activeTexture.usageCount--;
        if (activeTexture.usageCount === 0) {
          CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);
          TexturePool.returnTexture(activeTexture.texture);
          const source3 = activeTexture.texture.source;
          source3.resource = null;
          source3.uploadMethodId = "unknown";
          source3.alphaMode = "no-premultiply-alpha";
          this._activeTextures[textKey] = null;
        }
      }
      getReferenceCount(textKey) {
        return this._activeTextures[textKey].usageCount;
      }
      /**
       * Renders text to its canvas, and updates its texture.
       *
       * By default this is used internally to ensure the texture is correct before rendering,
       * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,
       * and then shared across multiple Sprites.
       * @param text
       * @param style
       * @param resolution
       * @param canvasAndContext
       */
      renderTextToCanvas(text, style, resolution, canvasAndContext) {
        const { canvas: canvas2, context: context2 } = canvasAndContext;
        const font = fontStringFromTextStyle(style);
        const measured = CanvasTextMetrics.measureText(text || " ", style);
        const lines = measured.lines;
        const lineHeight = measured.lineHeight;
        const lineWidths = measured.lineWidths;
        const maxLineWidth = measured.maxLineWidth;
        const fontProperties = measured.fontProperties;
        const height = canvas2.height;
        context2.resetTransform();
        context2.scale(resolution, resolution);
        context2.clearRect(0, 0, measured.width + 4, measured.height + 4);
        if (style._stroke?.width) {
          const strokeStyle = style._stroke;
          context2.lineWidth = strokeStyle.width;
          context2.miterLimit = strokeStyle.miterLimit;
          context2.lineJoin = strokeStyle.join;
          context2.lineCap = strokeStyle.cap;
        }
        context2.font = font;
        let linePositionX;
        let linePositionY;
        const passesCount = style.dropShadow ? 2 : 1;
        for (let i2 = 0; i2 < passesCount; ++i2) {
          const isShadowPass = style.dropShadow && i2 === 0;
          const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
          const dsOffsetShadow = dsOffsetText * resolution;
          if (isShadowPass) {
            context2.fillStyle = "black";
            context2.strokeStyle = "black";
            const shadowOptions = style.dropShadow;
            const dropShadowColor = shadowOptions.color;
            const dropShadowAlpha = shadowOptions.alpha;
            context2.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();
            const dropShadowBlur = shadowOptions.blur * resolution;
            const dropShadowDistance = shadowOptions.distance * resolution;
            context2.shadowBlur = dropShadowBlur;
            context2.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
            context2.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;
          } else {
            context2.globalAlpha = style._fill?.alpha ?? 1;
            context2.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context2) : null;
            if (style._stroke?.width) {
              context2.strokeStyle = getCanvasFillStyle(style._stroke, context2);
            }
            context2.shadowColor = "black";
          }
          let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
          if (lineHeight - fontProperties.fontSize < 0) {
            linePositionYShift = 0;
          }
          const strokeWidth = style._stroke?.width ?? 0;
          for (let i22 = 0; i22 < lines.length; i22++) {
            linePositionX = strokeWidth / 2;
            linePositionY = strokeWidth / 2 + i22 * lineHeight + fontProperties.ascent + linePositionYShift;
            if (style.align === "right") {
              linePositionX += maxLineWidth - lineWidths[i22];
            } else if (style.align === "center") {
              linePositionX += (maxLineWidth - lineWidths[i22]) / 2;
            }
            if (style._stroke) {
              this._drawLetterSpacing(
                lines[i22],
                style,
                canvasAndContext,
                linePositionX + style.padding,
                linePositionY + style.padding - dsOffsetText,
                true
              );
            }
            if (style._fill !== void 0) {
              this._drawLetterSpacing(
                lines[i22],
                style,
                canvasAndContext,
                linePositionX + style.padding,
                linePositionY + style.padding - dsOffsetText
              );
            }
          }
        }
      }
      /**
       * Render the text with letter-spacing.
       * @param text - The text to draw
       * @param style
       * @param canvasAndContext
       * @param x - Horizontal position to draw the text
       * @param y - Vertical position to draw the text
       * @param isStroke - Is this drawing for the outside stroke of the
       *  text? If not, it's for the inside fill
       */
      _drawLetterSpacing(text, style, canvasAndContext, x3, y2, isStroke = false) {
        const { context: context2 } = canvasAndContext;
        const letterSpacing = style.letterSpacing;
        let useExperimentalLetterSpacing = false;
        if (CanvasTextMetrics.experimentalLetterSpacingSupported) {
          if (CanvasTextMetrics.experimentalLetterSpacing) {
            context2.letterSpacing = `${letterSpacing}px`;
            context2.textLetterSpacing = `${letterSpacing}px`;
            useExperimentalLetterSpacing = true;
          } else {
            context2.letterSpacing = "0px";
            context2.textLetterSpacing = "0px";
          }
        }
        if (letterSpacing === 0 || useExperimentalLetterSpacing) {
          if (isStroke) {
            context2.strokeText(text, x3, y2);
          } else {
            context2.fillText(text, x3, y2);
          }
          return;
        }
        let currentPosition = x3;
        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);
        let previousWidth = context2.measureText(text).width;
        let currentWidth = 0;
        for (let i2 = 0; i2 < stringArray.length; ++i2) {
          const currentChar = stringArray[i2];
          if (isStroke) {
            context2.strokeText(currentChar, currentPosition, y2);
          } else {
            context2.fillText(currentChar, currentPosition, y2);
          }
          let textStr = "";
          for (let j3 = i2 + 1; j3 < stringArray.length; ++j3) {
            textStr += stringArray[j3];
          }
          currentWidth = context2.measureText(textStr).width;
          currentPosition += previousWidth - currentWidth + letterSpacing;
          previousWidth = currentWidth;
        }
      }
      destroy() {
        this._activeTextures = null;
      }
    };
    CanvasTextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "canvasText"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/HTMLTextPipe.mjs
var HTMLTextPipe;
var init_HTMLTextPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/HTMLTextPipe.mjs"() {
    init_Extensions();
    init_Texture();
    init_PoolGroup();
    init_updateQuadBounds();
    init_BatchableSprite();
    HTMLTextPipe = class {
      constructor(renderer) {
        this._gpuText = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      validateRenderable(renderable) {
        const gpuText = this._getGpuText(renderable);
        const newKey = renderable.view._getKey();
        if (gpuText.textureNeedsUploading) {
          gpuText.textureNeedsUploading = false;
          return true;
        }
        if (gpuText.currentKey !== newKey) {
          return true;
        }
        return false;
      }
      addRenderable(renderable) {
        const gpuText = this._getGpuText(renderable);
        const batchableSprite = gpuText.batchableSprite;
        if (renderable.view._didUpdate) {
          this._updateText(renderable);
        }
        this._renderer.renderPipes.batch.addToBatch(batchableSprite);
      }
      updateRenderable(renderable) {
        const gpuText = this._getGpuText(renderable);
        const batchableSprite = gpuText.batchableSprite;
        if (renderable.view._didUpdate) {
          this._updateText(renderable);
        }
        batchableSprite.batcher.updateElement(batchableSprite);
      }
      destroyRenderable(renderable) {
        this._destroyRenderableById(renderable.uid);
      }
      _destroyRenderableById(renderableUid) {
        const gpuText = this._gpuText[renderableUid];
        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);
        BigPool.return(gpuText.batchableSprite);
        this._gpuText[renderableUid] = null;
      }
      _updateText(renderable) {
        const newKey = renderable.view._getKey();
        const gpuText = this._getGpuText(renderable);
        const batchableSprite = gpuText.batchableSprite;
        if (gpuText.currentKey !== newKey) {
          this._updateGpuText(renderable).catch((e2) => {
            console.error(e2);
          });
        }
        renderable.view._didUpdate = false;
        const padding = renderable.view._style.padding;
        updateQuadBounds(batchableSprite.bounds, renderable.view.anchor, batchableSprite.texture, padding);
      }
      async _updateGpuText(renderable) {
        renderable.view._didUpdate = false;
        const gpuText = this._getGpuText(renderable);
        if (gpuText.generatingTexture)
          return;
        const newKey = renderable.view._getKey();
        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);
        gpuText.generatingTexture = true;
        gpuText.currentKey = newKey;
        const view = renderable.view;
        const resolution = view.resolution ?? this._renderer.resolution;
        const texture = await this._renderer.htmlText.getManagedTexture(
          view.text,
          resolution,
          view._style,
          view._getKey()
        );
        const batchableSprite = gpuText.batchableSprite;
        batchableSprite.texture = gpuText.texture = texture;
        gpuText.generatingTexture = false;
        gpuText.textureNeedsUploading = true;
        renderable.view.onUpdate();
        const padding = renderable.view._style.padding;
        updateQuadBounds(batchableSprite.bounds, renderable.view.anchor, batchableSprite.texture, padding);
      }
      _getGpuText(renderable) {
        return this._gpuText[renderable.uid] || this._initGpuText(renderable);
      }
      _initGpuText(renderable) {
        const view = renderable.view;
        view._style.update();
        const gpuTextData = {
          texture: Texture.EMPTY,
          currentKey: "--",
          batchableSprite: BigPool.get(BatchableSprite),
          textureNeedsUploading: false,
          generatingTexture: false
        };
        const batchableSprite = gpuTextData.batchableSprite;
        batchableSprite.renderable = renderable;
        batchableSprite.texture = Texture.EMPTY;
        batchableSprite.bounds = [0, 1, 0, 0];
        batchableSprite.roundPixels = this._renderer._roundPixels | renderable.view.roundPixels;
        this._gpuText[renderable.uid] = gpuTextData;
        renderable.on("destroyed", () => {
          this.destroyRenderable(renderable);
        });
        return gpuTextData;
      }
      destroy() {
        for (const i2 in this._gpuText) {
          this._destroyRenderableById(i2);
        }
        this._gpuText = null;
        this._renderer = null;
      }
    };
    HTMLTextPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "htmlText"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/isSafari.mjs
function isSafari() {
  const { userAgent } = DOMAdapter.get().getNavigator();
  return /^((?!chrome|android).)*safari/i.test(userAgent);
}
var init_isSafari = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/isSafari.mjs"() {
    init_adapter();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/utils/extractFontFamilies.mjs
function extractFontFamilies(text, style) {
  const fontFamily = style.fontFamily;
  const fontFamilies = [];
  const dedupe = {};
  const regex = /font-family:([^;"\s]+)/g;
  const matches = text.match(regex);
  function addFontFamily(fontFamily2) {
    if (!dedupe[fontFamily2]) {
      fontFamilies.push(fontFamily2);
      dedupe[fontFamily2] = true;
    }
  }
  if (Array.isArray(fontFamily)) {
    for (let i2 = 0; i2 < fontFamily.length; i2++) {
      addFontFamily(fontFamily[i2]);
    }
  } else {
    addFontFamily(fontFamily);
  }
  if (matches) {
    matches.forEach((match) => {
      const fontFamily2 = match.split(":")[1].trim();
      addFontFamily(fontFamily2);
    });
  }
  for (const i2 in style.tagStyles) {
    const fontFamily2 = style.tagStyles[i2].fontFamily;
    addFontFamily(fontFamily2);
  }
  return fontFamilies;
}
var init_extractFontFamilies = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/utils/extractFontFamilies.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/utils/loadFontAsBase64.mjs
async function loadFontAsBase64(url) {
  const response = await DOMAdapter.get().fetch(url);
  const blob = await response.blob();
  const reader = new FileReader();
  const dataSrc = await new Promise((resolve, reject) => {
    reader.onloadend = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
  return dataSrc;
}
var init_loadFontAsBase64 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/utils/loadFontAsBase64.mjs"() {
    init_adapter();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/utils/loadFontCSS.mjs
async function loadFontCSS(style, url) {
  const dataSrc = await loadFontAsBase64(url);
  return `@font-face {
        font-family: "${style.fontFamily}";
        src: url('${dataSrc}');
        font-weight: ${style.fontWeight};
        font-style: ${style.fontStyle};
    }`;
}
var init_loadFontCSS = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/utils/loadFontCSS.mjs"() {
    init_loadFontAsBase64();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/utils/getFontCss.mjs
async function getFontCss(fontFamilies, style) {
  const fontPromises = fontFamilies.filter((fontFamily) => Cache.has(fontFamily)).map((fontFamily, i2) => {
    if (!FontStylePromiseCache.has(fontFamily)) {
      const { url } = Cache.get(fontFamily);
      if (i2 === 0) {
        FontStylePromiseCache.set(fontFamily, loadFontCSS(style, url));
      } else {
        FontStylePromiseCache.set(fontFamily, loadFontCSS({
          ...HTMLTextSystem.defaultFontOptions,
          fontFamily
        }, url));
      }
    }
    return FontStylePromiseCache.get(fontFamily);
  });
  return (await Promise.all(fontPromises)).join("\n");
}
var init_getFontCss = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/utils/getFontCss.mjs"() {
    init_Cache();
    init_HTMLTextSystem();
    init_loadFontCSS();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/utils/getSVGUrl.mjs
function getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {
  const { domElement, styleElement, svgRoot } = htmlTextData;
  domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;
  domElement.setAttribute("style", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);
  styleElement.textContent = fontCSS;
  const { width, height } = htmlTextData.image;
  svgRoot.setAttribute("width", width.toString());
  svgRoot.setAttribute("height", height.toString());
  return new XMLSerializer().serializeToString(svgRoot);
}
var init_getSVGUrl = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/utils/getSVGUrl.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/utils/getTemporaryCanvasFromImage.mjs
function getTemporaryCanvasFromImage(image, resolution) {
  const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(
    image.width,
    image.height,
    resolution
  );
  const { context: context2 } = canvasAndContext;
  context2.clearRect(0, 0, image.width, image.height);
  context2.drawImage(image, 0, 0);
  CanvasPool.returnCanvasAndContext(canvasAndContext);
  return canvasAndContext.canvas;
}
var init_getTemporaryCanvasFromImage = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/utils/getTemporaryCanvasFromImage.mjs"() {
    init_CanvasPool();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/utils/loadSVGImage.mjs
function loadSVGImage(image, url, delay) {
  return new Promise(async (resolve) => {
    if (delay) {
      await new Promise((resolve2) => setTimeout(resolve2, 100));
    }
    image.onload = () => {
      resolve();
    };
    image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;
    image.crossOrigin = "anonymous";
  });
}
var init_loadSVGImage = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/utils/loadSVGImage.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/utils/measureHtmlText.mjs
function measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {
  htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());
  const { domElement, styleElement, svgRoot } = htmlTextRenderData;
  domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;
  domElement.setAttribute("style", "transform-origin: top left; display: inline-block");
  if (fontStyleCSS) {
    styleElement.textContent = fontStyleCSS;
  }
  document.body.appendChild(svgRoot);
  const contentBounds = domElement.getBoundingClientRect();
  svgRoot.remove();
  const descenderPadding = CanvasTextMetrics.measureFont(style.fontStyle).descent;
  return {
    width: contentBounds.width,
    height: contentBounds.height + descenderPadding
  };
}
var tempHTMLTextRenderData;
var init_measureHtmlText = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/utils/measureHtmlText.mjs"() {
    init_CanvasTextMetrics();
    init_HTMLTextSystem();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/HTMLTextSystem.mjs
var nssvg, nsxhtml, FontStylePromiseCache, HTMLTextRenderData, HTMLTextSystem;
var init_HTMLTextSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/HTMLTextSystem.mjs"() {
    init_Extensions();
    init_TexturePool();
    init_types();
    init_isSafari();
    init_warn();
    init_PoolGroup();
    init_extractFontFamilies();
    init_getFontCss();
    init_getPo2TextureFromSource();
    init_getSVGUrl();
    init_getTemporaryCanvasFromImage();
    init_loadSVGImage();
    init_measureHtmlText();
    nssvg = "http://www.w3.org/2000/svg";
    nsxhtml = "http://www.w3.org/1999/xhtml";
    FontStylePromiseCache = /* @__PURE__ */ new Map();
    HTMLTextRenderData = class {
      constructor() {
        this.svgRoot = document.createElementNS(nssvg, "svg");
        this.foreignObject = document.createElementNS(nssvg, "foreignObject");
        this.domElement = document.createElementNS(nsxhtml, "div");
        this.styleElement = document.createElementNS(nsxhtml, "style");
        this.image = new Image();
        const { foreignObject, svgRoot, styleElement, domElement } = this;
        foreignObject.setAttribute("width", "10000");
        foreignObject.setAttribute("height", "10000");
        foreignObject.style.overflow = "hidden";
        svgRoot.appendChild(foreignObject);
        foreignObject.appendChild(styleElement);
        foreignObject.appendChild(domElement);
      }
    };
    HTMLTextSystem = class {
      constructor(renderer) {
        this._activeTextures = {};
        this._renderer = renderer;
        this._createCanvas = renderer.type === RendererType.WEBGPU;
      }
      getTexture(options) {
        return this._buildTexturePromise(options.text, options.resolution, options.style);
      }
      getManagedTexture(text, resolution, style, textKey) {
        if (this._activeTextures[textKey]) {
          this._increaseReferenceCount(textKey);
          return this._activeTextures[textKey].promise;
        }
        const promise2 = this._buildTexturePromise(text, resolution, style).then((texture) => {
          this._activeTextures[textKey].texture = texture;
          return texture;
        });
        this._activeTextures[textKey] = {
          texture: null,
          promise: promise2,
          usageCount: 1
        };
        return promise2;
      }
      async _buildTexturePromise(text, resolution, style) {
        const htmlTextData = BigPool.get(HTMLTextRenderData);
        const fontFamilies = extractFontFamilies(text, style);
        const fontCSS = await getFontCss(fontFamilies, style);
        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);
        const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
        const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
        const image = htmlTextData.image;
        image.width = width | 0;
        image.height = height | 0;
        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);
        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);
        let resource = image;
        if (this._createCanvas) {
          resource = getTemporaryCanvasFromImage(image, resolution);
        }
        const texture = getPo2TextureFromSource(resource, image.width, image.height, resolution);
        if (this._createCanvas) {
          this._renderer.texture.initSource(texture.source);
        }
        BigPool.return(htmlTextData);
        return texture;
      }
      _increaseReferenceCount(textKey) {
        this._activeTextures[textKey].usageCount++;
      }
      decreaseReferenceCount(textKey) {
        const activeTexture = this._activeTextures[textKey];
        if (!activeTexture)
          return;
        activeTexture.usageCount--;
        if (activeTexture.usageCount === 0) {
          if (activeTexture.texture) {
            this._cleanUp(activeTexture);
          } else {
            activeTexture.promise.then((texture) => {
              activeTexture.texture = texture;
              this._cleanUp(activeTexture);
            }).catch(() => {
              warn("HTMLTextSystem: Failed to clean texture");
            });
          }
          this._activeTextures[textKey] = null;
        }
      }
      _cleanUp(activeTexture) {
        TexturePool.returnTexture(activeTexture.texture);
        activeTexture.texture.source.resource = null;
        activeTexture.texture.source.uploadMethodId = "unknown";
      }
      getReferenceCount(textKey) {
        return this._activeTextures[textKey].usageCount;
      }
      destroy() {
        this._activeTextures = null;
      }
    };
    HTMLTextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "htmlText"
    };
    HTMLTextSystem.defaultFontOptions = {
      fontFamily: "Arial",
      fontStyle: "normal",
      fontWeight: "normal"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs
var BatcherPipe;
var init_BatcherPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs"() {
    init_Extensions();
    init_State();
    init_BatchGeometry();
    init_Batcher();
    BatcherPipe = class {
      constructor(renderer, adaptor) {
        this.state = State.for2d();
        this._batches = /* @__PURE__ */ Object.create(null);
        this._geometries = /* @__PURE__ */ Object.create(null);
        this.renderer = renderer;
        this._adaptor = adaptor;
        this._adaptor.init();
      }
      buildStart(instructionSet) {
        if (!this._batches[instructionSet.uid]) {
          const batcher = new Batcher();
          this._batches[instructionSet.uid] = batcher;
          this._geometries[batcher.uid] = new BatchGeometry();
        }
        this._activeBatch = this._batches[instructionSet.uid];
        this._activeGeometry = this._geometries[this._activeBatch.uid];
        this._activeBatch.begin();
      }
      addToBatch(batchableObject) {
        this._activeBatch.add(batchableObject);
      }
      break(instructionSet) {
        this._activeBatch.break(instructionSet);
      }
      buildEnd(instructionSet) {
        const activeBatch = this._activeBatch;
        const geometry = this._activeGeometry;
        activeBatch.finish(instructionSet);
        geometry.indexBuffer.data = activeBatch.indexBuffer;
        geometry.indexBuffer.update(activeBatch.indexSize * 4);
        geometry.buffers[0].data = activeBatch.attributeBuffer.float32View;
      }
      upload(instructionSet) {
        const batcher = this._batches[instructionSet.uid];
        const geometry = this._geometries[batcher.uid];
        if (batcher.dirty) {
          batcher.dirty = false;
          geometry.buffers[0].update(batcher.attributeSize * 4);
        }
      }
      execute(batch) {
        if (batch.action === "startBatch") {
          const batcher = batch.batcher;
          const geometry = this._geometries[batcher.uid];
          this._adaptor.start(this, geometry);
        }
        this._adaptor.execute(this, batch);
      }
      destroy() {
        this.state = null;
        this.renderer = null;
        this._adaptor.destroy();
        this._adaptor = null;
        for (const i2 in this._batches) {
          this._batches[i2].destroy();
        }
        this._batches = null;
        for (const i2 in this._geometries) {
          this._geometries[i2].destroy();
        }
        this._geometries = null;
      }
    };
    BatcherPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "batch"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/Filter.mjs
var _Filter, Filter;
var init_Filter = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/Filter.mjs"() {
    init_Shader();
    init_State();
    _Filter = class extends Shader {
      constructor(options) {
        options = { ..._Filter.defaultOptions, ...options };
        super(options);
        this.enabled = true;
        this._state = State.for2d();
        this.padding = options.padding;
        if (typeof options.antialias === "boolean") {
          this.antialias = options.antialias ? "on" : "off";
        } else {
          this.antialias = options.antialias ?? "inherit";
        }
        this.resolution = options.resolution;
        this.blendRequired = options.blendRequired;
        this.addResource("filterUniforms", 0, 0);
        this.addResource("uSampler", 0, 1);
      }
      /**
       * Applies the filter
       * @param filterManager - The renderer to retrieve the filter from
       * @param input - The input render target.
       * @param output - The target to output to.
       * @param clearMode - Should the output be cleared before rendering to it
       */
      apply(filterManager, input, output, clearMode) {
        filterManager.applyFilter(this, input, output, clearMode);
      }
      /**
       * Sets the blend mode of the filter.
       * @default "normal"
       */
      get blendMode() {
        return this._state.blendMode;
      }
      set blendMode(value) {
        this._state.blendMode = value;
      }
    };
    Filter = _Filter;
    Filter.defaultOptions = {
      blendMode: "normal",
      resolution: 1,
      padding: 0,
      antialias: "inherit",
      blendRequired: false
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/mask/mask3.mjs
var fragment;
var init_mask3 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/mask/mask3.mjs"() {
    fragment = "in vec2 vMaskCoord;\nin vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mapTexture;\n\nuniform float alpha;\nuniform vec4 maskClamp;\n\nout vec4 fragColor;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    // TODO look into why this is needed\n    float npmAlpha = alpha; \n    vec4 original = texture(uSampler, vTextureCoord);\n    vec4 masky = texture(mapTexture, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    fragColor = original;\n}\n";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/mask/mask.mjs
var vertex;
var init_mask = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/mask/mask.mjs"() {
    vertex = "in vec2 aPosition;\n\nout vec2 vTextureCoord;\nout vec2 vMaskCoord;\n\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nuniform vec4 outputTexture;\nuniform mat3 filterMatrix;\n\nvec4 filterVertexPosition(  vec2 aPosition )\n{\n    vec2 position = aPosition * outputFrame.zw + outputFrame.xy;\n       \n    position.x = position.x * (2.0 / outputTexture.x) - 1.0;\n    position.y = position.y * (2.0*outputTexture.z / outputTexture.y) - outputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord(  vec2 aPosition )\n{\n    return aPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvec2 getFilterCoord( vec2 aPosition )\n{\n    return  ( filterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}   \n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition(aPosition);\n    vTextureCoord = filterTextureCoord(aPosition);\n    vMaskCoord = getFilterCoord(aPosition);\n}\n";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/mask/mask2.mjs
var source;
var init_mask2 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/mask/mask2.mjs"() {
    source = "struct GlobalFilterUniforms {\n  inputSize:vec4<f32>,\n  inputPixel:vec4<f32>,\n  inputClamp:vec4<f32>,\n  outputFrame:vec4<f32>,\n  globalFrame:vec4<f32>,\n  outputTexture:vec4<f32>,  \n};\n\nstruct MaskUniforms {\n  filterMatrix:mat3x3<f32>,\n  maskClamp:vec4<f32>,\n  alpha:f32,\n};\n\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uSampler: texture_2d<f32>;\n@group(0) @binding(2) var mySampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\n@group(1) @binding(1) var mapTexture: texture_2d<f32>;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.outputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.outputTexture.z / gfu.outputTexture.y) - gfu.outputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  \n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.filterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n\n  \n  return gfu.globalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var maskClamp = filterUniforms.maskClamp;\n\n     var clip = step(3.5,\n        step(maskClamp.x, filterUv.x) +\n        step(maskClamp.y, filterUv.y) +\n        step(filterUv.x, maskClamp.z) +\n        step(filterUv.y, maskClamp.w));\n\n    var mask = textureSample(mapTexture, mySampler, filterUv);\n    var source = textureSample(uSampler, mySampler, uv);\n    \n    var npmAlpha = 0.0;\n\n    var alphaMul = 1.0 - npmAlpha * (1.0 - mask.a);\n\n    var a = (alphaMul * mask.r) * clip;\n\n    return vec4(source.rgb * a, source.a) * a;\n  \n}";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs
var MaskFilter;
var init_MaskFilter = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs"() {
    init_Matrix();
    init_GlProgram();
    init_GpuProgram();
    init_UniformGroup();
    init_TextureMatrix();
    init_Filter();
    init_mask3();
    init_mask();
    init_mask2();
    MaskFilter = class extends Filter {
      constructor({ sprite }) {
        const textureMatrix = new TextureMatrix(sprite.texture);
        const filterUniforms = new UniformGroup({
          filterMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          maskClamp: { value: textureMatrix.uClampFrame, type: "vec4<f32>" },
          alpha: { value: 1, type: "f32" }
        });
        const gpuProgram = new GpuProgram({
          vertex: {
            source,
            entryPoint: "mainVertex"
          },
          fragment: {
            source,
            entryPoint: "mainFragment"
          }
        });
        const glProgram = GlProgram.from({
          vertex,
          fragment,
          name: "mask-filter"
        });
        super({
          gpuProgram,
          glProgram,
          resources: {
            filterUniforms,
            mapTexture: sprite.texture.source
          }
        });
        this.sprite = sprite;
        this._textureMatrix = textureMatrix;
      }
      apply(filterManager, input, output, clearMode) {
        this._textureMatrix.texture = this.sprite.texture;
        filterManager.calculateSpriteMatrix(
          this.resources.filterUniforms.uniforms.filterMatrix,
          this.sprite
        ).prepend(this._textureMatrix.mapCoord);
        this.resources.mapTexture = this.sprite.texture.source;
        filterManager.applyFilter(this, input, output, clearMode);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs
var tempBounds4, AlphaMaskEffect, AlphaMaskPipe;
var init_AlphaMaskPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs"() {
    init_Extensions();
    init_FilterEffect();
    init_MaskFilter();
    init_Bounds();
    init_getGlobalBounds();
    init_buildInstructions();
    init_Sprite();
    init_PoolGroup();
    init_Texture();
    init_TexturePool();
    tempBounds4 = new Bounds();
    AlphaMaskEffect = class extends FilterEffect {
      constructor() {
        super({
          filters: [new MaskFilter({
            sprite: new Sprite(Texture.EMPTY)
          })]
        });
      }
      get sprite() {
        return this.filters[0].sprite;
      }
      set sprite(value) {
        this.filters[0].sprite = value;
      }
    };
    AlphaMaskPipe = class {
      constructor(renderer) {
        this._activeMaskStage = [];
        this._renderer = renderer;
      }
      push(mask, maskedContainer, instructionSet) {
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          type: "alphaMask",
          action: "pushMaskBegin",
          mask,
          canBundle: false,
          maskedContainer
        });
        if (mask.renderMaskToTexture) {
          const maskContainer = mask.mask;
          maskContainer.includeInBuild = true;
          collectAllRenderables(
            maskContainer,
            instructionSet,
            renderer.renderPipes
          );
          maskContainer.includeInBuild = false;
        }
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          type: "alphaMask",
          action: "pushMaskEnd",
          mask,
          maskedContainer,
          canBundle: false
        });
      }
      pop(mask, _maskedContainer, instructionSet) {
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          type: "alphaMask",
          action: "popMaskEnd",
          mask,
          canBundle: false
        });
      }
      execute(instruction) {
        const renderer = this._renderer;
        const renderMask = instruction.mask.renderMaskToTexture;
        if (instruction.action === "pushMaskBegin") {
          const filterEffect = BigPool.get(AlphaMaskEffect);
          if (renderMask) {
            instruction.mask.mask.measurable = true;
            const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds4);
            instruction.mask.mask.measurable = false;
            bounds.ceil();
            const filterTexture = TexturePool.getOptimalTexture(
              bounds.width,
              bounds.height,
              1,
              false
            );
            const renderTarget = renderer.renderTarget.push(filterTexture, true);
            renderer.globalUniforms.push({
              projectionData: renderTarget,
              offset: bounds,
              worldColor: 4294967295
            });
            const sprite = filterEffect.sprite;
            sprite.texture = filterTexture;
            sprite.worldTransform.tx = bounds.minX;
            sprite.worldTransform.ty = bounds.minY;
            this._activeMaskStage.push({
              filterEffect,
              maskedContainer: instruction.maskedContainer,
              filterTexture
            });
          } else {
            filterEffect.sprite = instruction.mask.mask;
            this._activeMaskStage.push({
              filterEffect,
              maskedContainer: instruction.maskedContainer
            });
          }
        } else if (instruction.action === "pushMaskEnd") {
          const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];
          if (renderMask) {
            renderer.renderTarget.pop();
            renderer.globalUniforms.pop();
          }
          renderer.filter.push({
            type: "filter",
            action: "pushFilter",
            container: maskData.maskedContainer,
            filterEffect: maskData.filterEffect,
            canBundle: false
          });
        } else if (instruction.action === "popMaskEnd") {
          renderer.filter.pop();
          const maskData = this._activeMaskStage.pop();
          if (renderMask) {
            TexturePool.returnTexture(maskData.filterTexture);
          }
          BigPool.return(maskData.filterEffect);
        }
      }
      destroy() {
        this._renderer = null;
        this._activeMaskStage = null;
      }
    };
    AlphaMaskPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "alphaMask"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs
var ColorMaskPipe;
var init_ColorMaskPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs"() {
    init_Extensions();
    ColorMaskPipe = class {
      constructor(renderer) {
        this._colorStack = [];
        this._colorStackIndex = 0;
        this._currentColor = 0;
        this._renderer = renderer;
      }
      buildStart() {
        this._colorStack[0] = 15;
        this._colorStackIndex = 1;
        this._currentColor = 15;
      }
      push(mask, _container, instructionSet) {
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        const colorStack = this._colorStack;
        colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;
        const currentColor = this._colorStack[this._colorStackIndex];
        if (currentColor !== this._currentColor) {
          this._currentColor = currentColor;
          instructionSet.add({
            type: "colorMask",
            colorMask: currentColor,
            canBundle: false
          });
        }
        this._colorStackIndex++;
      }
      pop(_mask, _container, instructionSet) {
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        const colorStack = this._colorStack;
        this._colorStackIndex--;
        const currentColor = colorStack[this._colorStackIndex - 1];
        if (currentColor !== this._currentColor) {
          this._currentColor = currentColor;
          instructionSet.add({
            type: "colorMask",
            colorMask: currentColor,
            canBundle: false
          });
        }
      }
      execute(instruction) {
        const renderer = this._renderer;
        renderer.colorMask.setMask(instruction.colorMask);
      }
      destroy() {
        this._colorStack = null;
      }
    };
    ColorMaskPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "colorMask"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs
var CLEAR;
var init_const7 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs"() {
    CLEAR = /* @__PURE__ */ ((CLEAR2) => {
      CLEAR2[CLEAR2["NONE"] = 0] = "NONE";
      CLEAR2[CLEAR2["COLOR"] = 16384] = "COLOR";
      CLEAR2[CLEAR2["STENCIL"] = 1024] = "STENCIL";
      CLEAR2[CLEAR2["DEPTH"] = 256] = "DEPTH";
      CLEAR2[CLEAR2["COLOR_DEPTH"] = 16640] = "COLOR_DEPTH";
      CLEAR2[CLEAR2["COLOR_STENCIL"] = 17408] = "COLOR_STENCIL";
      CLEAR2[CLEAR2["DEPTH_STENCIL"] = 1280] = "DEPTH_STENCIL";
      CLEAR2[CLEAR2["ALL"] = 17664] = "ALL";
      return CLEAR2;
    })(CLEAR || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs
var STENCIL_MODES;
var init_const8 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs"() {
    STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {
      STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";
      STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";
      STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";
      STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 3] = "RENDERING_MASK_REMOVE";
      STENCIL_MODES2[STENCIL_MODES2["NONE"] = 4] = "NONE";
      return STENCIL_MODES2;
    })(STENCIL_MODES || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs
var StencilMaskPipe;
var init_StencilMaskPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs"() {
    init_Extensions();
    init_buildInstructions();
    init_const7();
    init_const8();
    StencilMaskPipe = class {
      constructor(renderer) {
        this._maskStackHash = {};
        this._maskHash = /* @__PURE__ */ new WeakMap();
        this._renderer = renderer;
      }
      push(mask, _container, instructionSet) {
        const effect = mask;
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
        instructionSet.add({
          type: "stencilMask",
          action: "pushMaskBegin",
          mask,
          canBundle: false
        });
        const maskContainer = effect.mask;
        maskContainer.includeInBuild = true;
        if (!this._maskHash.has(effect)) {
          this._maskHash.set(effect, {
            instructionsStart: 0,
            instructionsLength: 0
          });
        }
        const maskData = this._maskHash.get(effect);
        maskData.instructionsStart = instructionSet.instructionSize;
        collectAllRenderables(
          maskContainer,
          instructionSet,
          renderer.renderPipes
        );
        maskContainer.includeInBuild = false;
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          type: "stencilMask",
          action: "pushMaskEnd",
          mask,
          canBundle: false
        });
        const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;
        maskData.instructionsLength = instructionsLength;
        const renderTargetUid = renderer.renderTarget.renderTarget.uid;
        if (this._maskStackHash[renderTargetUid] === void 0) {
          this._maskStackHash[renderTargetUid] = 0;
        }
        this._maskStackHash[renderTargetUid]++;
      }
      pop(mask, _container, instructionSet) {
        const effect = mask;
        const renderer = this._renderer;
        const renderTargetUid = renderer.renderTarget.renderTarget.uid;
        this._maskStackHash[renderTargetUid]--;
        renderer.renderPipes.batch.break(instructionSet);
        renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
        instructionSet.add({
          type: "stencilMask",
          action: "popMaskBegin",
          canBundle: false
        });
        const maskData = this._maskHash.get(mask);
        if (this._maskStackHash[renderTargetUid] !== 0) {
          for (let i2 = 0; i2 < maskData.instructionsLength; i2++) {
            instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];
          }
        }
        instructionSet.add({
          type: "stencilMask",
          action: "popMaskEnd",
          canBundle: false
        });
      }
      execute(instruction) {
        const renderer = this._renderer;
        const renderTargetUid = renderer.renderTarget.renderTarget.uid;
        let maskStackIndex = this._maskStackHash[renderTargetUid] ?? 0;
        if (instruction.action === "pushMaskBegin") {
          maskStackIndex++;
          renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);
          renderer.colorMask.setMask(0);
        } else if (instruction.action === "pushMaskEnd") {
          renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
          renderer.colorMask.setMask(15);
        } else if (instruction.action === "popMaskBegin") {
          maskStackIndex--;
          if (maskStackIndex !== 0) {
            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);
            renderer.colorMask.setMask(0);
          } else {
            renderer.renderTarget.clear(CLEAR.STENCIL);
          }
        } else if (instruction.action === "popMaskEnd") {
          if (maskStackIndex === 0) {
            renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);
          } else {
            renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
          }
          renderer.colorMask.setMask(15);
        }
        this._maskStackHash[renderTargetUid] = maskStackIndex;
      }
      destroy() {
        this._renderer = null;
        this._maskStackHash = null;
        this._maskHash = null;
      }
    };
    StencilMaskPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "stencilMask"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs
var _BackgroundSystem, BackgroundSystem;
var init_BackgroundSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs"() {
    init_Color();
    init_Extensions();
    _BackgroundSystem = class {
      constructor() {
        this._backgroundColorRgba = [0, 0, 0, 0];
        this.clearBeforeRender = true;
        this._backgroundColor = new Color(0);
        this.color = this._backgroundColor;
        this.alpha = 1;
      }
      /**
       * initiates the background system
       * @param options - the options for the background colors
       */
      init(options) {
        options = { ..._BackgroundSystem.defaultOptions, ...options };
        this.clearBeforeRender = options.clearBeforeRender;
        this.color = options.background || options.backgroundColor || this._backgroundColor;
        this.alpha = options.backgroundAlpha;
      }
      /** The background color to fill if not transparent */
      get color() {
        return this._backgroundColor;
      }
      set color(value) {
        this._backgroundColor.setValue(value);
        this._backgroundColorRgba = this._backgroundColor.toArray();
      }
      /** The background color alpha. Setting this to 0 will make the canvas transparent. */
      get alpha() {
        return this._backgroundColor.alpha;
      }
      set alpha(value) {
        this._backgroundColor.setAlpha(value);
      }
      /** The background color as an [R, G, B, A] array. */
      get colorRgba() {
        return this._backgroundColorRgba;
      }
      destroy() {
      }
    };
    BackgroundSystem = _BackgroundSystem;
    BackgroundSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "background",
      priority: 0
    };
    BackgroundSystem.defaultOptions = {
      /**
       * {@link WebGLOptions.backgroundAlpha}
       * @default 1
       */
      backgroundAlpha: 1,
      /**
       * {@link WebGLOptions.backgroundColor}
       * @default 0x000000
       */
      backgroundColor: 0,
      /**
       * {@link WebGLOptions.clearBeforeRender}
       * @default true
       */
      clearBeforeRender: true
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs
var BLEND_MODE_FILTERS, BlendModePipe;
var init_BlendModePipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs"() {
    init_Extensions();
    init_FilterEffect();
    init_warn();
    BLEND_MODE_FILTERS = {};
    extensions.handle(ExtensionType.BlendMode, (value) => {
      if (!value.name) {
        throw new Error("BlendMode extension must have a name property");
      }
      BLEND_MODE_FILTERS[value.name] = value.ref;
    }, (value) => {
      delete BLEND_MODE_FILTERS[value.name];
    });
    BlendModePipe = class {
      constructor(renderer) {
        this._isAdvanced = false;
        this._filterHash = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      setBlendMode(renderable, blendMode, instructionSet) {
        if (this._activeBlendMode === blendMode) {
          if (this._isAdvanced)
            this._renderableList.push(renderable);
          return;
        }
        this._activeBlendMode = blendMode;
        if (this._isAdvanced) {
          this._endAdvancedBlendMode(instructionSet);
        }
        this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];
        if (this._isAdvanced) {
          this._beginAdvancedBlendMode(instructionSet);
          this._renderableList.push(renderable);
        }
      }
      _beginAdvancedBlendMode(instructionSet) {
        this._renderer.renderPipes.batch.break(instructionSet);
        const blendMode = this._activeBlendMode;
        if (!BLEND_MODE_FILTERS[blendMode]) {
          warn(`Unable to assign 'BLEND_MODES.${blendMode}' using the blend mode pipeline`);
          return;
        }
        if (!this._filterHash[blendMode]) {
          this._filterHash[blendMode] = new FilterEffect({
            filters: [new BLEND_MODE_FILTERS[blendMode]()]
          });
        }
        const instruction = {
          type: "filter",
          action: "pushFilter",
          renderables: [],
          filterEffect: this._filterHash[blendMode],
          canBundle: false
        };
        this._renderableList = instruction.renderables;
        instructionSet.add(instruction);
      }
      _endAdvancedBlendMode(instructionSet) {
        this._renderableList = null;
        this._renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          type: "filter",
          action: "popFilter",
          canBundle: false
        });
      }
      buildStart() {
        this._isAdvanced = false;
      }
      buildEnd(instructionSet) {
        if (this._isAdvanced) {
          this._endAdvancedBlendMode(instructionSet);
        }
      }
      destroy() {
        this._renderer = null;
        this._renderableList = null;
        for (const i2 in this._filterHash) {
          this._filterHash[i2].destroy();
        }
        this._filterHash = null;
      }
    };
    BlendModePipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "blendMode"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs
var _ExtractSystem, ExtractSystem;
var init_ExtractSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs"() {
    init_Extensions();
    init_Container();
    init_Texture();
    _ExtractSystem = class {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this._renderer = renderer;
      }
      _normalizeOptions(options, defaults = {}) {
        if (options instanceof Container || options instanceof Texture) {
          return {
            target: options,
            ...defaults
          };
        }
        return {
          ...defaults,
          ...options
        };
      }
      async image(options) {
        const image = new Image();
        image.src = await this.base64(options);
        return image;
      }
      async base64(options) {
        options = this._normalizeOptions(
          options,
          _ExtractSystem.defaultImageOptions
        );
        const { format: format2, quality } = options;
        const canvas2 = this.canvas(options);
        if (canvas2.toBlob !== void 0) {
          return new Promise((resolve, reject) => {
            canvas2.toBlob((blob) => {
              if (!blob) {
                reject(new Error("ICanvas.toBlob failed!"));
                return;
              }
              const reader = new FileReader();
              reader.onload = () => resolve(reader.result);
              reader.onerror = reject;
              reader.readAsDataURL(blob);
            }, format2, quality);
          });
        }
        if (canvas2.toDataURL !== void 0) {
          return canvas2.toDataURL(format2, quality);
        }
        if (canvas2.convertToBlob !== void 0) {
          const blob = await canvas2.convertToBlob({ type: format2, quality });
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          });
        }
        throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
      }
      canvas(options) {
        options = this._normalizeOptions(options);
        const target = options.target;
        const renderer = this._renderer;
        const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);
        const canvas2 = renderer.texture.generateCanvas(texture);
        if (target instanceof Container) {
          texture.destroy();
        }
        return canvas2;
      }
      pixels(options) {
        options = this._normalizeOptions(options);
        const target = options.target;
        const renderer = this._renderer;
        const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);
        const pixelInfo = renderer.texture.getPixels(texture);
        if (target instanceof Container) {
          texture.destroy();
        }
        return pixelInfo;
      }
      texture(options) {
        options = this._normalizeOptions(options);
        if (options.target instanceof Texture)
          return options.target;
        return this._renderer.textureGenerator.generateTexture(options);
      }
      download(options) {
        options = this._normalizeOptions(options);
        const canvas2 = this.canvas(options);
        const link = document.createElement("a");
        link.download = options.filename ?? "image.png";
        link.href = canvas2.toDataURL("image/png");
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
      log(options) {
        const width = options.width ?? 200;
        options = this._normalizeOptions(options);
        const canvas2 = this.canvas(options);
        const base64 = canvas2.toDataURL();
        console.log(`[Pixi Texture] ${canvas2.width}px ${canvas2.height}px`);
        const style = [
          "font-size: 1px;",
          `padding: ${width}px ${300}px;`,
          `background: url(${base64}) no-repeat;`,
          "background-size: contain;"
        ].join(" ");
        console.log("%c ", style);
      }
      destroy() {
        this._renderer = null;
      }
    };
    ExtractSystem = _ExtractSystem;
    ExtractSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "extract"
    };
    ExtractSystem.defaultImageOptions = {
      format: "png",
      quality: 1
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs
var RenderTexture;
var init_RenderTexture = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs"() {
    init_TextureSource();
    init_Texture();
    RenderTexture = class extends Texture {
      static create(options) {
        return new Texture({
          source: new TextureSource(options)
        });
      }
      resize(width, height, resolution) {
        this.source.resize(width, height, resolution);
        return this;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs
var tempRect2, tempBounds5, noColor, GenerateTextureSystem;
var init_GenerateTextureSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs"() {
    init_Color();
    init_Extensions();
    init_Matrix();
    init_Rectangle();
    init_Bounds();
    init_getLocalBounds();
    init_Container();
    init_RenderTexture();
    tempRect2 = new Rectangle();
    tempBounds5 = new Bounds();
    noColor = [0, 0, 0, 0];
    GenerateTextureSystem = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      /**
       * A Useful function that returns a texture of the display object that can then be used to create sprites
       * This can be quite useful if your container is complicated and needs to be reused multiple times.
       * @param {GenerateTextureOptions | Container} options - Generate texture options.
       * @param {Container} [options.container] - If not given, the renderer's resolution is used.
       * @param {Rectangle} options.region - The region of the container, that shall be rendered,
       *        if no region is specified, defaults to the local bounds of the container.
       * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.
       * @returns a shiny new texture of the container passed in
       */
      generateTexture(options) {
        if (options instanceof Container) {
          options = {
            target: options,
            frame: void 0,
            textureSourceOptions: {},
            resolution: void 0
          };
        }
        const resolution = options.resolution || this._renderer.resolution;
        const container = options.target;
        let clearColor = options.clearColor;
        if (clearColor) {
          const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;
          clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();
        } else {
          clearColor = noColor;
        }
        const region = options.frame?.copyTo(tempRect2) || getLocalBounds(container, tempBounds5).rectangle;
        region.width = Math.max(region.width, 1 / resolution) | 0;
        region.height = Math.max(region.height, 1 / resolution) | 0;
        const target = RenderTexture.create({
          ...options.textureSourceOptions,
          width: region.width,
          height: region.height,
          resolution
        });
        const transform2 = Matrix.shared.translate(-region.x, -region.y);
        this._renderer.render({
          container,
          transform: transform2,
          target,
          clearColor
        });
        return target;
      }
      destroy() {
        const writeable = this;
        writeable._renderer = null;
      }
    };
    GenerateTextureSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "textureGenerator"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs
var GlobalUniformSystem;
var init_GlobalUniformSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs"() {
    init_Extensions();
    init_Matrix();
    init_Point();
    init_BindGroup();
    init_UniformGroup();
    GlobalUniformSystem = class {
      constructor(renderer) {
        this._stackIndex = 0;
        this._globalUniformDataStack = [];
        this._uniformsPool = [];
        this._activeUniforms = [];
        this._bindGroupPool = [];
        this._activeBindGroups = [];
        this._renderer = renderer;
      }
      reset() {
        this._stackIndex = 0;
        for (let i2 = 0; i2 < this._activeUniforms.length; i2++) {
          this._uniformsPool.push(this._activeUniforms[i2]);
        }
        for (let i2 = 0; i2 < this._activeBindGroups.length; i2++) {
          this._bindGroupPool.push(this._activeBindGroups[i2]);
        }
        this._activeUniforms.length = 0;
        this._activeBindGroups.length = 0;
      }
      start(options) {
        this.reset();
        this.push(options);
      }
      bind({
        projectionData,
        worldTransformMatrix,
        worldColor,
        offset
      }) {
        const renderTarget = this._renderer.renderTarget.renderTarget;
        const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
          projectionData: renderTarget,
          worldTransformMatrix: new Matrix(),
          worldColor: 4294967295,
          offset: new Point()
        };
        const globalUniformData = {
          projectionMatrix: projectionData?.projectionMatrix || renderTarget.projectionMatrix,
          resolution: projectionData?.size || renderTarget.size,
          worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,
          worldColor: worldColor || currentGlobalUniformData.worldColor,
          offset: offset || currentGlobalUniformData.offset,
          bindGroup: null
        };
        const uniformGroup = this._uniformsPool.pop() || this._createUniforms();
        this._activeUniforms.push(uniformGroup);
        const uniforms = uniformGroup.uniforms;
        uniforms.projectionMatrix = globalUniformData.projectionMatrix;
        uniforms.uResolution = globalUniformData.resolution;
        uniforms.worldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);
        uniforms.worldTransformMatrix.tx -= globalUniformData.offset.x;
        uniforms.worldTransformMatrix.ty -= globalUniformData.offset.y;
        uniforms.worldAlpha = (globalUniformData.worldColor >> 24 & 255) / 255;
        uniformGroup.update();
        let bindGroup;
        if (this._renderer.renderPipes.uniformBatch) {
          bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);
        } else {
          this._renderer.uniformBuffer.updateUniformGroup(uniformGroup);
          bindGroup = this._bindGroupPool.pop() || new BindGroup();
          this._activeBindGroups.push(bindGroup);
          bindGroup.setResource(uniformGroup, 0);
        }
        globalUniformData.bindGroup = bindGroup;
        this._currentGlobalUniformData = globalUniformData;
      }
      push(options) {
        this.bind(options);
        this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
      }
      pop() {
        this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];
      }
      get bindGroup() {
        return this._currentGlobalUniformData.bindGroup;
      }
      get uniformGroup() {
        return this._currentGlobalUniformData.bindGroup.resources[0];
      }
      _createUniforms() {
        const globalUniforms = new UniformGroup({
          projectionMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          worldTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>
          worldAlpha: { value: 1, type: "f32" },
          uResolution: { value: [0, 0], type: "vec2<f32>" }
        }, {
          ubo: true,
          isStatic: true
        });
        return globalUniforms;
      }
      destroy() {
        const writeable = this;
        writeable._renderer = null;
      }
    };
    GlobalUniformSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "globalUniforms"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUBOElements.mjs
function createUBOElements(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    size: 0
  }));
  let size2 = 0;
  let chunkSize = 0;
  let offset = 0;
  for (let i2 = 0; i2 < uboElements.length; i2++) {
    const uboElement = uboElements[i2];
    size2 = WGSL_TO_STD40_SIZE[uboElement.data.type];
    if (!size2) {
      throw new Error(`Unknown type ${uboElement.data.type}`);
    }
    if (uboElement.data.size > 1) {
      size2 = Math.max(size2, 16) * uboElement.data.size;
    }
    uboElement.size = size2;
    if (chunkSize % size2 !== 0 && chunkSize < 16) {
      const lineUpValue = chunkSize % size2 % 16;
      chunkSize += lineUpValue;
      offset += lineUpValue;
    }
    if (chunkSize + size2 > 16) {
      offset = Math.ceil(offset / 16) * 16;
      uboElement.offset = offset;
      offset += size2;
      chunkSize = size2;
    } else {
      uboElement.offset = offset;
      chunkSize += size2;
      offset += size2;
    }
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}
var WGSL_TO_STD40_SIZE;
var init_createUBOElements = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUBOElements.mjs"() {
    WGSL_TO_STD40_SIZE = {
      "f32": 4,
      "vec2<f32>": 8,
      "vec3<f32>": 12,
      "vec4<f32>": 16,
      "mat2x2<f32>": 16 * 3,
      "mat3x3<f32>": 16 * 3,
      "mat4x4<f32>": 16 * 4
      // float:  4,
      // vec2:   8,
      // vec3:   12,
      // vec4:   16,
      // int:      4,
      // ivec2:    8,
      // ivec3:    12,
      // ivec4:    16,
      // uint:     4,
      // uvec2:    8,
      // uvec3:    12,
      // uvec4:    16,
      // bool:     4,
      // bvec2:    8,
      // bvec3:    12,
      // bvec4:    16,
      // mat2:     16 * 2,
      // mat3:     16 * 3,
      // mat4:     16 * 4,
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformBufferParsers.mjs
var uniformBufferParsers;
var init_uniformBufferParsers = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformBufferParsers.mjs"() {
    uniformBufferParsers = [
      // uploading pixi matrix object to mat3
      {
        type: "mat3x3<f32>",
        test: (data) => data.value.a !== void 0,
        code: (name) => `
                var ${name}_matrix = uv.${name}.toArray(true);

                data[offset] = ${name}_matrix[0];
                data[offset+1] = ${name}_matrix[1];
                data[offset+2] = ${name}_matrix[2];

                data[offset + 4] = ${name}_matrix[3];
                data[offset + 5] = ${name}_matrix[4];
                data[offset + 6] = ${name}_matrix[5];

                data[offset + 8] = ${name}_matrix[6];
                data[offset + 9] = ${name}_matrix[7];
                data[offset + 10] = ${name}_matrix[8];
            `
      },
      {
        type: "vec4<f32>",
        test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.width !== void 0,
        code: (name) => `
                        v = uv.${name};

                        data[offset] = v.x;
                        data[offset+1] = v.y;
                        data[offset+2] = v.width;
                        data[offset+3] = v.height;
                    `
      },
      {
        type: "vec2<f32>",
        test: (data) => data.type === "vec2<f32>" && data.size === 1 && data.value.x !== void 0,
        code: (name) => `
                    v = uv.${name};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                `
      }
      // uploading a pixi point as a vec2 with caching layer
      // {
      //     test: (data: any, uniform: any): boolean =>
      //         data.type === 'vec2' && data.size === 1 && uniform.x !== undefined,
      //     code: (name: string): string =>
      //         `
      //             v = uv.${name};
      //             data[offset] = v.x;
      //             data[offset+1] = v.y;
      //         `,
      // },
      // caching layer for a vec2
      // {
      //     test: (data: any): boolean =>
      //         data.type === 'vec2' && data.size === 1,
      //     code: (name: string): string =>
      //         `
      //             cv = ud["${name}"].value;
      //             v = uv["${name}"];
      //             if(cv[0] !== v[0] || cv[1] !== v[1])
      //             {
      //                 cv[0] = v[0];
      //                 cv[1] = v[1];
      //                 gl.uniform2f(ud["${name}"].location, v[0], v[1]);
      //             }
      //         `,
      // },
      // upload a pixi rectangle as a vec4 with caching layer
      // {
      //     test: (data: any, uniform: any): boolean =>
      //         data.type === 'vec4' && data.size === 1 && uniform.width !== undefined,
      //     code: (name: string): string =>
      //         `
      //                 v = uv.${name};
      //                 data[offset] = v.x;
      //                 data[offset+1] = v.y;
      //                 data[offset+2] = v.width;
      //                 data[offset+3] = v.height;
      //             `,
      // },
      // a caching layer for vec4 uploading
      // {
      //     test: (data: any): boolean =>
      //         data.type === 'vec4' && data.size === 1,
      //     code: (name: string): string =>
      //         `
      //             cv = ud["${name}"].value;
      //             v = uv["${name}"];
      //             if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
      //             {
      //                 cv[0] = v[0];
      //                 cv[1] = v[1];
      //                 cv[2] = v[2];
      //                 cv[3] = v[3];
      //                 gl.uniform4f(ud["${name}"].location, v[0], v[1], v[2], v[3])
      //             }`,
      // },
    ];
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUniformBufferSync.mjs
function generateUniformBufferSync(uboElements) {
  const funcFragments = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
    `];
  let prev = 0;
  for (let i2 = 0; i2 < uboElements.length; i2++) {
    const uboElement = uboElements[i2];
    const name = uboElement.data.name;
    let parsed = false;
    let offset = 0;
    for (let j3 = 0; j3 < uniformBufferParsers.length; j3++) {
      const uniformParser = uniformBufferParsers[j3];
      if (uniformParser.test(uboElement.data)) {
        offset = uboElement.offset / 4;
        funcFragments.push(
          `offset += ${offset - prev};`,
          uniformBufferParsers[j3].code(name)
        );
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      if (uboElement.data.size > 1) {
        const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
        const elementSize = uboElement.data.value.length / uboElement.data.size;
        const remainder = (4 - elementSize % 4) % 4;
        offset = uboElement.offset / 4;
        funcFragments.push(
          /* wgsl */
          `
                    v = uv.${name};
                    offset += ${offset - prev};

                    let arrayOffset = offset;
                    
                    t = 0;

                    for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
                    {
                        for(var j = 0; j < ${elementSize}; j++)
                        {
                            data[arrayOffset++] = v[t++];
                        }
                        ${remainder !== 0 ? "arrayOffset += ${remainder};" : ""}
                    }
                `
        );
      } else {
        const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
        offset = uboElement.offset / 4;
        funcFragments.push(
          /* wgsl */
          `
                    v = uv.${name};
                    offset += ${offset - prev};
                    ${template};
                `
        );
      }
    }
    prev = offset;
  }
  const fragmentSrc = funcFragments.join("\n");
  return new Function(
    "uv",
    "data",
    "offset",
    fragmentSrc
  );
}
var UBO_TO_SINGLE_SETTERS;
var init_createUniformBufferSync = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUniformBufferSync.mjs"() {
    init_createUBOElements();
    init_uniformBufferParsers();
    UBO_TO_SINGLE_SETTERS = {
      "f32": `
        data[offset] = v;
    `,
      "vec2<f32>": `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
      "vec3<f32>": `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
      "vec4<f32>": `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
      "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
      "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
      "mat4x4<f32>": `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformBufferSystem.mjs
var UniformBufferSystem;
var init_UniformBufferSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformBufferSystem.mjs"() {
    init_Extensions();
    init_Buffer();
    init_const5();
    init_createUBOElements();
    init_createUniformBufferSync();
    UniformBufferSystem = class {
      constructor() {
        this._syncFunctionHash = /* @__PURE__ */ Object.create(null);
      }
      ensureUniformGroup(uniformGroup) {
        if (!uniformGroup._syncFunction) {
          this._initUniformGroup(uniformGroup);
        }
      }
      _initUniformGroup(uniformGroup) {
        const uniformGroupSignature = uniformGroup.signature;
        let uniformData = this._syncFunctionHash[uniformGroupSignature];
        if (!uniformData) {
          const elements = Object.keys(uniformGroup.uniformStructures).map((i2) => uniformGroup.uniformStructures[i2]);
          const layout = createUBOElements(elements);
          const syncFunction = generateUniformBufferSync(layout.uboElements);
          uniformData = this._syncFunctionHash[uniformGroupSignature] = {
            layout,
            syncFunction
          };
        }
        uniformGroup._syncFunction = uniformData.syncFunction;
        uniformGroup.buffer = new Buffer2({
          data: new Float32Array(uniformData.layout.size / 4),
          usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
        });
        return uniformGroup._syncFunction;
      }
      syncUniformGroup(uniformGroup, data, offset) {
        const syncFunction = uniformGroup._syncFunction || this._initUniformGroup(uniformGroup);
        data || (data = uniformGroup.buffer.data);
        offset || (offset = 0);
        syncFunction(uniformGroup.uniforms, data, offset);
        return true;
      }
      updateUniformGroup(uniformGroup) {
        if (uniformGroup.isStatic && !uniformGroup.dirtyId)
          return false;
        uniformGroup.dirtyId = 0;
        const synced = this.syncUniformGroup(uniformGroup);
        uniformGroup.buffer.update();
        return synced;
      }
      destroy() {
        this._syncFunctionHash = null;
      }
    };
    UniformBufferSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "uniformBuffer"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/sayHello.mjs
function sayHello(type) {
  if (saidHello) {
    return;
  }
  if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
    const args = [
      `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/

`,
      "background: #E72264; padding:5px 0;",
      "background: #6CA2EA; padding:5px 0;",
      "background: #B5D33D; padding:5px 0;",
      "background: #FED23F; padding:5px 0;",
      "color: #FFFFFF; background: #E72264; padding:5px 0;",
      "color: #E72264; background: #FFFFFF; padding:5px 0;"
    ];
    globalThis.console.log(...args);
  } else if (globalThis.console) {
    globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);
  }
  saidHello = true;
}
var saidHello, VERSION;
var init_sayHello = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/sayHello.mjs"() {
    init_adapter();
    saidHello = false;
    VERSION = "8.0.0-beta.5";
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs
var HelloSystem;
var init_HelloSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs"() {
    init_Extensions();
    init_sayHello();
    HelloSystem = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      /**
       * It all starts here! This initiates every system, passing in the options for any system by name.
       * @param options - the config for the renderer and all its systems
       */
      init(options) {
        if (options.hello) {
          sayHello(this._renderer.name);
        }
      }
    };
    HelloSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "hello",
      priority: 0
    };
    HelloSystem.defaultOptions = {
      /**
       * {@link WebGLOptions.hello}
       * @default false
       */
      hello: false
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs
var _TextureGCSystem, TextureGCSystem;
var init_TextureGCSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs"() {
    init_Extensions();
    _TextureGCSystem = class {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this._renderer = renderer;
        this.count = 0;
        this.checkCount = 0;
      }
      init(options) {
        options = { ..._TextureGCSystem.defaultOptions, ...options };
        this.checkCountMax = options.textureGCCheckCountMax;
        this.maxIdle = options.textureGCAMaxIdle;
        this.active = options.textureGCActive;
      }
      /**
       * Checks to see when the last time a texture was used.
       * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
       */
      postrender() {
        if (!this._renderer.renderingToScreen) {
          return;
        }
        this.count++;
        if (!this.active)
          return;
        this.checkCount++;
        if (this.checkCount > this.checkCountMax) {
          this.checkCount = 0;
          this.run();
        }
      }
      /**
       * Checks to see when the last time a texture was used.
       * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
       */
      run() {
        const managedTextures = this._renderer.texture.managedTextures;
        for (let i2 = 0; i2 < managedTextures.length; i2++) {
          const texture = managedTextures[i2];
          if (texture.resource && texture.touched > -1 && this.count - texture.touched > this.maxIdle) {
            texture.touched = -1;
            texture.unload();
          }
        }
      }
      destroy() {
        this._renderer = null;
      }
    };
    TextureGCSystem = _TextureGCSystem;
    TextureGCSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "textureGC"
    };
    TextureGCSystem.defaultOptions = {
      textureGCActive: true,
      textureGCAMaxIdle: 60 * 60,
      textureGCCheckCountMax: 600
    };
    extensions.add(TextureGCSystem);
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs
function getCanvasTexture(canvas2, options) {
  if (!canvasCache.has(canvas2)) {
    const texture = new Texture({
      source: new CanvasSource({
        resource: canvas2,
        ...options
      })
    });
    canvasCache.set(canvas2, texture);
  }
  return canvasCache.get(canvas2);
}
var canvasCache;
var init_getCanvasTexture = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs"() {
    init_CanvasSource();
    init_Texture();
    canvasCache = /* @__PURE__ */ new Map();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs
var _ViewSystem, ViewSystem;
var init_ViewSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs"() {
    init_Extensions();
    init_Rectangle();
    init_adapter();
    init_deprecation();
    init_getCanvasTexture();
    _ViewSystem = class {
      get resolution() {
        return this.texture.source._resolution;
      }
      set resolution(value) {
        this.texture.source.resize(
          this.texture.source.width,
          this.texture.source.height,
          value
        );
      }
      /**
       * initiates the view system
       * @param options - the options for the view
       */
      init(options) {
        options = {
          ..._ViewSystem.defaultOptions,
          ...options
        };
        if (options.element) {
          deprecation(v8_0_0, "ViewSystem.element has been renamed to ViewSystem.canvas");
          options.canvas = options.element;
        }
        this.screen = new Rectangle(0, 0, options.width, options.height);
        this.canvas = options.canvas || DOMAdapter.get().createCanvas();
        this.antialias = !!options.antialias;
        this.texture = getCanvasTexture(this.canvas, options);
        this.multiView = !!options.multiView;
        if (this.autoDensity) {
          this.canvas.style.width = `${this.texture.width}px`;
          this.canvas.style.height = `${this.texture.height}px`;
        }
        this.resolution = options.resolution;
      }
      /**
       * Resizes the screen and canvas to the specified dimensions.
       * @param desiredScreenWidth - The new width of the screen.
       * @param desiredScreenHeight - The new height of the screen.
       * @param resolution
       */
      resize(desiredScreenWidth, desiredScreenHeight, resolution) {
        this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);
        this.screen.width = this.texture.frameWidth;
        this.screen.height = this.texture.frameHeight;
        if (this.autoDensity) {
          this.canvas.style.width = `${desiredScreenWidth}px`;
          this.canvas.style.height = `${desiredScreenHeight}px`;
        }
      }
      /**
       * Destroys this System and optionally removes the canvas from the dom.
       * @param {options | false} options - The options for destroying the view, or "false".
       * @param options.removeView - Whether to remove the view element from the DOM. Defaults to `false`.
       */
      destroy(options = false) {
        const removeView = typeof options === "boolean" ? options : !!options?.removeView;
        if (removeView && this.canvas.parentNode) {
          this.canvas.parentNode.removeChild(this.canvas);
        }
      }
    };
    ViewSystem = _ViewSystem;
    ViewSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "view",
      priority: 0
    };
    ViewSystem.defaultOptions = {
      /**
       * {@link WebGLOptions.width}
       * @default 800
       */
      width: 800,
      /**
       * {@link WebGLOptions.height}
       * @default 600
       */
      height: 600,
      /**
       * {@link WebGLOptions.autoDensity}
       * @default false
       */
      autoDensity: false,
      /**
       * {@link WebGLOptions.antialias}
       * @default false
       */
      antialias: false
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs
var SharedSystems, SharedRenderPipes;
var init_SharedSystems = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs"() {
    init_AccessibilitySystem();
    init_FilterPipe();
    init_FilterSystem();
    init_LayerPipe();
    init_LayerSystem();
    init_GraphicsContextSystem();
    init_GraphicsPipe();
    init_MeshPipe();
    init_SpritePipe();
    init_TilingSpritePipe();
    init_BitmapTextPipe();
    init_CanvasTextPipe();
    init_CanvasTextSystem();
    init_HTMLTextPipe();
    init_HTMLTextSystem();
    init_BatcherPipe();
    init_AlphaMaskPipe();
    init_ColorMaskPipe();
    init_StencilMaskPipe();
    init_BackgroundSystem();
    init_BlendModePipe();
    init_ExtractSystem();
    init_GenerateTextureSystem();
    init_GlobalUniformSystem();
    init_UniformBufferSystem();
    init_HelloSystem();
    init_TextureGCSystem();
    init_ViewSystem();
    SharedSystems = [
      BackgroundSystem,
      FilterSystem,
      GraphicsContextSystem,
      GlobalUniformSystem,
      HelloSystem,
      ViewSystem,
      CanvasTextSystem,
      HTMLTextSystem,
      LayerSystem,
      UniformBufferSystem,
      TextureGCSystem,
      GenerateTextureSystem,
      ExtractSystem,
      AccessibilitySystem
    ];
    SharedRenderPipes = [
      BlendModePipe,
      BatcherPipe,
      SpritePipe,
      LayerPipe,
      MeshPipe,
      GraphicsPipe,
      CanvasTextPipe,
      HTMLTextPipe,
      BitmapTextPipe,
      TilingSpritePipe,
      FilterPipe,
      AlphaMaskPipe,
      StencilMaskPipe,
      ColorMaskPipe
    ];
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs
var BindGroupSystem;
var init_BindGroupSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs"() {
    init_Extensions();
    BindGroupSystem = class {
      constructor(renderer) {
        this._hash = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
      getBindGroup(bindGroup, program, groupIndex) {
        bindGroup.updateKey();
        const gpuBindGroup = this._hash[bindGroup.key] || this._createBindGroup(bindGroup, program, groupIndex);
        return gpuBindGroup;
      }
      _createBindGroup(group, program, groupIndex) {
        const device = this._gpu.device;
        const groupLayout = program.layout[groupIndex];
        const entries = [];
        for (const j3 in groupLayout) {
          const resource = group.resources[j3] ?? group.resources[groupLayout[j3]];
          let gpuResource;
          if (resource.resourceType === "uniformGroup") {
            const uniformGroup = resource;
            this._renderer.uniformBuffer.updateUniformGroup(uniformGroup);
            const buffer = uniformGroup.buffer;
            gpuResource = {
              buffer: this._renderer.buffer.getGPUBuffer(buffer),
              offset: 0,
              size: buffer.descriptor.size
            };
          } else if (resource.resourceType === "buffer") {
            const buffer = resource;
            gpuResource = {
              buffer: this._renderer.buffer.getGPUBuffer(buffer),
              offset: 0,
              size: buffer.descriptor.size
            };
          } else if (resource.resourceType === "bufferResource") {
            const bufferResource = resource;
            gpuResource = {
              buffer: this._renderer.buffer.getGPUBuffer(bufferResource.buffer),
              offset: bufferResource.offset,
              size: bufferResource.size
            };
          } else if (resource.resourceType === "textureSampler") {
            const sampler = resource;
            gpuResource = this._renderer.texture.getGpuSampler(sampler);
          } else if (resource.resourceType === "textureSource") {
            const texture = resource;
            gpuResource = this._renderer.texture.getGpuSource(texture).createView({});
          }
          entries.push({
            binding: groupLayout[j3],
            resource: gpuResource
          });
        }
        const gpuBindGroup = device.createBindGroup({
          layout: program._gpuLayout.bindGroups[groupIndex],
          entries
        });
        this._hash[group.key] = gpuBindGroup;
        return gpuBindGroup;
      }
      destroy() {
        for (const key of Object.keys(this._hash)) {
          this._hash[key] = null;
        }
        this._hash = null;
        const writeable = this;
        writeable._renderer = null;
      }
    };
    BindGroupSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "bindGroup"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs
var BufferSystem;
var init_GpuBufferSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs"() {
    init_Extensions();
    init_fastCopy();
    BufferSystem = class {
      constructor() {
        this._gpuBuffers = /* @__PURE__ */ Object.create(null);
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
      getGPUBuffer(buffer) {
        return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
      }
      updateBuffer(buffer) {
        const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
        if (buffer._updateID && buffer.data) {
          buffer._updateID = 0;
          this._gpu.device.queue.writeBuffer(gpuBuffer, 0, buffer.data.buffer, 0, buffer._updateSize);
        }
        return gpuBuffer;
      }
      /** dispose all WebGL resources of all managed buffers */
      destroyAll() {
        for (const id in this._gpuBuffers) {
          this._gpuBuffers[id].destroy();
        }
        this._gpuBuffers = {};
      }
      createGPUBuffer(buffer) {
        const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);
        buffer._updateID = 0;
        if (buffer.data) {
          fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());
          gpuBuffer.unmap();
        }
        this._gpuBuffers[buffer.uid] = gpuBuffer;
        buffer.on("update", this.updateBuffer, this);
        buffer.on("change", this.onBufferChange, this);
        buffer.on("destroy", this.onBufferDestroy, this);
        return gpuBuffer;
      }
      onBufferChange(buffer) {
        let gpuBuffer = this._gpuBuffers[buffer.uid];
        gpuBuffer.destroy();
        gpuBuffer = this.createGPUBuffer(buffer);
        buffer._updateID = 0;
      }
      /**
       * Disposes buffer
       * @param buffer - buffer with data
       */
      onBufferDestroy(buffer) {
        const gpuBuffer = this._gpuBuffers[buffer.uid];
        gpuBuffer.destroy();
        this._gpuBuffers[buffer.uid] = null;
      }
      destroy() {
        for (const k3 of Object.keys(this._gpuBuffers)) {
          const key = Number(k3);
          const gpuBuffer = this._gpuBuffers[key];
          gpuBuffer.destroy();
          this._gpuBuffers[key] = null;
        }
        this._gpuBuffers = null;
        const writeable = this;
        writeable._renderer = null;
      }
    };
    BufferSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "buffer"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs
var GpuColorMaskSystem;
var init_GpuColorMaskSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs"() {
    init_Extensions();
    GpuColorMaskSystem = class {
      constructor(renderer) {
        this._colorMaskCache = 15;
        this._renderer = renderer;
      }
      setMask(colorMask) {
        if (this._colorMaskCache === colorMask)
          return;
        this._colorMaskCache = colorMask;
        this._renderer.pipeline.setColorMask(colorMask);
      }
      destroy() {
        const writeable = this;
        writeable._renderer = null;
        this._colorMaskCache = null;
      }
    };
    GpuColorMaskSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "colorMask"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs
var GpuDeviceSystem;
var init_GpuDeviceSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs"() {
    init_Extensions();
    GpuDeviceSystem = class {
      /**
       * @param {WebGPURenderer} renderer - The renderer this System works for.
       */
      constructor(renderer) {
        this._renderer = renderer;
      }
      async init() {
        if (this._initPromise)
          return this._initPromise;
        this._initPromise = this._createDeviceAndAdaptor({}).then((gpu) => {
          this.gpu = gpu;
          this._renderer.runners.contextChange.emit(this.gpu);
        });
        return this._initPromise;
      }
      /**
       * Handle the context change event
       * @param gpu
       */
      contextChange(gpu) {
        this._renderer.gpu = gpu;
      }
      /**
       * Helper class to create a WebGL Context
       * @param {object} options - An options object that gets passed in to the canvas element containing the
       *    context attributes
       * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
       * @returns {WebGLRenderingContext} the WebGL context
       */
      async _createDeviceAndAdaptor(options) {
        const adapter = await navigator.gpu.requestAdapter(options);
        const device = await adapter.requestDevice();
        return { adapter, device };
      }
      destroy() {
        this.gpu = null;
        this._renderer = null;
      }
    };
    GpuDeviceSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "device"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs
var GpuEncoderSystem;
var init_GpuEncoderSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs"() {
    init_Extensions();
    GpuEncoderSystem = class {
      constructor(renderer) {
        this._boundBindGroup = /* @__PURE__ */ Object.create(null);
        this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      start() {
        this.commandFinished = new Promise((resolve) => {
          this._resolveCommandFinished = resolve;
        });
        this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();
      }
      beginRenderPass(renderTarget, gpuRenderTarget) {
        if (this.renderPassEncoder) {
          this.renderPassEncoder.end();
        }
        this._clearCache();
        this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);
        this._setViewport(renderTarget.viewport);
      }
      _setViewport(viewport) {
        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
      }
      setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {
        const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);
        this.setPipeline(pipeline);
      }
      setPipeline(pipeline) {
        if (this._boundPipeline === pipeline)
          return;
        this._boundPipeline = pipeline;
        this.renderPassEncoder.setPipeline(pipeline);
      }
      _setVertexBuffer(index, buffer) {
        if (this._boundVertexBuffer[index] === buffer)
          return;
        this._boundVertexBuffer[index] = buffer;
        this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));
      }
      _setIndexBuffer(buffer) {
        if (this._boundIndexBuffer === buffer)
          return;
        this._boundIndexBuffer = buffer;
        this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), "uint32");
      }
      setBindGroup(index, bindGroup, program) {
        if (this._boundBindGroup[index] === bindGroup)
          return;
        this._boundBindGroup[index] = bindGroup;
        bindGroup.touch(this._renderer.textureGC.count);
        const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);
        this.renderPassEncoder.setBindGroup(index, gpuBindGroup);
      }
      setGeometry(geometry) {
        for (const i2 in geometry.attributes) {
          const attribute = geometry.attributes[i2];
          this._setVertexBuffer(attribute.shaderLocation, attribute.buffer);
        }
        if (geometry.indexBuffer) {
          this._setIndexBuffer(geometry.indexBuffer);
        }
      }
      _setShaderBindGroups(shader, skipSync) {
        for (const i2 in shader.groups) {
          const bindGroup = shader.groups[i2];
          if (!skipSync) {
            this._syncBindGroup(bindGroup);
          }
          this.setBindGroup(i2, bindGroup, shader.gpuProgram);
        }
      }
      _syncBindGroup(bindGroup) {
        for (const j3 in bindGroup.resources) {
          const resource = bindGroup.resources[j3];
          if (resource.isUniformGroup) {
            this._renderer.uniformBuffer.updateUniformGroup(resource);
          }
        }
      }
      draw(options) {
        const { geometry, shader, state, topology, size: size2, start, instanceCount, skipSync } = options;
        this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);
        this.setGeometry(geometry);
        this._setShaderBindGroups(shader, skipSync);
        if (geometry.indexBuffer) {
          this.renderPassEncoder.drawIndexed(size2 || geometry.indexBuffer.data.length, instanceCount || 1, start || 0);
        } else {
          this.renderPassEncoder.draw(size2 || geometry.getSize(), instanceCount || 1, start || 0);
        }
      }
      finishRenderPass() {
        if (this.renderPassEncoder) {
          this.renderPassEncoder.end();
          this.renderPassEncoder = null;
        }
      }
      postrender() {
        this.finishRenderPass();
        this._gpu.device.queue.submit([this.commandEncoder.finish()]);
        this._resolveCommandFinished();
      }
      // restores a render pass if finishRenderPass was called
      // not optimised as really used for debugging!
      // used when we want to stop drawing and log a texture..
      restoreRenderPass() {
        const descriptor = this._renderer.renderTarget.getDescriptor(
          this._renderer.renderTarget.renderTarget,
          false,
          [0, 0, 0, 1]
        );
        this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);
        const boundPipeline = this._boundPipeline;
        const boundVertexBuffer = { ...this._boundVertexBuffer };
        const boundIndexBuffer = this._boundIndexBuffer;
        const boundBindGroup = { ...this._boundBindGroup };
        this._clearCache();
        const viewport = this._renderer.renderTarget.renderTarget.viewport;
        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
        this.setPipeline(boundPipeline);
        for (const i2 in boundVertexBuffer) {
          this._setVertexBuffer(i2, boundVertexBuffer[i2]);
        }
        for (const i2 in boundBindGroup) {
          this.setBindGroup(i2, boundBindGroup[i2], null);
        }
        this._setIndexBuffer(boundIndexBuffer);
      }
      _clearCache() {
        for (let i2 = 0; i2 < 16; i2++) {
          this._boundBindGroup[i2] = null;
          this._boundVertexBuffer[i2] = null;
        }
        this._boundIndexBuffer = null;
        this._boundPipeline = null;
      }
      destroy() {
        const writeable = this;
        writeable._renderer = null;
        this._gpu = null;
        this._boundBindGroup = null;
        this._boundVertexBuffer = null;
        this._boundIndexBuffer = null;
        this._boundPipeline = null;
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
    };
    GpuEncoderSystem.extension = {
      type: [ExtensionType.WebGPUSystem],
      name: "encoder"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs
var GpuStencilSystem;
var init_GpuStencilSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs"() {
    init_Extensions();
    init_const8();
    GpuStencilSystem = class {
      constructor(renderer) {
        this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
        renderer.renderTarget.onRenderTargetChange.add(this);
      }
      onRenderTargetChange(renderTarget) {
        let stencilState = this._renderTargetStencilState[renderTarget.uid];
        if (!stencilState) {
          stencilState = this._renderTargetStencilState[renderTarget.uid] = {
            stencilMode: STENCIL_MODES.DISABLED,
            stencilReference: 0
          };
        }
        this._activeRenderTarget = renderTarget;
        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
      }
      setStencilMode(stencilMode, stencilReference) {
        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
        stencilState.stencilMode = stencilMode;
        stencilState.stencilReference = stencilReference;
        const renderer = this._renderer;
        renderer.pipeline.setStencilMode(stencilMode);
        renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);
      }
      destroy() {
        this._renderer.renderTarget.onRenderTargetChange.remove(this);
        const writeable = this;
        writeable._renderer = null;
        this._activeRenderTarget = null;
        this._renderTargetStencilState = null;
      }
    };
    GpuStencilSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "stencil"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs
var BufferResource;
var init_BufferResource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs"() {
    init_eventemitter3();
    init_uid();
    BufferResource = class extends eventemitter3_default {
      constructor({ buffer, offset, size: size2 }) {
        super();
        this.uid = uid("buffer");
        this.touched = 0;
        this.resourceType = "bufferResource";
        this.resourceId = uid("buffer");
        this.bufferResource = true;
        this.buffer = buffer;
        this.offset = offset;
        this.size = size2;
        this.buffer.on("change", this.onBufferChange, this);
      }
      onBufferChange() {
        this.resourceId = uid("buffer");
        this.emit("change", this);
      }
      destroy(destroyBuffer = false) {
        if (destroyBuffer) {
          this.buffer.destroy();
        }
        this.buffer = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UniformBufferBatch.mjs
var UniformBufferBatch;
var init_UniformBufferBatch = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UniformBufferBatch.mjs"() {
    UniformBufferBatch = class {
      constructor({ minUniformOffsetAlignment: minUniformOffsetAlignment2 }) {
        this._minUniformOffsetAlignment = 256;
        this.byteIndex = 0;
        this._minUniformOffsetAlignment = minUniformOffsetAlignment2;
        this.data = new Float32Array(65535);
      }
      clear() {
        this.byteIndex = 0;
      }
      addEmptyGroup(size2) {
        if (size2 > this._minUniformOffsetAlignment / 4) {
          throw new Error(`UniformBufferBatch: array is too large: ${size2 * 4}`);
        }
        const start = this.byteIndex;
        let newSize = start + size2 * 4;
        newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;
        if (newSize > this.data.length * 4) {
          throw new Error("UniformBufferBatch: ubo batch got too big");
        }
        this.byteIndex = newSize;
        return start;
      }
      addGroup(array) {
        const offset = this.addEmptyGroup(array.length);
        for (let i2 = 0; i2 < array.length; i2++) {
          this.data[offset / 4 + i2] = array[i2];
        }
        return offset;
      }
      destroy() {
        this._buffer.destroy();
        this._buffer = null;
        this.data = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs
var minUniformOffsetAlignment, GpuUniformBatchPipe;
var init_GpuUniformBatchPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs"() {
    init_Extensions();
    init_Buffer();
    init_BufferResource();
    init_const5();
    init_UniformBufferBatch();
    init_BindGroup();
    minUniformOffsetAlignment = 128;
    GpuUniformBatchPipe = class {
      constructor(renderer) {
        this._bindGroupHash = /* @__PURE__ */ Object.create(null);
        this._buffers = [];
        this._bindGroups = [];
        this._bufferResources = [];
        this._renderer = renderer;
        this._batchBuffer = new UniformBufferBatch({ minUniformOffsetAlignment });
        const totalBuffers = 256 / minUniformOffsetAlignment;
        for (let i2 = 0; i2 < totalBuffers; i2++) {
          let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;
          if (i2 === 0)
            usage |= BufferUsage.COPY_SRC;
          this._buffers.push(new Buffer2({
            data: this._batchBuffer.data,
            usage
          }));
        }
      }
      renderEnd() {
        this._uploadBindGroups();
        this._resetBindGroups();
      }
      _resetBindGroups() {
        for (const i2 in this._bindGroupHash) {
          this._bindGroupHash[i2] = null;
        }
        this._batchBuffer.clear();
      }
      // just works for single bind groups for now
      getUniformBindGroup(group, duplicate) {
        if (!duplicate && this._bindGroupHash[group.uid]) {
          return this._bindGroupHash[group.uid];
        }
        this._renderer.uniformBuffer.ensureUniformGroup(group);
        const data = group.buffer.data;
        const offset = this._batchBuffer.addEmptyGroup(data.length);
        this._renderer.uniformBuffer.syncUniformGroup(group, this._batchBuffer.data, offset / 4);
        this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);
        return this._bindGroupHash[group.uid];
      }
      getUniformBufferResource(group) {
        this._renderer.uniformBuffer.updateUniformGroup(group);
        const data = group.buffer.data;
        const offset = this._batchBuffer.addGroup(data);
        return this._getBufferResource(offset / minUniformOffsetAlignment);
      }
      getArrayBindGroup(data) {
        const offset = this._batchBuffer.addGroup(data);
        return this._getBindGroup(offset / minUniformOffsetAlignment);
      }
      getArrayBufferResource(data) {
        const offset = this._batchBuffer.addGroup(data);
        const index = offset / minUniformOffsetAlignment;
        return this._getBufferResource(index);
      }
      _getBufferResource(index) {
        if (!this._bufferResources[index]) {
          const buffer = this._buffers[index % 2];
          this._bufferResources[index] = new BufferResource({
            buffer,
            offset: (index / 2 | 0) * 256,
            size: minUniformOffsetAlignment
          });
        }
        return this._bufferResources[index];
      }
      _getBindGroup(index) {
        if (!this._bindGroups[index]) {
          const bindGroup = new BindGroup({
            0: this._getBufferResource(index)
          });
          this._bindGroups[index] = bindGroup;
        }
        return this._bindGroups[index];
      }
      _uploadBindGroups() {
        const bufferSystem = this._renderer.buffer;
        const firstBuffer = this._buffers[0];
        firstBuffer.update(this._batchBuffer.byteIndex);
        bufferSystem.updateBuffer(firstBuffer);
        const commandEncoder = this._renderer.gpu.device.createCommandEncoder();
        for (let i2 = 1; i2 < this._buffers.length; i2++) {
          const buffer = this._buffers[i2];
          commandEncoder.copyBufferToBuffer(
            bufferSystem.getGPUBuffer(firstBuffer),
            minUniformOffsetAlignment,
            bufferSystem.getGPUBuffer(buffer),
            0,
            this._batchBuffer.byteIndex
          );
        }
        this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);
      }
      destroy() {
        for (let i2 = 0; i2 < this._bindGroups.length; i2++) {
          this._bindGroups[i2].destroy();
        }
        this._bindGroups = null;
        this._bindGroupHash = null;
        for (let i2 = 0; i2 < this._buffers.length; i2++) {
          this._buffers[i2].destroy();
        }
        this._buffers = null;
        for (let i2 = 0; i2 < this._bufferResources.length; i2++) {
          this._bufferResources[i2].destroy();
        }
        this._bufferResources = null;
        this._batchBuffer.destroy();
        this._bindGroupHash = null;
        this._renderer = null;
      }
    };
    GpuUniformBatchPipe.extension = {
      type: [
        ExtensionType.WebGPUPipes
      ],
      name: "uniformBatch"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBufferPipe.mjs
var UniformBindGroup, GpuUniformBufferPipe;
var init_GpuUniformBufferPipe = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBufferPipe.mjs"() {
    init_Extensions();
    init_PoolGroup();
    init_Buffer();
    init_const5();
    init_BindGroup();
    UniformBindGroup = class extends BindGroup {
      constructor() {
        super({
          0: new Buffer2({
            data: new Float32Array(128),
            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
          })
        });
      }
      get buffer() {
        return this.resources[0];
      }
      get data() {
        return this.resources[0].data;
      }
    };
    GpuUniformBufferPipe = class {
      constructor(renderer) {
        this._activeBindGroups = [];
        this._activeBindGroupIndex = 0;
        this._renderer = renderer;
      }
      getUniformBindGroup(uniformGroup) {
        const renderer = this._renderer;
        renderer.uniformBuffer.ensureUniformGroup(uniformGroup);
        const bindGroup = BigPool.get(UniformBindGroup);
        renderer.uniformBuffer.syncUniformGroup(uniformGroup, bindGroup.data, 0);
        bindGroup.buffer.update(uniformGroup.buffer.data.byteLength);
        this._activeBindGroups[this._activeBindGroupIndex++] = bindGroup;
        return bindGroup;
      }
      renderEnd() {
        for (let i2 = 0; i2 < this._activeBindGroupIndex; i2++) {
          BigPool.return(this._activeBindGroups[i2]);
        }
        this._activeBindGroupIndex = 0;
      }
    };
    GpuUniformBufferPipe.extension = {
      type: [
        ExtensionType.WebGPUPipes
      ],
      name: "uniformBuffer"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs
var GpuStencilModesToPixi;
var init_GpuStencilModesToPixi = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs"() {
    init_const8();
    GpuStencilModesToPixi = [];
    GpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;
    GpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {
      format: "stencil8",
      depthCompare: "always",
      depthWriteEnabled: false,
      stencilWriteMask: 0,
      stencilReadMask: 0,
      stencilBack: {
        compare: "always",
        passOp: "keep"
      }
    };
    GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {
      format: "stencil8",
      depthCompare: "always",
      depthWriteEnabled: false,
      stencilBack: {
        compare: "always",
        passOp: "increment-clamp"
      }
    };
    GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {
      format: "stencil8",
      depthCompare: "always",
      depthWriteEnabled: false,
      stencilBack: {
        compare: "always",
        passOp: "increment-clamp"
      }
    };
    GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {
      format: "stencil8",
      depthCompare: "always",
      depthWriteEnabled: false,
      stencilBack: {
        compare: "always",
        passOp: "decrement-clamp"
      }
    };
    GpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {
      format: "stencil8",
      depthCompare: "always",
      depthWriteEnabled: false,
      stencilWriteMask: 0,
      stencilBack: {
        compare: "equal",
        passOp: "keep"
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs
function getKey(geometryId, programId, stateId, blendModeId, stencilStateId, multiSampleCount, colorMask, topology) {
  return geometryId << 26 | programId << 18 | colorMask << 14 | stateId << 8 | blendModeId << 3 | topology << 1 | stencilStateId << 4 | multiSampleCount;
}
var topologyStringToId, PipelineSystem;
var init_PipelineSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs"() {
    init_Extensions();
    init_const8();
    init_createIdFromString();
    init_GpuStencilModesToPixi();
    topologyStringToId = {
      "point-list": 0,
      "line-list": 1,
      "line-strip": 2,
      "triangle-list": 3,
      "triangle-strip": 4
    };
    PipelineSystem = class {
      constructor(renderer) {
        this._moduleCache = /* @__PURE__ */ Object.create(null);
        this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);
        this._pipeCache = /* @__PURE__ */ Object.create(null);
        this._colorMask = 15;
        this._multisampleCount = 1;
        this._renderer = renderer;
      }
      contextChange(gpu) {
        this._gpu = gpu;
        this.setStencilMode(STENCIL_MODES.DISABLED);
      }
      setMultisampleCount(multisampleCount) {
        this._multisampleCount = multisampleCount;
      }
      setColorMask(colorMask) {
        this._colorMask = colorMask;
      }
      setStencilMode(stencilMode) {
        this._stencilMode = stencilMode;
        this._stencilState = GpuStencilModesToPixi[stencilMode];
      }
      setPipeline(geometry, program, state, passEncoder) {
        const pipeline = this.getPipeline(geometry, program, state);
        passEncoder.setPipeline(pipeline);
      }
      getPipeline(geometry, program, state, topology) {
        if (!geometry._layoutKey) {
          this._generateBufferKey(geometry);
        }
        if (!program._layoutKey) {
          this._generateProgramKey(program);
          this._renderer.shader.createProgramLayout(program);
        }
        topology = topology || geometry.topology;
        const key = getKey(
          geometry._layoutKey,
          program._layoutKey,
          state.data,
          state._blendModeId,
          this._stencilMode,
          this._multisampleCount,
          this._colorMask,
          topologyStringToId[topology]
        );
        if (this._pipeCache[key])
          return this._pipeCache[key];
        this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);
        return this._pipeCache[key];
      }
      _createPipeline(geometry, program, state, topology) {
        const device = this._gpu.device;
        const buffers = this._createVertexBufferLayouts(geometry);
        const blendModes = this._renderer.state.getColorTargets(state);
        let depthStencil = this._stencilState;
        depthStencil = GpuStencilModesToPixi[this._stencilMode];
        blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;
        const descriptor = {
          // TODO later check if its helpful to create..
          // layout,
          vertex: {
            module: this._getModule(program.vertex.source),
            entryPoint: program.vertex.entryPoint,
            // geometry..
            buffers
          },
          fragment: {
            module: this._getModule(program.fragment.source),
            entryPoint: program.fragment.entryPoint,
            targets: blendModes
          },
          primitive: {
            topology,
            cullMode: state.cullMode
          },
          layout: program._gpuLayout.pipeline,
          multisample: {
            count: this._multisampleCount
          },
          depthStencil,
          label: `PIXI Pipeline`
        };
        const pipeline = device.createRenderPipeline(descriptor);
        return pipeline;
      }
      _getModule(code) {
        return this._moduleCache[code] || this._createModule(code);
      }
      _createModule(code) {
        const device = this._gpu.device;
        this._moduleCache[code] = device.createShaderModule({
          code
        });
        return this._moduleCache[code];
      }
      _generateProgramKey(program) {
        const { vertex: vertex2, fragment: fragment2 } = program;
        const bigKey = vertex2.source + fragment2.source + vertex2.entryPoint + fragment2.entryPoint;
        program._layoutKey = createIdFromString(bigKey, "program");
        return program._layoutKey;
      }
      _generateBufferKey(geometry) {
        const keyGen = [];
        let index = 0;
        const attributeKeys = Object.keys(geometry.attributes).sort();
        for (let i2 = 0; i2 < attributeKeys.length; i2++) {
          const attribute = geometry.attributes[attributeKeys[i2]];
          keyGen[index++] = attribute.shaderLocation;
          keyGen[index++] = attribute.offset;
          keyGen[index++] = attribute.format;
          keyGen[index++] = attribute.stride;
        }
        const stringKey = keyGen.join("");
        geometry._layoutKey = createIdFromString(stringKey, "geometry");
        return geometry._layoutKey;
      }
      _createVertexBufferLayouts(geometry) {
        if (this._bufferLayoutsCache[geometry._layoutKey]) {
          return this._bufferLayoutsCache[geometry._layoutKey];
        }
        const vertexBuffersLayout = [];
        geometry.buffers.forEach((buffer) => {
          const bufferEntry = {
            arrayStride: 0,
            stepMode: "vertex",
            attributes: []
          };
          const bufferEntryAttributes = bufferEntry.attributes;
          for (const i2 in geometry.attributes) {
            const attribute = geometry.attributes[i2];
            if (attribute.buffer === buffer) {
              bufferEntry.arrayStride = attribute.stride;
              bufferEntryAttributes.push({
                shaderLocation: attribute.shaderLocation,
                offset: attribute.offset,
                format: attribute.format
              });
            }
          }
          if (bufferEntryAttributes.length) {
            vertexBuffersLayout.push(bufferEntry);
          }
        });
        this._bufferLayoutsCache[geometry._layoutKey] = vertexBuffersLayout;
        return vertexBuffersLayout;
      }
      destroy() {
        const writeable = this;
        writeable._renderer = null;
        this._bufferLayoutsCache = null;
      }
    };
    PipelineSystem.extension = {
      type: [ExtensionType.WebGPUSystem],
      name: "pipeline"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs
function isRenderingToScreen(renderTarget) {
  const resource = renderTarget.colorTexture.source.resource;
  return resource instanceof HTMLCanvasElement && document.body.contains(resource);
}
var init_isRenderingToScreen = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs
function calculateProjection(pm, x3, y2, width, height, flipY) {
  const sign = flipY ? 1 : -1;
  pm.identity();
  pm.a = 1 / width * 2;
  pm.d = sign * (1 / height * 2);
  pm.tx = -1 - x3 * pm.a;
  pm.ty = -sign - y2 * pm.d;
  return pm;
}
var init_calculateProjection = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs
var _RenderTarget, RenderTarget;
var init_RenderTarget = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs"() {
    init_Matrix();
    init_Rectangle();
    init_uid();
    init_calculateProjection();
    init_TextureSource();
    init_Texture();
    _RenderTarget = class {
      constructor(descriptor = {}) {
        this.uid = uid("renderTarget");
        this.width = 0;
        this.height = 0;
        this.resolution = 1;
        this.colorTextures = [];
        this.dirtyId = 0;
        this.isRoot = false;
        this._projectionMatrix = new Matrix();
        this._size = new Float32Array(2);
        descriptor = { ..._RenderTarget.defaultDescriptor, ...descriptor };
        this.width = descriptor.width;
        this.height = descriptor.height;
        this.resolution = descriptor.resolution;
        this.stencil = descriptor.stencil;
        this._viewport = new Rectangle(0, 0, this.width, this.height);
        if (typeof descriptor.colorTextures === "number") {
          for (let i2 = 0; i2 < descriptor.colorTextures; i2++) {
            this.colorTextures.push(new Texture({
              source: new TextureSource({
                width: this.width,
                height: this.height,
                resolution: descriptor.resolution,
                antialias: descriptor.antialias
              })
            }));
          }
        } else {
          this.colorTextures = [...descriptor.colorTextures];
          const colorSource = this.colorTexture.source;
          this._resize(colorSource.width, colorSource.height, colorSource._resolution);
        }
        this.colorTexture.source.on("resize", this.onSourceResize, this);
        if (descriptor.depthTexture) {
          this.depthTexture = new Texture({
            source: new TextureSource({
              width: this.width,
              height: this.height,
              resolution: this.resolution,
              format: "stencil8"
              // sampleCount: handled by the render target system..
            })
          });
        }
      }
      get size() {
        const _size = this._size;
        _size[0] = this.pixelWidth;
        _size[1] = this.pixelHeight;
        return _size;
      }
      get pixelWidth() {
        return this.width * this.resolution;
      }
      get pixelHeight() {
        return this.height * this.resolution;
      }
      get colorTexture() {
        return this.colorTextures[0];
      }
      get projectionMatrix() {
        const texture = this.colorTexture;
        calculateProjection(this._projectionMatrix, 0, 0, texture.frameWidth, texture.frameHeight, !this.isRoot);
        return this._projectionMatrix;
      }
      get viewport() {
        const texture = this.colorTexture;
        const source3 = texture.source;
        const pixelWidth = source3.pixelWidth;
        const pixelHeight = source3.pixelHeight;
        const viewport = this._viewport;
        const frame = texture.layout.frame;
        viewport.x = frame.x * pixelWidth | 0;
        viewport.y = frame.y * pixelHeight | 0;
        viewport.width = frame.width * pixelWidth | 0;
        viewport.height = frame.height * pixelHeight | 0;
        return viewport;
      }
      onSourceResize(source3) {
        this._resize(source3.width, source3.height, source3._resolution, true);
      }
      _resize(width, height, resolution = this.resolution, skipColorTexture = false) {
        this.width = width;
        this.height = height;
        this.resolution = resolution;
        this.dirtyId++;
        this.colorTextures.forEach((colorTexture, i2) => {
          if (skipColorTexture && i2 === 0)
            return;
          colorTexture.source.resize(width, height, resolution);
        });
        if (this.depthTexture) {
          this.depthTexture.source.resize(width, height, resolution);
        }
      }
      destroy() {
        throw new Error("Method not implemented.");
      }
    };
    RenderTarget = _RenderTarget;
    RenderTarget.defaultDescriptor = {
      width: 0,
      height: 0,
      resolution: 1,
      colorTextures: 1,
      stencil: true,
      antialias: false
      // save on perf by default!
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs
var GpuRenderTarget;
var init_GpuRenderTarget = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs"() {
    GpuRenderTarget = class {
      constructor() {
        this.contexts = [];
        this.msaaTextures = [];
        this.msaaSamples = 1;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs
var GpuRenderTargetSystem;
var init_GpuRenderTargetSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs"() {
    init_Extensions();
    init_Matrix();
    init_const7();
    init_isRenderingToScreen();
    init_RenderTarget();
    init_SystemRunner();
    init_TextureSource();
    init_Texture();
    init_getCanvasTexture();
    init_GpuRenderTarget();
    GpuRenderTargetSystem = class {
      constructor(renderer) {
        this.rootProjectionMatrix = new Matrix();
        this.onRenderTargetChange = new SystemRunner("onRenderTargetChange");
        this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();
        this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
        this._renderTargetStack = [];
        this._defaultClearColor = [0, 0, 0, 0];
        this._renderer = renderer;
      }
      renderStart({
        target,
        clear,
        clearColor
      }) {
        this.rootRenderTarget = this.getRenderTarget(target);
        this.rootProjectionMatrix = this.rootRenderTarget.projectionMatrix;
        this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);
        this._renderTargetStack.length = 0;
        this._renderer.encoder.start();
        this.push(
          this.rootRenderTarget,
          clear,
          clearColor ?? this._renderer.background.colorRgba
        );
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
      bind(renderSurface, clear = true, clearColor) {
        const renderTarget = this.getRenderTarget(renderSurface);
        const didChange = this.renderTarget !== renderTarget;
        this.renderTarget = renderTarget;
        this._startRenderPass(clear, clearColor);
        if (didChange) {
          this.onRenderTargetChange.emit(renderTarget);
        }
        return renderTarget;
      }
      /**
       * returns the gpu texture for the first color texture in the render target
       * mainly used by the filter manager to get copy the texture for blending
       * @param renderTarget
       * @returns a gpu texture
       */
      _getGpuColorTexture(renderTarget) {
        const gpuRenderTarget = this._getGpuRenderTarget(renderTarget);
        if (gpuRenderTarget.contexts[0]) {
          return gpuRenderTarget.contexts[0].getCurrentTexture();
        }
        return this._renderer.texture.getGpuSource(
          renderTarget.colorTextures[0].source
        );
      }
      getDescriptor(renderTarget, clear, clearValue) {
        if (typeof clear === "boolean") {
          clear = clear ? CLEAR.ALL : CLEAR.NONE;
        }
        const gpuRenderTarget = this._getGpuRenderTarget(renderTarget);
        const colorAttachments = renderTarget.colorTextures.map(
          (texture, i2) => {
            const context2 = gpuRenderTarget.contexts[i2];
            let view;
            let resolveTarget;
            if (context2) {
              const currentTexture = context2.getCurrentTexture();
              const canvasTextureView = currentTexture.createView();
              view = canvasTextureView;
            } else {
              view = this._renderer.texture.getTextureView(texture);
            }
            if (gpuRenderTarget.msaaTextures[i2]) {
              resolveTarget = view;
              view = this._renderer.texture.getTextureView(
                gpuRenderTarget.msaaTextures[i2]
              );
            }
            const loadOp = clear & CLEAR.COLOR ? "clear" : "load";
            clearValue ?? (clearValue = this._defaultClearColor);
            return {
              view,
              // assign each frame based on the swap chain!
              resolveTarget,
              clearValue,
              storeOp: "store",
              loadOp
            };
          }
        );
        let depthStencilAttachment;
        if (renderTarget.depthTexture) {
          const stencilLoadOp = clear & CLEAR.STENCIL ? "clear" : "load";
          depthStencilAttachment = {
            view: this._renderer.texture.getGpuSource(renderTarget.depthTexture.source).createView(),
            stencilStoreOp: "store",
            stencilLoadOp
          };
        }
        const descriptor = {
          colorAttachments,
          depthStencilAttachment
        };
        return descriptor;
      }
      clear(clear = CLEAR.ALL, clearColor) {
        if (!clear)
          return;
        this._startRenderPass(
          clear,
          clearColor
        );
      }
      push(renderSurface, clear = CLEAR.ALL, clearColor) {
        const renderTarget = this.bind(renderSurface, clear, clearColor);
        this._renderTargetStack.push(renderTarget);
        return renderTarget;
      }
      pop() {
        this._renderTargetStack.pop();
        this.bind(
          this._renderTargetStack[this._renderTargetStack.length - 1],
          false
        );
      }
      getRenderTarget(renderSurface) {
        return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);
      }
      copyToTexture(sourceRenderSurfaceTexture, destinationTexture, origin, size2) {
        const renderer = this._renderer;
        const baseGpuTexture = renderer.renderTarget._getGpuColorTexture(
          sourceRenderSurfaceTexture
        );
        const backGpuTexture = renderer.texture.getGpuSource(
          destinationTexture.source
        );
        renderer.encoder.commandEncoder.copyTextureToTexture(
          {
            texture: baseGpuTexture,
            origin
          },
          {
            texture: backGpuTexture
          },
          size2
        );
        return destinationTexture;
      }
      restart() {
        this.bind(this.rootRenderTarget, CLEAR.NONE);
      }
      destroy() {
        const writeable = this;
        writeable._renderer = null;
        this._renderSurfaceToRenderTargetHash.clear();
      }
      _startRenderPass(clear = true, clearColor) {
        const renderTarget = this.renderTarget;
        const gpuRenderTarget = this._getGpuRenderTarget(renderTarget);
        if (renderTarget.width !== gpuRenderTarget.width || renderTarget.height !== gpuRenderTarget.height) {
          this._resizeGpuRenderTarget(renderTarget);
        }
        const descriptor = this.getDescriptor(renderTarget, clear, clearColor);
        gpuRenderTarget.descriptor = descriptor;
        this._renderer.encoder.beginRenderPass(renderTarget, gpuRenderTarget);
        this._renderer.pipeline.setMultisampleCount(gpuRenderTarget.msaaSamples);
      }
      _initRenderTarget(renderSurface) {
        let renderTarget = null;
        if (renderSurface instanceof HTMLCanvasElement) {
          renderSurface = getCanvasTexture(renderSurface);
        }
        if (renderSurface instanceof RenderTarget) {
          renderTarget = renderSurface;
        } else if (renderSurface instanceof Texture) {
          renderTarget = new RenderTarget({
            colorTextures: [renderSurface],
            depthTexture: renderSurface.source.depthStencil
          });
        }
        renderTarget.isRoot = true;
        this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);
        return renderTarget;
      }
      _getGpuRenderTarget(renderTarget) {
        return this._gpuRenderTargetHash[renderTarget.uid] || this._initGpuRenderTarget(renderTarget);
      }
      _initGpuRenderTarget(renderTarget) {
        renderTarget.isRoot = true;
        const gpuRenderTarget = new GpuRenderTarget();
        renderTarget.colorTextures.forEach((colorTexture, i2) => {
          if (colorTexture.source.resource instanceof HTMLCanvasElement) {
            const context2 = renderTarget.colorTexture.source.resource.getContext(
              "webgpu"
            );
            try {
              context2.configure({
                device: this._gpu.device,
                // eslint-disable-next-line max-len
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
                format: "bgra8unorm",
                alphaMode: "opaque"
              });
            } catch (e2) {
              console.error(e2);
            }
            gpuRenderTarget.contexts[i2] = context2;
          }
          gpuRenderTarget.msaa = colorTexture.source.antialias;
          if (colorTexture.source.antialias) {
            const msaaTexture = new TextureSource({
              width: 0,
              height: 0,
              sampleCount: 4
            });
            gpuRenderTarget.msaaTextures[i2] = msaaTexture;
          }
        });
        if (gpuRenderTarget.msaa) {
          gpuRenderTarget.msaaSamples = 4;
          if (renderTarget.depthTexture) {
            renderTarget.depthTexture.source.sampleCount = 4;
          }
        }
        this._gpuRenderTargetHash[renderTarget.uid] = gpuRenderTarget;
        return gpuRenderTarget;
      }
      _resizeGpuRenderTarget(renderTarget) {
        const gpuRenderTarget = this._getGpuRenderTarget(renderTarget);
        gpuRenderTarget.width = renderTarget.width;
        gpuRenderTarget.height = renderTarget.height;
        if (gpuRenderTarget.msaa) {
          renderTarget.colorTextures.forEach((colorTexture, i2) => {
            const msaaTexture = gpuRenderTarget.msaaTextures[i2];
            msaaTexture?.resize(
              colorTexture.source.width,
              colorTexture.source.height,
              colorTexture.source._resolution
            );
          });
        }
      }
    };
    GpuRenderTargetSystem.extension = {
      type: [ExtensionType.WebGPUSystem],
      name: "renderTarget"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs
var GpuShaderSystem;
var init_GpuShaderSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs"() {
    init_Extensions();
    GpuShaderSystem = class {
      contextChange(gpu) {
        this._gpu = gpu;
      }
      createProgramLayout(program) {
        const device = this._gpu.device;
        if (!program._gpuLayout) {
          if (program.gpuLayout) {
            const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));
            const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };
            program._gpuLayout = {
              bindGroups,
              pipeline: device.createPipelineLayout(pipelineLayoutDesc)
            };
          } else {
            program._gpuLayout = {
              bindGroups: null,
              pipeline: "auto"
            };
          }
        }
      }
      destroy() {
        this._gpu = null;
      }
    };
    GpuShaderSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "shader"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs
var GpuBlendModesToPixi;
var init_GpuBlendModesToPixi = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs"() {
    GpuBlendModesToPixi = {};
    GpuBlendModesToPixi.normal = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.add = {
      alpha: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.multiply = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "dst",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.screen = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.overlay = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.none = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "zero",
        dstFactor: "zero",
        operation: "add"
      }
    };
    GpuBlendModesToPixi["normal-npm"] = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      }
    };
    GpuBlendModesToPixi["add-npm"] = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "add"
      },
      color: {
        srcFactor: "src-alpha",
        dstFactor: "one",
        operation: "add"
      }
    };
    GpuBlendModesToPixi["screen-npm"] = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.erase = {
      alpha: {
        srcFactor: "zero",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "zero",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs
var GpuStateSystem;
var init_GpuStateSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs"() {
    init_Extensions();
    init_State();
    init_GpuBlendModesToPixi();
    GpuStateSystem = class {
      constructor() {
        this.defaultState = new State();
        this.defaultState.blend = true;
      }
      contextChange(gpu) {
        this.gpu = gpu;
      }
      getColorTargets(state) {
        const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;
        return [
          {
            format: "bgra8unorm",
            writeMask: 0,
            blend
          }
        ];
      }
      destroy() {
        this.gpu = null;
      }
    };
    GpuStateSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "state"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs
var gpuUploadBufferImageResource;
var init_gpuUploadBufferImageResource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs"() {
    gpuUploadBufferImageResource = {
      type: "image",
      upload(source3, gpuTexture, gpu) {
        const resource = source3.resource;
        const total = (source3.pixelWidth | 0) * (source3.pixelHeight | 0);
        const bytesPerPixel = resource.byteLength / total;
        gpu.device.queue.writeTexture(
          { texture: gpuTexture },
          resource,
          {
            offset: 0,
            rowsPerImage: source3.pixelWidth,
            bytesPerRow: source3.pixelWidth * bytesPerPixel
          },
          {
            width: source3.pixelWidth,
            height: source3.pixelHeight,
            depthOrArrayLayers: 1
          }
        );
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs
var gpuUploadImageResource;
var init_gpuUploadImageSource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs"() {
    gpuUploadImageResource = {
      type: "image",
      upload(source3, gpuTexture, gpu) {
        const resource = source3.resource;
        if (!resource)
          return;
        const width = source3.resourceWidth || source3.pixelWidth;
        const height = source3.resourceHeight || source3.pixelHeight;
        const premultipliedAlpha = source3.alphaMode === "premultiply-alpha-on-upload";
        gpu.device.queue.copyExternalImageToTexture(
          { source: resource },
          { texture: gpuTexture, premultipliedAlpha },
          {
            width,
            height
          }
        );
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs
var gpuUploadVideoResource;
var init_gpuUploadVideoSource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs"() {
    init_gpuUploadImageSource();
    gpuUploadVideoResource = {
      type: "video",
      upload(source3, gpuTexture, gpu) {
        gpuUploadImageResource.upload(source3, gpuTexture, gpu);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs
var GpuMipmapGenerator;
var init_GpuMipmapGenerator = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs"() {
    GpuMipmapGenerator = class {
      constructor(device) {
        this.device = device;
        this.sampler = device.createSampler({ minFilter: "linear" });
        this.pipelines = {};
      }
      _getMipmapPipeline(format2) {
        let pipeline = this.pipelines[format2];
        if (!pipeline) {
          if (!this.mipmapShaderModule) {
            this.mipmapShaderModule = this.device.createShaderModule({
              code: (
                /* wgsl */
                `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
              )
            });
          }
          pipeline = this.device.createRenderPipeline({
            layout: "auto",
            vertex: {
              module: this.mipmapShaderModule,
              entryPoint: "vertexMain"
            },
            fragment: {
              module: this.mipmapShaderModule,
              entryPoint: "fragmentMain",
              targets: [{ format: format2 }]
            }
          });
          this.pipelines[format2] = pipeline;
        }
        return pipeline;
      }
      /**
       * Generates mipmaps for the given GPUTexture from the data in level 0.
       * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.
       * @returns {module:External.GPUTexture} - The originally passed texture
       */
      generateMipmap(texture) {
        const pipeline = this._getMipmapPipeline(texture.format);
        if (texture.dimension === "3d" || texture.dimension === "1d") {
          throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
        }
        let mipTexture = texture;
        const arrayLayerCount = texture.depthOrArrayLayers || 1;
        const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;
        if (!renderToSource) {
          const mipTextureDescriptor = {
            size: {
              width: Math.ceil(texture.width / 2),
              height: Math.ceil(texture.height / 2),
              depthOrArrayLayers: arrayLayerCount
            },
            format: texture.format,
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
            mipLevelCount: texture.mipLevelCount - 1
          };
          mipTexture = this.device.createTexture(mipTextureDescriptor);
        }
        const commandEncoder = this.device.createCommandEncoder({});
        const bindGroupLayout = pipeline.getBindGroupLayout(0);
        for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {
          let srcView = texture.createView({
            baseMipLevel: 0,
            mipLevelCount: 1,
            dimension: "2d",
            baseArrayLayer: arrayLayer,
            arrayLayerCount: 1
          });
          let dstMipLevel = renderToSource ? 1 : 0;
          for (let i2 = 1; i2 < texture.mipLevelCount; ++i2) {
            const dstView = mipTexture.createView({
              baseMipLevel: dstMipLevel++,
              mipLevelCount: 1,
              dimension: "2d",
              baseArrayLayer: arrayLayer,
              arrayLayerCount: 1
            });
            const passEncoder = commandEncoder.beginRenderPass({
              colorAttachments: [{
                view: dstView,
                storeOp: "store",
                loadOp: "clear",
                clearValue: { r: 0, g: 0, b: 0, a: 0 }
              }]
            });
            const bindGroup = this.device.createBindGroup({
              layout: bindGroupLayout,
              entries: [{
                binding: 0,
                resource: this.sampler
              }, {
                binding: 1,
                resource: srcView
              }]
            });
            passEncoder.setPipeline(pipeline);
            passEncoder.setBindGroup(0, bindGroup);
            passEncoder.draw(3, 1, 0, 0);
            passEncoder.end();
            srcView = dstView;
          }
        }
        if (!renderToSource) {
          const mipLevelSize = {
            width: Math.ceil(texture.width / 2),
            height: Math.ceil(texture.height / 2),
            depthOrArrayLayers: arrayLayerCount
          };
          for (let i2 = 1; i2 < texture.mipLevelCount; ++i2) {
            commandEncoder.copyTextureToTexture({
              texture: mipTexture,
              mipLevel: i2 - 1
            }, {
              texture,
              mipLevel: i2
            }, mipLevelSize);
            mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);
            mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);
          }
        }
        this.device.queue.submit([commandEncoder.finish()]);
        if (!renderToSource) {
          mipTexture.destroy();
        }
        return texture;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs
var GpuTextureSystem;
var init_GpuTextureSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs"() {
    init_Extensions();
    init_adapter();
    init_CanvasPool();
    init_BindGroup();
    init_gpuUploadBufferImageResource();
    init_gpuUploadImageSource();
    init_gpuUploadVideoSource();
    init_GpuMipmapGenerator();
    GpuTextureSystem = class {
      constructor(renderer) {
        this.managedTextures = [];
        this._gpuSources = /* @__PURE__ */ Object.create(null);
        this._gpuSamplers = /* @__PURE__ */ Object.create(null);
        this._bindGroupHash = /* @__PURE__ */ Object.create(null);
        this._textureViewHash = /* @__PURE__ */ Object.create(null);
        this._uploads = {
          image: gpuUploadImageResource,
          buffer: gpuUploadBufferImageResource,
          video: gpuUploadVideoResource
        };
        this._renderer = renderer;
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
      initSource(source3) {
        if (source3.autoGenerateMipmaps) {
          const biggestDimension = Math.max(source3.pixelWidth, source3.pixelHeight);
          source3.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
        }
        const textureDescriptor = {
          size: { width: source3.pixelWidth || 1, height: source3.pixelHeight || 1 },
          format: source3.format,
          sampleCount: source3.sampleCount,
          mipLevelCount: source3.mipLevelCount,
          dimension: source3.dimension,
          usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
        };
        const gpuTexture = this._gpu.device.createTexture(textureDescriptor);
        this._gpuSources[source3.uid] = gpuTexture;
        source3.on("update", this.onSourceUpdate, this);
        source3.on("resize", this.onSourceResize, this);
        source3.on("destroy", this.onSourceDestroy, this);
        source3.on("unload", this.onSourceUnload, this);
        this.managedTextures.push(source3);
        this.onSourceUpdate(source3);
        return gpuTexture;
      }
      onSourceUpdate(source3) {
        const gpuTexture = this.getGpuSource(source3);
        if (!gpuTexture)
          return;
        if (this._uploads[source3.uploadMethodId]) {
          this._uploads[source3.uploadMethodId].upload(source3, gpuTexture, this._gpu);
        }
        if (source3.autoGenerateMipmaps && source3.mipLevelCount > 1) {
          if (!this._mipmapGenerator) {
            this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);
          }
          this._mipmapGenerator.generateMipmap(gpuTexture);
        }
      }
      onSourceUnload(source3) {
        const gpuTexture = this._gpuSources[source3.uid];
        if (gpuTexture) {
          this._gpuSources[source3.uid] = null;
          gpuTexture.destroy();
        }
      }
      onSourceDestroy(source3) {
        source3.off("update", this.onSourceUpdate, this);
        source3.off("unload", this.onSourceUnload, this);
        source3.off("destroy", this.onSourceDestroy, this);
        source3.off("resize", this.onSourceResize, this);
        this.managedTextures.splice(this.managedTextures.indexOf(source3), 1);
        this.onSourceUnload(source3);
      }
      onSourceResize(source3) {
        const gpuTexture = this._gpuSources[source3.uid];
        if (gpuTexture.width !== source3.pixelWidth || gpuTexture.height !== source3.pixelHeight) {
          this._textureViewHash[source3.uid] = null;
          this._bindGroupHash[source3.uid] = null;
          this.onSourceUnload(source3);
          this.initSource(source3);
        }
      }
      _initSampler(sampler) {
        this._gpuSamplers[sampler.resourceId] = this._gpu.device.createSampler(sampler);
        return this._gpuSamplers[sampler.resourceId];
      }
      getGpuSampler(sampler) {
        return this._gpuSamplers[sampler.resourceId] || this._initSampler(sampler);
      }
      getGpuSource(source3) {
        return this._gpuSources[source3.uid] || this.initSource(source3);
      }
      getTextureBindGroup(texture) {
        return this._bindGroupHash[texture.id] ?? this._createTextureBindGroup(texture);
      }
      _createTextureBindGroup(texture) {
        const source3 = texture.source;
        const bindGroupId = source3.uid;
        this._bindGroupHash[bindGroupId] = new BindGroup({
          0: source3,
          1: source3.style
        });
        return this._bindGroupHash[bindGroupId];
      }
      getTextureView(texture) {
        const source3 = texture.source;
        return this._textureViewHash[source3.uid] ?? this._createTextureView(source3);
      }
      _createTextureView(texture) {
        this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();
        return this._textureViewHash[texture.uid];
      }
      generateCanvas(texture) {
        const renderer = this._renderer;
        const commandEncoder = renderer.gpu.device.createCommandEncoder();
        const canvas2 = DOMAdapter.get().createCanvas();
        canvas2.width = texture.source.pixelWidth;
        canvas2.height = texture.source.pixelHeight;
        const context2 = canvas2.getContext("webgpu");
        context2.configure({
          device: renderer.gpu.device,
          // eslint-disable-next-line max-len
          usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
          format: "bgra8unorm",
          alphaMode: "premultiplied"
        });
        commandEncoder.copyTextureToTexture({
          texture: renderer.texture.getGpuSource(texture.source),
          origin: {
            x: 0,
            y: 0
          }
        }, {
          texture: context2.getCurrentTexture()
        }, {
          width: canvas2.width,
          height: canvas2.height
        });
        renderer.gpu.device.queue.submit([commandEncoder.finish()]);
        return canvas2;
      }
      getPixels(texture) {
        const webGPUCanvas = this.generateCanvas(texture);
        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);
        const context2 = canvasAndContext.context;
        context2.drawImage(webGPUCanvas, 0, 0);
        const { width, height } = webGPUCanvas;
        const imageData = context2.getImageData(0, 0, width, height);
        const pixels = new Uint8ClampedArray(imageData.data.buffer);
        CanvasPool.returnCanvasAndContext(canvasAndContext);
        return { pixels, width, height };
      }
      destroy() {
        for (const k3 of Object.keys(this._gpuSources)) {
          const key = Number(k3);
          const gpuTexture = this._gpuSources[key];
          gpuTexture.destroy();
          this._gpuSources[key] = null;
        }
        for (const k3 of Object.keys(this._bindGroupHash)) {
          const key = Number(k3);
          const bindGroup = this._bindGroupHash[key];
          bindGroup.destroy();
          this._bindGroupHash[key] = null;
        }
        this._gpu = null;
        this._mipmapGenerator = null;
        this._gpuSources = null;
        this._bindGroupHash = null;
        this._textureViewHash = null;
        this._gpuSamplers = null;
      }
    };
    GpuTextureSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "texture"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs
var WebGPURenderer_exports = {};
__export(WebGPURenderer_exports, {
  WebGPURenderer: () => WebGPURenderer
});
var DefaultWebGPUSystems, DefaultWebGPUPipes, DefaultWebGPUAdapters, systems, renderPipes, renderPipeAdaptors, WebGPURenderer;
var init_WebGPURenderer = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs"() {
    init_Extensions();
    init_GpuGraphicsAdaptor();
    init_GpuMeshAdapter();
    init_GpuBatchAdaptor();
    init_AbstractRenderer();
    init_SharedSystems();
    init_types();
    init_BindGroupSystem();
    init_GpuBufferSystem();
    init_GpuColorMaskSystem();
    init_GpuDeviceSystem();
    init_GpuEncoderSystem();
    init_GpuStencilSystem();
    init_GpuUniformBatchPipe();
    init_GpuUniformBufferPipe();
    init_PipelineSystem();
    init_GpuRenderTargetSystem();
    init_GpuShaderSystem();
    init_GpuStateSystem();
    init_GpuTextureSystem();
    DefaultWebGPUSystems = [
      ...SharedSystems,
      GpuDeviceSystem,
      BufferSystem,
      GpuTextureSystem,
      GpuRenderTargetSystem,
      GpuEncoderSystem,
      GpuShaderSystem,
      GpuStateSystem,
      PipelineSystem,
      GpuColorMaskSystem,
      GpuStencilSystem,
      BindGroupSystem
    ];
    DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe, GpuUniformBufferPipe];
    DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];
    systems = [];
    renderPipes = [];
    renderPipeAdaptors = [];
    extensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);
    extensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);
    extensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);
    extensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);
    WebGPURenderer = class extends AbstractRenderer {
      constructor() {
        const systemConfig = {
          name: "webgpu",
          type: RendererType.WEBGPU,
          systems,
          renderPipes,
          renderPipeAdaptors
        };
        super(systemConfig);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs
var GlGraphicsAdaptor;
var init_GlGraphicsAdaptor = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs"() {
    init_Extensions();
    init_Matrix();
    init_const3();
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_localUniformBit();
    init_roundPixelsBit();
    init_batchSamplersUniformGroup();
    init_Shader();
    init_UniformGroup();
    GlGraphicsAdaptor = class {
      init() {
        const uniforms = new UniformGroup({
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" }
        });
        const glProgram = compileHighShaderGlProgram({
          name: "graphics",
          bits: [
            colorBitGl,
            generateTextureBatchBitGl(MAX_TEXTURES),
            localUniformBitGl,
            roundPixelsBitGl
          ]
        });
        this.shader = new Shader({
          glProgram,
          resources: {
            localUniforms: uniforms,
            batchSamplers: batchSamplersUniformGroup
          }
        });
      }
      execute(graphicsPipe, renderable) {
        const context2 = renderable.view.context;
        const shader = context2.customShader || this.shader;
        const renderer = graphicsPipe.renderer;
        const contextSystem = renderer.graphicsContext;
        const {
          geometry,
          instructions
        } = contextSystem.getContextRenderData(context2);
        renderer.shader.bind(shader);
        renderer.shader.bindUniformBlock(renderer.globalUniforms.uniformGroup, "globalUniforms");
        renderer.geometry.bind(geometry, shader.glProgram);
        const batches = instructions.instructions;
        for (let i2 = 0; i2 < instructions.instructionSize; i2++) {
          const batch = batches[i2];
          if (batch.size) {
            for (let j3 = 0; j3 < batch.textures.textures.length; j3++) {
              renderer.texture.bind(batch.textures.textures[j3], j3);
            }
            renderer.geometry.draw("triangle-list", batch.size, batch.start);
          }
        }
      }
      destroy() {
        this.shader.destroy(true);
        this.shader = null;
      }
    };
    GlGraphicsAdaptor.extension = {
      type: [
        ExtensionType.WebGLPipesAdaptor
      ],
      name: "graphics"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs
var GlMeshAdaptor;
var init_GlMeshAdaptor = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs"() {
    init_Extensions();
    init_compileHighShaderToProgram();
    init_localUniformBit();
    init_roundPixelsBit();
    init_textureBit();
    init_Shader();
    init_Texture();
    GlMeshAdaptor = class {
      init() {
        const glProgram = compileHighShaderGlProgram({
          name: "mesh",
          bits: [
            localUniformBitGl,
            textureBitGl,
            roundPixelsBitGl
          ]
        });
        this._shader = new Shader({
          glProgram,
          resources: {
            uTexture: Texture.EMPTY.source
          }
        });
        this._shader.addResource("globalUniforms", 0, 0);
        this._shader.addResource("localUniforms", 1, 0);
      }
      execute(meshPipe, renderable) {
        const renderer = meshPipe.renderer;
        const view = renderable.view;
        let shader = view._shader;
        if (!shader) {
          shader = this._shader;
          const source3 = view.texture.source;
          shader.resources.uTexture = source3;
          shader.resources.uSampler = source3.style;
        }
        shader.groups[0] = renderer.globalUniforms.bindGroup;
        shader.groups[1] = meshPipe.localUniformsBindGroup;
        renderer.encoder.draw({
          geometry: view._geometry,
          shader,
          state: view.state
        });
      }
      destroy() {
        this._shader.destroy(true);
        this._shader = null;
      }
    };
    GlMeshAdaptor.extension = {
      type: [
        ExtensionType.WebGLPipesAdaptor
      ],
      name: "mesh"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs
var GlBatchAdaptor;
var init_GlBatchAdaptor = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs"() {
    init_Extensions();
    init_Matrix();
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_roundPixelsBit();
    init_batchSamplersUniformGroup();
    init_Shader();
    init_UniformGroup();
    init_State();
    init_const3();
    GlBatchAdaptor = class {
      constructor() {
        this._didUpload = false;
        this._tempState = State.for2d();
      }
      init() {
        const uniforms = new UniformGroup({
          tint: { value: new Float32Array([1, 1, 1, 1]), type: "f32" },
          translationMatrix: { value: new Matrix(), type: "mat3x3<f32>" }
        });
        const glProgram = compileHighShaderGlProgram({
          name: "batch",
          bits: [
            colorBitGl,
            generateTextureBatchBitGl(MAX_TEXTURES),
            roundPixelsBitGl
          ]
        });
        this._shader = new Shader({
          glProgram,
          resources: {
            uniforms,
            batchSamplers: batchSamplersUniformGroup
          }
        });
      }
      start(batchPipe, geometry) {
        const renderer = batchPipe.renderer;
        renderer.shader.bind(this._shader, this._didUpload);
        renderer.shader.bindUniformBlock(renderer.globalUniforms.uniformGroup, "globalUniforms", 0);
        renderer.geometry.bind(geometry, this._shader.glProgram);
      }
      execute(batchPipe, batch) {
        const renderer = batchPipe.renderer;
        this._didUpload = true;
        this._tempState.blendMode = batch.blendMode;
        renderer.state.set(this._tempState);
        const textures = batch.textures.textures;
        for (let i2 = 0; i2 < textures.length; i2++) {
          renderer.texture.bind(textures[i2], i2);
        }
        renderer.geometry.draw("triangle-list", batch.size, batch.start);
      }
      destroy() {
        this._shader.destroy(true);
        this._shader = null;
      }
    };
    GlBatchAdaptor.extension = {
      type: [
        ExtensionType.WebGLPipesAdaptor
      ],
      name: "batch"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs
var BUFFER_TYPE;
var init_const9 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs"() {
    BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
      BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
      BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
      BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
      return BUFFER_TYPE2;
    })(BUFFER_TYPE || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs
var GlBuffer;
var init_GlBuffer = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs"() {
    GlBuffer = class {
      constructor(buffer, type) {
        this.buffer = buffer || null;
        this.updateID = -1;
        this.byteLength = -1;
        this.type = type;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs
var GlBufferSystem;
var init_GlBufferSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs"() {
    init_Extensions();
    init_const5();
    init_const9();
    init_GlBuffer();
    GlBufferSystem = class {
      /**
       * @param {Renderer} renderer - The renderer this System works for.
       */
      constructor(renderer) {
        this._gpuBuffers = /* @__PURE__ */ Object.create(null);
        this._boundBufferBases = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      /**
       * @ignore
       */
      destroy() {
        const writeable = this;
        this.destroyAll(true);
        this._renderer = null;
        this._gl = null;
        this._gpuBuffers = null;
        writeable._boundBufferBases = null;
      }
      /** Sets up the renderer context and necessary buffers. */
      contextChange() {
        this.destroyAll(true);
        this._gl = this._renderer.gl;
      }
      getGlBuffer(buffer) {
        return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);
      }
      /**
       * This binds specified buffer. On first run, it will create the webGL buffers for the context too
       * @param buffer - the buffer to bind to the renderer
       */
      bind(buffer) {
        const { _gl: gl } = this;
        const glBuffer = this.getGlBuffer(buffer);
        gl.bindBuffer(glBuffer.type, glBuffer.buffer);
      }
      /**
       * Binds an uniform buffer to at the given index.
       *
       * A cache is used so a buffer will not be bound again if already bound.
       * @param buffer - the buffer to bind
       * @param index - the base index to bind it to.
       */
      bindBufferBase(buffer, index) {
        const { _gl: gl } = this;
        if (this._boundBufferBases[index] !== buffer) {
          const glBuffer = this.getGlBuffer(buffer);
          this._boundBufferBases[index] = buffer;
          gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
        }
      }
      /**
       * Binds a buffer whilst also binding its range.
       * This will make the buffer start from the offset supplied rather than 0 when it is read.
       * @param buffer - the buffer to bind
       * @param index - the base index to bind at, defaults to 0
       * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc
       */
      bindBufferRange(buffer, index, offset) {
        const { _gl: gl } = this;
        offset = offset || 0;
        const glBuffer = this.getGlBuffer(buffer);
        gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);
      }
      /**
       * Will ensure the data in the buffer is uploaded to the GPU.
       * @param {Buffer} buffer - the buffer to update
       */
      updateBuffer(buffer) {
        const { _gl: gl } = this;
        const glBuffer = this.getGlBuffer(buffer);
        if (buffer._updateID === glBuffer.updateID) {
          return glBuffer;
        }
        glBuffer.updateID = buffer._updateID;
        gl.bindBuffer(glBuffer.type, glBuffer.buffer);
        if (glBuffer.byteLength >= buffer.data.byteLength) {
          gl.bufferSubData(glBuffer.type, 0, buffer.data, 0, buffer._updateSize / 4);
        } else {
          const drawType = buffer.descriptor.usage & BufferUsage.STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
          glBuffer.byteLength = buffer.data.byteLength;
          gl.bufferData(glBuffer.type, buffer.data, drawType);
        }
        return glBuffer;
      }
      /**
       * dispose all WebGL resources of all managed buffers
       * @param {boolean} [contextLost=false] - If context was lost, we suppress `gl.delete` calls
       */
      destroyAll(contextLost) {
        const gl = this._gl;
        if (!contextLost) {
          for (const id in this._gpuBuffers) {
            gl.deleteBuffer(this._gpuBuffers[id].buffer);
          }
        }
        this._gpuBuffers = {};
      }
      /**
       * Disposes buffer
       * @param {Buffer} buffer - buffer with data
       * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray
       */
      onBufferDestroy(buffer, contextLost) {
        const glBuffer = this._gpuBuffers[buffer.uid];
        const gl = this._gl;
        if (!contextLost) {
          gl.deleteBuffer(glBuffer.buffer);
        }
        this._gpuBuffers[buffer.uid] = null;
      }
      /**
       * creates and attaches a GLBuffer object tied to the current context.
       * @param buffer
       * @protected
       */
      createGLBuffer(buffer) {
        const { _gl: gl } = this;
        let type = BUFFER_TYPE.ARRAY_BUFFER;
        if (buffer.descriptor.usage & BufferUsage.INDEX) {
          type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
        } else if (buffer.descriptor.usage & BufferUsage.UNIFORM) {
          type = BUFFER_TYPE.UNIFORM_BUFFER;
        }
        const glBuffer = new GlBuffer(gl.createBuffer(), type);
        this._gpuBuffers[buffer.uid] = glBuffer;
        buffer.on("destroy", this.onBufferDestroy, this);
        return glBuffer;
      }
    };
    GlBufferSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "buffer"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs
var GlContextSystem;
var init_GlContextSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs"() {
    init_Extensions();
    init_warn();
    GlContextSystem = class {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this._renderer = renderer;
        this.webGLVersion = 1;
        this.extensions = /* @__PURE__ */ Object.create(null);
        this.supports = {
          uint32Indices: false
        };
        this.handleContextLost = this.handleContextLost.bind(this);
        this.handleContextRestored = this.handleContextRestored.bind(this);
      }
      /**
       * `true` if the context is lost
       * @readonly
       */
      get isLost() {
        return !this.gl || this.gl.isContextLost();
      }
      /**
       * Handles the context change event.
       * @param {WebGLRenderingContext} gl - New WebGL context.
       */
      contextChange(gl) {
        this.gl = gl;
        this._renderer.gl = gl;
        if (gl.isContextLost() && gl.getExtension("WEBGL_lose_context")) {
          gl.getExtension("WEBGL_lose_context").restoreContext();
        }
      }
      init(options) {
        if (options?.context) {
          this.initFromContext(options.context);
        } else {
          const alpha = this._renderer.background.alpha < 1;
          const premultipliedAlpha = options.premultipliedAlpha ?? true;
          const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;
          this.initFromOptions({
            alpha,
            premultipliedAlpha,
            antialias,
            stencil: true,
            preserveDrawingBuffer: options.preserveDrawingBuffer,
            powerPreference: options.powerPreference
          });
        }
      }
      /**
       * Initializes the context.
       * @protected
       * @param {WebGLRenderingContext} gl - WebGL context
       */
      initFromContext(gl) {
        this.gl = gl;
        this.validateContext(gl);
        this._renderer.runners.contextChange.emit(gl);
        const element = this._renderer.view.canvas;
        element.addEventListener("webglcontextlost", this.handleContextLost, false);
        element.addEventListener("webglcontextrestored", this.handleContextRestored, false);
      }
      /**
       * Initialize from context options
       * @protected
       * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
       * @param {object} options - context attributes
       */
      initFromOptions(options) {
        const gl = this.createContext(this._renderer.view.canvas, options);
        this.initFromContext(gl);
      }
      /**
       * Helper class to create a WebGL Context
       * @param canvas - the canvas element that we will get the context from
       * @param options - An options object that gets passed in to the canvas element containing the
       *    context attributes
       * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
       * @returns {WebGLRenderingContext} the WebGL context
       */
      createContext(canvas2, options) {
        const gl = canvas2.getContext("webgl2", options);
        this.webGLVersion = 2;
        this.gl = gl;
        this.getExtensions();
        return this.gl;
      }
      /** Auto-populate the {@link ContextSystem.extensions extensions}. */
      getExtensions() {
        const { gl } = this;
        const common = {
          anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
          floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
          s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
          s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
          // eslint-disable-line camelcase
          etc: gl.getExtension("WEBGL_compressed_texture_etc"),
          etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
          pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
          atc: gl.getExtension("WEBGL_compressed_texture_atc"),
          astc: gl.getExtension("WEBGL_compressed_texture_astc")
        };
        Object.assign(this.extensions, common, {
          // Floats and half-floats
          colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
        });
      }
      /**
       * Handles a lost webgl context
       * @param {WebGLContextEvent} event - The context lost event.
       */
      handleContextLost(event) {
        event.preventDefault();
      }
      /** Handles a restored webgl context. */
      handleContextRestored() {
        this._renderer.runners.contextChange.emit(this.gl);
      }
      destroy() {
        const element = this._renderer.view.canvas;
        this._renderer = null;
        element.removeEventListener("webglcontextlost", this.handleContextLost);
        element.removeEventListener("webglcontextrestored", this.handleContextRestored);
        this.gl.useProgram(null);
        if (this.extensions.loseContext) {
          this.extensions.loseContext.loseContext();
        }
      }
      /**
       * Validate context.
       * @param {WebGLRenderingContext} gl - Render context.
       */
      validateContext(gl) {
        const attributes = gl.getContextAttributes();
        const isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
        if (isWebGl2) {
          this.webGLVersion = 2;
        }
        if (attributes && !attributes.stencil) {
          warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        }
        const hasUint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
        this.supports.uint32Indices = hasUint32;
        if (!hasUint32) {
          warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
        }
      }
    };
    GlContextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "context"
    };
    GlContextSystem.defaultOptions = {
      /**
       * {@link WebGLOptions.context}
       * @default null
       */
      context: null,
      /**
       * {@link WebGLOptions.premultipliedAlpha}
       * @default true
       */
      premultipliedAlpha: true,
      /**
       * {@link WebGLOptions.preserveDrawingBuffer}
       * @default false
       */
      preserveDrawingBuffer: false,
      /**
       * {@link WebGLOptions.powerPreference}
       * @default default
       */
      powerPreference: "default"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs
var GL_FORMATS, GL_TARGETS, GL_TYPES;
var init_const10 = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs"() {
    GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2) => {
      GL_FORMATS2[GL_FORMATS2["RGBA"] = 6408] = "RGBA";
      GL_FORMATS2[GL_FORMATS2["RGB"] = 6407] = "RGB";
      GL_FORMATS2[GL_FORMATS2["RG"] = 33319] = "RG";
      GL_FORMATS2[GL_FORMATS2["RED"] = 6403] = "RED";
      GL_FORMATS2[GL_FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
      GL_FORMATS2[GL_FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
      GL_FORMATS2[GL_FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
      GL_FORMATS2[GL_FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
      GL_FORMATS2[GL_FORMATS2["ALPHA"] = 6406] = "ALPHA";
      GL_FORMATS2[GL_FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
      GL_FORMATS2[GL_FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
      GL_FORMATS2[GL_FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
      GL_FORMATS2[GL_FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
      return GL_FORMATS2;
    })(GL_FORMATS || {});
    GL_TARGETS = /* @__PURE__ */ ((GL_TARGETS2) => {
      GL_TARGETS2[GL_TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
      return GL_TARGETS2;
    })(GL_TARGETS || {});
    GL_TYPES = /* @__PURE__ */ ((GL_TYPES2) => {
      GL_TYPES2[GL_TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
      GL_TYPES2[GL_TYPES2["BYTE"] = 5120] = "BYTE";
      GL_TYPES2[GL_TYPES2["SHORT"] = 5122] = "SHORT";
      GL_TYPES2[GL_TYPES2["INT"] = 5124] = "INT";
      GL_TYPES2[GL_TYPES2["FLOAT"] = 5126] = "FLOAT";
      GL_TYPES2[GL_TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
      GL_TYPES2[GL_TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
      return GL_TYPES2;
    })(GL_TYPES || {});
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlInfoFromFormat.mjs
function getGlInfoFromFormat(format2) {
  return infoMap[format2] ?? infoMap.float32;
}
var infoMap;
var init_getGlInfoFromFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlInfoFromFormat.mjs"() {
    init_const10();
    infoMap = {
      uint8x2: { type: GL_TYPES.UNSIGNED_BYTE, size: 2, normalised: false },
      uint8x4: { type: GL_TYPES.UNSIGNED_BYTE, size: 4, normalised: false },
      sint8x2: { type: GL_TYPES.BYTE, size: 2, normalised: false },
      sint8x4: { type: GL_TYPES.BYTE, size: 4, normalised: false },
      unorm8x2: { type: GL_TYPES.UNSIGNED_BYTE, size: 2, normalised: true },
      unorm8x4: { type: GL_TYPES.UNSIGNED_BYTE, size: 4, normalised: true },
      snorm8x2: { type: GL_TYPES.BYTE, size: 2, normalised: true },
      snorm8x4: { type: GL_TYPES.BYTE, size: 4, normalised: true },
      uint16x2: { type: GL_TYPES.UNSIGNED_SHORT, size: 2, normalised: false },
      uint16x4: { type: GL_TYPES.UNSIGNED_SHORT, size: 4, normalised: false },
      sint16x2: { type: GL_TYPES.SHORT, size: 2, normalised: false },
      sint16x4: { type: GL_TYPES.SHORT, size: 4, normalised: false },
      unorm16x2: { type: GL_TYPES.UNSIGNED_SHORT, size: 2, normalised: true },
      unorm16x4: { type: GL_TYPES.UNSIGNED_SHORT, size: 4, normalised: true },
      snorm16x2: { type: GL_TYPES.SHORT, size: 2, normalised: true },
      snorm16x4: { type: GL_TYPES.SHORT, size: 4, normalised: true },
      float16x2: { type: GL_TYPES.HALF_FLOAT, size: 2, normalised: false },
      float16x4: { type: GL_TYPES.HALF_FLOAT, size: 4, normalised: false },
      float32: { type: GL_TYPES.FLOAT, size: 1, normalised: false },
      float32x2: { type: GL_TYPES.FLOAT, size: 2, normalised: false },
      float32x3: { type: GL_TYPES.FLOAT, size: 3, normalised: false },
      float32x4: { type: GL_TYPES.FLOAT, size: 4, normalised: false },
      uint32: { type: GL_TYPES.UNSIGNED_INT, size: 1, normalised: false },
      uint32x2: { type: GL_TYPES.UNSIGNED_INT, size: 2, normalised: false },
      uint32x3: { type: GL_TYPES.UNSIGNED_INT, size: 3, normalised: false },
      uint32x4: { type: GL_TYPES.UNSIGNED_INT, size: 4, normalised: false },
      sint32: { type: GL_TYPES.INT, size: 1, normalised: false },
      sint32x2: { type: GL_TYPES.INT, size: 2, normalised: false },
      sint32x3: { type: GL_TYPES.INT, size: 3, normalised: false },
      sint32x4: { type: GL_TYPES.INT, size: 4, normalised: false }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs
var byteSizeMap, topologyToGlMap, GlGeometrySystem;
var init_GlGeometrySystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs"() {
    init_Extensions();
    init_warn();
    init_getGlInfoFromFormat();
    byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
    topologyToGlMap = {
      "point-list": 0,
      "line-list": 1,
      "line-strip": 3,
      "triangle-list": 4,
      "triangle-strip": 5
    };
    GlGeometrySystem = class {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this._geometryVaoHash = {};
        this._renderer = renderer;
        this._activeGeometry = null;
        this._activeVao = null;
        this.hasVao = true;
        this.hasInstance = true;
        this.canUseUInt32ElementIndex = true;
      }
      /** Sets up the renderer context and necessary buffers. */
      contextChange() {
        this.gl = this._renderer.gl;
      }
      /**
       * Binds geometry so that is can be drawn. Creating a Vao if required
       * @param geometry - Instance of geometry to bind.
       * @param program - Instance of program to use vao for.
       */
      bind(geometry, program) {
        const gl = this.gl;
        this._activeGeometry = geometry;
        const vao = this.getVao(geometry, program);
        if (this._activeVao !== vao) {
          this._activeVao = vao;
          gl.bindVertexArray(vao);
        }
        this.updateBuffers();
      }
      /** Reset and unbind any active VAO and geometry. */
      reset() {
        this.unbind();
      }
      /** Update buffers of the currently bound geometry. */
      updateBuffers() {
        const geometry = this._activeGeometry;
        const bufferSystem = this._renderer.buffer;
        for (let i2 = 0; i2 < geometry.buffers.length; i2++) {
          const buffer = geometry.buffers[i2];
          bufferSystem.updateBuffer(buffer);
        }
      }
      /**
       * Check compatibility between a geometry and a program
       * @param geometry - Geometry instance.
       * @param program - Program instance.
       */
      checkCompatibility(geometry, program) {
        const geometryAttributes = geometry.attributes;
        const shaderAttributes = program.attributeData;
        for (const j3 in shaderAttributes) {
          if (!geometryAttributes[j3]) {
            throw new Error(`shader and geometry incompatible, geometry missing the "${j3}" attribute`);
          }
        }
      }
      /**
       * Takes a geometry and program and generates a unique signature for them.
       * @param geometry - To get signature from.
       * @param program - To test geometry against.
       * @returns - Unique signature of the geometry and program
       */
      getSignature(geometry, program) {
        const attribs = geometry.attributes;
        const shaderAttributes = program.attributeData;
        const strings = ["g", geometry.uid];
        for (const i2 in attribs) {
          if (shaderAttributes[i2]) {
            strings.push(i2, shaderAttributes[i2].location);
          }
        }
        return strings.join("-");
      }
      getVao(geometry, program) {
        return this._geometryVaoHash[geometry.uid]?.[program.key] || this.initGeometryVao(geometry, program);
      }
      /**
       * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
       * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the
       * attribute locations.
       * @param geometry - Instance of geometry to to generate Vao for.
       * @param program
       * @param _incRefCount - Increment refCount of all geometry buffers.
       */
      initGeometryVao(geometry, program, _incRefCount = true) {
        const gl = this._renderer.gl;
        const bufferSystem = this._renderer.buffer;
        this._renderer.shader.getProgramData(program);
        this.checkCompatibility(geometry, program);
        const signature = this.getSignature(geometry, program);
        if (!this._geometryVaoHash[geometry.uid]) {
          this._geometryVaoHash[geometry.uid] = /* @__PURE__ */ Object.create(null);
          geometry.on("destroy", this.onGeometryDestroy, this);
        }
        const vaoObjectHash = this._geometryVaoHash[geometry.uid];
        let vao = vaoObjectHash[signature];
        if (vao) {
          vaoObjectHash[program.key] = vao;
          return vao;
        }
        const buffers = geometry.buffers;
        const attributes = geometry.attributes;
        const tempStride = {};
        const tempStart = {};
        for (const j3 in buffers) {
          tempStride[j3] = 0;
          tempStart[j3] = 0;
        }
        for (const j3 in attributes) {
          if (!attributes[j3].size && program.attributeData[j3]) {
            attributes[j3].size = program.attributeData[j3].size;
          } else if (!attributes[j3].size) {
            warn(`PIXI Geometry attribute '${j3}' size cannot be determined (likely the bound shader does not have the attribute)`);
          }
          tempStride[attributes[j3].buffer.uid] += attributes[j3].size * byteSizeMap[attributes[j3].type];
        }
        for (const j3 in attributes) {
          const attribute = attributes[j3];
          const attribSize = attribute.size;
          if (attribute.stride === void 0) {
            if (tempStride[attribute.buffer.uid] === attribSize * byteSizeMap[attribute.type]) {
              attribute.stride = 0;
            } else {
              attribute.stride = tempStride[attribute.buffer.uid];
            }
          }
          if (attribute.start === void 0) {
            attribute.start = tempStart[attribute.buffer.uid];
            tempStart[attribute.buffer.uid] += attribSize * byteSizeMap[attribute.type];
          }
        }
        vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        for (let i2 = 0; i2 < buffers.length; i2++) {
          const buffer = buffers[i2];
          bufferSystem.bind(buffer);
        }
        this.activateVao(geometry, program);
        vaoObjectHash[program.key] = vao;
        vaoObjectHash[signature] = vao;
        gl.bindVertexArray(null);
        return vao;
      }
      /**
       * Disposes geometry.
       * @param geometry - Geometry with buffers. Only VAO will be disposed
       * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray
       */
      onGeometryDestroy(geometry, contextLost) {
        const vaoObjectHash = this._geometryVaoHash[geometry.uid];
        const gl = this.gl;
        if (vaoObjectHash) {
          if (contextLost) {
            for (const i2 in vaoObjectHash) {
              if (this._activeVao !== vaoObjectHash[i2]) {
                this.unbind();
              }
              gl.deleteVertexArray(vaoObjectHash[i2]);
            }
          }
          this._geometryVaoHash[geometry.uid] = null;
        }
      }
      /**
       * Dispose all WebGL resources of all managed geometries.
       * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls
       */
      destroyAll(contextLost = false) {
        const gl = this.gl;
        for (const i2 in this._geometryVaoHash) {
          if (contextLost) {
            for (const j3 in this._geometryVaoHash[i2]) {
              const vaoObjectHash = this._geometryVaoHash[i2];
              if (this._activeVao !== vaoObjectHash) {
                this.unbind();
              }
              gl.deleteVertexArray(vaoObjectHash[j3]);
            }
          }
          this._geometryVaoHash[i2] = null;
        }
      }
      /**
       * Activate vertex array object.
       * @param geometry - Geometry instance.
       * @param program - Shader program instance.
       */
      activateVao(geometry, program) {
        const gl = this._renderer.gl;
        const bufferSystem = this._renderer.buffer;
        const attributes = geometry.attributes;
        if (geometry.indexBuffer) {
          bufferSystem.bind(geometry.indexBuffer);
        }
        let lastBuffer = null;
        for (const j3 in attributes) {
          const attribute = attributes[j3];
          const buffer = attribute.buffer;
          const glBuffer = bufferSystem.getGlBuffer(buffer);
          if (program.attributeData[j3]) {
            if (lastBuffer !== glBuffer) {
              bufferSystem.bind(buffer);
              lastBuffer = glBuffer;
            }
            const location = program.attributeData[j3].location;
            gl.enableVertexAttribArray(location);
            const glInfo = getGlInfoFromFormat(attribute.format);
            gl.vertexAttribPointer(
              location,
              glInfo.size,
              glInfo.type,
              // attribute.type || gl.FLOAT,
              glInfo.normalised,
              attribute.stride,
              attribute.offset
            );
            if (attribute.instance) {
              if (this.hasInstance) {
                gl.vertexAttribDivisor(location, 1);
              } else {
                throw new Error("geometry error, GPU Instancing is not supported on this device");
              }
            }
          }
        }
      }
      /**
       * Draws the currently bound geometry.
       * @param topology - The type primitive to render.
       * @param size - The number of elements to be rendered. If not specified, all vertices after the
       *  starting vertex will be drawn.
       * @param start - The starting vertex in the geometry to start drawing from. If not specified,
       *  drawing will start from the first vertex.
       * @param instanceCount - The number of instances of the set of elements to execute. If not specified,
       *  all instances will be drawn.
       */
      draw(topology, size2, start, instanceCount) {
        const { gl } = this._renderer;
        const geometry = this._activeGeometry;
        const glTopology = topologyToGlMap[geometry.topology || topology];
        if (geometry.indexBuffer) {
          const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
          const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
          if (geometry.instanced) {
            gl.drawElementsInstanced(glTopology, size2 || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, geometry.instanceCount || 1);
          } else {
            gl.drawElements(glTopology, size2 || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
          }
        } else if (geometry.instanced) {
          gl.drawArraysInstanced(glTopology, start, size2 || geometry.getSize(), instanceCount || 1);
        } else {
          gl.drawArrays(glTopology, start, size2 || geometry.getSize());
        }
        return this;
      }
      /** Unbind/reset everything. */
      unbind() {
        this.gl.bindVertexArray(null);
        this._activeVao = null;
        this._activeGeometry = null;
      }
      destroy() {
        this._renderer = null;
        this.gl = null;
        this._activeVao = null;
        this._activeGeometry = null;
      }
    };
    GlGeometrySystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "geometry"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs
var bigTriangleProgram, bigTriangleShader, _GlBackBufferSystem, GlBackBufferSystem;
var init_GlBackBufferSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs"() {
    init_Extensions();
    init_Shader();
    init_State();
    init_TextureSource();
    init_Texture();
    init_GlProgram();
    bigTriangleProgram = new GlProgram({
      vertex: `
        out vec2 vUv;

        void main() {
            vUv = vec2((gl_VertexID << 1) & 2, (gl_VertexID & 2));

            gl_Position = vec4(vUv * 2.0f + -1.0f, 0.0f, 1.0f);

            // flip dem UVs
            vUv.y = 1.0f - vUv.y;
        }`,
      fragment: `
        in vec2 vUv;
        out vec4 fragColor;

        uniform sampler2D uTexture;

        void main() {
            fragColor = texture(uTexture, vUv);
        }`,
      name: "big-triangle"
    });
    bigTriangleShader = new Shader({
      glProgram: bigTriangleProgram,
      resources: {
        uTexture: Texture.WHITE.source
      }
    });
    _GlBackBufferSystem = class {
      constructor(renderer) {
        this.useBackBuffer = false;
        this._useBackBufferThisRender = false;
        this._renderer = renderer;
      }
      init(options = {}) {
        const { useBackBuffer, antialias } = { ..._GlBackBufferSystem.defaultOptions, ...options };
        this.useBackBuffer = useBackBuffer;
        this._antialias = antialias;
      }
      renderStart({ target, clear, clearColor }) {
        this._useBackBufferThisRender = this.useBackBuffer && !!target;
        if (this.useBackBuffer) {
          const renderTarget = this._renderer.renderTarget.getRenderTarget(target);
          this._targetTexture = renderTarget.colorTexture;
          target = this._getBackBufferTexture(renderTarget.colorTexture);
        }
        clearColor ?? (clearColor = this._renderer.background.colorRgba);
        this._renderer.renderTarget.start(target, clear, clearColor);
      }
      renderEnd() {
        this._presentBackBuffer();
      }
      _presentBackBuffer() {
        const renderer = this._renderer;
        renderer.renderTarget.finishRenderPass();
        if (!this._useBackBufferThisRender)
          return;
        const gl = renderer.gl;
        renderer.renderTarget.bind(this._targetTexture, false);
        bigTriangleShader.resources.uTexture = this._backBufferTexture.source;
        renderer.shader.bind(bigTriangleShader, false);
        renderer.state.set(State.for2d());
        gl.drawArrays(gl.TRIANGLES, 0, 3);
      }
      _getBackBufferTexture(targetTexture) {
        const source3 = targetTexture.source;
        this._backBufferTexture = this._backBufferTexture || new Texture({
          source: new TextureSource({
            width: source3.width,
            height: source3.height,
            resolution: source3._resolution,
            antialias: this._antialias
          })
        });
        this._backBufferTexture.source.resize(
          source3.width,
          source3.height,
          source3._resolution
        );
        return this._backBufferTexture;
      }
      destroy() {
        if (this._backBufferTexture) {
          this._backBufferTexture.destroy();
          this._backBufferTexture = null;
        }
      }
    };
    GlBackBufferSystem = _GlBackBufferSystem;
    GlBackBufferSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "backBuffer"
    };
    GlBackBufferSystem.defaultOptions = {
      useBackBuffer: false
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs
var GlColorMaskSystem;
var init_GlColorMaskSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs"() {
    init_Extensions();
    GlColorMaskSystem = class {
      constructor(renderer) {
        this._colorMaskCache = 15;
        this._renderer = renderer;
      }
      setMask(colorMask) {
        if (this._colorMaskCache === colorMask)
          return;
        this._colorMaskCache = colorMask;
        this._renderer.gl.colorMask(
          !!(colorMask & 8),
          !!(colorMask & 4),
          !!(colorMask & 2),
          !!(colorMask & 1)
        );
      }
    };
    GlColorMaskSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "colorMask"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs
var GlEncoderSystem;
var init_GlEncoderSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs"() {
    init_Extensions();
    GlEncoderSystem = class {
      constructor(renderer) {
        this.commandFinished = Promise.resolve();
        this._renderer = renderer;
      }
      setGeometry(geometry, shader) {
        this._renderer.geometry.bind(geometry, shader.glProgram);
      }
      finishRenderPass() {
      }
      draw(options) {
        const renderer = this._renderer;
        const { geometry, shader, state, skipSync, topology: type, size: size2, start, instanceCount } = options;
        renderer.shader.bind(shader, skipSync);
        renderer.geometry.bind(geometry, renderer.shader.activeProgram);
        if (state) {
          renderer.state.set(state);
        }
        renderer.geometry.draw(type, size2, start, instanceCount);
      }
      destroy() {
        const writeable = this;
        writeable._renderer = null;
      }
    };
    GlEncoderSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "encoder"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs
var GlRenderTarget;
var init_GlRenderTarget = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs"() {
    GlRenderTarget = class {
      constructor() {
        this.width = -1;
        this.height = -1;
        this.msaaRenderBuffer = [];
        this.msaa = false;
        this.dirtyId = -1;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTargetSystem.mjs
var GlRenderTargetSystem;
var init_GlRenderTargetSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTargetSystem.mjs"() {
    init_Extensions();
    init_Matrix();
    init_isRenderingToScreen();
    init_RenderTarget();
    init_SystemRunner();
    init_Texture();
    init_getCanvasTexture();
    init_const7();
    init_GlRenderTarget();
    GlRenderTargetSystem = class {
      constructor(renderer) {
        this.onRenderTargetChange = new SystemRunner("onRenderTargetChange");
        this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();
        this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
        this._renderTargetStack = [];
        this._defaultClearColor = [0, 0, 0, 0];
        this._clearColorCache = [0, 0, 0, 0];
        this._viewPortCache = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
        this.rootProjectionMatrix = new Matrix();
        this._renderer = renderer;
      }
      contextChange(gl) {
        this._gl = gl;
      }
      start(rootRenderSurface, clear = true, clearColor) {
        this._renderTargetStack.length = 0;
        const renderTarget = this.getRenderTarget(rootRenderSurface);
        this.rootRenderTarget = renderTarget;
        this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);
        this.rootProjectionMatrix = renderTarget.projectionMatrix;
        this.push(renderTarget, clear, clearColor);
      }
      bind(renderSurface, clear = true, clearColor) {
        const renderTarget = this.getRenderTarget(renderSurface);
        this.renderTarget = renderTarget;
        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);
        if (renderTarget.dirtyId !== gpuRenderTarget.dirtyId) {
          gpuRenderTarget.dirtyId = renderTarget.dirtyId;
          this._resizeGpuRenderTarget(renderTarget);
        }
        const gl = this._gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);
        renderTarget.colorTextures.forEach((texture) => {
          this._renderer.texture.unbind(texture);
        });
        const viewport = renderTarget.viewport;
        let viewPortY = viewport.y;
        if (renderTarget.isRoot) {
          viewPortY = this._renderer.view.canvas.height - viewport.height;
        }
        const viewPortCache = this._viewPortCache;
        if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {
          viewPortCache.x = viewport.x;
          viewPortCache.y = viewPortY;
          viewPortCache.width = viewport.width;
          viewPortCache.height = viewport.height;
          gl.viewport(
            viewport.x,
            viewPortY,
            viewport.width,
            viewport.height
          );
        }
        this.clear(clear, clearColor);
        this.onRenderTargetChange.emit(renderTarget);
        return renderTarget;
      }
      clear(clear, clearColor) {
        if (!clear)
          return;
        if (typeof clear === "boolean") {
          clear = clear ? CLEAR.ALL : CLEAR.NONE;
        }
        const gl = this._gl;
        if (clear & CLEAR.COLOR) {
          clearColor ?? (clearColor = this._defaultClearColor);
          const clearColorCache = this._clearColorCache;
          const clearColorArray = clearColor;
          if (clearColorCache[0] !== clearColorArray[0] || clearColorCache[1] !== clearColorArray[1] || clearColorCache[2] !== clearColorArray[2] || clearColorCache[3] !== clearColorArray[3]) {
            clearColorCache[0] = clearColorArray[0];
            clearColorCache[1] = clearColorArray[1];
            clearColorCache[2] = clearColorArray[2];
            clearColorCache[3] = clearColorArray[3];
            gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);
          }
        }
        gl.clear(clear);
      }
      push(renderSurface, clear = true, clearColor) {
        const renderTarget = this.bind(renderSurface, clear, clearColor);
        this._renderTargetStack.push(renderTarget);
        return renderTarget;
      }
      pop() {
        this._renderTargetStack.pop();
        this.bind(this._renderTargetStack[this._renderTargetStack.length - 1], false);
      }
      getRenderTarget(renderSurface) {
        return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);
      }
      _initRenderTarget(renderSurface) {
        let renderTarget = null;
        if (renderSurface instanceof HTMLCanvasElement) {
          renderSurface = getCanvasTexture(renderSurface);
        }
        if (renderSurface instanceof RenderTarget) {
          renderTarget = renderSurface;
        } else if (renderSurface instanceof Texture) {
          renderTarget = new RenderTarget({
            colorTextures: [renderSurface]
          });
          if (renderSurface.source.resource instanceof HTMLCanvasElement) {
            renderTarget.isRoot = true;
          }
          renderSurface.source.on("destroy", () => {
            renderTarget.destroy();
          });
        }
        this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);
        return renderTarget;
      }
      finishRenderPass(renderTarget) {
        renderTarget = renderTarget || this.renderTarget;
        const glRenderTarget = this.getGpuRenderTarget(renderTarget);
        if (!glRenderTarget.msaa)
          return;
        const gl = this._renderer.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);
        gl.blitFramebuffer(
          0,
          0,
          glRenderTarget.width,
          glRenderTarget.height,
          0,
          0,
          glRenderTarget.width,
          glRenderTarget.height,
          gl.COLOR_BUFFER_BIT,
          gl.NEAREST
        );
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);
      }
      copyToTexture(sourceRenderSurfaceTexture, destinationTexture, origin, size2) {
        const renderer = this._renderer;
        const glRenderTarget = this.getGpuRenderTarget(sourceRenderSurfaceTexture);
        const gl = renderer.gl;
        this.finishRenderPass(sourceRenderSurfaceTexture);
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
        renderer.texture.bind(destinationTexture, 0);
        gl.copyTexSubImage2D(
          gl.TEXTURE_2D,
          0,
          0,
          0,
          origin.x,
          origin.y,
          size2.width,
          size2.height
        );
        return destinationTexture;
      }
      getGpuRenderTarget(renderTarget) {
        return this._gpuRenderTargetHash[renderTarget.uid] || this._initGpuRenderTarget(renderTarget);
      }
      _initGpuRenderTarget(renderTarget) {
        const renderer = this._renderer;
        const gl = renderer.gl;
        const glRenderTarget = new GlRenderTarget();
        if (renderTarget.colorTexture.source.resource instanceof HTMLCanvasElement) {
          this._gpuRenderTargetHash[renderTarget.uid] = glRenderTarget;
          glRenderTarget.framebuffer = null;
          return glRenderTarget;
        }
        this._initColor(renderTarget, glRenderTarget);
        if (renderTarget.stencil) {
          this._initStencil(glRenderTarget);
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        this._gpuRenderTargetHash[renderTarget.uid] = glRenderTarget;
        return glRenderTarget;
      }
      _resizeGpuRenderTarget(renderTarget) {
        if (renderTarget.isRoot)
          return;
        const glRenderTarget = this.getGpuRenderTarget(renderTarget);
        this._resizeColor(renderTarget, glRenderTarget);
        if (renderTarget.stencil) {
          this._resizeStencil(glRenderTarget);
        }
      }
      _initColor(renderTarget, glRenderTarget) {
        const renderer = this._renderer;
        const gl = renderer.gl;
        const resolveTargetFramebuffer = gl.createFramebuffer();
        glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);
        glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;
        glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;
        renderTarget.colorTextures.forEach((colorTexture, i2) => {
          const source3 = colorTexture.source;
          if (source3.antialias) {
            glRenderTarget.msaa = true;
          }
          renderer.texture.bindSource(source3, 0);
          const glSource = renderer.texture.getGlSource(source3);
          const glTexture = glSource.texture;
          gl.framebufferTexture2D(
            gl.FRAMEBUFFER,
            gl.COLOR_ATTACHMENT0 + i2,
            3553,
            // texture.target,
            glTexture,
            0
          );
        });
        if (glRenderTarget.msaa) {
          const viewFramebuffer = gl.createFramebuffer();
          glRenderTarget.framebuffer = viewFramebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
          renderTarget.colorTextures.forEach((_2, i2) => {
            const msaaRenderBuffer = gl.createRenderbuffer();
            glRenderTarget.msaaRenderBuffer[i2] = msaaRenderBuffer;
          });
        } else {
          glRenderTarget.framebuffer = resolveTargetFramebuffer;
        }
      }
      _resizeColor(renderTarget, glRenderTarget) {
        const source3 = renderTarget.colorTexture.source;
        glRenderTarget.width = source3.pixelWidth;
        glRenderTarget.height = source3.pixelHeight;
        renderTarget.colorTextures.forEach((colorTexture, i2) => {
          if (i2 === 0)
            return;
          colorTexture.source.resize(source3.width, source3.height, source3._resolution);
        });
        if (glRenderTarget.msaa) {
          const renderer = this._renderer;
          const gl = renderer.gl;
          const viewFramebuffer = glRenderTarget.framebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
          renderTarget.colorTextures.forEach((colorTexture, i2) => {
            const source22 = colorTexture.source;
            renderer.texture.bindSource(source22, 0);
            const glSource = renderer.texture.getGlSource(source22);
            const glInternalFormat = glSource.internalFormat;
            const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i2];
            gl.bindRenderbuffer(
              gl.RENDERBUFFER,
              msaaRenderBuffer
            );
            gl.renderbufferStorageMultisample(
              gl.RENDERBUFFER,
              4,
              glInternalFormat,
              source22.pixelWidth,
              source22.pixelHeight
            );
            gl.framebufferRenderbuffer(
              gl.FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0 + i2,
              gl.RENDERBUFFER,
              msaaRenderBuffer
            );
          });
        }
      }
      _initStencil(glRenderTarget) {
        const gl = this._renderer.gl;
        const depthStencilRenderBuffer = gl.createRenderbuffer();
        glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;
        gl.bindRenderbuffer(
          gl.RENDERBUFFER,
          depthStencilRenderBuffer
        );
        gl.framebufferRenderbuffer(
          gl.FRAMEBUFFER,
          gl.DEPTH_STENCIL_ATTACHMENT,
          gl.RENDERBUFFER,
          depthStencilRenderBuffer
        );
      }
      _resizeStencil(glRenderTarget) {
        const gl = this._renderer.gl;
        gl.bindRenderbuffer(
          gl.RENDERBUFFER,
          glRenderTarget.depthStencilRenderBuffer
        );
        if (glRenderTarget.msaa) {
          gl.renderbufferStorageMultisample(
            gl.RENDERBUFFER,
            4,
            gl.DEPTH24_STENCIL8,
            glRenderTarget.width,
            glRenderTarget.height
          );
        } else {
          gl.renderbufferStorage(
            gl.RENDERBUFFER,
            gl.DEPTH24_STENCIL8,
            glRenderTarget.width,
            glRenderTarget.height
          );
        }
      }
    };
    GlRenderTargetSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "renderTarget"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs
var GlStencilSystem;
var init_GlStencilSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs"() {
    init_Extensions();
    init_GpuStencilModesToPixi();
    init_const8();
    GlStencilSystem = class {
      constructor(renderer) {
        this._stencilCache = {
          enabled: false,
          stencilReference: 0,
          stencilMode: STENCIL_MODES.NONE
        };
        this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
        renderer.renderTarget.onRenderTargetChange.add(this);
      }
      contextChange(gl) {
        this._gl = gl;
        this._comparisonFuncMapping = {
          always: gl.ALWAYS,
          never: gl.NEVER,
          equal: gl.EQUAL,
          "not-equal": gl.NOTEQUAL,
          less: gl.LESS,
          "less-equal": gl.LEQUAL,
          greater: gl.GREATER,
          "greater-equal": gl.GEQUAL
        };
        this._stencilOpsMapping = {
          keep: gl.KEEP,
          zero: gl.ZERO,
          replace: gl.REPLACE,
          invert: gl.INVERT,
          "increment-clamp": gl.INCR,
          "decrement-clamp": gl.DECR,
          "increment-wrap": gl.INCR_WRAP,
          "decrement-wrap": gl.DECR_WRAP
        };
      }
      onRenderTargetChange(renderTarget) {
        if (this._activeRenderTarget === renderTarget)
          return;
        this._activeRenderTarget = renderTarget;
        let stencilState = this._renderTargetStencilState[renderTarget.uid];
        if (!stencilState) {
          stencilState = this._renderTargetStencilState[renderTarget.uid] = {
            stencilMode: STENCIL_MODES.DISABLED,
            stencilReference: 0
          };
        }
        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
      }
      setStencilMode(stencilMode, stencilReference) {
        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
        const gl = this._gl;
        const mode = GpuStencilModesToPixi[stencilMode];
        const _stencilCache = this._stencilCache;
        stencilState.stencilMode = stencilMode;
        stencilState.stencilReference = stencilReference;
        if (stencilMode === STENCIL_MODES.DISABLED) {
          if (this._stencilCache.enabled) {
            this._stencilCache.enabled = false;
            gl.disable(gl.STENCIL_TEST);
          }
          return;
        }
        if (!this._stencilCache.enabled) {
          this._stencilCache.enabled = true;
          gl.enable(gl.STENCIL_TEST);
        }
        if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference) {
          _stencilCache.stencilMode = stencilMode;
          _stencilCache.stencilReference = stencilReference;
          gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 255);
          gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);
        }
      }
    };
    GlStencilSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "stencil"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs
var GlProgramData;
var init_GlProgramData = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs"() {
    GlProgramData = class {
      /**
       * Makes a new Pixi program.
       * @param program - webgl program
       * @param uniformData - uniforms
       */
      constructor(program, uniformData) {
        this.program = program;
        this.uniformData = uniformData;
        this.uniformGroups = {};
        this.uniformDirtyGroups = {};
        this.uniformBlockBindings = {};
      }
      /** Destroys this program. */
      destroy() {
        this.uniformData = null;
        this.uniformGroups = null;
        this.uniformDirtyGroups = null;
        this.uniformBlockBindings = null;
        this.program = null;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs
function compileShader(gl, type, src) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}
var init_compileShader = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs
function booleanArray(size2) {
  const array = new Array(size2);
  for (let i2 = 0; i2 < array.length; i2++) {
    array[i2] = false;
  }
  return array;
}
function defaultValue(type, size2) {
  switch (type) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size2);
    case "vec3":
      return new Float32Array(3 * size2);
    case "vec4":
      return new Float32Array(4 * size2);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size2);
    case "ivec3":
      return new Int32Array(3 * size2);
    case "ivec4":
      return new Int32Array(4 * size2);
    case "uvec2":
      return new Uint32Array(2 * size2);
    case "uvec3":
      return new Uint32Array(3 * size2);
    case "uvec4":
      return new Uint32Array(4 * size2);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size2);
    case "bvec3":
      return booleanArray(3 * size2);
    case "bvec4":
      return booleanArray(4 * size2);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var init_defaultValue = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapSize.mjs
function mapSize(type) {
  return GLSL_TO_SIZE[type];
}
var GLSL_TO_SIZE;
var init_mapSize = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapSize.mjs"() {
    GLSL_TO_SIZE = {
      float: 1,
      vec2: 2,
      vec3: 3,
      vec4: 4,
      int: 1,
      ivec2: 2,
      ivec3: 3,
      ivec4: 4,
      uint: 1,
      uvec2: 2,
      uvec3: 3,
      uvec4: 4,
      bool: 1,
      bvec2: 2,
      bvec3: 3,
      bvec4: 4,
      mat2: 4,
      mat3: 9,
      mat4: 16,
      sampler2D: 1
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs
function mapType(gl, type) {
  if (!GL_TABLE) {
    const typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (let i2 = 0; i2 < typeNames.length; ++i2) {
      const tn = typeNames[i2];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type];
}
var GL_TABLE, GL_TO_GLSL_TYPES;
var init_mapType = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs"() {
    GL_TABLE = null;
    GL_TO_GLSL_TYPES = {
      FLOAT: "float",
      FLOAT_VEC2: "vec2",
      FLOAT_VEC3: "vec3",
      FLOAT_VEC4: "vec4",
      INT: "int",
      INT_VEC2: "ivec2",
      INT_VEC3: "ivec3",
      INT_VEC4: "ivec4",
      UNSIGNED_INT: "uint",
      UNSIGNED_INT_VEC2: "uvec2",
      UNSIGNED_INT_VEC3: "uvec3",
      UNSIGNED_INT_VEC4: "uvec4",
      BOOL: "bool",
      BOOL_VEC2: "bvec2",
      BOOL_VEC3: "bvec3",
      BOOL_VEC4: "bvec4",
      FLOAT_MAT2: "mat2",
      FLOAT_MAT3: "mat3",
      FLOAT_MAT4: "mat4",
      SAMPLER_2D: "sampler2D",
      INT_SAMPLER_2D: "sampler2D",
      UNSIGNED_INT_SAMPLER_2D: "sampler2D",
      SAMPLER_CUBE: "samplerCube",
      INT_SAMPLER_CUBE: "samplerCube",
      UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
      SAMPLER_2D_ARRAY: "sampler2DArray",
      INT_SAMPLER_2D_ARRAY: "sampler2DArray",
      UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getAttributeData.mjs
function getAttributeData(program, gl) {
  const attributes = {};
  const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i2 = 0; i2 < totalAttributes; i2++) {
    const attribData = gl.getActiveAttrib(program, i2);
    if (attribData.name.startsWith("gl_")) {
      continue;
    }
    const type = mapType(gl, attribData.type);
    const data = {
      type,
      name: attribData.name,
      size: mapSize(type),
      location: gl.getAttribLocation(program, attribData.name)
    };
    attributes[attribData.name] = data;
  }
  return attributes;
}
var init_getAttributeData = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getAttributeData.mjs"() {
    init_mapSize();
    init_mapType();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformBufferData.mjs
function getUniformBufferData(program, gl) {
  const uniformBlocks = {};
  const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
  for (let i2 = 0; i2 < totalUniformsBlocks; i2++) {
    const name = gl.getActiveUniformBlockName(program, i2);
    const uniformBlockIndex = gl.getUniformBlockIndex(program, name);
    const size2 = gl.getActiveUniformBlockParameter(program, i2, gl.UNIFORM_BLOCK_DATA_SIZE);
    uniformBlocks[name] = {
      name,
      index: uniformBlockIndex,
      size: size2
    };
  }
  return uniformBlocks;
}
var init_getUniformBufferData = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformBufferData.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs
function getUniformData(program, gl) {
  const uniforms = {};
  const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i2 = 0; i2 < totalUniforms; i2++) {
    const uniformData = gl.getActiveUniform(program, i2);
    const name = uniformData.name.replace(/\[.*?\]$/, "");
    const isArray = !!uniformData.name.match(/\[.*?\]$/);
    const type = mapType(gl, uniformData.type);
    uniforms[name] = {
      name,
      index: i2,
      type,
      size: uniformData.size,
      isArray,
      value: defaultValue(type, uniformData.size)
    };
  }
  return uniforms;
}
var init_getUniformData = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs"() {
    init_defaultValue();
    init_mapType();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs
function logPrettyShaderError(gl, shader) {
  const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index) => `${index}: ${line}`);
  const shaderLog = gl.getShaderInfoLog(shader);
  const splitShader = shaderLog.split("\n");
  const dedupe = {};
  const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n2) => {
    if (n2 && !dedupe[n2]) {
      dedupe[n2] = true;
      return true;
    }
    return false;
  });
  const logArgs = [""];
  lineNumbers.forEach((number) => {
    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  const fragmentSourceToLog = shaderSrc.join("\n");
  logArgs[0] = fragmentSourceToLog;
  console.error(shaderLog);
  console.groupCollapsed("click to view full shader code");
  console.warn(...logArgs);
  console.groupEnd();
}
function logProgramError(gl, program, vertexShader, fragmentShader) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, vertexShader);
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, fragmentShader);
    }
    console.error("PixiJS Error: Could not initialize shader.");
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
  }
}
var init_logProgramError = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs
function generateProgram(gl, program) {
  const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);
  const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);
  const webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader);
  gl.attachShader(webGLProgram, glFragShader);
  const transformFeedbackVaryings = program.transformFeedbackVaryings;
  if (transformFeedbackVaryings) {
    if (typeof gl.transformFeedbackVaryings !== "function") {
      warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
    } else {
      gl.transformFeedbackVaryings(
        webGLProgram,
        transformFeedbackVaryings.names,
        transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS
      );
    }
  }
  gl.linkProgram(webGLProgram);
  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
    logProgramError(gl, webGLProgram, glVertShader, glFragShader);
  }
  program.attributeData = getAttributeData(webGLProgram, gl);
  program.uniformData = getUniformData(webGLProgram, gl);
  program.uniformBlockData = getUniformBufferData(webGLProgram, gl);
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  const uniformData = {};
  for (const i2 in program.uniformData) {
    const data = program.uniformData[i2];
    uniformData[i2] = {
      location: gl.getUniformLocation(webGLProgram, i2),
      value: defaultValue(data.type, data.size)
    };
  }
  const glProgram = new GlProgramData(webGLProgram, uniformData);
  return glProgram;
}
var init_generateProgram = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs"() {
    init_warn();
    init_GlProgramData();
    init_compileShader();
    init_defaultValue();
    init_getAttributeData();
    init_getUniformBufferData();
    init_getUniformData();
    init_logProgramError();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs
var defaultSyncData, GlShaderSystem;
var init_GlShaderSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs"() {
    init_Extensions();
    init_BufferResource();
    init_UniformGroup();
    init_TextureSource();
    init_TextureStyle();
    init_generateProgram();
    defaultSyncData = {
      textureCount: 0,
      blockIndex: 0
    };
    GlShaderSystem = class {
      constructor(renderer) {
        this.activeProgram = null;
        this._programDataHash = /* @__PURE__ */ Object.create(null);
        this._nextIndex = 0;
        this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null);
        this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      contextChange(gl) {
        this._gl = gl;
        this._maxBindings = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);
      }
      bind(shader, skipSync) {
        this._setProgram(shader.glProgram);
        if (skipSync)
          return;
        defaultSyncData.textureCount = 0;
        defaultSyncData.blockIndex = 0;
        const gl = this._gl;
        const programData = this.getProgramData(shader.glProgram);
        for (const i2 in shader.groups) {
          const bindGroup = shader.groups[i2];
          for (const j3 in bindGroup.resources) {
            const resource = bindGroup.resources[j3];
            if (resource instanceof UniformGroup) {
              if (resource.ubo) {
                this.bindUniformBlock(
                  resource,
                  shader.uniformBindMap[i2][j3],
                  defaultSyncData.blockIndex++
                );
              } else {
                this._updateUniformGroup(resource);
              }
            } else if (resource instanceof BufferResource) {
              this.bindUniformBlock(
                resource,
                shader.uniformBindMap[i2][j3],
                defaultSyncData.blockIndex++
              );
            } else if (resource instanceof TextureSource) {
              this._renderer.texture.bind(resource, defaultSyncData.textureCount);
              const uniformName = shader.uniformBindMap[i2][j3];
              const uniformData = programData.uniformData[uniformName];
              if (uniformData) {
                if (uniformData.value !== defaultSyncData.textureCount) {
                  gl.uniform1i(uniformData.location, defaultSyncData.textureCount);
                }
                defaultSyncData.textureCount++;
              }
            } else if (resource instanceof TextureStyle) {
            }
          }
        }
      }
      _updateUniformGroup(uniformGroup) {
        this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this.activeProgram, defaultSyncData);
      }
      bindUniformBlock(uniformGroup, name, index = 0) {
        const bufferSystem = this._renderer.buffer;
        const programData = this.getProgramData(this.activeProgram);
        const isBufferResource = uniformGroup.bufferResource;
        if (isBufferResource) {
          this._renderer.uniformBuffer.updateUniformGroup(uniformGroup);
        }
        bufferSystem.updateBuffer(uniformGroup.buffer);
        let boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid];
        if (boundIndex === void 0) {
          const nextIndex = this._nextIndex++ % this._maxBindings;
          const currentBoundUniformGroup = this._boundIndexToUniformsHash[nextIndex];
          if (currentBoundUniformGroup) {
            this._boundUniformsIdsToIndexHash[currentBoundUniformGroup.uid] = void 0;
          }
          boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid] = nextIndex;
          this._boundIndexToUniformsHash[nextIndex] = uniformGroup;
          if (isBufferResource) {
            bufferSystem.bindBufferRange(uniformGroup.buffer, nextIndex, uniformGroup.offset);
          } else {
            bufferSystem.bindBufferBase(uniformGroup.buffer, nextIndex);
          }
        }
        const gl = this._gl;
        const uniformBlockIndex = this.activeProgram.uniformBlockData[name].index;
        if (programData.uniformBlockBindings[index] === boundIndex)
          return;
        programData.uniformBlockBindings[index] = boundIndex;
        gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundIndex);
      }
      _setProgram(program) {
        if (this.activeProgram === program)
          return;
        this.activeProgram = program;
        const programData = this.getProgramData(program);
        this._gl.useProgram(programData.program);
      }
      getProgramData(program) {
        return this._programDataHash[program.key] || this._createProgramData(program);
      }
      _createProgramData(program) {
        const key = program.key;
        this._programDataHash[key] = generateProgram(this._gl, program);
        return this._programDataHash[key];
      }
      destroy() {
        for (const key of Object.keys(this._programDataHash)) {
          const programData = this._programDataHash[key];
          programData.destroy();
          this._programDataHash[key] = null;
        }
        this._programDataHash = null;
        this._boundUniformsIdsToIndexHash = null;
      }
    };
    GlShaderSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "shader"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/unsafeEvalSupported.mjs
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func({ a: "b" }, "a", "b") === true;
  } catch (e2) {
    unsafeEval = false;
  }
  return unsafeEval;
}
var unsafeEval;
var init_unsafeEvalSupported = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/unsafeEvalSupported.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/uniformParsers.mjs
var uniformParsers;
var init_uniformParsers = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/uniformParsers.mjs"() {
    init_Texture();
    uniformParsers = [
      // a float cache layer
      {
        test: (data) => data.type === "float" && data.size === 1 && !data.isArray,
        code: (name) => `
            if(uv["${name}"] !== ud["${name}"].value)
            {
                ud["${name}"].value = uv["${name}"]
                gl.uniform1f(ud["${name}"].location, uv["${name}"])
            }
            `
      },
      // handling samplers
      {
        test: (data, uniform) => (
          // eslint-disable-next-line max-len,no-eq-null,eqeqeq
          (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform instanceof Texture)
        ),
        code: (name) => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${name}"], t);

            if(ud["${name}"].value !== t)
            {
                ud["${name}"].value = t;
                gl.uniform1i(ud["${name}"].location, t);
; // eslint-disable-line max-len
            }`
      },
      // uploading pixi matrix object to mat3
      {
        test: (data, uniform) => data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== void 0,
        code: (name) => (
          // TODO and some smart caching dirty ids here!
          `
            gl.uniformMatrix3fv(ud["${name}"].location, false, uv["${name}"].toArray(true));
            `
        )
      },
      // uploading a pixi point as a vec2 with caching layer
      {
        test: (data, uniform) => data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== void 0,
        code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${name}"].location, v.x, v.y);
                }`
      },
      // caching layer for a vec2
      {
        test: (data) => data.type === "vec2" && data.size === 1 && !data.isArray,
        code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${name}"].location, v[0], v[1]);
                }
            `
      },
      // upload a pixi rectangle as a vec4 with caching layer
      {
        test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== void 0,
        code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${name}"].location, v.x, v.y, v.width, v.height)
                }`
      },
      // upload a pixi color as vec4 with caching layer
      {
        test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.red !== void 0,
        code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${name}"].location, v.red, v.green, v.blue, v.alpha)
                }`
      },
      // upload a pixi color as a vec3 with caching layer
      {
        test: (data, uniform) => data.type === "vec3" && data.size === 1 && !data.isArray && uniform.red !== void 0,
        code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
    
                    gl.uniform3f(ud["${name}"].location, v.red, v.green, v.blue)
                }`
      },
      // a caching layer for vec4 uploading
      {
        test: (data) => data.type === "vec4" && data.size === 1 && !data.isArray,
        code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${name}"].location, v[0], v[1], v[2], v[3])
                }`
      }
    ];
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateUniformsSync.mjs
function generateUniformsSync(group, uniformData) {
  const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
  for (const i2 in group.uniforms) {
    const data = uniformData[i2];
    if (!data) {
      if (group.uniforms[i2] instanceof UniformGroup) {
        if (group.uniforms[i2].ubo) {
          funcFragments.push(`
                        renderer.shader.bindUniformBlock(uv.${i2}, "${i2}");
                    `);
        } else {
          funcFragments.push(`
                        renderer.shader.updateUniformGroup(uv.${i2});
                    `);
        }
      } else if (group.uniforms[i2] instanceof BufferResource) {
        funcFragments.push(`
                        renderer.shader.bindBufferResource(uv.${i2}, "${i2}");
                    `);
      }
      continue;
    }
    const uniform = group.uniforms[i2];
    let parsed = false;
    for (let j3 = 0; j3 < uniformParsers.length; j3++) {
      if (uniformParsers[j3].test(data, uniform)) {
        funcFragments.push(uniformParsers[j3].code(i2, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      const templateType = data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
      const template = templateType[data.type].replace("location", `ud["${i2}"].location`);
      funcFragments.push(`
            cu = ud["${i2}"];
            cv = cu.value;
            v = uv["${i2}"];
            ${template};`);
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
}
var GLSL_TO_SINGLE_SETTERS_CACHED, GLSL_TO_ARRAY_SETTERS;
var init_generateUniformsSync = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateUniformsSync.mjs"() {
    init_BufferResource();
    init_UniformGroup();
    init_uniformParsers();
    GLSL_TO_SINGLE_SETTERS_CACHED = {
      float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
      vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
      vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
      vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
      int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
      ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
      ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
      ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
      uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
      uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
      uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
      uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
      bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
      bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
      bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
      bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
      mat2: "gl.uniformMatrix2fv(location, false, v)",
      mat3: "gl.uniformMatrix3fv(location, false, v)",
      mat4: "gl.uniformMatrix4fv(location, false, v)",
      sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
      samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
      sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
    };
    GLSL_TO_ARRAY_SETTERS = {
      float: `gl.uniform1fv(location, v)`,
      vec2: `gl.uniform2fv(location, v)`,
      vec3: `gl.uniform3fv(location, v)`,
      vec4: "gl.uniform4fv(location, v)",
      mat4: "gl.uniformMatrix4fv(location, false, v)",
      mat3: "gl.uniformMatrix3fv(location, false, v)",
      mat2: "gl.uniformMatrix2fv(location, false, v)",
      int: "gl.uniform1iv(location, v)",
      ivec2: "gl.uniform2iv(location, v)",
      ivec3: "gl.uniform3iv(location, v)",
      ivec4: "gl.uniform4iv(location, v)",
      uint: "gl.uniform1uiv(location, v)",
      uvec2: "gl.uniform2uiv(location, v)",
      uvec3: "gl.uniform3uiv(location, v)",
      uvec4: "gl.uniform4uiv(location, v)",
      bool: "gl.uniform1iv(location, v)",
      bvec2: "gl.uniform2iv(location, v)",
      bvec3: "gl.uniform3iv(location, v)",
      bvec4: "gl.uniform4iv(location, v)",
      sampler2D: "gl.uniform1iv(location, v)",
      samplerCube: "gl.uniform1iv(location, v)",
      sampler2DArray: "gl.uniform1iv(location, v)"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs
var GlUniformGroupSystem;
var init_GlUniformGroupSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs"() {
    init_Extensions();
    init_unsafeEvalSupported();
    init_generateUniformsSync();
    GlUniformGroupSystem = class {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this.destroyed = false;
        this._cache = {};
        this._uniformGroupSyncHash = {};
        this._renderer = renderer;
        this._systemCheck();
        this.gl = null;
        this._cache = {};
      }
      /**
       * Overrideable function by `@pixi/unsafe-eval` to silence
       * throwing an error if platform doesn't support unsafe-evals.
       * @private
       */
      _systemCheck() {
        if (!unsafeEvalSupported()) {
          throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
        }
      }
      contextChange(gl) {
        this.gl = gl;
      }
      /**
       * Uploads the uniforms values to the currently bound shader.
       * @param group - the uniforms values that be applied to the current shader
       * @param program
       * @param syncData
       * @param syncData.textureCount
       */
      updateUniformGroup(group, program, syncData) {
        const programData = this._renderer.shader.getProgramData(program);
        if (!group.isStatic || group.dirtyId !== programData.uniformDirtyGroups[group.uid]) {
          programData.uniformDirtyGroups[group.uid] = group.dirtyId;
          const syncFunc = this._getUniformSyncFunction(group, program);
          syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);
        }
      }
      /**
       * Overrideable by the @pixi/unsafe-eval package to use static syncUniforms instead.
       * @param group
       * @param program
       */
      _getUniformSyncFunction(group, program) {
        return this._uniformGroupSyncHash[group.signature]?.[program.key] || this._createUniformSyncFunction(group, program);
      }
      _createUniformSyncFunction(group, program) {
        const uniformGroupSyncHash = this._uniformGroupSyncHash[group.signature] || (this._uniformGroupSyncHash[group.signature] = {});
        const id = this._getSignature(group, program.uniformData, "u");
        if (!this._cache[id]) {
          this._cache[id] = generateUniformsSync(group, program.uniformData);
        }
        uniformGroupSyncHash[program.key] = this._cache[id];
        return uniformGroupSyncHash[program.key];
      }
      /**
       * Takes a uniform group and data and generates a unique signature for them.
       * @param group - The uniform group to get signature of
       * @param group.uniforms
       * @param uniformData - Uniform information generated by the shader
       * @param preFix
       * @returns Unique signature of the uniform group
       */
      _getSignature(group, uniformData, preFix) {
        const uniforms = group.uniforms;
        const strings = [`${preFix}-`];
        for (const i2 in uniforms) {
          strings.push(i2);
          if (uniformData[i2]) {
            strings.push(uniformData[i2].type);
          }
        }
        return strings.join("-");
      }
      /** Destroys this System and removes all its textures. */
      destroy() {
        this._renderer = null;
        this.destroyed = true;
        this._cache = null;
      }
    };
    GlUniformGroupSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "uniformGroup"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs
function mapWebGLBlendModesToPixi(gl) {
  const blendMap = {};
  blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.add = [gl.ONE, gl.ONE];
  blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.none = [0, 0];
  blendMap["normal-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap["add-npm"] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  blendMap["screen-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  return blendMap;
}
var init_mapWebGLBlendModesToPixi = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs
var BLEND2, OFFSET2, CULLING2, DEPTH_TEST2, WINDING2, DEPTH_MASK2, _GlStateSystem, GlStateSystem;
var init_GlStateSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs"() {
    init_Extensions();
    init_State();
    init_mapWebGLBlendModesToPixi();
    BLEND2 = 0;
    OFFSET2 = 1;
    CULLING2 = 2;
    DEPTH_TEST2 = 3;
    WINDING2 = 4;
    DEPTH_MASK2 = 5;
    _GlStateSystem = class {
      constructor() {
        this.gl = null;
        this.stateId = 0;
        this.polygonOffset = 0;
        this.blendMode = "none";
        this._blendEq = false;
        this.map = [];
        this.map[BLEND2] = this.setBlend;
        this.map[OFFSET2] = this.setOffset;
        this.map[CULLING2] = this.setCullFace;
        this.map[DEPTH_TEST2] = this.setDepthTest;
        this.map[WINDING2] = this.setFrontFace;
        this.map[DEPTH_MASK2] = this.setDepthMask;
        this.checks = [];
        this.defaultState = new State();
        this.defaultState.blend = true;
      }
      contextChange(gl) {
        this.gl = gl;
        this.blendModesMap = mapWebGLBlendModesToPixi(gl);
        this.set(this.defaultState);
        this.reset();
      }
      /**
       * Sets the current state
       * @param {*} state - The state to set.
       */
      set(state) {
        state = state || this.defaultState;
        if (this.stateId !== state.data) {
          let diff = this.stateId ^ state.data;
          let i2 = 0;
          while (diff) {
            if (diff & 1) {
              this.map[i2].call(this, !!(state.data & 1 << i2));
            }
            diff = diff >> 1;
            i2++;
          }
          this.stateId = state.data;
        }
        for (let i2 = 0; i2 < this.checks.length; i2++) {
          this.checks[i2](this, state);
        }
      }
      /**
       * Sets the state, when previous state is unknown.
       * @param {*} state - The state to set
       */
      forceState(state) {
        state = state || this.defaultState;
        for (let i2 = 0; i2 < this.map.length; i2++) {
          this.map[i2].call(this, !!(state.data & 1 << i2));
        }
        for (let i2 = 0; i2 < this.checks.length; i2++) {
          this.checks[i2](this, state);
        }
        this.stateId = state.data;
      }
      /**
       * Sets whether to enable or disable blending.
       * @param value - Turn on or off WebGl blending.
       */
      setBlend(value) {
        this._updateCheck(_GlStateSystem._checkBlendMode, value);
        this.gl[value ? "enable" : "disable"](this.gl.BLEND);
      }
      /**
       * Sets whether to enable or disable polygon offset fill.
       * @param value - Turn on or off webgl polygon offset testing.
       */
      setOffset(value) {
        this._updateCheck(_GlStateSystem._checkPolygonOffset, value);
        this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
      }
      /**
       * Sets whether to enable or disable depth test.
       * @param value - Turn on or off webgl depth testing.
       */
      setDepthTest(value) {
        this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
      }
      /**
       * Sets whether to enable or disable depth mask.
       * @param value - Turn on or off webgl depth mask.
       */
      setDepthMask(value) {
        this.gl.depthMask(value);
      }
      /**
       * Sets whether to enable or disable cull face.
       * @param {boolean} value - Turn on or off webgl cull face.
       */
      setCullFace(value) {
        this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
      }
      /**
       * Sets the gl front face.
       * @param {boolean} value - true is clockwise and false is counter-clockwise
       */
      setFrontFace(value) {
        this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
      }
      /**
       * Sets the blend mode.
       * @param {number} value - The blend mode to set to.
       */
      setBlendMode(value) {
        if (!this.blendModesMap[value]) {
          value = "normal";
        }
        if (value === this.blendMode) {
          return;
        }
        this.blendMode = value;
        const mode = this.blendModesMap[value];
        const gl = this.gl;
        if (mode.length === 2) {
          gl.blendFunc(mode[0], mode[1]);
        } else {
          gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
        }
        if (mode.length === 6) {
          this._blendEq = true;
          gl.blendEquationSeparate(mode[4], mode[5]);
        } else if (this._blendEq) {
          this._blendEq = false;
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        }
      }
      /**
       * Sets the polygon offset.
       * @param {number} value - the polygon offset
       * @param {number} scale - the polygon offset scale
       */
      setPolygonOffset(value, scale3) {
        this.gl.polygonOffset(value, scale3);
      }
      // used
      /** Resets all the logic and disables the VAOs. */
      reset() {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
        this.forceState(this.defaultState);
        this._blendEq = true;
        this.blendMode = "";
        this.setBlendMode("normal");
      }
      /**
       * Checks to see which updates should be checked based on which settings have been activated.
       *
       * For example, if blend is enabled then we should check the blend modes each time the state is changed
       * or if polygon fill is activated then we need to check if the polygon offset changes.
       * The idea is that we only check what we have too.
       * @param func - the checking function to add or remove
       * @param value - should the check function be added or removed.
       */
      _updateCheck(func, value) {
        const index = this.checks.indexOf(func);
        if (value && index === -1) {
          this.checks.push(func);
        } else if (!value && index !== -1) {
          this.checks.splice(index, 1);
        }
      }
      /**
       * A private little wrapper function that we call to check the blend mode.
       * @param system - the System to perform the state check on
       * @param state - the state that the blendMode will pulled from
       */
      static _checkBlendMode(system, state) {
        system.setBlendMode(state.blendMode);
      }
      /**
       * A private little wrapper function that we call to check the polygon offset.
       * @param system - the System to perform the state check on
       * @param state - the state that the blendMode will pulled from
       */
      static _checkPolygonOffset(system, state) {
        system.setPolygonOffset(1, state.polygonOffset);
      }
      /**
       * @ignore
       */
      destroy() {
        this.gl = null;
        this.checks.length = 0;
      }
    };
    GlStateSystem = _GlStateSystem;
    GlStateSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "state"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs
var GlTexture;
var init_GlTexture = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs"() {
    init_const10();
    GlTexture = class {
      constructor(texture) {
        this.target = GL_TARGETS.TEXTURE_2D;
        this.texture = texture;
        this.width = -1;
        this.height = -1;
        this.type = GL_TYPES.UNSIGNED_BYTE;
        this.internalFormat = GL_FORMATS.RGBA;
        this.format = GL_FORMATS.RGBA;
        this.samplerType = 0;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs
var glUploadBufferImageResource;
var init_glUploadBufferImageResource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs"() {
    glUploadBufferImageResource = {
      id: "image",
      upload(source3, glTexture, gl) {
        if (glTexture.width === source3.width || glTexture.height === source3.height) {
          gl.texSubImage2D(
            gl.TEXTURE_2D,
            0,
            0,
            0,
            glTexture.format,
            glTexture.type,
            source3.resource
          );
        } else {
          gl.texImage2D(
            glTexture.target,
            0,
            glTexture.internalFormat,
            source3.width,
            source3.height,
            0,
            glTexture.format,
            glTexture.type,
            source3.resource
          );
        }
        glTexture.width = source3.width;
        glTexture.height = source3.height;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs
var glUploadImageResource;
var init_glUploadImageResource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs"() {
    glUploadImageResource = {
      id: "image",
      upload(source3, glTexture, gl) {
        const premultipliedAlpha = source3.alphaMode === "premultiply-alpha-on-upload";
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);
        const glWidth = glTexture.width;
        const glHeight = glTexture.height;
        const textureWidth = source3.pixelWidth;
        const textureHeight = source3.pixelHeight;
        const resourceWidth = source3.resourceWidth;
        const resourceHeight = source3.resourceHeight;
        if (resourceWidth < textureWidth || resourceHeight < textureHeight) {
          if (glWidth !== textureWidth || glHeight !== textureHeight) {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              textureWidth,
              textureHeight,
              0,
              glTexture.format,
              glTexture.type,
              null
            );
          }
          gl.texSubImage2D(
            gl.TEXTURE_2D,
            0,
            0,
            0,
            resourceWidth,
            resourceHeight,
            glTexture.format,
            glTexture.type,
            source3.resource
          );
        } else if (glWidth === textureWidth || glHeight === textureHeight) {
          gl.texSubImage2D(
            gl.TEXTURE_2D,
            0,
            0,
            0,
            glTexture.format,
            glTexture.type,
            source3.resource
          );
        } else {
          gl.texImage2D(
            glTexture.target,
            0,
            glTexture.internalFormat,
            textureWidth,
            textureHeight,
            0,
            glTexture.format,
            glTexture.type,
            source3.resource
          );
        }
        glTexture.width = textureWidth;
        glTexture.height = textureHeight;
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs
var glUploadVideoResource;
var init_glUploadVideoResource = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs"() {
    init_glUploadImageResource();
    glUploadVideoResource = {
      id: "video",
      upload(source3, glTexture, gl) {
        if (!source3.isValid) {
          gl.texImage2D(
            glTexture.target,
            0,
            glTexture.internalFormat,
            1,
            1,
            0,
            glTexture.format,
            glTexture.type,
            null
          );
          return;
        }
        glUploadImageResource.upload(source3, glTexture, gl);
      }
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs
var scaleModeToGlFilter, mipmapScaleModeToGlFilter, wrapModeToGlAddress, compareModeToGlCompare;
var init_pixiToGlMaps = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs"() {
    scaleModeToGlFilter = {
      linear: 9729,
      nearest: 9728
    };
    mipmapScaleModeToGlFilter = {
      linear: {
        linear: 9987,
        nearest: 9985
      },
      nearest: {
        linear: 9986,
        nearest: 9984
      }
    };
    wrapModeToGlAddress = {
      "clamp-to-edge": 33071,
      repeat: 10497,
      "mirror-repeat": 33648
    };
    compareModeToGlCompare = {
      never: 512,
      less: 513,
      equal: 514,
      "less-equal": 515,
      greater: 516,
      "not-equal": 517,
      "greater-equal": 518,
      always: 519
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs
function applyStyleParams(style, gl, mipmaps, anisotropicExt, glFunctionName, firstParam) {
  const castParam = firstParam;
  gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeToGlAddress[style.addressModeU]);
  gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeToGlAddress[style.addressModeV]);
  gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeToGlAddress[style.addressModeW]);
  gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);
  if (mipmaps) {
    const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];
    gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);
  } else {
    gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);
  }
  if (anisotropicExt && style.maxAnisotropy > 1) {
    const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
    gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
  }
  if (style.compare) {
    gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);
  }
}
var init_applyStyleParams = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs"() {
    init_pixiToGlMaps();
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs
function mapFormatToGlFormat(gl) {
  return {
    // 8-bit formats
    r8unorm: gl.RED,
    r8snorm: gl.RED,
    r8uint: gl.RED,
    r8sint: gl.RED,
    // 16-bit formats
    r16uint: gl.RED,
    r16sint: gl.RED,
    r16float: gl.RED,
    rg8unorm: gl.RG,
    rg8snorm: gl.RG,
    rg8uint: gl.RG,
    rg8sint: gl.RG,
    // 32-bit formats
    r32uint: gl.RED,
    r32sint: gl.RED,
    r32float: gl.RED,
    rg16uint: gl.RG,
    rg16sint: gl.RG,
    rg16float: gl.RG,
    rgba8unorm: gl.RGBA,
    "rgba8unorm-srgb": gl.RGBA,
    // Packed 32-bit formats
    rgba8snorm: gl.RGBA,
    rgba8uint: gl.RGBA,
    rgba8sint: gl.RGBA,
    bgra8unorm: gl.RGBA,
    "bgra8unorm-srgb": gl.RGBA,
    rgb9e5ufloat: gl.RGB,
    rgb10a2unorm: gl.RGBA,
    rg11b10ufloat: gl.RGB,
    // 64-bit formats
    rg32uint: gl.RG,
    rg32sint: gl.RG,
    rg32float: gl.RG,
    rgba16uint: gl.RGBA,
    rgba16sint: gl.RGBA,
    rgba16float: gl.RGBA,
    // 128-bit formats
    rgba32uint: gl.RGBA,
    rgba32sint: gl.RGBA,
    rgba32float: gl.RGBA,
    // Depth/stencil formats
    stencil8: gl.STENCIL_INDEX8,
    depth16unorm: gl.DEPTH_COMPONENT,
    depth24plus: gl.DEPTH_COMPONENT,
    "depth24plus-stencil8": gl.DEPTH_STENCIL,
    depth32float: gl.DEPTH_COMPONENT,
    "depth32float-stencil8": gl.DEPTH_STENCIL
  };
}
var init_mapFormatToGlFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs
function mapFormatToGlInternalFormat(gl) {
  return {
    // 8-bit formats
    r8unorm: gl.R8,
    r8snorm: gl.R8_SNORM,
    r8uint: gl.R8UI,
    r8sint: gl.R8I,
    // 16-bit formats
    r16uint: gl.R16UI,
    r16sint: gl.R16I,
    r16float: gl.R16F,
    rg8unorm: gl.RG8,
    rg8snorm: gl.RG8_SNORM,
    rg8uint: gl.RG8UI,
    rg8sint: gl.RG8I,
    // 32-bit formats
    r32uint: gl.R32UI,
    r32sint: gl.R32I,
    r32float: gl.R32F,
    rg16uint: gl.RG16UI,
    rg16sint: gl.RG16I,
    rg16float: gl.RG16F,
    rgba8unorm: gl.RGBA,
    "rgba8unorm-srgb": gl.SRGB8_ALPHA8,
    // Packed 32-bit formats
    rgba8snorm: gl.RGBA8_SNORM,
    rgba8uint: gl.RGBA8UI,
    rgba8sint: gl.RGBA8I,
    bgra8unorm: gl.RGBA8,
    "bgra8unorm-srgb": gl.SRGB8_ALPHA8,
    rgb9e5ufloat: gl.RGB9_E5,
    rgb10a2unorm: gl.RGB10_A2,
    rg11b10ufloat: gl.R11F_G11F_B10F,
    // 64-bit formats
    rg32uint: gl.RG32UI,
    rg32sint: gl.RG32I,
    rg32float: gl.RG32F,
    rgba16uint: gl.RGBA16UI,
    rgba16sint: gl.RGBA16I,
    rgba16float: gl.RGBA16F,
    // 128-bit formats
    rgba32uint: gl.RGBA32UI,
    rgba32sint: gl.RGBA32I,
    rgba32float: gl.RGBA32F,
    // Depth/stencil formats
    stencil8: gl.STENCIL_INDEX8,
    depth16unorm: gl.DEPTH_COMPONENT16,
    depth24plus: gl.DEPTH_COMPONENT24,
    "depth24plus-stencil8": gl.DEPTH24_STENCIL8,
    depth32float: gl.DEPTH_COMPONENT32F,
    "depth32float-stencil8": gl.DEPTH32F_STENCIL8
  };
}
var init_mapFormatToGlInternalFormat = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs
function mapFormatToGlType(gl) {
  return {
    // 8-bit formats
    r8unorm: gl.UNSIGNED_BYTE,
    r8snorm: gl.BYTE,
    r8uint: gl.UNSIGNED_BYTE,
    r8sint: gl.BYTE,
    // 16-bit formats
    r16uint: gl.UNSIGNED_SHORT,
    r16sint: gl.SHORT,
    r16float: gl.HALF_FLOAT,
    rg8unorm: gl.UNSIGNED_BYTE,
    rg8snorm: gl.BYTE,
    rg8uint: gl.UNSIGNED_BYTE,
    rg8sint: gl.BYTE,
    // 32-bit formats
    r32uint: gl.UNSIGNED_INT,
    r32sint: gl.INT,
    r32float: gl.FLOAT,
    rg16uint: gl.UNSIGNED_SHORT,
    rg16sint: gl.SHORT,
    rg16float: gl.HALF_FLOAT,
    rgba8unorm: gl.UNSIGNED_BYTE,
    "rgba8unorm-srgb": gl.UNSIGNED_BYTE,
    // Packed 32-bit formats
    rgba8snorm: gl.BYTE,
    rgba8uint: gl.UNSIGNED_BYTE,
    rgba8sint: gl.BYTE,
    bgra8unorm: gl.UNSIGNED_BYTE,
    "bgra8unorm-srgb": gl.UNSIGNED_BYTE,
    rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,
    rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,
    rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,
    // 64-bit formats
    rg32uint: gl.UNSIGNED_INT,
    rg32sint: gl.INT,
    rg32float: gl.FLOAT,
    rgba16uint: gl.UNSIGNED_SHORT,
    rgba16sint: gl.SHORT,
    rgba16float: gl.HALF_FLOAT,
    // 128-bit formats
    rgba32uint: gl.UNSIGNED_INT,
    rgba32sint: gl.INT,
    rgba32float: gl.FLOAT,
    // Depth/stencil formats
    stencil8: gl.UNSIGNED_BYTE,
    depth16unorm: gl.UNSIGNED_SHORT,
    depth24plus: gl.UNSIGNED_INT,
    "depth24plus-stencil8": gl.UNSIGNED_INT_24_8,
    depth32float: gl.FLOAT,
    "depth32float-stencil8": gl.FLOAT_32_UNSIGNED_INT_24_8_REV
  };
}
var init_mapFormatToGlType = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs"() {
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs
var TEMP_RECT, BYTES_PER_PIXEL, GlTextureSystem;
var init_GlTextureSystem = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs"() {
    init_Extensions();
    init_Rectangle();
    init_adapter();
    init_Texture();
    init_GlTexture();
    init_glUploadBufferImageResource();
    init_glUploadImageResource();
    init_glUploadVideoResource();
    init_applyStyleParams();
    init_mapFormatToGlFormat();
    init_mapFormatToGlInternalFormat();
    init_mapFormatToGlType();
    TEMP_RECT = new Rectangle();
    BYTES_PER_PIXEL = 4;
    GlTextureSystem = class {
      constructor(renderer) {
        this.managedTextures = [];
        this._glTextures = /* @__PURE__ */ Object.create(null);
        this._glSamplers = /* @__PURE__ */ Object.create(null);
        this._boundTextures = [];
        this._activeTextureLocation = -1;
        this._boundSamplers = /* @__PURE__ */ Object.create(null);
        this._uploads = {
          image: glUploadImageResource,
          buffer: glUploadBufferImageResource,
          video: glUploadVideoResource
        };
        this._useSeparateSamplers = false;
        this._renderer = renderer;
      }
      contextChange(gl) {
        this._gl = gl;
        if (!this._mapFormatToInternalFormat) {
          this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl);
          this._mapFormatToType = mapFormatToGlType(gl);
          this._mapFormatToFormat = mapFormatToGlFormat(gl);
        }
        for (let i2 = 0; i2 < 16; i2++) {
          this.bind(Texture.EMPTY, i2);
        }
      }
      bind(texture, location = 0) {
        const source3 = texture.source;
        if (texture) {
          this.bindSource(source3, location);
          if (this._useSeparateSamplers) {
            this._bindSampler(source3.style, location);
          }
        } else {
          this.bindSource(null, location);
          if (this._useSeparateSamplers) {
            this._bindSampler(null, location);
          }
        }
      }
      bindSource(source3, location = 0) {
        const gl = this._gl;
        source3.touched = this._renderer.textureGC.count;
        if (this._boundTextures[location] !== source3) {
          this._boundTextures[location] = source3;
          this._activateLocation(location);
          source3 = source3 || Texture.EMPTY.source;
          const glTexture = this.getGlSource(source3);
          gl.bindTexture(glTexture.target, glTexture.texture);
        }
      }
      _bindSampler(style, location = 0) {
        const gl = this._gl;
        if (!style) {
          this._boundSamplers[location] = null;
          gl.bindSampler(location, null);
          return;
        }
        const sampler = this._getGlSampler(style);
        if (this._boundSamplers[location] !== sampler) {
          this._boundSamplers[location] = sampler;
          gl.bindSampler(location, sampler);
        }
      }
      unbind(texture) {
        const source3 = texture.source;
        const boundTextures = this._boundTextures;
        const gl = this._gl;
        for (let i2 = 0; i2 < boundTextures.length; i2++) {
          if (boundTextures[i2] === source3) {
            this._activateLocation(i2);
            const glTexture = this.getGlSource(source3);
            gl.bindTexture(glTexture.target, null);
            boundTextures[i2] = null;
          }
        }
      }
      _activateLocation(location) {
        if (this._activeTextureLocation !== location) {
          this._activeTextureLocation = location;
          this._gl.activeTexture(this._gl.TEXTURE0 + location);
        }
      }
      _initSource(source3) {
        const gl = this._gl;
        const glTexture = new GlTexture(gl.createTexture());
        glTexture.type = this._mapFormatToType[source3.format];
        glTexture.internalFormat = this._mapFormatToInternalFormat[source3.format];
        glTexture.format = this._mapFormatToFormat[source3.format];
        if (source3.autoGenerateMipmaps) {
          const biggestDimension = Math.max(source3.width, source3.height);
          source3.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
        }
        this._glTextures[source3.uid] = glTexture;
        source3.on("update", this.onSourceUpdate, this);
        source3.on("resize", this.onSourceUpdate, this);
        source3.on("styleChange", this.onStyleChange, this);
        source3.on("destroy", this.onSourceDestroy, this);
        source3.on("unload", this.onSourceUnload, this);
        this.managedTextures.push(source3);
        this.onSourceUpdate(source3);
        this.onStyleChange(source3);
        return glTexture;
      }
      onStyleChange(source3) {
        const gl = this._gl;
        const glTexture = this._glTextures[source3.uid];
        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
        this._boundTextures[this._activeTextureLocation] = source3;
        applyStyleParams(
          source3.style,
          gl,
          source3.mipLevelCount > 1,
          this._renderer.context.extensions.anisotropicFiltering,
          "texParameteri",
          gl.TEXTURE_2D
        );
      }
      onSourceUnload(source3) {
        const glTexture = this._glTextures[source3.uid];
        if (!glTexture)
          return;
        this.unbind(source3);
        this._glTextures[source3.uid] = null;
        this._gl.deleteTexture(glTexture.texture);
      }
      onSourceUpdate(source3) {
        const gl = this._gl;
        const glTexture = this.getGlSource(source3);
        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
        this._boundTextures[this._activeTextureLocation] = source3;
        if (this._uploads[source3.uploadMethodId]) {
          this._uploads[source3.uploadMethodId].upload(source3, glTexture, this._gl);
          if (source3.autoGenerateMipmaps && source3.mipLevelCount > 1) {
            gl.generateMipmap(glTexture.target);
          }
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source3.pixelWidth, source3.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
      }
      onSourceDestroy(source3) {
        source3.off("destroy", this.onSourceDestroy, this);
        source3.off("update", this.onSourceUpdate, this);
        source3.off("unload", this.onSourceUnload, this);
        this.managedTextures.splice(this.managedTextures.indexOf(source3), 1);
        this.onSourceUnload(source3);
      }
      _initSampler(style) {
        const gl = this._gl;
        const glSampler = this._gl.createSampler();
        this._glSamplers[style.resourceId] = glSampler;
        applyStyleParams(
          style,
          gl,
          this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,
          this._renderer.context.extensions.anisotropicFiltering,
          "samplerParameteri",
          glSampler
        );
        return this._glSamplers[style.resourceId];
      }
      _getGlSampler(sampler) {
        return this._glSamplers[sampler.resourceId] || this._initSampler(sampler);
      }
      getGlSource(source3) {
        return this._glTextures[source3.uid] || this._initSource(source3);
      }
      generateCanvas(texture) {
        const { pixels, width, height } = this.getPixels(texture);
        const canvas2 = DOMAdapter.get().createCanvas();
        canvas2.width = width;
        canvas2.height = height;
        const ctx2 = canvas2.getContext("2d");
        if (ctx2) {
          const imageData = ctx2.createImageData(width, height);
          imageData.data.set(pixels);
          ctx2.putImageData(imageData, 0, 0);
        }
        return canvas2;
      }
      getPixels(texture) {
        const resolution = texture.source.resolution;
        const frame = TEMP_RECT;
        frame.x = texture.frameX;
        frame.y = texture.frameY;
        frame.width = texture.frameWidth;
        frame.height = texture.frameHeight;
        const width = Math.max(Math.round(frame.width * resolution), 1);
        const height = Math.max(Math.round(frame.height * resolution), 1);
        const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
        const renderer = this._renderer;
        const renderTarget = renderer.renderTarget.getRenderTarget(texture);
        const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);
        const gl = renderer.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);
        gl.readPixels(
          Math.round(frame.x * resolution),
          Math.round(frame.y * resolution),
          width,
          height,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          pixels
        );
        if (false) {
          unpremultiplyAlpha(pixels);
        }
        return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };
      }
      destroy() {
        const writeable = this;
        writeable._renderer = null;
      }
    };
    GlTextureSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "texture"
    };
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs
var WebGLRenderer_exports = {};
__export(WebGLRenderer_exports, {
  WebGLRenderer: () => WebGLRenderer
});
var DefaultWebGLSystems, DefaultWebGLPipes, DefaultWebGLAdapters, systems2, renderPipes2, renderPipeAdaptors2, WebGLRenderer;
var init_WebGLRenderer = __esm({
  "../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs"() {
    init_Extensions();
    init_GlGraphicsAdaptor();
    init_GlMeshAdaptor();
    init_GlBatchAdaptor();
    init_AbstractRenderer();
    init_SharedSystems();
    init_types();
    init_GlBufferSystem();
    init_GlContextSystem();
    init_GlGeometrySystem();
    init_GlBackBufferSystem();
    init_GlColorMaskSystem();
    init_GlEncoderSystem();
    init_GlRenderTargetSystem();
    init_GlStencilSystem();
    init_GlShaderSystem();
    init_GlUniformGroupSystem();
    init_GlStateSystem();
    init_GlTextureSystem();
    DefaultWebGLSystems = [
      ...SharedSystems,
      GlBackBufferSystem,
      GlContextSystem,
      GlBufferSystem,
      GlTextureSystem,
      GlRenderTargetSystem,
      GlGeometrySystem,
      GlUniformGroupSystem,
      GlShaderSystem,
      GlEncoderSystem,
      GlStateSystem,
      GlStencilSystem,
      GlColorMaskSystem
    ];
    DefaultWebGLPipes = [...SharedRenderPipes];
    DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];
    systems2 = [];
    renderPipes2 = [];
    renderPipeAdaptors2 = [];
    extensions.handleByNamedList(ExtensionType.WebGLSystem, systems2);
    extensions.handleByNamedList(ExtensionType.WebGLPipes, renderPipes2);
    extensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors2);
    extensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);
    WebGLRenderer = class extends AbstractRenderer {
      constructor() {
        const systemConfig = {
          name: "webgl2",
          type: RendererType.WEBGL,
          systems: systems2,
          renderPipes: renderPipes2,
          renderPipeAdaptors: renderPipeAdaptors2
        };
        super(systemConfig);
      }
    };
  }
});

// ../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js
var require_events = __commonJS({
  "../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js"(exports, module) {
    "use strict";
    var R2 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R2 && typeof R2.ownKeys === "function") {
      ReflectOwnKeys = R2.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter3() {
      EventEmitter3.init.call(this);
    }
    module.exports = EventEmitter3;
    module.exports.once = once;
    EventEmitter3.EventEmitter = EventEmitter3;
    EventEmitter3.prototype._events = void 0;
    EventEmitter3.prototype._eventsCount = 0;
    EventEmitter3.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter3, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter3.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter3.prototype.setMaxListeners = function setMaxListeners(n2) {
      if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
      }
      this._maxListeners = n2;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter3.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter3.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter3.prototype.emit = function emit(type) {
      var args = [];
      for (var i2 = 1; i2 < arguments.length; i2++)
        args.push(arguments[i2]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i2 = 0; i2 < len; ++i2)
          ReflectApply(listeners[i2], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m3;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m3 = _getMaxListeners(target);
        if (m3 > 0 && existing.length > m3 && !existing.warned) {
          existing.warned = true;
          var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w2.name = "MaxListenersExceededWarning";
          w2.emitter = target;
          w2.type = type;
          w2.count = existing.length;
          ProcessEmitWarning(w2);
        }
      }
      return target;
    }
    EventEmitter3.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter3.prototype.on = EventEmitter3.prototype.addListener;
    EventEmitter3.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter3.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter3.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter3.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i2, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i2 = list.length - 1; i2 >= 0; i2--) {
          if (list[i2] === listener || list[i2].listener === listener) {
            originalListener = list[i2].listener;
            position = i2;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i2;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i2 = 0; i2 < keys.length; ++i2) {
          key = keys[i2];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i2 = listeners.length - 1; i2 >= 0; i2--) {
          this.removeListener(type, listeners[i2]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter3.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter3.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter3.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter3.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n2) {
      var copy = new Array(n2);
      for (var i2 = 0; i2 < n2; ++i2)
        copy[i2] = arr[i2];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i2 = 0; i2 < ret.length; ++i2) {
        ret[i2] = arr[i2].listener || arr[i2];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/index.mjs
init_init();
init_all();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/app/Application.mjs
init_Extensions();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs
init_adapter();
var supported;
function isWebGLSupported(failIfMajorPerformanceCaveat) {
  if (typeof supported === "undefined") {
    supported = function supported2() {
      const contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat
      };
      try {
        if (!DOMAdapter.get().getWebGLRenderingContext()) {
          return false;
        }
        const canvas2 = DOMAdapter.get().createCanvas();
        let gl = canvas2.getContext("webgl2", contextOptions);
        const success = !!gl?.getContextAttributes()?.stencil;
        if (gl) {
          const loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success;
      } catch (e2) {
        return false;
      }
    }();
  }
  return supported;
}

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs
init_adapter();
async function isWebGPUSupported(options = {}) {
  const gpu = DOMAdapter.get().getNavigator().gpu;
  if (!gpu)
    return false;
  try {
    const adapter = await navigator.gpu.requestAdapter(options);
    await adapter.requestDevice();
    return true;
  } catch (e2) {
    return false;
  }
}

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs
init_AbstractRenderer();
var renderPriority = ["webgpu", "webgl", "canvas"];
async function autoDetectRenderer(options) {
  let preferredOrder = [];
  if (options.preference) {
    preferredOrder.push(options.preference);
    renderPriority.forEach((item) => {
      if (item !== options.preference) {
        preferredOrder.push(item);
      }
    });
  } else {
    preferredOrder = renderPriority.slice();
  }
  let RendererClass;
  if (options.manageImports ?? true) {
    await Promise.resolve().then(() => (init_all(), all_exports));
  }
  let finalOptions = {};
  for (let i2 = 0; i2 < preferredOrder.length; i2++) {
    const rendererType = preferredOrder[i2];
    if (rendererType === "webgpu" && await isWebGPUSupported()) {
      const { WebGPURenderer: WebGPURenderer2 } = await Promise.resolve().then(() => (init_WebGPURenderer(), WebGPURenderer_exports));
      RendererClass = WebGPURenderer2;
      finalOptions = { ...options, ...options.webgpu };
      break;
    } else if (rendererType === "webgl" && isWebGLSupported(
      options.failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
    )) {
      const { WebGLRenderer: WebGLRenderer2 } = await Promise.resolve().then(() => (init_WebGLRenderer(), WebGLRenderer_exports));
      RendererClass = WebGLRenderer2;
      finalOptions = { ...options, ...options.webgl };
      break;
    } else if (rendererType === "canvas") {
      finalOptions = { ...options };
      break;
    }
  }
  delete finalOptions.webgpu;
  delete finalOptions.webgl;
  const renderer = new RendererClass();
  await renderer.init(finalOptions);
  return renderer;
}

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/app/Application.mjs
init_Container();
var _Application = class {
  constructor() {
    this.stage = new Container();
  }
  /**
   * @param options - The optional application and renderer parameters.
   */
  async init(options) {
    options = {
      ...{
        // forceCanvas: false,
      },
      ...options
    };
    this.renderer = await autoDetectRenderer(options);
    _Application._plugins.forEach((plugin) => {
      plugin.init.call(this, options);
    });
  }
  /** Render the current stage. */
  render() {
    this.renderer.render({ container: this.stage });
  }
  /**
   * Reference to the renderer's canvas element.
   * @readonly
   */
  get canvas() {
    return this.renderer.canvas;
  }
  /**
   * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
   * @member {Rectangle}
   * @readonly
   */
  get screen() {
    return this.renderer.screen;
  }
  /**
   * Destroys the application and all of its resources.
   * @param {object|boolean} [options=false] - The options for destroying the application.
   * @param {boolean} [options.removeView=false] - Whether to remove the application's canvas element from the DOM.
   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method
   * called as well. `options` will be passed on to those calls.
   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.
   * If options.children is set to true,
   * it should destroy the texture of the child sprite.
   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
   *  If options.children is set to true,
   * it should destroy the texture source of the child sprite.
   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
   * If options.children is set to true,
   * it should destroy the context of the child graphics.
   */
  destroy(options = false) {
    const plugins = _Application._plugins.slice(0);
    plugins.reverse();
    plugins.forEach((plugin) => {
      plugin.destroy.call(this);
    });
    this.stage.destroy(options);
    this.stage = null;
    this.renderer.destroy(options);
    this.renderer = null;
  }
};
var Application = _Application;
Application._plugins = [];
extensions.handleByList(ExtensionType.Application, Application._plugins);

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/index.mjs
init_init2();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/Assets.mjs
init_Extensions();
init_warn();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/BackgroundLoader.mjs
var BackgroundLoader = class {
  /**
   * @param loader
   * @param verbose - should the loader log to the console
   */
  constructor(loader, verbose = false) {
    this._loader = loader;
    this._assetList = [];
    this._isLoading = false;
    this._maxConcurrent = 1;
    this.verbose = verbose;
  }
  /**
   * Adds an array of assets to load.
   * @param assetUrls - assets to load
   */
  add(assetUrls) {
    assetUrls.forEach((a2) => {
      this._assetList.push(a2);
    });
    if (this.verbose) {
      console.log("[BackgroundLoader] assets: ", this._assetList);
    }
    if (this._isActive && !this._isLoading) {
      void this._next();
    }
  }
  /**
   * Loads the next set of assets. Will try to load as many assets as it can at the same time.
   *
   * The max assets it will try to load at one time will be 4.
   */
  async _next() {
    if (this._assetList.length && this._isActive) {
      this._isLoading = true;
      const toLoad = [];
      const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
      for (let i2 = 0; i2 < toLoadAmount; i2++) {
        toLoad.push(this._assetList.pop());
      }
      await this._loader.load(toLoad);
      this._isLoading = false;
      void this._next();
    }
  }
  /**
   * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.
   * @returns whether the class is active
   */
  get active() {
    return this._isActive;
  }
  set active(value) {
    if (this._isActive === value)
      return;
    this._isActive = value;
    if (value && !this._isLoading) {
      void this._next();
    }
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/Assets.mjs
init_Cache();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/loader/Loader.mjs
init_warn();
init_path();
init_convertToList();
init_isSingleItem();
var Loader = class {
  constructor() {
    this._parsers = [];
    this._parsersValidated = false;
    this.parsers = new Proxy(this._parsers, {
      set: (target, key, value) => {
        this._parsersValidated = false;
        target[key] = value;
        return true;
      }
    });
    this.promiseCache = {};
  }
  /** function used for testing */
  reset() {
    this._parsersValidated = false;
    this.promiseCache = {};
  }
  /**
   * Used internally to generate a promise for the asset to be loaded.
   * @param url - The URL to be loaded
   * @param data - any custom additional information relevant to the asset being loaded
   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object
   */
  _getLoadPromiseAndParser(url, data) {
    const result = {
      promise: null,
      parser: null
    };
    result.promise = (async () => {
      let asset = null;
      let parser = null;
      if (data.loadParser) {
        parser = this._parserHash[data.loadParser];
        if (!parser) {
          warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url}`);
        }
      }
      if (!parser) {
        for (let i2 = 0; i2 < this.parsers.length; i2++) {
          const parserX = this.parsers[i2];
          if (parserX.load && parserX.test?.(url, data, this)) {
            parser = parserX;
            break;
          }
        }
        if (!parser) {
          warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);
          return null;
        }
      }
      asset = await parser.load(url, data, this);
      result.parser = parser;
      for (let i2 = 0; i2 < this.parsers.length; i2++) {
        const parser2 = this.parsers[i2];
        if (parser2.parse) {
          if (parser2.parse && await parser2.testParse?.(asset, data, this)) {
            asset = await parser2.parse(asset, data, this) || asset;
            result.parser = parser2;
          }
        }
      }
      return asset;
    })();
    return result;
  }
  async load(assetsToLoadIn, onProgress) {
    if (!this._parsersValidated) {
      this._validateParsers();
    }
    let count2 = 0;
    const assets = {};
    const singleAsset = isSingleItem(assetsToLoadIn);
    const assetsToLoad = convertToList(assetsToLoadIn, (item) => ({
      alias: [item],
      src: item
    }));
    const total = assetsToLoad.length;
    const promises = assetsToLoad.map(async (asset) => {
      const url = path.toAbsolute(asset.src);
      if (!assets[asset.src]) {
        try {
          if (!this.promiseCache[url]) {
            this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);
          }
          assets[asset.src] = await this.promiseCache[url].promise;
          if (onProgress)
            onProgress(++count2 / total);
        } catch (e2) {
          delete this.promiseCache[url];
          delete assets[asset.src];
          throw new Error(`[Loader.load] Failed to load ${url}.
${e2}`);
        }
      }
    });
    await Promise.all(promises);
    return singleAsset ? assets[assetsToLoad[0].src] : assets;
  }
  /**
   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.
   * The parser that created the asset, will be the one that unloads it.
   * @example
   * // Single asset:
   * const asset = await Loader.load('cool.png');
   *
   * await Loader.unload('cool.png');
   *
   * console.log(asset.destroyed); // true
   * @param assetsToUnloadIn - urls that you want to unload, or a single one!
   */
  async unload(assetsToUnloadIn) {
    const assetsToUnload = convertToList(assetsToUnloadIn, (item) => ({
      alias: [item],
      src: item
    }));
    const promises = assetsToUnload.map(async (asset) => {
      const url = path.toAbsolute(asset.src);
      const loadPromise = this.promiseCache[url];
      if (loadPromise) {
        const loadedAsset = await loadPromise.promise;
        delete this.promiseCache[url];
        loadPromise.parser?.unload?.(loadedAsset, asset, this);
      }
    });
    await Promise.all(promises);
  }
  /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */
  _validateParsers() {
    this._parsersValidated = true;
    this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {
      if (!parser.name) {
        warn(`[Assets] loadParser should have a name`);
      } else if (hash[parser.name]) {
        warn(`[Assets] loadParser name conflict "${parser.name}"`);
      }
      return { ...hash, [parser.name]: parser };
    }, {});
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/assets/Assets.mjs
init_Resolver();
init_convertToList();
init_isSingleItem();
var AssetsClass = class {
  constructor() {
    this._detections = [];
    this._initialized = false;
    this.resolver = new Resolver();
    this.loader = new Loader();
    this.cache = Cache;
    this._backgroundLoader = new BackgroundLoader(this.loader);
    this._backgroundLoader.active = true;
    this.reset();
  }
  /**
   * Best practice is to call this function before any loading commences
   * Initiating is the best time to add any customization to the way things are loaded.
   *
   * you do not need to call this for the Asset class to work, only if you want to set any initial properties
   * @param options - options to initialize the Asset manager with
   */
  async init(options = {}) {
    if (this._initialized) {
      warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
      return;
    }
    this._initialized = true;
    if (options.defaultSearchParams) {
      this.resolver.setDefaultSearchParams(options.defaultSearchParams);
    }
    if (options.basePath) {
      this.resolver.basePath = options.basePath;
    }
    if (options.bundleIdentifier) {
      this.resolver.setBundleIdentifier(options.bundleIdentifier);
    }
    if (options.manifest) {
      let manifest = options.manifest;
      if (typeof manifest === "string") {
        manifest = await this.load(manifest);
      }
      this.resolver.addManifest(manifest);
    }
    const resolutionPref = options.texturePreference?.resolution ?? 1;
    const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;
    const formats = await this._detectFormats({
      preferredFormats: options.texturePreference?.format,
      skipDetections: options.skipDetections,
      detections: this._detections
    });
    this.resolver.prefer({
      params: {
        format: formats,
        resolution
      }
    });
    if (options.preferences) {
      this.setPreferences(options.preferences);
    }
  }
  /**
   * Allows you to specify how to resolve any assets load requests.
   * There are a few ways to add things here as shown below:
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Simple
   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});
   * const bunny = await Assets.load('bunnyBooBoo');
   *
   * // Multiple keys:
   * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});
   *
   * const bunny = await Assets.load('burger');
   * const bunny2 = await Assets.load('chicken');
   *
   * // passing options to to the object
   * Assets.add({
   *     alias: 'bunnyBooBooSmooth',
   *     src: 'bunny{png,webp}',
   *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options
   * });
   *
   * // Multiple assets
   *
   * // The following all do the same thing:
   *
   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny{png,webp}'});
   *
   * Assets.add({
   *     alias: 'bunnyBooBoo',
   *     src: [
   *         'bunny.png',
   *         'bunny.webp',
   *    ],
   * });
   *
   * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available
   * @param assets - the unresolved assets to add to the resolver
   */
  add(assets) {
    this.resolver.add(assets);
  }
  async load(urls, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    const singleAsset = isSingleItem(urls);
    const urlArray = convertToList(urls).map((url) => {
      if (typeof url !== "string") {
        const aliases = this.resolver.getAlias(url);
        if (aliases.some((alias) => !this.resolver.hasKey(alias))) {
          this.add(url);
        }
        return Array.isArray(aliases) ? aliases[0] : aliases;
      }
      if (!this.resolver.hasKey(url))
        this.add({ alias: url, src: url });
      return url;
    });
    const resolveResults = this.resolver.resolve(urlArray);
    const out2 = await this._mapLoadToResolve(resolveResults, onProgress);
    return singleAsset ? out2[urlArray[0]] : out2;
  }
  /**
   * This adds a bundle of assets in one go so that you can load them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const assets = await Assets.loadBundle('animals');
   * @param bundleId - the id of the bundle to add
   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key
   */
  addBundle(bundleId, assets) {
    this.resolver.addBundle(bundleId, assets);
  }
  /**
   * Bundles are a way to load multiple assets at once.
   * If a manifest has been provided to the init function then you can load a bundle, or bundles.
   * you can also add bundles via `addBundle`
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * await Asset.init({ manifest });
   *
   * // Load a bundle...
   * loadScreenAssets = await Assets.loadBundle('load-screen');
   * // Load another bundle...
   * gameScreenAssets = await Assets.loadBundle('game-screen');
   * @param bundleIds - the bundle id or ids to load
   * @param onProgress - Optional function that is called when progress on asset loading is made.
   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)
   * of the assets loaded. Do not use this function to detect when assets are complete and available,
   * instead use the Promise returned by this function.
   * @returns all the bundles assets or a hash of assets for each bundle specified
   */
  async loadBundle(bundleIds, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    let singleAsset = false;
    if (typeof bundleIds === "string") {
      singleAsset = true;
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const out2 = {};
    const keys = Object.keys(resolveResults);
    let count2 = 0;
    let total = 0;
    const _onProgress = () => {
      onProgress?.(++count2 / total);
    };
    const promises = keys.map((bundleId) => {
      const resolveResult = resolveResults[bundleId];
      total += Object.keys(resolveResult).length;
      return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
        out2[bundleId] = resolveResult2;
      });
    });
    await Promise.all(promises);
    return singleAsset ? out2[bundleIds[0]] : out2;
  }
  /**
   * Initiate a background load of some assets. It will passively begin to load these assets in the background.
   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately
   *
   * An example of this might be that you would background load game assets after your inital load.
   * then when you got to actually load your game screen assets when a player goes to the game - the loading
   * would already have stared or may even be complete, saving you having to show an interim load bar.
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.backgroundLoad('bunny.png');
   *
   * // later on in your app...
   * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!
   * @param urls - the url / urls you want to background load
   */
  async backgroundLoad(urls) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof urls === "string") {
      urls = [urls];
    }
    const resolveResults = this.resolver.resolve(urls);
    this._backgroundLoader.add(Object.values(resolveResults));
  }
  /**
   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.
   * this can only be used if the loader has been initiated with a manifest
   * @example
   * import { Assets } from 'pixi.js';
   *
   * await Assets.init({
   *     manifest: {
   *         bundles: [
   *             {
   *                 name: 'load-screen',
   *                 assets: [...],
   *             },
   *             ...
   *         ],
   *     },
   * });
   *
   * Assets.backgroundLoadBundle('load-screen');
   *
   * // Later on in your app...
   * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!
   * @param bundleIds - the bundleId / bundleIds you want to background load
   */
  async backgroundLoadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof bundleIds === "string") {
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    Object.values(resolveResults).forEach((resolveResult) => {
      this._backgroundLoader.add(Object.values(resolveResult));
    });
  }
  /**
   * Only intended for development purposes.
   * This will wipe the resolver and caches.
   * You will need to reinitialize the Asset
   */
  reset() {
    this.resolver.reset();
    this.loader.reset();
    this.cache.reset();
    this._initialized = false;
  }
  get(keys) {
    if (typeof keys === "string") {
      return Cache.get(keys);
    }
    const assets = {};
    for (let i2 = 0; i2 < keys.length; i2++) {
      assets[i2] = Cache.get(keys[i2]);
    }
    return assets;
  }
  /**
   * helper function to map resolved assets back to loaded assets
   * @param resolveResults - the resolve results from the resolver
   * @param onProgress - the progress callback
   */
  async _mapLoadToResolve(resolveResults, onProgress) {
    const resolveArray = Object.values(resolveResults);
    const resolveKeys = Object.keys(resolveResults);
    this._backgroundLoader.active = false;
    const loadedAssets3 = await this.loader.load(resolveArray, onProgress);
    this._backgroundLoader.active = true;
    const out2 = {};
    resolveArray.forEach((resolveResult, i2) => {
      const asset = loadedAssets3[resolveResult.src];
      const keys = [resolveResult.src];
      if (resolveResult.alias) {
        keys.push(...resolveResult.alias);
      }
      out2[resolveKeys[i2]] = asset;
      Cache.set(keys, asset);
    });
    return out2;
  }
  /**
   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function
   * this will make sure to destroy any assets and release them from memory.
   * Once unloaded, you will need to load the asset again.
   *
   * Use this to help manage assets if you find that you have a large app and you want to free up memory.
   *
   * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,
   * Pixi won't break but you will end up with missing assets. Not a good look for the user!
   * @example
   * import { Assets } from 'pixi.js';
   *
   * // Load a URL:
   * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture
   *
   * await Assets.unload('http://some.url.com/image.png')
   *
   * // myImageTexture will be destroyed now.
   *
   * // Unload multiple assets:
   * const textures = await Assets.unload(['thumper', 'chicko']);
   * @param urls - the urls to unload
   */
  async unload(urls) {
    if (!this._initialized) {
      await this.init();
    }
    const urlArray = convertToList(urls).map((url) => typeof url !== "string" ? url.src : url);
    const resolveResults = this.resolver.resolve(urlArray);
    await this._unloadFromResolved(resolveResults);
  }
  /**
   * Bundles are a way to manage multiple assets at once.
   * this will unload all files in a bundle.
   *
   * once a bundle has been unloaded, you need to load it again to have access to the assets.
   * @example
   * import { Assets } from 'pixi.js';
   *
   * Assets.addBundle({
   *     'thumper': 'http://some.url.com/thumper.png',
   * })
   *
   * const assets = await Assets.loadBundle('thumper');
   *
   * // Now to unload...
   *
   * await Assets.unloadBundle('thumper');
   *
   * // All assets in the assets object will now have been destroyed and purged from the cache
   * @param bundleIds - the bundle id or ids to unload
   */
  async unloadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    bundleIds = convertToList(bundleIds);
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
    await Promise.all(promises);
  }
  async _unloadFromResolved(resolveResult) {
    const resolveArray = Object.values(resolveResult);
    resolveArray.forEach((resolveResult2) => {
      Cache.remove(resolveResult2.src);
    });
    await this.loader.unload(resolveArray);
  }
  /**
   * Detects the supported formats for the browser, and returns an array of supported formats, respecting
   * the users preferred formats order.
   * @param options - the options to use when detecting formats
   * @param options.preferredFormats - the preferred formats to use
   * @param options.skipDetections - if we should skip the detections altogether
   * @param options.detections - the detections to use
   * @returns - the detected formats
   */
  async _detectFormats(options) {
    let formats = [];
    if (options.preferredFormats) {
      formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats];
    }
    for (const detection of options.detections) {
      if (options.skipDetections || await detection.test()) {
        formats = await detection.add(formats);
      } else if (!options.skipDetections) {
        formats = await detection.remove(formats);
      }
    }
    formats = formats.filter((format2, index) => formats.indexOf(format2) === index);
    return formats;
  }
  /** All the detection parsers currently added to the Assets class. */
  get detections() {
    return this._detections;
  }
  /**
   * General setter for preferences. This is a helper function to set preferences on all parsers.
   * @param preferences - the preferences to set
   */
  setPreferences(preferences) {
    this.loader.parsers.forEach((parser) => {
      if (!parser.config)
        return;
      Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {
        parser.config[key] = preferences[key];
      });
    });
  }
};
var Assets = new AssetsClass();
extensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/index.mjs
init_init3();
init_init4();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs
init_GlProgram();
init_GpuProgram();
init_UniformGroup();
init_Texture();
init_Filter();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/blend-template2.mjs
var blendTemplateFrag = "\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 fragColor;\n\nuniform float uBlend;\n\nuniform sampler2D uSampler;\nuniform sampler2D backTexture;\n\n{FUNCTIONS}\n\nvoid main()\n{ \n    vec4 back = texture(backTexture, vTextureCoord);\n    vec4 front = texture(uSampler, vTextureCoord);\n\n    {MAIN}\n}\n";

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/blend-template3.mjs
var blendTemplateVert = "in vec2 aPosition;\nout vec2 vTextureCoord;\nout vec2 backgroundUv;\n\nuniform globalUniforms {\n  mat3 projectionMatrix;\n  mat3 worldTransformMatrix;\n  float worldAlpha;\n};\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nuniform vec4 backgroundFrame;\nuniform vec4 outputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * outputFrame.zw + outputFrame.xy;\n    \n    position.x = position.x * (2.0 / outputTexture.x) - 1.0;\n    position.y = position.y * (2.0*outputTexture.z / outputTexture.y) - outputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/blend-template.mjs
var blendTemplate = "struct GlobalUniforms {\n  projectionMatrix:mat3x3<f32>,\n  worldTransformMatrix:mat3x3<f32>,\n  worldAlpha: f32\n}\n\nstruct GlobalFilterUniforms {\n  inputSize:vec4<f32>,\n  inputPixel:vec4<f32>,\n  inputClamp:vec4<f32>,\n  outputFrame:vec4<f32>,\n  globalFrame:vec4<f32>,\n  outputTexture:vec4<f32>,\n};\n\nstruct BlendUniforms {\n  uBlend:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uSampler: texture_2d<f32>;\n@group(0) @binding(2) var mySampler : sampler;\n@group(0) @binding(3) var backTexture: texture_2d<f32>;\n\n@group(1) @binding(0) var<uniform> blendUniforms : BlendUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.outputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.outputTexture.z / gfu.outputTexture.y) - gfu.outputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  \n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n{FUNCTIONS}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>\n) -> @location(0) vec4<f32> {\n\n\n   var back =  textureSample(backTexture, mySampler, uv);\n   var front = textureSample(uSampler, mySampler, uv);\n   \n   var out = vec4<f32>(0.0,0.0,0.0,0.0);\n\n   {MAIN}\n\n   return out;\n}";

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs
var BlendModeFilter = class extends Filter {
  constructor(options) {
    const gpuOptions = options.gpu;
    const gpuSource = compileBlendModeShader({ source: blendTemplate, ...gpuOptions });
    const gpuProgram = new GpuProgram({
      vertex: {
        source: gpuSource,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: gpuSource,
        entryPoint: "mainFragment"
      }
    });
    const glOptions = options.gl;
    const glSource = compileBlendModeShader({ source: blendTemplateFrag, ...glOptions });
    const glProgram = new GlProgram({
      vertex: blendTemplateVert,
      fragment: glSource
    });
    const uniformGroup = new UniformGroup({
      uBlend: {
        value: 1,
        type: "f32"
      }
    });
    super({
      gpuProgram,
      glProgram,
      blendRequired: true,
      resources: {
        blendUniforms: uniformGroup,
        backTexture: Texture.EMPTY
      }
    });
  }
};
function compileBlendModeShader(options) {
  const { source: source3, functions, main } = options;
  return source3.replace("{FUNCTIONS}", functions).replace("{MAIN}", main);
}

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.mjs
var hslgl = `
	float getLuminosity(vec3 c) {
		return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;
	}

	vec3 setLuminosity(vec3 c, float lum) {
		float modLum = lum - getLuminosity(c);
		vec3 color = c.rgb + vec3(modLum);

		// clip back into legal range
		modLum = getLuminosity(color);
		vec3 modLumVec = vec3(modLum);

		float cMin = min(color.r, min(color.g, color.b));
		float cMax = max(color.r, max(color.g, color.b));

		if(cMin < 0.0) {
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0) {
			color = mix(modLumVec, color, (1.0 - modLum) / (cMax - modLum));
		}

		return color;
	}

	float getSaturation(vec3 c) {
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	vec3 setSaturationMinMidMax(vec3 cSorted, float s) {
		vec3 colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x) {
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else {
			colorSorted.y = 0.0;
			colorSorted.z = 0.0;
		}

		colorSorted.x = 0.0;

		return colorSorted;
	}

	vec3 setSaturation(vec3 c, float s) {
		vec3 color = c;

		if(color.r <= color.g && color.r <= color.b) {
			if(color.g <= color.b) {
				color = setSaturationMinMidMax(color.rgb, s).rgb;
			}
			else {
				color = setSaturationMinMidMax(color.rbg, s).rbg;
			}
		}
		else if(color.g <= color.r && color.g <= color.b) {
			if(color.r <= color.b) {
				color = setSaturationMinMidMax(color.grb, s).grb;
			}
			else {
				color = setSaturationMinMidMax(color.gbr, s).gbr;
			}
		}
		else {
			// Using bgr for both fixes part of hue
			if(color.r <= color.g) {
				color = setSaturationMinMidMax(color.brg, s).brg;
			}
			else {
				color = setSaturationMinMidMax(color.bgr, s).bgr;
			}
		}

		return color;
	}
    `;

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.mjs
var hslgpu = `
	fn getLuminosity(c: vec3<f32>) -> f32
	{
		return 0.3*c.r + 0.59*c.g + 0.11*c.b;
	}

	fn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32>
	{
		var modLum: f32 = lum - getLuminosity(c);
		var color: vec3<f32> = c.rgb + modLum;

		// clip back into legal range
		modLum = getLuminosity(color);
		let modLumVec = vec3<f32>(modLum);

		let cMin: f32 = min(color.r, min(color.g, color.b));
		let cMax: f32 = max(color.r, max(color.g, color.b));

		if(cMin < 0.0)
		{
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0)
		{
			color = mix(modLumVec, color, (1 - modLum) / (cMax - modLum));
		}

		return color;
	}

	fn getSaturation(c: vec3<f32>) -> f32
	{
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	fn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32>
	{
		var colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x)
		{
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else
		{
			colorSorted.y = 0;
			colorSorted.z = 0;
		}

		colorSorted.x = 0;

		return colorSorted;
	}

	fn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32>
	{
		var color = c;

		if (color.r <= color.g && color.r <= color.b)
		{
			if (color.g <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rgb, s)).rgb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rbg, s)).rbg;
			}
		}
		else if (color.g <= color.r && color.g <= color.b)
		{
			if (color.r <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.grb, s)).grb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.gbr, s)).gbr;
			}
		}
		else
		{
			// Using bgr for both fixes part of hue
			if (color.r <= color.g)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.brg, s)).brg;
			}
			else
			{
				color  = vec3<f32>(setSaturationMinMidMax(color.bgr, s)).bgr;
			}
		}

		return color;
	}
	`;

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/init.mjs
init_Extensions();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/ColorBlend.mjs
init_Extensions();
var ColorBlend = class extends BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                ${hslgl}

                vec3 blendColor(vec3 base, vec3 blend,  float opacity)
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendColor(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                ${hslgpu}

                fn blendColorOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendColorOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
      }
    });
  }
};
ColorBlend.extension = {
  name: "color",
  type: ExtensionType.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/ColorBurnBlend.mjs
init_Extensions();
var ColorBurnBlend = class extends BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0 - ((1.0 - base) / blend)), 0.0);
                }

                vec3 blendColorBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                fragColor = vec4(blendColorBurn(back.rgb, front.rgb, front.a), uBlend);
            `
      },
      gpu: {
        functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn blendColorBurn(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendColorBurn(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
      }
    });
  }
};
ColorBurnBlend.extension = {
  name: "color-burn",
  type: ExtensionType.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/ColorDodgeBlend.mjs
init_Extensions();
var ColorDodgeBlend = class extends BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float colorDodge(float base, float blend)
                {
                    return base / (1.0 - blend);
                }

                vec3 blendColorDodge(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendColorDodge(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return base / (1.0 - blend);
                }

                fn blendColorDodge(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                    out = vec4<f32>(blendColorDodge(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
      }
    });
  }
};
ColorDodgeBlend.extension = {
  name: "color-dodge",
  type: ExtensionType.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/DarkenBlend.mjs
init_Extensions();
var DarkenBlend = class extends BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                vec3 blendDarken(vec3 base, vec3 blend, float opacity)
                {
                    return (min(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendDarken(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn blendDarken(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (min(blend,base) * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendDarken(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
      }
    });
  }
};
DarkenBlend.extension = {
  name: "darken",
  type: ExtensionType.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/DifferenceBlend.mjs
init_Extensions();
var DifferenceBlend = class extends BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                vec3 blendDifference(vec3 base, vec3 blend,  float opacity)
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                fragColor = vec4(blendDifference(back.rgb, front.rgb, front.a), uBlend);
            `
      },
      gpu: {
        functions: `
                fn blendDifference(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendDifference(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
      }
    });
  }
};
DifferenceBlend.extension = {
  name: "difference",
  type: ExtensionType.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/DivideBlend.mjs
init_Extensions();
var DivideBlend = class extends BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float divide(float base, float blend)
                {
                    return (blend > 0.0) ? clamp(base / blend, 0.0, 1.0) : 1.0;
                }

                vec3 blendDivide(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendDivide(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn divide(base: f32, blend: f32) -> f32
                {
                    return select(1.0, clamp(base / blend, 0.0, 1.0), blend > 0.0);
                }

                fn blendDivide(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendDivide(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
      }
    });
  }
};
DivideBlend.extension = {
  name: "divide",
  type: ExtensionType.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/ExclusionBlend.mjs
init_Extensions();
var ExclusionBlend = class extends BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                vec3 exclusion(vec3 base, vec3 blend)
                {
                    return base + blend - 2.0 * base * blend;
                }

                vec3 blendExclusion(vec3 base, vec3 blend, float opacity)
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendExclusion(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn exclusion(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return base+blend-2.0*base*blend;
                }

                fn blendExclusion(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendExclusion(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
      }
    });
  }
};
ExclusionBlend.extension = {
  name: "exclusion",
  type: ExtensionType.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/HardLightBlend.mjs
init_Extensions();
var HardLightBlend = class extends BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float hardLight(float base, float blend)
                {
                    return (blend < 0.5) ? 2.0 * base * blend : 1.0 - 2.0 * (1.0 - base) * (1.0 - blend);
                }

                vec3 blendHardLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                fragColor = vec4(blendHardLight(back.rgb, front.rgb, front.a), uBlend);
            `
      },
      gpu: {
        functions: `
                fn hardLight(base: f32, blend: f32) -> f32
                {
                    return select(1.0 - 2.0 * (1.0 - base) * (1.0 - blend), 2.0 * base * blend, blend < 0.5);
                }

                fn blendHardLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendHardLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
      }
    });
  }
};
HardLightBlend.extension = {
  name: "hard-light",
  type: ExtensionType.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/HardMixBlend.mjs
init_Extensions();
var HardMixBlend = class extends BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float hardMix(float base, float blend)
                {
                    return (base + blend >= 1.0) ? 1.0 : 0.0;
                }

                vec3 blendHardMix(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blended = vec3(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                fragColor = vec4(blendHardMix(back.rgb, front.rgb, front.a), uBlend);
            `
      },
      gpu: {
        functions: `
                fn hardMix(base: f32, blend: f32) -> f32
                {
                    return select(0.0, 1.0, base + blend >= 1.0);
                }

                fn blendHardMix(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendHardMix(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
      }
    });
  }
};
HardMixBlend.extension = {
  name: "hard-mix",
  type: ExtensionType.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/LightenBlend.mjs
init_Extensions();
var LightenBlend = class extends BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                vec3 blendLighten(vec3 base, vec3 blend, float opacity)
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendLighten(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn blendLighten(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendLighten(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
      }
    });
  }
};
LightenBlend.extension = {
  name: "lighten",
  type: ExtensionType.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/LinearBurnBlend.mjs
init_Extensions();
var LinearBurnBlend = class extends BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float linearBurn(float base, float blend)
                {
                    return max(0.0, base + blend - 1.0);
                }

                vec3 blendLinearBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendLinearBurn(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn blendLinearBurn(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendLinearBurn(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
      }
    });
  }
};
LinearBurnBlend.extension = {
  name: "linear-burn",
  type: ExtensionType.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/LinearDodgeBlend.mjs
init_Extensions();
var LinearDodgeBlend = class extends BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                vec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendLinearDodge(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1, base + blend);
                }

                fn blendLinearDodge(base:vec3<f32>, blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendLinearDodge(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
      }
    });
  }
};
LinearDodgeBlend.extension = {
  name: "linear-dodge",
  type: ExtensionType.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/LinearLightBlend.mjs
init_Extensions();
var LinearLightBlend = class extends BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float linearBurn(float base, float blend) {
                    return max(0.0, base + blend - 1.0);
                }

                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                float linearLight(float base, float blend) {
                    return (blend <= 0.5) ? linearBurn(base,2.0*blend) : linearBurn(base,2.0*(blend-0.5));
                }

                vec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                fragColor = vec4(blendLinearLight(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base + blend);
                }

                fn linearLight(base: f32, blend: f32) -> f32
                {
                    return select(linearBurn(base,2.0*(blend-0.5)), linearBurn(base,2.0*blend), blend <= 0.5);
                }

                fn blendLinearLightOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendLinearLightOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
      }
    });
  }
};
LinearLightBlend.extension = {
  name: "linear-light",
  type: ExtensionType.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/LuminosityBlend.mjs
init_Extensions();
var LuminosityBlend = class extends BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                ${hslgl}

                vec3 blendLuminosity(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendLuminosity = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendLuminosity(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                ${hslgpu}

                fn blendLuminosity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendLuminosity: vec3<f32> = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendLuminosity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
      }
    });
  }
};
LuminosityBlend.extension = {
  name: "luminosity",
  type: ExtensionType.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/NegationBlend.mjs
init_Extensions();
var NegationBlend = class extends BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                vec3 negation(vec3 base, vec3 blend)
                {
                    return 1.0-abs(1.0-base-blend);
                }

                vec3 blendNegation(vec3 base, vec3 blend, float opacity)
                {
                    return (negation(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendNegation(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn blendNegation(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return 1.0-abs(1.0-base-blend);
                }

                fn blendNegationOpacity(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (blendNegation(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendNegationOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
      }
    });
  }
};
NegationBlend.extension = {
  name: "negation",
  type: ExtensionType.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/OverlayBlend.mjs
init_Extensions();
var OverlayBlend = class extends BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float overlay(float base, float blend)
                {
                    return (blend < 0.5) ? (2.0*base*blend) : (1.0-2.0*(1.0-base)*(1.0-blend));
                }

                vec3 blendOverlay(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendOverlay(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn overlay(base: f32, blend: f32) -> f32
                {
                    return select((1.0-2.0*(1.0-base)*(1.0-blend)), (2.0*base*blend), base < 0.5);
                }

                fn blendOverlay(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendOverlay(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
      }
    });
  }
};
OverlayBlend.extension = {
  name: "overlay",
  type: ExtensionType.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/PinLightBlend.mjs
init_Extensions();
var PinLightBlend = class extends BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float pinLight(float base, float blend)
                {
                    return (blend <= 0.5) ? min(base, 2.0 * blend) : max(base, 2.0 * (blend - 0.5));
                }

                vec3 blendPinLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                fragColor = vec4(blendPinLight(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn pinLight(base: f32, blend: f32) -> f32
                {
                    return select(max(base,2.0*(blend-0.5)), min(base,2.0*blend), blend <= 0.5);
                }

                fn blendPinLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendPinLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
      }
    });
  }
};
PinLightBlend.extension = {
  name: "pin-light",
  type: ExtensionType.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/SaturationBlend.mjs
init_Extensions();
var SaturationBlend = class extends BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                ${hslgl}

                vec3 blendSaturation(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                fragColor = vec4(blendSaturation(back.rgb, front.rgb, front.a), uBlend);
            `
      },
      gpu: {
        functions: `
                ${hslgpu}

                fn blendSaturation(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                out = vec4<f32>(blendSaturation(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `
      }
    });
  }
};
SaturationBlend.extension = {
  name: "saturation",
  type: ExtensionType.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/SoftLightBlend.mjs
init_Extensions();
var SoftLightBlend = class extends BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float softLight(float base, float blend)
                {
                    return (blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));
                }

                vec3 blendSoftLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendSoftLight(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn softLight(base: f32, blend: f32) -> f32
                {
                    return select(2.0 * base * blend + base * base * (1.0 - 2.0 * blend), sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend), blend < 0.5);
                }

                fn blendSoftLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendSoftLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
      }
    });
  }
};
SoftLightBlend.extension = {
  name: "soft-light",
  type: ExtensionType.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/SubtractBlend.mjs
init_Extensions();
var SubtractBlend = class extends BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float subtract(float base, float blend)
                {
                    return max(0.0, base - blend);
                }

                vec3 blendSubtract(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                fragColor = vec4(blendSubtract(back.rgb, front.rgb, front.a), uBlend);
                `
      },
      gpu: {
        functions: `
                fn subtract(base: f32, blend: f32) -> f32
                {
                    return max(0, base - blend);
                }

                fn blendSubtract(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendSubtract(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
      }
    });
  }
};
SubtractBlend.extension = {
  name: "subtract",
  type: ExtensionType.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/VividLightBlend.mjs
init_Extensions();
var VividLightBlend = class extends BlendModeFilter {
  constructor() {
    super({
      gl: {
        functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                float colorDodge(float base, float blend)
                {
                    return min(1.0, base / (1.0-blend));
                }

                float vividLight(float base, float blend)
                {
                    return (blend < 0.5) ? colorBurn(base,(2.0*blend)) : colorDodge(base,(2.0*(blend-0.5)));
                }

                vec3 blendVividLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
        main: `
                fragColor = vec4(blendVividLight(back.rgb, front.rgb, front.a), uBlend);
            `
      },
      gpu: {
        functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base / (1.0-blend));
                }

                fn vividLight(base: f32, blend: f32) -> f32
                {
                    return select(colorDodge(base,(2.0*(blend-0.5))), colorBurn(base,(2.0*blend)), blend<0.5);
                }

                fn blendVividLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
        main: `
                out = vec4<f32>(blendVividLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `
      }
    });
  }
};
VividLightBlend.extension = {
  name: "vivid-light",
  type: ExtensionType.BlendMode
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/blend-modes/init.mjs
extensions.add(
  ColorBlend,
  ColorBurnBlend,
  ColorDodgeBlend,
  DarkenBlend,
  DifferenceBlend,
  DivideBlend,
  ExclusionBlend,
  HardLightBlend,
  HardMixBlend,
  LightenBlend,
  LinearBurnBlend,
  LinearLightBlend,
  LinearDodgeBlend,
  LuminosityBlend,
  NegationBlend,
  OverlayBlend,
  PinLightBlend,
  SaturationBlend,
  SoftLightBlend,
  SubtractBlend,
  VividLightBlend
);

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/defaults/alpha/AlphaFilter.mjs
init_GpuProgram();
init_UniformGroup();
init_Filter();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/defaults/alpha/alpha.mjs
var source2 = "struct GlobalUniforms {\n  projectionMatrix:mat3x3<f32>,\n  worldTransformMatrix:mat3x3<f32>,\n  worldAlpha: f32\n}\n\nstruct GlobalFilterUniforms {\n  inputSize:vec4<f32>,\n  inputPixel:vec4<f32>,\n  inputClamp:vec4<f32>,\n  outputFrame:vec4<f32>,\n  backgroundFrame:vec4<f32>,\n  globalFrame:vec4<f32>,\n};\n\nstruct AlphaUniforms {\n  uAlpha:f32,\n};\n\n@group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n\n@group(1) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(1) @binding(1) var iTexture: texture_2d<f32>;\n@group(1) @binding(2) var iSampler : sampler;\n\n@group(2) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * max(gfu.outputFrame.zw, vec2(0.)) + gfu.outputFrame.xy;\n\n    return vec4((globalUniforms.projectionMatrix * globalUniforms.worldTransformMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);\n}\n\nfn filterBackgroundTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * gfu.backgroundFrame.zw;\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.globalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n) -> @location(0) vec4<f32> {\n  return textureSample(iTexture, iSampler, uv) * alphaUniforms.uAlpha;\n}";

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/filters/defaults/alpha/AlphaFilter.mjs
var _AlphaFilter = class extends Filter {
  constructor(options) {
    options = { ..._AlphaFilter.DEFAULT_OPTIONS, ...options };
    const gpuProgram = new GpuProgram({
      vertex: {
        source: source2,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source2,
        entryPoint: "mainFragment"
      }
    });
    const filterUniforms = new UniformGroup({
      uAlpha: { value: options.alpha, type: "f32" }
    });
    super({
      gpuProgram,
      resources: {
        filterUniforms
      }
    });
  }
  /**
   * Coefficient for alpha multiplication
   * @default 1
   */
  get alpha() {
    return this.resources.filterUniforms.uniforms.uAlpha;
  }
  set alpha(value) {
    this.resources.filterUniforms.uniforms.uAlpha = value;
  }
};
var AlphaFilter = _AlphaFilter;
AlphaFilter.DEFAULT_OPTIONS = {
  alpha: 1
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/index.mjs
init_Point();
init_Rectangle();
init_init6();
init_Container();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs
init_deprecation();
init_Container();
init_GraphicsContext();
init_GraphicsView();
var Graphics = class extends Container {
  constructor(options) {
    if (options instanceof GraphicsContext) {
      options = { context: options };
    }
    const { context: context2, ...rest } = options || {};
    super({
      view: new GraphicsView(context2),
      label: "Graphics",
      ...rest
    });
    this.allowChildren = false;
  }
  get context() {
    return this.view.context;
  }
  set context(context2) {
    this.view.context = context2;
  }
  _callContextMethod(method, args) {
    this.view.context[method](...args);
    return this;
  }
  fill(...args) {
    return this._callContextMethod("fill", args);
  }
  stroke(...args) {
    return this._callContextMethod("stroke", args);
  }
  texture(...args) {
    return this._callContextMethod("texture", args);
  }
  beginPath(...args) {
    return this._callContextMethod("beginPath", args);
  }
  cut(...args) {
    return this._callContextMethod("cut", args);
  }
  arc(...args) {
    return this._callContextMethod("arc", args);
  }
  arcTo(...args) {
    return this._callContextMethod("arcTo", args);
  }
  arcToSvg(...args) {
    return this._callContextMethod("arcToSvg", args);
  }
  bezierCurveTo(...args) {
    return this._callContextMethod("bezierCurveTo", args);
  }
  closePath(...args) {
    return this._callContextMethod("closePath", args);
  }
  ellipse(...args) {
    return this._callContextMethod("ellipse", args);
  }
  circle(...args) {
    return this._callContextMethod("circle", args);
  }
  path(...args) {
    return this._callContextMethod("path", args);
  }
  lineTo(...args) {
    return this._callContextMethod("lineTo", args);
  }
  moveTo(...args) {
    return this._callContextMethod("moveTo", args);
  }
  quadraticCurveTo(...args) {
    return this._callContextMethod("quadraticCurveTo", args);
  }
  rect(...args) {
    return this._callContextMethod("rect", args);
  }
  roundRect(...args) {
    return this._callContextMethod("roundRect", args);
  }
  poly(...args) {
    return this._callContextMethod("poly", args);
  }
  star(...args) {
    return this._callContextMethod("star", args);
  }
  svg(...args) {
    return this._callContextMethod("svg", args);
  }
  restore(...args) {
    return this._callContextMethod("restore", args);
  }
  save(...args) {
    return this._callContextMethod("save", args);
  }
  getTransform(...args) {
    return this._callContextMethod("getTransform", args);
  }
  resetTransform(...args) {
    return this._callContextMethod("resetTransform", args);
  }
  rotateTransform(...args) {
    return this._callContextMethod("rotate", args);
  }
  scaleTransform(...args) {
    return this._callContextMethod("scale", args);
  }
  setTransform(...args) {
    return this._callContextMethod("setTransform", args);
  }
  transform(...args) {
    return this._callContextMethod("transform", args);
  }
  translateTransform(...args) {
    return this._callContextMethod("translate", args);
  }
  clear(...args) {
    return this._callContextMethod("clear", args);
  }
  get fillStyle() {
    return this.view.context.fillStyle;
  }
  set fillStyle(value) {
    this.view.context.fillStyle = value;
  }
  get strokeStyle() {
    return this.view.context.strokeStyle;
  }
  set strokeStyle(value) {
    this.view.context.strokeStyle = value;
  }
  // v7 deprecations
  /**
   * @param color
   * @param alpha
   * @deprecated since 8.0.0
   */
  beginFill(color, alpha) {
    deprecation("8.0.0", "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
    this.endFill();
    this.context.fillStyle = { color, alpha };
    return this;
  }
  /**
   * @deprecated since 8.0.0
   */
  endFill() {
    deprecation("8.0.0", "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
    this.context.fill();
    return this;
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0
   */
  drawCircle(...args) {
    deprecation("8.0.0", "Graphics#drawCircle has been renamed to Graphics#circle");
    return this._callContextMethod("circle", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0
   */
  drawEllipse(...args) {
    deprecation("8.0.0", "Graphics#drawEllipse has been renamed to Graphics#ellipse");
    return this._callContextMethod("ellipse", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0
   */
  drawPolygon(...args) {
    deprecation("8.0.0", "Graphics#drawPolygon has been renamed to Graphics#poly");
    return this._callContextMethod("poly", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0
   */
  drawRect(...args) {
    deprecation("8.0.0", "Graphics#drawRect has been renamed to Graphics#rect");
    return this._callContextMethod("rect", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0
   */
  drawRoundedRect(...args) {
    deprecation("8.0.0", "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");
    return this._callContextMethod("roundRect", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0
   */
  drawStar(...args) {
    deprecation("8.0.0", "Graphics#drawStar has been renamed to Graphics#star");
    return this._callContextMethod("star", args);
  }
  get roundPixels() {
    return !!this.view.roundPixels;
  }
  set roundPixels(value) {
    this.view.roundPixels = value ? 1 : 0;
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/mesh-extras/NineSliceGeometry.mjs
init_Matrix();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/mesh-extras/PlaneGeometry.mjs
init_deprecation();
init_MeshGeometry();
var _PlaneGeometry = class extends MeshGeometry {
  constructor(...args) {
    super({});
    let options = args[0] ?? {};
    if (typeof options === "number") {
      deprecation(v8_0_0, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead");
      options = {
        width: options,
        height: args[1],
        verticesX: args[2],
        verticesY: args[3]
      };
    }
    this.build(options);
  }
  /**
   * Refreshes plane coordinates
   * @param options
   */
  build(options) {
    options = { ..._PlaneGeometry.defaultOptions, ...options };
    this.verticesX = this.verticesX ?? options.verticesX;
    this.verticesY = this.verticesY ?? options.verticesY;
    this.width = this.width ?? options.width;
    this.height = this.height ?? options.height;
    const total = this.verticesX * this.verticesY;
    const verts = [];
    const uvs = [];
    const indices = [];
    const verticesX = this.verticesX - 1;
    const verticesY = this.verticesY - 1;
    const sizeX = this.width / verticesX;
    const sizeY = this.height / verticesY;
    for (let i2 = 0; i2 < total; i2++) {
      const x3 = i2 % this.verticesX;
      const y2 = i2 / this.verticesX | 0;
      verts.push(x3 * sizeX, y2 * sizeY);
      uvs.push(x3 / verticesX, y2 / verticesY);
    }
    const totalSub = verticesX * verticesY;
    for (let i2 = 0; i2 < totalSub; i2++) {
      const xpos = i2 % verticesX;
      const ypos = i2 / verticesX | 0;
      const value = ypos * this.verticesX + xpos;
      const value2 = ypos * this.verticesX + xpos + 1;
      const value3 = (ypos + 1) * this.verticesX + xpos;
      const value4 = (ypos + 1) * this.verticesX + xpos + 1;
      indices.push(
        value,
        value2,
        value3,
        value2,
        value4,
        value3
      );
    }
    this.buffers[0].data = new Float32Array(verts);
    this.buffers[1].data = new Float32Array(uvs);
    this.indexBuffer.data = new Uint32Array(indices);
    this.buffers[0].update();
    this.buffers[1].update();
    this.indexBuffer.update();
  }
};
var PlaneGeometry = _PlaneGeometry;
PlaneGeometry.defaultOptions = {
  width: 100,
  height: 100,
  verticesX: 10,
  verticesY: 10
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/mesh-extras/NineSliceGeometry.mjs
var _NineSliceGeometry = class extends PlaneGeometry {
  constructor(options) {
    options = { ..._NineSliceGeometry.defaultOptions, ...options };
    super({
      width: options.width,
      height: options.height,
      verticesX: 4,
      verticesY: 4
    });
    this._textureMatrix = new Matrix();
    this.update(options);
  }
  update(options) {
    this.updateUvs(options);
    this.updatePositions(options);
  }
  updatePositions(options) {
    this.width = options.width ?? this.width;
    this.height = options.height ?? this.height;
    this._leftWidth = options.leftWidth ?? this._leftWidth;
    this._rightWidth = options.rightWidth ?? this._rightWidth;
    this._topHeight = options.topHeight ?? this._topHeight;
    this._bottomHeight = options.bottomHeight ?? this._bottomHeight;
    const positions = this.positions;
    const w2 = this._leftWidth + this._rightWidth;
    const scaleW = this.width > w2 ? 1 : this.width / w2;
    const h2 = this._topHeight + this._bottomHeight;
    const scaleH = this.height > h2 ? 1 : this.height / h2;
    const scale3 = Math.min(scaleW, scaleH);
    positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale3;
    positions[17] = positions[19] = positions[21] = positions[23] = this.height - this._bottomHeight * scale3;
    positions[25] = positions[27] = positions[29] = positions[31] = this.height;
    positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale3;
    positions[4] = positions[12] = positions[20] = positions[28] = this.width - this._rightWidth * scale3;
    positions[6] = positions[14] = positions[22] = positions[30] = this.width;
    this.getBuffer("aPosition").update();
  }
  updateUvs(options) {
    this._originalWidth = options.originalWidth ?? this._originalWidth;
    this._originalHeight = options.originalHeight ?? this._originalHeight;
    this._leftWidth = options.leftWidth ?? this._leftWidth;
    this._rightWidth = options.rightWidth ?? this._rightWidth;
    this._topHeight = options.topHeight ?? this._topHeight;
    this._bottomHeight = options.bottomHeight ?? this._bottomHeight;
    if (options.textureMatrix) {
      this._textureMatrix.copyFrom(options.textureMatrix);
    }
    const textureMatrix = this._textureMatrix;
    const uvs = this.uvs;
    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
    const _uvw = 1 / this._originalWidth;
    const _uvh = 1 / this._originalHeight;
    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
    multiplyUvs(textureMatrix, uvs);
    this.getBuffer("aUV").update();
  }
};
var NineSliceGeometry = _NineSliceGeometry;
NineSliceGeometry.defaultOptions = {
  width: 100,
  height: 100,
  leftWidth: 10,
  topHeight: 10,
  rightWidth: 10,
  bottomHeight: 10,
  originalWidth: 100,
  originalHeight: 100
};
function multiplyUvs(matrix, uvs, out2) {
  out2 ?? (out2 = uvs);
  const a2 = matrix.a;
  const b2 = matrix.b;
  const c2 = matrix.c;
  const d3 = matrix.d;
  const tx = matrix.tx;
  const ty = matrix.ty;
  for (let i2 = 0; i2 < uvs.length; i2 += 2) {
    const x3 = uvs[i2];
    const y2 = uvs[i2 + 1];
    out2[i2] = x3 * a2 + y2 * c2 + tx;
    out2[i2 + 1] = x3 * b2 + y2 * d3 + ty;
  }
  return out2;
}

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/mesh-extras/NineSliceSprite.mjs
init_Texture();
init_deprecation();
init_Container();
init_definedProps();
init_MeshView();
var _NineSliceSprite = class extends Container {
  /**
   * @param options - Options to use
   * @param options.texture - The texture to use on the NineSlicePlane.
   * @param options.leftWidth - Width of the left vertical bar (A)
   * @param options.topHeight - Height of the top horizontal bar (C)
   * @param options.rightWidth - Width of the right vertical bar (B)
   * @param options.bottomHeight - Height of the bottom horizontal bar (D)
   * @param options.width - Width of the NineSlicePlane,
   * setting this will actually modify the vertices and not the UV's of this plane.
   * @param options.height - Height of the NineSlicePlane,
   * setting this will actually modify the vertices and not UV's of this plane.
   */
  constructor(options) {
    if (options instanceof Texture) {
      options = { texture: options };
    }
    const { leftWidth, rightWidth, topHeight, bottomHeight, texture: optTex, ...rest } = options;
    const texture = optTex ?? _NineSliceSprite.defaultOptions.texture;
    const borders = texture.layout.defaultBorders;
    const nineSliceGeometry = new NineSliceGeometry(definedProps({
      width: texture.width,
      height: texture.height,
      originalWidth: texture.width,
      originalHeight: texture.height,
      leftWidth: leftWidth ?? borders?.left ?? _NineSliceSprite.defaultOptions.leftWidth,
      topHeight: topHeight ?? borders?.top ?? _NineSliceSprite.defaultOptions.topHeight,
      rightWidth: rightWidth ?? borders?.right ?? _NineSliceSprite.defaultOptions.rightWidth,
      bottomHeight: bottomHeight ?? borders?.bottom ?? _NineSliceSprite.defaultOptions.bottomHeight,
      textureMatrix: texture.textureMatrix.mapCoord
    }));
    super({
      view: new MeshView(definedProps({
        geometry: nineSliceGeometry,
        texture
      })),
      label: "NineSliceSprite",
      ...rest
    });
    this.allowChildren = false;
  }
  // /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
  get width() {
    return this.view.geometry.width;
  }
  set width(value) {
    this.view.geometry.updatePositions({
      width: value
    });
  }
  get height() {
    return this.view.geometry.height;
  }
  set height(value) {
    this.view.geometry.updatePositions({
      height: value
    });
  }
  get leftWidth() {
    return this.view.geometry._leftWidth;
  }
  set leftWidth(value) {
    this.view.geometry.updateUvs({
      leftWidth: value
    });
  }
  get topHeight() {
    return this.view.geometry._topHeight;
  }
  set topHeight(value) {
    this.view.geometry.updateUvs({
      topHeight: value
    });
  }
  get rightWidth() {
    return this.view.geometry._rightWidth;
  }
  set rightWidth(value) {
    this.view.geometry.updateUvs({
      rightWidth: value
    });
  }
  get bottomHeight() {
    return this.view.geometry._bottomHeight;
  }
  set bottomHeight(value) {
    this.view.geometry.updateUvs({
      bottomHeight: value
    });
  }
  get texture() {
    return this.view.texture;
  }
  set texture(value) {
    if (value === this.view.texture)
      return;
    this.view.geometry.updateUvs({
      originalWidth: value.width,
      originalHeight: value.height,
      textureMatrix: value.textureMatrix.mapCoord
    });
    this.view.texture = value;
  }
  get roundPixels() {
    return !!this.view.roundPixels;
  }
  set roundPixels(value) {
    this.view.roundPixels = value ? 1 : 0;
  }
};
var NineSliceSprite = _NineSliceSprite;
NineSliceSprite.defaultOptions = {
  texture: Texture.EMPTY,
  leftWidth: 10,
  topHeight: 10,
  rightWidth: 10,
  bottomHeight: 10
};
var NineSlicePlane = class extends NineSliceSprite {
  constructor(...args) {
    let options = args[0];
    if (options instanceof Texture) {
      deprecation(v8_0_0, "NineSlicePlane now uses the options object {texture, leftWidth, rightWidth, topHeight, bottomHeight}");
      options = {
        texture: options,
        leftWidth: args[1],
        topHeight: args[2],
        rightWidth: args[3],
        bottomHeight: args[4]
      };
    }
    deprecation(v8_0_0, "NineSlicePlane is deprecated. Use NineSliceSprite instead.");
    super(options);
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.mjs
init_Container();
init_definedProps();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpriteView.mjs
init_ObservablePoint();
init_Texture();
init_View();
init_uid();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/utils/Transform.mjs
init_Matrix();
init_ObservablePoint();
var Transform = class {
  constructor({ matrix, observer } = {}) {
    this.dirty = true;
    this._matrix = matrix ?? new Matrix();
    this.observer = observer;
    this.position = new ObservablePoint(this, 0, 0);
    this.scale = new ObservablePoint(this, 1, 1);
    this.pivot = new ObservablePoint(this, 0, 0);
    this.skew = new ObservablePoint(this, 0, 0);
    this._rotation = 0;
    this._cx = 1;
    this._sx = 0;
    this._cy = 0;
    this._sy = 1;
  }
  get matrix() {
    const lt = this._matrix;
    if (!this.dirty)
      return lt;
    lt.a = this._cx * this.scale.x;
    lt.b = this._sx * this.scale.x;
    lt.c = this._cy * this.scale.y;
    lt.d = this._sy * this.scale.y;
    lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
    lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
    this.dirty = false;
    return lt;
  }
  /**
   * Called when a value changes.
   * @param point
   * @internal
   */
  onUpdate(point) {
    this.dirty = true;
    if (point === this.skew) {
      this.updateSkew();
    }
    this.observer?.onUpdate(this);
  }
  /** Called when the skew or the rotation changes. */
  updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew.y);
    this._sx = Math.sin(this._rotation + this.skew.y);
    this._cy = -Math.sin(this._rotation - this.skew.x);
    this._sy = Math.cos(this._rotation - this.skew.x);
    this.dirty = true;
  }
  toString() {
    return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
  }
  /**
   * Decomposes a matrix and sets the transforms properties based on it.
   * @param matrix - The matrix to decompose
   */
  setFromMatrix(matrix) {
    matrix.decompose(this);
    this.dirty = true;
  }
  /** The rotation of the object in radians. */
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    if (this._rotation !== value) {
      this._rotation = value;
      this.updateSkew();
    }
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpriteView.mjs
var _TilingSpriteView = class {
  constructor(options) {
    this.owner = emptyViewObserver;
    this.uid = uid("tilingSpriteView");
    this.renderPipeId = "tilingSprite";
    this.batched = true;
    this.roundPixels = 0;
    this._bounds = [0, 1, 0, 0];
    this._boundsDirty = true;
    options = { ..._TilingSpriteView.defaultOptions, ...options };
    this.anchor = new ObservablePoint(this, 0, 0);
    this._applyAnchorToTexture = options.applyAnchorToTexture;
    this.texture = options.texture;
    this._width = options.width;
    this._height = options.height;
    this._tileTransform = new Transform({ observer: this });
  }
  get bounds() {
    if (this._boundsDirty) {
      this._updateBounds();
      this._boundsDirty = false;
    }
    return this._bounds;
  }
  set texture(value) {
    if (this._texture === value)
      return;
    this._texture = value;
    this.onUpdate();
  }
  get texture() {
    return this._texture;
  }
  set width(value) {
    this._width = value;
    this.onUpdate();
  }
  get width() {
    return this._width;
  }
  set height(value) {
    this._height = value;
    this.onUpdate();
  }
  get height() {
    return this._height;
  }
  _updateBounds() {
    const bounds = this._bounds;
    const anchor = this.anchor;
    const width = this._width;
    const height = this._height;
    bounds[1] = -anchor._x * width;
    bounds[0] = bounds[1] + width;
    bounds[3] = -anchor._y * height;
    bounds[2] = bounds[3] + height;
  }
  addBounds(bounds) {
    const _bounds = this.bounds;
    bounds.addFrame(
      _bounds[0],
      _bounds[2],
      _bounds[1],
      _bounds[3]
    );
  }
  containsPoint(point) {
    const width = this.bounds[2];
    const height = this.bounds[3];
    const x1 = -width * this.anchor.x;
    let y1 = 0;
    if (point.x >= x1 && point.x < x1 + width) {
      y1 = -height * this.anchor.y;
      if (point.y >= y1 && point.y < y1 + height)
        return true;
    }
    return false;
  }
  /**
   * @internal
   */
  onUpdate() {
    this._boundsDirty = true;
    this._didUpdate = true;
    this.owner.onViewUpdate();
  }
  /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
   */
  destroy(options = false) {
    this.anchor = null;
    this._tileTransform = null;
    this._bounds = null;
    const destroyTexture = typeof options === "boolean" ? options : options?.texture;
    if (destroyTexture) {
      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
      this._texture.destroy(destroyTextureSource);
    }
    this._texture = null;
  }
};
var TilingSpriteView = _TilingSpriteView;
TilingSpriteView.defaultOptions = {
  texture: Texture.WHITE,
  width: 256,
  height: 256,
  applyAnchorToTexture: false
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.mjs
var TilingSprite = class extends Container {
  constructor(options) {
    const { texture, width, height, applyAnchorToTexture, ...rest } = options ?? {};
    super({
      view: new TilingSpriteView(definedProps({
        texture,
        width,
        height,
        applyAnchorToTexture
      })),
      label: "TilingSprite",
      ...rest
    });
    this.allowChildren = false;
  }
  set texture(value) {
    this.view.texture = value;
  }
  get texture() {
    return this.view.texture;
  }
  get anchor() {
    return this.view.anchor;
  }
  set anchor(value) {
    this.view.anchor.x = value.x;
    this.view.anchor.y = value.y;
  }
  get width() {
    return this.view.width;
  }
  set width(value) {
    this.view.width = value;
  }
  get height() {
    return this.view.height;
  }
  set height(value) {
    this.view.height = value;
  }
  get tilePosition() {
    return this.view._tileTransform.position;
  }
  set tilePosition(value) {
    this.view._tileTransform.position.copyFrom(value);
  }
  get tileScale() {
    return this.view._tileTransform.scale;
  }
  set tileScale(value) {
    this.view._tileTransform.scale.copyFrom(value);
  }
  set tileRotation(value) {
    this.view._tileTransform.rotation = value;
  }
  get tileRotation() {
    return this.view._tileTransform.rotation;
  }
  get tileTransform() {
    return this.view._tileTransform;
  }
  get roundPixels() {
    return !!this.view.roundPixels;
  }
  set roundPixels(value) {
    this.view.roundPixels = value ? 1 : 0;
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/index.mjs
init_Sprite();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/HtmlTextStyle.mjs
init_warn();
init_TextStyle();
init_generateTextStyleKey();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/utils/textStyleToCSS.mjs
init_Color();
function textStyleToCSS(style) {
  const stroke = style._stroke;
  const fill = style._fill;
  const cssStyleString = [
    `color: ${Color.shared.setValue(fill.color).toHex()}`,
    `font-size: ${style.fontSize}px`,
    `font-family: ${style.fontFamily}`,
    `font-weight: ${style.fontWeight}`,
    `font-style: ${style.fontStyle}`,
    `font-variant: ${style.fontVariant}`,
    `letter-spacing: ${style.letterSpacing}px`,
    `text-align: ${style.align}`,
    `padding: ${style.padding}px`,
    `white-space: ${style.whiteSpace}`,
    ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],
    ...style.wordWrap ? [
      `word-wrap: ${style.breakWords ? "break-all" : "break-word"}`,
      `max-width: ${style.wordWrapWidth}px`
    ] : [],
    ...stroke ? [strokeToCSS(stroke)] : [],
    ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],
    ...style.cssOverrides
  ].join(";");
  const cssStyles = [`div { ${cssStyleString} }`];
  tagStyleToCSS(style.tagStyles, cssStyles);
  return cssStyles.join(" ");
}
function dropShadowToCSS(dropShadowStyle) {
  const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();
  const x3 = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);
  const y2 = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);
  const position = `${x3}px ${y2}px`;
  if (dropShadowStyle.blur > 0) {
    return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;
  }
  return `text-shadow: ${position} ${color}`;
}
function strokeToCSS(stroke) {
  return [
    `-webkit-text-stroke-width: ${stroke.width}px`,
    `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,
    `text-stroke-width: ${stroke.width}px`,
    `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,
    "paint-order: stroke"
  ].join(";");
}
var templates = {
  fontSize: `font-size: {{VALUE}}px`,
  fontFamily: `font-family: {{VALUE}}`,
  fontWeight: `font-weight: {{VALUE}}`,
  fontStyle: `font-style: {{VALUE}}`,
  fontVariant: `font-variant: {{VALUE}}`,
  letterSpacing: `letter-spacing: {{VALUE}}px`,
  align: `text-align: {{VALUE}}`,
  padding: `padding: {{VALUE}}px`,
  whiteSpace: `white-space: {{VALUE}}`,
  lineHeight: `line-height: {{VALUE}}px`,
  wordWrapWidth: `max-width: {{VALUE}}px`
};
var transform = {
  fill: (value) => `color: ${Color.shared.setValue(value).toHex()}`,
  breakWords: (value) => `word-wrap: ${value ? "break-all" : "break-word"}`,
  stroke: strokeToCSS,
  dropShadow: dropShadowToCSS
};
function tagStyleToCSS(tagStyles, out2) {
  for (const i2 in tagStyles) {
    const tagStyle = tagStyles[i2];
    const cssTagStyle = [];
    for (const j3 in tagStyle) {
      if (transform[j3]) {
        cssTagStyle.push(transform[j3](tagStyle[j3]));
      } else if (templates[j3]) {
        cssTagStyle.push(templates[j3].replace("{{VALUE}}", tagStyle[j3]));
      }
    }
    out2.push(`${i2} { ${cssTagStyle.join(";")} }`);
  }
}

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/html/HtmlTextStyle.mjs
var HTMLTextStyle = class _HTMLTextStyle extends TextStyle {
  constructor(options = {}) {
    super(options);
    this._cssOverrides = [];
    this.cssOverrides ?? (this.cssOverrides = options.cssOverrides);
    this.tagStyles = options.tagStyles ?? {};
  }
  set cssOverrides(value) {
    this._cssOverrides = value instanceof Array ? value : [value];
    this.update();
  }
  get cssOverrides() {
    return this._cssOverrides;
  }
  _generateKey() {
    this._styleKey = generateTextStyleKey(this) + this._cssOverrides.join("-");
    return this._styleKey;
  }
  update() {
    this._cssStyle = null;
    super.update();
  }
  clone() {
    return new _HTMLTextStyle({
      align: this.align,
      breakWords: this.breakWords,
      dropShadow: this.dropShadow,
      fill: this._fill,
      fontFamily: this.fontFamily,
      fontSize: this.fontSize,
      fontStyle: this.fontStyle,
      fontVariant: this.fontVariant,
      fontWeight: this.fontWeight,
      letterSpacing: this.letterSpacing,
      lineHeight: this.lineHeight,
      padding: this.padding,
      stroke: this._stroke,
      whiteSpace: this.whiteSpace,
      wordWrap: this.wordWrap,
      wordWrapWidth: this.wordWrapWidth,
      cssOverrides: this.cssOverrides
    });
  }
  get cssStyle() {
    if (!this._cssStyle) {
      this._cssStyle = textStyleToCSS(this);
    }
    return this._cssStyle;
  }
  /**
   * Add a style override, this can be any CSS property
   * it will override any built-in style. This is the
   * property and the value as a string (e.g., `color: red`).
   * This will override any other internal style.
   * @param {string} value - CSS style(s) to add.
   * @example
   * style.addOverride('background-color: red');
   */
  addOverride(...value) {
    const toAdd = value.filter((v3) => !this.cssOverrides.includes(v3));
    if (toAdd.length > 0) {
      this.cssOverrides.push(...toAdd);
      this.update();
    }
  }
  /**
   * Remove any overrides that match the value.
   * @param {string} value - CSS style to remove.
   * @example
   * style.removeOverride('background-color: red');
   */
  removeOverride(...value) {
    const toRemove = value.filter((v3) => this.cssOverrides.includes(v3));
    if (toRemove.length > 0) {
      this.cssOverrides = this.cssOverrides.filter((v3) => !toRemove.includes(v3));
      this.update();
    }
  }
  set fill(value) {
    if (typeof value !== "string" && typeof value !== "number") {
      warn("[HTMLTextStyle] only color fill is not supported by HTMLText");
    }
    super.fill = value;
  }
  set stroke(value) {
    if (value && typeof value !== "string" && typeof value !== "number") {
      warn("[HTMLTextStyle] only color stroke is not supported by HTMLText");
    }
    super.stroke = value;
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/Text.mjs
init_deprecation();
init_Container();
init_definedProps();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/TextView.mjs
init_Cache();
init_ObservablePoint();
init_View();
init_uid();
init_BitmapFont();
init_BitmapFontManager();
init_DynamicBitmapFont();
init_CanvasTextMetrics();
init_measureHtmlText();

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/utils/ensureTextStyle.mjs
init_TextStyle();
function ensureTextStyle(renderMode, style) {
  if (style instanceof TextStyle || style instanceof HTMLTextStyle) {
    return style;
  }
  return renderMode === "html" ? new HTMLTextStyle(style) : new TextStyle(style);
}

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/TextView.mjs
var map = {
  canvas: "text",
  html: "htmlText",
  bitmap: "bitmapText"
};
var TextView = class {
  constructor(options) {
    this.uid = uid("textView");
    this.renderPipeId = "text";
    this.owner = emptyViewObserver;
    this.batched = true;
    this.resolution = null;
    this._didUpdate = true;
    this.roundPixels = 0;
    this._bounds = [0, 1, 0, 0];
    this._boundsDirty = true;
    this.text = options.text ?? "";
    const renderMode = options.renderMode ?? this._detectRenderType(options.style);
    this._renderMode = renderMode;
    this._style = ensureTextStyle(renderMode, options.style);
    this.renderPipeId = map[renderMode];
    this.anchor = new ObservablePoint(this, 0, 0);
    this.resolution = options.resolution ?? null;
  }
  set text(value) {
    value = value.toString();
    if (this._text === value)
      return;
    this._text = value;
    this.onUpdate();
  }
  get text() {
    return this._text;
  }
  get style() {
    return this._style;
  }
  set style(style) {
    style = style || {};
    this._style?.off("update", this.onUpdate, this);
    this._style = ensureTextStyle(this._renderMode, style);
    this._style.on("update", this.onUpdate, this);
    this.onUpdate();
  }
  get bounds() {
    if (this._boundsDirty) {
      this._updateBounds();
      this._boundsDirty = false;
    }
    return this._bounds;
  }
  addBounds(bounds) {
    const _bounds = this.bounds;
    bounds.addFrame(
      _bounds[0],
      _bounds[2],
      _bounds[1],
      _bounds[3]
    );
  }
  containsPoint(point) {
    const width = this.bounds[2];
    const height = this.bounds[3];
    const x1 = -width * this.anchor.x;
    let y1 = 0;
    if (point.x >= x1 && point.x < x1 + width) {
      y1 = -height * this.anchor.y;
      if (point.y >= y1 && point.y < y1 + height)
        return true;
    }
    return false;
  }
  /** @internal */
  onUpdate() {
    this._didUpdate = true;
    this._boundsDirty = true;
    this.owner.onViewUpdate();
  }
  /** @internal */
  _getKey() {
    return `${this.text}:${this._style.styleKey}`;
  }
  _updateBounds() {
    const bounds = this._bounds;
    const padding = this._style.padding;
    const anchor = this.anchor;
    if (this.renderPipeId === "bitmapText") {
      const bitmapMeasurement = BitmapFontManager.measureText(this.text, this._style);
      const scale3 = bitmapMeasurement.scale;
      const offset = bitmapMeasurement.offsetY * scale3;
      const width = bitmapMeasurement.width * scale3;
      const height = bitmapMeasurement.height * scale3;
      bounds[0] = -anchor._x * width - padding;
      bounds[1] = bounds[0] + width;
      bounds[2] = -anchor._y * (height + offset) - padding;
      bounds[3] = bounds[2] + height;
    } else if (this.renderPipeId === "htmlText") {
      const htmlMeasurement = measureHtmlText(this.text, this._style);
      const { width, height } = htmlMeasurement;
      bounds[0] = -anchor._x * width - padding;
      bounds[1] = bounds[0] + width;
      bounds[2] = -anchor._y * height - padding;
      bounds[3] = bounds[2] + height;
    } else {
      const canvasMeasurement = CanvasTextMetrics.measureText(this.text, this._style);
      const { width, height } = canvasMeasurement;
      bounds[0] = -anchor._x * width - padding;
      bounds[1] = bounds[0] + width;
      bounds[2] = -anchor._y * height - padding;
      bounds[3] = bounds[2] + height;
    }
  }
  _detectRenderType(style) {
    if (style instanceof HTMLTextStyle) {
      return "html";
    }
    const fontData = Cache.get(style?.fontFamily);
    if (fontData instanceof DynamicBitmapFont || fontData instanceof BitmapFont) {
      return "bitmap";
    }
    return "canvas";
  }
  /**
   * Destroys this text renderable and optionally its style texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style
   */
  destroy(options = false) {
    this.owner = null;
    this._bounds = null;
    this.anchor = null;
    this._style.destroy(options);
    this._style = null;
    this._text = null;
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/scene/text/Text.mjs
var Text = class extends Container {
  constructor(...args) {
    let options = args[0];
    if (typeof options === "string" || args[1]) {
      deprecation(v8_0_0, 'use new Text({ text: "hi!", style }) instead');
      options = {
        text: options,
        style: args[1]
      };
    }
    const { style, text, renderMode, resolution, ...rest } = options;
    super({
      view: new TextView(definedProps({ style, text, renderMode, resolution })),
      label: "Text",
      ...rest
    });
    this.allowChildren = false;
  }
  get anchor() {
    return this.view.anchor;
  }
  set anchor(value) {
    this.view.anchor.x = value.x;
    this.view.anchor.y = value.y;
  }
  set text(value) {
    this.view.text = value;
  }
  get text() {
    return this.view.text;
  }
  set style(value) {
    this.view.style = value;
  }
  get style() {
    return this.view.style;
  }
  get roundPixels() {
    return !!this.view.roundPixels;
  }
  set roundPixels(value) {
    this.view.roundPixels = value ? 1 : 0;
  }
};

// ../../node_modules/.pnpm/pixi.js@8.0.0-beta.5/node_modules/pixi.js/lib/index.mjs
init_init5();
init_Ticker();
init_eventemitter3();
var import_earcut2 = __toESM(require_earcut(), 1);

// src/frontend/game/assets.ts
var loadedAssets = {};
async function loadAssets() {
  const sheet = await Assets.load("stars.json");
  const planetsheet = await Assets.load("planets.json");
  const uisheet = await Assets.load("uisheet.json");
  const planet = await Assets.load("planet.json");
  const buttonSheet = await Assets.load("ui/button.json");
  const font = await Assets.load("font.fnt");
  const buttonText = await Assets.load("buttontext.fnt");
  const segment = await Assets.load("segment.fnt");
  const buttonTextWhite = await Assets.load("buttontext_white.fnt");
  const bgTexture = await Assets.load("starfield.png");
  const navArrow = await Assets.load("navarrow.png");
  const starTexture = await Assets.load("stars.png");
  const shipyard = await Assets.load("shipyard.png");
  const station = await Assets.load("station.png");
  const jumpgate = await Assets.load("jumpgate.png");
  const treasure = await Assets.load("treasure-map.png");
  const select = await Assets.load("ui/select.png");
  const statsBlock = await Assets.load("ui/stats.png");
  const panel2 = await Assets.load("ui/panel2.png");
  const panelInvisible = await Assets.load("ui/panel_invisible.png");
  const selectInactive = await Assets.load("ui/select_inactive.png");
  const asteroidBelt = await Assets.load("asteroid_belt.png");
  const market = await Assets.load("money-bag-xxl.png");
  const spaceshipTexture = await Assets.load("spaceship.png");
  const probeTexture = await Assets.load("ships/PROBE.png");
  const lightFreighterTexture = await Assets.load("ships/LIGHT_FREIGHTER.png");
  loadedAssets = {
    sheet,
    planetsheet,
    uisheet,
    font,
    buttonsheet: buttonSheet,
    buttonText,
    planet,
    buttonTextWhite,
    bgTexture,
    navArrow,
    panelInvisible,
    starTexture,
    statsBlock,
    panel2,
    station,
    jumpgate,
    treasure,
    spaceshipTexture,
    spaceshipTextures: {
      FRAME_PROBE: probeTexture,
      FRAME_LIGHT_FREIGHTER: lightFreighterTexture,
      FRAME_EXPLORER: await Assets.load("ships/FRAME_EXPLORER.png")
    },
    asteroidBelt,
    shipyard,
    select,
    selectInactive,
    market,
    panel: await Assets.load("ui/panel.png"),
    button: await Assets.load("ui/button.png"),
    panelBg: await Assets.load("ui/panelbg.png")
  };
}

// ../../node_modules/.pnpm/@trpc+server@10.38.5/node_modules/@trpc/server/dist/observable-ade1bad8.mjs
function identity(x3) {
  return x3;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce((prev, fn) => fn(prev), input);
  };
}
function observable(subscribe) {
  const self2 = {
    subscribe(observer) {
      let teardownRef = null;
      let isDone = false;
      let unsubscribed = false;
      let teardownImmediately = false;
      function unsubscribe() {
        if (teardownRef === null) {
          teardownImmediately = true;
          return;
        }
        if (unsubscribed) {
          return;
        }
        unsubscribed = true;
        if (typeof teardownRef === "function") {
          teardownRef();
        } else if (teardownRef) {
          teardownRef.unsubscribe();
        }
      }
      teardownRef = subscribe({
        next(value) {
          if (isDone) {
            return;
          }
          observer.next?.(value);
        },
        error(err) {
          if (isDone) {
            return;
          }
          isDone = true;
          observer.error?.(err);
          unsubscribe();
        },
        complete() {
          if (isDone) {
            return;
          }
          isDone = true;
          observer.complete?.();
          unsubscribe();
        }
      });
      if (teardownImmediately) {
        unsubscribe();
      }
      return {
        unsubscribe
      };
    },
    pipe(...operations) {
      return pipeFromArray(operations)(self2);
    }
  };
  return self2;
}

// ../../node_modules/.pnpm/@trpc+server@10.38.5/node_modules/@trpc/server/dist/observable/index.mjs
function share(_opts) {
  return (originalObserver) => {
    let refCount = 0;
    let subscription = null;
    const observers = [];
    function startIfNeeded() {
      if (subscription) {
        return;
      }
      subscription = originalObserver.subscribe({
        next(value) {
          for (const observer of observers) {
            observer.next?.(value);
          }
        },
        error(error) {
          for (const observer of observers) {
            observer.error?.(error);
          }
        },
        complete() {
          for (const observer of observers) {
            observer.complete?.();
          }
        }
      });
    }
    function resetIfNeeded() {
      if (refCount === 0 && subscription) {
        const _sub = subscription;
        subscription = null;
        _sub.unsubscribe();
      }
    }
    return {
      subscribe(observer) {
        refCount++;
        observers.push(observer);
        startIfNeeded();
        return {
          unsubscribe() {
            refCount--;
            resetIfNeeded();
            const index = observers.findIndex((v3) => v3 === observer);
            if (index > -1) {
              observers.splice(index, 1);
            }
          }
        };
      }
    };
  };
}
var ObservableAbortError = class _ObservableAbortError extends Error {
  constructor(message) {
    super(message);
    this.name = "ObservableAbortError";
    Object.setPrototypeOf(this, _ObservableAbortError.prototype);
  }
};
function observableToPromise(observable2) {
  let abort;
  const promise2 = new Promise((resolve, reject) => {
    let isDone = false;
    function onDone() {
      if (isDone) {
        return;
      }
      isDone = true;
      reject(new ObservableAbortError("This operation was aborted."));
      obs$.unsubscribe();
    }
    const obs$ = observable2.subscribe({
      next(data) {
        isDone = true;
        resolve(data);
        onDone();
      },
      error(data) {
        isDone = true;
        reject(data);
        onDone();
      },
      complete() {
        isDone = true;
        onDone();
      }
    });
    abort = onDone;
  });
  return {
    promise: promise2,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort
  };
}

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/splitLink-4c75f7be.mjs
function createChain(opts) {
  return observable((observer) => {
    function execute(index = 0, op = opts.op) {
      const next = opts.links[index];
      if (!next) {
        throw new Error("No more links to execute - did you forget to add an ending link?");
      }
      const subscription = next({
        op,
        next(nextOp) {
          const nextObserver = execute(index + 1, nextOp);
          return nextObserver;
        }
      });
      return subscription;
    }
    const obs$ = execute();
    return obs$.subscribe(observer);
  });
}
function asArray(value) {
  return Array.isArray(value) ? value : [
    value
  ];
}
function splitLink(opts) {
  return (runtime) => {
    const yes = asArray(opts.true).map((link) => link(runtime));
    const no = asArray(opts.false).map((link) => link(runtime));
    return (props) => {
      return observable((observer) => {
        const links = opts.condition(props.op) ? yes : no;
        return createChain({
          op: props.op,
          links
        }).subscribe(observer);
      });
    };
  };
}

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/transformResult-ace864b8.mjs
function isObject(value) {
  return !!value && !Array.isArray(value) && typeof value === "object";
}
function transformResultInner(response, runtime) {
  if ("error" in response) {
    const error = runtime.transformer.deserialize(response.error);
    return {
      ok: false,
      error: {
        ...response,
        error
      }
    };
  }
  const result = {
    ...response.result,
    ...(!response.result.type || response.result.type === "data") && {
      type: "data",
      data: runtime.transformer.deserialize(response.result.data)
    }
  };
  return {
    ok: true,
    result
  };
}
var TransformResultError = class extends Error {
  constructor() {
    super("Unable to transform response from server");
  }
};
function transformResult(response, runtime) {
  let result;
  try {
    result = transformResultInner(response, runtime);
  } catch (err) {
    throw new TransformResultError();
  }
  if (!result.ok && (!isObject(result.error.error) || typeof result.error.error.code !== "number")) {
    throw new TransformResultError();
  }
  if (result.ok && !isObject(result.result)) {
    throw new TransformResultError();
  }
  return result;
}

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/TRPCClientError-0de4d231.mjs
function isTRPCClientError(cause) {
  return cause instanceof TRPCClientError || /**
  * @deprecated
  * Delete in next major
  */
  cause instanceof Error && cause.name === "TRPCClientError";
}
function isTRPCErrorResponse(obj) {
  return isObject(obj) && isObject(obj.error) && typeof obj.error.code === "number" && typeof obj.error.message === "string";
}
var TRPCClientError = class _TRPCClientError extends Error {
  static from(_cause, opts = {}) {
    const cause = _cause;
    if (isTRPCClientError(cause)) {
      if (opts.meta) {
        cause.meta = {
          ...cause.meta,
          ...opts.meta
        };
      }
      return cause;
    }
    if (isTRPCErrorResponse(cause)) {
      return new _TRPCClientError(cause.error.message, {
        ...opts,
        result: cause
      });
    }
    if (!(cause instanceof Error)) {
      return new _TRPCClientError("Unknown error", {
        ...opts,
        cause
      });
    }
    return new _TRPCClientError(cause.message, {
      ...opts,
      cause
    });
  }
  constructor(message, opts) {
    const cause = opts?.cause;
    super(message, {
      cause
    });
    this.meta = opts?.meta;
    this.cause = cause;
    this.shape = opts?.result?.error;
    this.data = opts?.result?.error.data;
    this.name = "TRPCClientError";
    Object.setPrototypeOf(this, _TRPCClientError.prototype);
  }
};

// ../../node_modules/.pnpm/@trpc+server@10.38.5/node_modules/@trpc/server/dist/codes-c924c3db.mjs
function invert(obj) {
  const newObj = /* @__PURE__ */ Object.create(null);
  for (const key in obj) {
    const v3 = obj[key];
    newObj[v3] = key;
  }
  return newObj;
}
var TRPC_ERROR_CODES_BY_KEY = {
  /**
  * Invalid JSON was received by the server.
  * An error occurred on the server while parsing the JSON text.
  */
  PARSE_ERROR: -32700,
  /**
  * The JSON sent is not a valid Request object.
  */
  BAD_REQUEST: -32600,
  // Internal JSON-RPC error
  INTERNAL_SERVER_ERROR: -32603,
  NOT_IMPLEMENTED: -32603,
  // Implementation specific errors
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099
};
var TRPC_ERROR_CODES_BY_NUMBER = invert(TRPC_ERROR_CODES_BY_KEY);

// ../../node_modules/.pnpm/@trpc+server@10.38.5/node_modules/@trpc/server/dist/index-f91d720c.mjs
var TRPC_ERROR_CODES_BY_NUMBER2 = invert(TRPC_ERROR_CODES_BY_KEY);
var noop = () => {
};
function createInnerProxy(callback, path2) {
  const proxy = new Proxy(noop, {
    get(_obj, key) {
      if (typeof key !== "string" || key === "then") {
        return void 0;
      }
      return createInnerProxy(callback, [
        ...path2,
        key
      ]);
    },
    apply(_1, _2, args) {
      const isApply = path2[path2.length - 1] === "apply";
      return callback({
        args: isApply ? args.length >= 2 ? args[1] : [] : args,
        path: isApply ? path2.slice(0, -1) : path2
      });
    }
  });
  return proxy;
}
var createRecursiveProxy = (callback) => createInnerProxy(callback, []);
var createFlatProxy = (callback) => {
  return new Proxy(noop, {
    get(_obj, name) {
      if (typeof name !== "string" || name === "then") {
        return void 0;
      }
      return callback(name);
    }
  });
};

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/httpUtils-0cb58db4.mjs
var isFunction = (fn) => typeof fn === "function";
function getFetch(customFetchImpl) {
  if (customFetchImpl) {
    return customFetchImpl;
  }
  if (typeof window !== "undefined" && isFunction(window.fetch)) {
    return window.fetch;
  }
  if (typeof globalThis !== "undefined" && isFunction(globalThis.fetch)) {
    return globalThis.fetch;
  }
  throw new Error("No fetch implementation found");
}
function getAbortController(customAbortControllerImpl) {
  if (customAbortControllerImpl) {
    return customAbortControllerImpl;
  }
  if (typeof window !== "undefined" && window.AbortController) {
    return window.AbortController;
  }
  if (typeof globalThis !== "undefined" && globalThis.AbortController) {
    return globalThis.AbortController;
  }
  return null;
}
function resolveHTTPLinkOptions(opts) {
  return {
    url: opts.url,
    fetch: opts.fetch,
    AbortController: getAbortController(opts.AbortController)
  };
}
function arrayToDict(array) {
  const dict = {};
  for (let index = 0; index < array.length; index++) {
    const element = array[index];
    dict[index] = element;
  }
  return dict;
}
var METHOD = {
  query: "GET",
  mutation: "POST"
};
function getInput(opts) {
  return "input" in opts ? opts.runtime.transformer.serialize(opts.input) : arrayToDict(opts.inputs.map((_input) => opts.runtime.transformer.serialize(_input)));
}
var getUrl = (opts) => {
  let url = opts.url + "/" + opts.path;
  const queryParts = [];
  if ("inputs" in opts) {
    queryParts.push("batch=1");
  }
  if (opts.type === "query") {
    const input = getInput(opts);
    if (input !== void 0) {
      queryParts.push(`input=${encodeURIComponent(JSON.stringify(input))}`);
    }
  }
  if (queryParts.length) {
    url += "?" + queryParts.join("&");
  }
  return url;
};
var getBody = (opts) => {
  if (opts.type === "query") {
    return void 0;
  }
  const input = getInput(opts);
  return input !== void 0 ? JSON.stringify(input) : void 0;
};
var jsonHttpRequester = (opts) => {
  return httpRequest({
    ...opts,
    contentTypeHeader: "application/json",
    getUrl,
    getBody
  });
};
async function fetchHTTPResponse(opts, ac) {
  const url = opts.getUrl(opts);
  const body = opts.getBody(opts);
  const { type } = opts;
  const resolvedHeaders = await opts.headers();
  if (type === "subscription") {
    throw new Error("Subscriptions should use wsLink");
  }
  const headers = {
    ...opts.contentTypeHeader ? {
      "content-type": opts.contentTypeHeader
    } : {},
    ...opts.batchModeHeader ? {
      "trpc-batch-mode": opts.batchModeHeader
    } : {},
    ...resolvedHeaders
  };
  return getFetch(opts.fetch)(url, {
    method: METHOD[type],
    signal: ac?.signal,
    body,
    headers
  });
}
function httpRequest(opts) {
  const ac = opts.AbortController ? new opts.AbortController() : null;
  const meta = {};
  let done = false;
  const promise2 = new Promise((resolve, reject) => {
    fetchHTTPResponse(opts, ac).then((_res) => {
      meta.response = _res;
      done = true;
      return _res.json();
    }).then((json) => {
      meta.responseJSON = json;
      resolve({
        json,
        meta
      });
    }).catch((err) => {
      done = true;
      reject(TRPCClientError.from(err, {
        meta
      }));
    });
  });
  const cancel = () => {
    if (!done) {
      ac?.abort();
    }
  };
  return {
    promise: promise2,
    cancel
  };
}

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/httpBatchLink-cee1f56c.mjs
var throwFatalError = () => {
  throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
};
function dataLoader(batchLoader) {
  let pendingItems = null;
  let dispatchTimer = null;
  const destroyTimerAndPendingItems = () => {
    clearTimeout(dispatchTimer);
    dispatchTimer = null;
    pendingItems = null;
  };
  function groupItems(items) {
    const groupedItems = [
      []
    ];
    let index = 0;
    while (true) {
      const item = items[index];
      if (!item) {
        break;
      }
      const lastGroup = groupedItems[groupedItems.length - 1];
      if (item.aborted) {
        item.reject?.(new Error("Aborted"));
        index++;
        continue;
      }
      const isValid = batchLoader.validate(lastGroup.concat(item).map((it) => it.key));
      if (isValid) {
        lastGroup.push(item);
        index++;
        continue;
      }
      if (lastGroup.length === 0) {
        item.reject?.(new Error("Input is too big for a single dispatch"));
        index++;
        continue;
      }
      groupedItems.push([]);
    }
    return groupedItems;
  }
  function dispatch() {
    const groupedItems = groupItems(pendingItems);
    destroyTimerAndPendingItems();
    for (const items of groupedItems) {
      if (!items.length) {
        continue;
      }
      const batch = {
        items,
        cancel: throwFatalError
      };
      for (const item of items) {
        item.batch = batch;
      }
      const unitResolver = (index, value) => {
        const item = batch.items[index];
        item.resolve?.(value);
        item.batch = null;
        item.reject = null;
        item.resolve = null;
      };
      const { promise: promise2, cancel } = batchLoader.fetch(batch.items.map((_item) => _item.key), unitResolver);
      batch.cancel = cancel;
      promise2.then((result) => {
        for (let i2 = 0; i2 < result.length; i2++) {
          const value = result[i2];
          unitResolver(i2, value);
        }
        for (const item of batch.items) {
          item.reject?.(new Error("Missing result"));
          item.batch = null;
        }
      }).catch((cause) => {
        for (const item of batch.items) {
          item.reject?.(cause);
          item.batch = null;
        }
      });
    }
  }
  function load(key) {
    const item = {
      aborted: false,
      key,
      batch: null,
      resolve: throwFatalError,
      reject: throwFatalError
    };
    const promise2 = new Promise((resolve, reject) => {
      item.reject = reject;
      item.resolve = resolve;
      if (!pendingItems) {
        pendingItems = [];
      }
      pendingItems.push(item);
    });
    if (!dispatchTimer) {
      dispatchTimer = setTimeout(dispatch);
    }
    const cancel = () => {
      item.aborted = true;
      if (item.batch?.items.every((item2) => item2.aborted)) {
        item.batch.cancel();
        item.batch = null;
      }
    };
    return {
      promise: promise2,
      cancel
    };
  }
  return {
    load
  };
}
function createHTTPBatchLink(requester) {
  return function httpBatchLink2(opts) {
    const resolvedOpts = resolveHTTPLinkOptions(opts);
    const maxURLLength = opts.maxURLLength ?? Infinity;
    return (runtime) => {
      const batchLoader = (type) => {
        const validate = (batchOps) => {
          if (maxURLLength === Infinity) {
            return true;
          }
          const path2 = batchOps.map((op) => op.path).join(",");
          const inputs = batchOps.map((op) => op.input);
          const url = getUrl({
            ...resolvedOpts,
            runtime,
            type,
            path: path2,
            inputs
          });
          return url.length <= maxURLLength;
        };
        const fetch2 = requester({
          ...resolvedOpts,
          runtime,
          type,
          opts
        });
        return {
          validate,
          fetch: fetch2
        };
      };
      const query = dataLoader(batchLoader("query"));
      const mutation = dataLoader(batchLoader("mutation"));
      const subscription = dataLoader(batchLoader("subscription"));
      const loaders = {
        query,
        subscription,
        mutation
      };
      return ({ op }) => {
        return observable((observer) => {
          const loader = loaders[op.type];
          const { promise: promise2, cancel } = loader.load(op);
          let _res = void 0;
          promise2.then((res) => {
            _res = res;
            const transformed = transformResult(res.json, runtime);
            if (!transformed.ok) {
              observer.error(TRPCClientError.from(transformed.error, {
                meta: res.meta
              }));
              return;
            }
            observer.next({
              context: res.meta,
              result: transformed.result
            });
            observer.complete();
          }).catch((err) => {
            observer.error(TRPCClientError.from(err, {
              meta: _res?.meta
            }));
          });
          return () => {
            cancel();
          };
        });
      };
    };
  };
}
var batchRequester = (requesterOpts) => {
  return (batchOps) => {
    const path2 = batchOps.map((op) => op.path).join(",");
    const inputs = batchOps.map((op) => op.input);
    const { promise: promise2, cancel } = jsonHttpRequester({
      ...requesterOpts,
      path: path2,
      inputs,
      headers() {
        if (!requesterOpts.opts.headers) {
          return {};
        }
        if (typeof requesterOpts.opts.headers === "function") {
          return requesterOpts.opts.headers({
            opList: batchOps
          });
        }
        return requesterOpts.opts.headers;
      }
    });
    return {
      promise: promise2.then((res) => {
        const resJSON = Array.isArray(res.json) ? res.json : batchOps.map(() => res.json);
        const result = resJSON.map((item) => ({
          meta: res.meta,
          json: item
        }));
        return result;
      }),
      cancel
    };
  };
};
var httpBatchLink = createHTTPBatchLink(batchRequester);

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/links/httpLink.mjs
function httpLinkFactory(factoryOpts) {
  return (opts) => {
    const resolvedOpts = resolveHTTPLinkOptions(opts);
    return (runtime) => ({ op }) => observable((observer) => {
      const { path: path2, input, type } = op;
      const { promise: promise2, cancel } = factoryOpts.requester({
        ...resolvedOpts,
        runtime,
        type,
        path: path2,
        input,
        headers() {
          if (!opts.headers) {
            return {};
          }
          if (typeof opts.headers === "function") {
            return opts.headers({
              op
            });
          }
          return opts.headers;
        }
      });
      let meta = void 0;
      promise2.then((res) => {
        meta = res.meta;
        const transformed = transformResult(res.json, runtime);
        if (!transformed.ok) {
          observer.error(TRPCClientError.from(transformed.error, {
            meta
          }));
          return;
        }
        observer.next({
          context: res.meta,
          result: transformed.result
        });
        observer.complete();
      }).catch((cause) => {
        observer.error(TRPCClientError.from(cause, {
          meta
        }));
      });
      return () => {
        cancel();
      };
    });
  };
}
var httpLink = httpLinkFactory({
  requester: jsonHttpRequester
});

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/links/wsLink.mjs
var retryDelay = (attemptIndex) => attemptIndex === 0 ? 0 : Math.min(1e3 * 2 ** attemptIndex, 3e4);
function createWSClient(opts) {
  const { url, WebSocket: WebSocketImpl = WebSocket, retryDelayMs: retryDelayFn = retryDelay, onOpen, onClose } = opts;
  if (!WebSocketImpl) {
    throw new Error("No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill");
  }
  let outgoing = [];
  const pendingRequests = /* @__PURE__ */ Object.create(null);
  let connectAttempt = 0;
  let dispatchTimer = null;
  let connectTimer = null;
  let activeConnection = createWS();
  let state = "connecting";
  function dispatch() {
    if (state !== "open" || dispatchTimer) {
      return;
    }
    dispatchTimer = setTimeout(() => {
      dispatchTimer = null;
      if (outgoing.length === 1) {
        activeConnection.send(JSON.stringify(outgoing.pop()));
      } else {
        activeConnection.send(JSON.stringify(outgoing));
      }
      outgoing = [];
    });
  }
  function tryReconnect() {
    if (connectTimer !== null || state === "closed") {
      return;
    }
    const timeout = retryDelayFn(connectAttempt++);
    reconnectInMs(timeout);
  }
  function reconnect() {
    state = "connecting";
    const oldConnection = activeConnection;
    activeConnection = createWS();
    closeIfNoPending(oldConnection);
  }
  function reconnectInMs(ms) {
    if (connectTimer) {
      return;
    }
    state = "connecting";
    connectTimer = setTimeout(reconnect, ms);
  }
  function closeIfNoPending(conn) {
    const hasPendingRequests = Object.values(pendingRequests).some((p2) => p2.ws === conn);
    if (!hasPendingRequests) {
      conn.close();
    }
  }
  function closeActiveSubscriptions() {
    Object.values(pendingRequests).forEach((req) => {
      if (req.type === "subscription") {
        req.callbacks.complete();
      }
    });
  }
  function resumeSubscriptionOnReconnect(req) {
    if (outgoing.some((r2) => r2.id === req.op.id)) {
      return;
    }
    request(req.op, req.callbacks);
  }
  function createWS() {
    const urlString = typeof url === "function" ? url() : url;
    const conn = new WebSocketImpl(urlString);
    clearTimeout(connectTimer);
    connectTimer = null;
    conn.addEventListener("open", () => {
      if (conn !== activeConnection) {
        return;
      }
      connectAttempt = 0;
      state = "open";
      onOpen?.();
      dispatch();
    });
    conn.addEventListener("error", () => {
      if (conn === activeConnection) {
        tryReconnect();
      }
    });
    const handleIncomingRequest = (req) => {
      if (req.method === "reconnect" && conn === activeConnection) {
        if (state === "open") {
          onClose?.();
        }
        reconnect();
        for (const pendingReq of Object.values(pendingRequests)) {
          if (pendingReq.type === "subscription") {
            resumeSubscriptionOnReconnect(pendingReq);
          }
        }
      }
    };
    const handleIncomingResponse = (data) => {
      const req = data.id !== null && pendingRequests[data.id];
      if (!req) {
        return;
      }
      req.callbacks.next?.(data);
      if (req.ws !== activeConnection && conn === activeConnection) {
        const oldWs = req.ws;
        req.ws = activeConnection;
        closeIfNoPending(oldWs);
      }
      if ("result" in data && data.result.type === "stopped" && conn === activeConnection) {
        req.callbacks.complete();
      }
    };
    conn.addEventListener("message", ({ data }) => {
      const msg = JSON.parse(data);
      if ("method" in msg) {
        handleIncomingRequest(msg);
      } else {
        handleIncomingResponse(msg);
      }
      if (conn !== activeConnection || state === "closed") {
        closeIfNoPending(conn);
      }
    });
    conn.addEventListener("close", ({ code }) => {
      if (state === "open") {
        onClose?.({
          code
        });
      }
      if (activeConnection === conn) {
        tryReconnect();
      }
      for (const [key, req] of Object.entries(pendingRequests)) {
        if (req.ws !== conn) {
          continue;
        }
        if (state === "closed") {
          delete pendingRequests[key];
          req.callbacks.complete?.();
          continue;
        }
        if (req.type === "subscription") {
          resumeSubscriptionOnReconnect(req);
        } else {
          delete pendingRequests[key];
          req.callbacks.error?.(TRPCClientError.from(new TRPCWebSocketClosedError("WebSocket closed prematurely")));
        }
      }
    });
    return conn;
  }
  function request(op, callbacks) {
    const { type, input, path: path2, id } = op;
    const envelope = {
      id,
      method: type,
      params: {
        input,
        path: path2
      }
    };
    pendingRequests[id] = {
      ws: activeConnection,
      type,
      callbacks,
      op
    };
    outgoing.push(envelope);
    dispatch();
    return () => {
      const callbacks2 = pendingRequests[id]?.callbacks;
      delete pendingRequests[id];
      outgoing = outgoing.filter((msg) => msg.id !== id);
      callbacks2?.complete?.();
      if (activeConnection.readyState === WebSocketImpl.OPEN && op.type === "subscription") {
        outgoing.push({
          id,
          method: "subscription.stop"
        });
        dispatch();
      }
    };
  }
  return {
    close: () => {
      state = "closed";
      onClose?.();
      closeActiveSubscriptions();
      closeIfNoPending(activeConnection);
      clearTimeout(connectTimer);
      connectTimer = null;
    },
    request,
    getConnection() {
      return activeConnection;
    }
  };
}
var TRPCWebSocketClosedError = class _TRPCWebSocketClosedError extends Error {
  constructor(message) {
    super(message);
    this.name = "TRPCWebSocketClosedError";
    Object.setPrototypeOf(this, _TRPCWebSocketClosedError.prototype);
  }
};
function wsLink(opts) {
  return (runtime) => {
    const { client } = opts;
    return ({ op }) => {
      return observable((observer) => {
        const { type, path: path2, id, context: context2 } = op;
        const input = runtime.transformer.serialize(op.input);
        const unsub = client.request({
          type,
          path: path2,
          input,
          id,
          context: context2
        }, {
          error(err) {
            observer.error(err);
            unsub();
          },
          complete() {
            observer.complete();
          },
          next(message) {
            const transformed = transformResult(message, runtime);
            if (!transformed.ok) {
              observer.error(TRPCClientError.from(transformed.error));
              return;
            }
            observer.next({
              result: transformed.result
            });
            if (op.type !== "subscription") {
              unsub();
              observer.complete();
            }
          }
        });
        return () => {
          unsub();
        };
      });
    };
  };
}

// ../../node_modules/.pnpm/@trpc+client@10.38.5_@trpc+server@10.38.5/node_modules/@trpc/client/dist/index.mjs
var TRPCUntypedClient = class {
  $request({ type, input, path: path2, context: context2 = {} }) {
    const chain$ = createChain({
      links: this.links,
      op: {
        id: ++this.requestId,
        type,
        path: path2,
        input,
        context: context2
      }
    });
    return chain$.pipe(share());
  }
  requestAsPromise(opts) {
    const req$ = this.$request(opts);
    const { promise: promise2, abort } = observableToPromise(req$);
    const abortablePromise = new Promise((resolve, reject) => {
      opts.signal?.addEventListener("abort", abort);
      promise2.then((envelope) => {
        resolve(envelope.result.data);
      }).catch((err) => {
        reject(TRPCClientError.from(err));
      });
    });
    return abortablePromise;
  }
  query(path2, input, opts) {
    return this.requestAsPromise({
      type: "query",
      path: path2,
      input,
      context: opts?.context,
      signal: opts?.signal
    });
  }
  mutation(path2, input, opts) {
    return this.requestAsPromise({
      type: "mutation",
      path: path2,
      input,
      context: opts?.context,
      signal: opts?.signal
    });
  }
  subscription(path2, input, opts) {
    const observable$ = this.$request({
      type: "subscription",
      path: path2,
      input,
      context: opts?.context
    });
    return observable$.subscribe({
      next(envelope) {
        if (envelope.result.type === "started") {
          opts.onStarted?.();
        } else if (envelope.result.type === "stopped") {
          opts.onStopped?.();
        } else {
          opts.onData?.(envelope.result.data);
        }
      },
      error(err) {
        opts.onError?.(err);
      },
      complete() {
        opts.onComplete?.();
      }
    });
  }
  constructor(opts) {
    this.requestId = 0;
    const combinedTransformer = (() => {
      const transformer = opts.transformer;
      if (!transformer) {
        return {
          input: {
            serialize: (data) => data,
            deserialize: (data) => data
          },
          output: {
            serialize: (data) => data,
            deserialize: (data) => data
          }
        };
      }
      if ("input" in transformer) {
        return opts.transformer;
      }
      return {
        input: transformer,
        output: transformer
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (data) => combinedTransformer.input.serialize(data),
        deserialize: (data) => combinedTransformer.output.deserialize(data)
      },
      combinedTransformer
    };
    this.links = opts.links.map((link) => link(this.runtime));
  }
};
var clientCallTypeMap = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
};
var clientCallTypeToProcedureType = (clientCallType) => {
  return clientCallTypeMap[clientCallType];
};
function createTRPCClientProxy(client) {
  return createFlatProxy((key) => {
    if (client.hasOwnProperty(key)) {
      return client[key];
    }
    if (key === "__untypedClient") {
      return client;
    }
    return createRecursiveProxy(({ path: path2, args }) => {
      const pathCopy = [
        key,
        ...path2
      ];
      const procedureType = clientCallTypeToProcedureType(pathCopy.pop());
      const fullPath = pathCopy.join(".");
      return client[procedureType](fullPath, ...args);
    });
  });
}
function createTRPCProxyClient(opts) {
  const client = new TRPCUntypedClient(opts);
  const proxy = createTRPCClientProxy(client);
  return proxy;
}
function getTextDecoder(customTextDecoder) {
  if (customTextDecoder) {
    return customTextDecoder;
  }
  if (typeof window !== "undefined" && window.TextDecoder) {
    return new window.TextDecoder();
  }
  if (typeof globalThis !== "undefined" && globalThis.TextDecoder) {
    return new globalThis.TextDecoder();
  }
  throw new Error("No TextDecoder implementation found");
}
async function parseJSONStream(opts) {
  const parse = opts.parse ?? JSON.parse;
  const onLine = (line) => {
    if (opts.signal?.aborted)
      return;
    if (!line || line === "}") {
      return;
    }
    const indexOfColon = line.indexOf(":");
    const indexAsStr = line.substring(2, indexOfColon - 1);
    const text = line.substring(indexOfColon + 1);
    opts.onSingle(Number(indexAsStr), parse(text));
  };
  await readLines(opts.readableStream, onLine, opts.textDecoder);
}
async function readLines(readableStream, onLine, textDecoder) {
  let partOfLine = "";
  const onChunk = (chunk) => {
    const chunkText = textDecoder.decode(chunk);
    const chunkLines = chunkText.split("\n");
    if (chunkLines.length === 1) {
      partOfLine += chunkLines[0];
    } else if (chunkLines.length > 1) {
      onLine(partOfLine + chunkLines[0]);
      for (let i2 = 1; i2 < chunkLines.length - 1; i2++) {
        onLine(chunkLines[i2]);
      }
      partOfLine = chunkLines[chunkLines.length - 1];
    }
  };
  if ("getReader" in readableStream) {
    await readStandardChunks(readableStream, onChunk);
  } else {
    await readNodeChunks(readableStream, onChunk);
  }
  onLine(partOfLine);
}
function readNodeChunks(stream, onChunk) {
  return new Promise((resolve) => {
    stream.on("data", onChunk);
    stream.on("end", resolve);
  });
}
async function readStandardChunks(stream, onChunk) {
  const reader = stream.getReader();
  let readResult = await reader.read();
  while (!readResult.done) {
    onChunk(readResult.value);
    readResult = await reader.read();
  }
}
var streamingJsonHttpRequester = (opts, onSingle) => {
  const ac = opts.AbortController ? new opts.AbortController() : null;
  const responsePromise = fetchHTTPResponse({
    ...opts,
    contentTypeHeader: "application/json",
    batchModeHeader: "stream",
    getUrl,
    getBody
  }, ac);
  const cancel = () => ac?.abort();
  const promise2 = responsePromise.then(async (res) => {
    if (!res.body)
      throw new Error("Received response without body");
    const meta = {
      response: res
    };
    return parseJSONStream({
      readableStream: res.body,
      onSingle,
      parse: (string) => ({
        json: JSON.parse(string),
        meta
      }),
      signal: ac?.signal,
      textDecoder: opts.textDecoder
    });
  });
  return {
    cancel,
    promise: promise2
  };
};
var streamRequester = (requesterOpts) => {
  const textDecoder = getTextDecoder(requesterOpts.opts.textDecoder);
  return (batchOps, unitResolver) => {
    const path2 = batchOps.map((op) => op.path).join(",");
    const inputs = batchOps.map((op) => op.input);
    const { cancel, promise: promise2 } = streamingJsonHttpRequester({
      ...requesterOpts,
      textDecoder,
      path: path2,
      inputs,
      headers() {
        if (!requesterOpts.opts.headers) {
          return {};
        }
        if (typeof requesterOpts.opts.headers === "function") {
          return requesterOpts.opts.headers({
            opList: batchOps
          });
        }
        return requesterOpts.opts.headers;
      }
    }, (index, res) => {
      unitResolver(index, res);
    });
    return {
      /**
      * return an empty array because the batchLoader expects an array of results
      * but we've already called the `unitResolver` for each of them, there's
      * nothing left to do here.
      */
      promise: promise2.then(() => []),
      cancel
    };
  };
};
var unstable_httpBatchStreamLink = createHTTPBatchLink(streamRequester);
var getBody2 = (opts) => {
  if (!("input" in opts)) {
    return void 0;
  }
  if (!(opts.input instanceof FormData)) {
    throw new Error("Input is not FormData");
  }
  return opts.input;
};
var formDataRequester = (opts) => {
  if (opts.type !== "mutation") {
    throw new Error("We only handle mutations with formdata");
  }
  return httpRequest({
    ...opts,
    getUrl() {
      return `${opts.url}/${opts.path}`;
    },
    getBody: getBody2
  });
};
var experimental_formDataLink = httpLinkFactory({
  requester: formDataRequester
});

// src/frontend/trpc.ts
var backendUrl = "http://" + window.location.hostname;
var wsClient = createWSClient({
  // * put ws instead of http on the url
  url: backendUrl.replace("https", "wss").replace("http", "ws") + ":4002/trpc",
  retryDelayMs: (attempt) => {
    if (attempt > 10) {
      return null;
    } else {
      return 1e3;
    }
  }
});
var trpc = createTRPCProxyClient({
  links: [
    splitLink({
      // * only use the web socket link if the operation is a subscription
      condition: (operation) => {
        return operation.type === "subscription";
      },
      true: wsLink({
        client: wsClient
        // * <- use the web socket client
      }),
      // * use the httpBatchLink for everything else (query, mutation)
      false: httpBatchLink({
        url: backendUrl + ":4001",
        async headers() {
          const token = localStorage.getItem("agent-token") ?? localStorage.getItem("user-token");
          return token ? {
            authorization: "Bearer " + token
          } : {};
        }
      })
    })
  ]
});

// src/frontend/game/game-state.ts
var GameState = {
  agent: {
    symbol: "",
    credits: 0
  },
  currentView: "universe",
  currentSystem: void 0,
  selected: void 0,
  systemShips: {},
  shipData: {},
  waypoints: {},
  systems: {},
  universeShips: {},
  displayedMarket: void 0,
  systemData: {},
  waypointData: {}
};

// src/frontend/game/makeInteractiveAndSelectable.ts
var import_events = __toESM(require_events());
var deselectListeners = new import_events.EventEmitter();
function makeInteractiveAndSelectable(item, options) {
  item.interactive = true;
  item.cursor = "pointer";
  item.on("mouseover", () => {
    item.filters = [];
    options?.onMouseOver?.();
  });
  const removeGlow = () => {
    item.filters = [];
  };
  item.on("mouseout", removeGlow);
  item.on("mouseout", () => {
    options?.onMouseOut?.();
  });
  if (options?.onOrder) {
    item.on("rightclick", async (event) => {
      event.stopPropagation();
      const allCommands = typeof options.onOrder == "function" ? await options.onOrder() : options.onOrder;
      const filteredCommands = allCommands.filter((c2) => {
        if (c2.withSelection && (!GameState.selected || GameState.selected.type !== c2.withSelection)) {
          return false;
        }
        return true;
      });
      const isCommandAvailable = await Promise.all(filteredCommands.map((c2) => {
        return c2.isAvailable ? c2.isAvailable() : true;
      }));
      const validCommands = filteredCommands.filter((c2, index) => {
        return isCommandAvailable[index];
      });
      if (validCommands.length == 0) {
      } else if (filteredCommands.length === 1) {
        filteredCommands[0].action(GameState.selected.symbol);
      } else {
        const background = new NineSlicePlane(loadedAssets.statsBlock);
        background.height = filteredCommands.length * 40;
        background.width = 180;
        item.addChild(background);
        deselectListeners.once("deselect", () => {
          item.removeChild(background);
        });
      }
    });
  }
  if (options?.onSelect) {
    item.on("click", (event) => {
      deselectListeners.emit("deselect");
      event.stopPropagation();
      deselectListeners.once("deselect", () => {
        removeGlow();
        GameState.selected = void 0;
        item.on("mouseout", removeGlow);
      });
      item.off("mouseout", removeGlow);
      GameState.selected = options.onSelect;
    });
  }
}

// src/frontend/game/consts.ts
var totalSize = 5e5;
var systemScale = 12;
var universeCoordinates = {
  minX: 0,
  minY: 0,
  maxX: 0,
  maxY: 0
};
var systemCoordinates = {
  minX: 0,
  minY: 0
};
var scale = {
  universe: 1
};
var gameWidth = window.innerWidth ?? 1920;
var gameHeight = window.innerHeight ?? 1080;

// ../pixi-viewport/dist/pixi_viewport.js
var u2 = class {
  /** @param {Viewport} parent */
  constructor(t2) {
    this.parent = t2, this.paused = false;
  }
  /** Called when plugin is removed */
  destroy() {
  }
  /** Handler for pointerdown PIXI event */
  down(t2) {
    return false;
  }
  /** Handler for pointermove PIXI event */
  move(t2) {
    return false;
  }
  /** Handler for pointerup PIXI event */
  up(t2) {
    return false;
  }
  /** Handler for wheel event on div */
  wheel(t2) {
    return false;
  }
  /**
   * Called on each tick
   * @param {number} elapsed time in millisecond since last update
   */
  update(t2) {
  }
  /** Called when the viewport is resized */
  resize() {
  }
  /** Called when the viewport is manually moved */
  reset() {
  }
  /** Pause the plugin */
  pause() {
    this.paused = true;
  }
  /** Un-pause the plugin */
  resume() {
    this.paused = false;
  }
};
var S2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function M2(l2) {
  return l2 && l2.__esModule && Object.prototype.hasOwnProperty.call(l2, "default") ? l2.default : l2;
}
var W = { exports: {} };
(function(l2, t2) {
  (function() {
    var e2, n2;
    n2 = function(i2) {
      return l2.exports = i2;
    }, e2 = {
      linear: function(i2, s2, h2, o2) {
        return h2 * i2 / o2 + s2;
      },
      easeInQuad: function(i2, s2, h2, o2) {
        return h2 * (i2 /= o2) * i2 + s2;
      },
      easeOutQuad: function(i2, s2, h2, o2) {
        return -h2 * (i2 /= o2) * (i2 - 2) + s2;
      },
      easeInOutQuad: function(i2, s2, h2, o2) {
        return (i2 /= o2 / 2) < 1 ? h2 / 2 * i2 * i2 + s2 : -h2 / 2 * (--i2 * (i2 - 2) - 1) + s2;
      },
      easeInCubic: function(i2, s2, h2, o2) {
        return h2 * (i2 /= o2) * i2 * i2 + s2;
      },
      easeOutCubic: function(i2, s2, h2, o2) {
        return h2 * ((i2 = i2 / o2 - 1) * i2 * i2 + 1) + s2;
      },
      easeInOutCubic: function(i2, s2, h2, o2) {
        return (i2 /= o2 / 2) < 1 ? h2 / 2 * i2 * i2 * i2 + s2 : h2 / 2 * ((i2 -= 2) * i2 * i2 + 2) + s2;
      },
      easeInQuart: function(i2, s2, h2, o2) {
        return h2 * (i2 /= o2) * i2 * i2 * i2 + s2;
      },
      easeOutQuart: function(i2, s2, h2, o2) {
        return -h2 * ((i2 = i2 / o2 - 1) * i2 * i2 * i2 - 1) + s2;
      },
      easeInOutQuart: function(i2, s2, h2, o2) {
        return (i2 /= o2 / 2) < 1 ? h2 / 2 * i2 * i2 * i2 * i2 + s2 : -h2 / 2 * ((i2 -= 2) * i2 * i2 * i2 - 2) + s2;
      },
      easeInQuint: function(i2, s2, h2, o2) {
        return h2 * (i2 /= o2) * i2 * i2 * i2 * i2 + s2;
      },
      easeOutQuint: function(i2, s2, h2, o2) {
        return h2 * ((i2 = i2 / o2 - 1) * i2 * i2 * i2 * i2 + 1) + s2;
      },
      easeInOutQuint: function(i2, s2, h2, o2) {
        return (i2 /= o2 / 2) < 1 ? h2 / 2 * i2 * i2 * i2 * i2 * i2 + s2 : h2 / 2 * ((i2 -= 2) * i2 * i2 * i2 * i2 + 2) + s2;
      },
      easeInSine: function(i2, s2, h2, o2) {
        return -h2 * Math.cos(i2 / o2 * (Math.PI / 2)) + h2 + s2;
      },
      easeOutSine: function(i2, s2, h2, o2) {
        return h2 * Math.sin(i2 / o2 * (Math.PI / 2)) + s2;
      },
      easeInOutSine: function(i2, s2, h2, o2) {
        return -h2 / 2 * (Math.cos(Math.PI * i2 / o2) - 1) + s2;
      },
      easeInExpo: function(i2, s2, h2, o2) {
        return i2 === 0 ? s2 : h2 * Math.pow(2, 10 * (i2 / o2 - 1)) + s2;
      },
      easeOutExpo: function(i2, s2, h2, o2) {
        return i2 === o2 ? s2 + h2 : h2 * (-Math.pow(2, -10 * i2 / o2) + 1) + s2;
      },
      easeInOutExpo: function(i2, s2, h2, o2) {
        return (i2 /= o2 / 2) < 1 ? h2 / 2 * Math.pow(2, 10 * (i2 - 1)) + s2 : h2 / 2 * (-Math.pow(2, -10 * --i2) + 2) + s2;
      },
      easeInCirc: function(i2, s2, h2, o2) {
        return -h2 * (Math.sqrt(1 - (i2 /= o2) * i2) - 1) + s2;
      },
      easeOutCirc: function(i2, s2, h2, o2) {
        return h2 * Math.sqrt(1 - (i2 = i2 / o2 - 1) * i2) + s2;
      },
      easeInOutCirc: function(i2, s2, h2, o2) {
        return (i2 /= o2 / 2) < 1 ? -h2 / 2 * (Math.sqrt(1 - i2 * i2) - 1) + s2 : h2 / 2 * (Math.sqrt(1 - (i2 -= 2) * i2) + 1) + s2;
      },
      easeInElastic: function(i2, s2, h2, o2) {
        var r2, a2, p2;
        return p2 = 1.70158, a2 = 0, r2 = h2, i2 === 0 || (i2 /= o2), a2 || (a2 = o2 * 0.3), r2 < Math.abs(h2) ? (r2 = h2, p2 = a2 / 4) : p2 = a2 / (2 * Math.PI) * Math.asin(h2 / r2), -(r2 * Math.pow(2, 10 * (i2 -= 1)) * Math.sin((i2 * o2 - p2) * (2 * Math.PI) / a2)) + s2;
      },
      easeOutElastic: function(i2, s2, h2, o2) {
        var r2, a2, p2;
        return p2 = 1.70158, a2 = 0, r2 = h2, i2 === 0 || (i2 /= o2), a2 || (a2 = o2 * 0.3), r2 < Math.abs(h2) ? (r2 = h2, p2 = a2 / 4) : p2 = a2 / (2 * Math.PI) * Math.asin(h2 / r2), r2 * Math.pow(2, -10 * i2) * Math.sin((i2 * o2 - p2) * (2 * Math.PI) / a2) + h2 + s2;
      },
      easeInOutElastic: function(i2, s2, h2, o2) {
        var r2, a2, p2;
        return p2 = 1.70158, a2 = 0, r2 = h2, i2 === 0 || (i2 /= o2 / 2), a2 || (a2 = o2 * (0.3 * 1.5)), r2 < Math.abs(h2) ? (r2 = h2, p2 = a2 / 4) : p2 = a2 / (2 * Math.PI) * Math.asin(h2 / r2), i2 < 1 ? -0.5 * (r2 * Math.pow(2, 10 * (i2 -= 1)) * Math.sin((i2 * o2 - p2) * (2 * Math.PI) / a2)) + s2 : r2 * Math.pow(2, -10 * (i2 -= 1)) * Math.sin((i2 * o2 - p2) * (2 * Math.PI) / a2) * 0.5 + h2 + s2;
      },
      easeInBack: function(i2, s2, h2, o2, r2) {
        return r2 === void 0 && (r2 = 1.70158), h2 * (i2 /= o2) * i2 * ((r2 + 1) * i2 - r2) + s2;
      },
      easeOutBack: function(i2, s2, h2, o2, r2) {
        return r2 === void 0 && (r2 = 1.70158), h2 * ((i2 = i2 / o2 - 1) * i2 * ((r2 + 1) * i2 + r2) + 1) + s2;
      },
      easeInOutBack: function(i2, s2, h2, o2, r2) {
        return r2 === void 0 && (r2 = 1.70158), (i2 /= o2 / 2) < 1 ? h2 / 2 * (i2 * i2 * (((r2 *= 1.525) + 1) * i2 - r2)) + s2 : h2 / 2 * ((i2 -= 2) * i2 * (((r2 *= 1.525) + 1) * i2 + r2) + 2) + s2;
      },
      easeInBounce: function(i2, s2, h2, o2) {
        var r2;
        return r2 = e2.easeOutBounce(o2 - i2, 0, h2, o2), h2 - r2 + s2;
      },
      easeOutBounce: function(i2, s2, h2, o2) {
        return (i2 /= o2) < 1 / 2.75 ? h2 * (7.5625 * i2 * i2) + s2 : i2 < 2 / 2.75 ? h2 * (7.5625 * (i2 -= 1.5 / 2.75) * i2 + 0.75) + s2 : i2 < 2.5 / 2.75 ? h2 * (7.5625 * (i2 -= 2.25 / 2.75) * i2 + 0.9375) + s2 : h2 * (7.5625 * (i2 -= 2.625 / 2.75) * i2 + 0.984375) + s2;
      },
      easeInOutBounce: function(i2, s2, h2, o2) {
        var r2;
        return i2 < o2 / 2 ? (r2 = e2.easeInBounce(i2 * 2, 0, h2, o2), r2 * 0.5 + s2) : (r2 = e2.easeOutBounce(i2 * 2 - o2, 0, h2, o2), r2 * 0.5 + h2 * 0.5 + s2);
      }
    }, n2(e2);
  }).call(S2);
})(W);
var O = W.exports;
var v2 = /* @__PURE__ */ M2(O);
function x2(l2, t2) {
  if (l2) {
    if (typeof l2 == "function")
      return l2;
    if (typeof l2 == "string")
      return v2[l2];
  } else
    return v2[t2];
}
var P = {
  removeOnInterrupt: false,
  ease: "linear",
  time: 1e3
};
var C = class extends u2 {
  /**
   * This is called by {@link Viewport.animate}.
   *
   * @param parent
   * @param options
   */
  constructor(t2, e2 = {}) {
    super(t2), this.startWidth = null, this.startHeight = null, this.deltaWidth = null, this.deltaHeight = null, this.width = null, this.height = null, this.time = 0, this.options = Object.assign({}, P, e2), this.options.ease = x2(this.options.ease), this.setupPosition(), this.setupZoom(), this.time = 0;
  }
  /**
   * Setup `startX`, `startY`, `deltaX`, `deltaY`, `keepCenter`.
   *
   * This is called during construction.
   */
  setupPosition() {
    typeof this.options.position < "u" ? (this.startX = this.parent.center.x, this.startY = this.parent.center.y, this.deltaX = this.options.position.x - this.parent.center.x, this.deltaY = this.options.position.y - this.parent.center.y, this.keepCenter = false) : this.keepCenter = true;
  }
  /**
   * Setup `startWidth, `startHeight`, `deltaWidth, `deltaHeight, `width`, `height`.
   *
   * This is called during construction.
   */
  setupZoom() {
    this.width = null, this.height = null, typeof this.options.scale < "u" ? this.width = this.parent.screenWidth / this.options.scale : typeof this.options.scaleX < "u" || typeof this.options.scaleY < "u" ? (typeof this.options.scaleX < "u" && (this.width = this.parent.screenWidth / this.options.scaleX), typeof this.options.scaleY < "u" && (this.height = this.parent.screenHeight / this.options.scaleY)) : (typeof this.options.width < "u" && (this.width = this.options.width), typeof this.options.height < "u" && (this.height = this.options.height)), this.width !== null && (this.startWidth = this.parent.screenWidthInWorldPixels, this.deltaWidth = this.width - this.startWidth), this.height !== null && (this.startHeight = this.parent.screenHeightInWorldPixels, this.deltaHeight = this.height - this.startHeight);
  }
  down() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("animate"), false;
  }
  complete() {
    this.parent.plugins.remove("animate"), this.width !== null && this.parent.fitWidth(this.width, this.keepCenter, this.height === null), this.height !== null && this.parent.fitHeight(this.height, this.keepCenter, this.width === null), !this.keepCenter && this.options.position && this.parent.moveCenter(this.options.position), this.parent.emit("animate-end", this.parent), this.options.callbackOnComplete && this.options.callbackOnComplete(this.parent);
  }
  update(t2) {
    if (this.paused)
      return;
    this.time += t2;
    const e2 = new Point(this.parent.scale.x, this.parent.scale.y);
    if (this.time >= this.options.time) {
      const n2 = this.parent.width, i2 = this.parent.height;
      this.complete(), (n2 !== this.parent.width || i2 !== this.parent.height) && this.parent.emit("zoomed", { viewport: this.parent, original: e2, type: "animate" });
    } else {
      const n2 = this.options.ease(this.time, 0, 1, this.options.time);
      if (this.width !== null) {
        const i2 = this.startWidth, s2 = this.deltaWidth;
        this.parent.fitWidth(
          i2 + s2 * n2,
          this.keepCenter,
          this.height === null
        );
      }
      if (this.height !== null) {
        const i2 = this.startHeight, s2 = this.deltaHeight;
        this.parent.fitHeight(
          i2 + s2 * n2,
          this.keepCenter,
          this.width === null
        );
      }
      if (this.width === null ? this.parent.scale.x = this.parent.scale.y : this.height === null && (this.parent.scale.y = this.parent.scale.x), !this.keepCenter) {
        const i2 = this.startX, s2 = this.startY, h2 = this.deltaX, o2 = this.deltaY, r2 = new Point(this.parent.x, this.parent.y);
        this.parent.moveCenter(i2 + h2 * n2, s2 + o2 * n2), this.parent.emit("moved", { viewport: this.parent, original: r2, type: "animate" });
      }
      (this.width || this.height) && this.parent.emit("zoomed", { viewport: this.parent, original: e2, type: "animate" });
    }
  }
};
var I = {
  sides: "all",
  friction: 0.5,
  time: 150,
  ease: "easeInOutSine",
  underflow: "center",
  bounceBox: null
};
var k2 = class extends u2 {
  /**
   * This is called by {@link Viewport.bounce}.
   */
  constructor(t2, e2 = {}) {
    super(t2), this.options = Object.assign({}, I, e2), this.ease = x2(this.options.ease, "easeInOutSine"), this.options.sides ? this.options.sides === "all" ? this.top = this.bottom = this.left = this.right = true : this.options.sides === "horizontal" ? (this.right = this.left = true, this.top = this.bottom = false) : this.options.sides === "vertical" ? (this.left = this.right = false, this.top = this.bottom = true) : (this.top = this.options.sides.indexOf("top") !== -1, this.bottom = this.options.sides.indexOf("bottom") !== -1, this.left = this.options.sides.indexOf("left") !== -1, this.right = this.options.sides.indexOf("right") !== -1) : this.left = this.top = this.right = this.bottom = false;
    const n2 = this.options.underflow.toLowerCase();
    n2 === "center" ? (this.underflowX = 0, this.underflowY = 0) : (this.underflowX = n2.indexOf("left") !== -1 ? -1 : n2.indexOf("right") !== -1 ? 1 : 0, this.underflowY = n2.indexOf("top") !== -1 ? -1 : n2.indexOf("bottom") !== -1 ? 1 : 0), this.reset();
  }
  isActive() {
    return this.toX !== null || this.toY !== null;
  }
  down() {
    return this.toX = this.toY = null, false;
  }
  up() {
    return this.bounce(), false;
  }
  update(t2) {
    if (!this.paused) {
      if (this.bounce(), this.toX) {
        const e2 = this.toX;
        e2.time += t2, this.parent.emit("moved", { viewport: this.parent, type: "bounce-x" }), e2.time >= this.options.time ? (this.parent.x = e2.end, this.toX = null, this.parent.emit("bounce-x-end", this.parent)) : this.parent.x = this.ease(e2.time, e2.start, e2.delta, this.options.time);
      }
      if (this.toY) {
        const e2 = this.toY;
        e2.time += t2, this.parent.emit("moved", { viewport: this.parent, type: "bounce-y" }), e2.time >= this.options.time ? (this.parent.y = e2.end, this.toY = null, this.parent.emit("bounce-y-end", this.parent)) : this.parent.y = this.ease(e2.time, e2.start, e2.delta, this.options.time);
      }
    }
  }
  /** @internal */
  calcUnderflowX() {
    let t2;
    switch (this.underflowX) {
      case -1:
        t2 = 0;
        break;
      case 1:
        t2 = this.parent.screenWidth - this.parent.screenWorldWidth;
        break;
      default:
        t2 = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
    }
    return t2;
  }
  /** @internal */
  calcUnderflowY() {
    let t2;
    switch (this.underflowY) {
      case -1:
        t2 = 0;
        break;
      case 1:
        t2 = this.parent.screenHeight - this.parent.screenWorldHeight;
        break;
      default:
        t2 = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
    }
    return t2;
  }
  oob() {
    const t2 = this.options.bounceBox;
    if (t2) {
      const e2 = typeof t2.x > "u" ? 0 : t2.x, n2 = typeof t2.y > "u" ? 0 : t2.y, i2 = typeof t2.width > "u" ? this.parent.worldWidth : t2.width, s2 = typeof t2.height > "u" ? this.parent.worldHeight : t2.height;
      return {
        left: this.parent.left < e2,
        right: this.parent.right > i2,
        top: this.parent.top < n2,
        bottom: this.parent.bottom > s2,
        topLeft: new Point(
          e2 * this.parent.scale.x,
          n2 * this.parent.scale.y
        ),
        bottomRight: new Point(
          i2 * this.parent.scale.x - this.parent.screenWidth,
          s2 * this.parent.scale.y - this.parent.screenHeight
        )
      };
    }
    return {
      left: this.parent.left < 0,
      right: this.parent.right > this.parent.worldWidth,
      top: this.parent.top < 0,
      bottom: this.parent.bottom > this.parent.worldHeight,
      topLeft: new Point(0, 0),
      bottomRight: new Point(
        this.parent.worldWidth * this.parent.scale.x - this.parent.screenWidth,
        this.parent.worldHeight * this.parent.scale.y - this.parent.screenHeight
      )
    };
  }
  bounce() {
    var s2, h2;
    if (this.paused)
      return;
    let t2, e2 = this.parent.plugins.get("decelerate", true);
    e2 && (e2.x || e2.y) && (e2.x && e2.percentChangeX === ((s2 = e2.options) == null ? void 0 : s2.friction) || e2.y && e2.percentChangeY === ((h2 = e2.options) == null ? void 0 : h2.friction)) && (t2 = this.oob(), (t2.left && this.left || t2.right && this.right) && (e2.percentChangeX = this.options.friction), (t2.top && this.top || t2.bottom && this.bottom) && (e2.percentChangeY = this.options.friction));
    const n2 = this.parent.plugins.get("drag", true) || {}, i2 = this.parent.plugins.get("pinch", true) || {};
    if (e2 = e2 || {}, !(n2 != null && n2.active) && !(i2 != null && i2.active) && (!this.toX || !this.toY) && (!e2.x || !e2.y)) {
      t2 = t2 || this.oob();
      const o2 = t2.topLeft, r2 = t2.bottomRight;
      if (!this.toX && !e2.x) {
        let a2 = null;
        t2.left && this.left ? a2 = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -o2.x : t2.right && this.right && (a2 = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -r2.x), a2 !== null && this.parent.x !== a2 && (this.toX = { time: 0, start: this.parent.x, delta: a2 - this.parent.x, end: a2 }, this.parent.emit("bounce-x-start", this.parent));
      }
      if (!this.toY && !e2.y) {
        let a2 = null;
        t2.top && this.top ? a2 = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -o2.y : t2.bottom && this.bottom && (a2 = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -r2.y), a2 !== null && this.parent.y !== a2 && (this.toY = { time: 0, start: this.parent.y, delta: a2 - this.parent.y, end: a2 }, this.parent.emit("bounce-y-start", this.parent));
      }
    }
  }
  reset() {
    this.toX = this.toY = null, this.bounce();
  }
};
var Y = {
  left: false,
  right: false,
  top: false,
  bottom: false,
  direction: null,
  underflow: "center"
};
var X = class extends u2 {
  /**
   * This is called by {@link Viewport.clamp}.
   */
  constructor(t2, e2 = {}) {
    super(t2), this.options = Object.assign({}, Y, e2), this.options.direction && (this.options.left = this.options.direction === "x" || this.options.direction === "all" ? true : null, this.options.right = this.options.direction === "x" || this.options.direction === "all" ? true : null, this.options.top = this.options.direction === "y" || this.options.direction === "all" ? true : null, this.options.bottom = this.options.direction === "y" || this.options.direction === "all" ? true : null), this.parseUnderflow(), this.last = { x: null, y: null, scaleX: null, scaleY: null }, this.update();
  }
  parseUnderflow() {
    const t2 = this.options.underflow.toLowerCase();
    t2 === "none" ? this.noUnderflow = true : t2 === "center" ? (this.underflowX = this.underflowY = 0, this.noUnderflow = false) : (this.underflowX = t2.indexOf("left") !== -1 ? -1 : t2.indexOf("right") !== -1 ? 1 : 0, this.underflowY = t2.indexOf("top") !== -1 ? -1 : t2.indexOf("bottom") !== -1 ? 1 : 0, this.noUnderflow = false);
  }
  move() {
    return this.update(), false;
  }
  update() {
    if (this.paused || this.parent.x === this.last.x && this.parent.y === this.last.y && this.parent.scale.x === this.last.scaleX && this.parent.scale.y === this.last.scaleY)
      return;
    const t2 = new Point(this.parent.x, this.parent.y), e2 = this.parent.plugins.decelerate || {};
    if (this.options.left !== null || this.options.right !== null) {
      let n2 = false;
      if (!this.noUnderflow && this.parent.screenWorldWidth < this.parent.screenWidth)
        switch (this.underflowX) {
          case -1:
            this.parent.x !== 0 && (this.parent.x = 0, n2 = true);
            break;
          case 1:
            this.parent.x !== this.parent.screenWidth - this.parent.screenWorldWidth && (this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth, n2 = true);
            break;
          default:
            this.parent.x !== (this.parent.screenWidth - this.parent.screenWorldWidth) / 2 && (this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2, n2 = true);
        }
      else
        this.options.left !== null && this.parent.left < (this.options.left === true ? 0 : this.options.left) && (this.parent.x = -(this.options.left === true ? 0 : this.options.left) * this.parent.scale.x, e2.x = 0, n2 = true), this.options.right !== null && this.parent.right > (this.options.right === true ? this.parent.worldWidth : this.options.right) && (this.parent.x = -(this.options.right === true ? this.parent.worldWidth : this.options.right) * this.parent.scale.x + this.parent.screenWidth, e2.x = 0, n2 = true);
      n2 && this.parent.emit("moved", { viewport: this.parent, original: t2, type: "clamp-x" });
    }
    if (this.options.top !== null || this.options.bottom !== null) {
      let n2 = false;
      if (!this.noUnderflow && this.parent.screenWorldHeight < this.parent.screenHeight)
        switch (this.underflowY) {
          case -1:
            this.parent.y !== 0 && (this.parent.y = 0, n2 = true);
            break;
          case 1:
            this.parent.y !== this.parent.screenHeight - this.parent.screenWorldHeight && (this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight, n2 = true);
            break;
          default:
            this.parent.y !== (this.parent.screenHeight - this.parent.screenWorldHeight) / 2 && (this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2, n2 = true);
        }
      else
        this.options.top !== null && this.parent.top < (this.options.top === true ? 0 : this.options.top) && (this.parent.y = -(this.options.top === true ? 0 : this.options.top) * this.parent.scale.y, e2.y = 0, n2 = true), this.options.bottom !== null && this.parent.bottom > (this.options.bottom === true ? this.parent.worldHeight : this.options.bottom) && (this.parent.y = -(this.options.bottom === true ? this.parent.worldHeight : this.options.bottom) * this.parent.scale.y + this.parent.screenHeight, e2.y = 0, n2 = true);
      n2 && this.parent.emit("moved", { viewport: this.parent, original: t2, type: "clamp-y" });
    }
    this.last.x = this.parent.x, this.last.y = this.parent.y, this.last.scaleX = this.parent.scale.x, this.last.scaleY = this.parent.scale.y;
  }
  reset() {
    this.update();
  }
};
var z = {
  minWidth: null,
  minHeight: null,
  maxWidth: null,
  maxHeight: null,
  minScale: null,
  maxScale: null
};
var A = class extends u2 {
  /**
   * This is called by {@link Viewport.clampZoom}.
   */
  constructor(t2, e2 = {}) {
    super(t2), this.options = Object.assign({}, z, e2), this.clamp();
  }
  resize() {
    this.clamp();
  }
  /** Clamp the viewport scale zoom) */
  clamp() {
    if (!this.paused) {
      if (this.options.minWidth || this.options.minHeight || this.options.maxWidth || this.options.maxHeight) {
        let t2 = this.parent.worldScreenWidth, e2 = this.parent.worldScreenHeight;
        if (this.options.minWidth !== null && t2 < this.options.minWidth) {
          const n2 = this.parent.scale.x;
          this.parent.fitWidth(this.options.minWidth, false, false, true), this.parent.scale.y *= this.parent.scale.x / n2, t2 = this.parent.worldScreenWidth, e2 = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.maxWidth !== null && t2 > this.options.maxWidth) {
          const n2 = this.parent.scale.x;
          this.parent.fitWidth(this.options.maxWidth, false, false, true), this.parent.scale.y *= this.parent.scale.x / n2, t2 = this.parent.worldScreenWidth, e2 = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.minHeight !== null && e2 < this.options.minHeight) {
          const n2 = this.parent.scale.y;
          this.parent.fitHeight(this.options.minHeight, false, false, true), this.parent.scale.x *= this.parent.scale.y / n2, t2 = this.parent.worldScreenWidth, e2 = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.maxHeight !== null && e2 > this.options.maxHeight) {
          const n2 = this.parent.scale.y;
          this.parent.fitHeight(this.options.maxHeight, false, false, true), this.parent.scale.x *= this.parent.scale.y / n2, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
      } else if (this.options.minScale || this.options.maxScale) {
        const t2 = { x: null, y: null }, e2 = { x: null, y: null };
        if (typeof this.options.minScale == "number")
          t2.x = this.options.minScale, t2.y = this.options.minScale;
        else if (this.options.minScale !== null) {
          const s2 = this.options.minScale;
          t2.x = typeof s2.x > "u" ? null : s2.x, t2.y = typeof s2.y > "u" ? null : s2.y;
        }
        if (typeof this.options.maxScale == "number")
          e2.x = this.options.maxScale, e2.y = this.options.maxScale;
        else if (this.options.maxScale !== null) {
          const s2 = this.options.maxScale;
          e2.x = typeof s2.x > "u" ? null : s2.x, e2.y = typeof s2.y > "u" ? null : s2.y;
        }
        let n2 = this.parent.scale.x, i2 = this.parent.scale.y;
        t2.x !== null && n2 < t2.x && (n2 = t2.x), e2.x !== null && n2 > e2.x && (n2 = e2.x), t2.y !== null && i2 < t2.y && (i2 = t2.y), e2.y !== null && i2 > e2.y && (i2 = e2.y), (n2 !== this.parent.scale.x || i2 !== this.parent.scale.y) && (this.parent.scale.set(n2, i2), this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" }));
      }
    }
  }
  reset() {
    this.clamp();
  }
};
var _ = {
  friction: 0.98,
  bounce: 0.8,
  minSpeed: 0.01
};
var d2 = 16;
var T = class extends u2 {
  /**
   * This is called by {@link Viewport.decelerate}.
   */
  constructor(t2, e2 = {}) {
    super(t2), this.options = Object.assign({}, _, e2), this.saved = [], this.timeSinceRelease = 0, this.reset(), this.parent.on("moved", (n2) => this.handleMoved(n2));
  }
  down() {
    return this.saved = [], this.x = this.y = null, false;
  }
  isActive() {
    return !!(this.x || this.y);
  }
  move() {
    if (this.paused)
      return false;
    const t2 = this.parent.input.count();
    return (t2 === 1 || t2 > 1 && !this.parent.plugins.get("pinch", true)) && (this.saved.push({ x: this.parent.x, y: this.parent.y, time: performance.now() }), this.saved.length > 60 && this.saved.splice(0, 30)), false;
  }
  /** Listener to viewport's "moved" event. */
  handleMoved(t2) {
    if (this.saved.length) {
      const e2 = this.saved[this.saved.length - 1];
      t2.type === "clamp-x" && t2.original ? e2.x === t2.original.x && (e2.x = this.parent.x) : t2.type === "clamp-y" && t2.original && e2.y === t2.original.y && (e2.y = this.parent.y);
    }
  }
  up() {
    if (this.parent.input.count() === 0 && this.saved.length) {
      const t2 = performance.now();
      for (const e2 of this.saved)
        if (e2.time >= t2 - 100) {
          const n2 = t2 - e2.time;
          this.x = (this.parent.x - e2.x) / n2, this.y = (this.parent.y - e2.y) / n2, this.percentChangeX = this.percentChangeY = this.options.friction, this.timeSinceRelease = 0;
          break;
        }
    }
    return false;
  }
  /**
   * Manually activate deceleration, starting from the (x, y) velocity components passed in the options.
   *
   * @param {object} options
   * @param {number} [options.x] - Specify x-component of initial velocity.
   * @param {number} [options.y] - Specify y-component of initial velocity.
   */
  activate(t2) {
    t2 = t2 || {}, typeof t2.x < "u" && (this.x = t2.x, this.percentChangeX = this.options.friction), typeof t2.y < "u" && (this.y = t2.y, this.percentChangeY = this.options.friction);
  }
  update(t2) {
    if (this.paused)
      return;
    const e2 = this.x || this.y, n2 = this.timeSinceRelease, i2 = this.timeSinceRelease + t2;
    if (this.x) {
      const s2 = this.percentChangeX, h2 = Math.log(s2);
      this.parent.x += this.x * d2 / h2 * (Math.pow(s2, i2 / d2) - Math.pow(s2, n2 / d2)), this.x *= Math.pow(this.percentChangeX, t2 / d2);
    }
    if (this.y) {
      const s2 = this.percentChangeY, h2 = Math.log(s2);
      this.parent.y += this.y * d2 / h2 * (Math.pow(s2, i2 / d2) - Math.pow(s2, n2 / d2)), this.y *= Math.pow(this.percentChangeY, t2 / d2);
    }
    this.timeSinceRelease += t2, this.x && this.y ? Math.abs(this.x) < this.options.minSpeed && Math.abs(this.y) < this.options.minSpeed && (this.x = 0, this.y = 0) : (Math.abs(this.x || 0) < this.options.minSpeed && (this.x = 0), Math.abs(this.y || 0) < this.options.minSpeed && (this.y = 0)), e2 && this.parent.emit("moved", { viewport: this.parent, type: "decelerate" });
  }
  reset() {
    this.x = this.y = null;
  }
};
var E = {
  direction: "all",
  pressDrag: true,
  wheel: true,
  wheelScroll: 1,
  reverse: false,
  clampWheel: false,
  underflow: "center",
  factor: 1,
  mouseButtons: "all",
  keyToPress: null,
  ignoreKeyToPressOnTouch: false,
  lineHeight: 20,
  wheelSwapAxes: false
};
var D = class extends u2 {
  /**
   * This is called by {@link Viewport.drag}.
   */
  constructor(t2, e2 = {}) {
    super(t2), this.windowEventHandlers = [], this.options = Object.assign({}, E, e2), this.moved = false, this.reverse = this.options.reverse ? 1 : -1, this.xDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "x", this.yDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "y", this.keyIsPressed = false, this.parseUnderflow(), this.mouseButtons(this.options.mouseButtons), this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress);
  }
  /**
   * Handles keypress events and set the keyIsPressed boolean accordingly
   *
   * @param {array} codes - key codes that can be used to trigger drag event
   */
  handleKeyPresses(t2) {
    const e2 = (i2) => {
      t2.includes(i2.code) && (this.keyIsPressed = true);
    }, n2 = (i2) => {
      t2.includes(i2.code) && (this.keyIsPressed = false);
    };
    this.addWindowEventHandler("keyup", n2), this.addWindowEventHandler("keydown", e2);
  }
  addWindowEventHandler(t2, e2) {
    typeof window > "u" || (window.addEventListener(t2, e2), this.windowEventHandlers.push({ event: t2, handler: e2 }));
  }
  destroy() {
    typeof window > "u" || this.windowEventHandlers.forEach(({ event: t2, handler: e2 }) => {
      window.removeEventListener(t2, e2);
    });
  }
  /**
   * initialize mousebuttons array
   * @param {string} buttons
   */
  mouseButtons(t2) {
    !t2 || t2 === "all" ? this.mouse = [true, true, true] : this.mouse = [
      t2.indexOf("left") !== -1,
      t2.indexOf("middle") !== -1,
      t2.indexOf("right") !== -1
    ];
  }
  parseUnderflow() {
    const t2 = this.options.underflow.toLowerCase();
    t2 === "center" ? (this.underflowX = 0, this.underflowY = 0) : (t2.includes("left") ? this.underflowX = -1 : t2.includes("right") ? this.underflowX = 1 : this.underflowX = 0, t2.includes("top") ? this.underflowY = -1 : t2.includes("bottom") ? this.underflowY = 1 : this.underflowY = 0);
  }
  /**
   * @param {PIXI.FederatedPointerEvent} event
   * @returns {boolean}
   */
  checkButtons(t2) {
    const e2 = t2.pointerType === "mouse", n2 = this.parent.input.count();
    return !!((n2 === 1 || n2 > 1 && !this.parent.plugins.get("pinch", true)) && (!e2 || this.mouse[t2.button]));
  }
  /**
   * @param {PIXI.FederatedPointerEvent} event
   * @returns {boolean}
   */
  checkKeyPress(t2) {
    return !this.options.keyToPress || this.keyIsPressed || this.options.ignoreKeyToPressOnTouch && t2.data.pointerType === "touch";
  }
  down(t2) {
    return this.paused || !this.options.pressDrag ? false : this.checkButtons(t2) && this.checkKeyPress(t2) ? (this.last = { x: t2.global.x, y: t2.global.y }, this.current = t2.pointerId, true) : (this.last = null, false);
  }
  get active() {
    return this.moved;
  }
  move(t2) {
    if (this.paused || !this.options.pressDrag)
      return false;
    if (this.last && this.current === t2.data.pointerId) {
      const e2 = t2.global.x, n2 = t2.global.y, i2 = this.parent.input.count();
      if (i2 === 1 || i2 > 1 && !this.parent.plugins.get("pinch", true)) {
        const s2 = e2 - this.last.x, h2 = n2 - this.last.y;
        if (this.moved || this.xDirection && this.parent.input.checkThreshold(s2) || this.yDirection && this.parent.input.checkThreshold(h2)) {
          const o2 = { x: e2, y: n2 };
          return this.xDirection && (this.parent.x += (o2.x - this.last.x) * this.options.factor), this.yDirection && (this.parent.y += (o2.y - this.last.y) * this.options.factor), this.last = o2, this.moved || this.parent.emit("drag-start", {
            event: t2,
            screen: new Point(this.last.x, this.last.y),
            world: this.parent.toWorld(new Point(this.last.x, this.last.y)),
            viewport: this.parent
          }), this.moved = true, this.parent.emit("moved", { viewport: this.parent, type: "drag" }), true;
        }
      } else
        this.moved = false;
    }
    return false;
  }
  up(t2) {
    if (this.paused)
      return false;
    const e2 = this.parent.input.touches;
    if (e2.length === 1) {
      const n2 = e2[0];
      return n2.last && (this.last = { x: n2.last.x, y: n2.last.y }, this.current = n2.id), this.moved = false, true;
    } else if (this.last && this.moved) {
      const n2 = new Point(this.last.x, this.last.y);
      return this.parent.emit("drag-end", {
        event: t2,
        screen: n2,
        world: this.parent.toWorld(n2),
        viewport: this.parent
      }), this.last = null, this.moved = false, true;
    }
    return false;
  }
  wheel(t2) {
    if (this.paused)
      return false;
    if (this.options.wheel) {
      const e2 = this.parent.plugins.get("wheel", true);
      if (!e2 || !e2.options.wheelZoom && !t2.ctrlKey) {
        const n2 = t2.deltaMode ? this.options.lineHeight : 1, i2 = [t2.deltaX, t2.deltaY], [s2, h2] = this.options.wheelSwapAxes ? i2.reverse() : i2;
        return this.xDirection && (this.parent.x += s2 * n2 * this.options.wheelScroll * this.reverse), this.yDirection && (this.parent.y += h2 * n2 * this.options.wheelScroll * this.reverse), this.options.clampWheel && this.clamp(), this.parent.emit("wheel-scroll", this.parent), this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.options.passiveWheel || t2.preventDefault(), this.parent.options.stopPropagation && t2.stopPropagation(), true;
      }
    }
    return false;
  }
  resume() {
    this.last = null, this.paused = false;
  }
  clamp() {
    const t2 = this.parent.plugins.get("decelerate", true) || {};
    if (this.options.clampWheel !== "y")
      if (this.parent.screenWorldWidth < this.parent.screenWidth)
        switch (this.underflowX) {
          case -1:
            this.parent.x = 0;
            break;
          case 1:
            this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth;
            break;
          default:
            this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
        }
      else
        this.parent.left < 0 ? (this.parent.x = 0, t2.x = 0) : this.parent.right > this.parent.worldWidth && (this.parent.x = -this.parent.worldWidth * this.parent.scale.x + this.parent.screenWidth, t2.x = 0);
    if (this.options.clampWheel !== "x")
      if (this.parent.screenWorldHeight < this.parent.screenHeight)
        switch (this.underflowY) {
          case -1:
            this.parent.y = 0;
            break;
          case 1:
            this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight;
            break;
          default:
            this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
        }
      else
        this.parent.top < 0 && (this.parent.y = 0, t2.y = 0), this.parent.bottom > this.parent.worldHeight && (this.parent.y = -this.parent.worldHeight * this.parent.scale.y + this.parent.screenHeight, t2.y = 0);
  }
};
var L = {
  speed: 0,
  acceleration: null,
  radius: null
};
var U = class extends u2 {
  /**
   * This is called by {@link Viewport.follow}.
   *
   * @param parent
   * @param target - target to follow
   * @param options
   */
  constructor(t2, e2, n2 = {}) {
    super(t2), this.target = e2, this.options = Object.assign({}, L, n2), this.velocity = { x: 0, y: 0 };
  }
  update(t2) {
    if (this.paused)
      return;
    const e2 = this.parent.center;
    let n2 = this.target.x, i2 = this.target.y;
    if (this.options.radius)
      if (Math.sqrt(Math.pow(this.target.y - e2.y, 2) + Math.pow(this.target.x - e2.x, 2)) > this.options.radius) {
        const r2 = Math.atan2(this.target.y - e2.y, this.target.x - e2.x);
        n2 = this.target.x - Math.cos(r2) * this.options.radius, i2 = this.target.y - Math.sin(r2) * this.options.radius;
      } else
        return;
    const s2 = n2 - e2.x, h2 = i2 - e2.y;
    if (s2 || h2)
      if (this.options.speed)
        if (this.options.acceleration) {
          const o2 = Math.atan2(i2 - e2.y, n2 - e2.x), r2 = Math.sqrt(Math.pow(s2, 2) + Math.pow(h2, 2));
          if (r2) {
            const a2 = (Math.pow(this.velocity.x, 2) + Math.pow(this.velocity.y, 2)) / (2 * this.options.acceleration);
            r2 > a2 ? this.velocity = {
              x: Math.min(this.velocity.x + (this.options.acceleration * t2, this.options.speed)),
              y: Math.min(this.velocity.y + (this.options.acceleration * t2, this.options.speed))
            } : this.velocity = {
              x: Math.max(this.velocity.x - this.options.acceleration * this.options.speed, 0),
              y: Math.max(this.velocity.y - this.options.acceleration * this.options.speed, 0)
            };
            const p2 = Math.cos(o2) * this.velocity.x, f2 = Math.sin(o2) * this.velocity.y, g2 = Math.abs(p2) > Math.abs(s2) ? n2 : e2.x + p2, w2 = Math.abs(f2) > Math.abs(h2) ? i2 : e2.y + f2;
            this.parent.moveCenter(g2, w2), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
          }
        } else {
          const o2 = Math.atan2(i2 - e2.y, n2 - e2.x), r2 = Math.cos(o2) * this.options.speed, a2 = Math.sin(o2) * this.options.speed, p2 = Math.abs(r2) > Math.abs(s2) ? n2 : e2.x + r2, f2 = Math.abs(a2) > Math.abs(h2) ? i2 : e2.y + a2;
          this.parent.moveCenter(p2, f2), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
        }
      else
        this.parent.moveCenter(n2, i2), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
  }
};
var F = {
  radius: null,
  distance: null,
  top: null,
  bottom: null,
  left: null,
  right: null,
  speed: 8,
  reverse: false,
  noDecelerate: false,
  linear: false,
  allowButtons: false
};
var B = class extends u2 {
  /**
   * This is called by {@link Viewport.mouseEdges}.
   */
  constructor(t2, e2 = {}) {
    super(t2), this.options = Object.assign({}, F, e2), this.reverse = this.options.reverse ? 1 : -1, this.radiusSquared = typeof this.options.radius == "number" ? Math.pow(this.options.radius, 2) : null, this.resize();
  }
  resize() {
    const t2 = this.options.distance;
    t2 !== null ? (this.left = t2, this.top = t2, this.right = this.parent.screenWidth - t2, this.bottom = this.parent.screenHeight - t2) : this.options.radius || (this.left = this.options.left, this.top = this.options.top, this.right = this.options.right === null ? null : this.parent.screenWidth - this.options.right, this.bottom = this.options.bottom === null ? null : this.parent.screenHeight - this.options.bottom);
  }
  down() {
    return this.paused || this.options.allowButtons || (this.horizontal = this.vertical = null), false;
  }
  move(t2) {
    if (this.paused || t2.pointerType !== "mouse" && t2.pointerId !== 1 || !this.options.allowButtons && t2.buttons !== 0)
      return false;
    const e2 = t2.global.x, n2 = t2.global.y;
    if (this.radiusSquared) {
      const i2 = this.parent.toScreen(this.parent.center);
      if (Math.pow(i2.x - e2, 2) + Math.pow(i2.y - n2, 2) >= this.radiusSquared) {
        const h2 = Math.atan2(i2.y - n2, i2.x - e2);
        this.options.linear ? (this.horizontal = Math.round(Math.cos(h2)) * this.options.speed * this.reverse * (60 / 1e3), this.vertical = Math.round(Math.sin(h2)) * this.options.speed * this.reverse * (60 / 1e3)) : (this.horizontal = Math.cos(h2) * this.options.speed * this.reverse * (60 / 1e3), this.vertical = Math.sin(h2) * this.options.speed * this.reverse * (60 / 1e3));
      } else
        this.horizontal && this.decelerateHorizontal(), this.vertical && this.decelerateVertical(), this.horizontal = this.vertical = 0;
    } else
      this.left !== null && e2 < this.left ? this.horizontal = Number(this.reverse) * this.options.speed * (60 / 1e3) : this.right !== null && e2 > this.right ? this.horizontal = -1 * this.reverse * this.options.speed * (60 / 1e3) : (this.decelerateHorizontal(), this.horizontal = 0), this.top !== null && n2 < this.top ? this.vertical = Number(this.reverse) * this.options.speed * (60 / 1e3) : this.bottom !== null && n2 > this.bottom ? this.vertical = -1 * this.reverse * this.options.speed * (60 / 1e3) : (this.decelerateVertical(), this.vertical = 0);
    return false;
  }
  decelerateHorizontal() {
    const t2 = this.parent.plugins.get("decelerate", true);
    this.horizontal && t2 && !this.options.noDecelerate && t2.activate({ x: this.horizontal * this.options.speed * this.reverse / (1e3 / 60) });
  }
  decelerateVertical() {
    const t2 = this.parent.plugins.get("decelerate", true);
    this.vertical && t2 && !this.options.noDecelerate && t2.activate({ y: this.vertical * this.options.speed * this.reverse / (1e3 / 60) });
  }
  up() {
    return this.paused || (this.horizontal && this.decelerateHorizontal(), this.vertical && this.decelerateVertical(), this.horizontal = this.vertical = null), false;
  }
  update() {
    if (!this.paused && (this.horizontal || this.vertical)) {
      const t2 = this.parent.center;
      this.horizontal && (t2.x += this.horizontal * this.options.speed), this.vertical && (t2.y += this.vertical * this.options.speed), this.parent.moveCenter(t2), this.parent.emit("moved", { viewport: this.parent, type: "mouse-edges" });
    }
  }
};
var V = {
  noDrag: false,
  percent: 1,
  center: null,
  factor: 1,
  axis: "all"
};
var N2 = class extends u2 {
  /**
   * This is called by {@link Viewport.pinch}.
   */
  constructor(t2, e2 = {}) {
    super(t2), this.active = false, this.pinching = false, this.moved = false, this.options = Object.assign({}, V, e2);
  }
  down() {
    return this.parent.input.count() >= 2 ? (this.active = true, true) : false;
  }
  isAxisX() {
    return ["all", "x"].includes(this.options.axis);
  }
  isAxisY() {
    return ["all", "y"].includes(this.options.axis);
  }
  move(t2) {
    if (this.paused || !this.active)
      return false;
    const e2 = t2.global.x, n2 = t2.global.y, i2 = this.parent.input.touches;
    if (i2.length >= 2) {
      const s2 = i2[0], h2 = i2[1], o2 = s2.last && h2.last ? Math.sqrt(Math.pow(h2.last.x - s2.last.x, 2) + Math.pow(h2.last.y - s2.last.y, 2)) : null;
      if (s2.id === t2.pointerId ? s2.last = { x: e2, y: n2, data: t2 } : h2.id === t2.pointerId && (h2.last = { x: e2, y: n2, data: t2 }), o2) {
        let r2;
        const a2 = new Point(
          s2.last.x + (h2.last.x - s2.last.x) / 2,
          s2.last.y + (h2.last.y - s2.last.y) / 2
        );
        this.options.center || (r2 = this.parent.toLocal(a2));
        let p2 = Math.sqrt(Math.pow(
          h2.last.x - s2.last.x,
          2
        ) + Math.pow(h2.last.y - s2.last.y, 2));
        p2 = p2 === 0 ? p2 = 1e-10 : p2;
        const f2 = (1 - o2 / p2) * this.options.percent * (this.isAxisX() ? this.parent.scale.x : this.parent.scale.y);
        this.isAxisX() && (this.parent.scale.x += f2), this.isAxisY() && (this.parent.scale.y += f2), this.parent.emit("zoomed", { viewport: this.parent, type: "pinch", center: a2 });
        const g2 = this.parent.plugins.get("clamp-zoom", true);
        if (g2 && g2.clamp(), this.options.center)
          this.parent.moveCenter(this.options.center);
        else {
          const w2 = this.parent.toGlobal(r2);
          this.parent.x += (a2.x - w2.x) * this.options.factor, this.parent.y += (a2.y - w2.y) * this.options.factor, this.parent.emit("moved", { viewport: this.parent, type: "pinch" });
        }
        !this.options.noDrag && this.lastCenter && (this.parent.x += (a2.x - this.lastCenter.x) * this.options.factor, this.parent.y += (a2.y - this.lastCenter.y) * this.options.factor, this.parent.emit("moved", { viewport: this.parent, type: "pinch" })), this.lastCenter = a2, this.moved = true;
      } else
        this.pinching || (this.parent.emit("pinch-start", this.parent), this.pinching = true);
      return true;
    }
    return false;
  }
  up() {
    return this.pinching && this.parent.input.touches.length <= 1 ? (this.active = false, this.lastCenter = null, this.pinching = false, this.moved = false, this.parent.emit("pinch-end", this.parent), true) : false;
  }
};
var Z = {
  topLeft: false,
  friction: 0.8,
  time: 1e3,
  ease: "easeInOutSine",
  interrupt: true,
  removeOnComplete: false,
  removeOnInterrupt: false,
  forceStart: false
};
var j2 = class extends u2 {
  /**
   * This is called by {@link Viewport.snap}.
   */
  constructor(t2, e2, n2, i2 = {}) {
    super(t2), this.options = Object.assign({}, Z, i2), this.ease = x2(i2.ease, "easeInOutSine"), this.x = e2, this.y = n2, this.options.forceStart && this.snapStart();
  }
  snapStart() {
    this.percent = 0, this.snapping = { time: 0 };
    const t2 = this.options.topLeft ? this.parent.corner : this.parent.center;
    this.deltaX = this.x - t2.x, this.deltaY = this.y - t2.y, this.startX = t2.x, this.startY = t2.y, this.parent.emit("snap-start", this.parent);
  }
  wheel() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("snap"), false;
  }
  down() {
    return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap") : this.options.interrupt && (this.snapping = null), false;
  }
  up() {
    if (this.parent.input.count() === 0) {
      const t2 = this.parent.plugins.get("decelerate", true);
      t2 && (t2.x || t2.y) && (t2.percentChangeX = t2.percentChangeY = this.options.friction);
    }
    return false;
  }
  update(t2) {
    if (!this.paused && !(this.options.interrupt && this.parent.input.count() !== 0))
      if (this.snapping) {
        const e2 = this.snapping;
        e2.time += t2;
        let n2, i2, s2;
        const h2 = this.startX, o2 = this.startY, r2 = this.deltaX, a2 = this.deltaY;
        if (e2.time > this.options.time)
          n2 = true, i2 = h2 + r2, s2 = o2 + a2;
        else {
          const p2 = this.ease(e2.time, 0, 1, this.options.time);
          i2 = h2 + r2 * p2, s2 = o2 + a2 * p2;
        }
        this.options.topLeft ? this.parent.moveCorner(i2, s2) : this.parent.moveCenter(i2, s2), this.parent.emit("moved", { viewport: this.parent, type: "snap" }), n2 && (this.options.removeOnComplete && this.parent.plugins.remove("snap"), this.parent.emit("snap-end", this.parent), this.snapping = null);
      } else {
        const e2 = this.options.topLeft ? this.parent.corner : this.parent.center;
        (e2.x !== this.x || e2.y !== this.y) && this.snapStart();
      }
  }
};
var R = {
  width: 0,
  height: 0,
  time: 1e3,
  ease: "easeInOutSine",
  center: null,
  interrupt: true,
  removeOnComplete: false,
  removeOnInterrupt: false,
  forceStart: false,
  noMove: false
};
var K = class extends u2 {
  /**
   * This is called by {@link Viewport.snapZoom}.
   */
  constructor(t2, e2 = {}) {
    super(t2), this.options = Object.assign({}, R, e2), this.ease = x2(this.options.ease), this.xIndependent = false, this.yIndependent = false, this.xScale = 0, this.yScale = 0, this.options.width > 0 && (this.xScale = t2.screenWidth / this.options.width, this.xIndependent = true), this.options.height > 0 && (this.yScale = t2.screenHeight / this.options.height, this.yIndependent = true), this.xScale = this.xIndependent ? this.xScale : this.yScale, this.yScale = this.yIndependent ? this.yScale : this.xScale, this.options.time === 0 ? (t2.container.scale.x = this.xScale, t2.container.scale.y = this.yScale, this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom")) : e2.forceStart && this.createSnapping();
  }
  createSnapping() {
    const t2 = this.parent.worldScreenWidth, e2 = this.parent.worldScreenHeight, n2 = this.parent.screenWidth / this.xScale, i2 = this.parent.screenHeight / this.yScale;
    this.snapping = {
      time: 0,
      startX: t2,
      startY: e2,
      deltaX: n2 - t2,
      deltaY: i2 - e2
    }, this.parent.emit("snap-zoom-start", this.parent);
  }
  resize() {
    this.snapping = null, this.options.width > 0 && (this.xScale = this.parent.screenWidth / this.options.width), this.options.height > 0 && (this.yScale = this.parent.screenHeight / this.options.height), this.xScale = this.xIndependent ? this.xScale : this.yScale, this.yScale = this.yIndependent ? this.yScale : this.xScale;
  }
  wheel() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("snap-zoom"), false;
  }
  down() {
    return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap-zoom") : this.options.interrupt && (this.snapping = null), false;
  }
  update(t2) {
    if (this.paused || this.options.interrupt && this.parent.input.count() !== 0)
      return;
    let e2;
    if (!this.options.center && !this.options.noMove && (e2 = this.parent.center), !this.snapping)
      (this.parent.scale.x !== this.xScale || this.parent.scale.y !== this.yScale) && this.createSnapping();
    else if (this.snapping) {
      const n2 = this.snapping;
      if (n2.time += t2, n2.time >= this.options.time)
        this.parent.scale.set(this.xScale, this.yScale), this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom"), this.parent.emit("snap-zoom-end", this.parent), this.snapping = null;
      else {
        const s2 = this.snapping, h2 = this.ease(s2.time, s2.startX, s2.deltaX, this.options.time), o2 = this.ease(s2.time, s2.startY, s2.deltaY, this.options.time);
        this.parent.scale.x = this.parent.screenWidth / h2, this.parent.scale.y = this.parent.screenHeight / o2;
      }
      const i2 = this.parent.plugins.get("clamp-zoom", true);
      i2 && i2.clamp(), this.options.noMove || (this.options.center ? this.parent.moveCenter(this.options.center) : this.parent.moveCenter(e2));
    }
  }
  resume() {
    this.snapping = null, super.resume();
  }
};
var q = {
  percent: 0.1,
  smooth: false,
  interrupt: true,
  reverse: false,
  center: null,
  lineHeight: 20,
  axis: "all",
  keyToPress: null,
  trackpadPinch: false,
  wheelZoom: true
};
var G = class extends u2 {
  /**
   * This is called by {@link Viewport.wheel}.
   */
  constructor(t2, e2 = {}) {
    super(t2), this.options = Object.assign({}, q, e2), this.keyIsPressed = false, this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress);
  }
  /**
   * Handles keypress events and set the keyIsPressed boolean accordingly
   *
   * @param {array} codes - key codes that can be used to trigger zoom event
   */
  handleKeyPresses(t2) {
    typeof window > "u" || (window.addEventListener("keydown", (e2) => {
      t2.includes(e2.code) && (this.keyIsPressed = true);
    }), window.addEventListener("keyup", (e2) => {
      t2.includes(e2.code) && (this.keyIsPressed = false);
    }));
  }
  checkKeyPress() {
    return !this.options.keyToPress || this.keyIsPressed;
  }
  down() {
    return this.options.interrupt && (this.smoothing = null), false;
  }
  isAxisX() {
    return ["all", "x"].includes(this.options.axis);
  }
  isAxisY() {
    return ["all", "y"].includes(this.options.axis);
  }
  update() {
    if (this.smoothing) {
      const t2 = this.smoothingCenter, e2 = this.smoothing;
      let n2;
      this.options.center || (n2 = this.parent.toLocal(t2)), this.isAxisX() && (this.parent.scale.x += e2.x), this.isAxisY() && (this.parent.scale.y += e2.y), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
      const i2 = this.parent.plugins.get("clamp-zoom", true);
      if (i2 && i2.clamp(), this.options.center)
        this.parent.moveCenter(this.options.center);
      else {
        const s2 = this.parent.toGlobal(n2);
        this.parent.x += t2.x - s2.x, this.parent.y += t2.y - s2.y;
      }
      this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.smoothingCount++, this.smoothingCount >= this.options.smooth && (this.smoothing = null);
    }
  }
  pinch(t2) {
    if (this.paused)
      return;
    const e2 = this.parent.input.getPointerPosition(t2), n2 = -t2.deltaY * (t2.deltaMode ? this.options.lineHeight : 1) / 200, i2 = Math.pow(2, (1 + this.options.percent) * n2);
    let s2;
    this.options.center || (s2 = this.parent.toLocal(e2)), this.isAxisX() && (this.parent.scale.x *= i2), this.isAxisY() && (this.parent.scale.y *= i2), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
    const h2 = this.parent.plugins.get("clamp-zoom", true);
    if (h2 && h2.clamp(), this.options.center)
      this.parent.moveCenter(this.options.center);
    else {
      const o2 = this.parent.toGlobal(s2);
      this.parent.x += e2.x - o2.x, this.parent.y += e2.y - o2.y;
    }
    this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.emit(
      "wheel-start",
      { event: t2, viewport: this.parent }
    );
  }
  wheel(t2) {
    if (this.paused || !this.checkKeyPress())
      return false;
    if (t2.ctrlKey && this.options.trackpadPinch)
      this.pinch(t2);
    else if (this.options.wheelZoom) {
      const e2 = this.parent.input.getPointerPosition(t2), i2 = (this.options.reverse ? -1 : 1) * -t2.deltaY * (t2.deltaMode ? this.options.lineHeight : 1) / 500, s2 = Math.pow(2, (1 + this.options.percent) * i2);
      if (this.options.smooth) {
        const h2 = {
          x: this.smoothing ? this.smoothing.x * (this.options.smooth - this.smoothingCount) : 0,
          y: this.smoothing ? this.smoothing.y * (this.options.smooth - this.smoothingCount) : 0
        };
        this.smoothing = {
          x: ((this.parent.scale.x + h2.x) * s2 - this.parent.scale.x) / this.options.smooth,
          y: ((this.parent.scale.y + h2.y) * s2 - this.parent.scale.y) / this.options.smooth
        }, this.smoothingCount = 0, this.smoothingCenter = e2;
      } else {
        let h2;
        this.options.center || (h2 = this.parent.toLocal(e2)), this.isAxisX() && (this.parent.scale.x *= s2), this.isAxisY() && (this.parent.scale.y *= s2), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
        const o2 = this.parent.plugins.get("clamp-zoom", true);
        if (o2 && o2.clamp(), this.options.center)
          this.parent.moveCenter(this.options.center);
        else {
          const r2 = this.parent.toGlobal(h2);
          this.parent.x += e2.x - r2.x, this.parent.y += e2.y - r2.y;
        }
      }
      this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.emit(
        "wheel-start",
        { event: t2, viewport: this.parent }
      );
    }
    return !this.parent.options.passiveWheel;
  }
};
var Q = class {
  constructor(t2) {
    this.viewport = t2, this.touches = [], this.addListeners();
  }
  /** Add input listeners */
  addListeners() {
    this.viewport.eventMode = "static", this.viewport.forceHitArea || (this.viewport.hitArea = new Rectangle(0, 0, this.viewport.worldWidth, this.viewport.worldHeight)), this.viewport.on("pointerdown", this.down, this), this.viewport.options.allowPreserveDragOutside ? this.viewport.on("globalpointermove", this.move, this) : this.viewport.on("pointermove", this.move, this), this.viewport.on("pointerup", this.up, this), this.viewport.on("pointerupoutside", this.up, this), this.viewport.on("pointercancel", this.up, this), this.viewport.options.allowPreserveDragOutside || this.viewport.on("pointerleave", this.up, this), this.wheelFunction = (t2) => this.handleWheel(t2), this.viewport.options.events.domElement.addEventListener(
      "wheel",
      this.wheelFunction,
      { passive: this.viewport.options.passiveWheel }
    ), this.isMouseDown = false;
  }
  /**
   * Removes all event listeners from viewport
   * (useful for cleanup of wheel when removing viewport)
   */
  destroy() {
    this.viewport.options.events.domElement.removeEventListener("wheel", this.wheelFunction);
  }
  /**
   * handle down events for viewport
   *
   * @param {PIXI.FederatedPointerEvent} event
   */
  down(t2) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    if (t2.pointerType === "mouse" ? this.isMouseDown = true : this.get(t2.pointerId) || this.touches.push({ id: t2.pointerId, last: null }), this.count() === 1) {
      this.last = t2.global.clone();
      const n2 = this.viewport.plugins.get("decelerate", true), i2 = this.viewport.plugins.get("bounce", true);
      (!n2 || !n2.isActive()) && (!i2 || !i2.isActive()) ? this.clickedAvailable = true : this.clickedAvailable = false;
    } else
      this.clickedAvailable = false;
    this.viewport.plugins.down(t2) && this.viewport.options.stopPropagation && t2.stopPropagation();
  }
  /** Clears all pointer events */
  clear() {
    this.isMouseDown = false, this.touches = [], this.last = null;
  }
  /**
   * @param {number} change
   * @returns whether change exceeds threshold
   */
  checkThreshold(t2) {
    return Math.abs(t2) >= this.viewport.threshold;
  }
  /** Handle move events for viewport */
  move(t2) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    const e2 = this.viewport.plugins.move(t2);
    if (this.clickedAvailable && this.last) {
      const n2 = t2.global.x - this.last.x, i2 = t2.global.y - this.last.y;
      (this.checkThreshold(n2) || this.checkThreshold(i2)) && (this.clickedAvailable = false);
    }
    e2 && this.viewport.options.stopPropagation && t2.stopPropagation();
  }
  /** Handle up events for viewport */
  up(t2) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    t2.pointerType === "mouse" && (this.isMouseDown = false), t2.pointerType !== "mouse" && this.remove(t2.pointerId);
    const e2 = this.viewport.plugins.up(t2);
    this.clickedAvailable && this.count() === 0 && this.last && (this.viewport.emit("clicked", {
      event: t2,
      screen: this.last,
      world: this.viewport.toWorld(this.last),
      viewport: this.viewport
    }), this.clickedAvailable = false), e2 && this.viewport.options.stopPropagation && t2.stopPropagation();
  }
  /** Gets pointer position if this.interaction is set */
  getPointerPosition(t2) {
    const e2 = new Point();
    return this.viewport.options.events.mapPositionToPoint(e2, t2.clientX, t2.clientY), e2;
  }
  /** Handle wheel events */
  handleWheel(t2) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    const e2 = this.viewport.toLocal(this.getPointerPosition(t2));
    this.viewport.left <= e2.x && e2.x <= this.viewport.right && this.viewport.top <= e2.y && e2.y <= this.viewport.bottom && this.viewport.plugins.wheel(t2) && !this.viewport.options.passiveWheel && t2.preventDefault();
  }
  pause() {
    this.touches = [], this.isMouseDown = false;
  }
  /** Get touch by id */
  get(t2) {
    for (const e2 of this.touches)
      if (e2.id === t2)
        return e2;
    return null;
  }
  /** Remove touch by number */
  remove(t2) {
    for (let e2 = 0; e2 < this.touches.length; e2++)
      if (this.touches[e2].id === t2) {
        this.touches.splice(e2, 1);
        return;
      }
  }
  /**
   * @returns {number} count of mouse/touch pointers that are down on the viewport
   */
  count() {
    return (this.isMouseDown ? 1 : 0) + this.touches.length;
  }
};
var m2 = [
  "drag",
  "pinch",
  "wheel",
  "follow",
  "mouse-edges",
  "decelerate",
  "animate",
  "bounce",
  "snap-zoom",
  "clamp-zoom",
  "snap",
  "clamp"
];
var J = class {
  /** This is called by {@link Viewport} to initialize the {@link Viewport.plugins plugins}. */
  constructor(t2) {
    this.viewport = t2, this.list = [], this.plugins = {};
  }
  /**
   * Inserts a named plugin or a user plugin into the viewport
   * default plugin order: 'drag', 'pinch', 'wheel', 'follow', 'mouse-edges', 'decelerate', 'bounce',
   * 'snap-zoom', 'clamp-zoom', 'snap', 'clamp'
   *
   * @param {string} name of plugin
   * @param {Plugin} plugin - instantiated Plugin class
   * @param {number} index to insert userPlugin (otherwise inserts it at the end)
   */
  add(t2, e2, n2 = m2.length) {
    const i2 = this.plugins[t2];
    i2 && i2.destroy(), this.plugins[t2] = e2;
    const s2 = m2.indexOf(t2);
    s2 !== -1 && m2.splice(s2, 1), m2.splice(n2, 0, t2), this.sort();
  }
  /**
   * Get plugin
   *
   * @param {string} name of plugin
   * @param {boolean} [ignorePaused] return null if plugin is paused
   */
  get(t2, e2) {
    var n2;
    return e2 && (n2 = this.plugins[t2]) != null && n2.paused ? null : this.plugins[t2];
  }
  /**
   * Update all active plugins
   *
   * @internal
   * @ignore
   * @param {number} elapsed type in milliseconds since last update
   */
  update(t2) {
    for (const e2 of this.list)
      e2.update(t2);
  }
  /**
   * Resize all active plugins
   *
   * @internal
   * @ignore
   */
  resize() {
    for (const t2 of this.list)
      t2.resize();
  }
  /** Clamps and resets bounce and decelerate (as needed) after manually moving viewport */
  reset() {
    for (const t2 of this.list)
      t2.reset();
  }
  /** removes all installed plugins */
  removeAll() {
    this.list.forEach((t2) => {
      t2.destroy();
    }), this.plugins = {}, this.sort();
  }
  /**
   * Removes installed plugin
   *
   * @param {string} name of plugin (e.g., 'drag', 'pinch')
   */
  remove(t2) {
    var e2;
    this.plugins[t2] && ((e2 = this.plugins[t2]) == null || e2.destroy(), delete this.plugins[t2], this.viewport.emit("plugin-remove", t2), this.sort());
  }
  /**
   * Pause plugin
   *
   * @param {string} name of plugin (e.g., 'drag', 'pinch')
   */
  pause(t2) {
    var e2;
    (e2 = this.plugins[t2]) == null || e2.pause();
  }
  /**
   * Resume plugin
   *
   * @param {string} name of plugin (e.g., 'drag', 'pinch')
   */
  resume(t2) {
    var e2;
    (e2 = this.plugins[t2]) == null || e2.resume();
  }
  /**
   * Sort plugins according to PLUGIN_ORDER
   *
   * @internal
   * @ignore
   */
  sort() {
    this.list = [];
    for (const t2 of m2)
      this.plugins[t2] && this.list.push(this.plugins[t2]);
  }
  /**
   * Handle down for all plugins
   *
   * @internal
   * @ignore
   */
  down(t2) {
    let e2 = false;
    for (const n2 of this.list)
      n2.down(t2) && (e2 = true);
    return e2;
  }
  /**
   * Handle move for all plugins
   *
   * @internal
   * @ignore
   */
  move(t2) {
    let e2 = false;
    for (const n2 of this.viewport.plugins.list)
      n2.move(t2) && (e2 = true);
    return e2;
  }
  /**
   * Handle up for all plugins
   *
   * @internal
   * @ignore
   */
  up(t2) {
    let e2 = false;
    for (const n2 of this.list)
      n2.up(t2) && (e2 = true);
    return e2;
  }
  /**
   * Handle wheel event for all plugins
   *
   * @internal
   * @ignore
   */
  wheel(t2) {
    let e2 = false;
    for (const n2 of this.list)
      n2.wheel(t2) && (e2 = true);
    return e2;
  }
};
var $2 = {
  screenWidth: typeof window > "u" ? 0 : window.innerWidth,
  screenHeight: typeof window > "u" ? 0 : window.innerHeight,
  worldWidth: null,
  worldHeight: null,
  threshold: 5,
  passiveWheel: true,
  stopPropagation: false,
  forceHitArea: null,
  noTicker: false,
  disableOnContextMenu: false,
  ticker: Ticker.shared,
  allowPreserveDragOutside: false
};
var et = class extends Container {
  /**
   * @param {IViewportOptions} ViewportOptions
   * @param {number} [options.screenWidth=window.innerWidth]
   * @param {number} [options.screenHeight=window.innerHeight]
   * @param {number} [options.worldWidth=this.width]
   * @param {number} [options.worldHeight=this.height]
   * @param {number} [options.threshold=5] number of pixels to move to trigger an input event (e.g., drag, pinch)
   * or disable a clicked event
   * @param {boolean} [options.passiveWheel=true] whether the 'wheel' event is set to passive (note: if false,
   * e.preventDefault() will be called when wheel is used over the viewport)
   * @param {boolean} [options.stopPropagation=false] whether to stopPropagation of events that impact the viewport
   * (except wheel events, see options.passiveWheel)
   * @param {HitArea} [options.forceHitArea] change the default hitArea from world size to a new value
   * @param {boolean} [options.noTicker] set this if you want to manually call update() function on each frame
   * @param {PIXI.Ticker} [options.ticker=PIXI.Ticker.shared] use this PIXI.ticker for updates
   * @param {PIXI.EventSystem} [options.events] EventSystem available from app.events or added manually and passed here
   * location on screen
   * @param {boolean} [options.disableOnContextMenu] remove oncontextmenu=() => {} from the pixi's events.domElement
   */
  constructor(t2) {
    super(), this._disableOnContextMenu = (e2) => e2.preventDefault(), this.options = {
      ...$2,
      ...t2
    }, this.screenWidth = this.options.screenWidth, this.screenHeight = this.options.screenHeight, this._worldWidth = this.options.worldWidth, this._worldHeight = this.options.worldHeight, this.forceHitArea = this.options.forceHitArea, this.threshold = this.options.threshold, this.options.disableOnContextMenu && this.options.events.domElement.addEventListener("contextmenu", this._disableOnContextMenu), this.options.noTicker || (this.tickerFunction = () => this.update(this.options.ticker.elapsedMS), this.options.ticker.add(this.tickerFunction)), this.input = new Q(this), this.plugins = new J(this);
  }
  /** Overrides PIXI.Container's destroy to also remove the 'wheel' and PIXI.Ticker listeners */
  destroy(t2) {
    !this.options.noTicker && this.tickerFunction && this.options.ticker.remove(this.tickerFunction), this.options.disableOnContextMenu && this.options.events.domElement.removeEventListener("contextmenu", this._disableOnContextMenu), this.input.destroy(), super.destroy(t2);
  }
  /**
   * Update viewport on each frame.
   *
   * By default, you do not need to call this unless you set `options.noTicker=true`.
   *
   * @param {number} elapsed time in milliseconds since last update
   */
  update(t2) {
    this.pause || (this.plugins.update(t2), this.lastViewport && (this.lastViewport.x !== this.x || this.lastViewport.y !== this.y ? this.moving = true : this.moving && (this.emit("moved-end", this), this.moving = false), this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y ? this.zooming = true : this.zooming && (this.emit("zoomed-end", this), this.zooming = false)), this.forceHitArea || (this._hitAreaDefault = new Rectangle(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight), this.hitArea = this._hitAreaDefault), this._dirty = this._dirty || !this.lastViewport || this.lastViewport.x !== this.x || this.lastViewport.y !== this.y || this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y, this.lastViewport = {
      x: this.x,
      y: this.y,
      scaleX: this.scale.x,
      scaleY: this.scale.y
    }, this.emit("frame-end", this));
  }
  /**
   * Use this to set screen and world sizes, needed for pinch/wheel/clamp/bounce.
   * @param {number} screenWidth=window.innerWidth
   * @param {number} screenHeight=window.innerHeight
   * @param {number} [worldWidth]
   * @param {number} [worldHeight]
   */
  resize(t2 = typeof window > "u" ? 0 : window.innerWidth, e2 = typeof window > "u" ? 0 : window.innerHeight, n2, i2) {
    this.screenWidth = t2, this.screenHeight = e2, typeof n2 < "u" && (this._worldWidth = n2), typeof i2 < "u" && (this._worldHeight = i2), this.plugins.resize(), this.dirty = true;
  }
  /** World width, in pixels */
  get worldWidth() {
    return this._worldWidth ? this._worldWidth : this.width / this.scale.x;
  }
  set worldWidth(t2) {
    this._worldWidth = t2, this.plugins.resize();
  }
  /** World height, in pixels */
  get worldHeight() {
    return this._worldHeight ? this._worldHeight : this.height / this.scale.y;
  }
  set worldHeight(t2) {
    this._worldHeight = t2, this.plugins.resize();
  }
  /** Get visible world bounds of viewport */
  getVisibleBounds() {
    return new Rectangle(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight);
  }
  /**
   * Changes coordinate from screen to world
   * @param {number|PIXI.Point} x
   * @param {number} y
   * @returns {PIXI.Point}
   */
  toWorld(t2, e2) {
    return arguments.length === 2 ? this.toLocal(new Point(t2, e2)) : this.toLocal(t2);
  }
  /**
   * Changes coordinate from world to screen
   * @param {number|PIXI.Point} x
   * @param {number} y
   * @returns {PIXI.Point}
   */
  toScreen(t2, e2) {
    return arguments.length === 2 ? this.toGlobal(new Point(t2, e2)) : this.toGlobal(t2);
  }
  /** Screen width in world coordinates */
  get worldScreenWidth() {
    return this.screenWidth / this.scale.x;
  }
  /** Screen height in world coordinates */
  get worldScreenHeight() {
    return this.screenHeight / this.scale.y;
  }
  /** World width in screen coordinates */
  get screenWorldWidth() {
    return this.worldWidth * this.scale.x;
  }
  /** World height in screen coordinates */
  get screenWorldHeight() {
    return this.worldHeight * this.scale.y;
  }
  /** Center of screen in world coordinates */
  get center() {
    return new Point(
      this.worldScreenWidth / 2 - this.x / this.scale.x,
      this.worldScreenHeight / 2 - this.y / this.scale.y
    );
  }
  set center(t2) {
    this.moveCenter(t2);
  }
  /**
   * Move center of viewport to (x, y)
   * @param {number|PIXI.Point} x
   * @param {number} [y]
   * @return {Viewport}
   */
  moveCenter(...t2) {
    let e2, n2;
    typeof t2[0] == "number" ? (e2 = t2[0], n2 = t2[1]) : (e2 = t2[0].x, n2 = t2[0].y);
    const i2 = (this.worldScreenWidth / 2 - e2) * this.scale.x, s2 = (this.worldScreenHeight / 2 - n2) * this.scale.y;
    return (this.x !== i2 || this.y !== s2) && (this.position.set(i2, s2), this.plugins.reset(), this.dirty = true), this;
  }
  /** Top-left corner of Viewport */
  get corner() {
    return new Point(-this.x / this.scale.x, -this.y / this.scale.y);
  }
  set corner(t2) {
    this.moveCorner(t2);
  }
  /**
   * MoveCorner
   * @param {number|PIXI.Point} x
   * @param {number} [y]
   * @returns {Viewport}
   */
  moveCorner(...t2) {
    let e2, n2;
    return t2.length === 1 ? (e2 = -t2[0].x * this.scale.x, n2 = -t2[0].y * this.scale.y) : (e2 = -t2[0] * this.scale.x, n2 = -t2[1] * this.scale.y), (e2 !== this.x || n2 !== this.y) && (this.position.set(e2, n2), this.plugins.reset(), this.dirty = true), this;
  }
  /** Get how many world pixels fit in screen's width */
  get screenWidthInWorldPixels() {
    return this.screenWidth / this.scale.x;
  }
  /** Get how many world pixels fit on screen's height */
  get screenHeightInWorldPixels() {
    return this.screenHeight / this.scale.y;
  }
  /**
   * Find the scale value that fits a world width on the screen
   * does not change the viewport (use fit... to change)
   *
   * @param width - Width in world pixels
   * @return - scale
   */
  findFitWidth(t2) {
    return this.screenWidth / t2;
  }
  /**
   * Finds the scale value that fits a world height on the screens
   * does not change the viewport (use fit... to change)
   *
   * @param height - Height in world pixels
   * @return - scale
   */
  findFitHeight(t2) {
    return this.screenHeight / t2;
  }
  /**
   * Finds the scale value that fits the smaller of a world width and world height on the screen
   * does not change the viewport (use fit... to change)
   *
   * @param {number} width in world pixels
   * @param {number} height in world pixels
   * @returns {number} scale
   */
  findFit(t2, e2) {
    const n2 = this.screenWidth / t2, i2 = this.screenHeight / e2;
    return Math.min(n2, i2);
  }
  /**
   * Finds the scale value that fits the larger of a world width and world height on the screen
   * does not change the viewport (use fit... to change)
   *
   * @param {number} width in world pixels
   * @param {number} height in world pixels
   * @returns {number} scale
   */
  findCover(t2, e2) {
    const n2 = this.screenWidth / t2, i2 = this.screenHeight / e2;
    return Math.max(n2, i2);
  }
  /**
   * Change zoom so the width fits in the viewport
   *
   * @param width - width in world coordinates
   * @param center - maintain the same center
   * @param scaleY - whether to set scaleY=scaleX
   * @param noClamp - whether to disable clamp-zoom
   * @returns {Viewport} this
   */
  fitWidth(t2 = this.worldWidth, e2, n2 = true, i2) {
    let s2;
    e2 && (s2 = this.center), this.scale.x = this.screenWidth / t2, n2 && (this.scale.y = this.scale.x);
    const h2 = this.plugins.get("clamp-zoom", true);
    return !i2 && h2 && h2.clamp(), e2 && s2 && this.moveCenter(s2), this;
  }
  /**
   * Change zoom so the height fits in the viewport
   *
   * @param {number} [height=this.worldHeight] in world coordinates
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @param {boolean} [scaleX=true] whether to set scaleX = scaleY
   * @param {boolean} [noClamp] whether to disable clamp-zoom
   * @returns {Viewport} this
   */
  fitHeight(t2 = this.worldHeight, e2, n2 = true, i2) {
    let s2;
    e2 && (s2 = this.center), this.scale.y = this.screenHeight / t2, n2 && (this.scale.x = this.scale.y);
    const h2 = this.plugins.get("clamp-zoom", true);
    return !i2 && h2 && h2.clamp(), e2 && s2 && this.moveCenter(s2), this;
  }
  /**
   * Change zoom so it fits the entire world in the viewport
   *
   * @param {boolean} center maintain the same center of the screen after zoom
   * @returns {Viewport} this
   */
  fitWorld(t2) {
    let e2;
    t2 && (e2 = this.center), this.scale.x = this.screenWidth / this.worldWidth, this.scale.y = this.screenHeight / this.worldHeight, this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y;
    const n2 = this.plugins.get("clamp-zoom", true);
    return n2 && n2.clamp(), t2 && e2 && this.moveCenter(e2), this;
  }
  /**
   * Change zoom so it fits the size or the entire world in the viewport
   *
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @param {number} [width=this.worldWidth] desired width
   * @param {number} [height=this.worldHeight] desired height
   * @returns {Viewport} this
   */
  fit(t2, e2 = this.worldWidth, n2 = this.worldHeight) {
    let i2;
    t2 && (i2 = this.center), this.scale.x = this.screenWidth / e2, this.scale.y = this.screenHeight / n2, this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y;
    const s2 = this.plugins.get("clamp-zoom", true);
    return s2 && s2.clamp(), t2 && i2 && this.moveCenter(i2), this;
  }
  /**
   * Zoom viewport to specific value.
   *
   * @param {number} scale value (e.g., 1 would be 100%, 0.25 would be 25%)
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @return {Viewport} this
   */
  setZoom(t2, e2) {
    let n2;
    e2 && (n2 = this.center), this.scale.set(t2);
    const i2 = this.plugins.get("clamp-zoom", true);
    return i2 && i2.clamp(), e2 && n2 && this.moveCenter(n2), this;
  }
  /**
   * Zoom viewport by a certain percent (in both x and y direction).
   *
   * @param {number} percent change (e.g., 0.25 would increase a starting scale of 1.0 to 1.25)
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @return {Viewport} this
   */
  zoomPercent(t2, e2) {
    return this.setZoom(this.scale.x + this.scale.x * t2, e2);
  }
  /**
   * Zoom viewport by increasing/decreasing width by a certain number of pixels.
   *
   * @param {number} change in pixels
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @return {Viewport} this
   */
  zoom(t2, e2) {
    return this.fitWidth(t2 + this.worldScreenWidth, e2), this;
  }
  /** Changes scale of viewport and maintains center of viewport */
  get scaled() {
    return this.scale.x;
  }
  set scaled(t2) {
    this.setZoom(t2, true);
  }
  /**
   * Returns zoom to the desired scale
   *
   * @param {ISnapZoomOptions} options
   * @param {number} [options.width=0] - the desired width to snap (to maintain aspect ratio, choose width or height)
   * @param {number} [options.height=0] - the desired height to snap (to maintain aspect ratio, choose width or height)
   * @param {number} [options.time=1000] - time for snapping in ms
   * @param {(string|function)} [options.ease=easeInOutSine] ease function or name (see http://easings.net/
   *   for supported names)
   * @param {PIXI.Point} [options.center] - place this point at center during zoom instead of center of the viewport
   * @param {boolean} [options.interrupt=true] - pause snapping with any user input on the viewport
   * @param {boolean} [options.removeOnComplete] - removes this plugin after snapping is complete
   * @param {boolean} [options.removeOnInterrupt] - removes this plugin if interrupted by any user input
   * @param {boolean} [options.forceStart] - starts the snap immediately regardless of whether the viewport is at the
   *   desired zoom
   * @param {boolean} [options.noMove] - zoom but do not move
   */
  snapZoom(t2) {
    return this.plugins.add("snap-zoom", new K(this, t2)), this;
  }
  /** Is container out of world bounds */
  OOB() {
    return {
      left: this.left < 0,
      right: this.right > this.worldWidth,
      top: this.top < 0,
      bottom: this.bottom > this.worldHeight,
      cornerPoint: new Point(
        this.worldWidth * this.scale.x - this.screenWidth,
        this.worldHeight * this.scale.y - this.screenHeight
      )
    };
  }
  /** World coordinates of the right edge of the screen */
  get right() {
    return -this.x / this.scale.x + this.worldScreenWidth;
  }
  set right(t2) {
    this.x = -t2 * this.scale.x + this.screenWidth, this.plugins.reset();
  }
  /** World coordinates of the left edge of the screen */
  get left() {
    return -this.x / this.scale.x;
  }
  set left(t2) {
    this.x = -t2 * this.scale.x, this.plugins.reset();
  }
  /** World coordinates of the top edge of the screen */
  get top() {
    return -this.y / this.scale.y;
  }
  set top(t2) {
    this.y = -t2 * this.scale.y, this.plugins.reset();
  }
  /** World coordinates of the bottom edge of the screen */
  get bottom() {
    return -this.y / this.scale.y + this.worldScreenHeight;
  }
  set bottom(t2) {
    this.y = -t2 * this.scale.y + this.screenHeight, this.plugins.reset();
  }
  /**
   * Determines whether the viewport is dirty (i.e., needs to be rendered to the screen because of a change)
   */
  get dirty() {
    return !!this._dirty;
  }
  set dirty(t2) {
    this._dirty = t2;
  }
  /**
   * Permanently changes the Viewport's hitArea
   *
   * NOTE: if not set then hitArea = PIXI.Rectangle(Viewport.left, Viewport.top, Viewport.worldScreenWidth,
   * Viewport.worldScreenHeight)
   */
  get forceHitArea() {
    return this._forceHitArea;
  }
  set forceHitArea(t2) {
    t2 ? (this._forceHitArea = t2, this.hitArea = t2) : (this._forceHitArea = null, this.hitArea = new Rectangle(0, 0, this.worldWidth, this.worldHeight));
  }
  /**
   * Enable one-finger touch to drag
   *
   * NOTE: if you expect users to use right-click dragging, you should enable `viewport.options.disableOnContextMenu`
   * to avoid the context menu popping up on each right-click drag.
   *
   * @param {IDragOptions} [options]
   * @param {string} [options.direction=all] direction to drag
   * @param {boolean} [options.pressDrag=true] whether click to drag is active
   * @param {boolean} [options.wheel=true] use wheel to scroll in direction (unless wheel plugin is active)
   * @param {number} [options.wheelScroll=1] number of pixels to scroll with each wheel spin
   * @param {boolean} [options.reverse] reverse the direction of the wheel scroll
   * @param {(boolean|string)} [options.clampWheel=false] clamp wheel(to avoid weird bounce with mouse wheel)
   * @param {string} [options.underflow=center] where to place world if too small for screen
   * @param {number} [options.factor=1] factor to multiply drag to increase the speed of movement
   * @param {string} [options.mouseButtons=all] changes which mouse buttons trigger drag, use: 'all', 'left',
   *  'right' 'middle', or some combination, like, 'middle-right'; you may want to set
   *   viewport.options.disableOnContextMenu if you want to use right-click dragging
   * @param {string[]} [options.keyToPress=null] - array containing
   *  {@link key|https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code} codes of keys that can be
   *  pressed for the drag to be triggered, e.g.: ['ShiftLeft', 'ShiftRight'}.
   * @param {boolean} [options.ignoreKeyToPressOnTouch=false] - ignore keyToPress for touch events
   * @param {number} [options.lineHeight=20] - scaling factor for non-DOM_DELTA_PIXEL scrolling events
   * @returns {Viewport} this
   */
  drag(t2) {
    return this.plugins.add("drag", new D(this, t2)), this;
  }
  /**
   * Clamp to world boundaries or other provided boundaries
   * There are three ways to clamp:
   * 1. direction: 'all' = the world is clamped to its world boundaries, ie, you cannot drag any part of offscreen
   *    direction: 'x' | 'y' = only the x or y direction is clamped to its world boundary
   * 2. left, right, top, bottom = true | number = the world is clamped to the world's pixel location for each side;
   *    if any of these are set to true, then the location is set to the boundary
   *    [0, viewport.worldWidth/viewport.worldHeight], eg: to allow the world to be completely dragged offscreen,
   *    set [-viewport.worldWidth, -viewport.worldHeight, viewport.worldWidth * 2, viewport.worldHeight * 2]
   *
   * Underflow determines what happens when the world is smaller than the viewport
   * 1. none = the world is clamped but there is no special behavior
   * 2. center = the world is centered on the viewport
   * 3. combination of top/bottom/center and left/right/center (case insensitive) = the world is stuck to the
   *     appropriate boundaries
   *
   * NOTES:
   *   clamp is disabled if called with no options; use { direction: 'all' } for all edge clamping
   *   screenWidth, screenHeight, worldWidth, and worldHeight needs to be set for this to work properly
   *
   * @param {object} [options]
   * @param {(number|boolean)} [options.left=false] - clamp left; true = 0
   * @param {(number|boolean)} [options.right=false] - clamp right; true = viewport.worldWidth
   * @param {(number|boolean)} [options.top=false] - clamp top; true = 0
   * @param {(number|boolean)} [options.bottom=false] - clamp bottom; true = viewport.worldHeight
   * @param {string} [direction] - (all, x, or y) using clamps of [0, viewport.worldWidth/viewport.worldHeight];
   *  replaces left/right/top/bottom if set
   * @param {string} [underflow=center] - where to place world if too small for screen (e.g., top-right, center,
   *  none, bottomLeft)     * @returns {Viewport} this
   */
  clamp(t2) {
    return this.plugins.add("clamp", new X(this, t2)), this;
  }
  /**
   * Decelerate after a move
   *
   * NOTE: this fires 'moved' event during deceleration
   *
   * @param {IDecelerateOptions} [options]
   * @param {number} [options.friction=0.95] - percent to decelerate after movement
   * @param {number} [options.bounce=0.8] - percent to decelerate when past boundaries (only applicable when
   *   viewport.bounce() is active)
   * @param {number} [options.minSpeed=0.01] - minimum velocity before stopping/reversing acceleration
   * @return {Viewport} this
   */
  decelerate(t2) {
    return this.plugins.add("decelerate", new T(this, t2)), this;
  }
  /**
   * Bounce on borders
   * NOTES:
   *    screenWidth, screenHeight, worldWidth, and worldHeight needs to be set for this to work properly
   *    fires 'moved', 'bounce-x-start', 'bounce-y-start', 'bounce-x-end', and 'bounce-y-end' events
   * @param {object} [options]
   * @param {string} [options.sides=all] - all, horizontal, vertical, or combination of top, bottom, right, left
   *  (e.g., 'top-bottom-right')
   * @param {number} [options.friction=0.5] - friction to apply to decelerate if active
   * @param {number} [options.time=150] - time in ms to finish bounce
   * @param {object} [options.bounceBox] - use this bounceBox instead of (0, 0, viewport.worldWidth, viewport.worldHeight)
   * @param {number} [options.bounceBox.x=0]
   * @param {number} [options.bounceBox.y=0]
   * @param {number} [options.bounceBox.width=viewport.worldWidth]
   * @param {number} [options.bounceBox.height=viewport.worldHeight]
   * @param {string|function} [options.ease=easeInOutSine] - ease function or name
   *  (see http://easings.net/ for supported names)
   * @param {string} [options.underflow=center] - (top/bottom/center and left/right/center, or center)
   *  where to place world if too small for screen
   * @return {Viewport} this
   */
  bounce(t2) {
    return this.plugins.add("bounce", new k2(this, t2)), this;
  }
  /**
   * Enable pinch to zoom and two-finger touch to drag
   *
   * @param {PinchOptions} [options]
   * @param {boolean} [options.noDrag] - disable two-finger dragging
   * @param {number} [options.percent=1] - percent to modify pinch speed
   * @param {number} [options.factor=1] - factor to multiply two-finger drag to increase the speed of movement
   * @param {PIXI.Point} [options.center] - place this point at center during zoom instead of center of two fingers
   * @param {('all'|'x'|'y')} [options.axis=all] - axis to zoom
   * @return {Viewport} this
   */
  pinch(t2) {
    return this.plugins.add("pinch", new N2(this, t2)), this;
  }
  /**
   * Snap to a point
   *
   * @param {number} x
   * @param {number} y
   * @param {ISnapOptions} [options]
   * @param {boolean} [options.topLeft] - snap to the top-left of viewport instead of center
   * @param {number} [options.friction=0.8] - friction/frame to apply if decelerate is active
   * @param {number} [options.time=1000] - time in ms to snap
   * @param {string|function} [options.ease=easeInOutSine] - ease function or name (see http://easings.net/
   *   for supported names)
   * @param {boolean} [options.interrupt=true] - pause snapping with any user input on the viewport
   * @param {boolean} [options.removeOnComplete] - removes this plugin after snapping is complete
   * @param {boolean} [options.removeOnInterrupt] - removes this plugin if interrupted by any user input
   * @param {boolean} [options.forceStart] - starts the snap immediately regardless of whether the viewport is at
   *   the desired location
   * @return {Viewport} this
   */
  snap(t2, e2, n2) {
    return this.plugins.add("snap", new j2(this, t2, e2, n2)), this;
  }
  /**
   * Follow a target
   *
   * NOTES:
   *    uses the (x, y) as the center to follow; for PIXI.Sprite to work properly, use sprite.anchor.set(0.5)
   *    options.acceleration is not perfect as it doesn't know the velocity of the target. It adds acceleration
   *    to the start of movement and deceleration to the end of movement when the target is stopped.
   *    To cancel the follow, use: `viewport.plugins.remove('follow')`
   *
   * @fires 'moved' event
   *
   * @param {PIXI.DisplayObject} target to follow
   * @param {IFollowOptions} [options]
   * @param {number} [options.speed=0] - to follow in pixels/frame (0=teleport to location)
   * @param {number} [options.acceleration] - set acceleration to accelerate and decelerate at this rate; speed
   *   cannot be 0 to use acceleration
   * @param {number} [options.radius] - radius (in world coordinates) of center circle where movement is allowed
   *   without moving the viewport     * @returns {Viewport} this
   * @returns {Viewport} this
   */
  follow(t2, e2) {
    return this.plugins.add("follow", new U(this, t2, e2)), this;
  }
  /**
   * Zoom using mouse wheel
   *
   * NOTE: the default event listener for 'wheel' event is the options.events.domElement.
   *
   * @param {IWheelOptions} [options]
   * @param {number} [options.percent=0.1] - percent to scroll with each spin
   * @param {number} [options.smooth] - smooth the zooming by providing the number of frames to zoom between wheel spins
   * @param {boolean} [options.interrupt=true] - stop smoothing with any user input on the viewport
   * @param {boolean} [options.reverse] - reverse the direction of the scroll
   * @param {PIXI.Point} [options.center] - place this point at center during zoom instead of current mouse position
   * @param {number} [options.lineHeight=20] - scaling factor for non-DOM_DELTA_PIXEL scrolling events
   * @param {('all'|'x'|'y')} [options.axis=all] - axis to zoom
   * @return {Viewport} this
   */
  wheel(t2) {
    return this.plugins.add("wheel", new G(this, t2)), this;
  }
  /**
   * Animate the position and/or scale of the viewport
   * To set the zoom level, use: (1) scale, (2) scaleX and scaleY, or (3) width and/or height
   * @param {object} options
   * @param {number} [options.time=1000] - time to animate
   * @param {PIXI.Point} [options.position=viewport.center] - position to move viewport
   * @param {number} [options.width] - desired viewport width in world pixels (use instead of scale;
   *  aspect ratio is maintained if height is not provided)
   * @param {number} [options.height] - desired viewport height in world pixels (use instead of scale;
   *  aspect ratio is maintained if width is not provided)
   * @param {number} [options.scale] - scale to change zoom (scale.x = scale.y)
   * @param {number} [options.scaleX] - independently change zoom in x-direction
   * @param {number} [options.scaleY] - independently change zoom in y-direction
   * @param {(function|string)} [options.ease=linear] - easing function to use
   * @param {function} [options.callbackOnComplete]
   * @param {boolean} [options.removeOnInterrupt] removes this plugin if interrupted by any user input
   * @returns {Viewport} this
   */
  animate(t2) {
    return this.plugins.add("animate", new C(this, t2)), this;
  }
  /**
   * Enable clamping of zoom to constraints
   *
   * The minWidth/Height settings are how small the world can get (as it would appear on the screen)
   * before clamping. The maxWidth/maxHeight is how larger the world can scale (as it would appear on
   * the screen) before clamping.
   *
   * For example, if you have a world size of 1000 x 1000 and a screen size of 100 x 100, if you set
   * minWidth/Height = 100 then the world will not be able to zoom smaller than the screen size (ie,
   * zooming out so it appears smaller than the screen). Similarly, if you set maxWidth/Height = 100
   * the world will not be able to zoom larger than the screen size (ie, zooming in so it appears
   * larger than the screen).
   *
   * @param {object} [options]
   * @param {number} [options.minWidth] - minimum width
   * @param {number} [options.minHeight] - minimum height
   * @param {number} [options.maxWidth] - maximum width
   * @param {number} [options.maxHeight] - maximum height
   * @param {number} [options.minScale] - minimum scale
   * @param {number} [options.maxScale] - minimum scale
   * @return {Viewport} this
   */
  clampZoom(t2) {
    return this.plugins.add("clamp-zoom", new A(this, t2)), this;
  }
  /**
   * Scroll viewport when mouse hovers near one of the edges or radius-distance from center of screen.
   *
   * NOTES: fires 'moved' event; there's a known bug where the mouseEdges does not work properly with "windowed" viewports
   *
   * @param {IMouseEdgesOptions} [options]
   * @param {number} [options.radius] - distance from center of screen in screen pixels
   * @param {number} [options.distance] - distance from all sides in screen pixels
   * @param {number} [options.top] - alternatively, set top distance (leave unset for no top scroll)
   * @param {number} [options.bottom] - alternatively, set bottom distance (leave unset for no top scroll)
   * @param {number} [options.left] - alternatively, set left distance (leave unset for no top scroll)
   * @param {number} [options.right] - alternatively, set right distance (leave unset for no top scroll)
   * @param {number} [options.speed=8] - speed in pixels/frame to scroll viewport
   * @param {boolean} [options.reverse] - reverse direction of scroll
   * @param {boolean} [options.noDecelerate] - don't use decelerate plugin even if it's installed
   * @param {boolean} [options.linear] - if using radius, use linear movement (+/- 1, +/- 1) instead of angled
   *   movement (Math.cos(angle from center), Math.sin(angle from center))
   * @param {boolean} [options.allowButtons] allows plugin to continue working even when there's a mousedown event
   */
  mouseEdges(t2) {
    return this.plugins.add("mouse-edges", new B(this, t2)), this;
  }
  /** Pause viewport (including animation updates such as decelerate) */
  get pause() {
    return !!this._pause;
  }
  set pause(t2) {
    this._pause = t2, this.lastViewport = null, this.moving = false, this.zooming = false, t2 && this.input.pause();
  }
  /**
   * Move the viewport so the bounding box is visible
   *
   * @param x - left
   * @param y - top
   * @param width
   * @param height
   * @param resizeToFit - Resize the viewport so the box fits within the viewport
   */
  ensureVisible(t2, e2, n2, i2, s2) {
    s2 && (n2 > this.worldScreenWidth || i2 > this.worldScreenHeight) && (this.fit(true, n2, i2), this.emit("zoomed", { viewport: this, type: "ensureVisible" }));
    let h2 = false;
    t2 < this.left ? (this.left = t2, h2 = true) : t2 + n2 > this.right && (this.right = t2 + n2, h2 = true), e2 < this.top ? (this.top = e2, h2 = true) : e2 + i2 > this.bottom && (this.bottom = e2 + i2, h2 = true), h2 && this.emit("moved", { viewport: this, type: "ensureVisible" });
  }
};

// ../../node_modules/.pnpm/pixi-cull@2.2.0_pixi.js@8.0.0-beta.5/node_modules/pixi-cull/dist/pixi-cull.es.js
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var defaultSimpleOptions = {
  visible: "visible",
  dirtyTest: false
};
var Simple = (
  /** @class */
  function() {
    function Simple2(options) {
      if (options === void 0) {
        options = {};
      }
      options = __assign(__assign({}, defaultSimpleOptions), options);
      this.dirtyTest = typeof options.dirtyTest !== "undefined" ? options.dirtyTest : true;
      this.lists = [[]];
    }
    Simple2.prototype.addList = function(array, staticObject) {
      this.lists.push(array);
      if (staticObject) {
        array.staticObject = true;
      }
      var length = array.length;
      for (var i2 = 0; i2 < length; i2++) {
        this.updateObject(array[i2]);
      }
      return array;
    };
    Simple2.prototype.removeList = function(array) {
      var index = this.lists.indexOf(array);
      if (index === -1) {
        return array;
      }
      this.lists.splice(index, 1);
      return array;
    };
    Simple2.prototype.add = function(object, staticObject) {
      if (staticObject) {
        object.staticObject = true;
      }
      if (this.dirtyTest || staticObject) {
        this.updateObject(object);
      }
      this.lists[0].push(object);
      return object;
    };
    Simple2.prototype.remove = function(object) {
      var index = this.lists[0].indexOf(object);
      if (index === -1) {
        return object;
      }
      this.lists[0].splice(index, 1);
      return object;
    };
    Simple2.prototype.cull = function(bounds, skipUpdate) {
      if (!skipUpdate) {
        this.updateObjects();
      }
      for (var _i = 0, _a = this.lists; _i < _a.length; _i++) {
        var list = _a[_i];
        var length_1 = list.length;
        for (var i2 = 0; i2 < length_1; i2++) {
          var object = list[i2];
          var box = object.AABB;
          object.visible = box.x + box.width > bounds.x && box.x < bounds.x + bounds.width && box.y + box.height > bounds.y && box.y < bounds.y + bounds.height;
        }
      }
    };
    Simple2.prototype.updateObjects = function() {
      if (this.dirtyTest) {
        for (var _i = 0, _a = this.lists; _i < _a.length; _i++) {
          var list = _a[_i];
          if (!list.staticObject) {
            var length_2 = list.length;
            for (var i2 = 0; i2 < length_2; i2++) {
              var object = list[i2];
              if (!object.staticObject && object.dirty) {
                this.updateObject(object);
                object.dirty = false;
              }
            }
          }
        }
      } else {
        for (var _b = 0, _c = this.lists; _b < _c.length; _b++) {
          var list = _c[_b];
          if (!list.staticObject) {
            var length_3 = list.length;
            for (var i2 = 0; i2 < length_3; i2++) {
              var object = list[i2];
              if (!object.staticObject) {
                this.updateObject(object);
              }
            }
          }
        }
      }
    };
    Simple2.prototype.updateObject = function(object) {
      var box = object.getLocalBounds();
      object.AABB = object.AABB || { x: 0, y: 0, width: 0, height: 0 };
      object.AABB.x = object.x + (box.x - object.pivot.x) * Math.abs(object.scale.x);
      object.AABB.y = object.y + (box.y - object.pivot.y) * Math.abs(object.scale.y);
      object.AABB.width = box.width * Math.abs(object.scale.x);
      object.AABB.height = box.height * Math.abs(object.scale.y);
    };
    Simple2.prototype.query = function(bounds) {
      var results = [];
      for (var _i = 0, _a = this.lists; _i < _a.length; _i++) {
        var list = _a[_i];
        for (var _b = 0, list_1 = list; _b < list_1.length; _b++) {
          var object = list_1[_b];
          var box = object.AABB;
          if (box && box.x + box.width > bounds.x && box.x - box.width < bounds.x + bounds.width && box.y + box.height > bounds.y && box.y - box.height < bounds.y + bounds.height) {
            results.push(object);
          }
        }
      }
      return results;
    };
    Simple2.prototype.queryCallback = function(bounds, callback) {
      for (var _i = 0, _a = this.lists; _i < _a.length; _i++) {
        var list = _a[_i];
        for (var _b = 0, list_2 = list; _b < list_2.length; _b++) {
          var object = list_2[_b];
          var box = object.AABB;
          if (box && box.x + box.width > bounds.x && box.x - box.width < bounds.x + bounds.width && box.y + box.height > bounds.y && box.y - box.height < bounds.y + bounds.height) {
            if (callback(object)) {
              return true;
            }
          }
        }
      }
      return false;
    };
    Simple2.prototype.stats = function() {
      var visible = 0, count2 = 0;
      for (var _i = 0, _a = this.lists; _i < _a.length; _i++) {
        var list = _a[_i];
        list.forEach(function(object) {
          visible += object.visible ? 1 : 0;
          count2++;
        });
      }
      return { total: count2, visible, culled: count2 - visible };
    };
    return Simple2;
  }()
);
var SpatialHashDefaultOptions = {
  xSize: 1e3,
  ySize: 1e3,
  simpleTest: true,
  dirtyTest: true
};
var SpatialHash = (
  /** @class */
  function() {
    function SpatialHash3(options) {
      this.xSize = 1e3;
      this.ySize = 1e3;
      this.simpleTest = true;
      this.dirtyTest = true;
      options = __assign(__assign({}, SpatialHashDefaultOptions), options);
      if (options && typeof options.size !== "undefined") {
        this.xSize = this.ySize = options.size;
      } else {
        this.xSize = options.xSize;
        this.ySize = options.ySize;
      }
      this.simpleTest = options.simpleTest;
      this.dirtyTest = options.dirtyTest;
      this.width = this.height = 0;
      this.hash = {};
      this.containers = [];
      this.elements = [];
    }
    SpatialHash3.prototype.add = function(object, staticObject) {
      object.spatial = { hashes: [] };
      if (this.dirtyTest) {
        object.dirty = true;
      }
      if (staticObject) {
        object.staticObject = true;
      }
      this.updateObject(object);
      this.elements.push(object);
      return object;
    };
    SpatialHash3.prototype.remove = function(object) {
      this.elements.splice(this.elements.indexOf(object), 1);
      this.removeFromHash(object);
      return object;
    };
    SpatialHash3.prototype.addContainer = function(container, staticObject) {
      var _this = this;
      var added = function(object2) {
        object2.spatial = { hashes: [] };
        _this.updateObject(object2);
      };
      var removed = function(object2) {
        _this.removeFromHash(object2);
      };
      var length = container.children.length;
      for (var i2 = 0; i2 < length; i2++) {
        var object = container.children[i2];
        object.spatial = { hashes: [] };
        this.updateObject(object);
      }
      container.cull = {};
      this.containers.push(container);
      container.on("childAdded", added);
      container.on("childRemoved", removed);
      container.cull.added = added;
      container.cull.removed = removed;
      if (staticObject) {
        container.cull.static = true;
      }
    };
    SpatialHash3.prototype.removeContainer = function(container) {
      var _this = this;
      this.containers.splice(this.containers.indexOf(container), 1);
      container.children.forEach(function(object) {
        return _this.removeFromHash(object);
      });
      container.off("childAdded", container.cull.added);
      container.off("removedFrom", container.cull.removed);
      delete container.cull;
      return container;
    };
    SpatialHash3.prototype.cull = function(AABB, skipUpdate, callback) {
      if (!skipUpdate) {
        this.updateObjects();
      }
      this.invisible();
      var objects;
      if (callback) {
        objects = this.queryCallbackAll(AABB, this.simpleTest, callback);
      } else {
        objects = this.query(AABB, this.simpleTest);
      }
      objects.forEach(function(object) {
        return object.visible = true;
      });
      return this.lastBuckets;
    };
    SpatialHash3.prototype.invisible = function() {
      var length = this.elements.length;
      for (var i2 = 0; i2 < length; i2++) {
        this.elements[i2].visible = false;
      }
      for (var _i = 0, _a = this.containers; _i < _a.length; _i++) {
        var container = _a[_i];
        var length_1 = container.children.length;
        for (var i2 = 0; i2 < length_1; i2++) {
          container.children[i2].visible = false;
        }
      }
    };
    SpatialHash3.prototype.updateObjects = function() {
      if (this.dirtyTest) {
        var length_2 = this.elements.length;
        for (var i2 = 0; i2 < length_2; i2++) {
          var object = this.elements[i2];
          if (object.dirty) {
            this.updateObject(object);
            object.dirty = false;
          }
        }
        for (var _i = 0, _a = this.containers; _i < _a.length; _i++) {
          var container = _a[_i];
          if (!container.cull.static) {
            var length_3 = container.children.length;
            for (var i2 = 0; i2 < length_3; i2++) {
              var object = container.children[i2];
              if (object.dirty) {
                this.updateObject(object);
                object.dirty = false;
              }
            }
          }
        }
      } else {
        var length_4 = this.elements.length;
        for (var i2 = 0; i2 < length_4; i2++) {
          var object = this.elements[i2];
          if (!object.staticObject) {
            this.updateObject(object);
          }
        }
        for (var _b = 0, _c = this.containers; _b < _c.length; _b++) {
          var container = _c[_b];
          if (!container.cull.static) {
            var length_5 = container.children.length;
            for (var i2 = 0; i2 < length_5; i2++) {
              this.updateObject(container.children[i2]);
            }
          }
        }
      }
    };
    SpatialHash3.prototype.updateObject = function(object) {
      var AABB;
      var box = object.getLocalBounds();
      AABB = object.AABB = {
        x: object.x + (box.x - object.pivot.x) * object.scale.x,
        y: object.y + (box.y - object.pivot.y) * object.scale.y,
        width: box.width * object.scale.x,
        height: box.height * object.scale.y
      };
      var spatial = object.spatial;
      if (!spatial) {
        spatial = object.spatial = { hashes: [] };
      }
      var _a = this.getBounds(AABB), xStart = _a.xStart, yStart = _a.yStart, xEnd = _a.xEnd, yEnd = _a.yEnd;
      if (spatial.xStart !== xStart || spatial.yStart !== yStart || spatial.xEnd !== xEnd || spatial.yEnd !== yEnd) {
        if (spatial.hashes.length) {
          this.removeFromHash(object);
        }
        for (var y2 = yStart; y2 <= yEnd; y2++) {
          for (var x3 = xStart; x3 <= xEnd; x3++) {
            var key = x3 + "," + y2;
            this.insert(object, key);
            spatial.hashes.push(key);
          }
        }
        spatial.xStart = xStart;
        spatial.yStart = yStart;
        spatial.xEnd = xEnd;
        spatial.yEnd = yEnd;
      }
    };
    SpatialHash3.prototype.getBuckets = function(minimum) {
      if (minimum === void 0) {
        minimum = 1;
      }
      var hashes = [];
      for (var key in this.hash) {
        var hash = this.hash[key];
        if (hash.length >= minimum) {
          hashes.push(hash);
        }
      }
      return hashes;
    };
    SpatialHash3.prototype.getBounds = function(AABB) {
      var xStart = Math.floor(AABB.x / this.xSize);
      var yStart = Math.floor(AABB.y / this.ySize);
      var xEnd = Math.floor((AABB.x + AABB.width) / this.xSize);
      var yEnd = Math.floor((AABB.y + AABB.height) / this.ySize);
      return { xStart, yStart, xEnd, yEnd };
    };
    SpatialHash3.prototype.insert = function(object, key) {
      if (!this.hash[key]) {
        this.hash[key] = [object];
      } else {
        this.hash[key].push(object);
      }
    };
    SpatialHash3.prototype.removeFromHash = function(object) {
      var spatial = object.spatial;
      while (spatial.hashes.length) {
        var key = spatial.hashes.pop();
        var list = this.hash[key];
        list.splice(list.indexOf(object), 1);
      }
    };
    SpatialHash3.prototype.neighbors = function(object) {
      var _this = this;
      var results = [];
      object.spatial.hashes.forEach(function(key) {
        return results = results.concat(_this.hash[key]);
      });
      return results;
    };
    SpatialHash3.prototype.query = function(AABB, simpleTest) {
      if (simpleTest === void 0) {
        simpleTest = true;
      }
      var buckets = 0;
      var results = [];
      var _a = this.getBounds(AABB), xStart = _a.xStart, yStart = _a.yStart, xEnd = _a.xEnd, yEnd = _a.yEnd;
      for (var y2 = yStart; y2 <= yEnd; y2++) {
        for (var x3 = xStart; x3 <= xEnd; x3++) {
          var entry = this.hash[x3 + "," + y2];
          if (entry) {
            if (simpleTest) {
              var length_6 = entry.length;
              for (var i2 = 0; i2 < length_6; i2++) {
                var object = entry[i2];
                var box = object.AABB;
                if (box.x + box.width > AABB.x && box.x < AABB.x + AABB.width && box.y + box.height > AABB.y && box.y < AABB.y + AABB.height) {
                  results.push(object);
                }
              }
            } else {
              results = results.concat(entry);
            }
            buckets++;
          }
        }
      }
      this.lastBuckets = buckets;
      return results;
    };
    SpatialHash3.prototype.queryCallbackAll = function(AABB, simpleTest, callback) {
      if (simpleTest === void 0) {
        simpleTest = true;
      }
      var buckets = 0;
      var results = [];
      var _a = this.getBounds(AABB), xStart = _a.xStart, yStart = _a.yStart, xEnd = _a.xEnd, yEnd = _a.yEnd;
      for (var y2 = yStart; y2 <= yEnd; y2++) {
        for (var x3 = xStart; x3 <= xEnd; x3++) {
          var entry = this.hash[x3 + "," + y2];
          if (entry) {
            if (simpleTest) {
              var length_7 = entry.length;
              for (var i2 = 0; i2 < length_7; i2++) {
                var object = entry[i2];
                var box = object.AABB;
                if (box.x + box.width > AABB.x && box.x < AABB.x + AABB.width && box.y + box.height > AABB.y && box.y < AABB.y + AABB.height) {
                  results.push(object);
                  callback(object);
                }
              }
            } else {
              results = results.concat(entry);
              for (var _i = 0, entry_1 = entry; _i < entry_1.length; _i++) {
                var object = entry_1[_i];
                callback(object);
              }
            }
            buckets++;
          }
        }
      }
      this.lastBuckets = buckets;
      return results;
    };
    SpatialHash3.prototype.queryCallback = function(AABB, callback, simpleTest) {
      if (simpleTest === void 0) {
        simpleTest = true;
      }
      var _a = this.getBounds(AABB), xStart = _a.xStart, yStart = _a.yStart, xEnd = _a.xEnd, yEnd = _a.yEnd;
      for (var y2 = yStart; y2 <= yEnd; y2++) {
        for (var x3 = xStart; x3 <= xEnd; x3++) {
          var entry = this.hash[x3 + "," + y2];
          if (entry) {
            for (var i2 = 0; i2 < entry.length; i2++) {
              var object = entry[i2];
              if (simpleTest) {
                var AABB_1 = object.AABB;
                if (AABB_1.x + AABB_1.width > AABB_1.x && AABB_1.x < AABB_1.x + AABB_1.width && AABB_1.y + AABB_1.height > AABB_1.y && AABB_1.y < AABB_1.y + AABB_1.height) {
                  if (callback(object)) {
                    return true;
                  }
                }
              } else {
                if (callback(object)) {
                  return true;
                }
              }
            }
          }
        }
      }
      return false;
    };
    SpatialHash3.prototype.stats = function() {
      var visible = 0, count2 = 0;
      var length = this.elements.length;
      for (var i2 = 0; i2 < length; i2++) {
        var object = this.elements[i2];
        visible += object.visible ? 1 : 0;
        count2++;
      }
      for (var _i = 0, _a = this.containers; _i < _a.length; _i++) {
        var list = _a[_i];
        var length_8 = list.children.length;
        for (var i2 = 0; i2 < length_8; i2++) {
          var object = list.children[i2];
          visible += object.visible ? 1 : 0;
          count2++;
        }
      }
      return {
        buckets: this.lastBuckets,
        total: count2,
        visible,
        culled: count2 - visible
      };
    };
    SpatialHash3.prototype.getNumberOfBuckets = function() {
      return Object.keys(this.hash).length;
    };
    SpatialHash3.prototype.getAverageSize = function() {
      var total = 0;
      for (var key in this.hash) {
        total += this.hash[key].length;
      }
      return total / this.getBuckets().length;
    };
    SpatialHash3.prototype.getLargest = function() {
      var largest = 0;
      for (var key in this.hash) {
        if (this.hash[key].length > largest) {
          largest = this.hash[key].length;
        }
      }
      return largest;
    };
    SpatialHash3.prototype.getWorldBounds = function() {
      var xStart = Infinity, yStart = Infinity, xEnd = 0, yEnd = 0;
      for (var key in this.hash) {
        var split = key.split(",");
        var x3 = parseInt(split[0]);
        var y2 = parseInt(split[1]);
        xStart = x3 < xStart ? x3 : xStart;
        yStart = y2 < yStart ? y2 : yStart;
        xEnd = x3 > xEnd ? x3 : xEnd;
        yEnd = y2 > yEnd ? y2 : yEnd;
      }
      return { xStart, yStart, xEnd, yEnd };
    };
    SpatialHash3.prototype.getSparseness = function(AABB) {
      var count2 = 0, total = 0;
      var _a = AABB ? this.getBounds(AABB) : this.getWorldBounds(), xStart = _a.xStart, yStart = _a.yStart, xEnd = _a.xEnd, yEnd = _a.yEnd;
      for (var y2 = yStart; y2 < yEnd; y2++) {
        for (var x3 = xStart; x3 < xEnd; x3++) {
          count2 += this.hash[x3 + "," + y2] ? 1 : 0;
          total++;
        }
      }
      return count2 / total;
    };
    return SpatialHash3;
  }()
);

// src/frontend/game/UIElements.ts
var universeView;
var systemView;
var uiOverlay;
var currentCoordinate;
var fps;
var universeCuller;
var universeGraphics;
var universeGraphicsText;
var systemGraphics;
var systemGraphicsText;
var createUIElements = (app2) => {
  let pointerDownPlace;
  systemView = new et({
    screenWidth: window.innerWidth,
    screenHeight: window.innerHeight,
    worldWidth: 2e3,
    worldHeight: 2e3,
    events: app2.renderer.events
    // the interaction module is important for wheel to work properly when renderer.view is placed or scaled
  });
  systemView.on("pointerdown", (event) => {
    console.log("pointerdown");
    pointerDownPlace = new Point(event.globalX, event.globalY);
  });
  systemView.on("click", (event) => {
    console.log("click");
    if (pointerDownPlace) {
      const distance = Math.abs(pointerDownPlace.x - event.globalX) + Math.abs(pointerDownPlace.y - event.globalY);
      if (distance > 2) {
        console.log("cancelling drag event");
        event.stopPropagation();
      }
    }
  });
  systemGraphics = new Graphics();
  systemView.addChild(systemGraphics);
  systemGraphicsText = new Text({
    text: "",
    style: {
      fontFamily: "sans-serif",
      fontSize: 16,
      //tint: 0x0000FF,
      align: "right"
    }
  });
  systemView.addChild(systemGraphicsText);
  systemView.drag().pinch().wheel().decelerate();
  systemView.visible = false;
  systemView.moveCenter(1e3, 1e3);
  universeView = new et({
    screenWidth: window.innerWidth,
    screenHeight: window.innerHeight,
    worldWidth: totalSize,
    worldHeight: totalSize,
    events: app2.renderer.events
    // the interaction module is important for wheel to work properly when renderer.view is placed or scaled
  });
  universeView.on("pointerdown", (event) => {
    console.log("pointerdown");
    pointerDownPlace = new Point(event.globalX, event.globalY);
  });
  universeView.on("click", (event) => {
    console.log("click");
    if (pointerDownPlace) {
      const distance = Math.abs(pointerDownPlace.x - event.globalX) + Math.abs(pointerDownPlace.y - event.globalY);
      if (distance > 2) {
        console.log("cancelling drag event");
        event.stopPropagation();
      }
    }
  });
  universeView.drag().pinch().wheel().decelerate();
  universeView.moveCenter(totalSize / 2, totalSize / 2);
  const starContainer = new Container();
  starContainer.name = "stars";
  universeView.addChild(starContainer);
  universeCuller = new Simple();
  universeCuller.cull(universeView.getVisibleBounds());
  universeGraphics = new Graphics();
  universeView.addChild(universeGraphics);
  universeGraphicsText = new Text({
    text: "",
    style: {
      fontFamily: "sans-serif",
      fontSize: 16,
      //tint: 0x0000FF,
      align: "right"
    }
  });
  universeView.addChild(universeGraphicsText);
  uiOverlay = new Container();
  const popupOverlay = new Container();
  currentCoordinate = new Text({
    text: "0, 0",
    style: {
      fontFamily: "sans-serif",
      fontSize: 18,
      align: "right"
    }
  });
  currentCoordinate.x = gameWidth - 166;
  currentCoordinate.y = 16;
  currentCoordinate.maxWidth = 150;
  uiOverlay.addChild(currentCoordinate);
  fps = new Text({
    text: "FPS: 60",
    style: {
      fontFamily: "sans-serif",
      fontSize: 18,
      align: "right"
    }
  });
  fps.x = gameWidth - 166;
  fps.y = 40;
  fps.maxWidth = 150;
  uiOverlay.addChild(fps);
  const bgContainer = new TilingSprite(loadedAssets.bgTexture, 4096, 4096);
  app2.stage.addChild(bgContainer);
  app2.stage.addChild(universeView);
  app2.stage.addChild(systemView);
  app2.stage.addChild(uiOverlay);
  app2.stage.addChild(popupOverlay);
};

// src/frontend/game/positionShips.ts
var waypointShips = {};
function resetShipWaypoints() {
  waypointShips = {};
}
var planetOrbitSpeed = 2e4;
function positionWaypoint(waypoint, timeElapsed) {
  let x3, y2;
  if (waypoint.orbitsSymbol) {
    const orbitData = GameState.waypointData[waypoint.orbitsSymbol];
    const orbitDistance = Math.sqrt(Math.pow(waypoint.x, 2) + Math.pow(waypoint.y, 2));
    const orbitalPeriod = orbitDistance * planetOrbitSpeed;
    const currentAngle = (timeElapsed % orbitalPeriod / orbitalPeriod + orbitData.offset) * Math.PI * 2;
    x3 = (Math.abs(systemCoordinates.minX) + Math.cos(currentAngle) * orbitDistance) * systemScale;
    y2 = (Math.abs(systemCoordinates.minY) + Math.sin(currentAngle) * orbitDistance) * systemScale;
    const ownOrbitalPeriod = 60 * 500;
    const ownAngle = (timeElapsed % ownOrbitalPeriod / ownOrbitalPeriod + waypoint.offset) * Math.PI * 2;
    const offsetX = Math.cos(ownAngle) * 60;
    const offsetY = Math.sin(ownAngle) * 60;
    x3 += offsetX;
    y2 += offsetY;
  } else {
    const orbitDistance = Math.sqrt(Math.pow(waypoint.x, 2) + Math.pow(waypoint.y, 2));
    const orbitalPeriod = orbitDistance * planetOrbitSpeed;
    const currentAngle = (timeElapsed % orbitalPeriod / orbitalPeriod + waypoint.offset) * Math.PI * 2;
    x3 = (Math.abs(systemCoordinates.minX) + Math.cos(currentAngle) * orbitDistance) * systemScale;
    y2 = (Math.abs(systemCoordinates.minY) + Math.sin(currentAngle) * orbitDistance) * systemScale;
  }
  return {
    x: x3,
    y: y2
  };
}
function positionShip(ship) {
  let serverX, serverY, navRot, xOffset = 0, yOffset = 0;
  const arrivalOn = new Date(ship.arrivalOn);
  const departureOn = new Date(ship.departureOn);
  if (ship.destinationWaypoint.symbol !== ship.departureWaypoint.symbol && Date.now() < arrivalOn.getTime()) {
    const positionAlongPath = (Date.now() - departureOn.getTime()) / (arrivalOn.getTime() - departureOn.getTime());
    try {
      const from = GameState.waypoints[ship.departureWaypoint.symbol];
      const to = GameState.waypoints[ship.destinationWaypoint.symbol];
      serverX = from.x + (to.x - from.x) * positionAlongPath;
      serverY = from.y + (to.y - from.y) * positionAlongPath;
      navRot = Math.atan2(to.y - from.y, to.x - from.x) + Math.PI / 2;
    } catch (e2) {
      serverX = 0;
      serverY = 0;
      navRot = 0;
    }
  } else {
    const orbitSymbol = ship.currentWaypoint.orbitsSymbol ? ship.currentWaypoint.orbitsSymbol : ship.currentWaypoint.symbol;
    if (waypointShips[orbitSymbol] === void 0) {
      waypointShips[orbitSymbol] = 0;
    } else {
      waypointShips[orbitSymbol]++;
    }
    const curr = GameState.waypoints[ship.currentWaypoint.symbol];
    if (curr) {
      serverX = curr.x;
      serverY = curr.y;
      xOffset = 32 * waypointShips[orbitSymbol];
      yOffset = 80;
    } else {
      serverX = 0;
      serverY = 0;
      navRot = 0;
    }
  }
  const x3 = serverX + xOffset;
  const y2 = serverY + yOffset;
  return {
    x: x3,
    y: y2,
    navRot
  };
}
function positionUniverseShip(ship) {
  let serverX, serverY, navRot, xOffset = 0, yOffset = 0;
  const arrivalOn = new Date(ship.arrivalOn);
  const departureOn = new Date(ship.departureOn);
  const sizeMultiplier = universeView.worldScreenWidth / universeView.screenWidth;
  if (ship.destinationWaypoint.systemSymbol !== ship.departureWaypoint.systemSymbol && Date.now() < arrivalOn.getTime()) {
    const positionAlongPath = (Date.now() - departureOn.getTime()) / (arrivalOn.getTime() - departureOn.getTime());
    const departureSystem = GameState.systems[ship.departureWaypoint.systemSymbol];
    const destinationSystem = GameState.systems[ship.destinationWaypoint.systemSymbol];
    serverX = departureSystem.x + (destinationSystem.x - departureSystem.x) * positionAlongPath;
    serverY = departureSystem.y + (destinationSystem.y - departureSystem.y) * positionAlongPath;
    navRot = Math.atan2(destinationSystem.y - departureSystem.y, destinationSystem.x - departureSystem.x) + Math.PI / 2;
  } else {
    if (waypointShips[ship.currentWaypoint.systemSymbol] === void 0) {
      waypointShips[ship.currentWaypoint.systemSymbol] = 0;
    } else {
      waypointShips[ship.currentWaypoint.systemSymbol]++;
    }
    const currentSystem = GameState.systems[ship.currentWaypoint.systemSymbol];
    serverX = currentSystem.x;
    serverY = currentSystem.y;
    xOffset = 32 * waypointShips[ship.currentWaypoint.systemSymbol] * sizeMultiplier;
    yOffset = 80 * Math.min(sizeMultiplier, 8);
  }
  const x3 = serverX + xOffset;
  const y2 = serverY + yOffset;
  return {
    x: x3,
    y: y2,
    navRot
  };
}

// src/frontend/game/loadSystem.ts
function createShipContainer(ship) {
  const shipGroup = new Container();
  const itemSprite = new Sprite(loadedAssets.spaceshipTextures[ship.frameSymbol] ? loadedAssets.spaceshipTextures[ship.frameSymbol] : loadedAssets.spaceshipTexture);
  itemSprite.name = "ship";
  itemSprite.pivot = {
    x: 32,
    y: 32
  };
  const navSprite = new Sprite(loadedAssets.navArrow);
  navSprite.pivot = {
    x: navSprite.width / 2,
    y: navSprite.height / 2
  };
  navSprite.name = "nav";
  navSprite.visible = false;
  shipGroup.addChild(navSprite);
  itemSprite.scale = { x: 0.5, y: 0.5 };
  const shipPosition = positionShip(ship);
  shipGroup.x = shipPosition.x;
  shipGroup.y = shipPosition.y;
  if (ship.agent !== GameState.agent.symbol) {
    itemSprite.tint = 14522777;
  }
  shipGroup.addChild(itemSprite);
  const text = new Text({
    text: ship.symbol + " - " + ship.role,
    renderMode: "bitmap",
    style: {
      fontFamily: "sans-serif",
      fontSize: 16,
      align: "right"
    }
  });
  text.visible = false;
  text.x = 0;
  text.y = 32;
  shipGroup.addChild(text);
  makeInteractiveAndSelectable(shipGroup, {
    onMouseOver: () => {
      text.visible = true;
    },
    onMouseOut: () => {
      text.visible = false;
    },
    onSelect: {
      type: "ship",
      symbol: ship.symbol
    }
  });
  return shipGroup;
}
function createOrbitGraphics(item) {
  const orbit = new Graphics();
  orbit.lineStyle({
    width: 2,
    color: 4473924
  });
  orbit.drawCircle(Math.abs(systemCoordinates.minX) * systemScale, Math.abs(systemCoordinates.minY) * systemScale, Math.sqrt(Math.pow(item.x * systemScale, 2) + Math.pow(item.y * systemScale, 2)));
  return orbit;
}
function addTraitIcons(item, container) {
  let xOffset = 0;
  item.traits.forEach((trait) => {
    if (trait.symbol === "MARKETPLACE") {
      const sprite = new Sprite(loadedAssets.market);
      sprite.pivot = {
        x: 32,
        y: 32
      };
      sprite.scale = { x: 0.25, y: 0.25 };
      sprite.x = xOffset - 16;
      sprite.y = 24;
      container.addChild(sprite);
      xOffset += 16;
    }
    if (trait.symbol === "SHIPYARD") {
      const sprite = new Sprite(loadedAssets.shipyard);
      sprite.pivot = {
        x: 32,
        y: 32
      };
      sprite.scale = { x: 0.25, y: 0.24 };
      sprite.x = xOffset - 16;
      sprite.y = 24;
      container.addChild(sprite);
      xOffset += 16;
    }
  });
}
function createSystemItem(data, scale3 = 1, index = 0) {
  const orbitingGroup = new Container();
  let orbitingSprite;
  orbitingSprite = new Sprite(loadedAssets.planetsheet.textures[`planets/tile/${data.waypoint.type}.png`]);
  orbitingSprite.pivot = {
    x: 32,
    y: 32
  };
  orbitingSprite.scale = { x: scale3, y: scale3 };
  if (data.parent) {
    orbitingGroup.x = data.parent.x * systemScale + 32 + Math.abs(systemCoordinates.minX) * systemScale;
    orbitingGroup.y = data.parent.y * systemScale + 48 + 64 * index + Math.abs(systemCoordinates.minY) * systemScale;
  } else {
    orbitingGroup.x = (data.waypoint.x + Math.abs(systemCoordinates.minX)) * systemScale;
    orbitingGroup.y = (data.waypoint.y + Math.abs(systemCoordinates.minY)) * systemScale;
  }
  orbitingGroup.addChild(orbitingSprite);
  const orbitingText = new Text({
    text: data.waypoint.symbol + " - " + data.waypoint.type,
    renderMode: "bitmap",
    style: {
      fontFamily: "sans-serif",
      fontSize: 16,
      align: "right"
    }
  });
  orbitingText.x = 24;
  orbitingText.y = -8;
  orbitingText.visible = false;
  orbitingGroup.addChild(orbitingText);
  makeInteractiveAndSelectable(orbitingGroup, {
    onMouseOver: () => {
      console.log("hovered", data.waypoint);
      GameState.hoveredWaypoint = data.waypoint;
      orbitingText.visible = true;
    },
    onMouseOut: () => {
      GameState.hoveredWaypoint = void 0;
      orbitingText.visible = false;
    },
    onSelect: {
      type: "waypoint",
      symbol: data.waypoint.symbol
    },
    onOrder: [
      {
        name: "navigate",
        withSelection: "ship",
        action: async (selectedSymbol) => {
          const res = await trpc.instructNavigate.mutate({
            shipSymbol: selectedSymbol,
            waypointSymbol: data.waypoint.symbol
          });
          GameState.shipData[res.symbol] = res;
          console.log("updated state for ship " + res.symbol);
        }
      }
    ]
  });
  addTraitIcons(data.waypoint, orbitingGroup);
  return orbitingGroup;
}
function clearSystem() {
  systemView.removeChildren();
  systemView.addChild(systemGraphics);
  systemView.addChild(systemGraphicsText);
}
function showSystemView() {
  universeView.visible = false;
  systemView.visible = true;
  GameState.currentView = "system";
}
async function loadSystem(systemSymbol, resetCamera = true) {
  Promise.all([
    trpc.shipsForSystem.query({
      system: systemSymbol
    }),
    trpc.waypointsForSystem.query({
      system: systemSymbol
    })
  ]).then(([ships, waypoints]) => {
    const starData = GameState.systemData[systemSymbol];
    ships.forEach((ship) => {
      GameState.shipData[ship.symbol] = ship;
    });
    waypoints.forEach((waypoint) => {
      GameState.waypointData[waypoint.symbol] = {
        ...waypoint,
        offset: Math.random()
      };
    });
    clearSystem();
    showSystemView();
    GameState.currentSystem = systemSymbol;
    systemCoordinates.minX = 0;
    systemCoordinates.minY = 0;
    waypoints.filter((item) => !item.orbitsSymbol).forEach((item) => {
      if (item.x < systemCoordinates.minX) {
        systemCoordinates.minX = item.x;
      }
      if (item.y < systemCoordinates.minY) {
        systemCoordinates.minY = item.y;
      }
    });
    let texture = loadedAssets.sheet.textures[`planets/tile/${starData.type}.png`];
    const star = new Sprite(texture);
    star.x = Math.abs(systemCoordinates.minX) * systemScale;
    star.y = Math.abs(systemCoordinates.minY) * systemScale;
    star.pivot = {
      x: 32,
      y: 32
    };
    systemView.addChild(star);
    resetShipWaypoints();
    GameState.systemShips = {};
    GameState.waypoints = {};
    Object.values(GameState.shipData).filter((ship) => ship.currentWaypoint.systemSymbol === starData.symbol).forEach((data) => {
      const ship = data;
      const shipGroup = createShipContainer(ship);
      systemView.addChild(shipGroup);
      GameState.systemShips[ship.symbol] = shipGroup;
    });
    waypoints.filter((item) => !item.orbitsSymbol && item.type !== "MOON" && item.type !== "ORBITAL_STATION").forEach((item) => {
      systemView.addChild(createOrbitGraphics(item));
      const itemGroup = createSystemItem({
        waypoint: item
      });
      waypoints.filter((orbitingThing) => orbitingThing.orbitsSymbol === item.symbol || orbitingThing.symbol !== item.symbol && orbitingThing.x == item.x && orbitingThing.y == item.y).forEach((orbitingThing, index) => {
        const orbitingGroup = createSystemItem({
          waypoint: orbitingThing,
          parent: item
        }, 0.5, index);
        GameState.waypoints[orbitingThing.symbol] = orbitingGroup;
        systemView.addChild(orbitingGroup);
      });
      GameState.waypoints[item.symbol] = itemGroup;
      systemView.addChild(itemGroup);
    });
    if (resetCamera) {
      systemView.moveCenter({
        x: Math.abs(systemCoordinates.minX) * systemScale,
        y: Math.abs(systemCoordinates.minY) * systemScale
      });
    }
  });
}

// src/common/lib/getDistance.ts
var getDistance = (pos1, pos2) => {
  return Math.sqrt(Math.pow(pos1.x - pos2.x, 2) + Math.pow(pos1.y - pos2.y, 2));
};

// src/frontend/game/util.ts
var convertToDisplayCoordinates = (position) => {
  return {
    x: (position.x + Math.abs(universeCoordinates.minX)) / (universeCoordinates.maxX - universeCoordinates.minX) * totalSize,
    y: (position.y + Math.abs(universeCoordinates.minY)) / (universeCoordinates.maxY - universeCoordinates.minY) * totalSize
  };
};

// src/frontend/game/highlightmodes.ts
var stringToColour = function(str) {
  var hash = 0;
  for (var i2 = 0; i2 < str.length; i2++) {
    hash = str.charCodeAt(i2) + ((hash << 5) - hash);
  }
  var colour = "#";
  for (var i2 = 0; i2 < 3; i2++) {
    var value = hash >> i2 * 8 & 255;
    colour += ("00" + value.toString(16)).substr(-2);
  }
  return colour;
};
var highlightmodes = {
  Factions: (graphics) => {
    for (const starData of Object.values(GameState.systemData)) {
      if (starData.majorityFaction) {
        const isHeadquarters = GameState.factions[starData.majorityFaction].headquartersSymbol.includes(starData.symbol);
        const displayCoords = convertToDisplayCoordinates(starData);
        graphics.beginFill(stringToColour(starData.majorityFaction));
        graphics.drawCircle(displayCoords.x, displayCoords.y, isHeadquarters ? 4500 : 1500);
      }
    }
    const colorMatrix = new AlphaFilter();
    colorMatrix.alpha = 0.1;
    graphics.filters = [colorMatrix];
  },
  Shipyards: (graphics) => {
    for (const starData of Object.values(GameState.systemData)) {
      if (starData.hasShipyard) {
        const displayCoords = convertToDisplayCoordinates(starData);
        graphics.beginFill(255);
        graphics.drawCircle(displayCoords.x, displayCoords.y, 1500);
      }
    }
    const colorMatrix = new AlphaFilter();
    colorMatrix.alpha = 0.1;
    graphics.filters = [colorMatrix];
  },
  "Market Update": (graphics) => {
    for (const shipData of Object.values(GameState.shipData)) {
      if (shipData.currentBehavior === "EXPLORE_MARKETS" || shipData.currentBehavior === "UPDATE_MARKETS") {
        const homeSystem = GameState.systemData[shipData.homeSystemSymbol];
        const displayCoords = convertToDisplayCoordinates(homeSystem);
        const range = shipData.behaviorRange * scale.universe;
        graphics.beginFill(6750054);
        graphics.drawRect(displayCoords.x - range, displayCoords.y - range, range * 2, range * 2);
      }
    }
    const colorMatrix = new AlphaFilter();
    colorMatrix.alpha = 0.1;
    graphics.filters = [colorMatrix];
  }
};

// src/frontend/game/loadUniverse.ts
var addTraitIcons2 = (item, container) => {
  let xOffset = 0;
  if (item.hasMarket) {
    const sprite = new Sprite(loadedAssets.market);
    sprite.pivot = {
      x: 32,
      y: 32
    };
    sprite.scale = { x: 0.25, y: 0.25 };
    sprite.x = xOffset - 16;
    sprite.y = 24;
    container.addChild(sprite);
    xOffset += 16;
  }
  if (item.hasShipyard) {
    const sprite = new Sprite(loadedAssets.shipyard);
    sprite.pivot = {
      x: 32,
      y: 32
    };
    sprite.scale = { x: 0.25, y: 0.24 };
    sprite.x = xOffset - 16;
    sprite.y = 24;
    container.addChild(sprite);
    xOffset += 16;
  }
  if (item.hasBelt) {
    const sprite = new Sprite(loadedAssets.asteroidBelt);
    sprite.pivot = {
      x: 32,
      y: 32
    };
    sprite.scale = { x: 0.25, y: 0.24 };
    sprite.x = xOffset - 16;
    sprite.y = 24;
    container.addChild(sprite);
    xOffset += 16;
  }
  if (item.hasJumpGate) {
    const sprite = new Sprite(loadedAssets.jumpgate);
    sprite.pivot = {
      x: 32,
      y: 32
    };
    sprite.scale = { x: 0.25, y: 0.24 };
    sprite.x = xOffset - 16;
    sprite.y = 24;
    container.addChild(sprite);
    xOffset += 16;
  }
  if (item.hasStation && !item.hasShipyard) {
    const sprite = new Sprite(loadedAssets.station);
    sprite.pivot = {
      x: 32,
      y: 32
    };
    sprite.scale = { x: 0.25, y: 0.24 };
    sprite.x = xOffset - 16;
    sprite.y = 24;
    container.addChild(sprite);
    xOffset += 16;
  }
  if (item.hasUncharted) {
    const sprite = new Sprite(loadedAssets.treasure);
    sprite.pivot = {
      x: 32,
      y: 32
    };
    sprite.scale = { x: 0.25, y: 0.24 };
    sprite.x = xOffset - 16;
    sprite.y = 24;
    container.addChild(sprite);
    xOffset += 16;
  }
};
function createStar(starData) {
  let texture = loadedAssets.sheet.textures[`planets/tile/${starData.type}.png`];
  const star = new Sprite(texture);
  star.pivot = {
    x: 32,
    y: 32
  };
  const text = new Text({
    text: starData.name + "\n(" + starData.symbol + ")",
    renderMode: "bitmap",
    style: {
      fontFamily: "sans-serif",
      fontSize: 18,
      align: "left"
    }
  });
  text.name = "label";
  text.x = 0;
  text.y = 40;
  const starContainer = new Container();
  starContainer.addChild(star);
  starContainer.addChild(text);
  addTraitIcons2(starData, starContainer);
  makeInteractiveAndSelectable(starContainer, {
    onMouseOut: () => {
      GameState.hoveredSystem = void 0;
    },
    onMouseOver: () => {
      GameState.hoveredSystem = starData;
    },
    onOrder: [
      {
        name: "Travel",
        withSelection: "ship",
        isAvailable: async () => {
          return true;
        },
        action: async () => {
          await trpc.orderTravel.mutate({
            shipSymbol: GameState.selected.symbol,
            systemSymbol: starData.symbol
          });
        }
      },
      {
        name: "Warp",
        withSelection: "ship",
        isAvailable: async () => {
          const shipData = GameState.shipData[GameState.selected.symbol];
          const warpRange = shipData.modules.find((m3) => m3.effectName === "WARP_DRIVE")?.value;
          const currentSystem = GameState.systemData[shipData.currentWaypoint.systemSymbol];
          return getDistance(currentSystem, GameState.hoveredSystem) < warpRange;
        },
        action: async () => {
          const waypoints = await trpc.waypointsForSystem.query({
            system: starData.symbol
          });
          console.log("waypoints", waypoints);
          const bestWaypoint = waypoints.find((w2) => w2.traits.find((t2) => t2.symbol === "MARKETPLACE"))?.symbol ?? waypoints[0].symbol;
          if (bestWaypoint) {
            console.log("warping to ", bestWaypoint);
            const res = await trpc.instructWarp.mutate({
              shipSymbol: GameState.selected.symbol,
              waypointSymbol: bestWaypoint
            });
            GameState.shipData[res.symbol] = res;
          } else {
            alert("Cannot warp to system without waypoints, nothing to target");
          }
        }
      },
      {
        name: "Jump using gate",
        withSelection: "ship",
        isAvailable: async () => {
          const shipData = GameState.shipData[GameState.selected.symbol];
          const currentSystemWaypoints = await trpc.waypointsForSystem.query({
            system: shipData.currentWaypoint.systemSymbol
          });
          const jumpGate = currentSystemWaypoints.find((wp) => wp.type === "JUMP_GATE" && wp.symbol === shipData.currentWaypoint.symbol);
          console.log("deve", { currentSystemWaypoints, jumpGate });
          return !!jumpGate;
        },
        action: async () => {
          const res = await trpc.instructJump.mutate({
            shipSymbol: GameState.selected.symbol,
            systemSymbol: starData.symbol
          });
          GameState.shipData[res.symbol] = res;
        }
      },
      {
        name: "Jump",
        withSelection: "ship",
        isAvailable: async () => {
          const shipData = GameState.shipData[GameState.selected.symbol];
          const jumpRange = shipData.modules.find((m3) => m3.effectName === "JUMP_DRIVE")?.value;
          const currentSystem = GameState.systemData[shipData.currentWaypoint.systemSymbol];
          return !!GameState.selected?.symbol && getDistance(currentSystem, GameState.hoveredSystem) < jumpRange;
        },
        action: async () => {
          const res = await trpc.instructJump.mutate({
            shipSymbol: GameState.selected.symbol,
            systemSymbol: starData.symbol
          });
          GameState.shipData[res.symbol] = res;
        }
      },
      {
        name: "Set behavior",
        withSelection: "ship",
        isAvailable: async () => {
          return true;
        },
        action: async (selectedSymbol) => {
          behaviorWindow.show();
          behaviorWindow.setHome(starData.symbol);
          deselectListeners.once("deselect", () => {
            behaviorWindow.hide();
          });
        }
      }
    ]
  });
  starContainer.on("click", () => {
    loadSystem(starData.symbol);
  });
  const displayCoords = convertToDisplayCoordinates(starData);
  starContainer.x = displayCoords.x;
  starContainer.y = displayCoords.y;
  return starContainer;
}
var loadUniverse = async () => {
  const references = {};
  const systems3 = await trpc.getSystems.query();
  for (const starData of systems3) {
    GameState.systemData[starData.symbol] = starData;
    if (starData.x < universeCoordinates.minX)
      universeCoordinates.minX = starData.x;
    if (starData.x > universeCoordinates.maxX)
      universeCoordinates.maxX = starData.x;
    if (starData.y < universeCoordinates.minY)
      universeCoordinates.minY = starData.y;
    if (starData.y > universeCoordinates.maxY)
      universeCoordinates.maxY = starData.y;
  }
  GameState.systems = {};
  scale.universe = totalSize / (universeCoordinates.maxX - universeCoordinates.minX);
  const influenceGraphics = new Graphics();
  highlightmodes.Factions(influenceGraphics);
  influenceGraphics.name = "highlight";
  universeView.addChild(influenceGraphics);
  const jumpGraphics = new Graphics();
  for (const starData of systems3) {
    const jumpGate = starData.hasJumpGate;
    if (jumpGate && starData.jumpgateRange) {
      const validJumpTargets = systems3.filter((s2) => getDistance(s2, starData) <= starData.jumpgateRange && s2.hasJumpGate && s2.symbol !== starData.symbol);
      validJumpTargets.forEach((jumpTarget) => {
        const displayCoords = convertToDisplayCoordinates(starData);
        const targetCoords = convertToDisplayCoordinates(jumpTarget);
        jumpGraphics.stroke({
          width: starData.jumpgateRange / 250,
          color: 10066227,
          alpha: 0.1
        });
        jumpGraphics.moveTo(displayCoords.x, displayCoords.y);
        jumpGraphics.lineTo(targetCoords.x, targetCoords.y);
        jumpGraphics.closePath();
      });
    }
  }
  universeView.addChild(jumpGraphics);
  const routeGraphics = new Graphics();
  routeGraphics.name = "route";
  universeView.addChild(routeGraphics);
  const homeSystemGraphics = new Graphics();
  homeSystemGraphics.name = "homeSystem";
  universeView.addChild(homeSystemGraphics);
  const starsCont = new Container();
  for (const starData of systems3) {
    const starContainer = createStar(starData);
    GameState.systems[starData.symbol] = starContainer;
    starsCont.addChild(starContainer);
    references[starData.symbol] = starContainer;
  }
  universeView.addChild(starsCont);
  universeCuller.addList(starsCont.children);
  resetShipWaypoints();
  GameState.universeShips = {};
  Object.values(GameState.shipData).forEach((ship) => {
    const shipGroup = new Container();
    const itemSprite = new Sprite(loadedAssets.spaceshipTextures[ship.frameSymbol] ? loadedAssets.spaceshipTextures[ship.frameSymbol] : loadedAssets.spaceshipTexture);
    itemSprite.name = "ship";
    itemSprite.pivot = {
      x: 32,
      y: 32
    };
    const navSprite = new Sprite(loadedAssets.navArrow);
    navSprite.pivot = {
      x: navSprite.width / 2,
      y: navSprite.height / 2
    };
    navSprite.name = "nav";
    navSprite.visible = false;
    shipGroup.addChild(navSprite);
    itemSprite.scale = { x: 0.5, y: 0.5 };
    const shipPosition = positionUniverseShip(ship);
    shipGroup.x = shipPosition.x;
    shipGroup.y = shipPosition.y;
    shipGroup.addChild(itemSprite);
    const text = new BitmapText(ship.symbol + " - " + ship.role, {
      fontName: "sans-serif",
      fontSize: 16,
      align: "right"
    });
    text.visible = false;
    text.x = 0;
    text.y = 32;
    shipGroup.addChild(text);
    makeInteractiveAndSelectable(shipGroup, {
      onMouseOver: () => {
        text.visible = true;
      },
      onMouseOut: () => {
        text.visible = false;
      },
      onSelect: {
        type: "ship",
        symbol: ship.symbol
      }
    });
    universeView.addChild(shipGroup);
    GameState.universeShips[ship.symbol] = shipGroup;
  });
  const graphics = new Graphics();
  graphics.lineStyle({
    width: 15,
    color: 30719
  });
  const multiFactor = 5e3 / (universeCoordinates.maxX - universeCoordinates.minX) * totalSize;
  const commandShip = Object.values(GameState.shipData).find((ship) => ship.role === "COMMAND");
  const commandShipLocation = commandShip?.currentWaypoint.systemSymbol;
  universeView.addChild(graphics);
  if (commandShipLocation) {
    universeView.moveCenter(references[commandShipLocation].x, references[commandShipLocation].y);
  }
  return {
    systems: references
  };
};

// src/frontend/game/worldCoordinateToOriginal.ts
var worldCoordinateToOriginal = (point) => {
  const multiFactor = (universeCoordinates.maxX - universeCoordinates.minX) / totalSize;
  return {
    x: Math.round(universeCoordinates.minX + point.x * multiFactor),
    y: Math.round(universeCoordinates.minY + point.y * multiFactor)
  };
};
var systemCoordinateToOriginal = (point) => {
  return {
    x: Math.round(systemCoordinates.minX + point.x / systemScale),
    y: Math.round(systemCoordinates.minY + point.y / systemScale)
  };
};

// src/frontend/game/loadPlayerData.ts
async function loadPlayerData() {
  await trpc.updateAgentInfo.mutate();
  const ships = await trpc.getMyShips.query();
  console.log("my ships", ships);
  ships.forEach((ship) => {
    GameState.shipData[ship.symbol] = ship;
  });
  await updateCredits();
  const factions = await trpc.getFactions.query();
  GameState.factions = {};
  factions.forEach((faction) => {
    GameState.factions[faction.symbol] = faction;
  });
}
async function updateCredits() {
  const agent = await trpc.getAgentInfo.query();
  GameState.agent = agent;
}

// src/frontend/game/targetingLine.ts
var clearGraphics = () => {
  universeGraphics.clear();
  systemGraphics.clear();
  universeGraphicsText.text = "";
  systemGraphicsText.text = "";
};
var warpColor = 4491229;
var jumpColor = 10066227;
var universeTargetingLine = (sizeMultiplier) => {
  if (GameState.hoveredSystem && GameState.currentView == "universe" && GameState.selected?.type === "ship") {
    const selectedShip = GameState.shipData[GameState.selected?.symbol];
    const warpRange = selectedShip.modules.find((m3) => m3.effectName === "WARP_DRIVE")?.value;
    const jumpRange = selectedShip.modules.find((m3) => m3.effectName === "JUMP_DRIVE")?.value;
    const jumpGateRange = GameState.waypointData[selectedShip.currentWaypoint.symbol]?.jumpgate?.range;
    const currentSystemSymbol = GameState.shipData[GameState.selected.symbol].currentWaypoint.systemSymbol;
    const hoveredSystemSymbol = GameState.hoveredSystem.symbol;
    const fromContainer = GameState.systems[currentSystemSymbol];
    const toContainer = GameState.systems[hoveredSystemSymbol];
    if (!fromContainer || !toContainer)
      return;
    const fromData = GameState.systemData[currentSystemSymbol];
    const toData = GameState.systemData[hoveredSystemSymbol];
    const distance = Math.round(Math.sqrt(Math.pow(fromData.x - toData.x, 2) + Math.pow(fromData.y - toData.y, 2)));
    if (jumpRange && distance < (jumpGateRange ?? jumpRange)) {
      universeGraphics.stroke({
        color: jumpColor,
        width: sizeMultiplier
      });
    } else if (warpRange && distance < warpRange) {
      universeGraphics.stroke({
        color: warpColor,
        width: sizeMultiplier
      });
    } else {
      universeGraphics.stroke({
        color: 16711680,
        width: sizeMultiplier
      });
    }
    universeGraphics.moveTo(fromContainer.x, fromContainer.y);
    universeGraphics.lineTo(toContainer.x, toContainer.y);
    universeGraphicsText.x = (fromContainer.x + toContainer.x) / 2;
    universeGraphicsText.y = (fromContainer.y + toContainer.y) / 2 + 120;
    universeGraphicsText.text = `Distance ${distance}`;
    universeGraphicsText.scale = { x: sizeMultiplier, y: sizeMultiplier };
  }
  if (GameState.currentView === "universe" && GameState.selected?.type === "ship") {
    const currentSystemSymbol = GameState.shipData[GameState.selected.symbol].currentWaypoint.systemSymbol;
    const fromContainer = GameState.systems[currentSystemSymbol];
    const selectedShip = GameState.shipData[GameState.selected?.symbol];
    const warpRange = selectedShip.modules.find((m3) => m3.effectName === "WARP_DRIVE")?.value;
    const jumpRange = selectedShip.modules.find((m3) => m3.effectName === "JUMP_DRIVE")?.value;
    const jumpGateRange = GameState.waypointData[selectedShip.currentWaypoint.symbol]?.jumpgate?.range;
    console.log("jumpgate range", jumpGateRange);
    if (warpRange) {
      universeGraphics.stroke({
        color: warpColor,
        width: sizeMultiplier
      });
      universeGraphics.circle(fromContainer.x, fromContainer.y, warpRange * scale.universe);
    }
    if (jumpRange || jumpGateRange) {
      universeGraphics.stroke({
        color: jumpColor,
        width: sizeMultiplier
      });
      universeGraphics.circle(fromContainer.x, fromContainer.y, (jumpGateRange ?? jumpRange) * scale.universe);
    }
  }
};
var systemTargetingLine = () => {
  if (GameState.hoveredWaypoint && GameState.selected?.type === "ship" && GameState.hoveredWaypoint.symbol !== GameState.shipData[GameState.selected.symbol].currentWaypoint.symbol) {
    console.log("shiptargeting");
    systemGraphics.clear();
    systemGraphics.stroke({
      color: 5583871,
      width: 10
    });
    const currentWaypointSymbol = GameState.shipData[GameState.selected.symbol].currentWaypoint.symbol;
    const hoveredWaypointSymbol = GameState.hoveredWaypoint.symbol;
    const fromContainer = GameState.waypoints[currentWaypointSymbol];
    const toContainer = GameState.waypoints[hoveredWaypointSymbol];
    if (!fromContainer || !toContainer)
      return;
    systemGraphics.moveTo(fromContainer.x, fromContainer.y);
    systemGraphics.lineTo(toContainer.x, toContainer.y);
    const fromData = GameState.waypointData[currentWaypointSymbol];
    const toData = GameState.waypointData[hoveredWaypointSymbol];
    systemGraphicsText.x = (toContainer.x - fromContainer.x) / 2;
    systemGraphicsText.y = (toContainer.y - fromContainer.y) / 2 + 120;
    systemGraphicsText.text = `Distance ${Math.round(Math.sqrt(Math.pow(fromData.x - toData.x, 2) + Math.pow(fromData.y - toData.y, 2)))}`;
  }
};

// src/frontend/game/application.ts
var app = new Application();
app.init();

// src/frontend/index.ts
if (!localStorage.getItem("agent-token")) {
  const agentToken = prompt("Please enter your agent token");
  localStorage.setItem("agent-token", agentToken);
}
document.body.appendChild(app.canvas);
app.view.addEventListener("contextmenu", (e2) => {
  e2.preventDefault();
});
app.stage.interactive = true;
app.stage.hitArea = app.screen;
app.stage.on("click", (event) => {
  console.log(event);
  deselectListeners.emit("deselect");
  GameState.selected = void 0;
});
await loadAssets();
await createUIElements(app);
await loadPlayerData();
var loadedUniverse = await loadUniverse();
var format = Intl.NumberFormat("en");
var lastRefresh = Date.now();
var hidingLabels = false;
var currentRoute;
trpc.event.subscribe(void 0, {
  onData: (data) => {
    console.log("event", data);
    if (data.type == "NAVIGATE") {
      GameState.shipData[data.data.symbol] = data.data;
    }
  }
});
app.ticker.add((dt) => {
  const sizeMultiplier = Math.min(universeView.worldScreenWidth / universeView.screenWidth, 20);
  const shipSizeMultiplier = universeView.worldScreenWidth / universeView.screenWidth;
  credits.displayObject.bitmapText.text = `${format.format(GameState.agent.credits)}`;
  if (GameState.currentView == "universe") {
    Object.values(loadedUniverse.systems).forEach((ref) => {
      ref.scale = { x: sizeMultiplier, y: sizeMultiplier };
    });
    if (!hidingLabels && shipSizeMultiplier > 15) {
      hidingLabels = true;
      Object.values(loadedUniverse.systems).forEach((ref) => {
        ref.getChildByName("label").visible = false;
        ref.interactive = false;
      });
    } else if (hidingLabels && shipSizeMultiplier < 15) {
      hidingLabels = false;
      Object.values(loadedUniverse.systems).forEach((ref) => {
        ref.getChildByName("label").visible = true;
        ref.interactive = true;
      });
    }
    const worldCoordinates = worldCoordinateToOriginal(universeView.toWorld(app.renderer.plugins.interaction.rootPointerEvent.offset));
    currentCoordinate.text = worldCoordinates.x + ", " + worldCoordinates.y;
    resetShipWaypoints();
    Object.keys(GameState.universeShips).forEach((shipKey) => {
      const shipData = GameState.shipData[shipKey];
      const shipContainer = GameState.universeShips[shipKey];
      shipContainer.scale = { x: shipSizeMultiplier, y: shipSizeMultiplier };
      const shipPosition = positionUniverseShip(shipData);
      shipContainer.x = shipPosition.x;
      shipContainer.y = shipPosition.y;
      const nav = shipContainer.getChildByName("nav");
      if (nav) {
        if (shipPosition.navRot) {
          nav.visible = true;
          shipContainer.getChildByName("ship").rotation = shipPosition.navRot;
          shipContainer.getChildByName("nav").rotation = shipPosition.navRot;
        } else {
          nav.visible = false;
          shipContainer.getChildByName("ship").rotation = 0;
          shipContainer.getChildByName("nav").rotation = 0;
        }
      }
      if (shipData.navStatus === "IN_TRANSIT" && new Date(shipData.arrivalOn).getTime() < Date.now()) {
        shipData.navStatus = "IN_ORBIT";
      }
    });
  } else {
    const systemCoordinate = systemCoordinateToOriginal(systemView.toWorld(app.renderer.plugins.interaction.rootPointerEvent.offset));
    currentCoordinate.text = systemCoordinate.x + ", " + systemCoordinate.y;
    Object.keys(GameState.waypoints).forEach((waypointSymbol) => {
      const waypointItem = GameState.waypoints[waypointSymbol];
      const waypointData = GameState.waypointData[waypointSymbol];
      const newPosition = positionWaypoint(waypointData, Date.now());
      waypointItem.x = newPosition.x;
      waypointItem.y = newPosition.y;
    });
    resetShipWaypoints();
    Object.keys(GameState.systemShips).forEach((shipKey) => {
      const shipData = GameState.shipData[shipKey];
      const shipContainer = GameState.systemShips[shipKey];
      const shipPosition = positionShip(shipData);
      shipContainer.x = shipPosition.x;
      shipContainer.y = shipPosition.y;
      const nav = shipContainer.getChildByName("nav");
      if (nav) {
        if (shipPosition.navRot) {
          nav.visible = true;
          shipContainer.getChildByName("ship").rotation = shipPosition.navRot;
          shipContainer.getChildByName("nav").rotation = shipPosition.navRot;
        } else {
          nav.visible = false;
          shipContainer.getChildByName("ship").rotation = 0;
          shipContainer.getChildByName("nav").rotation = 0;
        }
      }
      if (shipData.navStatus === "IN_TRANSIT" && new Date(shipData.arrivalOn).getTime() < Date.now()) {
        shipData.navStatus = "IN_ORBIT";
      }
    });
  }
  clearGraphics();
  universeTargetingLine(sizeMultiplier);
  systemTargetingLine();
  const homeGraphics = universeView.getChildByName("homeSystem");
  if (GameState.selected) {
    if (GameState.selected.type === "ship") {
      const shipInfo = GameState.shipData[GameState.selected.symbol];
      cruiseModeSelect.displayObject.visible = true;
      if (shipInfo.flightMode && cruiseModeSelect.selectedValue !== shipInfo.flightMode) {
        cruiseModeSelect.setSelectedValue(shipInfo.flightMode);
      }
      const cooldownTime = new Date(shipInfo.reactorCooldownOn).getTime();
      const cooldownValue = cooldownTime > Date.now() ? Math.round((cooldownTime - Date.now()) / 1e3) + "s" : "Ready";
      const navTime = new Date(shipInfo.arrivalOn).getTime();
      const arrivalValue = navTime > Date.now() ? Math.round((navTime - Date.now()) / 1e3) + "s" : "Ready";
      if (GameState.agent.symbol === shipInfo.agent) {
        entityInfo.displayObject.bitmapText.text = `Entity Information
Symbol: ${shipInfo.symbol}
Location: ${shipInfo.currentWaypoint.symbol}
Fuel: ${shipInfo.fuelAvailable}/${shipInfo.fuelCapacity}
Cargo: ${shipInfo.cargoUsed}/${shipInfo.cargoCapacity}
Nav Status: ${shipInfo.navStatus} ${arrivalValue}
Reactor Cooldown: ${cooldownValue}
Action: ${shipInfo.overalGoal}`;
      } else {
        entityInfo.displayObject.bitmapText.text = `Entity Information
Symbol: ${shipInfo.symbol}
Location: ${shipInfo.currentWaypoint.symbol}
Owner: ${shipInfo.agent}
Nav Status: ${shipInfo.navStatus} ${arrivalValue}
Last update: ${Math.round((Date.now() - new Date(shipInfo.updatedAt).getTime()) / 1e3)}s ago`;
      }
      if (GameState.hoveredSystem) {
        if (currentRoute != GameState.hoveredSystem + GameState.selected.symbol) {
          currentRoute = GameState.hoveredSystem + GameState.selected.symbol;
          const route = trpc.getRoute.query({
            fromSystemSymbol: shipInfo.currentSystemSymbol,
            toSystemSymbol: GameState.hoveredSystem.symbol
          }).then((data) => {
            const graphics = universeView.getChildByName("route");
            graphics.clear();
            data.finalPath.forEach((item) => {
              const fromSystem = GameState.systemData[item.source];
              const toSystem = GameState.systemData[item.target];
              const displayCoords = convertToDisplayCoordinates(fromSystem);
              const targetCoords = convertToDisplayCoordinates(toSystem);
              graphics.lineStyle({
                width: 10,
                color: 65280,
                alpha: 0.25
              });
              graphics.moveTo(displayCoords.x, displayCoords.y);
              graphics.lineTo(targetCoords.x, targetCoords.y);
              graphics.closePath();
            });
          });
        }
      } else {
        currentRoute = "";
        const graphics = universeView.getChildByName("route");
        graphics.clear();
      }
      if (GameState.currentView == "universe" && shipInfo.currentBehavior) {
        homeGraphics.clear();
        const homeSystem = GameState.systemData[shipInfo.homeSystemSymbol];
        const shipCoordinates = GameState.universeShips[shipInfo.symbol].position;
        const displayCoordinates = convertToDisplayCoordinates(homeSystem);
        homeGraphics.lineStyle({
          width: 10 * sizeMultiplier,
          color: 65280,
          alpha: 0.5
        });
        homeGraphics.moveTo(shipCoordinates.x, shipCoordinates.y);
        homeGraphics.lineTo(displayCoordinates.x, displayCoordinates.y);
        homeGraphics.closePath();
        homeGraphics.lineStyle({
          width: 10 * sizeMultiplier,
          color: 16777215,
          alpha: 0.5
        });
        const range = shipInfo.behaviorRange * scale.universe;
        homeGraphics.drawRect(displayCoordinates.x - range, displayCoordinates.y - range, range * 2, range * 2);
        homeGraphics.closePath();
      } else {
        homeGraphics.clear();
      }
    } else if (GameState.selected.type === "waypoint") {
      const waypointInfo = GameState.waypointData[GameState.selected.symbol];
      entityInfo.displayObject.bitmapText.text = `Entity Information
Symbol: ${GameState.selected.symbol}
Kind: ${waypointInfo.type}
Traits: ${waypointInfo.traits.length == 0 ? "UNKNOWN" : waypointInfo.traits.map((t2) => t2.name).join(", ")}
Faction: ${waypointInfo.factionSymbol}
Chart: ${waypointInfo.chartSubmittedBy ? `${waypointInfo.chartSubmittedBy} at ${waypointInfo.chartSubmittedOn}` : "None"}`;
      if (waypointInfo.traits.find((t2) => t2.symbol === "MARKETPLACE") && GameState.displayedMarket !== GameState.selected.symbol) {
        GameState.displayedMarket = GameState.selected.symbol;
        trpc.getMarketInfo.query({
          waypoint: GameState.selected.symbol
        }).then((data) => {
          console.log("marketinfo", data);
          marketWindow.clearGoods();
          marketWindow.setGoods(data);
          marketWindow.container.displayObject.x = 400;
          marketWindow.container.displayObject.y = gameHeight - 300;
          marketWindow.container.displayObject.visible = true;
        });
      }
    }
  } else {
    currentRoute = "";
    const graphics = universeView.getChildByName("route");
    graphics.clear();
    homeGraphics.clear();
    GameState.displayedMarket = void 0;
    marketWindow.container.displayObject.visible = false;
    cruiseModeSelect.displayObject.visible = false;
    entityInfo.displayObject.bitmapText.text = `Entity Information`;
  }
  if (universeView.dirty) {
    universeCuller.cull(universeView.getVisibleBounds());
    universeView.dirty = false;
  }
  fps.text = `FPS: ${Math.round(app.ticker.FPS)}`;
});
/*! Bundled license information:

@trpc/client/dist/httpUtils-0cb58db4.mjs:
  (* istanbul ignore if -- @preserve *)

@trpc/client/dist/links/wsLink.mjs:
  (* istanbul ignore next -- @preserve *)

pixi-cull/dist/pixi-cull.es.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
